import{jsxs as e,jsx as t,Fragment as n}from"react/jsx-runtime";import r,{useContext as a,createContext as i,useRef as s,useState as o,useMemo as l,useEffect as c,Suspense as d,lazy as u,useCallback as h}from"react";import p,{DEFAULT_SUPPORTED_CHAIN_IDS as w,rpc as m,PrivyClientError as y,getWallet as g,updateWallet as f,generateAuthorizationSignature as v}from"@privy-io/js-sdk-core";import{v4 as A}from"uuid";import*as k from"jose";import{base64url as C}from"jose";import{u as T,a as _,g as b,i as S,b as E,c as I,d as P,e as W,f as U,h as N,j as O,P as R,M,k as x,l as F,m as L}from"./get-is-unified-wallet-gMDXpX6C.mjs";import D from"eventemitter3";import{E as j,P as z,t as q,p as H,H as V,u as B,L as K,g as $,s as G,a as Y,b as J,c as Q,i as Z,d as X,e as ee,f as te,h as ne,j as re,k as ae,R as ie,l as se,m as oe,n as le,M as ce,o as de,q as ue,S as he,r as pe,v as we,w as me,x as ye}from"./useActiveWallet-BeOB3HTh.mjs";import{u as ge,t as fe,g as ve,U as Ae}from"./useWallets-kObl6ZLS.mjs";import{P as ke,a as Ce,f as Te,b as _e,c as be,n as Se,d as Ee,u as Ie,e as Pe,g as We,I as Ue,h as Ne,i as Oe}from"./internal-context-e-Eni5bG.mjs";import{f as Re,u as Me,W as xe,i as Fe,a as Le,p as De,e as je,P as ze,b as qe,l as He}from"./prepareFundingModalData-BVTcQcmw.mjs";import{createCoinbaseWalletSDK as Ve}from"@coinbase/wallet-sdk";import{toViemTransactionSerializable as Be,STRING_TO_NUMBER_TXN_TYPE as Ke}from"@privy-io/ethereum";import{P as $e,C as Ge,a as Ye,H as Je,O as Qe,S as Ze,u as Xe,b as et,c as tt,D as nt,d as rt,g as at,V as it,R as st,e as ot,f as lt,h as ct,i as dt,j as ut,I as ht,k as pt,l as wt,m as mt,W as yt}from"./context-DRLoVlsO.mjs";import{createStore as gt}from"mipd";import{isMobile as ft,isIOS as vt,isAndroid as At,isSafari as kt}from"react-device-detect";import{toHex as Ct,isAddress as Tt,getAddress as _t,isHex as bt,hashAuthorization as St}from"viem/utils";import{trigger as Et}from"@privy-io/popup";import{u as It,p as Pt,a as Wt,b as Ut,f as Nt,c as Ot,d as Rt,e as Mt,o as xt,g as Ft,h as Lt,i as Dt,j as jt,k as zt,l as qt,m as Ht,n as Vt,q as Bt,r as Kt,s as $t,t as Gt,v as Yt,w as Jt,x as Qt,y as Zt,z as Xt,A as en,B as tn,C as nn,D as rn,E as an,F as sn,G as on,H as ln,I as cn,J as dn,K as un,L as hn,M as pn,N as wn,O as mn,P as yn,Q as gn,R as fn,S as vn,T as An,U as kn,V as Cn,W as Tn,X as _n,Y as bn,Z as Sn,_ as En,$ as In,a0 as Pn,a1 as Wn,a2 as Un,a3 as Nn,a4 as On}from"./paths-3HW55qZg.mjs";import{o as Rn,p as Mn,d as xn,r as Fn,b as Ln,s as Dn,a as jn,u as zn,c as qn,S as Hn,e as Vn,P as Bn,f as Kn}from"./usePrivy-BWtc2XF-.mjs";import{base64 as $n}from"@scure/base";import{styled as Gn,createGlobalStyle as Yn,css as Jn}from"styled-components";import{u as Qn,a as Zn,p as Xn,e as er,P as tr}from"./events-context-CI0iqAXA.mjs";import{create as nr}from"zustand";import{Transition as rr,Dialog as ar,TransitionChild as ir,DialogPanel as sr}from"@headlessui/react";import{EthereumProvider as or,OPTIONAL_METHODS as lr,OPTIONAL_EVENTS as cr}from"@walletconnect/ethereum-provider";import{constructURL as dr}from"@privy-io/urls";import{toHex as ur,zeroAddress as hr,getAddress as pr,createWalletClient as wr,http as mr,parseSignature as yr}from"viem";import{g as gr,a as fr}from"./getPublicClient-A9RSftUZ.mjs";import{ofetch as vr}from"ofetch";import Ar from"js-cookie";import{F as kr}from"./frame-CwE9r3cT.mjs";import{MfaAuthPasskeyVerify as Cr,MfaAuthPasskeyInit as Tr,MfaAuthTotpVerify as _r,MfaAuthPasskeyEnrollment as br,MfaAuthTotpUnenroll as Sr,MfaAuthTotpEnroll as Er,MfaAuthTotpInit as Ir}from"@privy-io/routes";import{selectPaymentRequirements as Pr,createPaymentHeader as Wr}from"x402/client";import{InvalidInputError as Ur}from"@privy-io/api-base";import{toAccount as Nr}from"viem/accounts";import{u as Or}from"./use-sign-with-user-signer-eEm9Olt_.mjs";import"./getEmbeddedConnectedWallet-CM6cDQCS.mjs";class Rr{static parse(e){try{return new Rr(e)}catch(e){return null}}static throwIfNotWellFormedJwt(e){return k.decodeJwt(e),e}get subject(){return this._decoded.sub}get expiration(){return this._decoded.exp}get issuer(){return this._decoded.iss}get audience(){return this._decoded.aud}isExpired(e=0){return Date.now()>=1e3*(this.expiration-e)}constructor(e){this.value=e,this._decoded=k.decodeJwt(e)}}class Mr extends Rr{static parse(e){try{return new Mr(e)}catch(e){return null}}get appId(){return this._decoded.aid?this._decoded.aid:this.audience}}const xr=({style:n,...r})=>/*#__PURE__*/e("svg",{viewBox:"0 0 1024 1024",fill:"none",xmlns:"http://www.w3.org/2000/svg",style:{height:"28px",width:"28px",...n},...r,children:[/*#__PURE__*/t("rect",{width:"1024",height:"1024",fill:"#0052FF",rx:100,ry:100}),/*#__PURE__*/t("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z",fill:"white"})]}),Fr="data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PScwIDAgMTAyNCAxMDI0JyBmaWxsPSdub25lJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHN0eWxlPSdoZWlnaHQ6MjhweDt3aWR0aDoyOHB4Jz48cmVjdCB3aWR0aD0nMTAyNCcgaGVpZ2h0PScxMDI0JyBmaWxsPScjMDA1MkZGJyByeD0nMTAwJyByeT0nMTAwJz48L3JlY3Q+PHBhdGggZmlsbC1ydWxlPSdldmVub2RkJyBjbGlwLXJ1bGU9J2V2ZW5vZGQnIGQ9J00xNTIgNTEyQzE1MiA3MTAuODIzIDMxMy4xNzcgODcyIDUxMiA4NzJDNzEwLjgyMyA4NzIgODcyIDcxMC44MjMgODcyIDUxMkM4NzIgMzEzLjE3NyA3MTAuODIzIDE1MiA1MTIgMTUyQzMxMy4xNzcgMTUyIDE1MiAzMTMuMTc3IDE1MiA1MTJaTTQyMCAzOTZDNDA2Ljc0NSAzOTYgMzk2IDQwNi43NDUgMzk2IDQyMFY2MDRDMzk2IDYxNy4yNTUgNDA2Ljc0NSA2MjggNDIwIDYyOEg2MDRDNjE3LjI1NSA2MjggNjI4IDYxNy4yNTUgNjI4IDYwNFY0MjBDNjI4IDQwNi43NDUgNjE3LjI1NSAzOTYgNjA0IDM5Nkg0MjBaJyBmaWxsPSd3aGl0ZSc+PC9wYXRoPjwvc3ZnPg==",Lr="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAALZJREFUaEPtmjEOhDAMBNc/O14GvOzys3CAKK6eAlmaVGl2Zc+kTOU685vkc9/bnD2prZK5/TZY24z9P+g4F5hNh7/GdoG37WlAA5CATwgCxHENYISwQAMQII5rACOEBRqAAHFcAxghLNAABIjjGsAIYYEGIEAc1wBGCAs0AAHiuAYwQligAQgQxzWAEcICDUCAOK4BjBAWaAACxHENYISwQAMQII6fBjr+VHkW3+u+tfyxMpJaDgYzYxb/ALZVAAAAAElFTkSuQmCC";let Dr,jr;class zr extends j{async initialize(){await this.importPromise,await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}disconnect(){this.proxyProvider.walletProvider.disconnect(),this.onDisconnect()}get walletBranding(){return{name:this.displayName,icon:Lr,id:"com.coinbase.wallet"}}async promptConnection(){try{await this.importPromise;let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new ke("Unable to retrieve accounts");this.connected=!0,await this.syncAccounts([e[0]])}catch(e){throw Re(e)}}constructor(e,t,n,r,a){super("base_account",e,t,n),this.connectorType="base_account",this.walletClientType="base_account",this.displayName="Base",this.setBaseAccountSdk=a,this.proxyProvider=new z(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.baseAccountConfig={...r,appChainIds:[t.id].concat(e.map((e=>e.id)))},Dr?(this.proxyProvider.setWalletProvider(Dr.getProvider()),this.setBaseAccountSdk(Dr)):this.importPromise=import("@base-org/account").then((({createBaseAccountSDK:e})=>{Dr=e(this.baseAccountConfig),this.proxyProvider.setWalletProvider(Dr.getProvider()),this.setBaseAccountSdk(Dr)})).catch(console.error)}}let qr=[1,11155111,137,10,8453,84532,42161,7777777,43114,56];class Hr extends j{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}disconnect(){this.proxyProvider.walletProvider.disconnect(),this.onDisconnect()}get walletBranding(){return{name:this.displayName,icon:Fr,id:"com.coinbase.wallet"}}async promptConnection(){try{let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new ke("Unable to retrieve accounts");this.connected=!0,await this.syncAccounts([e[0]])}catch(e){throw Re(e)}}updateConnectionPreference(e){this.coinbaseWalletConfig={...this.coinbaseWalletConfig,preference:{...this.coinbaseWalletConfig.preference,options:e}},this.walletClientType="smartWalletOnly"===e?"coinbase_smart_wallet":"coinbase_wallet",jr=Ve({...this.coinbaseWalletConfig}),this.proxyProvider.setWalletProvider(jr.getProvider())}constructor(e,t,n,r){if(super("coinbase_wallet",e,t,n),this.connectorType="coinbase_wallet",this.displayName="Coinbase Wallet",this.proxyProvider=new z(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.coinbaseWalletConfig={...r,appChainIds:[t.id].concat(e.map((e=>e.id)))},this.walletClientType="smartWalletOnly"===this.coinbaseWalletConfig.preference?.options?"coinbase_smart_wallet":"coinbase_wallet","coinbase_smart_wallet"===this.walletClientType&&(this.displayName="Coinbase Smart Wallet"),!jr){let e="eoaOnly"!==this.coinbaseWalletConfig.preference?.options?(this.coinbaseWalletConfig.appChainIds??[]).filter((e=>!qr.includes(e))):[];e.length>0&&!e.every((e=>w.has(e)))&&console.info(`The configured chains are not supported by Coinbase Smart Wallet: ${e.join(", ")}`),jr=Ve(this.coinbaseWalletConfig)}this.proxyProvider.setWalletProvider(jr.getProvider())}}const Vr=({...e})=>/*#__PURE__*/t("svg",{width:"15",height:"15",viewBox:"0 0 15 15",fill:"none",xmlns:"http://www.w3.org/2000/svg",...e,children:/*#__PURE__*/t("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M2.37126 11.0323C2.37126 12.696 3.90598 13.4421 5.40654 13.4468C8.91753 13.4468 12.8021 11.2897 12.7819 7.67984C12.7673 5.07728 10.3748 2.86167 7.54357 2.88296C4.8495 2.88296 2.21821 4.6411 2.21803 7.03628C2.21803 7.67951 2.58722 8.30178 3.55231 8.37184C2.74763 9.16826 2.37126 10.1225 2.37126 11.0323ZM7.55283 8.68012C8.11562 8.68012 8.57186 8.13217 8.57186 7.45624C8.57186 6.78032 8.11562 6.23237 7.55283 6.23237C6.99003 6.23237 6.53379 6.78032 6.53379 7.45624C6.53379 8.13217 6.99003 8.68012 7.55283 8.68012ZM10.4747 8.68012C11.0375 8.68012 11.4937 8.13217 11.4937 7.45625C11.4937 6.78032 11.0375 6.23237 10.4747 6.23237C9.91186 6.23237 9.45562 6.78032 9.45562 7.45625C9.45562 8.13217 9.91186 8.68012 10.4747 8.68012Z",fill:e.color||"var(--privy-color-foreground-3)"})});class Br extends j{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return await this.isConnected()?(await this.proxyProvider.request({method:"wallet_switchEthereumChain",params:[q(e?.chainId||"0x1")]}),this.getConnectedWallet()):null}get walletBranding(){return{name:"Privy Wallet",icon:Vr,id:"io.privy.wallet"}}disconnect(){this.connected=!1}async promptConnection(){}constructor({provider:e,chains:t,defaultChain:n,rpcConfig:r,imported:a,walletIndex:i}){super("privy",t,n,r),this.connectorType="embedded",this.proxyProvider=e,this.walletIndex=i,a&&(this.connectorType="embedded_imported"),this.subscribeListeners()}}async function Kr(){let e=Ws();return e?e.getAccessToken():Promise.resolve(Me.get($e)||Me.get(Ge)||null)}const $r=["eth_sign","eth_populateTransactionRequest","eth_signTransaction","personal_sign","eth_signTypedData_v4","csw_signUserOperation","secp256k1_sign"];function Gr(e){return e?{"privy-ui":"t"}:void 0}class Yr{async authenticate(){if(!this.api)throw new Ce("Auth flow has no API instance");if(!this.meta.email||!this.meta.emailCode)throw new Ce("Email and email code must be set prior to calling authenticate.");try{return await this.api.post(Pt,{email:this.meta.email,code:this.meta.emailCode,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw Te(e)}}async link(){if(!this.api)throw new Ce("Auth flow has no API instance");if(!this.meta.email||!this.meta.emailCode)throw new Ce("Email and email code must be set prior to calling authenticate.");try{return await this.api.post(Wt,{email:this.meta.email,code:this.meta.emailCode})}catch(e){throw Te(e)}}async sendCodeEmail({email:e,captchaToken:t,withPrivyUi:n}){if(!this.api)throw new Ce("Auth flow has no API instance");if(e&&(this.meta.email=e),t&&(this.meta.captchaToken=t),!this.meta.email)throw new Ce("Email must be set when initialzing authentication.");let r=Gr(n);try{return await this.api.post(Ut,{email:this.meta.email,token:this.meta.captchaToken},{headers:{...r}})}catch(e){throw Te(e)}}constructor({email:e,captchaToken:t,disableSignup:n}){this.meta={email:e,captchaToken:t,disableSignup:n??!1}}}class Jr extends Yr{async link(){if(!this.api)throw new Ce("Auth flow has no API instance");if(!this.meta.email||!this.meta.emailCode||!this.meta.oldAddress)throw new Ce("Email, email code, and an old email address must be set prior to calling update.");try{return await this.api.post(It,{oldAddress:this.meta.oldAddress,newAddress:this.meta.email,code:this.meta.emailCode})}catch(e){throw Te(e)}}constructor(e,t,n){super({email:t,captchaToken:n}),this.meta={email:t,captchaToken:n,oldAddress:e,disableSignup:!1}}}class Qr{execute(e){return null===this.promise&&(this.promise=(async()=>{try{return await this.fn(e)}finally{this.promise=null}})()),this.promise}constructor(e){this.promise=null,this.fn=e}}class Zr{get meta(){return this._meta}async authenticate(){if(!this.api)throw new Ce("Auth flow has no API instance");if(!this.meta.channelToken)throw new Ce("Auth flow must be initialized first");try{let e=await this.api.post(Nt,{channel_token:this.meta.channelToken,message:this.message,signature:this.signature,fid:this.fid,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"});if(!e)throw new Ce("No response from authentication");return e}catch(e){throw Te(e)}}async link(){if(!this.api)throw new Ce("Auth flow has no API instance");try{return await this.api.post(Ot,{channel_token:this.meta.channelToken,message:this.message,signature:this.signature,fid:this.fid})}catch(e){throw Te(e)}}async _startChannelOnce(){if(!this.api)throw new Ce("Auth flow has no API instance");let e=await this.api.post(Rt,{token:this.captchaToken});ft&&!vt&&e.connect_uri&&Rn(e.connect_uri,"_blank"),this._meta={...this._meta,connectUri:e.connect_uri,channelToken:e.channel_token}}async initializeFarcasterConnect(){if(!this.api)throw new Ce("Auth flow has no API instance");await this.startChannelOnce.execute()}async _pollForReady(){if(!this.api)throw new Ce("Auth flow has no API instance");if(!this.meta.channelToken)throw new Ce("Auth flow must be initialized first");let e=await this.api.get(Mt,{headers:{"farcaster-channel-token":this.meta.channelToken}});return"completed"===e.state&&(this.message=e.message,this.signature=e.signature,this.fid=e.fid,!0)}constructor(e,t=!1){this._meta={disableSignup:!1},this.captchaToken=e,this.startChannelOnce=new Qr(this._startChannelOnce.bind(this)),this.pollForReady=new Qr(this._pollForReady.bind(this)),this._meta.disableSignup=t}}function Xr(){return"undefined"!=typeof window&&"chrome-extension:"===window.location.protocol&&"chrome"in window}function ea(){if(!Xr())return;let e=window.chrome;return e?.runtime?.id}function ta(){if(!Xr())return!1;let e=window.chrome;return"function"==typeof e?.identity?.launchWebAuthFlow}async function na(e){return new Promise(((t,n)=>{ta()?window.chrome.identity.launchWebAuthFlow({url:e,interactive:!0},(async e=>{try{let n=function(){if(!Xr())return;let e=window.chrome;return e?.runtime?.lastError?.message}();if(n||!e){let e=`WebAuthFlow failed: ${n||"Response URI missing"}`;throw Error(e)}let r=new URL(e),a=ea();if(!a)throw Error("Invalid extension context");if("chrome-extension:"===r.protocol){if(r.hostname!==a)throw Error("Invalid responseUri origin")}else{if("https:"!==r.protocol)throw Error("Invalid responseUri protocol");{let e=r.hostname.split(".");if(3!==e.length||"chromiumapp"!==e[1]||"org"!==e[2]||e[0]!==a)throw Error("Invalid responseUri origin")}}let i=r.searchParams.get("privy_oauth_state"),s=r.searchParams.get("privy_oauth_code");if(!i||!s)throw Error("Invalid responseUri - missing required parameters");t({privyOAuthState:i,privyOAuthCode:s})}catch(e){n(e)}})):n(Error("Chrome identity API not available"))}))}function ra(e){return crypto.getRandomValues(new Uint8Array(e))}function aa(){return C.encode(ra(36))}function ia(){return aa()}async function sa(e,t="S256"){if("S256"!=t)return e;{let t=await async function(e){let t=(new TextEncoder).encode(e);return new Uint8Array(await crypto.subtle.digest("SHA-256",t))}(e);return C.encode(t)}}class oa{addCaptchaToken(e){this.meta.captchaToken=e}isActive(){return!!(this.meta.authorizationCode&&this.meta.stateCode&&this.meta.provider)}async authenticate(){if(!this.api)throw new Ce("Auth flow has no API instance");if(!this.meta.authorizationCode||!this.meta.stateCode)throw new Ce("[OAuth AuthFlow] Authorization and state codes code must be set prior to calling authenticate.");if("undefined"===this.meta.authorizationCode)throw new Ce("User denied confirmation during OAuth flow");let e=function(){let e=Me.get(Ye);if(!e)throw new Ce("Authentication error.");return e}();try{let t=await this.api.post(xt,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:e,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"});return Me.del(Ye),Me.del(Je),Me.del(Qe),t}catch(e){let t=Te(e);if(t.privyErrorCode)throw new Ce(t.message||"Invalid code during OAuth flow.",void 0,t.privyErrorCode);if("User denied confirmation during OAuth flow"===t.message)throw new Ce("Invalid code during oauth flow.",void 0,_e.OAUTH_USER_DENIED);throw new Ce("Invalid code during OAuth flow.",void 0,_e.UNKNOWN_AUTH_ERROR)}}async link(){if(!this.api)throw new Ce("Auth flow has no API instance");if(!this.meta.authorizationCode||!this.meta.stateCode)throw new Ce("[OAuth AuthFlow] Authorization and state codes code must be set prior to calling link.");if("undefined"===this.meta.authorizationCode)throw new Ce("User denied confirmation during OAuth flow");let e=Me.get(Ye);if(!e)throw new Ce("Authentication error.");try{let t=await this.api.post(Ft,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:e});return Me.del(Ye),t}catch(e){throw Te(e)}}async getAuthorizationUrl(){if(!this.api)throw new Ce("Auth flow has no API instance");if(!this.meta.provider)throw new Ce("Provider must be set when initializing OAuth authentication.");let e=aa();Me.put(Ye,e);let t=ia();Me.put(Ze,t);let n=await sa(e);this.meta.withPrivyUi||Me.put(Je,!0),this.meta.disableSignup?Me.put(Qe,!0):Me.del(Qe);let r=Gr(this.meta.withPrivyUi),a=window.location.href,i=function(){let e=ea();if(e)return`https://${e}.chromiumapp.org`}();i&&(a=i);try{return await this.api.post(Lt,{provider:this.meta.provider,redirect_to:this.meta.customOAuthRedirectUrl||a,token:this.meta.captchaToken,code_challenge:n,state_code:t},{headers:{...r}})}catch(e){throw Te(e)}}constructor(e){this.meta=e}}function la(){let e=new URLSearchParams(window.location.search),t=e.get("privy_oauth_code"),n=e.get("privy_oauth_state"),r=e.get("privy_oauth_provider");if(!t||!n||!r)return{inProgress:!1};let a=!1;try{a=!!window.opener.location.origin}catch{}return{inProgress:!0,authorizationCode:t,stateCode:n,provider:r,withPrivyUi:!Me.get(Je),popupFlow:null!==window.opener&&a,disableSignup:!!Me.get(Qe)}}function ca(){let e=new URL(window.location.href);e.searchParams.delete("privy_oauth_code"),e.searchParams.delete("privy_oauth_provider"),e.searchParams.delete("privy_oauth_state"),Me.del(Ze),window.history.replaceState({},"",e)}class da{async initRegisterFlow(e){if(!this.api)throw new Ce("Auth flow has no API instance");this.authenticateForRegistration=!0,this.meta.initRegisterResponse=await this.initRegisterOnce.execute(e)}async initAuthenticationFlow(e){if(!this.api)throw new Ce("Auth flow has no API instance");this.authenticateForRegistration=!1,this.meta.initAuthenticateResponse=await this.initAuthenticateOnce.execute(e)}async initLinkFlow(){if(!this.api)throw new Ce("Auth flow has no API instance");this.meta.initLinkResponse=await this.initLinkOnce.execute()}async register(){let e=await import("@simplewebauthn/browser");if(!this.api)throw new Ce("Auth flow has no API instance");if(!e.browserSupportsWebAuthn())throw new Ce("WebAuthn is not supported in this browser");this.meta.initRegisterResponse||(this.meta.initRegisterResponse=await this.initRegisterOnce.execute());try{let t=this.meta.initRegisterResponse.options,n=await e.startRegistration({optionsJSON:this._transformInitLinkOptionsToCamelCase(t)});return this.meta.setPasskeyAuthState?.({status:"submitting-response"}),await this.api.post(Dt,{relying_party:this.meta.initRegisterResponse.relying_party,authenticator_response:this._transformRegistrationResponseToSnakeCase(n)})}catch(e){if("NotAllowedError"===e.name)throw new Ce("Passkey request timed out or rejected by user.",void 0,_e.PASSKEY_NOT_ALLOWED);throw Te(e)}}async authenticate(){if(this.authenticateForRegistration)return this.register();let e=await import("@simplewebauthn/browser");if(!this.api)throw new Ce("Auth flow has no API instance");if(!e.browserSupportsWebAuthn())throw new Ce("WebAuthn is not supported in this browser");this.meta.initAuthenticateResponse||(this.meta.initAuthenticateResponse=await this.initAuthenticateOnce.execute());let t=this.meta.allowedCredentialsIds?.map((e=>({type:"public-key",id:e})))??this.meta.initAuthenticateResponse.options.allow_credentials;try{let n=await e.startAuthentication({optionsJSON:this._transformInitAuthenticateOptionsToCamelCase({...this.meta.initAuthenticateResponse.options,allow_credentials:t})});return this.meta.setPasskeyAuthState?.({status:"submitting-response"}),await this.api.post(jt,{relying_party:this.meta.initAuthenticateResponse.relying_party,challenge:this.meta.initAuthenticateResponse.options.challenge,authenticator_response:this._transformAuthenticationResponseToSnakeCase(n)})}catch(e){if("NotAllowedError"===e.name)throw new Ce("Passkey request timed out or rejected by user.",void 0,_e.PASSKEY_NOT_ALLOWED);throw Te(e)}}async link(){let e=await import("@simplewebauthn/browser");if(!this.api)throw new Ce("Auth flow has no API instance");if(!e.browserSupportsWebAuthn())throw new Ce("WebAuthn is not supported in this browser");this.meta.initLinkResponse||(this.meta.initLinkResponse=await this.initLinkOnce.execute());try{let t=this.meta.initLinkResponse.options,n=await e.startRegistration({optionsJSON:this._transformInitLinkOptionsToCamelCase(t)});return this.meta.setPasskeyAuthState?.({status:"submitting-response"}),await this.api.post(zt,{relying_party:this.meta.initLinkResponse.relying_party,authenticator_response:this._transformRegistrationResponseToSnakeCase(n)})}catch(e){if("NotAllowedError"===e.name)throw new Ce("Passkey request timed out or rejected by user.",void 0,_e.PASSKEY_NOT_ALLOWED);throw Te(e)}}async _initRegisterOnce(e){if(!this.api)throw new Ce("Auth flow has no API instance");let t=Gr(e);return await this.api.post(qt,{token:this.meta.captchaToken},{headers:{...t}})}async _initAuthenticateOnce(e){if(!this.api)throw new Ce("Auth flow has no API instance");let t=Gr(e);return await this.api.post(Ht,{token:this.meta.captchaToken},{headers:{...t}})}async _initLinkOnce(){if(!this.api)throw new Ce("Auth flow has no API instance");return await this.api.post(Vt,{})}_transformInitLinkOptionsToCamelCase(e){return{rp:e.rp,user:{id:e.user.id,name:e.user.name,displayName:e.user.display_name},challenge:e.challenge,pubKeyCredParams:e.pub_key_cred_params.map((e=>({type:e.type,alg:e.alg}))),timeout:e.timeout,excludeCredentials:e.exclude_credentials?.map((e=>({id:e.id,type:e.type,transports:e.transports}))),authenticatorSelection:{authenticatorAttachment:e.authenticator_selection?.authenticator_attachment,requireResidentKey:e.authenticator_selection?.require_resident_key,residentKey:e.authenticator_selection?.resident_key,userVerification:e.authenticator_selection?.user_verification},attestation:e.attestation,extensions:{appid:e.extensions?.app_id,credProps:e.extensions?.cred_props?.rk,hmacCreateSecret:e.extensions?.hmac_create_secret},hints:this.meta.hints}}_transformRegistrationResponseToSnakeCase(e){return{id:e.id,raw_id:e.rawId,response:{client_data_json:e.response.clientDataJSON,attestation_object:e.response.attestationObject,authenticator_data:e.response.authenticatorData},authenticator_attachment:e.authenticatorAttachment,client_extension_results:{app_id:e.clientExtensionResults.appid,cred_props:e.clientExtensionResults.credProps,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret},type:e.type}}_transformInitAuthenticateOptionsToCamelCase(e){return{rpId:e.rp_id,challenge:e.challenge,allowCredentials:e.allow_credentials?.map((e=>({id:e.id,type:e.type,transports:e.transports})))||[],timeout:e.timeout,extensions:{appid:e.extensions?.app_id,credProps:e.extensions?.cred_props,hmacCreateSecret:e.extensions?.hmac_create_secret},userVerification:e.user_verification}}_transformAuthenticationResponseToSnakeCase(e){return{id:e.id,raw_id:e.rawId,response:{client_data_json:e.response.clientDataJSON,authenticator_data:e.response.authenticatorData,signature:e.response.signature,user_handle:e.response.userHandle},authenticator_attachment:e.authenticatorAttachment,client_extension_results:{app_id:e.clientExtensionResults.appid,cred_props:e.clientExtensionResults.credProps,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret},type:e.type}}constructor({captchaToken:e,setPasskeyAuthState:t,hints:n}){this.authenticateForRegistration=!1,this.initRegisterOnce=new Qr(this._initRegisterOnce.bind(this)),this.initAuthenticateOnce=new Qr(this._initAuthenticateOnce.bind(this)),this.initLinkOnce=new Qr(this._initLinkOnce.bind(this)),this.meta={captchaToken:e,setPasskeyAuthState:t,hints:n}}}const ua=({address:e,chainId:t,nonce:n})=>`${window.location.host} wants you to sign in with your Ethereum account:\n${e}\n\nBy signing, you are proving you own this wallet and logging in. This does not initiate a transaction or cost any fees.\n\nURI: ${window.location.origin}\nVersion: 1\nChain ID: ${t}\nNonce: ${n}\nIssued At: ${(new Date).toISOString()}\nResources:\n- https://privy.io`;class ha{get meta(){return{connectorType:this.wallet?.connectorType,walletClientType:this.wallet?.walletClientType,chainId:this.wallet?.chainId,address:this.wallet?.address,disableSignup:this._meta.disableSignup}}async authenticate(){if(!this.client)throw new Ce("SiweFlow has no client instance");try{if(this.preparedMessage&&this.signature)return await this.client.authenticateWithSiweInternal({message:this.preparedMessage,signature:this.signature,chainId:this.wallet?.chainId,walletClientType:this.walletClientType??this.wallet?.walletClientType,connectorType:this.connectorType??this.wallet?.connectorType,mode:this._meta.disableSignup?"no-signup":"login-or-sign-up"});if(!this.wallet)throw new Ce("SiweFlow has no wallet instance");let{message:e,signature:t}=await this.sign();return await this.client.authenticateWithSiweInternal({message:e,signature:t,chainId:this.wallet.chainId,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw Te(e)}}async link(){if(!this.client)throw new Ce("SiweFlow has no client instance");try{if(!this.wallet)throw new Ce("SiweFlow has no wallet instance");let{message:e,signature:t}=await this.sign();return await this.client.linkWithSiweInternal({message:e,signature:t,chainId:this.wallet.chainId,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType})}catch(e){throw Te(e)}}async sign(){if(!this.client)throw new Ce("SiweFlow has no client instance");if(await this.buildMessage(),!this.preparedMessage)throw new Ce("Could not prepare SIWE message");if(!this.wallet)throw new Ce("SiweFlow has no wallet instance");let e=await this.wallet.sign(this.preparedMessage);return{message:this.preparedMessage,signature:e}}async _getNonceOnce(){if(!this.client)throw new Ce("SiweFlow has no client instance");if(!this.wallet)throw new Ce("UI SiweFlow has no wallet instance");return await this.client.generateSiweNonce({address:this.wallet.address,captchaToken:this.captchaToken})}async buildMessage(){if(!this.client)throw new Ce("SiweFlow has no client instance");if(!this.wallet)throw new Ce("SiweFlow has no wallet instance");let e=this.wallet.address,t=this.wallet.chainId.replace("eip155:","");return this.nonce||(this.nonce=await this.getNonceOnce.execute()),this.preparedMessage=ua({address:e,chainId:t,nonce:this.nonce}),this.preparedMessage}constructor(e,t,n,r=!1,a){this._meta={disableSignup:!1},this.getNonceOnce=new Qr(this._getNonceOnce.bind(this)),this.wallet=t,this.captchaToken=n,this.client=e,this._meta.disableSignup=r,this.preparedMessage=a?.message,this.signature=a?.signature,this.walletClientType=a?.walletClientType,this.connectorType=a?.connectorType}}class pa{get meta(){return{connectorType:this.wallet.connectorType,walletClientType:this.wallet.walletClientType,disableSignup:this._meta.disableSignup,messageType:this._meta.messageType,address:this.wallet?.address}}set messageType(e){this._meta.messageType=e}async authenticate(){if(!this.client)throw new Ce("SiwsFlow has no client instance");try{let{message:e,signature:t}=await this.sign();return await this.client.authenticateWithSiwsInternal({message:e,signature:t,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up",messageType:this.meta.messageType})}catch(e){throw Te(e)}}async link(){if(!this.client)throw new Ce("SiwsFlow has no client instance");try{let{message:e,signature:t}=await this.sign();return await this.client.linkWithSiwsInternal({message:e,signature:t,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType,messageType:this.meta.messageType})}catch(e){throw Te(e)}}async sign(){let e,t;if(!this.client)throw new Ce("SiwsFlow has no client instance");await this.buildMessage();let n="transaction"===this.meta.messageType;if(!this.preparedMessage)throw new Ce("Could not prepare SIWS message");if(!n&&!this.wallet.provider.signMessage||n&&!this.wallet.provider.signTransaction)throw new Ce("Wallet does not support the necessary signing methods");if(n&&this._plugin){let n=await this.wallet.provider.signTransaction({transaction:$n.decode(this.preparedMessage)});e=$n.encode(n.signedTransaction),t=this._plugin.getSignatureFromTransaction(n.signedTransaction,this.wallet.address)}else{e=this.preparedMessage;let n=await this.wallet.provider.signMessage({message:(new TextEncoder).encode(this.preparedMessage)});t=$n.encode(n.signature)}return{message:e,signature:t}}async _getNonceOnce(){if(!this.client)throw new Ce("SiwsFlow has no client instance");return await this.client.generateSiwsNonce({address:this.wallet.address,captchaToken:this.captchaToken})}async buildMessage(){if(!this.client)throw new Ce("SiwsFlow has no client instance");let e=this.wallet.address;return this.nonce||(this.nonce=await this.getNonceOnce.execute()),"transaction"===this.meta.messageType&&this._plugin?this.preparedMessage=this._plugin.createSiwsMemoTransaction({address:e,nonce:this.nonce}):this.preparedMessage=Mn({address:e,nonce:this.nonce}),this.preparedMessage}constructor(e,t,n,r=!1,a="plain",i){this._meta={disableSignup:!1,messageType:"plain"},this.getNonceOnce=new Qr(this._getNonceOnce.bind(this)),this.wallet=e,this.captchaToken=n,this.client=t,this._meta.disableSignup=r,this._meta.messageType=a,this._plugin=i}}class wa{async authenticate(){if(!this.api)throw new Ce("Auth flow has no API instance");if(!this.meta.phoneNumber||!this.meta.smsCode)throw new Ce("phone number and sms code must be set prior to calling authenticate.");try{return await this.api.post(Bt,{phoneNumber:this.meta.phoneNumber,code:this.meta.smsCode,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw Te(e)}}async link(){if(!this.api)throw new Ce("Auth flow has no API instance");if(!this.meta.phoneNumber||!this.meta.smsCode)throw new Ce("phone number and sms code must be set prior to calling authenticate.");try{return await this.api.post(Kt,{phoneNumber:this.meta.phoneNumber,code:this.meta.smsCode})}catch(e){throw Te(e)}}async sendSmsCode({phoneNumber:e,captchaToken:t,withPrivyUi:n}){if(!this.api)throw new Ce("Auth flow has no API instance");if(e&&(this.meta.phoneNumber=e),t&&(this.meta.captchaToken=t),!this.meta.phoneNumber)throw new Ce("phone nNumber must be set when initialzing authentication.");let r=Gr(n);try{return await this.api.post($t,{phoneNumber:this.meta.phoneNumber,token:this.meta.captchaToken},{headers:{...r}})}catch(e){throw Te(e)}}constructor({phoneNumber:e,captchaToken:t,disableSignup:n}){this.meta={phoneNumber:e,captchaToken:t,disableSignup:n??!1}}}class ma extends wa{async link(){if(!this.api)throw new Ce("Auth flow has no API instance");if(!this.meta.phoneNumber||!this.meta.smsCode||!this.meta.oldPhoneNumber)throw new Ce("Phone number, sms code, and an old phone number must be set prior to calling update.");try{return await this.api.post(Gt,{old_phone_number:this.meta.oldPhoneNumber,new_phone_number:this.meta.phoneNumber,code:this.meta.smsCode})}catch(e){throw Te(e)}}constructor(e,t,n){super({phoneNumber:t,captchaToken:n}),this.meta={phoneNumber:t,captchaToken:n,oldPhoneNumber:e,disableSignup:!1}}}const ya=/*#__PURE__*/i({enabled:!1,siteKey:"",provider:void 0,appId:void 0,token:void 0,error:void 0,status:"disabled",setToken:Se,setError:Se,setExecuting:Se,waitForResult:()=>Promise.resolve(""),ref:{current:null},remove:Ee,reset:Se,execute:Se});class ga extends be{constructor(e,t,n){super(e||"Captcha failed"),this.type="Captcha",t instanceof Error&&(this.cause=t),this.privyErrorCode=n}}const fa=({children:e,appId:n,captchaSiteKey:r,enabledCaptchaProvider:a})=>{let i=s(null),c=s(null),[d,u]=o(),[h,p]=o(),[w,m]=o(!1),y=l((()=>a?w||d||h?!w||d||h?d&&!h?{status:"success",token:d}:h?{status:"error",error:h}:{status:"ready"}:{status:"loading"}:{status:"ready"}:{status:"disabled"}),[a,d,h,w]),g=l((()=>a?"turnstile"===a?{remove:()=>{i.current?.remove(),m(!1),p(void 0),u(void 0)},reset:()=>{i.current?.reset(),m(!1),p(void 0),u(void 0)},execute:()=>{m(!0),i.current?.execute()},waitForResult:async()=>{try{return await H((()=>i.current?.getResponse()),{interval:200,timeout:2e4})}catch(e){throw new ga("Captcha failed",null,_e.CAPTCHA_TIMEOUT)}}}:{remove:()=>{c.current?.removeCaptcha(),m(!1),p(void 0),u(void 0)},reset:()=>{c.current?.resetCaptcha(),m(!1),p(void 0),u(void 0)},execute:()=>{m(!0),c.current?.execute()},waitForResult:async()=>{try{return await H((()=>c.current?.getResponse()),{interval:200,timeout:2e4})}catch(e){throw new ga("Captcha failed",null,_e.CAPTCHA_TIMEOUT)}}}:null),[a]),f=l((()=>{if(!a||!g)return{...y,enabled:!1,siteKey:"",appId:n,setToken:Se,setError:Se,setExecuting:Se,waitForResult:()=>Promise.resolve(void 0),remove:Ee,reset:Se,execute:Se,provider:void 0,ref:{current:null}};let e={...y,enabled:!0,appId:n,setToken:u,setError:p,setExecuting:m};return"turnstile"===a?{...e,provider:"turnstile",ref:i,siteKey:r.split("t:")[1]??"",...g}:{...e,provider:"hcaptcha",ref:c,siteKey:r.split("h:")[1]??"",...g}}),[y,a,g,n,r]);/*#__PURE__*/return t(ya.Provider,{value:f,children:e})},va=()=>a(ya);class Aa{async authenticate(){if(!this.api)throw new Ce("Auth flow has no API instance");try{return await this.api.post(Yt,{captcha_token:this.meta.captchaToken,telegram_auth_result:this.meta.telegramAuthResult,telegram_web_app_data:this.meta.telegramWebAppData,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw Te(e)}}async link(){if(!this.api)throw new Ce("Auth flow has no API instance");try{return await this.api.post(Jt,{telegram_auth_result:this.meta.telegramAuthResult,telegram_web_app_data:this.meta.telegramWebAppData})}catch(e){throw Te(e)}}constructor(e,t=!1){this.meta={disableSignup:!1},this.meta={captchaToken:e,disableSignup:!1},this.meta.disableSignup=t}}function ka(e){let t={detail:"",retryable:!1};return e?.privyErrorCode===_e.LINKED_TO_ANOTHER_USER&&(t.detail="This account has already been linked to another user."),e?.privyErrorCode===_e.DISALLOWED_LOGIN_METHOD&&(t.detail="Login with Telegram not allowed."),e?.privyErrorCode===_e.INVALID_DATA&&(t.retryable=!0,t.detail="Something went wrong. Try again."),e?.privyErrorCode===_e.CANNOT_LINK_MORE_OF_TYPE&&(t.retryable=!0,t.detail="Something went wrong. Try again."),e?.privyErrorCode===_e.INVALID_CREDENTIALS&&(t.retryable=!0,t.detail="Something went wrong. Try again."),e?.privyErrorCode===_e.TOO_MANY_REQUESTS&&(t.detail="Too many requests. Please wait before trying again."),e?.privyErrorCode===_e.TOO_MANY_REQUESTS&&e.message.includes("rate limit")&&(t.detail="Request limit reached for Telegram. Please wait a moment and try again."),e instanceof ga&&(t.retryable=!0,t.detail="Something went wrong. Try again."),t}function Ca(e){return Object.fromEntries(decodeURIComponent(e).split("&").map((e=>e.split("=").map(decodeURIComponent))))}function Ta(){let e=new URL(window.location.href);e.searchParams.delete("id"),e.searchParams.delete("hash"),e.searchParams.delete("auth_date"),e.searchParams.delete("first_name"),e.searchParams.delete("last_name"),e.searchParams.delete("username"),e.searchParams.delete("photo_url"),e.hash="",window.history.replaceState({},"",e)}let _a=/*#__PURE__*/u((()=>import("./TurnstileWrapper-Co-t5mTh.mjs"))),ba=/*#__PURE__*/u((()=>import("./HCaptchaWrapper-Dl2Jt_Df.mjs")));const Sa=n=>{let r=va();return c((()=>r.remove),[r.remove]),r.enabled&&r.provider?/*#__PURE__*/t(d,{fallback:null,children:/*#__PURE__*/e("div",{className:"hidden h-0 w-0",children:["turnstile"===r.provider&&/*#__PURE__*/t(_a,{...n,captchaContext:r}),"hcaptcha"===r.provider&&/*#__PURE__*/t(ba,{...n,captchaContext:r})]})}):null};var Ea=/*#__PURE__*/Object.freeze({__proto__:null,AccountNotFoundScreen:()=>import("./AccountNotFoundScreen-BzbvtCmu.mjs"),AffirmativeConsentScreen:()=>import("./AffirmativeConsentScreen-CrZKQjas.mjs"),AllowlistRejectionScreen:()=>import("./AllowlistRejectionScreen-DhhfJ6ai.mjs"),AuthenticateWithWalletScreen:()=>import("./AuthenticateWithWalletScreen-BN0s1mtv.mjs"),AwaitingEvmToSolBridgingScreen:()=>import("./AwaitingEvmToSolBridgingScreen-C7mp2-Hy.mjs"),AwaitingExternalEthereumTransferScreen:()=>import("./AwaitingExternalEthereumTransferScreen-EqM4Kcsu.mjs"),AwaitingPasswordlessCodeScreen:()=>import("./AwaitingPasswordlessCodeScreen-NAVmxM9-.mjs"),AwaitingSolToEvmBridgingScreen:()=>import("./AwaitingSolToEvmBridgingScreen-dC9b-wlg.mjs"),CaptchaScreen:()=>import("./CaptchaScreen-CTRyyYc9.mjs"),CoinbaseOnrampStatusScreen:()=>import("./CoinbaseOnrampStatusScreen-BNmvm8Bl.mjs"),ConnectLedgerScreen:()=>import("./ConnectLedgerScreen-BEhSz1FM.mjs"),ConnectOnlyLandingScreen:()=>import("./ConnectOnlyLandingScreen-ZnI9ReZJ.mjs"),ConnectOnlyStatusScreen:()=>import("./ConnectOnlyStatusScreen-1oCuFsd6.mjs"),ConnectOrCreateScreen:()=>import("./ConnectOrCreateScreen-BOO4iaC6.mjs"),ConnectionStatusScreen:()=>import("./ConnectionStatusScreen-CZNBQeOQ.mjs"),CrossAppAuthScreen:()=>import("./CrossAppAuthScreen-Bno8NQSa.mjs"),DelegatedActionsConsentScreen:()=>import("./DelegatedActionsConsentScreen-B0AwZEKc.mjs"),DelegatedActionsRevokeScreen:()=>import("./DelegatedActionsRevokeScreen-D0mAKxDs.mjs"),EmbeddedWalletConnectingScreen:()=>import("./EmbeddedWalletConnectingScreen-9ADobSle.mjs"),EmbeddedWalletCreatedScreen:()=>import("./EmbeddedWalletCreatedScreen-B7TnCst_.mjs"),EmbeddedWalletKeyExportScreen:()=>import("./EmbeddedWalletKeyExportScreen-Cmp2CUOa.mjs"),EmbeddedWalletOnAccountCreateScreen:()=>import("./EmbeddedWalletOnAccountCreateScreen-vxaCVWy1.mjs"),EmbeddedWalletPasswordCreateScreen:()=>import("./RecoveryPasswordCreateScreen-jWT25C0X.mjs"),EmbeddedWalletPasswordUpdateScreen:()=>import("./EmbeddedWalletPasswordUpdateScreen-C4dNnXVI.mjs"),EmbeddedWalletPasswordUpdateSplashScreen:()=>import("./EmbeddedWalletPasswordUpdateSplashScreen-BPTp0nwT.mjs"),ErrorScreen:()=>import("./ErrorScreen-Yi-Rhs0v.mjs"),FarcasterConnectStatusScreen:()=>import("./FarcasterConnectStatusScreen-BfoDjDwg.mjs"),FarcasterSignerStatusScreen:()=>import("./FarcasterSignerStatusScreen-CsSFmDry.mjs"),FundSolWalletWithExternalSolanaWallet:()=>import("./FundSolWalletWithExternalSolanaWallet-BIk-6GIl.mjs"),FundingAmountEditScreen:()=>import("./FundingEditAmountScreen-CzbuYpdw.mjs"),FundingMethodSelectionScreen:()=>import("./FundingMethodSelectionScreen-DdZxdcVe.mjs"),InAppBrowserLoginNotPossible:()=>import("./InAppBrowserLoginNotPossible-COUNBN1W.mjs"),InstallWalletScreen:()=>import("./InstallWalletScreen-BjprJkty.mjs"),LandingScreen:()=>import("./LandingScreen-Dp4m_c2X.mjs"),LinkConflictScreen:()=>import("./LinkConflictScreen-DMHPhlV7.mjs"),LinkEmailScreen:()=>import("./LinkEmailScreen-D7VTyZrH.mjs"),LinkPasskeyScreen:()=>import("./LinkPasskeyScreen-B5LWH116.mjs"),LinkPhoneScreen:()=>import("./LinkPhoneScreen-DdRe154C.mjs"),LoginFailedScreen:()=>import("./LoginFailedScreen-CZnzwKpB.mjs"),ManualTransferScreen:()=>import("./ManualTransferScreen-Bn2qhDAI.mjs"),MfaAuthEnrollmentFlowScreen:()=>import("./MfaAuthEnrollmentFlowScreen-CWMULcQb.mjs"),MfaAuthVerifyFlowScreen:()=>import("./MfaAuthVerifyFlowScreen-B3Hw1YN-.mjs"),MfaEnrollmentFlowScreen:()=>import("./MfaEnrollmentFlowScreen-DcnqGJ3O.mjs"),MoonpayStatusScreen:()=>import("./MoonpayStatusScreen-lYMS5etL.mjs"),OAuthStatusScreen:()=>import("./OAuthStatusScreen-DEtT_t2P.mjs"),PasskeySelectSignupOrLogin:()=>import("./PasskeySelectSignupOrLogin-DgH-G2yO.mjs"),PasskeyStatusScreen:()=>import("./PasskeyStatusScreen-BOac_MoC.mjs"),PasswordRecoveryScreen:()=>import("./PasswordRecoveryScreen-CT1bj8Gb.mjs"),RecoveryOAuthScreen:()=>import("./RecoveryOAuthStatusScreen-Ce6qiP-3.mjs"),RecoverySelectionScreen:()=>import("./RecoverySelectionScreen-_u02vomS.mjs"),SendTransactionScreen:()=>import("./index-DNmMGazz.mjs"),SetAutomaticRecoveryScreen:()=>import("./SetAutomaticRecoveryScreen-CUheSZ7h.mjs"),SignRequestScreen:()=>import("./SignRequestScreen-BNC2mYtk.mjs"),StandardSignAndSendTransactionScreen:()=>import("./StandardSignAndSendTransactionScreen-Ckxfv32q.mjs"),TelegramAuthScreen:()=>import("./TelegramAuthScreen-xobB3RHK.mjs"),TransferFromWalletScreen:()=>import("./TransferFromWalletScreen-CLqyv8Ra.mjs"),UpdateEmailScreen:()=>import("./UpdateEmailScreen-BVzkFXeI.mjs"),UpdatePhoneScreen:()=>import("./UpdatePhoneScreen-DZ_resri.mjs"),UserLimitReachedScreen:()=>import("./UserLimitReachedScreen-CTmSitf0.mjs"),WalletInterstitialScreen:()=>import("./WalletInterstitialScreen-tDCVxTFi.mjs")});function Ia(e){Qn("configureMfa",e)}const Pa=nr((()=>({inProgressMfaFlow:void 0})));const Wa=/*#__PURE__*/Yn([":root{","};"],(e=>Ua(e.palette)));const Ua=e=>
/*#__PURE__*/Jn(["",""],Object.entries(function(e){return{"--privy-color-background":e.background,"--privy-color-background-2":e.background2,"--privy-color-background-3":e.background3,"--privy-color-foreground":e.foreground,"--privy-color-foreground-2":e.foreground2,"--privy-color-foreground-3":e.foreground3,"--privy-color-foreground-4":e.foreground4,"--privy-color-foreground-accent":e.foregroundAccent,"--privy-color-accent":e.accent,"--privy-color-accent-light":e.accentLight,"--privy-color-accent-hover":e.accentHover,"--privy-color-accent-dark":e.accentDark,"--privy-color-accent-darkest":e.accentDarkest,"--privy-color-success":e.success,"--privy-color-success-dark":e.successDark,"--privy-color-success-light":e.successLight,"--privy-color-success-bg":e.successBg,"--privy-color-error":e.error,"--privy-color-error-light":e.errorLight,"--privy-color-error-bg":e.errorBg,"--privy-color-error-bg-hover":e.errorBgHover,"--privy-color-warn":e.warn,"--privy-color-warn-light":e.warnLight,"--privy-color-warn-bg":e.warnBg,"--privy-color-warning-dark":e.warningDark,"--privy-color-error-dark":e.errorDark,"--privy-color-info-bg":e.infoBg,"--privy-color-info-bg-hover":e.infoBgHover,"--privy-color-border-default":e.borderDefault,"--privy-color-border-hover":e.borderHover,"--privy-color-border-focus":e.borderFocus,"--privy-color-border-error":e.borderError,"--privy-color-border-success":e.borderSuccess,"--privy-color-border-warning":e.borderWarning,"--privy-color-border-info":e.borderInfo,"--privy-color-border-interactive":e.borderInteractive,"--privy-color-border-interactive-hover":e.borderInteractiveHover,"--privy-color-background-hover":e.backgroundHover,"--privy-color-background-clicked":e.backgroundClicked,"--privy-color-background-disabled":e.backgroundDisabled,"--privy-color-background-interactive":e.backgroundInteractive,"--privy-color-background-interactive-hover":e.backgroundInteractiveHover,"--privy-color-background-interactive-clicked":e.backgroundInteractiveClicked,"--privy-color-background-interactive-disabled":e.backgroundInteractiveDisabled,"--privy-color-foreground-hover":e.foregroundHover,"--privy-color-foreground-clicked":e.foregroundClicked,"--privy-color-foreground-disabled":e.foregroundDisabled,"--privy-color-foreground-interactive":e.foregroundInteractive,"--privy-color-foreground-interactive-hover":e.foregroundInteractiveHover,"--privy-link-navigation-color":e.linkNavigationColor,"--privy-link-navigation-decoration":e.linkNavigationDecoration,"--privy-accent-has-good-contrast":e.accentHasGoodContrast,"--privy-color-icon-default":e.iconDefault,"--privy-color-icon-muted":e.iconMuted,"--privy-color-icon-subtle":e.iconSubtle,"--privy-color-icon-inverse":e.iconInverse,"--privy-color-icon-success":e.iconSuccess,"--privy-color-icon-warning":e.iconWarning,"--privy-color-icon-error":e.iconError,"--privy-color-icon-interactive":e.iconInteractive,"--privy-color-icon-default-hover":e.iconDefaultHover,"--privy-color-icon-muted-hover":e.iconMutedHover,"--privy-color-icon-subtle-hover":e.iconSubtleHover,"--privy-color-icon-default-clicked":e.iconDefaultClicked,"--privy-color-icon-muted-clicked":e.iconMutedClicked,"--privy-color-icon-subtle-clicked":e.iconSubtleClicked,"--privy-color-icon-default-disabled":e.iconDefaultDisabled,"--privy-color-icon-muted-disabled":e.iconMutedDisabled,"--privy-color-icon-subtle-disabled":e.iconSubtleDisabled,"--privy-color-icon-error-hover":e.iconErrorHover,"--privy-color-icon-interactive-hover":e.iconInteractiveHover,"--privy-color-icon-error-clicked":e.iconErrorClicked,"--privy-color-icon-interactive-clicked":e.iconInteractiveClicked,"--privy-color-icon-muted-disabled-alt":e.iconMutedDisabledAlt,"--privy-color-icon-subtle-disabled-alt":e.iconSubtleDisabledAlt,"--privy-border-radius-xs":"6px","--privy-border-radius-sm":"8px","--privy-border-radius-md":"12px","--privy-border-radius-mdlg":"16px","--privy-border-radius-lg":"24px","--privy-border-radius-full":"9999px","--privy-height-modal-full":"620px","--privy-height-modal-compact":"480px"}}(e)).map((([e,t])=>`${e}: ${t};`)).join("\n")),Na=/*#__PURE__*/Gn.div.withConfig({displayName:"StylesWrapper",componentId:"sc-188229e4-0"})([""," color:var(--privy-color-foreground-2);h3{font-size:16px;line-height:24px;font-weight:500;color:var(--privy-color-foreground-2);}h4{font-size:14px;line-height:20px;font-weight:500;color:var(--privy-color-foreground);}p{font-size:13px;line-height:20px;color:var(--privy-color-foreground-2);}button:focus,input:focus,optgroup:focus,select:focus,textarea:focus{outline:none;border-color:var(--privy-color-accent-light);box-shadow:0 0 0 3px var(--privy-color-border-focus);}.mobile-only{@media (min-width:441px){display:none;}}@keyframes fadein{0%{opacity:0;}100%{opacity:1;}}"],"\n  *,\n  ::before,\n  ::after {\n    box-sizing: border-box;\n    border-width: 0;\n    border-style: solid;\n  }\n\n  line-height: 1.15;\n  -webkit-text-size-adjust: 100%;\n  -moz-tab-size: 4;\n  tab-size: 4;\n  font-feature-settings: normal;\n\n  margin: 0;\n  font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif,\n    'Apple Color Emoji', 'Segoe UI Emoji';\n\n  hr {\n    height: 0;\n    color: inherit;\n    border-top-width: 1px;\n  }\n\n  abbr:where([title]) {\n    text-decoration: underline dotted;\n  }\n\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6 {\n    font-size: inherit;\n    font-weight: inherit;\n    font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif,\n    'Apple Color Emoji', 'Segoe UI Emoji';\n    display: inline;\n  }\n\n  a {\n    color: inherit;\n    text-decoration: inherit;\n  }\n\n  b,\n  strong {\n    font-weight: bolder;\n  }\n\n  code,\n  kbd,\n  samp,\n  pre {\n    font-family: ui-monospace, SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;\n    font-size: 1em;\n  }\n\n  small {\n    font-size: 80%;\n  }\n\n  sub,\n  sup {\n    font-size: 75%;\n    line-height: 0;\n    position: relative;\n    vertical-align: baseline;\n  }\n\n  sub {\n    bottom: -0.25em;\n  }\n\n  sup {\n    top: -0.5em;\n  }\n\n  table {\n    text-indent: 0;\n    border-color: inherit;\n    border-collapse: collapse;\n  }\n\n  button,\n  input,\n  optgroup,\n  select,\n  textarea {\n    font-family: inherit;\n    font-size: 100%;\n    font-weight: inherit;\n    line-height: inherit;\n    color: inherit;\n    margin: 0;\n    padding: 0;\n  }\n\n  button,\n  select {\n    text-transform: none;\n  }\n\n  button,\n  [type='button'],\n  [type='reset'],\n  [type='submit'] {\n    -webkit-appearance: button;\n    background-color: transparent;\n    background-image: none;\n  }\n\n  ::-moz-focus-inner {\n    border-style: none;\n    padding: 0;\n  }\n\n  :-moz-focusring {\n    outline: 1px dotted ButtonText;\n  }\n\n  :-moz-ui-invalid {\n    box-shadow: none;\n  }\n\n  legend {\n    padding: 0;\n  }\n\n  progress {\n    vertical-align: baseline;\n  }\n\n  ::-webkit-inner-spin-button,\n  ::-webkit-outer-spin-button {\n    height: auto;\n  }\n\n  [type='search'] {\n    -webkit-appearance: textfield;\n    outline-offset: -2px;\n  }\n\n  ::-webkit-search-decoration {\n    -webkit-appearance: none;\n  }\n\n  ::-webkit-file-upload-button {\n    -webkit-appearance: button;\n    font: inherit;\n  }\n\n  summary {\n    display: list-item;\n  }\n\n  blockquote,\n  dl,\n  dd,\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6,\n  hr,\n  figure,\n  p,\n  pre {\n    margin: 0;\n  }\n\n  fieldset {\n    margin: 0;\n    padding: 0;\n  }\n\n  legend {\n    padding: 0;\n  }\n\n  ol,\n  ul,\n  menu {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n  }\n\n  textarea {\n    resize: vertical;\n  }\n\n  input::placeholder,\n  textarea::placeholder {\n    opacity: 1;\n    color: #9ca3af;\n  }\n\n  button,\n  [role='button'] {\n    cursor: pointer;\n  }\n\n  :disabled {\n    cursor: default;\n  }\n\n  img,\n  svg,\n  video,\n  canvas,\n  audio,\n  iframe,\n  embed,\n  object {\n    display: block;\n  }\n\n  img,\n  video {\n    max-width: 100%;\n    height: auto;\n  }\n\n  [hidden] {\n    display: none;\n  }\n"),Oa=({children:n,open:a,onClick:i,...s})=>/*#__PURE__*/t(rr,{show:a,as:r.Fragment,children:/*#__PURE__*/e(ar,{onClose:i,...s,as:Ma,children:[/*#__PURE__*/t(ir,{as:r.Fragment,enterFrom:"entering",leaveTo:"leaving",children:/*#__PURE__*/t(Ra,{id:"privy-dialog-backdrop","aria-hidden":"true"})}),/*#__PURE__*/t(xa,{children:/*#__PURE__*/t(ir,{as:r.Fragment,enterFrom:"entering",leaveTo:"leaving",children:/*#__PURE__*/t(sr,{as:Fa,children:n})})})]})});let Ra=/*#__PURE__*/Gn.div.withConfig({displayName:"Backdrop",componentId:"sc-3cfde0b5-0"})(["position:fixed;inset:0;transition:backdrop-filter 100ms ease;backdrop-filter:blur(3px);-webkit-backdrop-filter:blur(3px);&.entering,&.leaving{backdrop-filter:unset;-webkit-backdrop-filter:unset;}"]),Ma=/*#__PURE__*/Gn.div.withConfig({displayName:"DialogWrapper",componentId:"sc-3cfde0b5-1"})(["position:relative;z-index:999999;"]),xa=/*#__PURE__*/Gn.div.withConfig({displayName:"DialogContainer",componentId:"sc-3cfde0b5-2"})(["position:fixed;inset:0;display:flex;align-items:center;justify-content:center;width:100vw;min-height:100vh;"]);const Fa=/*#__PURE__*/Gn.div.withConfig({displayName:"Panel",componentId:"sc-3cfde0b5-3"})(["padding:0;background:transparent;border:none;width:100%;pointer-events:auto;outline:none;display:block;@media (max-width:440px){opacity:1;transform:translate3d(0,0,0);transition:transform 200ms ease-in;position:fixed;bottom:0;&.entering,&.leaving{opacity:0;transform:translate3d(0,100%,0);transition:transform 150ms ease-in 0ms,opacity 0ms ease 150ms;}}@media (min-width:441px){opacity:1;transition:opacity 100ms ease-in;&.entering,&.leaving{opacity:0;transition-delay:5ms;}margin:auto;width:360px;box-shadow:0px 8px 36px rgba(55,65,81,0.15);border-radius:var(--privy-border-radius-lg);}"]);const La=()=>{let{ready:e}=T(),{currentScreen:t}=_(),[n,r]=o(null),[a,i]=o(!1),l=function(e){let[t,n]=o(!1),r=s(null),a=s(null),i=s(null);return c((()=>{if(r.current&&(clearTimeout(r.current),r.current=null),a.current&&(clearTimeout(a.current),a.current=null),e)i.current=Date.now(),r.current=setTimeout((()=>{n(!0)}),150);else if(null!==i.current){let e=Date.now()-i.current;if(e>=150){let t=Math.max(0,400-(e-150));a.current=setTimeout((()=>{n(!1),i.current=null}),t)}else r.current&&(clearTimeout(r.current),r.current=null),n(!1),i.current=null}return()=>{r.current&&clearTimeout(r.current),a.current&&clearTimeout(a.current)}}),[e]),t}(a);return c((()=>{if(!t)return r(null),void i(!1);i(!0),Ea[t]().then((n=>{(!t||e||n.default.isShownBeforeReady)&&(r((()=>n.default.component)),i(!1))})).catch((()=>{r(null),i(!1)}))}),[t,e]),{component:n,isLoading:l}};let Da=/*#__PURE__*/u((()=>import("./MfaVerifyFlowScreen-BEt8Gfpb.mjs"))),ja=/*#__PURE__*/u((()=>(e=>Ea[e]().then((e=>({default:e.default.component}))))("MfaAuthVerifyFlowScreen"))),za=()=>/*#__PURE__*/t($a,{children:/*#__PURE__*/t(K,{})}),qa=()=>{let{currentScreen:r}=_(),a=Pa((e=>e.inProgressMfaFlow)),i=()=>Pa.setState({inProgressMfaFlow:void 0}),{component:s,isLoading:l}=La();return function(){let{isModalOpen:e}=T(),{headless:t}=Xe(),{currentScreen:n}=_(),{status:r,execute:a,reset:i,enabled:s}=va(),[l,d]=o(!1);c((()=>{!e&&s&&i()}),[e,s,i]),c((()=>{n?Ea[n]().then((e=>{d(!!e.default.isCaptchaRequired)})).catch((()=>{d(!1)})):d(!1)}),[n]),c((()=>{e&&l&&!t&&"ready"===r&&s&&a()}),[e,l,t,r,s,a])}(),r||"txn"!==a?l?/*#__PURE__*/t(za,{}):s?
/*#__PURE__*/e(n,{children:[/*#__PURE__*/t(V,{$if:!!a,children:/*#__PURE__*/t(d,{children:/*#__PURE__*/t(s,{})})}),/*#__PURE__*/e(d,{children:["txn"===a&&/*#__PURE__*/t(Da,{onClose:i}),"auth"===a&&/*#__PURE__*/t(ja,{})]})]}):null:/*#__PURE__*/e(d,{children:[/*#__PURE__*/t(Da,{onClose:i}),";"]})},Ha=()=>{let e=s(null);/*#__PURE__*/return t(Ka,{style:{height:B(e)},id:"privy-modal-content",children:/*#__PURE__*/t("div",{ref:e,children:/*#__PURE__*/t(qa,{})})})};const Va=({open:e})=>{let n=Xe(),{gracefulClosePrivyModal:r}=(()=>{let{closePrivyModal:e}=Ie(),{onUserCloseViaDialogOrKeybindRef:t}=_();return{gracefulClosePrivyModal:h((()=>{if(!t?.current)return e({shouldCallAuthOnSuccess:!1});t.current()}),[e])}})(),a=Pa((e=>e.inProgressMfaFlow));return Ia({onMfaRequired:()=>{n.mfa.noPromptOnMfaRequired||Pa.setState({inProgressMfaFlow:"txn"})}}),n.render.standalone?/*#__PURE__*/t(Na,{children:/*#__PURE__*/t(Ba,{id:"privy-modal-content",children:/*#__PURE__*/t(qa,{})})}):/*#__PURE__*/t(Oa,{open:!(!e&&!a),id:"privy-dialog","aria-label":"log in or sign up","aria-labelledby":"privy-dialog-title",onClick:()=>r(),children:/*#__PURE__*/t(Na,{children:/*#__PURE__*/t(Ha,{})})})};let Ba=/*#__PURE__*/Gn.div.withConfig({displayName:"ContentWrapper",componentId:"sc-9b080f09-0"})(["display:flex;flex-direction:column;text-align:center;font-size:14px;line-height:20px;width:100%;background:var(--privy-color-background);padding:0 16px;"]),Ka=/*#__PURE__*/Gn(Ba).withConfig({displayName:"BaseModal",componentId:"sc-9b080f09-1"})(["transition:height 150ms ease-out;overflow-x:hidden;overflow-y:auto;scrollbar-width:none;max-height:calc(100svh - 32px);border-radius:var(--privy-border-radius-lg) var(--privy-border-radius-lg) 0 0;box-shadow:0px 0px 36px rgba(55,65,81,0.15);@media (min-width:441px){box-shadow:0px 8px 36px rgba(55,65,81,0.15);border-radius:var(--privy-border-radius-lg);}"]),$a=/*#__PURE__*/Gn.div.withConfig({displayName:"LoadingScreenContainer",componentId:"sc-9b080f09-2"})(["display:flex;align-items:center;justify-content:center;min-height:300px;padding:2rem;"]);function Ga(e){let n=s(null),r=s();return c((()=>{r.current?.remove(),r.current=function({botUsername:e,scriptHost:t}){let n=document.createElement("script"),{origin:r}=new URL(t);return n.async=!0,n.src=`${r}/js/telegram-login.js`,n.setAttribute("data-telegram-login",e),n.setAttribute("data-request-access","write"),n.setAttribute("data-lang","en"),n}(e),n.current?.after(r.current)}),[e]),/*#__PURE__*/t("div",{ref:n,hidden:!0})}const Ya=()=>{let{ready:e}=ge(),{client:t}=Ie();return c((()=>{let n=()=>{if(!t.connectors||!e)return;let n=t.connectors.wallets.map((e=>({address:e.address,connectorType:e.connectorType,walletClientType:e.walletClientType,connectedAt:e.connectedAt,id:e.meta.id})));Me.put(et,n)};return t.connectors?.on("walletsUpdated",n),()=>{t.connectors?.off("walletsUpdated",n)}}),[e,t.connectors]),null};class Ja extends j{async initialize(){let e=await this.createProvider();this.provider=e,this.proxyProvider.setWalletProvider(e),this.subscribeListeners(),e.session&&(this.walletProvider?.session?.peer.metadata.url&&(this.walletEntry=$(this.walletProvider?.session?.peer.metadata.url),this.walletClientType=this.walletEntry?.slug||"unknown"),this.connected=!0,await this.syncAccounts()),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),this.getConnectedWallet()}async isConnected(){return!!this.walletProvider?.connected}get walletBranding(){let e=this.walletProvider?.session?.peer.metadata.icons?.[0];return{name:G(this.walletProvider?.session?.peer.metadata.name||"")||"WalletConnect",icon:"string"==typeof e?e:xe,id:this.walletProvider?.session?.peer.metadata.name.toLowerCase()||"wallet_connect_v2"}}async resetConnection(e){this.walletProvider&&this.walletProvider.connected&&(await this.walletProvider.disconnect(),this.walletProvider.signer.session=void 0,this.walletClientType=e,this.redirectUri=void 0,this.fallbackUniversalRedirectUri=void 0,xn(),this.onDisconnect())}async promptConnection(){if(this.provider)return new Promise(((e,t)=>{(async()=>{let t="",n=await Promise.race([this.walletProvider?.enable(),this.proxyProvider.walletTimeout()]);if(n?.length&&(t=n[0]),!t||""===t)throw new ke("Unable to retrieve address");this.walletProvider?.session?.peer.metadata.url&&(this.walletEntry=$(this.walletProvider?.session?.peer.metadata.url),this.walletClientType=this.walletEntry?.slug||"unknown",this.proxyProvider.rpcTimeoutDuration=Q(this.rpcConfig,this.walletClientType)),this.connected=!0,await this.syncAccounts(n),e()})().catch((e=>{t(e?Re(e):new ke("Unknown error during connection"))}))}))}disconnect(){this.walletProvider?.disconnect().then((()=>this.onDisconnect())).catch((()=>console.warn("Unable to disconnect WalletConnect provider")))}get walletProvider(){return this.proxyProvider.walletProvider}setWalletProvider(e){this.proxyProvider.setWalletProvider(e)}async createProvider(){let e={};for(let t of this.chains){let n=Y(t.id,this.chains,this.rpcConfig,this.privyAppId);n&&(e[t.id]=n)}let t=this.shouldEnforceDefaultChainOnConnect?[this.defaultChain.id]:[],n=this.chains.map((e=>e.id)),r=await or.init({projectId:this.walletConnectCloudProjectId,chains:t,optionalChains:n,optionalEvents:cr,optionalMethods:lr,rpcMap:e,showQrModal:!1,metadata:{description:this.privyAppName,name:this.privyAppName,url:window.location.origin,icons:[]}});return r.on("display_uri",(e=>{if(r.signer.abortPairingAttempt(),Fn(),!this.showPrivyQrModal)throw new ke("WalletConnect modal not available - Privy handles wallet connections through its own UI");if(ft&&this.walletEntry){let{redirect:t,href:n}=Ln(e,this.walletEntry);Rn(t,"_self"),Dn({href:n,name:this.walletEntry.metadata?.shortName||this.walletEntry.name});let r=jn(e,this.walletEntry);return this.redirectUri=t,this.fallbackUniversalRedirectUri=r?.redirect,this.showPrivyQrModal({native:t,universal:t})}if(this.redirectUri=void 0,this.walletEntry){let t=jn(e,this.walletEntry);this.fallbackUniversalRedirectUri=t?.redirect}this.showPrivyQrModal({native:e,universal:void 0})})),r.on("connect",(()=>{r.session?.peer.metadata.url&&(this.walletEntry=$(r.session?.peer.metadata.url),this.walletClientType=this.walletEntry?.slug||"unknown")})),r}async enableProvider(){return this.walletProvider?.connected?Promise.resolve(this.walletProvider.accounts):await(this.walletProvider?.enable())}setWalletEntry(e,t){this.walletEntry=e,this.showPrivyQrModal=t}constructor({walletConnectCloudProjectId:e,rpcConfig:t,chains:n,defaultChain:r,shouldEnforceDefaultChainOnConnect:a,privyAppId:i,privyAppName:s,walletClientType:o}){super(o||"unknown",n,r,t),this.connectorType="wallet_connect_v2",this.privyAppId=i,this.privyAppName=s,this.walletConnectCloudProjectId=e,this.rpcConfig=t,this.shouldEnforceDefaultChainOnConnect=a,this.proxyProvider=new z(void 0,this.rpcTimeoutDuration),o&&(this.walletEntry=J(o),this.walletClientType=o)}}const Qa=["error","invalid_request_arguments","wallet_not_on_device","invalid_recovery_pin","insufficient_funds","missing_or_invalid_mfa","mfa_verification_max_attempts_reached","mfa_timeout","twilio_verification_failed"];class Za extends Error{constructor(e,t){super(t),this.type=e}}function Xa(e){let t=e.type;return"string"==typeof t&&Qa.includes(t)}function ei(e){return Xa(e)&&"wallet_not_on_device"===e.type}function ti(e){return Xa(e)&&("invalid_recovery_pin"===e.type||"invalid_request_arguments"===e.type)}function ni(e){return!!Xa(e)&&"mfa_timeout"===e.type}function ri(e){return!!Xa(e)&&"missing_or_invalid_mfa"===e.type}function ai(e){return!!Xa(e)&&"mfa_verification_max_attempts_reached"===e.type}function ii(e){return!(!Xa(e)||!e.message.includes("code 429"))}function si(e){return!!function(e){let t=e.type;return"string"==typeof t&&"client_error"===t}(e)&&"MFA canceled"===e.message}async function oi(e,t,n,r,a,i=!1){let s=i,o=async o=>{if(s&&t&&t.length>0){o===(i?0:1)?a("configureMfa","onMfaRequired",{mfaMethods:t}):r.current?.reject(new Za("missing_or_invalid_mfa","MFA verification failed, retry."));let s=await new Promise(((e,t)=>{n.current={resolve:e,reject:t},setTimeout((()=>{let e=new Za("mfa_timeout","Timed out waiting for MFA code");r.current?.reject(e),t(e)}),3e5)}));return await e(s)}return await e()},l=null;for(let e=0;e<4;e++)try{l=await o(e),r.current?.resolve(void 0);break}catch(e){if("missing_or_invalid_mfa"!==e.type)throw r.current?.resolve(void 0),e;s=!0}if(null===l){let e=new Za("mfa_verification_max_attempts_reached","Max MFA verification attempts reached");throw r.current?.reject(e),e}return l}var li;let ci=(li=0,()=>"id-"+li++);function di(e){return void 0!==e.error}let ui=new class{enqueue(e,t){this.callbacks[e]=t}dequeue(e,t){let n=this.callbacks[t];if(!n)throw Error(`cannot dequeue ${e} event: no event found for id ${t}`);switch(delete this.callbacks[t],e){case"privy:iframe:ready":case"privy:user-signer:sign":case"privy:wallets:add":case"privy:wallets:import":case"privy:wallets:set-recovery":case"privy:wallets:connect":case"privy:wallets:recover":case"privy:wallets:rpc":case"privy:wallet:create":case"privy:mfa:verify":case"privy:mfa:init-enrollment":case"privy:mfa:submit-enrollment":case"privy:mfa:unenroll":case"privy:mfa:clear":case"privy:auth:unlink-passkey":case"privy:farcaster:init-signer":case"privy:farcaster:sign":case"privy:solana-wallet:create":case"privy:delegated-actions:consent":return n;default:throw Error(`invalid wallet event type ${e}`)}}constructor(){this.callbacks={}}},hi=new Map,pi=(e,t)=>"bigint"==typeof t?t.toString():t;function wi(e,t,n,r){let a=n.contentWindow;if(!a)throw Error("iframe not initialized");let i=((e,t)=>`${e}${JSON.stringify(t,pi)}`)(e,t);if("privy:wallet:create"===e){let e=hi.get(i);if(e)return e}let s=new Promise(((n,i)=>{let s=ci();ui.enqueue(s,{resolve:n,reject:i}),a.postMessage({id:s,event:e,data:t},r)})).finally((()=>{hi.delete(i)}));return hi.set(i,s),s}function mi(e){let n=tt(),r=s(null),a=s(e.mfaMethods),i=Zn(),[l,d]=o(!1);return c((()=>{a.current=e.mfaMethods}),[e.mfaMethods]),c((()=>{if(!l)return;let t=r.current;if(!t)return;function n(t){var n;t&&t.origin===e.origin&&"string"==typeof(n=t.data).event&&/^privy:.+/.test(n.event)&&function(e){switch(e.event){case"privy:iframe:ready":let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data);case"privy:user-signer:sign":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:add":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:set-recovery":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:connect":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:recover":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:rpc":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallet:create":let n=ui.dequeue(e.event,e.id);return di(e)?n.reject(new Za(e.error.type,e.error.message)):n.resolve(e.data);case"privy:wallets:import":let r=ui.dequeue(e.event,e.id);return di(e)?r.reject(new Za(e.error.type,e.error.message)):r.resolve(e.data);case"privy:mfa:verify":let a=ui.dequeue(e.event,e.id);return di(e)?a.reject(new Za(e.error.type,e.error.message)):a.resolve(e.data);case"privy:mfa:init-enrollment":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:mfa:submit-enrollment":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:mfa:unenroll":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:mfa:clear":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:auth:unlink-passkey":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:solana-wallet:create":let i=ui.dequeue(e.event,e.id);return di(e)?i.reject(new Za(e.error.type,e.error.message)):i.resolve(e.data);case"privy:farcaster:init-signer":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:farcaster:sign":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:delegated-actions:consent":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}default:console.warn("Unsupported wallet proxy method:",e)}}(t.data)}let s={signWithUserSigner:n=>oi((r=>wi("privy:user-signer:sign",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),addWallet:n=>oi((r=>wi("privy:wallets:add",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),setRecovery:n=>oi((r=>wi("privy:wallets:set-recovery",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),connect:n=>oi((r=>wi("privy:wallets:connect",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),recover:n=>oi((r=>wi("privy:wallets:recover",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i,!n.recoveryAccessToken&&!n.recoveryPassword&&!n.recoverySecretOverride),rpc:n=>oi((r=>wi("privy:wallets:rpc",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),create:n=>wi("privy:wallet:create",n,t,e.origin),importWallet:n=>wi("privy:wallets:import",n,t,e.origin),createSolana:n=>oi((r=>wi("privy:solana-wallet:create",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),createDelegatedAction:n=>wi("privy:delegated-actions:consent",n,t,e.origin),verifyMfa:n=>oi((r=>wi("privy:mfa:verify",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i,!0),initEnrollMfa:n=>oi((r=>wi("privy:mfa:init-enrollment",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),submitEnrollMfa:n=>oi((r=>wi("privy:mfa:submit-enrollment",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),unenrollMfa:n=>oi((r=>wi("privy:mfa:unenroll",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),clearMfa:n=>wi("privy:mfa:clear",n,t,e.origin),unlinkPasskeyAccount:n=>oi((r=>wi("privy:auth:unlink-passkey",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),initFarcasterSigner:n=>wi("privy:farcaster:init-signer",n,t,e.origin),signFarcasterMessage:n=>wi("privy:farcaster:sign",n,t,e.origin)};window.addEventListener("message",n);let o=new AbortController;return Z((()=>wi("privy:iframe:ready",{},t,e.origin)),{abortSignal:o.signal}).then((()=>e.onLoad(s)),((...t)=>{console.warn("Privy iframe failed to load: ",...t),e.onLoadFailed()})),()=>{window.removeEventListener("message",n),o.abort()}}),[l]),n?
/*#__PURE__*/t("iframe",{ref:r,width:"0",height:"0",style:{display:"none",height:"0px",width:"0px"},onLoad:()=>d(!0),src:dr({origin:e.origin,path:`/apps/${e.appId}/embedded-wallets`,query:{caid:e.clientAnalyticsId,client_id:e.appClientId}})}):null}const yi=({address:e,user:t})=>{let n=t.linkedAccounts.find((t=>"wallet"===t.type&&"privy"===t.walletClientType&&t.address===e));if(!n)throw new Ce("Address to delegate is not associated with current user.");if(!Fe(n))throw new Ce(`useDelegatedActions is not supported for ${n.chainType} wallets. Use the useSessionSigners hook to provision server side access on behalf of your users.`);return{address:n.address,chainType:n.chainType,walletIndex:n.walletIndex??0}},gi=({address:e,user:t})=>{let n=t.linkedAccounts.find((t=>"wallet"===t.type&&"privy"===t.walletClientType&&t.address===e));if(!n)throw new Ce("Address to delegate is not associated with current user.");let r=n.imported?n:b(t);if(!r)throw new Ce("Unable to determine root address for delegated address.");if(!Fe(r))throw new Ce(`useDelegatedActions is not supported for ${r.chainType} wallets. Use the useSessionSigners hook to provision server side access on behalf of your users.`);return{address:r.address,chainType:r.chainType,imported:r.imported}},fi=e=>e.linkedAccounts.filter((e=>"wallet"===e.type&&"privy"===e.walletClientType&&e.delegated));const vi="popup-privy-oauth",Ai="PRIVY_OAUTH_USE_BROADCAST_CHANNEL";class ki{async authenticate(){if(!this.api)throw new Ce("Auth flow has no API instance");try{return await this.api.post(xt,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:this.meta.codeVerifier,provider:this.meta.provider})}catch(e){throw Te(e)}}async link(){if(!this.api)throw new Ce("Auth flow has no API instance");try{return await this.api.post(Ft,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:this.meta.codeVerifier,provider:this.meta.provider})}catch(e){throw Te(e)}}constructor({authorizationCode:e,stateCode:t,codeVerifier:n,provider:r}){this.meta={authorizationCode:e,stateCode:t,codeVerifier:n,provider:r}}}async function Ci({api:e,requesterAppId:t,providerAppId:n}){let r=(await e.get(`/api/v1/apps/${t}/cross-app/connections`)).connections.find((e=>e.provider_app_id===n));if(!r)throw new Ce("Invalid connected app");return{name:r.provider_app_name,logoUrl:r.provider_app_icon_url||void 0,apiUrl:r.provider_app_custom_api_url,readOnly:r.read_only,customAuthAuthorizeUrl:r.provider_app_custom_auth_authorize_url,customAuthTransactUrl:r.provider_app_custom_auth_transact_url}}const Ti=async({user:e,address:t,client:n,request:r,requesterAppId:a,reconnect:i})=>{n.createAnalyticsEvent({eventName:"cross_app_request_started",payload:{address:t,method:r.method}});let s=e?.linkedAccounts.find((e=>"cross_app"===e.type&&(e.embeddedWallets.some((e=>e.address===t))||e.smartWallets.some((e=>e.address===t)))));if(!e||!s)throw n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Cannot request a signature with this wallet address",address:t}}),new Ce("Cannot request a signature with this wallet address");let o=n.getProviderAccessToken(s.providerApp.id),l=await Ci({api:n.api,requesterAppId:a,providerAppId:s.providerApp.id});if(!o){if(l.readOnly)throw console.error("cannot transact against a read-only provider app"),new Ce("Cannot transact against a read-only provider app");await i({appId:s.providerApp.id,action:"link"})&&(o=n.getProviderAccessToken(s.providerApp.id))}if(!o)throw n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Transactions require a valid token",address:t}}),new Ce("Transactions require a valid token");let c=new URL(l.customAuthTransactUrl||`${l.apiUrl}/oauth/transact`);c.searchParams.set("token",o||""),c.searchParams.set("request",_i(r));let d=Et({location:c.href});if(!d)throw n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Missing token",address:t}}),new Ce("Failed to initialize signature request");return new Promise(((e,a)=>{let i=setTimeout((()=>{c(),a(new Ce("Request timeout")),n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Request timeout",address:t}})}),12e4),o=setInterval((()=>{d.closed&&(c(),a(new Ce("User rejected request")),n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"User rejected request",address:t}}))}),300),l=i=>{i.data&&("set"===i.data.token?.action&&void 0!==i.data.token?.value?n.storeProviderAccessToken(s.providerApp.id,i.data.token.value):"clear"===i.data.token?.action&&n.storeProviderAccessToken(s.providerApp.id,null),"PRIVY_CROSS_APP_ACTION_RESPONSE"===i.data.type&&i.data.result&&(c(),e(i.data.result),n.createAnalyticsEvent({eventName:"cross_app_request_success",payload:{address:t,method:r.method}})),"PRIVY_CROSS_APP_ACTION_ERROR"===i.data.type&&i.data.error&&(c(),a(i.data.error),n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:i.data.error,address:t}})))};window.addEventListener("message",l);let c=()=>{d.close(),clearInterval(o),clearTimeout(i),window.removeEventListener("message",l)}}))};let _i=e=>JSON.stringify({content:{request:{request:bi(e,ur)}},timestamp:Date.now(),callbackUrl:window.origin});const bi=(e,t)=>"bigint"==typeof e?t(e):Array.isArray(e)?e.map((e=>bi(e,t))):e&&"object"==typeof e?Object.fromEntries(Object.entries(e).map((([e,n])=>[e,bi(n,t)]))):e;function Si({isCreatingWallet:e,skipSplashScreen:t}){return e?"EmbeddedWalletPasswordCreateScreen":t?"EmbeddedWalletPasswordUpdateScreen":"EmbeddedWalletPasswordUpdateSplashScreen"}function Ei({walletAction:e,availableRecoveryMethods:t,legacySetWalletPasswordFlow:n,isResettingPassword:r,showAutomaticRecovery:a}){return a?"SetAutomaticRecoveryScreen":n||1===t.length?Si({isCreatingWallet:"create"===e,skipSplashScreen:r}):"RecoverySelectionScreen"}function Ii(e){switch(e){case"user-passcode":return"PasswordRecoveryScreen";case"google-drive":case"icloud":return"RecoveryOAuthScreen";default:throw Error("Recovery method not supported")}}function Pi(e,t,n,r,a,i,s){return{...e,funding:e?.funding?{...e.funding,fundingResult:{status:t,address:e.funding.address,fundingMethod:void 0,transactionHash:n,amount:e.funding.amount,assetType:a?i?.symbol||"ETH":s.nativeCurrency.symbol||"ETH",metadata:{walletClientType:r}}}:void 0,solanaFundingData:e?.solanaFundingData,sendTransaction:e?.sendTransaction}}const Wi=new Map([["FundingMethodSelectionScreen",null],["TransferFromWalletScreen","external"],["FundingAmountEditScreen","external"],["ConnectOnlyLandingScreen","external"],["ConnectOnlyStatusScreen","external"],["AwaitingExternalEthereumTransferScreen","external"],["AwaitingEvmToSolBridgingScreen","external"],["AwaitingSolToEvmBridgingScreen","external"],["ManualTransferScreen","manual"],["MoonpayStatusScreen","moonpay"]]);function Ui(e){let t=e.toLowerCase();return!!window?.webkit?.messageHandlers?.ReactNativeWebView||!!window?.ReactNativeWebView||["fbav","fban","instagram","snapchat","linkedinapp"].some((e=>t.includes(e)))}async function Ni({rpc:e,address:t}){return(await e.getBalance(t,{commitment:"confirmed"}).send()).value??0n}let Oi={apple_oauth:"apple",custom_auth:"custom",discord_oauth:"discord",email:"email",farcaster:"farcaster",github_oauth:"github",google_oauth:"google",instagram_oauth:"instagram",linkedin_oauth:"linkedin",passkey:"passkey",phone:"sms",spotify_oauth:"spotify",telegram:"telegram",tiktok_oauth:"tiktok",line_oauth:"line",twitch_oauth:"twitch",twitter_oauth:"twitter",wallet:"siwe",smart_wallet:"siwe",cross_app:"privy:"};const Ri=e=>{if(S(e))return{displayName:e.replace("custom:",""),loginMethod:"custom"};let t=Oi[e];return"wallet"===e||"phone"===e?{displayName:e,loginMethod:t}:{displayName:t,loginMethod:t}},Mi=(e,t)=>!E(e)&&("all-users"===t||"users-without-wallets"===t&&!xi(e).length);let xi=e=>e.linkedAccounts.filter((e=>"wallet"===e.type&&"ethereum"===e.chainType));const Fi=(e,t)=>!I(e)&&("all-users"===t||"users-without-wallets"===t&&!Li(e).length);let Li=e=>e.linkedAccounts.filter((e=>"wallet"===e.type&&"solana"===e.chainType));async function Di(e,t,n,r){let a=Be(e),{chain:i,...s}=await(async()=>r?await r():await t.prepareTransactionRequest({...a,account:{address:n,type:"json-rpc"}}))();return{...s,type:Ke[s.type]}}const ji=()=>{let e=Xe(),{user:t}=T(),{client:n,refreshSessionAndUser:r,walletProxy:a}=Ie();return{migrate:h((async()=>{if("legacy-embedded-wallets-only"===e.embeddedWallets.mode)return{success:!0};if(!t)throw new Ce("User must be authenticated before migrating wallets",_e.MUST_BE_AUTHENTICATED);if(!a)throw new Ce("Cannot connect to wallet proxy");let i=await n.getAccessToken();if(!i)throw new Ce("User must be authenticated before migrating wallets",_e.MUST_BE_AUTHENTICATED);let s=t.linkedAccounts.filter((e=>"wallet"===e.type&&"privy"===e.walletClientType&&Fe(e)&&!P(e)));if(0===s.length)return{success:!0};let o=s.filter((e=>e.imported)),l=s.filter((e=>!e.imported));if(l.length>0){let e=l.find((e=>"ethereum"===e.chainType&&0===e.walletIndex))??l.find((e=>"solana"===e.chainType&&0===e.walletIndex))??null;if(!e)throw new Ce("Primary wallet not found");let{entropyId:t,entropyIdVerifier:n}=fe(e);try{await a.connect({accessToken:i,entropyId:t,entropyIdVerifier:n})}catch(r){if(!ei(r)||"privy"!==e.recoveryMethod)throw r;await a.recover({accessToken:i,entropyId:t,entropyIdVerifier:n})}await a.createDelegatedAction({accessToken:i,rootWallet:{address:e.address,chainType:e.chainType,imported:!1},delegatedWallets:l.map((e=>({address:e.address,chainType:e.chainType,walletIndex:e.walletIndex??0})))})}for(let e of o){let{entropyId:t,entropyIdVerifier:n}=fe(e);try{await a.connect({accessToken:i,entropyId:t,entropyIdVerifier:n})}catch(o){if(!ei(o)||"privy"!==e.recoveryMethod)throw o;await a.recover({accessToken:i,entropyId:t,entropyIdVerifier:n})}await a.createDelegatedAction({accessToken:i,rootWallet:{address:e.address,chainType:e.chainType,imported:!0},delegatedWallets:[{address:e.address,chainType:e.chainType,walletIndex:e.walletIndex??0}]})}return await r(),{success:!0}}),[e.embeddedWallets.mode,t,a,n,r])}},zi=({disabled:e})=>{let{migrate:t}=ji(),{user:n}=T(),{walletProxy:r}=Ie(),a=s(!1);return c((()=>{!e&&!a.current&&n&&r&&(a.current=!0,t().catch((e=>{console.debug("Unable to migrate wallets: ",e)})).finally((()=>{a.current=!1})))}),[n,r,e,t]),null},qi=e=>({id:e.id,raw_id:e.rawId,response:{client_data_json:e.response.clientDataJSON,authenticator_data:e.response.authenticatorData,signature:e.response.signature,user_handle:e.response.userHandle},authenticator_attachment:e.authenticatorAttachment,client_extension_results:{app_id:e.clientExtensionResults.appid,cred_props:e.clientExtensionResults.credProps,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret},type:e.type}),Hi=nr((()=>({ethereum:[]}))),Vi=()=>Hi.getState().ethereum;class Bi{async authenticate(){if(!this.api)throw new Ce("Auth flow has no API instance");try{return await this.api.post(Qt,{token:this.meta.token})}catch(e){throw Te(e)}}async link(){if(!this.api)throw new Ce("Auth flow has no API instance");try{return await this.api.post(Zt,{token:this.meta.token})}catch(e){throw Te(e)}}constructor(e){this.meta={token:e}}}function Ki({subscribe:e,getExternalJwt:t,enabled:n=!0,onAuthenticated:r,onUnauthenticated:a,onError:i}){let{client:l,onCustomAuthAuthenticated:d}=Ie(),{logout:u,authenticated:h,ready:p}=zn();if(!l)throw new Ce("`useSyncJwtBasedAuthState` must be used within a `PrivyProvider`");let[w,m]=o({status:"initial"}),y=s(),g=s(!1),f=s(t);c((()=>{f.current=t}),[t]);let v=s(r);c((()=>{v.current=r}),[r]);let A=s(a);c((()=>{A.current=a}),[a]);let k=s(i);return c((()=>{k.current=i}),[i]),c((()=>{if(!n||!p)return;let t=async()=>{if(!g.current){g.current=!0;try{m({status:"loading"});let e=await f.current();if(void 0!==y.current&&y.current===e)return void m({status:"done"});if(!e)return h&&(await u(),A.current?.()),y.current=e,void m({status:"done"});l.startAuthFlow(new Bi(e));let{user:t,isNewUser:n=!1}=await l.authenticate();if(!t)throw new Ce("Failed to sync with custom auth provider");v.current?.({user:t,isNewUser:n}),d(t,n),y.current=e,m({status:"done"})}catch(e){if(console.warn(e),await u().catch((()=>{})),A.current?.(),e instanceof Pe&&e.privyErrorCode===_e.LINKED_TO_ANOTHER_USER)return m({status:"initial"}),void setTimeout((()=>{t()}),0);k.current?.(e),m({status:"error",error:e})}finally{g.current=!1}}};return t(),e(t)}),[e,l,d,h,u,n,p]),n?{state:w}:{state:{status:"not-enabled"}}}let $i=nr((()=>({jwtAuthFlowState:{status:"not-enabled"}})));function Gi({customAuth:e}){let{jwtAuthFlowState:t}=function({customAuth:e}){let t=Zn(),n=s(),r=h((e=>(n.current=e,()=>{n.current=void 0})),[]),a=e?.getCustomAccessToken??(()=>Promise.resolve(void 0)),{state:i}=Ki({enabled:!0===e?.enabled,subscribe:r,getExternalJwt:a,onAuthenticated:({user:e,isNewUser:n})=>{t("login","onComplete",{user:e,isNewUser:n,wasAlreadyAuthenticated:!1,loginMethod:"custom",loginAccount:null}),t("customAuth","onAuthenticated",{user:e})},onUnauthenticated:()=>{t("customAuth","onUnauthenticated")},onError:e=>{t("login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR)}});return c((()=>{(async()=>{e&&!e.isLoading&&n.current?.()})()}),[e?.enabled,e?.getCustomAccessToken,e?.isLoading]),{jwtAuthFlowState:i}}({customAuth:e});return c((()=>{$i.setState({jwtAuthFlowState:t})}),[t]),null}const Yi=/*#__PURE__*/i(!1);let Ji,Qi,Zi,Xi,es;const ts=n=>{let r=n.client,a=n.privy,i=qn(),d=Xe();X(ee(d?.appearance.walletList??[]));let[u,p]=o(!1),w=Pa((e=>e.inProgressMfaFlow)),[y,g]=o(!1),[f,v]=o(null),A=Hi((e=>e.ethereum)),[k,C]=o(void 0),[T,_]=o(!1),[S,I]=o(null),[F,L]=o(!1),[D,j]=o({status:"disconnected",connectedWallet:null,connectError:null,connector:null,connectRetry:Se}),[z,q]=o({status:"initial"}),[H,B]=o({status:"initial"}),[K,$]=o({status:"initial"}),[G,Y]=o({status:"initial"}),[J,Q]=o({status:"initial"}),[Z,ce]=o({status:"initial"}),[de,ue]=o(null),he=tt(),[pe,we]=o({}),[me,ye]=o(null),ge=s(null),[fe,Ee]=o(!1),[Ie,Pe]=o(!1),Ne=s(null),Oe=s(null),Re=s(Xn),[xe,He]=o(!1),[Ve,Be]=o(!1),Ke=h((e=>{Be(e),!e&&S&&Ea[S]().then((e=>{e.default.isUnauthenticatedScreem&&I(null)}))}),[S]);r.onStoreCustomerAccessToken=e=>{e&&er(Re,"accessToken","onAccessTokenGranted",{accessToken:e})},r.onDeleteCustomerAccessToken=()=>{v(null),Ke(!1),er(Re,"accessToken","onAccessTokenRemoved")};let $e=s(null),Ge=s(null),Ye=s(!1),et=({showWalletUIs:e})=>Ye.current?Ye.current:void 0!==e?!e:!d.embeddedWallets.showWalletUIs,it=e=>{I(e),setTimeout((()=>{p(!0)}),15)};c((()=>{if(!f)return void r.connectors?.removeEmbeddedWalletConnectors();let e=E(f),t=W(f),i=U(f);e&&t.length||r.connectors?.removeEmbeddedWalletConnectors(),i.length||r.connectors?.removeImportedWalletConnectors(),r.connectors?de?(e&&r.connectors.addEmbeddedWalletConnectors({walletProxy:de,user:f,embeddedWallets:t,defaultChain:d.defaultChain,appId:n.appId,privyClient:a}),i.forEach((e=>r.connectors?.addImportedWalletConnector(de,e.address,d.defaultChain,n.appId)))):console.debug("Failed to add embedded wallet connector: Wallet proxy not initialized"):console.debug("Failed to add embedded wallet connector: Client connectors not initialized")}),[de,f]),c((()=>{de&&ge.current?.(de)}),[de]);let st=h(((e,t)=>{v(e),_(t),Ke(!0),Pe(!0)}),[]);c((()=>{Ie&&de&&f&&(async()=>{let e=Mi(f,d.embeddedWallets.ethereum.createOnLogin),t=Fi(f,d.embeddedWallets.solana.createOnLogin),n=await Kr();if(n){if(e&&t){let e=await de.create({accessToken:n});return await de.createSolana({accessToken:n,ethereumAddress:e?.address}),void Pe(!1)}if(t)return await de.createSolana({accessToken:n,ethereumAddress:E(f)?.address}),await Ut.refreshSessionAndUser(),void Pe(!1);if(e)return await de.create({accessToken:n}),void Pe(!1)}})().catch(console.error)}),[Ie&&de&&f]),c((()=>{if(d.externalWallets.solana.connectors)return d.externalWallets.solana.connectors.onMount(),()=>d.externalWallets.solana.connectors?.onUnmount()}),[d.externalWallets.solana.connectors]),c((()=>{!y&&he&&async function(){let e,t=ot(),n=lt(),a=gt();r.initializeConnectorManager({walletConnectCloudProjectId:d.walletConnectCloudProjectId,rpcConfig:d.rpcConfig,chains:d.chains,defaultChain:d.defaultChain,store:a,walletList:d.appearance.walletList,shouldEnforceDefaultChainOnConnect:d.shouldEnforceDefaultChainOnConnect,externalWalletConfig:d.externalWallets,appName:d.name??"Privy",walletChainType:d.appearance.walletChainType,setBaseAccountSdk:C}),r.connectors?.on("connectorInitialized",(()=>{e&&clearTimeout(e);let t=r.connectors.walletConnectors.length,n=r.connectors.walletConnectors.reduce(((e,t)=>e+(t.initialized?1:0)),0);n===t?He(!0):e=setTimeout((()=>{console.debug({message:"Unable to initialize all expected connectors before timeout",initialized:n,expected:t}),He(!0)}),1500)})),r.connectors?.initialize().then((()=>{pt()}));let i=await r.getAuthenticatedUser(),s=!!i;d.legal.requireUsersAcceptTerms&&i&&!i.hasAcceptedTerms?(await r.logout(),Ut.setReadyToTrue(!0),er(Re,"logout","onSuccess")):(d.customAuth?.enabled||(Ke(!!i),i&&er(Re,"login","onComplete",{user:i,isNewUser:!1,wasAlreadyAuthenticated:!0,loginMethod:null,loginAccount:null}),v(i)),t?Ge.current=s?"link":"login":n&&!s?(Ge.current="login",we({telegramAuthModalData:{seamlessAuth:!0}}),it("TelegramAuthScreen")):Ut.setReadyToTrue(!!i))}()}),[r,me,y,he]),c((()=>{if(y){if(!f||!f.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType)))return void Ee(!!de);if([...A].some((e=>"privy"===e.walletClientType)))return void Ee(!0);Ee(!!de)}}),[y,f,A,de]),c((()=>{r.connectors?.setWalletList(d.appearance.walletList)}),[d.appearance.walletList.join()]);let ot=()=>{let e=la();return e.inProgress&&e.popupFlow?window.opener.location.origin!==window.location.origin?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Origins between parent and child windows do not match."}):"error"===e.authorizationCode?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Something went wrong. Try again."}):void window.opener.postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}):(e.inProgress&&e.provider.startsWith("privy:")&&!e.popupFlow&&(new BroadcastChannel(vi).postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}),window.close()),!!e.inProgress&&!!e.withPrivyUi&&(r.startAuthFlow(new oa({...e,customOAuthRedirectUrl:d.customOAuthRedirectUrl})),it("OAuthStatusScreen"),!0))},lt=()=>{let e=function(){let e;return(e=function(){let e=new URLSearchParams(window.location.search),t=Number(e.get("id")||""),n=e.get("hash"),r=Number(e.get("auth_date")||""),a=e.get("first_name");if(t&&a&&r&&n)return Object.fromEntries(e.entries())}())?(Ta(),{flowType:"login-url",authData:e}):(e=function(){let e=window.location.hash;if(!e||!e.startsWith("#tgWebAppData"))return;let t=Ca(e.replace("#tgWebAppData=","")),{user:n,auth_date:r,hash:a}=t;return n&&r&&a?t:void 0}())?(Ta(),{flowType:"web-app",authData:e}):void 0}();if(!e||!d.loginMethods.telegram||!d.loginConfig.telegramAuthConfiguration?.seamlessAuthEnabled)return;let t=new Aa;return r.startAuthFlow(t),"login-url"===e.flowType&&(t.meta.telegramWebAppData=void 0,t.meta.telegramAuthResult=e.authData),"web-app"===e.flowType&&(t.meta.telegramAuthResult=void 0,t.meta.telegramWebAppData=e.authData),!0},ct=async(e,t,n,a)=>{if("solana_adapter"!==e)dt(await(r.connectors?.createEthereumWalletConnector({connectorType:e,walletClientType:t}))||null,t,n,a);else{let e=r.connectors?.findSolanaWalletConnector(t);if(!e)return;dt(e,t,n,a)}};async function dt(e,t,n,r){if(!e)return j({status:"disconnected",connectedWallet:null,connectError:new ke("Unable to connect to wallet."),connector:null,connectRetry:Se}),r?.(null,n);j({status:"disconnected",connectedWallet:null,connectError:null,connector:e,connectRetry:Se}),e instanceof Ja&&t&&await e.resetConnection(t),j({connector:e,status:"connecting",connectedWallet:null,connectError:null,connectRetry:()=>dt(e,t,n,r)});try{let t=await e.connect({showPrompt:!0});if((!t||te(t))&&d.shouldEnforceDefaultChainOnConnect&&!d.chains.find((e=>e.id===Number(t?.chainId.replace("eip155:",""))))&&("wallet_connect_v2"!==t?.connectorType||"metamask"!==t?.walletClientType)){j((t=>({...t,connector:e,status:"switching_to_supported_chain",connectedWallet:null,connectError:null,connectRetry:Se})));try{await(t?.switchChain(d.defaultChain.id)),t&&(t.chainId=ne(Ct(d.defaultChain.id)))}catch{console.warn(`Unable to switch to default chain: ${d.defaultChain.id}`)}}return j((e=>({...e,status:"connected",connectedWallet:t,connectError:null,connectRetry:Se}))),t&&er(Re,"connectWallet","onSuccess",{wallet:t}),r?.(t,n)}catch(e){return e instanceof be?(console.warn(e.cause?e.cause:e.message),er(Re,"connectWallet","onError",e.privyErrorCode||_e.GENERIC_CONNECT_WALLET_ERROR)):(console.warn(e),er(Re,"connectWallet","onError",_e.UNKNOWN_CONNECT_WALLET_ERROR)),j((t=>({...t,status:"disconnected",connectedWallet:null,connectError:e}))),r?.(null,n)}}let ut=async(e,t,n)=>{if(null===e||!te(e))return;let a=new ha(r,e,t,n);r.startAuthFlow(a)},ht=async(e,t,n,a="plain")=>{let s=i(Vn);if("transaction"===a&&!s)throw new Ce("useSolanaLedger plugin hook must be mounted");if(null===e||!se(e))return;let o=new pa(e,r,t,n,a,s);r.startAuthFlow(o)},pt=async()=>{let e=new URLSearchParams(window.location.search),t=e.get("privy_connector"),n=e.get("privy_wallet_client"),a="true"===e.get("privy_connect_only");if(!t||!n)return;let i=le({connectorType:t,walletClientType:n});if(!i||!i.isInstalled)return it("LoginFailedScreen");if(!r.connectors)throw new Ce("Connector not initialized");await it(a?"ConnectOnlyStatusScreen":"ConnectionStatusScreen");let s=new URL(window.location.href);s.searchParams.delete("privy_connector"),s.searchParams.delete("privy_wallet_client"),s.searchParams.delete("privy_connect_only"),window.history.pushState({},"",s),ct(t,n,void 0,a?void 0:"solana_adapter"===t?ht:ut)};c((()=>{y&&Ve&&null===f&&r.getAuthenticatedUser().then(v)}),[y,Ve,f,r]);let wt=e=>{if(!Ve)throw er(Re,"linkAccount","onError",_e.MUST_BE_AUTHENTICATED,{linkMethod:e}),new Ce("User must be authenticated before linking an account.")},mt=e=>{if(!Ve||!f)return!1;if("privy"===e.walletClientType)return!0;for(let t of f.linkedAccounts)if("wallet"===t.type&&t.address===e.address&&"privy"!==t.walletClientType)return!0;return!1},yt=()=>{Hi.setState((e=>{let t=r.connectors?.wallets.filter(te).map((e=>({...e,linked:mt(e),loginOrLink:async()=>{if(!await e.isConnected())throw new Ce("Wallet is not connected");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Ce("Cannot link or login with embedded wallet");(async e=>{let t;if(!r.connectors)throw new Ce("Connector not initialized");t="ethereum"===e.type?r.connectors.findWalletConnector(e.connectorType,e.walletClientType)||null:r.connectors.findSolanaWalletConnector(e.walletClientType)||null,j((n=>({...n,connector:t,status:"connected",connectedWallet:e,connectError:null,connectRetry:Se}))),d.captcha.enabledProvider&&!Ve?(we({captchaModalData:{callback:t=>te(e)?ut(e,t):ht(e,t),userIntentRequired:!1,onSuccessNavigateTo:"ConnectionStatusScreen",onErrorNavigateTo:"ErrorScreen"}}),await it("CaptchaScreen")):(te(e)?await ut(e):await ht(e),await it("ConnectionStatusScreen"))})(e)},fund:async t=>{await Ut.fundWallet(e.address,t)},unlink:async()=>{if(!Ve)throw new Ce("User is not authenticated.");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Ce("Cannot unlink an embedded wallet");v(await r.unlinkEthereumWallet(e.address))}})))||[];return re(e.ethereum,t)?{}:{ethereum:t}}))};c((()=>{yt()}),[f?.linkedAccounts,Ve,y]),c((()=>{if(y){if(!r.connectors)throw new Ce("Connector not initialized");yt(),r.connectors.on("walletsUpdated",yt)}}),[y]),c((()=>{[...d.loginMethodsAndOrder?.primary??[],...d.loginMethodsAndOrder?.overflow??[]].filter((e=>e.startsWith("privy:"))).forEach((e=>r.getCrossAppProviderDetails(e.replace("privy:",""))))}),[!!r]);let ft=({transaction:e,sponsor:t,uiOptions:i,fundWalletConfig:s,address:o,signOnly:l})=>new Promise((async(c,u)=>{let{requesterAppId:h}=i||{},p=l?"signTransaction":"sendTransaction",w=o?N(f,o):E(f);if(!w&&o){let n=x(Vi(),o);if(n){if(t)throw new Ce("Cannot sponsor transactions for externally connected wallet.");try{let t=await n.getEthereumProvider(),r={...e,from:o,chainId:e.chainId||Number(n.chainId.replace("eip155:","")),value:void 0!==e.value?Ct(e.value):void 0},a=await t.request({method:"sendTransaction"===p?"eth_sendTransaction":"eth_signTransaction",params:[r]});return er(Re,p,"onSuccess",{hash:a}),void c({hash:a})}catch(e){return er(Re,p,"onError",_e.TRANSACTION_FAILURE),void u(e??new ze("Unable to "+p+e))}}}if(!w)return er(Re,p,"onError",_e.EMBEDDED_WALLET_NOT_FOUND),void u(new Ce("No embedded or connected wallet found for address."));if(!Ve||!f)return er(Re,p,"onError",_e.MUST_BE_AUTHENTICATED),void u(Error("User must be authenticated before signing with a Privy wallet"));let y=w.address,g=w.walletIndex??0,{entropyId:v,entropyIdVerifier:A}=ve(f,w),k=Nt.wallets.find((e=>"privy"===e.walletClientType&&_t(e.address)===_t(y)));if(!k)return er(Re,p,"onError",_e.EMBEDDED_WALLET_NOT_FOUND),void u(Error("Must have a Privy wallet before signing"));let C=await k.getEthereumProvider(),T=await C.request({method:"eth_chainId"}),_=e.chainId?Number(e.chainId):qe(T);(e=>{if(!d.chains.map((e=>e.id)).includes(e))throw new ke(`Chain ID ${e} is not supported. It must be added to the config.supportedChains property of the PrivyProvider.`,_e.UNSUPPORTED_CHAIN_ID)})(_);let b={...e,from:e.from??y,chainId:_},S=await Kr();if(!S||!de)return er(Re,p,"onError",_e.EMBEDDED_WALLET_NOT_FOUND),void u(Error("Must have valid access token and Privy wallet to send transaction"));let I=gr(b.chainId,d.chains,d.rpcConfig,{appId:n.appId}),W=P(w),U=async({transactionRequest:e})=>{try{let n;if(!await Ut.recoverEmbeddedWallet({address:y}))throw er(Re,p,"onError",_e.UNKNOWN_CONNECT_WALLET_ERROR),u(Error("Unable to connect to wallet")),Error("Unable to connect to wallet");if(t){let t=await(async({transactionRequest:e})=>{if(!W)throw new Ce("Sponsoring is only supported for wallets on the TEE stack");if(l)throw new Ce("Cannot sponsor a sign transaction request");let t=e=>null==e?void 0:Ct(e),n=await m(a,(async({message:e})=>await de.signWithUserSigner({accessToken:S,requesterAppId:h,message:e})),{chain_type:"ethereum",method:"eth_sendTransaction",caip2:ne(Ct(e.chainId)),sponsor:!0,params:{transaction:{from:e.from,to:e.to,chain_id:t(e.chainId),data:bt(e.data)?e.data?e.data:Ct(Uint8Array.from(e.data)):void 0,value:t(e.value)}},wallet_id:w.id});if(n.data&&"hash"in n.data)return n.data.hash;throw new ze("Unable to sign transaction")})({transactionRequest:e});return er(Re,"sendTransaction","onSuccess",{hash:t}),t}if(W){let t=e=>null==e?void 0:Ct(e),r=await m(a,(async({message:e})=>await de.signWithUserSigner({accessToken:S,requesterAppId:h,message:e})),{chain_type:"ethereum",method:"eth_signTransaction",params:{transaction:{from:e.from,to:e.to,nonce:t(e.nonce),chain_id:t(e.chainId),data:bt(e.data)?e.data?e.data:Ct(Uint8Array.from(e.data)):void 0,value:t(e.value),type:e.type,gas_limit:t(e.gasLimit??e.gas),gas_price:t(e.gasPrice??e.gas),max_fee_per_gas:t(e.maxFeePerGas),max_priority_fee_per_gas:t(e.maxPriorityFeePerGas)}},wallet_id:w.id});if(!r.data||!("signed_transaction"in r.data))throw new ze("Unable to sign transaction");n=r.data.signed_transaction}else n=await async function({accessToken:e,entropyId:t,entropyIdVerifier:n,transactingWalletIndex:r,walletProxy:a,transactionRequest:i,requesterAppId:s}){return(await a.rpc({entropyId:t,entropyIdVerifier:n,hdWalletIndex:r??0,chainType:"ethereum",accessToken:e,requesterAppId:s,request:{method:"eth_signTransaction",params:[i]}})).response.data}({accessToken:S,entropyId:v,entropyIdVerifier:A,transactingWalletIndex:g,walletProxy:de,transactionRequest:e,requesterAppId:h});if(l)return er(Re,"signTransaction","onSuccess",{signature:n}),n;{let e=await I.sendRawTransaction({serializedTransaction:n});return er(Re,"sendTransaction","onSuccess",{hash:e}),e}}catch(e){throw er(Re,p,"onError",_e.TRANSACTION_FAILURE),e}};if(et({showWalletUIs:i?.showWalletUIs})){let e=l||t?b:await Di(b,I,b.from);try{let t=await U({transactionRequest:e});l?er(Re,"signTransaction","onSuccess",{signature:t}):er(Re,"sendTransaction","onSuccess",{hash:t}),c({hash:t})}catch(e){er(Re,p,"onError",_e.TRANSACTION_FAILURE),u(e)}}else{let e={connectingWalletAddress:y,recoveryMethod:w.recoveryMethod,entropyId:v,entropyIdVerifier:A,onCompleteNavigateTo:"SendTransactionScreen",isUnifiedWallet:W,onFailure:e=>{er(Re,p,"onError",_e.UNKNOWN_CONNECT_WALLET_ERROR),u(e)}},n=(e=>!!e.fundingConfig&&Le(e.fundingConfig.options).length>=1)(d)?De({address:y,appConfig:d,fundWalletConfig:s,methodScreen:"FundingMethodSelectionScreen",chainIdOverride:b.chainId,comingFromSendTransactionScreen:!0}):void 0;we({connectWallet:e,sendTransaction:{transactionRequest:b,transactingWalletIndex:g,transactingWalletAddress:y,entropyId:v,entropyIdVerifier:A,signOnly:l,scanTransaction:async()=>{let e=await Di(b,I,b.from);return await r.scanTransaction({metadata:{domain:d.embeddedWallets.transactionScanning.domain},chain_id:e.chainId.toString(),request:{method:"eth_sendTransaction",params:[{from:e.from,to:e.to,value:e.value?.toString(),gas:e.gas?.toString(),gasPrice:e.gasPrice?.toString(),nonce:e.nonce?.toString(),data:e.data}]}})},getIsSponsored:async()=>!!t,onConfirm:({transactionRequest:e})=>U({transactionRequest:e}),onSuccess:e=>{l?er(Re,"signTransaction","onSuccess",{signature:e.hash}):er(Re,"sendTransaction","onSuccess",{hash:e.hash}),c(e)},onFailure:e=>{er(Re,p,"onError",_e.TRANSACTION_FAILURE),u(e)},uiOptions:i||{},fundWalletConfig:s,requesterAppId:h},funding:n}),it("EmbeddedWalletConnectingScreen")}}));function vt(){return new Promise((async(e,t)=>{let n=await Kr();if(!n||!de)throw Error("Must have valid access token to enroll in MFA");try{await de.verifyMfa({accessToken:n}),e()}catch(e){t(e)}}))}let kt=e=>e?.linkedAccounts.filter((e=>null!==e.latestVerifiedAt&&!("wallet"===e.type&&"privy"===e.walletClientType))).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0],St=e=>{let t=f?.linkedAccounts.filter((t=>t.type===e)).length??0,{displayName:n,loginMethod:r}=Ri(e);if("passkey"===e&&t>=5||"passkey"!==e&&t>=1)throw er(Re,"linkAccount","onError",_e.CANNOT_LINK_MORE_OF_TYPE,{linkMethod:r}),new Ce(`User already has an account of type ${n} linked.`)};async function It({showAutomaticRecovery:e=!1,legacySetWalletPasswordFlow:t=!1}){I(null);let n=t?"setWalletPassword":"setWalletRecovery";if(!Ve||!f)throw er(Re,n,"onError",_e.MUST_BE_AUTHENTICATED),Error("User must be authenticated before adding recovery method to Privy wallet");let r=b(f);if(!r||!de)throw er(Re,n,"onError",_e.EMBEDDED_WALLET_NOT_FOUND),Error("Must have a Privy wallet to add a recovery method");let a=P(r);if(a)throw er(Re,n,"onError",_e.UNSUPPORTED_WALLET_TYPE),new Ce("User owned wallet recovery is only supported for on-device execution and this app uses TEE execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");try{await vt()}catch(e){throw er(Re,n,"onError",_e.MISSING_MFA_CREDENTIALS),e}return new Promise(((i,s)=>{let o="user-passcode"===r.recoveryMethod,l=Ei({walletAction:"update",availableRecoveryMethods:d.embeddedWallets.userOwnedRecoveryOptions,legacySetWalletPasswordFlow:t,isResettingPassword:o,showAutomaticRecovery:e}),{entropyId:c,entropyIdVerifier:u}=ve(f),h={recoveryMethod:r.recoveryMethod,connectingWalletAddress:r.address,onCompleteNavigateTo:l,shouldForceMFA:!1,entropyId:c,isUnifiedWallet:a,entropyIdVerifier:u,onFailure:e=>{er(Re,n,"onError",_e.UNKNOWN_CONNECT_WALLET_ERROR),s(e)}};we({setWalletPassword:{onSuccess:e=>{er(Re,n,"onSuccess",{method:"user-passcode",wallet:e}),i(e)},onFailure:e=>{er(Re,n,"onError",_e.USER_EXITED_SET_PASSWORD_FLOW),s(e)},callAuthOnSuccessOnClose:!1},recoverWallet:{entropyId:c,entropyIdVerifier:u,onFailure:s},connectWallet:h,recoverySelection:{isInAccountCreateFlow:!1,isResettingPassword:o,shouldCreateEth:!1,shouldCreateSol:!1}}),it("EmbeddedWalletConnectingScreen")}))}async function Pt({appId:e,action:t}){let n=await Kr();if("link"===t&&!n)throw er(Re,"linkAccount","onError",_e.MUST_BE_AUTHENTICATED,{linkMethod:`privy:${e}`}),new Ce("User must be authenticated before linking an account.");if("login"===t&&n)throw er(Re,"login","onError",_e.UNKNOWN_AUTH_ERROR),new Ce("Attempted to log in, but user is already logged in. Use a `link` helper instead.");$e.current=`privy:${e}`,Ge.current=t;let a=Et();return r.createAnalyticsEvent({eventName:"cross_app_auth_started",payload:{providerAppId:e}}),new Promise((async(n,i)=>{let{name:s,logoUrl:o}=await Ci({api:r.api,providerAppId:e,requesterAppId:d.id});we({crossAppAuth:{appId:e,name:s,logoUrl:o,action:t,popup:a,onSuccess:n,onError:i}}),it("CrossAppAuthScreen")}))}let Wt={ready:y,authenticated:Ve,user:f,walletConnectors:r.connectors||null,connectWallet:e=>{e&&"target"in e&&e&&(e=void 0),we({externalConnectWallet:{walletList:e?.walletList&&e?.walletList.length>0?e.walletList:void 0,walletChainType:e?.walletChainType,description:e?.description,hideHeader:e?.hideHeader}}),it("ConnectOnlyLandingScreen")},linkWallet:e=>(e&&"target"in e&&e&&(e=void 0),wt("siwe"),$e.current="siwe",Ge.current="link",we({...pe,externalConnectWallet:{...pe.externalConnectWallet,walletList:e?.walletList,walletChainType:e?.walletChainType,description:e?.description||`Link a wallet to your ${d?.name} account`}}),it("AuthenticateWithWalletScreen")),startCrossAppAuthFlow:Pt,linkEmail:()=>{wt("email"),St("email"),$e.current="email",Ge.current="link",it("LinkEmailScreen")},linkPhone:()=>{wt("sms"),St("phone"),$e.current="sms",Ge.current="link",it("LinkPhoneScreen")},linkGoogle:async()=>{wt("google"),St("google_oauth"),Ge.current="link",await Ut.initLoginWithOAuth("google")},linkTwitter:async()=>{wt("twitter"),St("twitter_oauth"),Ge.current="link",await Ut.initLoginWithOAuth("twitter")},linkTwitch:async()=>{wt("twitch"),St("twitch_oauth"),Ge.current="link",await Ut.initLoginWithOAuth("twitch")},linkDiscord:async()=>{wt("discord"),St("discord_oauth"),Ge.current="link",await Ut.initLoginWithOAuth("discord")},linkGithub:async()=>{wt("github"),St("github_oauth"),Ge.current="link",await Ut.initLoginWithOAuth("github")},linkSpotify:async()=>{wt("spotify"),St("spotify_oauth"),Ge.current="link",await Ut.initLoginWithOAuth("spotify")},linkInstagram:async()=>{wt("instagram"),St("instagram_oauth"),Ge.current="link",await Ut.initLoginWithOAuth("instagram")},linkTiktok:async()=>{wt("tiktok"),St("tiktok_oauth"),Ge.current="link",await Ut.initLoginWithOAuth("tiktok")},linkLine:async()=>{wt("line"),St("line_oauth"),Ge.current="link",await Ut.initLoginWithOAuth("line")},linkLinkedIn:async()=>{wt("linkedin"),St("linkedin_oauth"),Ge.current="link",await Ut.initLoginWithOAuth("linkedin")},linkApple:async()=>{wt("apple"),St("apple_oauth"),Ge.current="link",await Ut.initLoginWithOAuth("apple")},linkPasskey:async()=>{wt("passkey"),St("passkey"),await Ut.initLinkWithPasskey(),it("LinkPasskeyScreen")},linkTelegram:async e=>{if(wt("telegram"),St("telegram"),Ge.current="link",$e.current="telegram",e?.launchParams)if(e.launchParams.initDataRaw){let t=new Aa;r.startAuthFlow(t),t.meta.telegramAuthResult=void 0,t.meta.telegramWebAppData=Ca(e.launchParams.initDataRaw),we({telegramAuthModalData:{seamlessAuth:!0}}),it("TelegramAuthScreen")}else er(Re,"linkAccount","onError",_e.INVALID_DATA,{linkMethod:"telegram"});else await Ut.initLoginWithTelegram();it("TelegramAuthScreen")},linkFarcaster:async()=>{wt("farcaster"),St("farcaster"),await Ut.initLoginWithFarcaster(),Ge.current="link",$e.current="farcaster",it("FarcasterConnectStatusScreen")},updateEmail:()=>{if(wt("email"),!f?.email)throw new Ce("User does not have an email linked to their account.");Ge.current="update",$e.current="email",it("UpdateEmailScreen")},updatePhone:()=>{if(wt("sms"),!f?.phone)throw new Ce("User does not have a phone number linked to their account.");Ge.current="update",$e.current="sms",it("UpdatePhoneScreen")},login:async e=>{e&&"target"in e&&e&&(e=void 0);let t="Attempted to log in, but user is already logged in. Use a `link` helper instead.";if(!y){let e=await new Promise((e=>{ye((t=>e.bind(t)))}));if(ye(null),e)return void console.warn(t)}!f||f.isGuest?(Ge.current="login",we({login:e}),it("LandingScreen")):console.warn(t)},connectOrCreateWallet:async()=>{y||(await new Promise((e=>{ye((()=>e))})),ye(null)),Ve?console.warn("User must be unauthenticated to `connectOrCreateWallet`"):(Ge.current="connect-or-create",it("ConnectOrCreateScreen"))},logout:async()=>{if(Ge.current=null,$e.current=null,f&&r.clearProviderAcccessTokens(f),I(null),await r.logout(),f&&de)try{await de.clearMfa({userId:f.id})}catch(e){}v(null),Ke(!1),B({status:"initial"}),$({status:"initial"}),q({status:"initial"}),Y({status:"initial"}),Q({status:"initial"}),ce({status:"initial"}),er(Re,"logout","onSuccess"),p(!1),Me.del(rt),Me.del(at(d.id))},getAccessToken:h((async()=>{let e=await r.getCustomerAccessToken();return e&&!Ve&&Ke(!0),e}),[r,Ve]),unlinkWallet:async e=>{let t;return v(t=e.startsWith("0x")?await r.unlinkEthereumWallet(e):await r.unlinkSolanaWallet(e)),t},unlinkEmail:async e=>{let t=await r.unlinkEmail(e);return v(t),t},unlinkPhone:async e=>{let t=await r.unlinkPhone(e);return v(t),t},unlinkGoogle:async e=>{let t=await r.unlinkOAuth("google",e);return v(t),t},unlinkTwitter:async e=>{let t=await r.unlinkOAuth("twitter",e);return v(t),t},unlinkTwitch:async e=>{let t=await r.unlinkOAuth("twitch",e);return v(t),t},unlinkDiscord:async e=>{let t=await r.unlinkOAuth("discord",e);return v(t),t},unlinkGithub:async e=>{let t=await r.unlinkOAuth("github",e);return v(t),t},unlinkSpotify:async e=>{let t=await r.unlinkOAuth("spotify",e);return v(t),t},unlinkInstagram:async e=>{let t=await r.unlinkOAuth("instagram",e);return v(t),t},unlinkTiktok:async e=>{let t=await r.unlinkOAuth("tiktok",e);return v(t),t},unlinkLine:async e=>{let t=await r.unlinkOAuth("line",e);return v(t),t},unlinkLinkedIn:async e=>{let t=await r.unlinkOAuth("linkedin",e);return v(t),t},unlinkApple:async e=>{let t=await r.unlinkOAuth("apple",e);return v(t),t},unlinkFarcaster:async e=>{let t=await r.unlinkFarcaster(e);return v(t),t},unlinkTelegram:async e=>{let t=await r.unlinkTelegram(e);return v(t),t},unlinkPasskey:async e=>{let t=await Kr();if(!t)throw Error("Must have valid access token to enroll in MFA");if(!de)throw Error("Wallet proxy not initialized.");let n=d.passkeys.shouldUnenrollMfaOnUnlink;await de.unlinkPasskeyAccount({credentialId:e,accessToken:t,removeAsMfa:n});let a=await r.getAuthenticatedUser();return v(a),a},unlinkCrossAppAccount:async({subject:e})=>{let t=f?.linkedAccounts.find((t=>"cross_app"===t.type&&t.subject===e))?.providerApp;if(!t)throw new Ce("Invalid subject");r.storeProviderAccessToken(t.id,null);let n=await r.unlinkOAuth(`privy:${t.id}`,e);return v(n),n},setWalletRecovery:async e=>It({legacySetWalletPasswordFlow:!1,showAutomaticRecovery:e?.showAutomaticRecovery??!1}),setWalletPassword:async()=>It({legacySetWalletPasswordFlow:!0,showAutomaticRecovery:!1}),signMessage:(e,t)=>new Promise((async(n,i)=>{let{requesterAppId:s}=t?.uiOptions||{},o=e.message,l=t?.address?N(f,t.address):E(f);if(!l&&void 0!==t?.address){let e=x(Vi(),t.address);if(e)try{let t=await e.getEthereumProvider(),r=await t.request({method:"personal_sign",params:[o,e.address]});return er(Re,"signMessage","onSuccess",{signature:r}),void n({signature:r})}catch(e){return er(Re,"signMessage","onError",_e.UNABLE_TO_SIGN),void i(e??new ze("Unable to sign message"))}}if(!l)throw new Ce("No embedded or connected wallet found for address.");if(!Ve||!f)return er(Re,"signMessage","onError",_e.MUST_BE_AUTHENTICATED),void i(Error("User must be authenticated before signing with a Privy wallet"));let c=l.address,d=l.walletIndex??0,{entropyId:u,entropyIdVerifier:h}=ve(f,l),p=P(l);if("string"!=typeof o||o.length<1)return er(Re,"signMessage","onError",_e.INVALID_MESSAGE),void i(Error("Message must be a non-empty string"));let w=async()=>{let t;if(!Ve)throw Error("User must be authenticated before signing with a Privy wallet");let n=await Kr();if(!de||!n||!await Ut.recoverEmbeddedWallet({address:c}))throw Error("Unable to connect to wallet");if(r.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_started",payload:{walletAddress:c,requesterAppId:s}}),p){let r=bt(e.message,{strict:!0}),i=await m(a,(async({message:e})=>await de.signWithUserSigner({accessToken:n,requesterAppId:s,message:e})),{chain_type:"ethereum",method:"personal_sign",params:r?{message:o.slice(2),encoding:"hex"}:{message:o,encoding:"utf-8"},wallet_id:l.id});if(!i.data||!("signature"in i.data))throw new ze("Unable to sign message");t=i.data.signature}else{let{response:e}=await de.rpc({accessToken:n,entropyId:u,entropyIdVerifier:h,chainType:"ethereum",hdWalletIndex:d,requesterAppId:s,request:{method:"personal_sign",params:[o,c]}});t=e.data}return r.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_completed",payload:{walletAddress:c,requesterAppId:s}}),t};if(et({showWalletUIs:t?.uiOptions?.showWalletUIs}))try{let e=await w();er(Re,"signMessage","onSuccess",{signature:e}),n({signature:e})}catch(e){er(Re,"signMessage","onError",_e.UNABLE_TO_SIGN),i(e??new ze("Unable to sign message"))}else we({signMessage:{method:"personal_sign",data:o,confirmAndSign:w,onSuccess:e=>{er(Re,"signMessage","onSuccess",{signature:e}),n({signature:e})},onFailure:e=>{er(Re,"signMessage","onError",_e.UNABLE_TO_SIGN),i(e)},uiOptions:t?.uiOptions||{}},connectWallet:{recoveryMethod:l.recoveryMethod,connectingWalletAddress:c,entropyId:u,entropyIdVerifier:h,onCompleteNavigateTo:"SignRequestScreen",isUnifiedWallet:p,onFailure:e=>{er(Re,"signMessage","onError",_e.UNKNOWN_CONNECT_WALLET_ERROR),i(e)}}}),it("EmbeddedWalletConnectingScreen")})),signTypedData:(e,t)=>new Promise((async(n,i)=>{let{requesterAppId:s}=t?.uiOptions||{},o=t?.address?N(f,t.address):E(f);if(!o&&t?.address){let r=x(Vi(),t.address);if(r)try{let t=await r.getEthereumProvider(),a=oe(e),i=await t.request({method:"eth_signTypedData_v4",params:[r.address,a]});return er(Re,"signTypedData","onSuccess",{signature:i}),void n({signature:i})}catch(e){return er(Re,"signTypedData","onError",_e.UNABLE_TO_SIGN),void i(e??new ze("Unable to sign typed data "+e))}}if(!o)throw new Ce("No embedded or connected wallet found for address.");if(!Ve||!f)return er(Re,"signTypedData","onError",_e.MUST_BE_AUTHENTICATED),void i(Error("User must be authenticated before signing with a Privy wallet"));let l=o.address,c=o.walletIndex??0,{entropyId:d,entropyIdVerifier:u}=ve(f,o),h=P(o),p=oe(e),w=async()=>{let e;if(!Ve)throw Error("User must be authenticated before signing with a Privy wallet");let t=await Kr();if(!de||!t||!await Ut.recoverEmbeddedWallet({address:l}))throw Error("Unable to connect to wallet");if(r.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_started",payload:{walletAddress:l,requesterAppId:s}}),h){let{domain:n,types:r,primaryType:i,message:l}=p,c=await m(a,(async({message:e})=>await de.signWithUserSigner({accessToken:t,requesterAppId:s,message:e})),{chain_type:"ethereum",method:"eth_signTypedData_v4",params:{typed_data:{domain:n,types:r,primary_type:i,message:l}},wallet_id:o.id});if(!c.data||!("signature"in c.data))throw new ze("Unable to sign message");e=c.data.signature}else{let{response:n}=await de.rpc({accessToken:t,entropyId:d,entropyIdVerifier:u,chainType:"ethereum",hdWalletIndex:c,requesterAppId:s,request:{method:"eth_signTypedData_v4",params:[l,p]}});e=n.data}return r.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_completed",payload:{walletAddress:l,requesterAppId:s}}),e};if(et({showWalletUIs:t?.uiOptions?.showWalletUIs}))try{let e=await w();er(Re,"signTypedData","onSuccess",{signature:e}),n({signature:e})}catch(e){er(Re,"signTypedData","onError",_e.UNABLE_TO_SIGN),i(e??new ze("Unable to sign message"))}else we({signMessage:{method:"eth_signTypedData_v4",data:p,confirmAndSign:w,onSuccess:e=>{er(Re,"signTypedData","onSuccess",{signature:e}),n({signature:e})},onFailure:e=>{er(Re,"signTypedData","onError",_e.UNABLE_TO_SIGN),i(e)},uiOptions:t?.uiOptions||{}},connectWallet:{recoveryMethod:o.recoveryMethod,connectingWalletAddress:o.address,entropyId:d,isUnifiedWallet:h,entropyIdVerifier:u,onCompleteNavigateTo:"SignRequestScreen",onFailure:e=>{er(Re,"signMessage","onError",_e.UNKNOWN_CONNECT_WALLET_ERROR),i(e)}}}),it("EmbeddedWalletConnectingScreen")})),sendTransaction:async(e,t)=>await ft({transaction:e,sponsor:t?.sponsor,uiOptions:t?.uiOptions,fundWalletConfig:t?.fundWalletConfig,address:t?.address,signOnly:!1}),signTransaction:async(e,t)=>({signature:(await ft({transaction:e,uiOptions:t?.uiOptions,address:t?.address,signOnly:!0})).hash}),exportWallet:e=>new Promise((async(t,a)=>{if(!Ve||!f)return void a(Error("User must be authenticated before exporting their Privy wallet"));e&&"target"in e&&e&&(e=void 0);let i=e?.address?N(f,e.address):E(f);if(!i)return void a(new Ce("User must have an embedded wallet."));let s=i.address,{entropyId:o,entropyIdVerifier:l}=ve(f,i),c=P(i);if(!s)return void a(Error("User does not have an HD Ethereum wallet. To export an imported wallet, pass the `address` of the wallet to `exportWallet`."));if(!Tt(s))return void a(Error("Must provide a valid Ethereum address."));let d={recoveryMethod:i.recoveryMethod,connectingWalletAddress:i.address,isUnifiedWallet:c,entropyId:o,entropyIdVerifier:l,onCompleteNavigateTo:"EmbeddedWalletKeyExportScreen",onFailure:a,shouldForceMFA:!0};we(pe),await Kr()&&de?de?Fe(i)?(we({keyExport:{appId:n.appId,appClientId:n.clientId,origin:r.apiUrl,address:i.address,entropyId:o,entropyIdVerifier:l,hdWalletIndex:i.walletIndex,chainType:i.chainType,walletId:i.id,isUnifiedWallet:c,imported:i.imported,onSuccess:t,onFailure:a},connectWallet:d}),it("EmbeddedWalletConnectingScreen")):a(Error(`Export is not supported for ${i.chainType} wallets`)):a(Error("Must have a Privy wallet before exporting")):a(Error("Must have valid access token to enroll in MFA"))})),promptMfa:vt,async init(e){switch(e){case"sms":return void await r.initMfaSmsVerification();case"passkey":return await r.initMfaPasskeyVerification();case"totp":return;default:throw Error(`Unsupported MFA method: ${e}`)}},async submit(e,t){switch(e){case"totp":case"sms":if("string"!=typeof t)throw new Ce("Invalid MFA code");Ne.current?.resolve({mfaMethod:e,mfaCode:t,relyingParty:window.origin}),await new Promise(((e,t)=>{Oe.current={resolve:e,reject:t}}));break;case"passkey":if("string"==typeof t)throw new Ce("Invalid authenticator response");let n=await import("@simplewebauthn/browser"),r=qi(await n.startAuthentication({optionsJSON:t}));Ne.current?.resolve({mfaMethod:e,mfaCode:r,relyingParty:window.origin}),await new Promise(((e,t)=>{Oe.current={resolve:e,reject:t}}));break;default:throw Ne.current?.reject(new Ce("Unsupported MFA method")),new Ce(`Unsupported MFA method: ${e}`)}},cancel(){Ne.current?.reject(new Ce("MFA canceled"))},async initEnrollmentWithSms(e){let t=await Kr();if(!t||!de)throw Error("Must have valid access token to enroll in MFA");await de.initEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber})},enrollInMfa:e=>new Promise(((t,n)=>{if(!e)return Ut.closePrivyModal(),void t();d.mfa.noPromptOnMfaRequired&&console.warn("[Privy Warning] Triggering the 'showMfaEnrollmentModal' function when 'noPromptOnMfaRequired' is set to true is unexpected. If this is intentional, ensure that you are building custom UIs for MFA verification."),we({mfaEnrollmentFlow:{mfaMethods:d.mfa.methods,shouldUnlinkOnUnenrollMfa:d.passkeys.shouldUnlinkOnUnenrollMfa,onSuccess:t,onFailure:n}}),it("MfaEnrollmentFlowScreen")})),async initEnrollmentWithTotp(){let e=await Kr();if(!e||!de)throw Error("Must have valid access token to enroll in MFA");let t=await de.initEnrollMfa({method:"totp",accessToken:e});return{secret:t.secret,authUrl:t.authUrl}},async submitEnrollmentWithSms(e){let t=await Kr();if(!t||!de)throw Error("Must have valid access token to enroll in MFA");await de.submitEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber,code:e.mfaCode}),v(await r.getAuthenticatedUser())},async submitEnrollmentWithTotp(e){let t=await Kr();if(!t||!de)throw Error("Must have valid access token to enroll in MFA");await de.submitEnrollMfa({method:"totp",accessToken:t,code:e.mfaCode}),v(await r.getAuthenticatedUser())},async initEnrollmentWithPasskey(){},async submitEnrollmentWithPasskey({credentialIds:e},t={}){let n=await Kr();if(!n||!de)throw Error("Must have valid access token to enroll in MFA");await de.submitEnrollMfa({method:"passkey",accessToken:n,credentialIds:e,removeForLogin:t.removeForLogin}),v(await r.getAuthenticatedUser())},async unenroll(e,t={}){let n=await Kr();if(!n||!de)throw Error("Must have valid access token to remove MFA");"passkey"===e?await de.submitEnrollMfa({method:"passkey",accessToken:n,credentialIds:[],removeForLogin:t.removeForLogin}):await de.unenrollMfa({method:e,accessToken:n}),v(await r.getAuthenticatedUser())},requestFarcasterSignerFromWarpcast:async()=>{let e=await Kr(),t=f?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!e)throw Error("Must have valid access token to connect with Farcaster");if(!de||!t)throw Error("Must have an embedded wallet to use Farcaster signers");if(P(t))throw new Ce("Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");if(!f?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await Ut.recoverEmbeddedWallet({address:t.address}))throw Error("Unable to connect to wallet");let n=await de.initFarcasterSigner({address:t.address,hdWalletIndex:null,accessToken:e,mfaCode:null,mfaMethod:null,relyingParty:window.origin});"approved"===n.status&&v(await r.getAuthenticatedUser()||f||null),we({farcasterSigner:n}),it("FarcasterSignerStatusScreen")},getFarcasterSignerPublicKey:async()=>{let e,t=await Kr(),n=f?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!de||!n)throw Error("Must have an embedded wallet to use Farcaster signers");if(P(n))throw new Ce("Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");if(!f?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await Ut.recoverEmbeddedWallet({address:n.address}))throw Error("Unable to connect to wallet");if(!f.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");return e=f.farcaster.signerPublicKey.slice(2),Uint8Array.from(e.match(/.{1,2}/g).map((e=>parseInt(e,16))))},signFarcasterMessage:async e=>{let t=await Kr(),n=f?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!de||!n)throw Error("Must have an embedded wallet to use Farcaster signers");if(P(n))throw new Ce("Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");if(!f?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await Ut.recoverEmbeddedWallet({address:n.address}))throw Error("Unable to connect to wallet");if(!f.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");let r=await import("@simplewebauthn/browser"),a=await de.signFarcasterMessage({address:n.address,hdWalletIndex:null,accessToken:t,mfaCode:null,mfaMethod:null,payload:{hash:r.bufferToBase64URLString(e)},fid:BigInt(f.farcaster.fid),relyingParty:window.origin});return new Uint8Array(r.base64URLStringToBuffer(a.signature))},signMessageWithCrossAppWallet(e,{address:t,chainId:n}){let a=f?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return Ti({user:f,client:r,address:t,requesterAppId:d.id,request:{method:a?"privy_signSmartWalletMessage":"personal_sign",params:[e,t],chainId:n},reconnect:Pt})},signTypedDataWithCrossAppWallet(e,{address:t,chainId:n}){let a=f?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t)))),i=oe(e);return Ti({user:f,client:r,address:t,requesterAppId:d.id,request:{method:a?"privy_signSmartWalletTypedData":"eth_signTypedData_v4",params:[t,i],chainId:n},reconnect:Pt})},sendTransactionWithCrossAppWallet(e,{address:t}){let n=f?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return Ti({user:f,client:r,address:t,requesterAppId:d.id,request:{method:n?"privy_sendSmartWalletTx":"eth_sendTransaction",params:[e],chainId:e.chainId},reconnect:Pt})},signTransactionWithCrossAppWallet(e,{address:t}){let n=f?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return Ti({user:f,client:r,address:t,requesterAppId:d.id,request:{method:n?"privy_signSmartWalletTx":"eth_signTransaction",params:[e],chainId:e.chainId},reconnect:Pt})},isModalOpen:u||!!w,mfaMethods:d.mfa.methods};Ji=Wt.signMessage,Qi=Wt.signTypedData,Xi=async(e,t)=>await ft({transaction:e,...t,signOnly:!1}),Zi=async(e,t)=>({signature:(await ft({transaction:e,...t,signOnly:!0})).hash});let Ut={privy:a,setAuthenticated:Ke,setUser:v,setIsNewUser:_,isNewUserThisSession:T,pendingTransaction:null,walletConnectionStatus:D,setWalletConnectionStatus:j,connectors:r.connectors?.walletConnectors??[],rpcConfig:d.rpcConfig,chains:d.chains,appId:n.appId,showFiatPrices:"native-token"!==d.embeddedWallets.priceDisplay.primary,clientAnalyticsId:r.clientAnalyticsId,onCustomAuthAuthenticated:st,hideWalletUIs:Ye,isHeadlessSigning:h(et,[d.embeddedWallets.showWalletUIs]),emailOtpState:H,setEmailOtpState:B,smsOtpState:K,setSmsOtpState:$,oAuthState:J,setOAuthState:Q,telegramAuthState:Z,setTelegramAuthState:ce,siweState:G,setSiweState:Y,isHeadlessOAuthLoading:F,baseAccountSdk:k,setBaseAccountSdk:C,nativeTokenSymbolForChainId:e=>d.chains.find((t=>t.id===Number(e)))?.nativeCurrency.symbol,initializeWalletProxy:async e=>{if(de)return de;let t=new Promise((e=>{ge.current=e})),n=new Promise((t=>setTimeout((()=>t(null)),e))),r=await Promise.race([t,n]);return ge.current=null,r},getAuthFlow:()=>r.authFlow,getAuthMeta:()=>r.authFlow?.meta,client:r,closePrivyModal:async(e={shouldCallAuthOnSuccess:!0,isSuccess:!1})=>{let t,a=y&&Ve&&f;if(a&&$e.current&&(t=kt(f)),"login"===Ge.current)e.shouldCallAuthOnSuccess&&a&&$e.current?er(Re,"login","onComplete",{user:f,isNewUser:T,wasAlreadyAuthenticated:!1,loginMethod:$e.current,loginAccount:t??null}):er(Re,"login","onError",_e.USER_EXITED_AUTH_FLOW);else if("link"===Ge.current&&t)e.isSuccess&&a&&$e.current?er(Re,"linkAccount","onSuccess",{user:f,linkMethod:$e.current,linkedAccount:t}):$e.current&&er(Re,"linkAccount","onError",_e.USER_EXITED_LINK_FLOW,{linkMethod:$e.current});else if("update"===Ge.current&&t)e.isSuccess&&a&&$e.current?er(Re,"update","onSuccess",{user:f,updateMethod:$e.current,updatedAccount:t}):$e.current&&er(Re,"update","onError",_e.USER_EXITED_UPDATE_FLOW,{linkMethod:$e.current});else if("connect-or-create"===Ge.current){let e=Vi();e[0]?er(Re,"connectOrCreateWallet","onSuccess",{wallet:e[0]}):er(Re,"connectOrCreateWallet","onError",_e.USER_EXITED_AUTH_FLOW)}let s=S&&Wi.has(S),o="ErrorScreen"===S&&pe.errorModalData&&Wi.has(pe.errorModalData.previousScreen);if((s||o)&&pe.funding){let e,t=Wi.get(S)??null;if(o&&pe.funding?.onError){let e=pe.errorModalData?.error,t=e?.privyErrorCode||_e.UNKNOWN_FUNDING_ERROR,n=new Ce(e?.message||"Funding failed",e,t);pe.funding?.onError?.(n)}if("solana"===pe.funding.chainType){let n=d.solanaRpcs[pe.funding.chain];if(!n)return void console.warn("Unable to load solana rpc, skipping balance");if(i(Hn))try{e=await Ni({rpc:n.rpc,address:pe.funding.address})}catch{console.error("Unable to pull wallet balance")}else console.warn("Unable to load solana plugin, skipping balance");er(Re,"fundSolanaWallet","onUserExited",{address:pe.funding.address,fundingMethod:t,chain:pe.funding.chain,balance:e})}else{let r=gr(pe.funding.chain.id,d.chains,d.rpcConfig,{appId:n.appId});try{e=await r.getBalance({address:pe.funding.address})}catch{console.error("Unable to pull wallet balance")}er(Re,"fundWallet","onUserExited",{address:pe.funding.address,chain:pe.funding.chain,fundingMethod:t,balance:e}),function(e,t){if(e.onComplete)switch(t){case"external":e.fundingResult?e.onComplete({...e.fundingResult,fundingMethod:t}):e.onComplete({status:"cancelled",address:e.address,fundingMethod:t,amount:e.amount});break;case null:e.onComplete({status:"cancelled",address:e.address,fundingMethod:void 0,amount:e.amount});break;default:e.onComplete({status:"completed",address:e.address,fundingMethod:t,amount:e.amount})}}(pe.funding,t)}}we((e=>({...e,externalConnectWallet:{}}))),Ge.current=null,$e.current=null,_(!1),p(!1),j({status:"disconnected",connectedWallet:null,connector:null,connectError:null,connectRetry:()=>{}}),setTimeout((()=>{r.authFlow=void 0}),200)},openPrivyModal:it,connectWallet:dt,initLoginWithWallet:async(e,t,n,r)=>{te(e)?($e.current="siwe",ut(e,t,n)):($e.current="siws",ht(e,t,n,r))},loginWithWallet:async()=>{let e,t,n;if(!y)throw new We;if(r.authFlow instanceof ha?e="siwe":r.authFlow instanceof pa&&(e="siws"),!e)throw new Ce("Must initialize SIWE/SIWS flow first.");if(null!==await r.getAccessToken())try{({user:t}=await r.link()),$e.current=e}catch(t){throw er(Re,"linkAccount","onError",t.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{({user:t,isNewUser:n}=await r.authenticate()),$e.current=e}catch(e){throw er(Re,"login","onError",e.privyErrorCode||_e.GENERIC_CONNECT_WALLET_ERROR),e}v(t||f||null),_(n||!1),Ke(!0)},delegateWallet:async({address:e,chainType:t,showDelegationUIs:n})=>new Promise((async(r,a)=>{let i=await Kr();if(!Ve||!f||!i)throw new Ce("User must be authenticated and have an embedded wallet to delegate actions.");if("solana"!==t&&"ethereum"!==t)throw new Ce("Only Solana and Ethereum embedded wallets are supported for delegation and revocation.");let s=Ut.walletProxy??await Ut.initializeWalletProxy(15e3);if(!s)throw new Ce("Wallet proxy not initialized.");if((({address:e,user:t})=>!!fi(t).find((t=>t.address===e)))({address:e,user:f}))return r();let o=N(f,e);if(!o)throw new Ce("Address to delegate is not associated with current user.");if(P(o))throw new Ce("useDelegatedActions is only supported for on-device execution and this app uses TEE execution. Use the useSessionSigners hook to provision server side access on behalf of your users. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");let l=yi({address:e,user:f}),c=gi({address:e,user:f}),d=async()=>{await s.createDelegatedAction({accessToken:i,rootWallet:c,delegatedWallets:[l]}),await Ut.refreshSessionAndUser()};if(await Ut.recoverEmbeddedWallet({address:e}),n)we({delegatedActions:{consent:{address:e,onDelegate:d,onSuccess:async()=>{r()},onError:async e=>{a(e)}}}}),it("DelegatedActionsConsentScreen");else try{await d(),r()}catch(e){a(e)}})),revokeDelegatedWallets:async({showDelegationUIs:e})=>new Promise((async(t,n)=>{if(!Ve||!f)throw new Ce("User must be authenticated and have an embedded wallet to revoke a delegated wallet.");let a=fi(f);if(0===a.length)throw new Ce("User has no delegated wallets to revoke.");if(a.some(P))throw new Ce("useDelegatedActions is only supported for on-device execution and this app uses TEE execution. Use the useSessionSigners hook to provision server side access on behalf of your users. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");let i=async()=>{await r.revokeDelegatedWallet(),await Ut.refreshSessionAndUser()};if(e)we({delegatedActions:{revoke:{onRevoke:i,onSuccess:async()=>{t()},onError:async e=>{n(e)}}}}),it("DelegatedActionsRevokeScreen");else try{await i(),t()}catch(e){n(e)}})),initLoginWithFarcaster:async(e,t)=>{let n=new Zr(e,t);r.startAuthFlow(n);try{$e.current="farcaster",await n.initializeFarcasterConnect()}catch(e){throw"login"===Ge.current?er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR):"link"===Ge.current&&er(Re,"linkAccount","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"farcaster"}),e}},loginWithFarcaster:async()=>{let e,t;if(!y)throw new We;if(!(r.authFlow instanceof Zr))throw new Ce("Must initialize Farcaster flow first.");if(null!==await r.getAccessToken())try{({user:e}=await r.link()),$e.current="farcaster"}catch(e){throw er(Re,"linkAccount","onError",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:"farcaster"}),e}else try{({user:e,isNewUser:t}=await r.authenticate()),$e.current="farcaster"}catch(e){throw er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}v(e||null),_(t||!1),Ke(!0)},async crossAppAuthFlow({appId:e,popup:t,action:n}){let a=`privy:${e}`;$e.current=a;let{url:i,stateCode:s,codeVerifier:o}=await async function({api:e,appId:t}){let n=aa(),r=ia(),a=await sa(n);try{let{url:i}=await e.post(Lt,{provider:`privy:${t}`,redirect_to:window.location.href,code_challenge:a,state_code:r});return{url:i,stateCode:r,codeVerifier:n}}catch(e){throw Te(e)}}({api:r.api,appId:e});if(!i)throw r.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:"Unable to open cross-app auth popup",appId:e}}),new Ce("No authorization URL returned for cross-app auth.");try{let l=await async function({url:e,popup:t}){return t.location=e,new Promise(((e,n)=>{let r,a=setTimeout((()=>{n(new Ce("Authorization request timed out after 2 minutes.")),i()}),12e4);function i(){t?.close(),window.removeEventListener("message",o)}let s=setInterval((()=>{t?.closed&&!r&&(i(),clearInterval(s),clearTimeout(a),n(new Ce("User rejected request")))}),300);function o(t){t.data&&("PRIVY_OAUTH_RESPONSE"===t.data.type&&t.data.stateCode&&t.data.authorizationCode&&(clearTimeout(a),e(t.data),i()),"PRIVY_OAUTH_ERROR"===t.data.type&&(clearTimeout(a),n(new Ce(t.data.error)),i()),t.data.type===Ai&&((r=new BroadcastChannel(vi)).onmessage=o))}window.addEventListener("message",o)}))}({url:i,popup:t,provider:a}),c=l.stateCode,d=l.authorizationCode;if(c!==s)throw r.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:a,storedStateCode:s??"",returnedStateCode:c??""}}),new Ce("Unexpected auth flow. This may be a phishing attempt.",void 0,_e.OAUTH_UNEXPECTED);let u=await async function({appId:e,stateCode:t,codeVerifier:n,authorizationCode:r,action:a,client:i}){if(!r||!t)throw new Ce("[Cross-App AuthFlow] Authorization and state codes code must be set prior to calling authenicate.");if("undefined"===r)throw new Ce("User denied confirmation during cross-app auth flow");try{let s=new ki({authorizationCode:r,stateCode:t,codeVerifier:n,provider:`privy:${e}`});i.startAuthFlow(s);let o="link"===a?await i.link():await i.authenticate(),l=o.oAuthTokens?.accessToken;return console.debug(),l}catch(e){let t=Te(e);if(t.privyErrorCode===_e.ACCOUNT_TRANSFER_REQUIRED)throw t;if(t.privyErrorCode)throw new Ce(t.message||"Invalid code during cross-app auth flow.",void 0,t.privyErrorCode);if("User denied confirmation during cross-app auth flow"===t.message)throw new Ce("Invalid code during cross-app auth flow.",void 0,_e.OAUTH_USER_DENIED);throw new Ce("Invalid code during cross-app auth flow.",void 0,_e.UNKNOWN_AUTH_ERROR)}}({appId:e,codeVerifier:o,stateCode:c,authorizationCode:d,action:n,client:r});u&&r.storeProviderAccessToken(e,u);let h=await Ut.refreshSessionAndUser();if(!h)throw new Ce("Unable to update user");return r.createAnalyticsEvent({eventName:"cross_app_auth_completed",payload:{providerAppId:e}}),h}catch(e){throw r.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:e.toString(),provider:a}}),e}},async initLoginWithOAuth(e,t,n){if($e.current=e,!je())return void it("InAppBrowserLoginNotPossible");if("google"===e&&!d.allowOAuthInEmbeddedBrowsers&&Ui(window.navigator.userAgent))return void it("InAppBrowserLoginNotPossible");"twitter"===e&&window.opener&&window.opener.postMessage({type:Ai},"*"),Me.del(Je),Me.del(Qe);let a=new oa({provider:e,disableSignup:!!n,withPrivyUi:!0,customOAuthRedirectUrl:d.customOAuthRedirectUrl});t&&a.addCaptchaToken(t),r.startAuthFlow(a);let i=await r.authFlow.getAuthorizationUrl();if(i&&i.url)if("twitter"===e&&At&&(i.url=i.url.replace("x.com","twitter.com")),"chrome-extension:"===window.location.protocol&&ta())try{let{privyOAuthCode:e,privyOAuthState:t}=await na(i.url);it("OAuthStatusScreen"),a.meta.stateCode=t,a.meta.authorizationCode=e}catch(e){throw console.error("OAuth in chrome extension flow failed:",e),e}else window.location.assign(i.url)},async initLoginWithTelegram(e,t){if(!y)throw new We;$e.current="telegram";let n=new Aa(e,t);r.startAuthFlow(n),ce({status:"loading"}),n.meta.telegramWebAppData=void 0,n.meta.telegramAuthResult=await new Promise(((e,t)=>d.loginConfig.telegramAuthConfiguration?window.Telegram?void window.Telegram.Login.auth({bot_id:d.loginConfig.telegramAuthConfiguration.botId,request_access:!0},(n=>n?e(n):("link"===Ge.current?er(Re,"linkAccount","onError",_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:"telegram"}):"login"===Ge.current?er(Re,"login","onError",_e.INVALID_CREDENTIALS):"update"===Ge.current&&er(Re,"login","onError",_e.FAILED_TO_UPDATE_ACCOUNT),t(new Ce("Telegram auth failed or was canceled by the client"))))):t(new Ce("Telegram was not initialized")):t(new Ce("Telegram Auth configuration is not loaded"))))},async loginWithTelegram(e){let t,n;if(!(r.authFlow instanceof Aa))throw new Ce("Must initialize Telegram flow before calling loginWithTelegram");r.authFlow.meta.captchaToken||=e?.captchaToken;let a=await Kr(),i=e?.intent||Ge.current;if("login"===i)try{let e=await r.authenticate();t=e.user,n=e.isNewUser,$e.current="telegram"}catch(e){throw er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}else{if("link"!==i)throw new Ce("Unknown auth intent");try{t=(await r.link()).user,$e.current="telegram"}catch(e){throw er(Re,"linkAccount","onError",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:"telegram"}),e}}v(t),_(n||!1),Ke(!0),ce({status:"done"});let s=t?.linkedAccounts.find((({type:e})=>"telegram"===e))||null;return{user:t,isNewUser:n||!1,wasAlreadyAuthenticated:!!a,loginAccount:s}},async loginWithOAuth(e){let t,n,a;if(!(r.authFlow instanceof oa))throw new Ce("Must initialize OAuth flow before calling loginWithOAuth");let i=Me.get(Ze),s=r.authFlow.meta.stateCode;if(i!==s)throw r.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e,storedStateCode:i??"",returnedStateCode:s??""}}),new Ce("Unexpected auth flow. This may be a phishing attempt.",void 0,_e.OAUTH_UNEXPECTED);if(null!==await r.getAccessToken())try{let n=await r.link();t=n.user,a=n.oAuthTokens,$e.current=e}catch(t){throw er(Re,"linkAccount","onError",t.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{let i=await r.authenticate();t=i.user,n=i.isNewUser,a=i.oAuthTokens,$e.current=e}catch(t){throw"login"===Ge.current?er(Re,"login","onError",t.privyErrorCode||_e.UNKNOWN_AUTH_ERROR):"link"===Ge.current&&er(Re,"linkAccount","onError",t.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}return v(t),_(n||!1),Ke(!0),a&&t&&er(Re,"oAuthAuthorization","onOAuthTokenGrant",{oAuthTokens:a,user:t}),a},passkeyAuthState:z,setPasskeyAuthState:q,async initSignupWithPasskey({captchaToken:e,withPrivyUi:t}){let n=new da({captchaToken:e,setPasskeyAuthState:q,hints:d.passkeys.registration?.hints});r.startAuthFlow(n),Ge.current="login";try{$e.current="passkey",q({status:"generating-challenge"}),await n.initRegisterFlow(t),q({status:"awaiting-passkey"})}catch(e){throw q({status:"error",error:e}),er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}},async signupWithPasskey(){let e,t;if(!y)throw new We;if(!(r.authFlow instanceof da))throw new Ce("Must initialize Passkey flow first.");if("passkey"!==$e.current){let e=new Ce("Must init login with Passkey flow first.");throw q({status:"error",error:e}),e}let n=await Kr();try{$e.current="passkey",q({status:"awaiting-passkey"}),({user:e,isNewUser:t}=await r.authenticate())}catch(e){throw q({status:"error",error:e}),er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}v(e),_(t||!1),Ke(!0),q({status:"done"});let a=e?.linkedAccounts.find((({type:e})=>"passkey"===e))||null;return{user:e,isNewUser:t||!1,wasAlreadyAuthenticated:!!n,loginAccount:a}},async initLoginWithPasskey({captchaToken:e,withPrivyUi:t}){let n=new da({captchaToken:e,setPasskeyAuthState:q,hints:void 0});r.startAuthFlow(n),Ge.current="login";try{$e.current="passkey",q({status:"generating-challenge"}),await n.initAuthenticationFlow(t),q({status:"awaiting-passkey"})}catch(e){throw q({status:"error",error:e}),er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}},async loginWithPasskey(e){let t,n;if(!y)throw new We;if(!(r.authFlow instanceof da))throw new Ce("Must initialize Passkey flow first.");if(e?.credentialIds&&(r.authFlow.meta.allowedCredentialsIds=e.credentialIds),"passkey"!==$e.current){let e=new Ce("Must init login with Passkey flow first.");throw q({status:"error",error:e}),e}let a=await Kr();try{$e.current="passkey",q({status:"awaiting-passkey"}),({user:t,isNewUser:n}=await r.authenticate())}catch(e){throw q({status:"error",error:e}),er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}v(t),_(n||!1),Ke(!0),q({status:"done"});let i=t?.linkedAccounts.find((({type:e})=>"passkey"===e))||null;return{user:t,isNewUser:n||!1,wasAlreadyAuthenticated:!!a,loginAccount:i}},async initLinkWithPasskey(e){let t=new da({captchaToken:e,hints:d.passkeys.registration?.hints});r.startAuthFlow(t),Ge.current="link",$e.current="passkey",q({status:"generating-challenge"});try{await t.initLinkFlow(),q({status:"awaiting-passkey"})}catch(e){throw er(Re,"linkAccount","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),q({status:"error",error:e}),e}},async linkWithPasskey(){let e;if(!y)throw new We;if(!(r.authFlow instanceof da))throw new Ce("Must initialize Passkey flow first.");if("passkey"!==$e.current)throw new Ce("Must init login with Passkey flow first.");try{$e.current="passkey",({user:e}=await r.link())}catch(e){throw er(Re,"linkAccount","onError",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:"passkey"}),e}return v(e||f||null),q({status:"done"}),e},async initLoginWithHeadlessOAuth(e,t,n){if(!je())throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");if("google"===e&&!d.allowOAuthInEmbeddedBrowsers&&Ui(window.navigator.userAgent))throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");let a=new oa({provider:e,withPrivyUi:!1,disableSignup:n??!1,customOAuthRedirectUrl:d.customOAuthRedirectUrl});t&&a.addCaptchaToken(t),Q({status:"loading"});let i=await r.startAuthFlow(a).getAuthorizationUrl();if(i?.url)if("chrome-extension:"===window.location.protocol&&ta())try{let{privyOAuthCode:e,privyOAuthState:t}=await na(i.url);a.meta.stateCode=t,a.meta.authorizationCode=e,await this.loginWithHeadlessOAuth(a.meta)}catch(e){throw Q({status:"error",error:e}),e}else window.location.assign(i.url)},async loginWithHeadlessOAuth(e){let t,n,a;L(!0),Q({status:"loading"}),r.startAuthFlow(new oa({...e,customOAuthRedirectUrl:d.customOAuthRedirectUrl}));let i=Me.get(Ze),s=e.stateCode;if(i!==s)throw r.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e.provider,storedStateCode:i??"",returnedStateCode:s??""}}),L(!1),new Ce("Unexpected auth flow. This may be a phishing attempt.",void 0,_e.OAUTH_UNEXPECTED);if(null!==await r.getAccessToken())try{({user:t,oAuthTokens:a}=await r.link()),$e.current=e.provider;let n=kt(t);t&&n&&er(Re,"linkAccount","onSuccess",{user:t,linkMethod:$e.current,linkedAccount:n})}catch(t){throw L(!1),er(Re,"linkAccount","onError",t.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:e.provider}),t}else try{({user:t,isNewUser:n,oAuthTokens:a}=await r.authenticate()),$e.current=e.provider;let i=kt(t);t&&i&&void 0!==n&&er(Re,"login","onComplete",{user:t,isNewUser:n,wasAlreadyAuthenticated:!1,loginMethod:$e.current,loginAccount:i})}catch(e){throw L(!1),Q({status:"error",error:e}),er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}return v(t),_(n||!1),Ke(!0),L(!1),Q({status:"done"}),a&&t&&er(Re,"oAuthAuthorization","onOAuthTokenGrant",{oAuthTokens:a,user:t}),t??void 0},initLoginWithEmail:async({email:e,captchaToken:t,disableSignup:n,withPrivyUi:a})=>{let i=new Yr({email:e,captchaToken:t,disableSignup:n});r.startAuthFlow(i);try{$e.current="email",B({status:"sending-code"});let e=await i.sendCodeEmail({withPrivyUi:a});if(e?.ssoRedirectUrl)return window.location.href=e.ssoRedirectUrl,void await ae(1e4);B({status:"awaiting-code-input"})}catch(e){throw B({status:"error",error:e}),"login"===Ge.current?er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR):"link"===Ge.current&&er(Re,"linkAccount","onError",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:"email"}),e}},initUpdateEmail:async({oldAddress:e,newAddress:t,captchaToken:n})=>{let a=new Jr(e,t,n);r.startAuthFlow(a);try{await a.sendCodeEmail({withPrivyUi:!0})}catch(e){throw er(Re,"update","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:$e.current}),e}},initUpdatePhone:async(e,t,n)=>{let a=new ma(e,t,n);r.startAuthFlow(a);try{await a.sendSmsCode({withPrivyUi:!0})}catch(e){er(Re,"update","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:$e.current})}},initLoginWithSms:async({phoneNumber:e,captchaToken:t,disableSignup:n,withPrivyUi:a})=>{$({status:"sending-code"});let i=new wa({phoneNumber:e,captchaToken:t,disableSignup:n});r.startAuthFlow(i);try{$e.current="sms",await i.sendSmsCode({withPrivyUi:a}),$({status:"awaiting-code-input"})}catch(e){throw $({status:"error",error:e}),"login"===Ge.current?er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR):"link"===Ge.current&&er(Re,"linkAccount","onError",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:"sms"}),e}},resendEmailCode:async()=>{await(r.authFlow?.sendCodeEmail({withPrivyUi:!0}))},resendSmsCode:async()=>{await(r.authFlow?.sendSmsCode({withPrivyUi:!0}))},loginWithCode:async e=>{let t,n;function a(e){r.authFlow instanceof Yr?B(e):r.authFlow instanceof wa&&$(e)}if(a({status:"submitting-code"}),!y){let e=new We;throw a({status:"error",error:e}),e}if(r.authFlow instanceof Yr)r.authFlow.meta.emailCode=e.trim();else{if(!(r.authFlow instanceof wa)){let e=new Ce("Must initialize a passwordless code flow first");throw a({status:"error",error:e}),e}r.authFlow.meta.smsCode=e.trim()}let i=await Kr();if("link"===Ge.current)try{({user:t}=await r.link())}catch(e){throw a({status:"error",error:e}),er(Re,"linkAccount","onError",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:$e.current}),e}else if("update"===Ge.current)try{({user:t}=await r.link())}catch(e){throw a({status:"error",error:e}),er(Re,"update","onError",e.privyErrorCode||_e.FAILED_TO_UPDATE_ACCOUNT,{linkMethod:$e.current}),e}else try{({user:t,isNewUser:n}=await r.authenticate())}catch(e){throw a({status:"error",error:e}),er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}let s=t||f;v(s||null),_(n||!1),Ke(!0),a({status:"done"});let o=null;return r.authFlow instanceof Yr?o=s?.linkedAccounts.find((({type:e})=>"email"===e))||null:r.authFlow instanceof wa&&(o=s?.linkedAccounts.find((({type:e})=>"phone"===e))||null),{user:s,isNewUser:n||!1,wasAlreadyAuthenticated:!!i,linkedAccount:o}},generateSiweMessage:async({address:e,chainId:t,captchaToken:n})=>{Ge.current=Ve?"link":"login",$e.current="siwe",Y({status:"generating-message"});let a=await r.generateSiweNonce({address:e,captchaToken:n});return Y({status:"awaiting-signature"}),ua({address:e,chainId:t.replace("eip155:",""),nonce:a})},generateSiweMessageForSmartWallet:async({address:e,chainId:t})=>{let n=await r.generateSiweNonce({address:e});return ua({address:e,chainId:t.replace("eip155:",""),nonce:n})},linkSmartWallet:async({message:e,signature:t,smartWalletType:n,smartWalletVersion:a})=>{let i;i=await r.linkSmartWallet({message:e,signature:t,smartWalletType:n,smartWalletVersion:a}),v((i=await Ut.refreshSessionAndUser()??i)||f||null)},loginWithSiwe:async({message:e,signature:t,captchaToken:n,disableSignup:a,walletClientType:i,connectorType:s})=>{let o,l=null;try{if(f)throw Error("User already authenticated");let c=new ha(r,void 0,n,a,{message:e,signature:t,walletClientType:i,connectorType:s});r.startAuthFlow(c),$e.current="siwe",Ge.current="login",Y({status:"submitting-signature"});let d=await r.authenticate();if(({user:l,isNewUser:o}=d),!l)throw Error("Authentication failed - no user returned")}catch(e){throw er(Re,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),Y({status:"error",error:e}),e}return v(l),_(o||!1),Ke(!0),Y({status:"done"}),Ge.current=null,$e.current=null,{user:l,isNewUser:o||!1}},linkWithSiwe:async({message:e,signature:t,chainId:n,walletClientType:a,connectorType:i})=>{let s;wt("siwe");let o=null;try{Y({status:"submitting-signature"}),s=await r.linkWithSiwe({message:e,signature:t,chainId:n,walletClientType:a,connectorType:i}),s=await Ut.refreshSessionAndUser()??s,Y({status:"done"}),(o=kt(s)||null)&&er(Re,"linkAccount","onSuccess",{user:s,linkMethod:"siwe",linkedAccount:o})}catch(e){throw er(Re,"linkAccount","onError",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:"siwe"}),Ge.current=null,$e.current=null,Y({status:"error",error:e}),e}let l=s||f;return v(l||null),Ge.current=null,$e.current=null,{user:l,linkedAccount:o}},refreshSessionAndUser:async()=>{let e=await r.getAuthenticatedUser();return Ke(!!e),v(e),e},walletProxy:de,createAnalyticsEvent:({eventName:e,payload:t,timestamp:n})=>r.createAnalyticsEvent({eventName:e,payload:t,timestamp:n}),acceptTerms:async()=>{let e=await r.acceptTerms();return v(e),e},getUsdTokenPrice:e=>r.getUsdTokenPrice(e),getUsdPriceForSol:()=>r.getUsdPriceForSol(),getSplTokenMetadata:e=>r.getSplTokenMetadata(e),recoverEmbeddedWallet:async e=>new Promise((async(t,n)=>{if(!f)return void t(!0);let a=e?.address?N(f,e.address):b(f)||U(f).at(0)||O(f).at(0);if(!a||P(a))return void t(!0);let i=await Kr();if(!i||!de||!a)return void n(Error("Must have valid access token and Privy wallet to recover wallet"));let{entropyId:s,entropyIdVerifier:o}=ve(f,a);try{await de.connect({accessToken:i,entropyId:s,entropyIdVerifier:o}),t(!0)}catch(e){if(ei(e)&&"privy"===a.recoveryMethod){let e;r.createAnalyticsEvent({eventName:"embedded_wallet_pinless_recovery_started",payload:{walletAddress:a.address}});try{e=await de.recover({entropyId:s,entropyIdVerifier:o,accessToken:i})}catch(e){return void n(e)}e.entropyId||n(Error("Unable to recover wallet")),r.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:a.address}}),t(!0)}else ei(e)&&"privy"!==a.recoveryMethod&&"privy-v2"!==a.recoveryMethod?(we({recoverWallet:{entropyId:s,entropyIdVerifier:o,onFailure:n,onSuccess:()=>t(!0)},recoveryOAuthStatus:{provider:a.recoveryMethod,action:"recover",shouldCreateEth:!1,shouldCreateSol:!1}}),it(Ii(a.recoveryMethod))):n(e)}})),setReadyToTrue:e=>{g(!0),me?.(e)},updateWallets:()=>yt(),fundWallet:async(e,t)=>{let n="FundingMethodSelectionScreen";return new Promise(((r,a)=>{we({funding:{...De({address:e,appConfig:d,fundWalletConfig:t,methodScreen:n,onComplete:r,onError:a})}}),it(n)}))},openModal:it,requestFarcasterSignerStatus:async e=>{let t=await Kr(),n=f?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!de||!n)throw Error("Must have an embedded wallet to use Farcaster signers");if(!f?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");let a=await r.requestFarcasterSignerStatus(e);return"approved"===a.status&&v(await r.getAuthenticatedUser()||f||null),a},connectCoinbaseSmartWallet:async()=>{d.externalWallets.coinbaseWallet.config.preference={...d.externalWallets.coinbaseWallet.config.preference,options:"smartWalletOnly"};let e=r.connectors?.findWalletConnector("coinbase_wallet","coinbase_smart_wallet")||r.connectors?.findWalletConnector("coinbase_wallet","coinbase_wallet");if(e)return e.updateConnectionPreference("smartWalletOnly"),dt(e);await ct("coinbase_wallet","coinbase_smart_wallet")},connectBaseAccount:async()=>{let e=r.connectors?.findWalletConnector("base_account","base_account");if(e)return dt(e);await ct("base_account","base_account")},initiateAccountTransfer:async({nonce:e,account:t,accountType:n,externalWalletMetadata:a,telegramAuthResult:i,telegramWebAppData:s,farcasterEmbeddedAddress:o,oAuthUserInfo:l})=>{let c=await r.sendAccountTransferRequest({nonce:e,account:t,accountType:n,externalWalletMetadata:a,telegramAuthResult:i,telegramWebAppData:s,farcasterEmbeddedAddress:o,oAuthUserInfo:l});return v(c),c},inProgressAuthFlowRef:Ge,inProgressLoginOrLinkMethodRef:$e};es=Ut.recoverEmbeddedWallet,Ut.recoverEmbeddedWallet;let Nt=l((()=>({wallets:A,ready:fe&&xe})),[A,fe,xe]),Ot=r.authFlow instanceof Aa,{siteKey:Rt,enabledProvider:Mt}=d.captcha,xt=!d.headless&&Mt&&!Ve&&(y||Ot);/*#__PURE__*/return t(Yi.Provider,{value:!0,children:/*#__PURE__*/t(R.Provider,{value:Wt,children:/*#__PURE__*/t(tr.Provider,{value:Re,children:/*#__PURE__*/t(Ae.Provider,{value:Nt,children:/*#__PURE__*/t(fa,{appId:d.id,captchaSiteKey:Rt,enabledCaptchaProvider:Mt,children:/*#__PURE__*/e(Ue.Provider,{value:Ut,children:[/*#__PURE__*/t(ie,{children:/*#__PURE__*/e(M,{data:pe,setModalData:we,setInitialScreen:I,initialScreen:S,authenticated:Ve,open:u,children:[n.children,/*#__PURE__*/t(Gi,{customAuth:d.customAuth}),xt&&/*#__PURE__*/t(Sa,{delayedExecution:!1}),/*#__PURE__*/t(Ya,{}),/*#__PURE__*/t(zi,{disabled:d.embeddedWallets.disableAutomaticMigration}),/*#__PURE__*/t(Wa,{palette:d.appearance.palette||{}}),!d.render.standalone&&/*#__PURE__*/t(Va,{open:u})]})}),/*#__PURE__*/t(mi,{appId:n.appId,appClientId:n.clientId,clientAnalyticsId:r.clientAnalyticsId,origin:r.apiUrl,mfaMethods:f?.mfaMethods,mfaPromise:Ne,mfaSubmitPromise:Oe,onLoad:ue,onLoadFailed:()=>null}),d.loginConfig.telegramAuthConfiguration&&
/*#__PURE__*/t(V,{$if:!0,children:/*#__PURE__*/t(Ga,{scriptHost:n.apiUrl||nt,botUsername:d.loginConfig.telegramAuthConfiguration.botName})})]})})})})})})},ns=e=>es(e);class rs extends Error{constructor(e,t,n){super(e),this.code=t,this.data=n}}class as extends D{async handleSendTransaction(e){if(!e.params||!Array.isArray(e.params))throw new rs(`Invalid params for ${e.method}`,4200);let t=e.params[0];if(!await Kr()||!this.address)throw new rs("Disconnected",4900);let{hash:n}=await((e,t)=>Xi(e,t))(t,{address:this.address});return n}async handleSignTransaction(e){if(!e.params||!Array.isArray(e.params))throw new rs(`Invalid params for ${e.method}`,4200);let t=e.params[0];if(!await Kr()||!this.address)throw new rs("Disconnected",4900);let{signature:n}=await((e,t)=>Zi(e,t))(t,{address:this.address});return n}handleSwitchEthereumChain(e){let t;if(!e.params||!Array.isArray(e.params))throw new rs(`Invalid params for ${e.method}`,4200);if("string"==typeof e.params[0])t=e.params[0];else{if(!("chainId"in e.params[0])||"string"!=typeof e.params[0].chainId)throw new rs(`Invalid params for ${e.method}`,4200);t=e.params[0].chainId}this.chainId=Number(t),this.publicClient=gr(this.chainId,this.chains,this.rpcConfig,{appId:this.appId}),this.emit("chainChanged",t)}async handlePersonalSign(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for personal_sign");let t=e.params[0],n=e.params[1],{signature:r}=await((e,t)=>Ji(e,t))({message:t},{address:n});return r}async handleSignedTypedData(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_signTypedData_v4");let t=e.params[0],n="string"==typeof e.params[1]?JSON.parse(e.params[1]):e.params[1],{signature:r}=await((e,t)=>Qi(e,t))(oe(n),{address:t});return r}async handleEstimateGas(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_estimateGas");delete e.params[0].gasPrice,delete e.params[0].maxFeePerGas,delete e.params[0].maxPriorityFeePerGas;let t={...e.params[0],chainId:q(this.chainId)};return await this.publicClient.estimateGas({account:t.from??this.address,...Be(t)})}async request(e){switch(console.debug("Embedded1193Provider.request() called with args",e),e.method){case"eth_accounts":case"eth_requestAccounts":return this.address?[this.address]:[];case"eth_chainId":return q(this.chainId);case"eth_estimateGas":return this.handleEstimateGas(e);case"eth_sendTransaction":return this.handleSendTransaction(e);case"eth_signTransaction":return this.handleSignTransaction(e);case"wallet_switchEthereumChain":return this.handleSwitchEthereumChain(e);case"personal_sign":return this.handlePersonalSign(e);case"eth_signTypedData_v4":return this.handleSignedTypedData(e)}if(!(e=>$r.includes(e))(e.method))return this.publicClient.request({method:e.method,params:e.params});{let t=await Kr();if(await ns({address:this.address}),!t||!this.address)throw new rs("Disconnected",4900);try{let n={method:e.method,params:e.params},r=this.walletAccount;return r&&P(r)?this.handleWalletApiRequest(n,r,t):(await this.walletProxy.rpc({accessToken:t,entropyId:this.entropyId,entropyIdVerifier:this.entropyIdVerifier,chainType:"ethereum",hdWalletIndex:this.walletIndex,request:n})).response.data}catch(e){throw console.error(e),new rs("Disconnected",4900)}}}async handleWalletApiRequest(e,t,n){let r=this.privyClient;if(!r)throw new rs("Disconnected",4900);if("secp256k1_sign"===e.method){let a=await m(r,(async({message:e})=>this.walletProxy.signWithUserSigner({accessToken:n,message:e})),{chain_type:"ethereum",method:"secp256k1_sign",wallet_id:t.id,params:{hash:e.params[0]}});if("secp256k1_sign"!==a.method)throw new rs(`Invalid params for ${e.method}`,4200);return a.data.signature}throw new rs(`Method not supported: ${e.method}`,4200)}constructor({walletProxy:e,address:t,entropyId:n,entropyIdVerifier:r,rpcConfig:a,chains:i,appId:s,chainId:o=1,walletIndex:l,privyClient:c,walletAccount:d}){super(),this.walletProxy=e,this.address=t,this.entropyId=n,this.entropyIdVerifier=r,this.chainId=o,this.rpcConfig=a,this.chains=i,this.publicClient=gr(o,this.chains,a,{appId:s}),this.rpcTimeoutDuration=Q(a,"privy"),this.appId=s,this.walletIndex=l,this.privyClient=c,this.walletAccount=d}}const is=({style:e,...n})=>/*#__PURE__*/t("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",stroke:"currentColor",strokeWidth:1.5,viewBox:"0 0 24 24",style:{...e},...n,children:/*#__PURE__*/t("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M9 17.25v1.007a3 3 0 01-.879 2.122L7.5 21h9l-.621-.621A3 3 0 0115 18.257V17.25m6-12V15a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 15V5.25m18 0A2.25 2.25 0 0018.75 3H5.25A2.25 2.25 0 003 5.25m18 0V12a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 12V5.25"})}),ss=({style:n,...r})=>/*#__PURE__*/e("svg",{xmlns:"http://www.w3.org/2000/svg",width:"108",height:"108",viewBox:"0 0 108 108",fill:"none",style:{height:"28px",width:"28px",...n},...r,children:[/*#__PURE__*/t("rect",{width:"108",height:"108",rx:"23",fill:"#AB9FF2"}),/*#__PURE__*/t("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M46.5267 69.9229C42.0054 76.8509 34.4292 85.6182 24.348 85.6182C19.5824 85.6182 15 83.6563 15 75.1342C15 53.4305 44.6326 19.8327 72.1268 19.8327C87.768 19.8327 94 30.6846 94 43.0079C94 58.8258 83.7355 76.9122 73.5321 76.9122C70.2939 76.9122 68.7053 75.1342 68.7053 72.314C68.7053 71.5783 68.8275 70.7812 69.0719 69.9229C65.5893 75.8699 58.8685 81.3878 52.5754 81.3878C47.993 81.3878 45.6713 78.5063 45.6713 74.4598C45.6713 72.9884 45.9768 71.4556 46.5267 69.9229ZM83.6761 42.5794C83.6761 46.1704 81.5575 47.9658 79.1875 47.9658C76.7816 47.9658 74.6989 46.1704 74.6989 42.5794C74.6989 38.9885 76.7816 37.1931 79.1875 37.1931C81.5575 37.1931 83.6761 38.9885 83.6761 42.5794ZM70.2103 42.5795C70.2103 46.1704 68.0916 47.9658 65.7216 47.9658C63.3157 47.9658 61.233 46.1704 61.233 42.5795C61.233 38.9885 63.3157 37.1931 65.7216 37.1931C68.0916 37.1931 70.2103 38.9885 70.2103 42.5795Z",fill:"#FFFDF8"})]});function os(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e}var ls=0;class cs extends j{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}get walletBranding(){return{name:this.providerDetail.info.name,icon:this.providerDetail.info.icon,id:this.providerDetail.info.rdns}}disconnect(){console.warn(`Programmatic disconnect with ${this.providerDetail.info.name} is not yet supported.`)}async promptConnection(){try{let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new ke("Unable to retrieve accounts");await this.syncAccounts([e[0]])}catch(e){throw Re(e)}}constructor(e,t,n,r,a){super(a||"unknown",e,t,n),this.connectorType="injected",this.proxyProvider=new z(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.providerDetail=r;let i=r.provider;this.proxyProvider.setWalletProvider(i)}}var ds="__private_"+ls+++"__walletBranding";class us extends j{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}get walletBranding(){return os(this,ds)[ds]??{name:"Browser Extension",icon:is,id:"extension"}}disconnect(){console.warn("Programmatic disconnect with browser wallets is not yet supported.")}async promptConnection(){try{let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new ke("Unable to retrieve accounts");await this.syncAccounts([e[0]])}catch(e){throw Re(e)}}constructor(e,t,n,r,a){super(a??"unknown",e,t,n),Object.defineProperty(this,ds,{writable:!0,value:void 0}),this.connectorType="injected",this.proxyProvider=new z(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.proxyProvider.setWalletProvider(r),"metamask"===a?os(this,ds)[ds]={name:"MetaMask",icon:ce,id:"io.metamask"}:"phantom"===a&&(os(this,ds)[ds]={name:"Phantom",icon:ss,id:"phantom"})}}class hs extends cs{disconnect(){console.warn("MetaMask does not support programmatic disconnect.")}async promptConnection(){try{ft||await this.proxyProvider.request({method:"wallet_requestPermissions",params:[{eth_accounts:{}}]});let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new ke("Unable to retrieve accounts");await this.syncAccounts([e[0]])}catch(e){throw Re(e)}}}class ps extends D{get wallets(){let e=new Set;return this.walletConnectors.flatMap((e=>e.wallets)).sort(((e,t)=>e.connectedAt&&t.connectedAt?t.connectedAt-e.connectedAt:0)).filter((t=>{let n=`${t.address}${t.walletClientType}${t.connectorType}${t.meta.id}`;return!e.has(n)&&(e.add(n),!0)}))}async initialize(e){if(this.initialized&&!e||(e&&this.removeAllConnectors(),this.externalWalletConfig.disableAllExternalWallets))return;let t=de({store:this.store,walletList:this.walletList,externalWalletConfig:this.externalWalletConfig,walletChainType:this.walletChainType}).then((e=>{e.forEach((({type:e,eip6963InjectedProvider:t,legacyInjectedProvider:n})=>{this.createEthereumWalletConnector({connectorType:"injected",walletClientType:e,providers:{eip6963InjectedProvider:t,legacyInjectedProvider:n}})}))}));for(let e of(this.walletList.includes("coinbase_wallet")&&this.createEthereumWalletConnector({connectorType:"coinbase_wallet",walletClientType:"coinbase_wallet"}),this.walletList.includes("base_account")&&this.createEthereumWalletConnector({connectorType:"base_account",walletClientType:"base_account"}),Object.values(ue)))!e.isInstalled&&this.walletList.includes(e.client)&&(["ethereum-only","ethereum-and-solana"].includes(this.walletChainType)&&e.chainTypes.includes("ethereum")&&this.createEthereumWalletConnector({connectorType:"null",walletClientType:e.client,walletConfig:e}),["ethereum-and-solana","solana-only"].includes(this.walletChainType)&&e.chainTypes.includes("solana")&&this.addSolanaWalletConnector(new he({id:e.client,name:e.name})));this.externalWalletConfig.walletConnect.enabled&&(this.walletList.includes("wallet_connect_qr")||ee(this.walletList))&&"solana-only"!==this.walletChainType&&this.createEthereumWalletConnector({connectorType:"wallet_connect_v2",walletClientType:"unknown"});let n=this.walletList.includes("wallet_connect_qr_solana")||ee(this.walletList)&&"ethereum-only"!==this.walletChainType,r=this.externalWalletConfig.solana.connectors?.get()||[],a=async e=>{if(!n)return;let t=e.find((e=>"walletconnect_solana"===e.walletBranding?.id));t&&t.wallet&&await t.wallet.initialize({walletConnectCloudProjectId:this.walletConnectCloudProjectId,privyAppName:this.privyAppName})};a(r),r.filter((e=>n||"walletconnect_solana"!==e.walletBranding?.id)).forEach(this.addSolanaWalletConnector),this.externalWalletConfig.solana.connectors?._setOnConnectorsUpdated?.((e=>{a(e),e?.filter((e=>n||"walletconnect_solana"!==e.walletBranding?.id)).forEach(this.addSolanaWalletConnector)})),await t,this.initialized=!0}findWalletConnector(e,t,n){return"wallet_connect_v2"===e?this.walletConnectors.filter(pe).find((t=>t.connectorType===e&&(!n||t.wallets.some((e=>e.address===n)))))??null:this.walletConnectors.filter(pe).find((r=>r.connectorType===e&&r.walletClientType===t&&(!n||r.wallets.some((e=>e.address===n)))))??null}findSolanaWalletConnector(e){return this.walletConnectors.filter(we).find((t=>"unknown"===t.walletClientType?t.walletBranding.id===e:t.walletClientType===e))??null}findEmbeddedWalletConnectors(){return this.walletConnectors.filter((e=>"embedded"===e.connectorType))}findImportedWalletConnectors(){return this.walletConnectors.filter((e=>"embedded_imported"===e.connectorType))}onInitialized(e){e.wallets.forEach((e=>{let t=this.storedConnections.find((t=>t.address===e.address&&t.connectorType===e.connectorType&&("solana"===e.type&&"unknown"===t.walletClientType&&"unknown"===e.walletClientType?e.meta.id===t.id:t.walletClientType===e.walletClientType)));t&&(e.connectedAt=t.connectedAt)})),this.emit("walletsUpdated"),this.emit("connectorInitialized")}onWalletsUpdated(e){e.initialized&&this.emit("walletsUpdated")}addEmbeddedWalletConnectors({walletProxy:e,user:t,embeddedWallets:n,defaultChain:r,appId:a,privyClient:i}){let{entropyId:s,entropyIdVerifier:o}=ve(t);for(let t of n){let n=this.findEmbeddedWalletConnectors().find((e=>e.walletIndex===t.walletIndex));if(n&&pe(n))n.proxyProvider.walletProxy=e;else{let n=new Br({provider:new as({walletProxy:e,address:t.address,entropyId:s,entropyIdVerifier:o,rpcConfig:this.rpcConfig,chains:this.chains,appId:a,chainId:r.id,walletIndex:t.walletIndex,privyClient:i,walletAccount:t}),chains:this.chains,defaultChain:r,rpcConfig:this.rpcConfig,imported:!1,walletIndex:t.walletIndex});this.addWalletConnector(n)}}}addImportedWalletConnector(e,t,n,r){let a=this.findWalletConnector("embedded_imported","privy",t);if(a&&pe(a))a.proxyProvider.walletProxy=e;else{let a=new Br({provider:new as({walletProxy:e,address:t,entropyId:t,entropyIdVerifier:"ethereum-address-verifier",walletIndex:0,rpcConfig:this.rpcConfig,chains:this.chains,appId:r,chainId:n.id}),chains:this.chains,walletIndex:0,defaultChain:n,rpcConfig:this.rpcConfig,imported:!0});this.addWalletConnector(a)}}removeEmbeddedWalletConnectors(){this.walletConnectors=this.walletConnectors.filter((e=>"embedded"!==e.connectorType)),this.storedConnections=He(),this.emit("walletsUpdated")}removeImportedWalletConnectors(){let e=this.findImportedWalletConnectors();e.length&&(e.forEach((e=>{let t=this.walletConnectors.indexOf(e);this.walletConnectors.splice(t,1)})),this.storedConnections=He(),this.emit("walletsUpdated"))}async createEthereumWalletConnector({connectorType:e,walletClientType:t,providers:n,walletConfig:r}){let a=this.findWalletConnector(e,t);if(a&&pe(a))return a instanceof Ja&&a.resetConnection(t),a;let i=(()=>"injected"!==e?"coinbase_wallet"===e?new Hr(this.chains,this.defaultChain,this.rpcConfig,this.externalWalletConfig.coinbaseWallet.config):"base_account"===e?new zr(this.chains,this.defaultChain,this.rpcConfig,this.externalWalletConfig.baseAccount.config,this.setBaseAccountSdk):"null"!==e?new Ja({walletConnectCloudProjectId:this.walletConnectCloudProjectId,rpcConfig:this.rpcConfig,chains:this.chains,defaultChain:this.defaultChain,shouldEnforceDefaultChainOnConnect:this.shouldEnforceDefaultChainOnConnect,privyAppId:this.privyAppId,privyAppName:this.privyAppName,walletClientType:t}):r?new me({id:r.client,name:r.name,defaultChain:this.defaultChain,walletClientType:r.client}):null:"metamask"===t&&n?.eip6963InjectedProvider?new hs(this.chains,this.defaultChain,this.rpcConfig,n?.eip6963InjectedProvider,"metamask"):"metamask"===t&&n?.legacyInjectedProvider?new us(this.chains,this.defaultChain,this.rpcConfig,n?.legacyInjectedProvider,"metamask"):"phantom"===t&&n?.legacyInjectedProvider?new us(this.chains,this.defaultChain,this.rpcConfig,n?.legacyInjectedProvider,"phantom"):n?.legacyInjectedProvider&&"unknown_browser_extension"===t?new us(this.chains,this.defaultChain,this.rpcConfig,n?.legacyInjectedProvider):n?.eip6963InjectedProvider?new cs(this.chains,this.defaultChain,this.rpcConfig,n?.eip6963InjectedProvider,t):void 0)();return i&&this.addWalletConnector(i),i||null}addWalletConnector(e){this.walletConnectors.push(e),e.on("initialized",(()=>this.onInitialized(e))),e.on("walletsUpdated",(()=>this.onWalletsUpdated(e))),e.initialize().catch((e=>{console.debug("Failed to initialize connector",e)}))}setWalletList(e){this.walletList=e,this.initialized&&this.initialize(!0).catch(console.error)}removeAllConnectors(){for(let e of this.walletConnectors)e.removeAllListeners();this.walletConnectors=[]}constructor(e,t,n,r,a,i,s,o,l,c,d,u){super(),this.addSolanaWalletConnector=async e=>{let t=this.findSolanaWalletConnector(e.walletClientType);if(!t||"null"===t.connectorType){if("null"===t?.connectorType){let e=this.walletConnectors.indexOf(t);this.walletConnectors.splice(e,1)}this.addWalletConnector(e)}},this.privyAppId=e,this.walletConnectCloudProjectId=t,this.rpcConfig=n,this.chains=r,this.defaultChain=a,this.walletConnectors=[],this.initialized=!1,this.store=i,this.walletList=s,this.shouldEnforceDefaultChainOnConnect=o,this.externalWalletConfig=l,this.privyAppName=c,this.walletChainType=u||"ethereum-only",this.setBaseAccountSdk=d,this.storedConnections=He()}}const ws=nr((()=>({identityToken:null})));function ms(){let{identityToken:e}=ws();return{identityToken:e}}let ys=[Xt,en,tn];class gs{async get(e,t){try{return await this.baseFetch(e,t)}catch(e){throw Te(e)}}async post(e,t,n){try{return await this.baseFetch(e,{method:"POST",...t?{body:t}:{},...n})}catch(e){throw Te(e)}}async delete(e,t){try{return await this.baseFetch(e,{method:"DELETE",...t})}catch(e){throw Te(e)}}constructor({appId:e,appClientId:t,client:n,defaults:r}){this.appId=e,this.appClientId=t,this.clientAnalyticsId=n.clientAnalyticsId,this.sdkVersion=it,this.client=n,this.defaults=r,this.fallbackApiUrl=n.fallbackApiUrl,this.baseFetch=vr.create({baseURL:this.defaults.baseURL,timeout:this.defaults.timeout,retry:3,retryDelay:500,retryStatusCodes:[408,409,425,500,502,503,504],credentials:"include",onRequest:async({request:e,options:t})=>{let n=new Headers(t.headers);n.set("privy-app-id",this.appId),this.appClientId&&n.set("privy-client-id",this.appClientId),n.set("privy-ca-id",this.clientAnalyticsId||""),n.set("privy-client",`react-auth:${this.sdkVersion}`);let r=ys.includes(e.toString());if(!n.has("authorization")){let e=await this.client.getAccessToken({disableAutoRefresh:r});null!==e&&n.set("authorization",`Bearer ${e}`)}t.headers=n,t.retryDelay&&"number"==typeof t.retryDelay&&(t.retryDelay=3*t.retryDelay)},onRequestError:({error:e})=>{if(e instanceof DOMException&&"AbortError"===e.name)throw new Ne}})}}const fs=e=>({rpId:e.rp_id,challenge:e.challenge,allowCredentials:e.allow_credentials?.map((e=>({id:e.id,type:e.type,transports:e.transports})))||[],timeout:e.timeout,extensions:{appid:e.extensions?.app_id,credProps:e.extensions?.cred_props,hmacCreateSecret:e.extensions?.hmac_create_secret},userVerification:e.user_verification});class vs{getOrCreateGuestCredential(e){let t=at(e);if(je()){if(Me.get(t))return Me.get(t);{let e=C.encode(ra(32));return Me.put(t,e),e}}return C.encode(ra(32))}async authenticate(){if(!this.api)throw new Ce("Auth flow has no API instance");try{return await this.api.post(nn,{guest_credential:this.meta.guestCredential})}catch(e){throw Te(e)}}async link(){throw Error("Linking is not supported for the guest flow")}constructor(e){this.meta={guestCredential:this.getOrCreateGuestCredential(e)}}}function As(){return!(kt&&window.location.origin.startsWith("http://localhost"))}var ks,Cs=((ks={}).PRIVY="privy_access_token",ks.CUSTOMER="customer_access_token",ks);class Ts{get token(){return this.privyAccessToken||this.customerAccessToken}getToken(e){return"privy_access_token"===e?this.privyAccessToken:this.customerAccessToken}get customerAccessToken(){return this._getToken(Ge)}get privyAccessToken(){return this._getToken($e)}_getToken(e){try{let t=Me.get(e);return"string"==typeof t?Rr.throwIfNotWellFormedJwt(t):null}catch(e){return console.error(e),this.destroyLocalState(),null}}get refreshToken(){try{let e=Me.get(st);return"string"==typeof e?e:null}catch(e){return console.error(e),this.destroyLocalState(),null}}getProviderAccessToken(e){try{let t=Me.get(ot(e));if("string"!=typeof t)return null;{let n=new Rr(t);return n.isExpired()?(Me.del(ot(e)),null):n.value}}catch(e){return console.error(e),null}}get mightHaveServerCookies(){try{let e=Ar.get(lt);return void 0!==e&&e.length>0}catch(e){console.error(e)}return!1}hasRefreshCredentials(e="privy_access_token"){let t="string"==typeof this.getToken(e),n="string"==typeof this.refreshToken&&this.refreshToken!==ct;return this.mightHaveServerCookies||t&&n}hasActiveAccessToken(e){let t=Rr.parse(this.getToken(e));return null!==t&&!t.isExpired(30)}authenticate(e){return this.authenticateOnce.execute(e)}link(e){return this.linkOnce.execute(e)}refresh(){return this.refreshOnce.execute()}destroy(){return this.destroyOnce.execute()}storeProviderAccessToken(e,t){"string"==typeof t?Me.put(ot(e),t):Me.del(ot(e))}updateIdentityToken(e){"string"==typeof e?this.storeIdentityToken(e):this.clearIdentityToken()}async _authenticate(e){try{let t=await e.authenticate(),{user:n,is_new_user:r,oauth_tokens:a}=t;this.handleTokenResponse(t);let i=a?{provider:a.provider,accessToken:a.access_token,accessTokenExpiresInSeconds:a.access_token_expires_in_seconds,refreshToken:a.refresh_token,refreshTokenExpiresInSeconds:a.refresh_token_expires_in_seconds,scopes:a.scopes}:void 0;return this._trackAuthenticateEvents(e,r),{user:F(n),isNewUser:r,oAuthTokens:i}}catch(e){throw console.warn("Error authenticating session"),Oe(e)}}_trackAuthenticateEvents(e,t){let n=function(e){return e instanceof Yr?"email":e instanceof wa?"sms":e instanceof ha?"siwe":e instanceof vs?"guest":e instanceof Bi?"custom_auth":e instanceof oa?e.meta.provider:null}(e);n&&this.client&&this.client.createAnalyticsEvent({eventName:"sdk_authenticate",payload:{method:n,isNewUser:t}}),"siwe"===n&&this.client&&this.client.createAnalyticsEvent({eventName:"sdk_authenticate_siwe",payload:{connectorType:e.meta.connectorType,walletClientType:e.meta.walletClientType}})}async _link(e){try{let t=await e.link(),n=t.oauth_tokens,r=n?{provider:n.provider,accessToken:n.access_token,accessTokenExpiresInSeconds:n.access_token_expires_in_seconds,refreshToken:n.refresh_token,refreshTokenExpiresInSeconds:n.refresh_token_expires_in_seconds,scopes:n.scopes}:void 0;return{user:F(t),oAuthTokens:r}}catch(e){throw console.warn("Error linking account"),Oe(e)}}async _refresh(){if(!this.api)throw new Ce("Session has no API instance");if(!this.client)throw new Ce("Session has no PrivyClient instance");await this.client.getAccessToken({disableAutoRefresh:!0});let e=this.token,t=this.refreshToken;if(this.client.useServerCookies&&!this.mightHaveServerCookies&&this.token&&window.location.origin===this.client.apiUrl)return this.destroyLocalState(),null;try{let n;if(!(e&&t||this.mightHaveServerCookies))return null;{let r={};e&&(r.authorization=`Bearer ${e}`),n=await this.api.post(Xt,t?{refresh_token:t}:{},{headers:r})}return this.handleTokenResponse(n),F(n.user)}catch(e){if(e instanceof Pe&&e.privyErrorCode===_e.MISSING_OR_INVALID_TOKEN)return console.warn("Unable to refresh tokens - token is missing or no longer valid"),this.destroyLocalState(),null;throw Oe(e)}}handleTokenResponse(e){e.session_update_action&&"set"!==e.session_update_action?"clear"===e.session_update_action?this.destroyLocalState():"ignore"===e.session_update_action&&(e.token&&(this.storeCustomerAccessToken(e.token),this.storePrivyAccessToken(e.privy_access_token)),e.identity_token&&this.storeIdentityToken(e.identity_token)):this._storeAllTokens(e)}_storeAllTokens(e){this.storeRefreshToken(e.refresh_token),this.storeCustomerAccessToken(e.token),this.storePrivyAccessToken(e.privy_access_token),e.identity_token&&this.storeIdentityToken(e.identity_token)}async _destroy(){try{await(this.api?.post(en,{refresh_token:this.refreshToken}))}catch(e){console.warn("Error destroying session")}this.destroyLocalState()}destroyLocalState(){this.storeRefreshToken(null),this.storeCustomerAccessToken(null),this.storePrivyAccessToken(null),this.clearIdentityToken()}storeCustomerAccessToken(e){if("string"==typeof e){let t=Me.get(Ge);if(Me.put(Ge,e),!this.client?.useServerCookies){let t=Rr.parse(e)?.expiration;Ar.set(dt,e,{sameSite:"Strict",secure:As(),expires:t?new Date(1e3*t):void 0})}t!==e&&this.client?.onStoreCustomerAccessToken?.(e)}else Me.del(Ge),Ar.remove(dt),this.client?.onDeleteCustomerAccessToken?.()}storeRefreshToken(e){"string"==typeof e?(Me.put(st,e),this.client?.useServerCookies||Ar.set(lt,"t",{sameSite:"Strict",secure:As(),expires:30})):(Me.del(st),Ar.remove(ut),Ar.remove(lt))}storePrivyAccessToken(e){"string"==typeof e?Me.put($e,e):Me.del($e)}storeIdentityToken(e){if(ws.setState({identityToken:e}),this.client?.useServerCookies)return;Me.put(ht,e);let t=Rr.parse(e)?.expiration;Ar.set(pt,e,{sameSite:"Strict",secure:As(),expires:t?new Date(1e3*t):void 0})}clearIdentityToken(){Me.del(ht),ws.setState({identityToken:null}),Ar.remove(pt)}constructor(){this.authenticateOnce=new Qr((async e=>this._authenticate(e))),this.linkOnce=new Qr((async e=>this._link(e))),this.refreshOnce=new Qr(this._refresh.bind(this)),this.destroyOnce=new Qr(this._destroy.bind(this))}}let _s,bs;var Ss=0,Es="__private_"+Ss+++"__getOrGenerateClientAnalyticsId";class Is{getAppId(){return this.appId}initializeConnectorManager({walletConnectCloudProjectId:e,rpcConfig:t,chains:n,defaultChain:r,store:a,walletList:i,shouldEnforceDefaultChainOnConnect:s,externalWalletConfig:o,appName:l,walletChainType:c,setBaseAccountSdk:d}){this.connectors||(this.connectors=new ps(this.appId,e,t,n,r,a,i,s,o,l,d,c))}generateApi(){let e=new gs({appId:this.appId,appClientId:this.appClientId,client:this,defaults:{baseURL:this.apiUrl,timeout:this.timeout}});return this.session.api=e,e}updateApiUrl(e){this.apiUrl=e||this.fallbackApiUrl,this.api=this.generateApi(),e&&(this.useServerCookies=!0)}authenticate(){if(!this.authFlow)throw new Ce("No auth flow in progress.");return this.session.authenticate(this.authFlow)}async link(){if(!this.authFlow)throw new Ce("No auth flow in progress.");let{oAuthTokens:e}=await this.session.link(this.authFlow);return{user:await this.getAuthenticatedUser(),oAuthTokens:e}}storeProviderAccessToken(e,t){this.session.storeProviderAccessToken(e,t)}getProviderAccessToken(e){return this.session.getProviderAccessToken(e)}async logout(){await this.session.destroy(),this.authFlow=void 0}clearProviderAcccessTokens(e){e.linkedAccounts.filter((e=>"cross_app"===e.type)).forEach((e=>{this.storeProviderAccessToken(e.providerApp.id,null)}))}startAuthFlow(e){return e.api=this.api,this.authFlow=e,this.authFlow}async initMfaSmsVerification(){try{await this.api.post(rn,{action:"verify"})}catch(e){throw Te(e)}}async initMfaPasskeyVerification(){try{let e=await this.api.post(an,{});return fs(e.options)}catch(e){throw Te(e)}}async getCrossAppProviderDetails(e){try{return this._cachedProviderAppDetails[e]||(this._cachedProviderAppDetails[e]=await this.api.get(`/api/v1/apps/${e}/cross-app/details`)),this._cachedProviderAppDetails[e]}catch(e){console.error("Error fetching cross app provider details",e)}}async acceptTerms(){try{let e=await this.api.post(sn,{});return F(e)}catch(e){throw Oe(e)}}async unlinkEmail(e){try{let t=await this.api.post(on,{address:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async unlinkPhone(e){try{let t=await this.api.post(ln,{phoneNumber:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async unlinkEthereumWallet(e){try{let t=await this.api.post(cn,{address:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async unlinkSolanaWallet(e){try{let t=await this.api.post(dn,{address:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async unlinkOAuth(e,t){try{let n=await this.api.post(un,{provider:e,subject:t});return await this.getAuthenticatedUser()??F(n)}catch(e){throw Oe(e)}}async unlinkFarcaster(e){try{let t=await this.api.post(hn,{fid:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async unlinkTelegram(e){try{let t=await this.api.post(pn,{telegram_user_id:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async revokeDelegatedWallet(){try{await this.api.post(wn,{})}catch(e){throw Oe(e)}}async createAnalyticsEvent({eventName:e,payload:t,timestamp:n,options:r}){if("undefined"!=typeof window)try{this.clientAnalyticsId||console.warn("No client analytics id set, refusing to send analytics event"),await this.api.post(tn,{event_name:e,client_id:this.clientAnalyticsId,payload:{...t||{},clientTimestamp:n?n.toISOString():(new Date).toISOString()}},{retry:-1,keepalive:r?.keepAlive??!1})}catch(e){console.log("Unable to submit event. This is not an issue.")}}async signMoonpayOnRampUrl(e){try{return this.api.post(mn,e)}catch(e){throw Oe(e)}}async initCoinbaseOnRamp(e){try{return this.api.post(yn,e)}catch(e){throw Oe(e)}}async getCoinbaseOnRampStatus({partnerUserId:e}){try{return this.api.get(`${gn}?partnerUserId=${e}`)}catch(e){throw Oe(e)}}async getAuthenticatedUser(){return this.session.hasRefreshCredentials()?this.session.refresh():null}async getAccessToken(e){return await this.getPrivyAccessToken(e)||await this.getCustomerAccessToken(e)}async getCustomerAccessToken(e){return await this._getToken(Cs.CUSTOMER,e)}async getPrivyAccessToken(e){return await this._getToken(Cs.PRIVY,e)}async _getToken(e,t){return this.session.getToken(e)?this.session.hasActiveAccessToken(e)?this.session.hasRefreshCredentials(e)?Mr.parse(this.session.getToken(e))?.appId!==this.appId?(await this.logout(),null):this.session.getToken(e):(this.session.destroyLocalState(),null):!t?.disableAutoRefresh&&this.session.hasRefreshCredentials(e)?(await this.session.refresh(),this.session.getToken(e)):null:null}async getUsdTokenPrice(e){try{return(await this.api.get(`/api/v1/token_price?chainId=${e.id}&tokenSymbol=${e.nativeCurrency.symbol}`)).usd}catch(t){return void console.error(`Unable to fetch token price for chain with id ${e.id}`)}}async getUsdPriceForSol(){try{return(await this.api.get("/api/v1/token_price?chainId=0&tokenSymbol=SOL")).usd}catch(e){return void console.error("Unable to fetch token price for SOL")}}async getSplTokenMetadata({mintAddress:e,cluster:t}){try{return await this.api.get(`/api/v1/spl_token_info?mint_address=${e}&cluster=${t}`)}catch(n){return void console.error(`Unable to fetch token metadata for ${t}:${e}`)}}async requestFarcasterSignerStatus(e){try{return await this.api.post("/api/v1/farcaster/signer/status",{ed25519_public_key:e})}catch(e){throw console.error("Unable to fetch Farcaster signer status"),e}}async generateSiweNonce({address:e,captchaToken:t}){try{return(await this.api.post(fn,{address:e,token:t})).nonce}catch(e){throw Oe(e)}}async authenticateWithSiweInternal({message:e,signature:t,chainId:n,walletClientType:r,connectorType:a,mode:i}){return await this.api.post(vn,{message:e,signature:t,chainId:n,walletClientType:r,connectorType:a,mode:i})}async linkWithSiweInternal({message:e,signature:t,chainId:n,walletClientType:r,connectorType:a}){return await this.api.post(An,{message:e,signature:t,chainId:n,walletClientType:r,connectorType:a})}async linkSmartWallet({message:e,signature:t,smartWalletType:n,smartWalletVersion:r}){try{let a=await this.api.post(kn,{message:e,signature:t,smart_wallet_type:n,smart_wallet_version:r});return F(a)}catch(e){throw Oe(e)}}async linkWithSiwe({message:e,signature:t,chainId:n,walletClientType:r,connectorType:a}){try{let i=await this.linkWithSiweInternal({message:e,signature:t,chainId:n,walletClientType:r,connectorType:a});return F(i)}catch(e){throw Oe(e)}}async generateSiwsNonce({address:e,captchaToken:t}){try{return(await this.api.post(Cn,{address:e,token:t})).nonce}catch(e){throw Oe(e)}}async authenticateWithSiwsInternal({message:e,signature:t,walletClientType:n,connectorType:r,mode:a,messageType:i="plain"}){return await this.api.post(Tn,{message:e,signature:t,walletClientType:n,connectorType:r,mode:a,message_type:i})}async authenticateWithSiws({message:e,signature:t,walletClientType:n,connectorType:r,mode:a,messageType:i="plain"}){let s=await this.authenticateWithSiwsInternal({message:e,signature:t,walletClientType:n,connectorType:r,mode:a,messageType:i});this.session.handleTokenResponse(s);let o=F(s.user);if(!o)throw Error("Authentication failed - no user returned");return{user:o,isNewUser:s.is_new_user||!1}}async sendAccountTransferRequest({nonce:e,account:t,accountType:n,externalWalletMetadata:r,telegramAuthResult:a,telegramWebAppData:i,farcasterEmbeddedAddress:s,oAuthUserInfo:o}){try{let l,c;switch(n){case"email":l=Wn,c={nonce:e,email:t};break;case"sms":l=Pn,c={nonce:e,phoneNumber:t};break;case"siwe":if(l=In,!r)throw Error("Wallet parameters must be defined");c={nonce:e,address:t,...r};break;case"farcaster":l=En,c={nonce:e,farcaster_id:t,farcaster_embedded_address:s};break;case"telegram":l=Sn,c={nonce:e,telegram_auth_result:a,telegram_web_app_data:i};break;case"siws":l=bn,c={nonce:e,address:t,...r};break;case"custom":case"guest":case"passkey":throw Error("Invalid transfer account type");default:l=_n,c={nonce:e,userInfo:o}}let d=await this.api.post(l,c);return await this.getAuthenticatedUser()??F(d)}catch(e){throw Oe(e)}}async linkWithSiwsInternal({message:e,signature:t,walletClientType:n,connectorType:r,messageType:a="plain"}){return await this.api.post(Un,{message:e,signature:t,walletClientType:n,connectorType:r,message_type:a})}async linkWithSiws({message:e,signature:t,walletClientType:n,connectorType:r,messageType:a="plain"}){try{let i=await this.linkWithSiwsInternal({message:e,signature:t,walletClientType:n,connectorType:r,messageType:a});return F(i)}catch(e){throw Oe(e)}}async updateUserAndIdToken(){try{let e=await this.api.get(Nn);return this.session.updateIdentityToken(e.identity_token),F(e.user)}catch(e){throw Oe(e)}}async scanTransaction(e){try{return await this.api.post(On,e)}catch(e){throw Oe(e)}}constructor({apiUrl:e=nt,appId:t,appClientId:n,timeout:r=wt}){Object.defineProperty(this,Es,{value:Ps}),this._cachedProviderAppDetails={},this.apiUrl=e,this.fallbackApiUrl=this.apiUrl,this.useServerCookies=e!==nt&&e.startsWith("https://privy."),this.timeout=r,this.appId=t,this.appClientId=n,this.clientAnalyticsId=function(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e}(this,Es)[Es](),_s||(_s=new Ts),this.session=_s,this.api=this.generateApi(),this.session.client=this}}function Ps(){if("undefined"==typeof window)return null;try{let e=Me.get(rt);if("string"==typeof e&&e.length>0)return e}catch(e){}let e=A();try{return Me.put(rt,e),e}catch(t){return e}}function Ws(){if(!bs)throw new Ce("No global PrivyClient instance found. Please ensure you have initialized the PrivyProvider.");return bs}async function Us(){return await(bs?.updateUserAndIdToken()),bs?.useServerCookies?ws.getState().identityToken:Promise.resolve(Me.get(ht)||null)}const Ns=({config:e,...n})=>{(()=>{if(a(Yi))throw new Ce("Multiple PrivyProvider instances found","Found multiple instances of PrivyProvider, ensure there is only one mounted in your application tree.")})(),function(){if("undefined"==typeof window)return;let e=["localhost","127.0.0.1"].includes(window.location.hostname),t="https:"===window.location.protocol||"chrome-extension:"===window.location.protocol;if(!e&&!t)throw new Ce("Embedded wallet is only available over HTTPS")}(),function(e){if("string"!=typeof e||25!==e.length)throw new Ce("Cannot initialize the Privy provider with an invalid Privy app ID")}(n.appId),function(e){bs||(bs=new Is({appId:e.appId,appClientId:e.clientId,apiUrl:e.apiUrl}))}(n);let r=l((()=>new p({appId:n.appId,clientId:n.clientId,storage:Me,baseUrl:n.apiUrl,sdkVersion:"react-auth:3.10.0"})),[]),i=Ws(),s=Object.assign({},e);/*#__PURE__*/return t(mt,{client:r,legacyClient:i,appClientId:n.clientId,clientConfig:s,children:/*#__PURE__*/t(Bn,{children:/*#__PURE__*/t(ts,{...n,client:i,privy:r})})})},Os=()=>{let{user:e}=T(),{walletProxy:t}=Ie();return{recover:h((async n=>{if(!t)throw Error("Wallet proxy is not ready");let r=await Kr();if(!e||!r)throw new Ce("User must be logged in before attempting to modify the recovery method.");let{entropyId:a,entropyIdVerifier:i}=ve(e);try{await t.recover({entropyId:a,entropyIdVerifier:i,accessToken:r,...n})}catch{throw new Ce("Unable to recover wallets")}}),[t,e])}};function Rs(){let{promptMfa:e,init:t,submit:n,cancel:r,mfaMethods:i}=a(R);return{promptMfa:e,init:t,submit:n,cancel:r,mfaMethods:i}}function Ms(){let{initEnrollmentWithSms:e,initEnrollmentWithTotp:t,initEnrollmentWithPasskey:n,submitEnrollmentWithSms:r,submitEnrollmentWithTotp:i,submitEnrollmentWithPasskey:s,unenroll:o,enrollInMfa:l}=a(R);return{initEnrollmentWithSms:e,initEnrollmentWithTotp:t,initEnrollmentWithPasskey:n,submitEnrollmentWithSms:r,submitEnrollmentWithTotp:i,submitEnrollmentWithPasskey:s,unenrollWithSms:()=>o("sms"),unenrollWithTotp:()=>o("totp"),unenrollWithPasskey:e=>o("passkey",e),showMfaEnrollmentModal:()=>l(!0),closeMfaEnrollmentModal:()=>l(!1)}}function xs(){let e=Ws();return e?e.getCustomerAccessToken():Promise.resolve(Me.get(Ge)||null)}const Fs=()=>{let{client:e,setAuthenticated:t,setUser:n}=Ie();return l((()=>({init:async()=>{if(!e)throw new Ce("Must initialize Privy client first.");let t=new kr;return e.startAuthFlow(t),await t.init()},login:async({fid:r,message:a,signature:i})=>{if(!e)throw new Ce("Must initialize Privy client first.");if(!(e.authFlow instanceof kr))throw new Ce("Must initialize Farcaster Mini App flow first.");e.authFlow.setAuthData({message:a,signature:i,fid:r});let{user:s}=await e.authenticate();if(!s)throw new Ce("Failed to login with Farcaster V2");return n(s),t(!0),{user:s}}})),[e,n,t])},Ls=()=>l((()=>({getAccessTokenForProvider:({appId:e})=>{try{let t=Me.get(ot(e));if("string"!=typeof t)return{token:null};{let n=new Rr(t);return n.isExpired()?(Me.del(ot(e)),{token:null}):{token:n.value}}}catch(e){return console.error(e),{token:null}}}})),[]),Ds=e=>{Qn("login",e);let t=va(),n=tt(),{ready:r,user:a}=T(),{initLoginWithHeadlessOAuth:i,loginWithHeadlessOAuth:s,oAuthState:o,setOAuthState:l,isHeadlessOAuthLoading:d}=Ie(),u=h((async e=>{try{if(t.enabled&&"success"!==t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);return await i(e.provider,t.token,e.disableSignup)}catch(e){throw l({status:"error",error:e}),e}}),[i,t]),p=h((async()=>{let e=la();try{if(!e.inProgress)throw Error("Cannot login with OAuth because no OAuth flow is in progress");let t=e.provider;if(S(t)){if(a&&a.linkedAccounts.some((e=>e.type===t)))return console.warn("User is already logged in with this OAuth provider"),a}else if(a&&t in a&&a[t])return console.warn("User is already logged in with this OAuth provider"),a;if(e.popupFlow)return}catch(e){throw l({status:"error",error:e}),e}try{return await s(e)}catch(e){throw l({status:"error",error:e}),e}finally{ca()}}),[s]);return c((()=>{let e=la();r&&n&&e.inProgress&&!e.withPrivyUi&&!e.popupFlow&&p().catch((()=>{}))}),[r,n]),{initOAuth:u,loading:d,state:o}},js=e=>{let t=va(),{emailOtpState:n,setEmailOtpState:r,initLoginWithEmail:a,loginWithCode:i}=Ie();return{sendCode:h((async({email:n,disableSignup:i})=>{try{let e;if(!n)throw Error("Email required to send OTP code");if(t.enabled&&"error"===t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);return t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),await a({email:n,captchaToken:e,disableSignup:i,withPrivyUi:!1})}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[a]),loginWithCode:h((async({code:n})=>{try{if(t.enabled&&"error"===t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);let{user:r,isNewUser:a,wasAlreadyAuthenticated:s,linkedAccount:o}=await i(n);e?.onComplete?.({user:r,isNewUser:a,wasAlreadyAuthenticated:s,loginMethod:"email",loginAccount:o})}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[i,t.status]),state:n}},zs=e=>{let t=va(),{initSignupWithPasskey:n,signupWithPasskey:r,passkeyAuthState:a,setPasskeyAuthState:i}=Ie();return{signupWithPasskey:h((async()=>{try{let a;if(t.enabled&&"error"===t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),a=await t.waitForResult()),await n({captchaToken:a,withPrivyUi:!1});let{user:i,isNewUser:s,wasAlreadyAuthenticated:o,loginAccount:l}=await r();e?.onComplete?.({user:i,isNewUser:s,wasAlreadyAuthenticated:o,loginMethod:"passkey",loginAccount:l})}catch(t){throw i({status:"error",error:t}),e?.onError?.(t.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),t}}),[r,t.status]),state:a}},qs=e=>{let t=va(),{initLoginWithPasskey:n,loginWithPasskey:r,passkeyAuthState:a,setPasskeyAuthState:i}=Ie();return{loginWithPasskey:h((async a=>{try{let i;if(t.enabled&&"error"===t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),i=await t.waitForResult()),await n({captchaToken:i,withPrivyUi:!1});let{user:s,isNewUser:o,wasAlreadyAuthenticated:l,loginAccount:c}=await r(a);e?.onComplete?.({user:s,isNewUser:o,wasAlreadyAuthenticated:l,loginMethod:"passkey",loginAccount:c})}catch(a){throw i({status:"error",error:a}),e?.onError?.(a.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),a}}),[r,t.status]),state:a}},Hs=e=>{let{initLinkWithPasskey:t,linkWithPasskey:n,passkeyAuthState:r,setPasskeyAuthState:a}=Ie();return{linkWithPasskey:h((async()=>{try{await t();let r=await n();if(!r)throw Error("Error, user not found");let a=r.linkedAccounts.filter((e=>"passkey"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0];e?.onSuccess?.({user:r,linkMethod:"passkey",linkedAccount:a})}catch(t){throw a({status:"error",error:t}),e?.onError?.(t.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),t}}),[n]),state:r}},Vs=e=>{let t=va(),{smsOtpState:n,setSmsOtpState:r,initLoginWithSms:a,loginWithCode:i}=Ie();return{sendCode:h((async({phoneNumber:n,disableSignup:i})=>{try{let e;if(!n)throw Error("SMS required to send OTP code");if(t.enabled&&"error"===t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);return t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),await a({phoneNumber:n,captchaToken:e,disableSignup:i,withPrivyUi:!1})}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[a]),loginWithCode:h((async({code:n})=>{try{if(t.enabled&&"error"===t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);let{user:r,isNewUser:a,wasAlreadyAuthenticated:s,linkedAccount:o}=await i(n);e?.onComplete?.({user:r,isNewUser:a,wasAlreadyAuthenticated:s,loginMethod:"sms",loginAccount:o})}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[i,t.status]),state:n}},Bs=e=>{let{connectOrCreateWallet:t}=T();return Qn("connectOrCreateWallet",e),{connectOrCreateWallet:t}},Ks=e=>{let t=va(),{siweState:n,setSiweState:r,linkWithSiwe:a,generateSiweMessage:i}=Ie();return{generateSiweMessage:h((async({address:t,chainId:n})=>{try{if(!t||!n)throw Error("wallet address and chainId required to generate nonce");return await i({address:t,chainId:n}).then((e=>e))}catch(t){throw r({status:"error",error:t}),e?.onError?.(t.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),t}}),[i]),linkWithSiwe:h((async({signature:n,message:i,chainId:s,walletClientType:o,connectorType:l})=>{try{if(t.enabled&&"success"!==t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);let{user:r,linkedAccount:c}=await a({message:i,signature:n,chainId:s,walletClientType:o,connectorType:l});c&&e?.onSuccess?.({user:r,linkMethod:"siwe",linkedAccount:c})}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),n}}),[a,t.status]),state:n}},$s=e=>{let t=va(),{siweState:n,setSiweState:r,client:a,generateSiweMessage:i,loginWithSiwe:s}=Ie();return{generateSiweNonce:h((async n=>{try{let e;if(t.enabled&&"error"===t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),r({status:"generating-message"});let i=await a.generateSiweNonce({address:n?.address,captchaToken:e});return r({status:"awaiting-signature"}),i}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[a,t]),generateSiweMessage:h((async({address:n,chainId:a})=>{try{let e;if(t.enabled&&"error"===t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);return t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),await i({address:n,chainId:a,captchaToken:e})}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[i,t]),loginWithSiwe:h((async({message:n,signature:a,disableSignup:i,walletClientType:o,connectorType:l})=>{try{let r;if(t.enabled&&"error"===t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),r=await t.waitForResult());let{user:c,isNewUser:d}=await s({message:n,signature:a,captchaToken:r,disableSignup:i,walletClientType:o,connectorType:l});return e?.onComplete?.({user:c,isNewUser:d,wasAlreadyAuthenticated:!1,loginMethod:"siwe",loginAccount:null}),c}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[s,t.status]),state:n}},Gs=()=>{let e=va(),{client:t,setAuthenticated:n,setUser:r,setIsNewUser:a}=Ie(),{authenticated:i}=zn();return{generateSiwsMessage:h((async({address:n})=>{let r;if(e.enabled&&"error"===e.status)throw new ga(e.error,null,_e.CAPTCHA_FAILURE);e.enabled&&"success"!==e.status&&(e.execute(),r=await e.waitForResult());let a=await t.generateSiwsNonce({address:n,captchaToken:r});return Mn({address:n,nonce:a})}),[e,t]),loginWithSiws:h((async({message:s,signature:o,disableSignup:l,walletClientType:c,connectorType:d})=>{if(i)throw Error("User already authenticated");if(e.enabled&&"error"===e.status)throw new ga(e.error,null,_e.CAPTCHA_FAILURE);e.enabled&&"success"!==e.status&&(e.execute(),await e.waitForResult());let{user:u,isNewUser:h}=await t.authenticateWithSiws({message:s,signature:o,walletClientType:c,connectorType:d,mode:l?"no-signup":"login-or-sign-up",messageType:"plain"});if(!u)throw Error("Authentication failed - no user returned");return r(u),a(h||!1),n(!0),u}),[i,e,t,n,r,a])}},Ys=()=>{let e=va(),{client:t,setUser:n,refreshSessionAndUser:r}=Ie(),{authenticated:a}=zn();return{generateSiwsMessage:h((async({address:n})=>{let r;if(e.enabled&&"error"===e.status)throw new ga(e.error,null,_e.CAPTCHA_FAILURE);e.enabled&&"success"!==e.status&&(e.execute(),r=await e.waitForResult());let a=await t.generateSiwsNonce({address:n,captchaToken:r});return Mn({address:n,nonce:a})}),[e,t]),linkWithSiws:h((async({signature:i,message:s,walletClientType:o,connectorType:l})=>{if(!a)throw Error("User must be authenticated before linking");if(e.enabled&&"error"===e.status)throw new ga(e.error,null,_e.CAPTCHA_FAILURE);let c=await t.linkWithSiws({message:s,signature:i,walletClientType:o,connectorType:l,messageType:"plain"}),d=(e=>{if(!e)return;let t=e.linkedAccounts;return t&&0!==t.length?t[t.length-1]:void 0})(c=await r()??c)||null;return n(c||null),{user:c,linkedAccount:d}}),[a,e,t,r,n])}};function Js(){let{signTransaction:e}=a(R);return{signTransaction:e}}function Qs(e){let{linkEmail:t,linkPhone:n,linkWallet:r,linkGoogle:i,linkApple:s,linkTwitter:o,linkTwitch:l,linkDiscord:c,linkGithub:d,linkLinkedIn:u,linkTiktok:h,linkLine:p,linkSpotify:w,linkInstagram:m,linkTelegram:y,linkFarcaster:g,linkPasskey:f}=a(R);return Qn("linkAccount",e),{linkEmail:t,linkPhone:n,linkWallet:r,linkGoogle:i,linkApple:s,linkTwitter:o,linkTwitch:l,linkDiscord:c,linkGithub:d,linkLinkedIn:u,linkTiktok:h,linkLine:p,linkSpotify:w,linkInstagram:m,linkFarcaster:g,linkTelegram:y,linkPasskey:f}}function Zs(e){let{updateEmail:t,updatePhone:n}=a(R);return Qn("update",e),{updateEmail:t,updatePhone:n}}const Xs=e=>{let{user:t}=T(),{loginWithCode:n,emailOtpState:r,setEmailOtpState:a,client:i,inProgressAuthFlowRef:s,inProgressLoginOrLinkMethodRef:o}=Ie();return{state:r,sendCode:h((async({newEmailAddress:n})=>{try{if(!t?.email)throw Error("User is required to have an email address to update it.");let e=new Jr(t.email.address,n);i.startAuthFlow(e),await e.sendCodeEmail({withPrivyUi:!1})}catch(n){a({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"email"})}}),[t?.email]),verifyCode:h((async({code:r})=>{try{if(!t?.email)throw Error("User is required to have an email address to update it.");s.current="update",o.current="email";let{user:a,linkedAccount:i}=await n(r);return e?.onSuccess?.({user:a,updateMethod:"email",updatedAccount:i}),{user:a}}catch(r){a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"email"})}}),[t?.email])}},eo=()=>{let{connectCoinbaseSmartWallet:e}=Ie();return{connectCoinbaseSmartWallet:e}},to=()=>{let{connectBaseAccount:e}=Ie();return{connectBaseAccount:e}},no=()=>{let{baseAccountSdk:e}=Ie();return{baseAccountSdk:e}},ro=()=>{let{setModalData:e}=_(),{openModal:t,privy:n,closePrivyModal:r}=Ie(),{user:a}=T();return l((()=>({verify:async({standalone:i=!0}={standalone:!0})=>new Promise(((s,o)=>a?0===a.mfaMethods.length?s():(e((e=>({...e,mfaVerify:{onSuccess:async()=>{i?await r({shouldCallAuthOnSuccess:!1,isSuccess:!0}):Pa.setState({inProgressMfaFlow:void 0}),s()},onFailure:async e=>{i?await r({shouldCallAuthOnSuccess:!1,isSuccess:!1}):Pa.setState({inProgressMfaFlow:void 0}),o(e)},sendSmsCode:async()=>{throw Error("Not enabled")},verifySmsCode:async()=>{throw Error("Not enabled")},verifyTotpCode:async e=>{await n.fetchPrivyRoute(_r,{body:{code:e}})},generateOptions:async()=>fs((await n.fetchPrivyRoute(Tr,{body:{}})).options),verifyPasskey:async e=>{let t=await import("@simplewebauthn/browser"),r=await t.startAuthentication({optionsJSON:e});await n.fetchPrivyRoute(Cr,{body:{authenticator_response:qi(r)}})}}}))),void(i?t("MfaAuthVerifyFlowScreen"):Pa.setState({inProgressMfaFlow:"auth"}))):o(Error("Must be logged in to verify MFA"))))})),[n,e,t,r])},ao=()=>{let e=Xe(),{setModalData:t}=_(),{verify:n}=ro(),{openModal:r,privy:a,closePrivyModal:i,refreshSessionAndUser:s,setUser:o}=Ie();return l((()=>({enroll:async l=>new Promise(((c,d)=>{t({mfaEnroll:{onSuccess:async e=>{await i({shouldCallAuthOnSuccess:!1,isSuccess:!0}),c(e)},onFailure:async e=>{await i({shouldCallAuthOnSuccess:!1,isSuccess:!1}),d(e)},onBack:l?.onBack?async()=>{await i({shouldCallAuthOnSuccess:!1,isSuccess:!1}),d(Error("User canceled MFA enrollment flow.")),l.onBack?.()}:void 0,verify:()=>n({standalone:!1}),shouldUnlinkOnUnenrollMfa:!0,mfaMethods:e.mfa.methods,sendSmsCode:async()=>{throw Error("Not enabled")},enrollSms:async()=>{throw Error("Not enabled")},unenrollSms:async()=>{throw Error("Not enabled")},generateTotpSecret:async()=>await a.fetchPrivyRoute(Ir,{body:{}}),enrollTotp:async e=>{await a.fetchPrivyRoute(Er,{body:{code:e}});let t=await s();return o(t),t},unenrollTotp:async()=>{await a.fetchPrivyRoute(Sr,{body:{}});let e=await s();return o(e),e},enrollPasskey:async e=>{await a.fetchPrivyRoute(br,{body:{credential_ids:e,remove_for_login:!0}});let t=await s();return o(t),t}}}),r("MfaAuthEnrollmentFlowScreen")}))})),[a,t,r,i])},io=()=>{let{startCrossAppAuthFlow:e,unlinkCrossAppAccount:t,signMessageWithCrossAppWallet:n,signTypedDataWithCrossAppWallet:r,sendTransactionWithCrossAppWallet:a,signTransactionWithCrossAppWallet:i}=T();return{loginWithCrossAppAccount:({appId:t})=>e({appId:t,action:"login"}),linkCrossAppAccount:({appId:t})=>e({appId:t,action:"link"}),unlinkCrossAppAccount:t,signMessage:n,signTypedData:r,sendTransaction:a,signTransaction:i}};function so(e){let{sendTransaction:t}=a(R);return Qn("sendTransaction",e),{sendTransaction:t}}function oo(){let e=Xe(),t=Zn(),{client:n,setUser:r,setAuthenticated:a,setIsNewUser:i,initializeWalletProxy:s}=Ie(),{create:o}=Kn();return{createGuestAccount:async()=>{if(!e.id||!n)throw Error("SDK not yet ready");n.startAuthFlow(new vs(e.id));try{let l=await n.authenticate(),c=l.user,d=l.isNewUser??!1;if(!c)throw new Ce("Unable to authenticate guest account");let u=await n.getAccessToken(),h=await s(yt);if(u&&h)try{let t=Mi(c,e.embeddedWallets.ethereum.createOnLogin),n=Fi(c,e.embeddedWallets.solana.createOnLogin);t&&n?(c=(await o({chainType:"ethereum",latestUser:c})).user,c=(await o({chainType:"solana",latestUser:c})).user):n?c=(await o({chainType:"solana",latestUser:c})).user:t?c=(await o({chainType:"ethereum",latestUser:c})).user:r(c)}catch(e){r(c),console.warn("Unable to create embedded wallet for guest account")}return i(d),a(!0),t("login","onComplete",{user:c,isNewUser:d,wasAlreadyAuthenticated:!1,loginMethod:"guest",loginAccount:null}),c}catch(e){throw t("login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}}}}function lo(e){let{setWalletRecovery:t}=a(R);return Qn("setWalletRecovery",e),{setWalletRecovery:t}}function co(e){let{signMessage:t}=a(R);return Qn("signMessage",e),{signMessage:t}}const uo=()=>{let{ready:e,wallets:t}=ge(),{user:n}=T(),{rpcConfig:r,chains:a,appId:i}=Ie();return{signAuthorization:h((async(s,o)=>{let l;if(!n)throw Error("User must be authenticated before signing with a Privy wallet");if(!e)throw Error("Wallets are not ready");let c=o?.address??E(n)?.address??hr,d=t.find((e=>pr(e.address)===pr(c)));if(!d)throw Error("Signing wallet not found.");let u=s.chainId??Number(d.chainId.split(":")[1]);if(0===u)l={chainId:0,address:s.contractAddress,nonce:s.nonce??0};else{let e=a.find((e=>e.id===u));if(!e)throw Error("Error, chain not configured in PrivyProvider config");let t=wr({account:c,chain:e,transport:mr(fr(e,r,i))});l=await t.prepareAuthorization({...s})}let h=await d.getEthereumProvider(),p=await h.request({method:"secp256k1_sign",params:[St(l)]});return{...l,...yr(p)}}),[e,t,n,a])}};function ho(e){let{signTypedData:t}=a(R);return Qn("signTypedData",e),{signTypedData:t}}const po=async({wallet:e})=>{let t=await e.getEthereumProvider();return Nr({address:e.address,sign:async({hash:n})=>{if("privy"!==e.walletClientType)throw new y({error:"Unprefixed signing is not supported by external wallets.",code:"unsupported_wallet_type"});return await t.request({method:"secp256k1_sign",params:[n]})},signMessage:async({message:n})=>await t.request({method:"personal_sign",params:[n,e.address]}),signTypedData:async n=>await t.request({method:"eth_signTypedData_v4",params:[e.address,n]}),signTransaction:async e=>await t.request({method:"eth_signTransaction",params:[e]})})},wo=()=>{let{wallets:e}=ge();return l((()=>({wrapFetchWithPayment:({walletAddress:t,fetch:n,maxValue:r=BigInt(1e5),paymentRequirementsSelector:a=Pr,config:i})=>{let s=t||e[0]?.address;if(!s)throw new Ur("No wallet available for payment");let o=e.find((e=>L(e.address,s)));if(!o)throw new Ur(`Wallet ${s} not found in connected wallets`);return async(e,t)=>{let s=await n(e,t);if(402!==s.status)return s;if(t?.__is402Retry)throw Error("Payment already attempted for this request");let{x402Version:l,accepts:c}=await s.json(),d=a(c,void 0,"exact");if(BigInt(d.maxAmountRequired)>r)throw new Ur("Payment amount exceeds maximum allowed");let u=await po({wallet:o}),h=await Wr(u,l,d,i),p={...t,headers:{...t?.headers||{},"X-PAYMENT":h,"Access-Control-Expose-Headers":"X-PAYMENT-RESPONSE"},__is402Retry:!0};return await n(e,p)}}})),[e])},mo=()=>{let{isModalOpen:e}=a(R);return{isOpen:e}};function yo(e){let{getAccessToken:t}=a(R);return Qn("accessToken",e),{getAccessToken:t}}function go(e){let{authenticated:t,user:n}=T(),{initLoginWithOAuth:r}=Ie(),a=Zn();return Qn("oAuthAuthorization",e),{reauthorize:e=>fo(t,n,r,a,e.provider)}}let fo=async(e,t,n,r,a)=>{if(!e)throw r("linkAccount","onError",_e.MUST_BE_AUTHENTICATED,{linkMethod:a}),new Ce("User must be authenticated before linking an account.");if(!t?.linkedAccounts.some((e=>e.type.includes(a))))throw new Ce(`OAuth account of type ${a} not linked to the account.`);await n(a)};function vo(e){let{client:t}=Ie(),[n,r]=o({status:"initial"});return{linkWithCustomJwt:h((async n=>{try{r({status:"initial"}),t.startAuthFlow(new Bi(n)),r({status:"loading"});let{user:a}=await t.link();if(!a)throw Error("Error, user not found");let i=a.linkedAccounts.filter((e=>"custom_auth"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime())).at(0);return r({status:"done"}),e?.onSuccess?.({user:a,linkMethod:"custom",linkedAccount:i}),{user:a}}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"custom"}),n}}),[t.startAuthFlow,t.link]),state:n}}const Ao=e=>{let t=$i((e=>e.jwtAuthFlowState));return Qn("customAuth",e),{status:t}};function ko({isAuthenticated:e,isLoading:t,...n}){let r=s();c((()=>{t||r.current?.()}),[e,t]);let a=h((e=>(r.current=e,()=>{r.current=void 0})),[]);return Ki({...n,subscribe:a})}function Co(){let{getFarcasterSignerPublicKey:e,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:n}=T();return{getFarcasterSignerPublicKey:e,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:n}}const To=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=Ie();return{delegateWallet:async({address:e,chainType:n})=>await t({address:e,chainType:n,showDelegationUIs:!0}),revokeWallets:async()=>await e({showDelegationUIs:!0})}},_o=()=>{let{user:e}=T(),t=Ie(),{signWithUserSigner:n}=Or(),r=async({wallet:r,additional_signers:a})=>{let i=await t.client.getAccessToken();if(!e||!i)throw new Ce("User must be authenticated and have an embedded wallet to delegate actions.");if(!r.id)throw new Ce("Wallet to add signers to must have ID on server");if(!t.walletProxy)throw new Ce("Wallet proxy not initialized.");await f(t.privy,{wallet_id:r.id},n,{additional_signers:a})};return{addSessionSignersInternal:async({address:n,signers:a})=>{let i=await t.client.getAccessToken();if(!e||!i)throw new Ce("User must be authenticated and have an embedded wallet to add a session signer.");let s=t.walletProxy??await t.initializeWalletProxy(15e3);if(!s)throw new Ce("Wallet proxy not initialized.");let o=N(e,n);if(!o)throw new Ce("Address to add signers too is not associated with current user.");if(P(o)){if(0===a.length)throw new Ce("Must specify at least one signer to add.");let e=[...(await g(t.privy,{wallet_id:o.id})).additional_signers,...ye(a)];await r({wallet:o,additional_signers:e})}else{if(o.delegated)return{user:e};if(a.length>0)throw new Ce("Specifying signers in addSessionSigners is only supported for TEE execution and this app uses On-device execution. Pass an empty array for signers instead. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");let r=yi({address:n,user:e}),l=gi({address:n,user:e});await t.recoverEmbeddedWallet({address:n}),await s.createDelegatedAction({accessToken:i,rootWallet:l,delegatedWallets:[r]})}let l=await t.refreshSessionAndUser();if(!l)throw Error("Could not refresh user");return{user:l}},removeSessionSignersInternal:async({address:n})=>{let a=await t.client.getAccessToken();if(!e||!a)throw new Ce("User must be authenticated and have an embedded wallet to delegate actions.");if(!(t.walletProxy??await t.initializeWalletProxy(15e3)))throw new Ce("Wallet proxy not initialized.");let i=N(e,n);if(!i)throw new Ce("Address to remove signers from is not associated with current user.");P(i)?await r({wallet:i,additional_signers:[]}):await t.client.revokeDelegatedWallet();let s=await t.refreshSessionAndUser();if(!s)throw Error("Could not refresh user");return{user:s}}}},bo=()=>{let{addSessionSignersInternal:e,removeSessionSignersInternal:t}=_o();return{addSessionSigners:async({address:t,signers:n})=>e({address:t,signers:n}),removeSessionSigners:async({address:e})=>t({address:e})}},So=()=>{let{addSessionSignersInternal:e,removeSessionSignersInternal:t}=_o();return{addSigners:async({address:t,signers:n})=>e({address:t,signers:n}),removeSigners:async({address:e})=>t({address:e})}},Eo=()=>{let{signWithUserSigner:e}=Or();return l((()=>({async generateAuthorizationSignature(t){let{targetAppId:n,...r}=t,{signature:a}=await v((async({message:t})=>e({message:t,targetAppId:n})),r);return{signature:a}}})),[e])},Io=()=>{let{setUser:e,client:t}=a(Ue),{user:n}=a(R);return{user:n,refreshUser:h((async()=>{let n=await(t?.updateUserAndIdToken());return e(n??null),n}),[t,e])}},Po=e=>{let t=va(),{initLoginWithTelegram:n,loginWithTelegram:r,telegramAuthState:a,setTelegramAuthState:i}=Ie();return{login:h((async a=>{try{if(t.enabled&&"success"!==t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);await n(t.token,a?.disableSignup);let{user:i,isNewUser:s,loginAccount:o,wasAlreadyAuthenticated:l}=await r({intent:"login"});e?.onComplete?.({user:i,isNewUser:s,wasAlreadyAuthenticated:l,loginMethod:"telegram",loginAccount:o})}catch(a){throw i({status:"error",error:a}),e?.onError?.(a.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),a}}),[n,r,t]),state:a}},Wo=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=Ie();return{delegateWallet:async({address:e,chainType:n})=>await t({address:e,chainType:n,showDelegationUIs:!1}),revokeWallets:async()=>await e({showDelegationUIs:!1})}},Uo=Va;export{Bs as $,Fr as A,is as B,ga as C,Lr as D,Ei as E,ss as F,xr as G,Ns as H,Sa as I,ps as J,Os as K,Is as L,Us as M,xs as N,Fs as O,Za as P,ms as Q,Qr as R,pa as S,Ls as T,Ds as U,js as V,Ja as W,zs as X,qs as Y,Hs as Z,Vs as _,va as a,Ks as a0,$s as a1,Gs as a2,Ys as a3,Js as a4,Ia as a5,Qs as a6,Zs as a7,Xs as a8,eo as a9,Wo as aA,Uo as aB,Va as aC,po as aD,ji as aE,to as aa,no as ab,ro as ac,ao as ad,io as ae,so as af,oo as ag,lo as ah,co as ai,uo as aj,ho as ak,wo as al,mo as am,yo as an,go as ao,vo as ap,Ao as aq,Ki as ar,ko as as,Co as at,To as au,bo as av,So as aw,Eo as ax,Io as ay,Po as az,ha as b,Ii as c,Ms as d,ei as e,ii as f,ri as g,ni as h,si as i,ai as j,Fi as k,ca as l,ka as m,ti as n,aa as o,Di as p,ia as q,sa as r,Mi as s,Ri as t,Rs as u,Si as v,Ni as w,Pi as x,Vr as y,Ui as z};

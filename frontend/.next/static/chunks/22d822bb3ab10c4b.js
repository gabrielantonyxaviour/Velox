(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,633069,e=>{"use strict";var t=e.i(960398),n=e.i(971080),r=e.i(149454),a=e.i(227302),o=e.i(82283),s=e.i(626321),i=e.i(401564),c=e.i(681285),l=e.i(150576),d=e.i(851887),C=e.i(886259),p=e.i(436220),h=e.i(24742),u=e.i(210087),N=e.i(360334),g=e.i(378133),m=e.i(291984);let E={convertEVMChainIdToCoinType(e){if(e>=0x80000000)throw Error("Invalid chainId");return(0x80000000|e)>>>0}};var w=e.i(758331),A=e.i(592279),f=e.i(221728);let v=(0,g.proxy)({suggestions:[],loading:!1}),T=(0,A.withErrorBoundary)({state:v,subscribe:e=>(0,g.subscribe)(v,()=>e(v)),subscribeKey:(e,t)=>(0,m.subscribeKey)(v,e,t),async resolveName(e){try{return await h.BlockchainApiController.lookupEnsName(e)}catch(e){throw Error(e?.reasons?.[0]?.description||"Error resolving name")}},async isNameRegistered(e){try{return await h.BlockchainApiController.lookupEnsName(e),!0}catch{return!1}},async getSuggestions(e){try{return v.loading=!0,v.suggestions=[],v.suggestions=(await h.BlockchainApiController.getEnsNameSuggestions(e)).suggestions||[],v.suggestions}catch(e){throw Error(T.parseEnsApiError(e,"Error fetching name suggestions"))}finally{v.loading=!1}},async getNamesForAddress(e){try{if(!t.ChainController.state.activeCaipNetwork)return[];let n=w.StorageUtil.getEnsFromCacheForAddress(e);if(n)return n;let r=await h.BlockchainApiController.reverseLookupEnsName({address:e});return w.StorageUtil.updateEnsCache({address:e,ens:r,timestamp:Date.now()}),r}catch(e){throw Error(T.parseEnsApiError(e,"Error fetching names for address"))}},async registerName(e){let a=t.ChainController.state.activeCaipNetwork,o=t.ChainController.getAccountData(a?.chainNamespace)?.address,s=r.ConnectorController.getAuthConnector();if(!a)throw Error("Network not found");if(!o||!s)throw Error("Address or auth connector not found");v.loading=!0;try{let r=JSON.stringify({name:e,attributes:{},timestamp:Math.floor(Date.now()/1e3)});f.RouterController.pushTransactionStack({onCancel(){f.RouterController.replace("RegisterAccountName")}});let s=await n.ConnectionController.signMessage(r);v.loading=!1;let i=a.id;if(!i)throw Error("Network not found");let c=E.convertEVMChainIdToCoinType(Number(i));await h.BlockchainApiController.registerEnsName({coinType:c,address:o,signature:s,message:r}),t.ChainController.setAccountProp("profileName",e,a.chainNamespace),w.StorageUtil.updateEnsCache({address:o,ens:[{name:e,registered_at:new Date().toISOString(),updated_at:void 0,addresses:{},attributes:[]}],timestamp:Date.now()}),f.RouterController.replace("RegisterAccountNameSuccess")}catch(n){let t=T.parseEnsApiError(n,`Error registering name ${e}`);throw f.RouterController.replace("RegisterAccountName"),Error(t)}finally{v.loading=!1}},validateName:e=>/^[a-zA-Z0-9-]{4,}$/u.test(e),parseEnsApiError:(e,t)=>e?.reasons?.[0]?.description||t});var y=e.i(653157),O=e.i(803468);let b={id:"2b92315d-eab7-5bef-84fa-089a131333f5",name:"USD Coin",symbol:"USDC",networks:[{name:"ethereum-mainnet",display_name:"Ethereum",chain_id:"1",contract_address:"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"},{name:"polygon-mainnet",display_name:"Polygon",chain_id:"137",contract_address:"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"}]},I={id:"USD",payment_method_limits:[{id:"card",min:"10.00",max:"7500.00"},{id:"ach_bank_account",min:"10.00",max:"25000.00"}]},_={providers:N.ONRAMP_PROVIDERS,selectedProvider:null,error:null,purchaseCurrency:b,paymentCurrency:I,purchaseCurrencies:[b],paymentCurrencies:[],quotesLoading:!1},U=(0,g.proxy)(_),k=(0,A.withErrorBoundary)({state:U,subscribe:e=>(0,g.subscribe)(U,()=>e(U)),subscribeKey:(e,t)=>(0,m.subscribeKey)(U,e,t),setSelectedProvider(e){if(e&&"meld"===e.name){let n=t.ChainController.state.activeChain,r=n===i.ConstantsUtil.CHAIN.SOLANA?"SOL":"USDC",a=n?t.ChainController.state.chains.get(n)?.accountState?.address??"":"",s=new URL(e.url);s.searchParams.append("publicKey",N.MELD_PUBLIC_KEY),s.searchParams.append("destinationCurrencyCode",r),s.searchParams.append("walletAddress",a),s.searchParams.append("externalCustomerId",o.OptionsController.state.projectId),U.selectedProvider={...e,url:s.toString()}}else U.selectedProvider=e},setOnrampProviders(e){Array.isArray(e)&&e.every(e=>"string"==typeof e)?U.providers=N.ONRAMP_PROVIDERS.filter(t=>e.includes(t.name)):U.providers=[]},setPurchaseCurrency(e){U.purchaseCurrency=e},setPaymentCurrency(e){U.paymentCurrency=e},setPurchaseAmount(e){k.state.purchaseAmount=e},setPaymentAmount(e){k.state.paymentAmount=e},async getAvailableCurrencies(){let e=await h.BlockchainApiController.getOnrampOptions();U.purchaseCurrencies=e.purchaseCurrencies,U.paymentCurrencies=e.paymentCurrencies,U.paymentCurrency=e.paymentCurrencies[0]||I,U.purchaseCurrency=e.purchaseCurrencies[0]||b,await C.ApiController.fetchCurrencyImages(e.paymentCurrencies.map(e=>e.id)),await C.ApiController.fetchTokenImages(e.purchaseCurrencies.map(e=>e.symbol))},async getQuote(){U.quotesLoading=!0;try{let e=await h.BlockchainApiController.getOnrampQuote({purchaseCurrency:U.purchaseCurrency,paymentCurrency:U.paymentCurrency,amount:U.paymentAmount?.toString()||"0",network:U.purchaseCurrency?.symbol});return U.quotesLoading=!1,U.purchaseAmount=Number(e?.purchaseAmount.amount),e}catch(e){return U.error=e.message,U.quotesLoading=!1,null}finally{U.quotesLoading=!1}},resetState(){U.selectedProvider=null,U.error=null,U.purchaseCurrency=b,U.paymentCurrency=I,U.purchaseCurrencies=[b],U.paymentCurrencies=[],U.paymentAmount=void 0,U.purchaseAmount=void 0,U.quotesLoading=!1}}),S={eip155:void 0,solana:void 0,polkadot:void 0,bip122:void 0,cosmos:void 0,sui:void 0,stacks:void 0},R=(0,g.proxy)({providers:{...S},providerIds:{...S}}),P={state:R,subscribeKey:(e,t)=>(0,m.subscribeKey)(R,e,t),subscribe:e=>(0,g.subscribe)(R,()=>{e(R)}),subscribeProviders:e=>(0,g.subscribe)(R.providers,()=>e(R.providers)),setProvider(e,t){e&&t&&(R.providers[e]=(0,g.ref)(t))},getProvider(e){if(e)return R.providers[e]},setProviderId(e,t){t&&(R.providerIds[e]=t)},getProviderId(e){if(e)return R.providerIds[e]},reset(){R.providers={...S},R.providerIds={...S}},resetChain(e){R.providers[e]=void 0,R.providerIds[e]=void 0}};var D=e.i(77277),L=e.i(218454),M=e.i(194712),W=e.i(811424),F=e.i(639403),B=e.i(564126),x=e.i(288085);e.i(542904);var H=e.i(533659);e.i(404041);var K=e.i(459088),j=e.i(307075),V=e.i(110163);let q={METMASK_CONNECTOR_NAME:"MetaMask",TRUST_CONNECTOR_NAME:"Trust Wallet",SOLFLARE_CONNECTOR_NAME:"Solflare",PHANTOM_CONNECTOR_NAME:"Phantom",COIN98_CONNECTOR_NAME:"Coin98",MAGIC_EDEN_CONNECTOR_NAME:"Magic Eden",BACKPACK_CONNECTOR_NAME:"Backpack",BITGET_CONNECTOR_NAME:"Bitget Wallet",FRONTIER_CONNECTOR_NAME:"Frontier",XVERSE_CONNECTOR_NAME:"Xverse Wallet",LEATHER_CONNECTOR_NAME:"Leather",OKX_CONNECTOR_NAME:"OKX Wallet",EIP155:i.ConstantsUtil.CHAIN.EVM,ADD_CHAIN_METHOD:"wallet_addEthereumChain",EIP6963_ANNOUNCE_EVENT:"eip6963:announceProvider",EIP6963_REQUEST_EVENT:"eip6963:requestProvider",CONNECTOR_RDNS_MAP:{coinbaseWallet:"com.coinbase.wallet",coinbaseWalletSDK:"com.coinbase.wallet"},CONNECTOR_TYPE_EXTERNAL:"EXTERNAL",CONNECTOR_TYPE_WALLET_CONNECT:"WALLET_CONNECT",CONNECTOR_TYPE_INJECTED:"INJECTED",CONNECTOR_TYPE_ANNOUNCED:"ANNOUNCED",CONNECTOR_TYPE_AUTH:"AUTH",CONNECTOR_TYPE_MULTI_CHAIN:"MULTI_CHAIN",CONNECTOR_TYPE_W3M_AUTH:"ID_AUTH",getSDKVersionWarningMessage:(e,t)=>`
     @@@@@@@           @@@@@@@@@@@@@@@@@@      
   @@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@   
  @@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@  
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@  
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@@@   @@@@@@@@@@@ 
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@@   @@@@@@@@@@@@ 
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@@  @@@@@@@@@@@@@
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@   @@@@@@@@@@@@@    
 @@@@@@   @@@@@@  @@@@@@@@@@@   @@@@@@@@@@@@@@    
 @@@@@@   @@@@@@  @@@@@@@@@@@  @@@@@@@@@@@@@@@ 
 @@@@@@@@@@@@@@@  @@@@@@@@@@   @@@@@@@@@@@@@@@ 
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@  
  @@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@  
   @@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@   
      @@@@@            @@@@@@@@@@@@@@@@@@  
      
AppKit SDK version ${e} is outdated. Latest version is ${t}. Please update to the latest version for bug fixes and new features.
            
Changelog: https://github.com/reown-com/appkit/releases
NPM Registry: https://www.npmjs.com/package/@reown/appkit`},$=(i.ConstantsUtil.CONNECTOR_ID.COINBASE,i.ConstantsUtil.CONNECTOR_ID.COINBASE_SDK,i.ConstantsUtil.CONNECTOR_ID.SAFE,i.ConstantsUtil.CONNECTOR_ID.LEDGER,i.ConstantsUtil.CONNECTOR_ID.OKX,q.METMASK_CONNECTOR_NAME,q.TRUST_CONNECTOR_NAME,q.SOLFLARE_CONNECTOR_NAME,q.PHANTOM_CONNECTOR_NAME,q.COIN98_CONNECTOR_NAME,q.MAGIC_EDEN_CONNECTOR_NAME,q.BACKPACK_CONNECTOR_NAME,q.BITGET_CONNECTOR_NAME,q.FRONTIER_CONNECTOR_NAME,q.XVERSE_CONNECTOR_NAME,q.LEATHER_CONNECTOR_NAME,q.OKX_CONNECTOR_NAME,{1:"ba0ba0cd-17c6-4806-ad93-f9d174f17900",42161:"3bff954d-5cb0-47a0-9a23-d20192e74600",43114:"30c46e53-e989-45fb-4549-be3bd4eb3b00",56:"93564157-2e8e-4ce7-81df-b264dbee9b00",250:"06b26297-fe0c-4733-5d6b-ffa5498aac00",10:"ab9c186a-c52f-464b-2906-ca59d760a400",137:"41d04d42-da3b-4453-8506-668cc0727900",5e3:"e86fae9b-b770-4eea-e520-150e12c81100",295:"6a97d510-cac8-4e58-c7ce-e8681b044c00",0xaa36a7:"e909ea0a-f92a-4512-c8fc-748044ea6800",84532:"a18a7ecd-e307-4360-4746-283182228e00",1301:"4eeea7ef-0014-4649-5d1d-07271a80f600",130:"2257980a-3463-48c6-cbac-a42d2a956e00",10143:"0a728e83-bacb-46db-7844-948f05434900",100:"02b53f6a-e3d4-479e-1cb4-21178987d100",9001:"f926ff41-260d-4028-635e-91913fc28e00",324:"b310f07f-4ef7-49f3-7073-2a0a39685800",314:"5a73b3dd-af74-424e-cae0-0de859ee9400",4689:"34e68754-e536-40da-c153-6ef2e7188a00",1088:"3897a66d-40b9-4833-162f-a2c90531c900",1284:"161038da-44ae-4ec7-1208-0ea569454b00",1285:"f1d73bb6-5450-4e18-38f7-fb6484264a00",7777777:"845c60df-d429-4991-e687-91ae45791600",42220:"ab781bbc-ccc6-418d-d32d-789b15da1f00",8453:"7289c336-3981-4081-c5f4-efc26ac64a00",0x4e454152:"3ff73439-a619-4894-9262-4470c773a100",2020:"b8101fc0-9c19-4b6f-ec65-f6dfff106e00",2021:"b8101fc0-9c19-4b6f-ec65-f6dfff106e00",80094:"e329c2c9-59b0-4a02-83e4-212ff3779900",2741:"fc2427d1-5af9-4a9c-8da5-6f94627cd900","5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp":"a1b58899-f671-4276-6a5e-56ca5bd59700","4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z":"a1b58899-f671-4276-6a5e-56ca5bd59700",EtWTRABZaYq6iMfeYKouRu166VU2xqa1:"a1b58899-f671-4276-6a5e-56ca5bd59700","000000000019d6689c085ae165831e93":"0b4838db-0161-4ffe-022d-532bf03dba00","000000000933ea01ad0ee984209779ba":"39354064-d79b-420b-065d-f980c4b78200","00000008819873e925422c1ff0f99f7c":"b3406e4a-bbfc-44fb-e3a6-89673c78b700"}),z={[i.ConstantsUtil.CONNECTOR_ID.COINBASE]:"0c2840c3-5b04-4c44-9661-fbd4b49e1800",[i.ConstantsUtil.CONNECTOR_ID.COINBASE_SDK]:"0c2840c3-5b04-4c44-9661-fbd4b49e1800",[i.ConstantsUtil.CONNECTOR_ID.SAFE]:"461db637-8616-43ce-035a-d89b8a1d5800",[i.ConstantsUtil.CONNECTOR_ID.LEDGER]:"54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",[i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT]:"ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",[i.ConstantsUtil.CONNECTOR_ID.INJECTED]:"07ba87ed-43aa-4adf-4540-9e6a2b9cae00"},Y={[i.ConstantsUtil.CONNECTOR_ID.INJECTED]:"Browser Wallet",[i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT]:"WalletConnect",[i.ConstantsUtil.CONNECTOR_ID.COINBASE]:"Coinbase",[i.ConstantsUtil.CONNECTOR_ID.COINBASE_SDK]:"Coinbase",[i.ConstantsUtil.CONNECTOR_ID.LEDGER]:"Ledger",[i.ConstantsUtil.CONNECTOR_ID.SAFE]:"Safe"};function J(e,t){let n=new URL("https://rpc.walletconnect.org/v1/");return n.searchParams.set("chainId",e),n.searchParams.set("projectId",t),n.toString()}i.ConstantsUtil.CONNECTOR_ID.INJECTED,i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT,i.ConstantsUtil.CONNECTOR_ID.EIP6963,i.ConstantsUtil.CONNECTOR_ID.AUTH,q.CONNECTOR_TYPE_AUTH;let G=["near:mainnet","solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp","eip155:1101","eip155:56","eip155:42161","eip155:7777777","eip155:59144","eip155:324","solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1","eip155:5000","solana:4sgjmw1sunhzsxgspuhpqldx6wiyjntz","eip155:80084","eip155:5003","eip155:100","eip155:8453","eip155:42220","eip155:1313161555","eip155:17000","eip155:1","eip155:300","eip155:1313161554","eip155:1329","eip155:84532","eip155:421614","eip155:11155111","eip155:8217","eip155:43114","solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z","eip155:999999999","eip155:11155420","eip155:80002","eip155:97","eip155:43113","eip155:137","eip155:10","eip155:1301","eip155:80094","eip155:80069","eip155:560048","eip155:31","eip155:2818","eip155:57054","eip155:911867","eip155:534351","eip155:1112","eip155:534352","eip155:1111","eip155:146","eip155:130","eip155:1284","eip155:30","eip155:2810","bip122:000000000019d6689c085ae165831e93","bip122:000000000933ea01ad0ee984209779ba"],X={extendRpcUrlWithProjectId(e,t){let n=!1;try{n="rpc.walletconnect.org"===new URL(e).host}catch(e){n=!1}if(n){let n=new URL(e);return n.searchParams.has("projectId")||n.searchParams.set("projectId",t),n.toString()}return e},isCaipNetwork:e=>"chainNamespace"in e&&"caipNetworkId"in e,getChainNamespace(e){return this.isCaipNetwork(e)?e.chainNamespace:i.ConstantsUtil.CHAIN.EVM},getCaipNetworkId(e){return this.isCaipNetwork(e)?e.caipNetworkId:`${i.ConstantsUtil.CHAIN.EVM}:${e.id}`},getDefaultRpcUrl(e,t,n){let r=e.rpcUrls?.default?.http?.[0];return G.includes(t)?J(t,n):r||""},extendCaipNetwork(e,{customNetworkImageUrls:t,projectId:n,customRpcUrls:r}){let a=this.getChainNamespace(e),o=this.getCaipNetworkId(e),s=e.rpcUrls?.default?.http?.[0],i=this.getDefaultRpcUrl(e,o,n),c=e?.rpcUrls?.chainDefault?.http?.[0]||s,l=r?.[o]?.map(e=>e.url)||[],d=[...l,...i?[i]:[]],C=[...l];return c&&!C.includes(c)&&C.push(c),{...e,chainNamespace:a,caipNetworkId:o,assets:{imageId:$[e.id],imageUrl:t?.[e.id]},rpcUrls:{...e.rpcUrls,default:{http:d},chainDefault:{http:C}}}},extendCaipNetworks:(e,{customNetworkImageUrls:t,projectId:n,customRpcUrls:r})=>e.map(e=>X.extendCaipNetwork(e,{customNetworkImageUrls:t,customRpcUrls:r,projectId:n})),getViemTransport(e,t,n){let r=[];return n?.forEach(e=>{r.push((0,V.http)(e.url,e.config))}),G.includes(e.caipNetworkId)&&r.push((0,V.http)(J(e.caipNetworkId,t),{fetchOptions:{headers:{"Content-Type":"text/plain"}}})),e?.rpcUrls?.default?.http?.forEach(e=>{r.push((0,V.http)(e))}),(0,j.fallback)(r)},extendWagmiTransports(e,t,n){if(G.includes(e.caipNetworkId)){let r=this.getDefaultRpcUrl(e,e.caipNetworkId,t);return(0,j.fallback)([n,(0,V.http)(r)])}return n},getUnsupportedNetwork:e=>({id:e.split(":")[1],caipNetworkId:e,name:i.ConstantsUtil.UNSUPPORTED_NETWORK_NAME,chainNamespace:e.split(":")[0],nativeCurrency:{name:"",decimals:0,symbol:""},rpcUrls:{default:{http:[]}}}),getCaipNetworkFromStorage(e){let n=w.StorageUtil.getActiveCaipNetworkId(),r=t.ChainController.getAllRequestedCaipNetworks(),a=Array.from(t.ChainController.state.chains?.keys()||[]),o=n?.split(":")[0],s=!!o&&a.includes(o),i=r?.find(e=>e.caipNetworkId===n);return s&&!i&&n?this.getUnsupportedNetwork(n):i||e||r?.[0]}};var Z=e.i(376527);new AbortController;let Q={UNAUTHORIZED_DOMAIN_NOT_ALLOWED:{message:"Unauthorized: origin not allowed",alertErrorKey:"ORIGIN_NOT_ALLOWED"},JWT_VALIDATION_ERROR:{message:"JWT validation error: JWT Token is not yet valid",alertErrorKey:"JWT_TOKEN_NOT_VALID"},INVALID_KEY:{message:"Unauthorized: invalid key",alertErrorKey:"INVALID_PROJECT_ID"}},ee={SWITCH_NETWORK_NOT_FOUND:{code:"APKT001",displayMessage:"Network Not Found",debugMessage:"The specified network is not recognized. Please ensure it is included in the `networks` array of your `createAppKit` configuration."},ORIGIN_NOT_ALLOWED:{code:"APKT002",displayMessage:"Invalid App Configuration",debugMessage:()=>`The origin ${(0,Z.isSafe)()?window.origin:"unknown"} is not in your allow list. Please update your allowed domains at https://dashboard.reown.com.`},IFRAME_LOAD_FAILED:{code:"APKT003",displayMessage:"Network Error: Wallet Load Failed",debugMessage:()=>"Failed to load the embedded wallet. This may be due to network issues or server downtime. Please check your network connection and try again shortly. Contact support if the issue persists."},IFRAME_REQUEST_TIMEOUT:{code:"APKT004",displayMessage:"Wallet Request Timeout",debugMessage:()=>"The request to the embedded wallet timed out. Please check your network connection and try again shortly. Contact support if the issue persists."},UNVERIFIED_DOMAIN:{code:"APKT005",displayMessage:"Unverified Domain",debugMessage:()=>"Embedded wallet load failed. Ensure your domain is verified in https://dashboard.reown.com."},JWT_TOKEN_NOT_VALID:{code:"APKT006",displayMessage:"Session Expired",debugMessage:"Your session is invalid or expired. Please check your systemâ€™s date and time settings, then reconnect."},INVALID_PROJECT_ID:{code:"APKT007",displayMessage:"Invalid Project ID",debugMessage:"The specified project ID is invalid. Please visit https://dashboard.reown.com to obtain a valid project ID."},PROJECT_ID_NOT_CONFIGURED:{code:"APKT008",displayMessage:"Project ID Missing",debugMessage:"No project ID is configured. You can create and configure a project ID at https://dashboard.reown.com."},SERVER_ERROR_APP_CONFIGURATION:{code:"APKT009",displayMessage:"Server Error",debugMessage:e=>`Unable to fetch App Configuration. ${e}. Please check your network connection and try again shortly. Contact support if the issue persists.`},RATE_LIMITED_APP_CONFIGURATION:{code:"APKT010",displayMessage:"Rate Limited",debugMessage:"You have been rate limited while retrieving App Configuration. Please wait a few minutes and try again. Contact support if the issue persists."}},et={debugMessage:e=>`[Reown Config Notice] ${e}`},en={code:"APKTW001",displayMessage:"Inactive Namespace Not Connected",debugMessage:(e,t)=>`An error occurred while connecting an inactive namespace ${e}: "${t}"`},er={getCaipTokens(e){if(!e)return;let t={};return Object.entries(e).forEach(([e,n])=>{t[`${q.EIP155}:${e}`]=n}),t},isLowerCaseMatch:(e,t)=>e?.toLowerCase()===t?.toLowerCase(),getActiveNamespaceConnectedToAuth(){let e=t.ChainController.state.activeChain;return i.ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.find(t=>r.ConnectorController.getConnectorId(t)===i.ConstantsUtil.CONNECTOR_ID.AUTH&&t===e)},withRetry({conditionFn:e,intervalMs:t,maxRetries:n}){let r=0;return new Promise(a=>{async function o(){return(r+=1,await e())?a(!0):r>=n?a(!1):(setTimeout(o,t),null)}o()})},userChainIdToChainNamespace(e){if("number"==typeof e)return i.ConstantsUtil.CHAIN.EVM;let[t]=e.split(":");return t},getOtherAuthNamespaces:e=>e?i.ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.filter(t=>t!==e):[],getConnectorStorageInfo(e,t){let n=w.StorageUtil.getConnections()[t]??[];return{hasDisconnected:w.StorageUtil.isConnectorDisconnected(e,t),hasConnected:n.some(t=>er.isLowerCaseMatch(t.connectorId,e))}}};var ea=e.i(278662);let eo={createLogger(e,t="error"){let n=(0,ea.getDefaultLoggerOptions)({level:t}),{logger:r}=(0,ea.generatePlatformLogger)({opts:n});return r.error=(...t)=>{for(let n of t)if(n instanceof Error)return void e(n,...t);e(void 0,...t)},r}},es={extractVersion(e){if(!e||"string"!=typeof e)return null;let t=e.match(/(?:[~^>=<]+\s*)?(?<version>\d+(?:\.\d+){0,2})(?:-[a-zA-Z]+\.\d+)?/u);return t?.groups?.version||null},checkSDKVersion(e){let t=this.extractVersion(e),n=i.ConstantsUtil.IS_DEVELOPMENT;if(!t||!n)return;let r=w.StorageUtil.getLatestAppKitVersion();if(this.isValidVersion(r)&&this.isOlder(t,r))return void console.warn(q.getSDKVersionWarningMessage(t,r));try{fetch("https://registry.npmjs.org/@reown/appkit/latest").then(e=>e.json()).then(e=>{let n=e.version;this.isOlder(t,n)&&(w.StorageUtil.updateLatestAppKitVersion({timestamp:Date.now(),version:n}),console.warn(q.getSDKVersionWarningMessage(t,n)))})}catch(e){}},isValidVersion:e=>"string"==typeof e&&/^\d+\.\d+\.\d+$/u.test(e),isOlder(e,t){let n=this.extractVersion(e),r=this.extractVersion(t);if(!n||!r)return!1;function a(e){let t=e.split(".").map(Number);for(;t.length<3;)t.push(0);return t}let o=a(n),s=a(r);for(let e=0;e<Math.max(o.length,s.length);e+=1){let t=o[e]||0,n=s[e]||0;if(t<n)return!0;if(t>n)break}return!1}},ei={TOKEN_ADDRESSES_BY_SYMBOL:{USDC:{8453:"0x833589fcd6edb6e08f4c7c32d4f71b54bda02913",84532:"0x036CbD53842c5426634e7929541eC2318f3dCF7e"}},getTokenSymbolByAddress(e){if(!e)return;let[t]=Object.entries(ei.TOKEN_ADDRESSES_BY_SYMBOL).find(([t,n])=>Object.values(n).includes(e))??[];return t}};var ec=e.i(103476),el=e.i(675107),ed=e.i(683075);let eC={hexStringToNumber:e=>parseInt(e.startsWith("0x")?e.slice(2):e,16),numberToHexString:e=>`0x${e.toString(16)}`,async getUserInfo(e){let[t,n]=await Promise.all([eC.getAddresses(e),eC.getChainId(e)]);return{chainId:n,addresses:t}},getChainId:async e=>Number(await e.request({method:"eth_chainId"})),async getAddress(e){let[t]=await e.request({method:"eth_accounts"});return t},getAddresses:async e=>await e.request({method:"eth_accounts"}),async addEthereumChain(e,t){let n=t.rpcUrls.chainDefault?.http||[];await e.request({method:"wallet_addEthereumChain",params:[{chainId:eC.numberToHexString(t.id),rpcUrls:[...n],chainName:t.name,nativeCurrency:{name:t.nativeCurrency.name,decimals:t.nativeCurrency.decimals,symbol:t.nativeCurrency.symbol},blockExplorerUrls:[t.blockExplorers?.default.url],iconUrls:[$[t.id]]}]})}},ep=0,eh=1;function eu(e){return{formatters:void 0,fees:void 0,serializers:void 0,...e}}let eN=eu({id:"5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",name:"Solana",network:"solana-mainnet",nativeCurrency:{name:"Solana",symbol:"SOL",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},testnet:!1,chainNamespace:"solana",caipNetworkId:"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",deprecatedCaipNetworkId:"solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ"}),eg=eu({id:"EtWTRABZaYq6iMfeYKouRu166VU2xqa1",name:"Solana Devnet",network:"solana-devnet",nativeCurrency:{name:"Solana",symbol:"SOL",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},testnet:!0,chainNamespace:"solana",caipNetworkId:"solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",deprecatedCaipNetworkId:"solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K"});eu({id:"4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",name:"Solana Testnet",network:"solana-testnet",nativeCurrency:{name:"Solana",symbol:"SOL",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},testnet:!0,chainNamespace:"solana",caipNetworkId:"solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z"}),eu({id:"000000000019d6689c085ae165831e93",caipNetworkId:"bip122:000000000019d6689c085ae165831e93",chainNamespace:"bip122",name:"Bitcoin",nativeCurrency:{name:"Bitcoin",symbol:"BTC",decimals:8},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}}}),eu({id:"000000000933ea01ad0ee984209779ba",caipNetworkId:"bip122:000000000933ea01ad0ee984209779ba",chainNamespace:"bip122",name:"Bitcoin Testnet",nativeCurrency:{name:"Bitcoin",symbol:"BTC",decimals:8},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},testnet:!0}),eu({id:"00000008819873e925422c1ff0f99f7c",caipNetworkId:"bip122:00000008819873e925422c1ff0f99f7c",chainNamespace:"bip122",name:"Bitcoin Signet",nativeCurrency:{name:"Bitcoin",symbol:"BTC",decimals:8},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},testnet:!0});let em={solana:["solana_signMessage","solana_signTransaction","solana_requestAccounts","solana_getAccounts","solana_signAllTransactions","solana_signAndSendTransaction"],eip155:["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode","wallet_getCallsStatus","wallet_showCallsStatus","wallet_sendCalls","wallet_getCapabilities","wallet_grantPermissions","wallet_revokePermissions","wallet_getAssets"],bip122:["sendTransfer","signMessage","signPsbt","getAccountAddresses"]},eE={RPC_ERROR_CODE:{USER_REJECTED:5e3,USER_REJECTED_METHODS:5002},getMethodsByChainNamespace:e=>em[e]||[],createDefaultNamespace(e){return{methods:this.getMethodsByChainNamespace(e),events:["accountsChanged","chainChanged"],chains:[],rpcMap:{}}},applyNamespaceOverrides(e,t){if(!t)return{...e};let n={...e},r=new Set;if(t.methods&&Object.keys(t.methods).forEach(e=>r.add(e)),t.chains&&Object.keys(t.chains).forEach(e=>r.add(e)),t.events&&Object.keys(t.events).forEach(e=>r.add(e)),t.rpcMap&&Object.keys(t.rpcMap).forEach(e=>{let[t]=e.split(":");t&&r.add(t)}),r.forEach(e=>{n[e]||(n[e]=this.createDefaultNamespace(e))}),t.methods&&Object.entries(t.methods).forEach(([e,t])=>{n[e]&&(n[e].methods=t)}),t.chains&&Object.entries(t.chains).forEach(([e,t])=>{n[e]&&(n[e].chains=t)}),t.events&&Object.entries(t.events).forEach(([e,t])=>{n[e]&&(n[e].events=t)}),t.rpcMap){let e=new Set;Object.entries(t.rpcMap).forEach(([t,r])=>{let[a,o]=t.split(":");a&&o&&n[a]&&(n[a].rpcMap||(n[a].rpcMap={}),e.has(a)||(n[a].rpcMap={},e.add(a)),n[a].rpcMap[o]=r)})}return n},createNamespaces(e,t){let n=e.reduce((e,t)=>{let{id:n,chainNamespace:r,rpcUrls:a}=t,o=a.default.http[0];e[r]||(e[r]=this.createDefaultNamespace(r));let s=`${r}:${n}`,i=e[r];switch(i.chains.push(s),s){case eN.caipNetworkId:i.chains.push(eN.deprecatedCaipNetworkId);break;case eg.caipNetworkId:i.chains.push(eg.deprecatedCaipNetworkId)}return i?.rpcMap&&o&&(i.rpcMap[n]=o),e},{});return this.applyNamespaceOverrides(n,t)},resolveReownName:async e=>{let t=await T.resolveName(e),n=Object.values(t?.addresses)||[];return n[0]?.address||!1},getChainsFromNamespaces:(e={})=>Object.values(e).flatMap(e=>Array.from(new Set([...e.chains||[],...e.accounts.map(e=>{let[t,n]=e.split(":");return`${t}:${n}`})]))),isSessionEventData:e=>"object"==typeof e&&null!==e&&"id"in e&&"topic"in e&&"params"in e&&"object"==typeof e.params&&null!==e.params&&"chainId"in e.params&&"event"in e.params&&"object"==typeof e.params.event&&null!==e.params.event,isUserRejectedRequestError(e){try{if("object"==typeof e&&null!==e){let t="number"==typeof e.code,n=t&&e.code===eE.RPC_ERROR_CODE.USER_REJECTED_METHODS,r=t&&e.code===eE.RPC_ERROR_CODE.USER_REJECTED;return n||r}return!1}catch{return!1}},isOriginAllowed(e,t,n){for(let r of[...t,...n])if(r.includes("*")){let t=r.replace(/[.*+?^${}()|[\]\\]/gu,"\\$&");if(RegExp(`^${t.replace(/\\\*/gu,".*")}$`,"u").test(e))return!0}else try{if(new URL(r).origin===e)return!0}catch(t){if(r===e)return!0}return!1},listenWcProvider({universalProvider:e,namespace:t,onConnect:n,onDisconnect:r,onAccountsChanged:a,onChainChanged:o,onDisplayUri:s}){n&&e.on("connect",()=>{n(eE.getWalletConnectAccounts(e,t))}),r&&e.on("disconnect",()=>{r()}),a&&e.on("accountsChanged",n=>{try{let r=e.session?.namespaces?.[t]?.accounts||[],o=e.rpcProviders?.[t]?.getDefaultChain(),s=n.map(e=>{let n=r.find(n=>n.includes(`${t}:${o}:${e}`));if(!n)return;let{chainId:a,chainNamespace:s}=l.ParseUtil.parseCaipAddress(n);return{address:e,chainId:a,chainNamespace:s}}).filter(e=>void 0!==e);s.length>0&&a(s)}catch(e){console.warn("Failed to parse accounts for namespace on accountsChanged event",t,n,e)}}),o&&e.on("chainChanged",e=>{o(e)}),s&&e.on("display_uri",e=>{s(e)})},getWalletConnectAccounts(e,t){let n=new Set,r=e?.session?.namespaces?.[t]?.accounts?.map(e=>l.ParseUtil.parseCaipAddress(e)).filter(({address:e})=>!n.has(e.toLowerCase())&&(n.add(e.toLowerCase()),!0));return r&&r.length>0?r:[]}};class ew{constructor(e){this.namespace=e.namespace}async syncConnections(e){switch(this.namespace){case i.ConstantsUtil.CHAIN.EVM:await this.syncEVMConnections(e);break;case i.ConstantsUtil.CHAIN.SOLANA:await this.syncSolanaConnections(e);break;case i.ConstantsUtil.CHAIN.BITCOIN:await this.syncBitcoinConnections(e);break;default:throw Error(`Unsupported chain namespace: ${this.namespace}`)}}async syncEVMConnections({connectors:e,caipNetworks:t,universalProvider:n,onConnection:r,onListenProvider:a}){await Promise.all(e.filter(e=>{let{hasDisconnected:t,hasConnected:n}=er.getConnectorStorageInfo(e.id,this.namespace);return!t&&n}).map(async e=>{if(e.id===i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT){let a=eE.getWalletConnectAccounts(n,this.namespace),o=t.find(e=>e.chainNamespace===this.namespace&&e.id.toString()===a[0]?.chainId?.toString());a.length>0&&r({connectorId:e.id,accounts:a.map(e=>({address:e.address})),caipNetwork:o})}else{let{accounts:n,chainId:o}=await x.ConnectorUtil.fetchProviderData(e);if(n.length>0&&o){let s=t.find(e=>e.chainNamespace===this.namespace&&e.id.toString()===o.toString());r({connectorId:e.id,accounts:n.map(e=>({address:e})),caipNetwork:s}),e.provider&&e.id!==i.ConstantsUtil.CONNECTOR_ID.AUTH&&e.id!==i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT&&a(e.id,e.provider)}}}))}async syncSolanaConnections({connectors:e,caipNetwork:t,universalProvider:n,onConnection:r,onListenProvider:a}){await Promise.all(e.filter(e=>{let{hasDisconnected:t,hasConnected:n}=er.getConnectorStorageInfo(e.id,this.namespace);return!t&&n}).map(async e=>{if(e.id===i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT){let a=eE.getWalletConnectAccounts(n,this.namespace);a.length>0&&r({connectorId:e.id,accounts:a.map(e=>({address:e.address})),caipNetwork:t})}else{let n=await e.connect({chainId:t?.id});n&&(r({connectorId:e.id,accounts:[{address:n}],caipNetwork:t}),a(e.id,e.provider))}}))}async syncBitcoinConnections({connectors:e,caipNetwork:t,universalProvider:n,onConnection:r,onListenProvider:o}){await Promise.all(e.filter(e=>{let{hasDisconnected:t,hasConnected:n}=er.getConnectorStorageInfo(e.id,this.namespace);return!t&&n}).map(async e=>{if(e.id===i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT){let a=eE.getWalletConnectAccounts(n,this.namespace);a.length>0&&r({connectorId:e.id,accounts:a.map(e=>({address:e.address})),caipNetwork:t});return}let s=await e.connect(),c=await e.getAccountAddresses(),l=c?.map(e=>a.CoreHelperUtil.createAccount(i.ConstantsUtil.CHAIN.BITCOIN,e.address,e.purpose||"payment",e.publicKey,e.path));if(l&&l.length>1&&(l=[{namespace:i.ConstantsUtil.CHAIN.BITCOIN,publicKey:l[ep]?.publicKey??"",path:l[ep]?.path??"",address:l[ep]?.address??"",type:"payment"},{namespace:i.ConstantsUtil.CHAIN.BITCOIN,publicKey:l[eh]?.publicKey??"",path:l[eh]?.path??"",address:l[eh]?.address??"",type:"ordinal"}]),!(e.chains.find(e=>e.id===t?.id)||e.chains[0]))throw Error("The connector does not support any of the requested chains");s&&(o(e.id,e.provider),r({connectorId:e.id,accounts:l.map(e=>({address:e.address,type:e.type,publicKey:e.publicKey,path:e.path})),caipNetwork:t}))}))}getConnection({address:e,connectorId:t,connections:n,connectors:r}){if(t){let a=n.find(e=>er.isLowerCaseMatch(e.connectorId,t));if(!a)return null;let o=r.find(e=>er.isLowerCaseMatch(e.id,a.connectorId)),s=e?a.accounts.find(t=>er.isLowerCaseMatch(t.address,e)):a.accounts[0];return{...a,account:s,connector:o}}let a=n.find(e=>e.accounts.length>0&&r.some(t=>er.isLowerCaseMatch(t.id,e.connectorId)));if(a){let[e]=a.accounts,t=r.find(e=>er.isLowerCaseMatch(e.id,a.connectorId));return{...a,account:e,connector:t}}return null}}let eA=["http://localhost:*","https://localhost:*","http://127.0.0.1:*","https://127.0.0.1:*","https://*.pages.dev","https://*.vercel.app","https://*.ngrok-free.app","https://secure-mobile.walletconnect.com","https://secure-mobile.walletconnect.org"];class ef{constructor({provider:e,namespace:n}){this.id=i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT,this.name=Y[i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT],this.type="WALLET_CONNECT",this.imageId=z[i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT],this.getCaipNetworks=t.ChainController.getCaipNetworks.bind(t.ChainController),this.caipNetworks=this.getCaipNetworks(),this.provider=e,this.chain=n}get chains(){return this.getCaipNetworks()}async connectWalletConnect(){if(!await this.authenticate()){let e=this.getCaipNetworks(),t=o.OptionsController.state.universalProviderConfigOverride,n=eE.createNamespaces(e,t);await this.provider.connect({optionalNamespaces:n})}return{clientId:await this.provider.client.core.crypto.getClientId(),session:this.provider.session}}async disconnect(){await this.provider.disconnect()}async authenticate(){let e=this.chains.map(e=>e.caipNetworkId);return L.SIWXUtil.universalProviderAuthenticate({universalProvider:this.provider,chains:e,methods:ev})}}let ev=["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode","wallet_getCallsStatus","wallet_sendCalls","wallet_getCapabilities","wallet_grantPermissions","wallet_revokePermissions","wallet_getAssets"],eT=[i.ConstantsUtil.CONNECTOR_ID.AUTH,i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT];class ey{constructor(e){this.availableConnectors=[],this.availableConnections=[],this.providerHandlers={},this.eventListeners=new Map,this.getCaipNetworks=e=>t.ChainController.getCaipNetworks(e),this.getConnectorId=e=>r.ConnectorController.getConnectorId(e),e&&this.construct(e),e?.namespace&&(this.connectionManager=new ew({namespace:e.namespace}))}construct(e){this.projectId=e.projectId,this.namespace=e.namespace,this.adapterType=e.adapterType}get connectors(){return this.availableConnectors}get connections(){return this.availableConnections}get networks(){return this.getCaipNetworks(this.namespace)}onAuthConnected({accounts:e,chainId:t}){let n=this.getCaipNetworks().filter(e=>e.chainNamespace===this.namespace).find(e=>e.id.toString()===t?.toString());e&&n&&this.addConnection({connectorId:i.ConstantsUtil.CONNECTOR_ID.AUTH,accounts:e,caipNetwork:n})}setAuthProvider(e){e.onConnect(this.onAuthConnected.bind(this)),e.onSocialConnected(this.onAuthConnected.bind(this)),this.addConnector({id:i.ConstantsUtil.CONNECTOR_ID.AUTH,type:"AUTH",name:i.ConstantsUtil.CONNECTOR_NAMES.AUTH,provider:e,imageId:z[i.ConstantsUtil.CONNECTOR_ID.AUTH],chain:this.namespace,chains:[]})}addConnector(...e){let t=new Set;this.availableConnectors=[...e,...this.availableConnectors].filter(e=>!t.has(e.id)&&(t.add(e.id),!0)),this.emit("connectors",this.availableConnectors)}addConnection(...e){let t=new Set;this.availableConnections=[...e,...this.availableConnections].filter(e=>!t.has(e.connectorId.toLowerCase())&&(t.add(e.connectorId.toLowerCase()),!0)),this.emit("connections",this.availableConnections)}deleteConnection(e){this.availableConnections=this.availableConnections.filter(t=>!er.isLowerCaseMatch(t.connectorId,e)),this.emit("connections",this.availableConnections)}clearConnections(e=!1){this.availableConnections=[],e&&this.emit("connections",this.availableConnections)}setStatus(e,n){t.ChainController.setAccountProp("status",e,n)}on(e,t){this.eventListeners.has(e)||this.eventListeners.set(e,new Set),this.eventListeners.get(e)?.add(t)}off(e,t){let n=this.eventListeners.get(e);n&&n.delete(t)}removeAllEventListeners(){this.eventListeners.forEach(e=>{e.clear()})}emit(e,t){let n=this.eventListeners.get(e);n&&n.forEach(e=>e(t))}async connectWalletConnect(e){try{let e=this.getWalletConnectConnector();return{clientId:(await e.connectWalletConnect()).clientId}}catch(e){if(eE.isUserRejectedRequestError(e))throw new ed.UserRejectedRequestError(e);throw e}}async switchNetwork(e){let{caipNetwork:t,providerType:n}=e;if(!e.provider)return;let r="provider"in e.provider?e.provider.provider:e.provider;if("WALLET_CONNECT"===n)return void r.setDefaultChain(t.caipNetworkId);if(r&&"AUTH"===n){let e=(0,B.getPreferredAccountType)(t.chainNamespace);await r.switchNetwork({chainId:t.caipNetworkId});let n=await r.getUser({chainId:t.caipNetworkId,preferredAccountType:e});this.emit("switchNetwork",n)}}getWalletConnectConnector(){let e=this.connectors.find(e=>e instanceof ef);if(!e)throw Error("WalletConnectConnector not found");return e}onConnect(e,t){if(e.length>0){let{address:n,chainId:r}=a.CoreHelperUtil.getAccount(e[0]),o=this.getCaipNetworks().filter(e=>e.chainNamespace===this.namespace).find(e=>e.id.toString()===r?.toString()),s=this.connectors.find(e=>e.id===t);n&&(this.emit("accountChanged",{address:n,chainId:r,connector:s}),this.addConnection({connectorId:t,accounts:e.map(e=>{let{address:t}=a.CoreHelperUtil.getAccount(e);return{address:t}}),caipNetwork:o}))}}onAccountsChanged(e,t,n=!0){if(e.length>0){let{address:n}=a.CoreHelperUtil.getAccount(e[0]),r=this.connectionManager?.getConnection({connectorId:t,connections:this.connections,connectors:this.connectors});n&&er.isLowerCaseMatch(this.getConnectorId(i.ConstantsUtil.CHAIN.EVM),t)&&this.emit("accountChanged",{address:n,chainId:r?.caipNetwork?.id,connector:r?.connector}),this.addConnection({connectorId:t,accounts:e.map(e=>{let{address:t}=a.CoreHelperUtil.getAccount(e);return{address:t}}),caipNetwork:r?.caipNetwork})}else n&&this.onDisconnect(t)}onDisconnect(e){this.removeProviderListeners(e),this.deleteConnection(e),er.isLowerCaseMatch(this.getConnectorId(i.ConstantsUtil.CHAIN.EVM),e)&&this.emitFirstAvailableConnection(),0===this.connections.length&&this.emit("disconnect")}onChainChanged(e,t){let n="string"==typeof e&&e.startsWith("0x")?eC.hexStringToNumber(e).toString():e.toString(),r=this.connectionManager?.getConnection({connectorId:t,connections:this.connections,connectors:this.connectors}),a=this.getCaipNetworks().filter(e=>e.chainNamespace===this.namespace).find(e=>e.id.toString()===n);r&&this.addConnection({connectorId:t,accounts:r.accounts,caipNetwork:a}),er.isLowerCaseMatch(this.getConnectorId(i.ConstantsUtil.CHAIN.EVM),t)&&this.emit("switchNetwork",{chainId:n})}listenProviderEvents(e,t){if(eT.includes(e))return;let n=t=>this.onAccountsChanged(t,e),r=t=>this.onChainChanged(t,e),a=()=>this.onDisconnect(e);this.providerHandlers[e]||(t.on("disconnect",a),t.on("accountsChanged",n),t.on("chainChanged",r),this.providerHandlers[e]={provider:t,disconnect:a,accountsChanged:n,chainChanged:r})}removeProviderListeners(e){if(this.providerHandlers[e]){let{provider:t,disconnect:n,accountsChanged:r,chainChanged:a}=this.providerHandlers[e];t.removeListener("disconnect",n),t.removeListener("accountsChanged",r),t.removeListener("chainChanged",a),this.providerHandlers[e]=null}}emitFirstAvailableConnection(){let e=this.connectionManager?.getConnection({connections:this.connections,connectors:this.connectors});if(e){let[t]=e.accounts;this.emit("accountChanged",{address:t?.address,chainId:e.caipNetwork?.id,connector:e.connector})}}}class eO extends ey{async setUniversalProvider(e){if(!this.namespace)throw Error("UniversalAdapter:setUniversalProvider - namespace is required");return this.addConnector(new ef({provider:e,caipNetworks:this.getCaipNetworks(),namespace:this.namespace})),Promise.resolve()}async connect(e){return Promise.resolve({id:"WALLET_CONNECT",type:"WALLET_CONNECT",chainId:Number(e.chainId),provider:this.provider,address:""})}async disconnect(){try{let e=this.getWalletConnectConnector();await e.disconnect(),this.emit("disconnect")}catch(e){console.warn("UniversalAdapter:disconnect - error",e)}return{connections:[]}}syncConnections(){return Promise.resolve()}async getAccounts({namespace:e}){let t=this.provider;return Promise.resolve({accounts:(t?.session?.namespaces?.[e]?.accounts?.map(e=>{let[,,t]=e.split(":");return t}).filter((e,t,n)=>n.indexOf(e)===t)||[]).map(t=>a.CoreHelperUtil.createAccount(e,t,"bip122"===e?"payment":"eoa"))})}async syncConnectors(){return Promise.resolve()}async getBalance(e){if(!(e.caipNetwork&&N.ConstantsUtil.BALANCE_SUPPORTED_CHAINS.includes(e.caipNetwork?.chainNamespace))||e.caipNetwork?.testnet)return{balance:"0.00",symbol:e.caipNetwork?.nativeCurrency.symbol||""};let n=t.ChainController.getAccountData();if(n?.balanceLoading&&e.chainId===t.ChainController.state.activeCaipNetwork?.id)return{balance:n?.balance||"0.00",symbol:n?.balanceSymbol||""};let r=(await t.ChainController.fetchTokenBalance()).find(t=>t.chainId===`${e.caipNetwork?.chainNamespace}:${e.chainId}`&&t.symbol===e.caipNetwork?.nativeCurrency.symbol);return{balance:r?.quantity.numeric||"0.00",symbol:r?.symbol||e.caipNetwork?.nativeCurrency.symbol||""}}async signMessage(e){let{provider:n,message:r,address:a}=e;if(!n)throw Error("UniversalAdapter:signMessage - provider is undefined");return{signature:t.ChainController.state.activeCaipNetwork?.chainNamespace===i.ConstantsUtil.CHAIN.SOLANA?(await n.request({method:"solana_signMessage",params:{message:ec.default.encode(new TextEncoder().encode(r)),pubkey:a}},t.ChainController.state.activeCaipNetwork?.caipNetworkId)).signature:await n.request({method:"personal_sign",params:[r,a]},t.ChainController.state.activeCaipNetwork?.caipNetworkId)}}async estimateGas(){return Promise.resolve({gas:BigInt(0)})}async sendTransaction(){return Promise.resolve({hash:""})}walletGetAssets(e){return Promise.resolve({})}async writeContract(){return Promise.resolve({hash:""})}emitFirstAvailableConnection(){}parseUnits(){return 0n}formatUnits(){return"0"}async getCapabilities(){return Promise.resolve({})}async grantPermissions(){return Promise.resolve({})}async revokePermissions(){return Promise.resolve("0x")}async syncConnection(){return Promise.resolve({id:"WALLET_CONNECT",type:"WALLET_CONNECT",chainId:1,provider:this.provider,address:""})}async switchNetwork(e){let{caipNetwork:t}=e,n=this.getWalletConnectConnector();if(t.chainNamespace===i.ConstantsUtil.CHAIN.EVM)try{await n.provider?.request({method:"wallet_switchEthereumChain",params:[{chainId:(0,el.toHex)(t.id)}]})}catch(e){if(4902===e.code||32603===e.code||5e3===e.code||e?.data?.originalError?.code===4902)try{await n.provider?.request({method:"wallet_addEthereumChain",params:[{chainId:(0,el.toHex)(t.id),rpcUrls:[t?.rpcUrls.chainDefault?.http],chainName:t.name,nativeCurrency:t.nativeCurrency,blockExplorerUrls:[t.blockExplorers?.default.url]}]})}catch(e){throw Error("Chain is not supported")}}n.provider.setDefaultChain(t.caipNetworkId)}getWalletConnectProvider(){let e=this.connectors.find(e=>"WALLET_CONNECT"===e.type);return e?.provider}}let eb=["email","socials","swaps","onramp","activity","reownBranding","multiWallet","emailCapture","payWithExchange","payments","reownAuthentication"],eI={email:{apiFeatureName:"social_login",localFeatureName:"email",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:e=>{if(!e?.config)return!1;let t=e.config;return!!e.isEnabled&&t.includes("email")},processFallback:e=>void 0===e?N.ConstantsUtil.DEFAULT_REMOTE_FEATURES.email:!!e},socials:{apiFeatureName:"social_login",localFeatureName:"socials",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:e=>{if(!e?.config)return!1;let t=e.config;return!!e.isEnabled&&t.length>0&&t.filter(e=>"email"!==e)},processFallback:e=>void 0===e?N.ConstantsUtil.DEFAULT_REMOTE_FEATURES.socials:"boolean"==typeof e?!!e&&N.ConstantsUtil.DEFAULT_REMOTE_FEATURES.socials:e},swaps:{apiFeatureName:"swap",localFeatureName:"swaps",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:e=>{if(!e?.config)return!1;let t=e.config;return!!e.isEnabled&&t.length>0&&t},processFallback:e=>void 0===e?N.ConstantsUtil.DEFAULT_REMOTE_FEATURES.swaps:"boolean"==typeof e?!!e&&N.ConstantsUtil.DEFAULT_REMOTE_FEATURES.swaps:e},onramp:{apiFeatureName:"onramp",localFeatureName:"onramp",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:e=>{if(!e?.config)return!1;let t=e.config;return!!e.isEnabled&&t.length>0&&t},processFallback:e=>void 0===e?N.ConstantsUtil.DEFAULT_REMOTE_FEATURES.onramp:"boolean"==typeof e?!!e&&N.ConstantsUtil.DEFAULT_REMOTE_FEATURES.onramp:e},activity:{apiFeatureName:"activity",localFeatureName:"history",returnType:!1,isLegacy:!0,isAvailableOnBasic:!1,processApi:e=>!!e.isEnabled,processFallback:e=>void 0===e?N.ConstantsUtil.DEFAULT_REMOTE_FEATURES.activity:!!e},reownBranding:{apiFeatureName:"reown_branding",localFeatureName:"reownBranding",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:e=>!!e.isEnabled,processFallback:e=>void 0===e?N.ConstantsUtil.DEFAULT_REMOTE_FEATURES.reownBranding:!!e},emailCapture:{apiFeatureName:"email_capture",localFeatureName:"emailCapture",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:e=>e.isEnabled&&(e.config??[]),processFallback:e=>!1},multiWallet:{apiFeatureName:"multi_wallet",localFeatureName:"multiWallet",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:e=>!!e.isEnabled,processFallback:()=>N.ConstantsUtil.DEFAULT_REMOTE_FEATURES.multiWallet},payWithExchange:{apiFeatureName:"fund_from_exchange",localFeatureName:"payWithExchange",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:e=>!!e.isEnabled,processFallback:()=>N.ConstantsUtil.DEFAULT_REMOTE_FEATURES.payWithExchange},payments:{apiFeatureName:"payments",localFeatureName:"payments",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:e=>!!e.isEnabled,processFallback:()=>N.ConstantsUtil.DEFAULT_REMOTE_FEATURES.payments},reownAuthentication:{apiFeatureName:"reown_authentication",localFeatureName:"reownAuthentication",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:e=>!!e.isEnabled,processFallback:e=>void 0===e?N.ConstantsUtil.DEFAULT_REMOTE_FEATURES.reownAuthentication:!!e}},e_={localSettingsOverridden:new Set,getApiConfig:(e,t)=>t?.find(t=>t.id===e),addWarning(e,t){if(void 0!==e){let e=eI[t],n=e.isLegacy?`"features.${e.localFeatureName}" (now "${t}")`:`"features.${t}"`;this.localSettingsOverridden.add(n)}},processFeature(e,t,n,r,a){let o=eI[e],s=t[o.localFeatureName];if(a&&!o.isAvailableOnBasic)return!1;if(r){let t=this.getApiConfig(o.apiFeatureName,n);return t?.config===null?this.processFallbackFeature(e,s):!!t?.config&&(void 0!==s&&this.addWarning(s,e),this.processApiFeature(e,t))}return this.processFallbackFeature(e,s)},processApiFeature:(e,t)=>eI[e].processApi(t),processFallbackFeature:(e,t)=>eI[e].processFallback(t),async fetchRemoteFeatures(e){let t=e.basic??!1,n=e.features||{};this.localSettingsOverridden.clear();let r=null,a=!1;try{a=null!=(r=await C.ApiController.fetchProjectConfig())}catch(e){console.warn("[Reown Config] Failed to fetch remote project configuration. Using local/default values.",e)}let o=a&&!t?N.ConstantsUtil.DEFAULT_REMOTE_FEATURES:N.ConstantsUtil.DEFAULT_REMOTE_FEATURES_DISABLED;try{for(let e of eb){let s=this.processFeature(e,n,r,a,t);Object.assign(o,{[e]:s})}}catch(e){return console.warn("[Reown Config] Failed to process the configuration from Cloud. Using default values.",e),N.ConstantsUtil.DEFAULT_REMOTE_FEATURES}if(a&&this.localSettingsOverridden.size>0){let e=`Your local configuration for ${Array.from(this.localSettingsOverridden).join(", ")} was ignored because a remote configuration was successfully fetched. Please manage these features via your project dashboard on dashboard.reown.com.`;d.AlertController.open({debugMessage:et.debugMessage(e)},"warning")}return o}};class eU{constructor(e){this.chainNamespaces=[],this.features={},this.remoteFeatures={},this.reportedAlertErrors={},this.getCaipNetwork=(e,n)=>{if(e){let r=t.ChainController.getCaipNetworks(e)?.find(e=>e.id===n);if(r)return r;let a=t.ChainController.getNetworkData(e)?.caipNetwork;if(a)return a;let o=t.ChainController.getRequestedCaipNetworks(e);return o.filter(t=>t.chainNamespace===e)?.[0]}return t.ChainController.state.activeCaipNetwork||this.defaultCaipNetwork},this.getCaipNetworkId=()=>{let e=this.getCaipNetwork();if(e)return e.id},this.getCaipNetworks=e=>t.ChainController.getCaipNetworks(e),this.getActiveChainNamespace=()=>t.ChainController.state.activeChain,this.setRequestedCaipNetworks=(e,n)=>{t.ChainController.setRequestedCaipNetworks(e,n)},this.getApprovedCaipNetworkIds=()=>t.ChainController.getAllApprovedCaipNetworkIds(),this.getCaipAddress=e=>t.ChainController.state.activeChain!==e&&e?t.ChainController.state.chains.get(e)?.accountState?.caipAddress:t.ChainController.state.activeCaipAddress,this.setClientId=e=>{h.BlockchainApiController.setClientId(e)},this.getProvider=e=>P.getProvider(e),this.getProviderType=e=>P.getProviderId(e),this.getPreferredAccountType=e=>(0,B.getPreferredAccountType)(e),this.setCaipAddress=(e,n,r=!1)=>{t.ChainController.setAccountProp("caipAddress",e,n,r),t.ChainController.setAccountProp("address",a.CoreHelperUtil.getPlainAddress(e),n,r)},this.setBalance=(e,n,r)=>{t.ChainController.setAccountProp("balance",e,r),t.ChainController.setAccountProp("balanceSymbol",n,r)},this.setProfileName=(e,n)=>{t.ChainController.setAccountProp("profileName",e,n)},this.setProfileImage=(e,n)=>{t.ChainController.setAccountProp("profileImage",e,n)},this.setUser=(e,n)=>{t.ChainController.setAccountProp("user",e,n)},this.resetAccount=e=>{t.ChainController.resetAccount(e)},this.setCaipNetwork=e=>{t.ChainController.setActiveCaipNetwork(e)},this.setCaipNetworkOfNamespace=(e,n)=>{t.ChainController.setChainNetworkData(n,{caipNetwork:e})},this.setStatus=(e,n)=>{t.ChainController.setAccountProp("status",e,n),r.ConnectorController.isConnected()?w.StorageUtil.setConnectionStatus("connected"):w.StorageUtil.setConnectionStatus("disconnected")},this.getAddressByChainNamespace=e=>t.ChainController.getAccountData(e)?.address,this.setConnectors=e=>{let t=[...r.ConnectorController.state.allConnectors,...e];r.ConnectorController.setConnectors(t)},this.setConnections=(e,t)=>{w.StorageUtil.setConnections(e,t),n.ConnectionController.setConnections(e,t)},this.fetchIdentity=e=>h.BlockchainApiController.fetchIdentity(e),this.getReownName=e=>T.getNamesForAddress(e),this.getConnectors=()=>r.ConnectorController.getConnectors(),this.getConnectorImage=e=>p.AssetUtil.getConnectorImage(e),this.getConnections=e=>this.remoteFeatures.multiWallet?u.ConnectionControllerUtil.getConnectionsData(e).connections:(d.AlertController.open(i.ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,"info"),[]),this.getRecentConnections=e=>this.remoteFeatures.multiWallet?u.ConnectionControllerUtil.getConnectionsData(e).recentConnections:(d.AlertController.open(i.ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,"info"),[]),this.switchConnection=async e=>{this.remoteFeatures.multiWallet?await n.ConnectionController.switchConnection(e):d.AlertController.open(i.ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,"info")},this.deleteConnection=e=>{this.remoteFeatures.multiWallet?(w.StorageUtil.deleteAddressFromConnection(e),n.ConnectionController.syncStorageConnections()):d.AlertController.open(i.ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,"info")},this.setConnectedWalletInfo=(e,n)=>{let r=P.getProviderId(n),a=e?{...e,type:r}:void 0;t.ChainController.setAccountProp("connectedWalletInfo",a,n)},this.getIsConnectedState=()=>!!t.ChainController.state.activeCaipAddress,this.addAddressLabel=(e,n,r)=>{let a=t.ChainController.getAccountData(r)?.addressLabels||{};t.ChainController.setAccountProp("addressLabels",{...a,[e]:n},r)},this.removeAddressLabel=(e,n)=>{let r=t.ChainController.getAccountData(n)?.addressLabels||{};t.ChainController.setAccountProp("addressLabels",{...r,[e]:void 0},n)},this.getAddress=e=>{let n=e||t.ChainController.state.activeChain;return t.ChainController.getAccountData(n)?.address},this.setApprovedCaipNetworksData=e=>t.ChainController.setApprovedCaipNetworksData(e),this.resetNetwork=e=>{t.ChainController.resetNetwork(e)},this.addConnector=e=>{r.ConnectorController.addConnector(e)},this.resetWcConnection=()=>{n.ConnectionController.resetWcConnection()},this.setAddressExplorerUrl=(e,n)=>{t.ChainController.setAccountProp("addressExplorerUrl",e,n)},this.setSmartAccountDeployed=(e,n)=>{t.ChainController.setAccountProp("smartAccountDeployed",e,n)},this.setPreferredAccountType=(e,n)=>{t.ChainController.setAccountProp("preferredAccountType",e,n)},this.setEIP6963Enabled=e=>{o.OptionsController.setEIP6963Enabled(e)},this.handleUnsafeRPCRequest=()=>{this.isOpen()?this.isTransactionStackEmpty()||this.redirect("ApproveTransaction"):this.open({view:"ApproveTransaction"})},this.options=e,this.version=e.sdkVersion,this.caipNetworks=this.extendCaipNetworks(e),this.chainNamespaces=this.getChainNamespacesSet(e.adapters,this.caipNetworks),this.defaultCaipNetwork=this.extendDefaultCaipNetwork(e),this.chainAdapters=this.createAdapters(e.adapters),this.readyPromise=this.initialize(e),es.checkSDKVersion(e.sdkVersion)}getChainNamespacesSet(e,t){let n=e?.map(e=>e.namespace).filter(e=>!!e);return n?.length?[...new Set(n)]:[...new Set(t?.map(e=>e.chainNamespace))]}async initialize(t){if(this.initializeProjectSettings(t),this.initControllers(t),await this.initChainAdapters(),this.sendInitializeEvent(t),o.OptionsController.state.enableReconnect?(await this.syncExistingConnection(),await this.syncAdapterConnections()):await this.unSyncExistingConnection(),this.remoteFeatures=await e_.fetchRemoteFeatures(t),o.OptionsController.setRemoteFeatures(this.remoteFeatures),this.remoteFeatures.onramp&&k.setOnrampProviders(this.remoteFeatures.onramp),(o.OptionsController.state.remoteFeatures?.email||Array.isArray(o.OptionsController.state.remoteFeatures?.socials)&&o.OptionsController.state.remoteFeatures?.socials.length>0)&&await this.checkAllowedOrigins(),o.OptionsController.state.features?.reownAuthentication||o.OptionsController.state.remoteFeatures?.reownAuthentication){let{ReownAuthentication:t}=await e.A(731507),n=o.OptionsController.state.siwx;n instanceof t||(n&&console.warn("ReownAuthentication option is enabled, SIWX configuration will be overridden."),o.OptionsController.setSIWX(new t))}}async openSend(e){let n=e.namespace||t.ChainController.state.activeChain,r=this.getCaipAddress(n),a=this.getCaipNetwork(n)?.id;if(!r)throw Error("openSend: caipAddress not found");if(a?.toString()!==e.chainId.toString()){let r=t.ChainController.getCaipNetworkById(e.chainId,n);if(!r)throw Error(`openSend: caipNetwork with chainId ${e.chainId} not found`);await this.switchNetwork(r,{throwOnFailure:!0})}try{let t=ei.getTokenSymbolByAddress(e.assetAddress);t&&await C.ApiController.fetchTokenImages([t])}catch{}return await O.ModalController.open({view:"WalletSend",data:{send:e}}),new Promise((e,t)=>{let n=M.SendController.subscribeKey("hash",t=>{t&&(a(),e({hash:t}))}),r=O.ModalController.subscribe(e=>{e.open||(a(),t(Error("Modal closed")))}),a=this.createCleanupHandler([n,r])})}toModalOptions(){return{isSwap:function(e){return e?.view==="Swap"},isSend:function(e){return e?.view==="WalletSend"}}}async checkAllowedOrigins(){try{let e=await C.ApiController.fetchAllowedOrigins();if(!a.CoreHelperUtil.isClient())return;let t=window.location.origin;eE.isOriginAllowed(t,e,eA)||d.AlertController.open(ee.ORIGIN_NOT_ALLOWED,"error")}catch(e){if(!(e instanceof Error))return;switch(e.message){case"RATE_LIMITED":d.AlertController.open(ee.RATE_LIMITED_APP_CONFIGURATION,"error");break;case"SERVER_ERROR":{let t=e.cause instanceof Error?e.cause:e;d.AlertController.open({displayMessage:ee.SERVER_ERROR_APP_CONFIGURATION.displayMessage,debugMessage:ee.SERVER_ERROR_APP_CONFIGURATION.debugMessage(t.message)},"error")}}}}createCleanupHandler(e){return()=>{e.forEach(e=>{try{e()}catch{}})}}sendInitializeEvent(e){let{...t}=e;delete t.adapters,delete t.universalProvider,y.EventsController.sendEvent({type:"track",event:"INITIALIZE",properties:{...t,networks:e.networks.map(e=>e.id),siweConfig:{options:e.siweConfig?.options||{}}}})}initControllers(e){this.initializeOptionsController(e),this.initializeChainController(e),this.initializeThemeController(e),this.initializeConnectionController(e),this.initializeConnectorController()}initializeThemeController(e){e.themeMode&&F.ThemeController.setThemeMode(e.themeMode),e.themeVariables&&F.ThemeController.setThemeVariables(e.themeVariables)}initializeChainController(e){if(!this.connectionControllerClient||!this.networkControllerClient)throw Error("ConnectionControllerClient and NetworkControllerClient must be set");t.ChainController.initialize(e.adapters??[],this.caipNetworks,{connectionControllerClient:this.connectionControllerClient,networkControllerClient:this.networkControllerClient});let n=this.getDefaultNetwork();n&&t.ChainController.setActiveCaipNetwork(n)}initializeConnectionController(e){n.ConnectionController.initialize(e.adapters??[]),n.ConnectionController.setWcBasic(e.basic??!1)}initializeConnectorController(){r.ConnectorController.initialize(this.chainNamespaces)}initializeProjectSettings(e){o.OptionsController.setProjectId(e.projectId),o.OptionsController.setSdkVersion(e.sdkVersion)}initializeOptionsController(e){o.OptionsController.setDebug(!1!==e.debug),o.OptionsController.setEnableWalletGuide(!1!==e.enableWalletGuide),o.OptionsController.setEnableWallets(!1!==e.enableWallets),o.OptionsController.setEIP6963Enabled(!1!==e.enableEIP6963),o.OptionsController.setEnableNetworkSwitch(!1!==e.enableNetworkSwitch),o.OptionsController.setEnableReconnect(!1!==e.enableReconnect),o.OptionsController.setEnableMobileFullScreen(!0===e.enableMobileFullScreen),o.OptionsController.setEnableAuthLogger(!1!==e.enableAuthLogger),o.OptionsController.setCustomRpcUrls(e.customRpcUrls),o.OptionsController.setEnableEmbedded(e.enableEmbedded),o.OptionsController.setAllWallets(e.allWallets),o.OptionsController.setIncludeWalletIds(e.includeWalletIds),o.OptionsController.setExcludeWalletIds(e.excludeWalletIds),o.OptionsController.setFeaturedWalletIds(e.featuredWalletIds),o.OptionsController.setTokens(e.tokens),o.OptionsController.setTermsConditionsUrl(e.termsConditionsUrl),o.OptionsController.setPrivacyPolicyUrl(e.privacyPolicyUrl),o.OptionsController.setCustomWallets(e.customWallets),o.OptionsController.setFeatures(e.features),o.OptionsController.setAllowUnsupportedChain(e.allowUnsupportedChain),o.OptionsController.setUniversalProviderConfigOverride(e.universalProviderConfigOverride),o.OptionsController.setPreferUniversalLinks(e.experimental_preferUniversalLinks),o.OptionsController.setDefaultAccountTypes(e.defaultAccountTypes);let t=this.getDefaultMetaData();if(!e.metadata&&t&&(e.metadata=t),o.OptionsController.setMetadata(e.metadata),o.OptionsController.setDisableAppend(e.disableAppend),o.OptionsController.setEnableEmbedded(e.enableEmbedded),o.OptionsController.setSIWX(e.siwx),this.features=o.OptionsController.state.features??{},!e.projectId)return void d.AlertController.open(ee.PROJECT_ID_NOT_CONFIGURED,"error");if(e.adapters?.find(e=>e.namespace===i.ConstantsUtil.CHAIN.EVM)&&e.siweConfig){if(e.siwx)throw Error("Cannot set both `siweConfig` and `siwx` options");o.OptionsController.setSIWX(e.siweConfig.mapToSIWX())}}getDefaultMetaData(){return a.CoreHelperUtil.isClient()?{name:document.getElementsByTagName("title")?.[0]?.textContent||"",description:document.querySelector('meta[property="og:description"]')?.content||"",url:window.location.origin,icons:[document.querySelector('link[rel~="icon"]')?.href||""]}:null}setUnsupportedNetwork(e){let n=this.getActiveChainNamespace();if(n){let r=X.getUnsupportedNetwork(`${n}:${e}`);t.ChainController.setActiveCaipNetwork(r)}}getDefaultNetwork(){return X.getCaipNetworkFromStorage(this.defaultCaipNetwork)}extendCaipNetwork(e,t){return X.extendCaipNetwork(e,{customNetworkImageUrls:t.chainImages,projectId:t.projectId})}extendCaipNetworks(e){return X.extendCaipNetworks(e.networks,{customNetworkImageUrls:e.chainImages,customRpcUrls:e.customRpcUrls,projectId:e.projectId})}extendDefaultCaipNetwork(e){let t=e.networks.find(t=>t.id===e.defaultNetwork?.id);return t?X.extendCaipNetwork(t,{customNetworkImageUrls:e.chainImages,customRpcUrls:e.customRpcUrls,projectId:e.projectId}):void 0}async disconnectConnector(e,n){try{this.setLoading(!0,e);let r={connections:[]},a=this.getAdapter(e);return(t.ChainController.state.chains.get(e)?.accountState?.caipAddress||!o.OptionsController.state.enableReconnect)&&a?.disconnect&&(r=await a.disconnect({id:n})),this.setLoading(!1,e),r}catch(t){throw this.setLoading(!1,e),Error(`Failed to disconnect chains: ${t.message}`)}}createClients(){this.connectionControllerClient={connectWalletConnect:async()=>{let e=t.ChainController.state.activeChain,r=this.getAdapter(e),a=this.getCaipNetwork(e)?.id,o=n.ConnectionController.getConnections(e),s=this.remoteFeatures.multiWallet,i=o.length>0;if(!r)throw Error("Adapter not found");let c=await r.connectWalletConnect(a);i&&s||this.close(),this.setClientId(c?.clientId||null),w.StorageUtil.setConnectedNamespaces([...t.ChainController.state.chains.keys()]),await this.syncWalletConnectAccount(),await L.SIWXUtil.initializeIfEnabled()},connectExternal:async e=>{let t=await this.onConnectExternal(e);return await this.connectInactiveNamespaces(e,t),t?{address:t.address}:void 0},reconnectExternal:async({id:e,info:n,type:r,provider:a})=>{let o=t.ChainController.state.activeChain,s=this.getAdapter(o);if(!o)throw Error("reconnectExternal: namespace not found");if(!s)throw Error("reconnectExternal: adapter not found");s?.reconnect&&(await s?.reconnect({id:e,info:n,type:r,provider:a,chainId:this.getCaipNetwork()?.id}),w.StorageUtil.addConnectedNamespace(o),this.syncConnectedWalletInfo(o))},disconnectConnector:async e=>{await this.disconnectConnector(e.namespace,e.id)},disconnect:async e=>{let{id:a,chainNamespace:o,initialDisconnect:s}=e||{},c=o||t.ChainController.state.activeChain,l=r.ConnectorController.getConnectorId(c),d=a===i.ConstantsUtil.CONNECTOR_ID.AUTH||l===i.ConstantsUtil.CONNECTOR_ID.AUTH,C=a===i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT||l===i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;try{let e=Array.from(t.ChainController.state.chains.keys()),i=o?[o]:e;(C||d)&&(i=e);let c=i.map(async e=>{let t=r.ConnectorController.getConnectorId(e),n=await this.disconnectConnector(e,a||t);n&&(d&&w.StorageUtil.deleteConnectedSocialProvider(),n.connections.forEach(t=>{w.StorageUtil.addDisconnectedConnectorId(t.connectorId,e)})),s&&this.onDisconnectNamespace({chainNamespace:e,closeModal:!1})}),l=await Promise.allSettled(c);M.SendController.resetSend(),n.ConnectionController.resetWcConnection(),L.SIWXUtil.getSIWX()?.signOutOnDisconnect&&await L.SIWXUtil.clearSessions(),r.ConnectorController.setFilterByNamespace(void 0),n.ConnectionController.syncStorageConnections();let p=l.filter(e=>"rejected"===e.status);if(p.length>0)throw Error(p.map(e=>e.reason.message).join(", "));y.EventsController.sendEvent({type:"track",event:"DISCONNECT_SUCCESS",properties:{namespace:o||"all"}})}catch(e){throw Error(`Failed to disconnect chains: ${e.message}`)}},checkInstalled:e=>e?e.some(e=>!!window.ethereum?.[String(e)]):!!window.ethereum,signMessage:async e=>{let n=t.ChainController.state.activeChain,r=this.getAdapter(t.ChainController.state.activeChain);if(!n)throw Error("signMessage: namespace not found");if(!r)throw Error("signMessage: adapter not found");let a=this.getAddress(n);if(!a)throw Error("signMessage: address not found");let o=await r?.signMessage({message:e,address:a,provider:P.getProvider(n)});return o?.signature||""},sendTransaction:async e=>{let t=e.chainNamespace;if(!t)throw Error("sendTransaction: namespace not found");if(N.ConstantsUtil.SEND_SUPPORTED_NAMESPACES.includes(t)){let n=this.getAdapter(t);if(!n)throw Error("sendTransaction: adapter not found");let r=P.getProvider(t),a=await n?.sendTransaction({...e,caipNetwork:this.getCaipNetwork(),provider:r});return a?.hash||""}return""},estimateGas:async e=>{let t=e.chainNamespace;if(t===i.ConstantsUtil.CHAIN.EVM){let n=this.getAdapter(t);if(!n)throw Error("estimateGas: adapter is required but got undefined");let r=P.getProvider(t),a=this.getCaipNetwork();if(!a)throw Error("estimateGas: caipNetwork is required but got undefined");let o=await n?.estimateGas({...e,provider:r,caipNetwork:a});return o?.gas||0n}return 0n},getEnsAvatar:async()=>{let e=t.ChainController.state.activeChain;if(!e)throw Error("getEnsAvatar: namespace is required but got undefined");let n=this.getAddress(e);if(!n)throw Error("getEnsAvatar: address not found");await this.syncIdentity({address:n,chainId:Number(this.getCaipNetwork()?.id),chainNamespace:e});let r=t.ChainController.getAccountData();return r?.profileImage||!1},getEnsAddress:async e=>await eE.resolveReownName(e),writeContract:async e=>{let n=t.ChainController.state.activeChain,r=this.getAdapter(n);if(!n)throw Error("writeContract: namespace is required but got undefined");if(!r)throw Error("writeContract: adapter is required but got undefined");let a=this.getCaipNetwork(),o=this.getCaipAddress(),s=P.getProvider(n);if(!a||!o)throw Error("writeContract: caipNetwork or caipAddress is required but got undefined");let i=await r?.writeContract({...e,caipNetwork:a,provider:s,caipAddress:o});return i?.hash},parseUnits:(e,n)=>{let r=this.getAdapter(t.ChainController.state.activeChain);if(!r)throw Error("parseUnits: adapter is required but got undefined");return r?.parseUnits({value:e,decimals:n})??0n},formatUnits:(e,n)=>{let r=this.getAdapter(t.ChainController.state.activeChain);if(!r)throw Error("formatUnits: adapter is required but got undefined");return r?.formatUnits({value:e,decimals:n})??"0"},getCapabilities:async e=>{let n=this.getAdapter(t.ChainController.state.activeChain);if(!n)throw Error("getCapabilities: adapter is required but got undefined");return await n?.getCapabilities(e)},grantPermissions:async e=>{let n=this.getAdapter(t.ChainController.state.activeChain);if(!n)throw Error("grantPermissions: adapter is required but got undefined");return await n?.grantPermissions(e)},revokePermissions:async e=>{let n=this.getAdapter(t.ChainController.state.activeChain);if(!n)throw Error("revokePermissions: adapter is required but got undefined");return n?.revokePermissions?await n.revokePermissions(e):"0x"},walletGetAssets:async e=>{let n=this.getAdapter(t.ChainController.state.activeChain);if(!n)throw Error("walletGetAssets: adapter is required but got undefined");return await n?.walletGetAssets(e)??{}},updateBalance:e=>{let t=this.getAddress(e),n=this.getCaipNetwork(e);n&&t&&this.updateNativeBalance(t,n?.id,e)}},this.networkControllerClient={switchCaipNetwork:async e=>await this.switchCaipNetwork(e),getApprovedCaipNetworksData:async()=>this.getApprovedCaipNetworksData()},n.ConnectionController.setClient(this.connectionControllerClient)}async onConnectExternal(e){let n=t.ChainController.state.activeChain,a=e.chain||n,o=this.getAdapter(a),s=!0;if(e.type===q.CONNECTOR_TYPE_AUTH&&i.ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.some(e=>r.ConnectorController.getConnectorId(e)===i.ConstantsUtil.CONNECTOR_ID.AUTH)&&e.chain!==n&&(s=!1),e.chain&&e.chain!==n&&!e.caipNetwork){let t=this.getCaipNetworks().find(t=>t.chainNamespace===e.chain);t&&s&&this.setCaipNetwork(t)}if(!a)throw Error("connectExternal: namespace not found");if(!o)throw Error("connectExternal: adapter not found");let c=this.getCaipNetwork(a),l=e.caipNetwork||c,d=await o.connect({id:e.id,address:e.address,info:e.info,type:e.type,provider:e.provider,socialUri:e.socialUri,chainId:e.caipNetwork?.id||c?.id,rpcUrl:e.caipNetwork?.rpcUrls?.default?.http?.[0]||c?.rpcUrls?.default?.http?.[0]});if(d)return w.StorageUtil.addConnectedNamespace(a),this.syncProvider({...d,chainNamespace:a}),this.setStatus("connected",a),this.syncConnectedWalletInfo(a),w.StorageUtil.removeDisconnectedConnectorId(e.id,a),{address:d.address,connectedCaipNetwork:l}}async connectInactiveNamespaces(e,n){let r=e.type===q.CONNECTOR_TYPE_AUTH,a=er.getOtherAuthNamespaces(n?.connectedCaipNetwork?.chainNamespace),o=t.ChainController.state.activeCaipNetwork,s=this.getAdapter(o?.chainNamespace),i=P.getProvider(o?.chainNamespace);r&&(await Promise.all(a.map(async t=>{try{let n=P.getProvider(t),r=this.getCaipNetwork(t),a=this.getAdapter(t);await a?.connect({...e,provider:n,socialUri:void 0,chainId:r?.id,rpcUrl:r?.rpcUrls?.default?.http?.[0]})&&(w.StorageUtil.addConnectedNamespace(t),w.StorageUtil.removeDisconnectedConnectorId(e.id,t),this.setStatus("connected",t),this.syncConnectedWalletInfo(t))}catch(e){d.AlertController.warn(en.displayMessage,en.debugMessage(t,e instanceof Error?e.message:void 0),en.code)}})),o&&await s?.switchNetwork({caipNetwork:o,provider:i,providerType:e.type}))}getApprovedCaipNetworksData(){if(P.getProviderId(t.ChainController.state.activeChain)===q.CONNECTOR_TYPE_WALLET_CONNECT){let e=this.universalProvider?.session?.namespaces;return{supportsAllNetworks:this.universalProvider?.session?.peer?.metadata.name==="MetaMask Wallet",approvedCaipNetworkIds:this.getChainsFromNamespaces(e)}}return{supportsAllNetworks:!0,approvedCaipNetworkIds:[]}}async switchCaipNetwork(e){let n=e.chainNamespace;if(this.getAddressByChainNamespace(e.chainNamespace)){let r=P.getProvider(n),a=P.getProviderId(n);if(e.chainNamespace===t.ChainController.state.activeChain){let t=this.getAdapter(n);await t?.switchNetwork({caipNetwork:e,provider:r,providerType:a})}else if(this.setCaipNetwork(e),a===q.CONNECTOR_TYPE_WALLET_CONNECT)this.syncWalletConnectAccount();else{let t=this.getAddressByChainNamespace(n);t&&this.syncAccount({address:t,chainId:e.id,chainNamespace:n})}}else this.setCaipNetwork(e)}getChainsFromNamespaces(e={}){return Object.values(e).flatMap(e=>Array.from(new Set([...e.chains||[],...e.accounts.map(e=>{let{chainId:t,chainNamespace:n}=l.ParseUtil.parseCaipAddress(e);return`${n}:${t}`})])))}createAdapters(e){return this.createClients(),this.chainNamespaces.reduce((t,n)=>{let r=e?.find(e=>e.namespace===n);return r?(r.construct({namespace:n,projectId:this.options?.projectId,networks:this.caipNetworks?.filter(({chainNamespace:e})=>e===n)}),t[n]=r):t[n]=new eO({namespace:n,networks:this.getCaipNetworks()}),t},{})}async initChainAdapter(e){this.onConnectors(e),this.listenAdapter(e),await this.chainAdapters?.[e].syncConnectors(this.options,this),await this.createUniversalProviderForAdapter(e)}async initChainAdapters(){await Promise.all(this.chainNamespaces.map(async e=>{await this.initChainAdapter(e)}))}onConnectors(e){let t=this.getAdapter(e);t?.on("connectors",this.setConnectors.bind(this))}listenAdapter(e){let r=this.getAdapter(e);if(!r)return;let a=w.StorageUtil.getConnectionStatus();!1===o.OptionsController.state.enableReconnect?this.setStatus("disconnected",e):"connected"===a?this.setStatus("connecting",e):("disconnected"===a&&w.StorageUtil.clearAddressCache(),this.setStatus(a,e)),r.on("switchNetwork",({address:n,chainId:r})=>{let a=this.getCaipNetworks().find(e=>e.id.toString()===r.toString()||e.caipNetworkId.toString()===r.toString()),o=t.ChainController.state.activeChain===e,s=t.ChainController.state.chains.get(e)?.accountState?.address;if(a){let t=o&&n?n:s;t&&this.syncAccount({address:t,chainId:a.id,chainNamespace:e})}else this.setUnsupportedNetwork(r)}),r.on("disconnect",()=>{let t=this.remoteFeatures.multiWallet,r=Array.from(n.ConnectionController.state.connections.values()).flat();this.onDisconnectNamespace({chainNamespace:e,closeModal:!t||0===r.length})}),r.on("connections",t=>{this.setConnections(t,e)}),r.on("pendingTransactions",()=>{let n=this.getAddress(e),r=t.ChainController.state.activeCaipNetwork;n&&r?.id&&this.updateNativeBalance(n,r.id,r.chainNamespace)}),r.on("accountChanged",({address:n,chainId:r,connector:a})=>{this.handlePreviousConnectorConnection(a);let o=t.ChainController.state.activeChain===e;a?.provider&&(this.syncProvider({id:a.id,type:a.type,provider:a?.provider,chainNamespace:e}),this.syncConnectedWalletInfo(e));let s=t.ChainController.getNetworkData(e)?.caipNetwork?.id,i=r||s;o&&i?this.syncAccount({address:n,chainId:i,chainNamespace:e}):!o&&i?(this.syncAccountInfo(n,i,e),this.syncBalance({address:n,chainId:i,chainNamespace:e})):this.syncAccountInfo(n,r,e),w.StorageUtil.addConnectedNamespace(e)})}async handlePreviousConnectorConnection(e){let t=e?.chain,a=e?.id,s=r.ConnectorController.getConnectorId(t),i=o.OptionsController.state.remoteFeatures?.multiWallet,c=s!==a,l=t&&a&&s&&c&&!i;try{l&&await n.ConnectionController.disconnect({id:s,namespace:t})}catch(e){console.warn("Error disconnecting previous connector",e)}}async createUniversalProviderForAdapter(e){await this.getUniversalProvider(),this.universalProvider&&await this.chainAdapters?.[e]?.setUniversalProvider?.(this.universalProvider)}async syncExistingConnection(){await Promise.allSettled(this.chainNamespaces.map(e=>this.syncNamespaceConnection(e)))}async unSyncExistingConnection(){try{await Promise.allSettled(this.chainNamespaces.map(e=>n.ConnectionController.disconnect({namespace:e,initialDisconnect:!0})))}catch(e){console.error("Error disconnecting existing connections:",e)}}async reconnectWalletConnect(){await this.syncWalletConnectAccount();let e=this.getAddress();this.getCaipAddress()||w.StorageUtil.deleteRecentWallet();let t=w.StorageUtil.getRecentWallet();y.EventsController.sendEvent({type:"track",event:"CONNECT_SUCCESS",address:e,properties:{method:a.CoreHelperUtil.isMobile()?"mobile":"qrcode",name:t?.name||"Unknown",reconnect:!0,view:f.RouterController.state.view,walletRank:t?.order}})}async syncNamespaceConnection(e){try{e===i.ConstantsUtil.CHAIN.EVM&&a.CoreHelperUtil.isSafeApp()&&r.ConnectorController.setConnectorId(i.ConstantsUtil.CONNECTOR_ID.SAFE,e);let t=r.ConnectorController.getConnectorId(e);switch(this.setStatus("connecting",e),t){case i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT:await this.reconnectWalletConnect();break;case i.ConstantsUtil.CONNECTOR_ID.AUTH:break;default:await this.syncAdapterConnection(e)}}catch(t){console.warn("AppKit couldn't sync existing connection",t),this.setStatus("disconnected",e)}}onDisconnectNamespace(e){let{chainNamespace:n,closeModal:a}=e||{};t.ChainController.resetAccount(n),t.ChainController.resetNetwork(n),w.StorageUtil.removeConnectedNamespace(n);let o=Array.from(t.ChainController.state.chains.keys());(n?[n]:o).forEach(e=>w.StorageUtil.addDisconnectedConnectorId(r.ConnectorController.getConnectorId(e)||"",e)),r.ConnectorController.removeConnectorId(n),P.resetChain(n),this.setUser(null,n),this.setStatus("disconnected",n),this.setConnectedWalletInfo(null,n),!1!==a&&O.ModalController.close()}async syncAdapterConnections(){await Promise.allSettled(this.chainNamespaces.map(e=>{let t=this.getAdapter(e),n=this.getCaipAddress(e),r=this.getCaipNetwork(e);return t?.syncConnections({connectToFirstConnector:!n,caipNetwork:r})}))}async syncAdapterConnection(e){let t=this.getAdapter(e),n=this.getCaipNetwork(e),a=r.ConnectorController.getConnectorId(e),o=r.ConnectorController.getConnectors(e).find(e=>e.id===a);try{if(!t||!o)throw Error(`Adapter or connector not found for namespace ${e}`);if(!n?.id)throw Error("CaipNetwork not found");let r=await t?.syncConnection({namespace:e,id:o.id,chainId:n.id,rpcUrl:n?.rpcUrls?.default?.http?.[0]});r?(this.syncProvider({...r,chainNamespace:e}),await this.syncAccount({...r,chainNamespace:e}),this.setStatus("connected",e),y.EventsController.sendEvent({type:"track",event:"CONNECT_SUCCESS",address:r.address,properties:{method:"browser",name:o.info?.name||o.name||"Unknown",reconnect:!0,view:f.RouterController.state.view,walletRank:void 0}})):this.setStatus("disconnected",e)}catch(t){this.onDisconnectNamespace({chainNamespace:e,closeModal:!1})}}async syncWalletConnectAccount(){let e=Object.keys(this.universalProvider?.session?.namespaces||{}),n=this.chainNamespaces.map(async n=>{let a=this.getAdapter(n);if(!a)return;let o=this.universalProvider?.session?.namespaces?.[n]?.accounts||[],s=t.ChainController.state.activeCaipNetwork?.id,c=o.find(e=>{let{chainId:t}=l.ParseUtil.parseCaipAddress(e);return t===s?.toString()})||o[0];if(c){let e=l.ParseUtil.validateCaipAddress(c),{chainId:o,address:s}=l.ParseUtil.parseCaipAddress(e);if(P.setProviderId(n,q.CONNECTOR_TYPE_WALLET_CONNECT),this.caipNetworks&&t.ChainController.state.activeCaipNetwork&&a.namespace!==i.ConstantsUtil.CHAIN.EVM){let e=a.getWalletConnectProvider({caipNetworks:this.getCaipNetworks(),provider:this.universalProvider,activeCaipNetwork:t.ChainController.state.activeCaipNetwork});P.setProvider(n,e)}else P.setProvider(n,this.universalProvider);r.ConnectorController.setConnectorId(i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT,n),w.StorageUtil.addConnectedNamespace(n),await this.syncAccount({address:s,chainId:o,chainNamespace:n})}else e.includes(n)&&this.setStatus("disconnected",n);this.syncConnectedWalletInfo(n),await t.ChainController.setApprovedCaipNetworksData(n)});await Promise.all(n)}syncProvider({type:e,provider:t,id:n,chainNamespace:a}){P.setProviderId(a,e),P.setProvider(a,t),r.ConnectorController.setConnectorId(n,a)}async syncAccount(e){let n=e.chainNamespace===t.ChainController.state.activeChain,r=t.ChainController.getCaipNetworkByNamespace(e.chainNamespace,e.chainId),{address:a,chainId:s,chainNamespace:c}=e,{chainId:d}=w.StorageUtil.getActiveNetworkProps(),C=s||d,p=t.ChainController.state.activeCaipNetwork?.name===i.ConstantsUtil.UNSUPPORTED_NETWORK_NAME,h=t.ChainController.getNetworkProp("supportsAllNetworks",c);if(this.setStatus("connected",c),(!p||h)&&C){let e=this.getCaipNetworks().find(e=>e.id.toString()===C.toString()),d=this.getCaipNetworks().find(e=>e.chainNamespace===c);if(!h&&!e&&!d){let t=this.getApprovedCaipNetworkIds()||[],n=t.find(e=>l.ParseUtil.parseCaipNetworkId(e)?.chainId===C.toString()),r=t.find(e=>l.ParseUtil.parseCaipNetworkId(e)?.chainNamespace===c);e=this.getCaipNetworks().find(e=>e.caipNetworkId===n),d=this.getCaipNetworks().find(e=>e.caipNetworkId===r||"deprecatedCaipNetworkId"in e&&e.deprecatedCaipNetworkId===r)}let p=e||d;p?.chainNamespace===t.ChainController.state.activeChain?o.OptionsController.state.enableNetworkSwitch&&!o.OptionsController.state.allowUnsupportedChain&&t.ChainController.state.activeCaipNetwork?.name===i.ConstantsUtil.UNSUPPORTED_NETWORK_NAME?t.ChainController.showUnsupportedChainUI():this.setCaipNetwork(p):!n&&r&&this.setCaipNetworkOfNamespace(r,c),this.syncConnectedWalletInfo(c);let u=this.getAddress(c);er.isLowerCaseMatch(a,u)||this.syncAccountInfo(a,p?.id,c),n?await this.syncBalance({address:a,chainId:p?.id,chainNamespace:c}):await this.syncBalance({address:a,chainId:r?.id,chainNamespace:c}),this.syncIdentity({address:a,chainId:s,chainNamespace:c})}}async syncAccountInfo(e,t,n){let r=this.getCaipAddress(n),a=t||r?.split(":")[1];if(!a)return;let o=`${n}:${a}:${e}`;this.setCaipAddress(o,n,!0),await this.syncIdentity({address:e,chainId:a,chainNamespace:n})}async syncReownName(e,t){try{let n=await this.getReownName(e);if(n[0]){let e=n[0];this.setProfileName(e.name,t)}else this.setProfileName(null,t)}catch{this.setProfileName(null,t)}}syncConnectedWalletInfo(e){let t=r.ConnectorController.getConnectorId(e),n=P.getProviderId(e);if(n===q.CONNECTOR_TYPE_ANNOUNCED||n===q.CONNECTOR_TYPE_INJECTED){if(t){let n=this.getConnectors().find(e=>{let n=e.id===t,r=e.info?.rdns===t,a=e.connectors?.some(e=>e.id===t||e.info?.rdns===t);return n||r||!!a});if(n){let{info:t,name:r,imageUrl:a}=n,o=a||this.getConnectorImage(n);this.setConnectedWalletInfo({name:r,icon:o,...t},e)}}}else if(n===q.CONNECTOR_TYPE_WALLET_CONNECT){let t=P.getProvider(e);t?.session&&this.setConnectedWalletInfo({...t.session.peer.metadata,name:t.session.peer.metadata.name,icon:t.session.peer.metadata.icons?.[0]},e)}else if(t&&(t===i.ConstantsUtil.CONNECTOR_ID.COINBASE_SDK||t===i.ConstantsUtil.CONNECTOR_ID.COINBASE)){let n=this.getConnectors().find(e=>e.id===t),r=n?.name||"Coinbase Wallet",a=n?.imageUrl||this.getConnectorImage(n),o=n?.info;this.setConnectedWalletInfo({...o,name:r,icon:a},e)}}async syncBalance(e){c.NetworkUtil.getNetworksByNamespace(this.getCaipNetworks(),e.chainNamespace).find(t=>t.id.toString()===e.chainId?.toString())&&e.chainId&&await this.updateNativeBalance(e.address,e.chainId,e.chainNamespace)}async ready(){await this.readyPromise}async updateNativeBalance(e,n,r){let a=this.getAdapter(r),o=t.ChainController.getCaipNetworkByNamespace(r,n);if(a){let t=await a.getBalance({address:e,chainId:n,caipNetwork:o,tokens:this.options.tokens});return this.setBalance(t.balance,t.symbol,r),t}}async initializeUniversalAdapter(){let e=eo.createLogger((e,...t)=>{e&&this.handleAlertError(e),console.error(...t)}),t={projectId:this.options?.projectId,metadata:{name:this.options?.metadata?this.options?.metadata.name:"",description:this.options?.metadata?this.options?.metadata.description:"",url:this.options?.metadata?this.options?.metadata.url:"",icons:this.options?.metadata?this.options?.metadata.icons:[""]},logger:e};o.OptionsController.setManualWCControl(!!this.options?.manualWCControl),this.universalProvider=this.options.universalProvider??await s.default.init(t),!1===o.OptionsController.state.enableReconnect&&this.universalProvider.session&&await this.universalProvider.disconnect(),this.listenWalletConnect()}listenWalletConnect(){this.universalProvider&&this.chainNamespaces.forEach(e=>{eE.listenWcProvider({universalProvider:this.universalProvider,namespace:e,onDisplayUri:e=>{n.ConnectionController.setUri(e)},onConnect:e=>{let{address:t}=a.CoreHelperUtil.getAccount(e[0]);n.ConnectionController.finalizeWcConnection(t)},onDisconnect:()=>{t.ChainController.state.noAdapters&&this.resetAccount(e),n.ConnectionController.resetWcConnection()},onChainChanged:n=>{let a=t.ChainController.state.activeChain,o=a&&r.ConnectorController.state.activeConnectorIds[a]===i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;if(a===e&&(t.ChainController.state.noAdapters||o)){let e=this.getCaipNetworks().find(e=>e.id.toString()===n.toString()||e.caipNetworkId.toString()===n.toString()),t=this.getCaipNetwork();if(!e)return void this.setUnsupportedNetwork(n);t?.id.toString()!==e?.id.toString()&&t?.chainNamespace===e?.chainNamespace&&this.setCaipNetwork(e)}},onAccountsChanged:n=>{let a=t.ChainController.state.activeChain,o=a&&r.ConnectorController.state.activeConnectorIds[a]===i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;if(a===e&&(t.ChainController.state.noAdapters||o)){let e=n?.[0];e&&this.syncAccount({address:e.address,chainId:e.chainId,chainNamespace:e.chainNamespace})}}})})}createUniversalProvider(){return!this.universalProviderInitPromise&&a.CoreHelperUtil.isClient()&&this.options?.projectId&&(this.universalProviderInitPromise=this.initializeUniversalAdapter()),this.universalProviderInitPromise}async getUniversalProvider(){if(!this.universalProvider)try{await this.createUniversalProvider()}catch(e){y.EventsController.sendEvent({type:"error",event:"INTERNAL_SDK_ERROR",properties:{errorType:"UniversalProviderInitError",errorMessage:e instanceof Error?e.message:"Unknown",uncaught:!1}}),console.error("AppKit:getUniversalProvider - Cannot create provider",e)}return this.universalProvider}getDisabledCaipNetworks(){let e=t.ChainController.getAllApprovedCaipNetworkIds(),n=t.ChainController.getAllRequestedCaipNetworks();return a.CoreHelperUtil.sortRequestedNetworks(e,n).filter(e=>t.ChainController.isCaipNetworkDisabled(e))}handleAlertError(e){let[t,n]=Object.entries(Q).find(([,{message:t}])=>e.message.includes(t))??[],{message:r,alertErrorKey:a}=n??{};if(t&&r&&!this.reportedAlertErrors[t]){let e=ee[a];e&&(d.AlertController.open(e,"error"),this.reportedAlertErrors[t]=!0)}}getAdapter(e){if(e)return this.chainAdapters?.[e]}createAdapter(e){if(!e)return;let t=e.namespace;t&&(this.createClients(),e.namespace=t,e.construct({namespace:t,projectId:this.options?.projectId,networks:this.caipNetworks?.filter(({chainNamespace:e})=>e===t)}),this.chainNamespaces.includes(t)||this.chainNamespaces.push(t),this.chainAdapters&&(this.chainAdapters[t]=e))}async open(e){await this.injectModalUi(),e?.uri&&n.ConnectionController.setUri(e.uri);let{isSwap:t,isSend:r}=this.toModalOptions();return t(e)?O.ModalController.open({...e,data:{swap:e.arguments}}):r(e)&&e.arguments?this.openSend(e.arguments):O.ModalController.open(e)}async close(){await this.injectModalUi(),O.ModalController.close()}setLoading(e,t){O.ModalController.setLoading(e,t)}async disconnect(e){await n.ConnectionController.disconnect({namespace:e})}getSIWX(){return o.OptionsController.state.siwx}getError(){return""}getChainId(){return t.ChainController.state.activeCaipNetwork?.id}async switchNetwork(e,{throwOnFailure:n=!1}={}){let r=this.getCaipNetworks().find(t=>t.id===e.id);r?await t.ChainController.switchActiveNetwork(r,{throwOnFailure:n}):d.AlertController.open(ee.SWITCH_NETWORK_NOT_FOUND,"error")}getWalletProvider(){return t.ChainController.state.activeChain?P.state.providers[t.ChainController.state.activeChain]:null}getWalletProviderType(){return P.getProviderId(t.ChainController.state.activeChain)}subscribeProviders(e){return P.subscribeProviders(e)}getThemeMode(){return F.ThemeController.state.themeMode}getThemeVariables(){return F.ThemeController.state.themeVariables}setThemeMode(e){F.ThemeController.setThemeMode(e),(0,K.setColorTheme)(F.ThemeController.state.themeMode)}setTermsConditionsUrl(e){o.OptionsController.setTermsConditionsUrl(e)}setPrivacyPolicyUrl(e){o.OptionsController.setPrivacyPolicyUrl(e)}setThemeVariables(e){F.ThemeController.setThemeVariables(e),(0,K.setThemeVariables)(F.ThemeController.state.themeVariables)}subscribeTheme(e){return F.ThemeController.subscribe(e)}subscribeConnections(e){return this.remoteFeatures.multiWallet?n.ConnectionController.subscribe(e):(d.AlertController.open(i.ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,"info"),()=>void 0)}getWalletInfo(e){if(e)return t.ChainController.state.chains.get(e)?.accountState?.connectedWalletInfo;let n=t.ChainController.getAccountData();return n?.connectedWalletInfo}getAccount(e){let o=e||t.ChainController.state.activeChain,s=r.ConnectorController.getAuthConnector(o),c=t.ChainController.getAccountData(o),l=w.StorageUtil.getConnectedConnectorId(t.ChainController.state.activeChain),d=n.ConnectionController.getConnections(o);if(!o)throw Error("AppKit:getAccount - namespace is required");let C=d.flatMap(e=>e.accounts.map(({address:e,type:t,publicKey:n})=>a.CoreHelperUtil.createAccount(o,e,t||"eoa",n)));if(c)return{allAccounts:C,caipAddress:c.caipAddress,address:a.CoreHelperUtil.getPlainAddress(c.caipAddress),isConnected:!!c.caipAddress,status:c.status,embeddedWalletInfo:s&&l===i.ConstantsUtil.CONNECTOR_ID.AUTH?{user:c.user?{...c.user,username:w.StorageUtil.getConnectedSocialUsername()}:void 0,authProvider:c.socialProvider||"email",accountType:(0,B.getPreferredAccountType)(o),isSmartAccountDeployed:!!c.smartAccountDeployed}:void 0}}subscribeAccount(e,n){let a=()=>{let t=this.getAccount(n);t&&e(t)};n?t.ChainController.subscribeChainProp("accountState",a,n):t.ChainController.subscribe(a),r.ConnectorController.subscribe(a)}subscribeNetwork(e){return t.ChainController.subscribe(({activeCaipNetwork:t})=>{e({caipNetwork:t,chainId:t?.id,caipNetworkId:t?.caipNetworkId})})}subscribeWalletInfo(e,n){return n?t.ChainController.subscribeChainProp("accountState",t=>e(t?.connectedWalletInfo),n):t.ChainController.subscribeChainProp("accountState",t=>e(t?.connectedWalletInfo))}subscribeShouldUpdateToAddress(e){t.ChainController.subscribeChainProp("accountState",t=>e(t?.shouldUpdateToAddress))}subscribeCaipNetworkChange(e){t.ChainController.subscribeKey("activeCaipNetwork",e)}getState(){return D.PublicStateController.state}getRemoteFeatures(){return o.OptionsController.state.remoteFeatures}subscribeState(e){return D.PublicStateController.subscribe(e)}subscribeRemoteFeatures(e){return o.OptionsController.subscribeKey("remoteFeatures",e)}showErrorMessage(e){W.SnackController.showError(e)}showSuccessMessage(e){W.SnackController.showSuccess(e)}getEvent(){return{...y.EventsController.state}}subscribeEvents(e){return y.EventsController.subscribe(e)}replace(e){f.RouterController.replace(e)}redirect(e){f.RouterController.push(e)}popTransactionStack(e){f.RouterController.popTransactionStack(e)}isOpen(){return O.ModalController.state.open}isTransactionStackEmpty(){return 0===f.RouterController.state.transactionStack.length}static getInstance(){return this.instance}updateFeatures(e){o.OptionsController.setFeatures(e)}updateRemoteFeatures(e){o.OptionsController.setRemoteFeatures(e)}updateOptions(e){let t={...o.OptionsController.state||{},...e};o.OptionsController.setOptions(t)}setConnectMethodsOrder(e){o.OptionsController.setConnectMethodsOrder(e)}setWalletFeaturesOrder(e){o.OptionsController.setWalletFeaturesOrder(e)}setCollapseWallets(e){o.OptionsController.setCollapseWallets(e)}setSocialsOrder(e){o.OptionsController.setSocialsOrder(e)}getConnectMethodsOrder(){return H.WalletUtil.getConnectOrderMethod(o.OptionsController.state.features,r.ConnectorController.getConnectors())}addNetwork(e,n){if(this.chainAdapters&&!this.chainAdapters[e])throw Error(`Adapter for namespace ${e} doesn't exist`);let r=this.extendCaipNetwork(n,this.options);this.getCaipNetworks().find(e=>e.id===r.id)||t.ChainController.addNetwork(r)}removeNetwork(e,n){if(this.chainAdapters&&!this.chainAdapters[e])throw Error(`Adapter for namespace ${e} doesn't exist`);this.getCaipNetworks().find(e=>e.id===n)&&t.ChainController.removeNetwork(e,n)}}let ek=!1;class eS extends eU{async open(e){r.ConnectorController.isConnected()||await super.open(e)}async close(){if(await super.close(),this.options.manualWCControl){let e=t.ChainController.getAccountData(this.activeChainNamespace)?.address;n.ConnectionController.finalizeWcConnection(e)}}async syncIdentity(e){return Promise.resolve()}async syncBalance(e){return Promise.resolve()}async injectModalUi(){if(!ek&&a.CoreHelperUtil.isClient()){if(await e.A(758042),await e.A(449870),!document.querySelector("w3m-modal")){let e=document.createElement("w3m-modal");o.OptionsController.state.disableAppend||o.OptionsController.state.enableEmbedded||document.body.insertAdjacentElement("beforeend",e)}ek=!0}}}function eR(e){return new eS({...e,basic:!0,sdkVersion:"html-core-1.8.7"})}e.s(["createAppKit",()=>eR],580019),e.i(580019),e.s(["AppKit",()=>eS,"createAppKit",()=>eR],633069)}]);
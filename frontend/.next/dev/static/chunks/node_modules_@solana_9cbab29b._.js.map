{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/errors/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/errors/src/codes.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/errors/src/context.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/errors/src/messages.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/errors/src/message-formatter.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/errors/src/error.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/errors/src/stack-trace.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/errors/src/rpc-enum-errors.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/errors/src/instruction-error.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/errors/src/transaction-error.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/errors/src/json-rpc-error.ts"],"sourcesContent":["/**\n * To add a new error, follow the instructions at\n * https://github.com/anza-xyz/kit/tree/main/packages/errors/#adding-a-new-error\n *\n * @module\n * @privateRemarks\n * WARNING:\n *   - Don't remove error codes\n *   - Don't change or reorder error codes.\n *\n * Good naming conventions:\n *   - Prefixing common errors — e.g. under the same package — can be a good way to namespace them. E.g. All codec-related errors start with `SOLANA_ERROR__CODECS__`.\n *   - Use consistent names — e.g. choose `PDA` or `PROGRAM_DERIVED_ADDRESS` and stick with it. Ensure your names are consistent with existing error codes. The decision might have been made for you.\n *   - Recommended prefixes and suffixes:\n *     - `MALFORMED_`: Some input was not constructed properly. E.g. `MALFORMED_BASE58_ENCODED_ADDRESS`.\n *     - `INVALID_`: Some input is invalid (other than because it was MALFORMED). E.g. `INVALID_NUMBER_OF_BYTES`.\n *     - `EXPECTED_`: Some input was different than expected, no need to specify the \"GOT\" part unless necessary. E.g. `EXPECTED_DECODED_ACCOUNT`.\n *     - `_CANNOT_`: Some operation cannot be performed or some input cannot be used due to some condition. E.g. `CANNOT_DECODE_EMPTY_BYTE_ARRAY` or `PDA_CANNOT_END_WITH_PDA_MARKER`.\n *     - `_MUST_BE_`: Some condition must be true. E.g. `NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE`.\n *     - `_FAILED_TO_`: Tried to perform some operation and failed. E.g. `FAILED_TO_DECODE_ACCOUNT`.\n *     - `_NOT_FOUND`: Some operation lead to not finding something. E.g. `ACCOUNT_NOT_FOUND`.\n *     - `_OUT_OF_RANGE`: Some value is out of range. E.g. `ENUM_DISCRIMINATOR_OUT_OF_RANGE`.\n *     - `_EXCEEDED`: Some limit was exceeded. E.g. `PDA_MAX_SEED_LENGTH_EXCEEDED`.\n *     - `_MISMATCH`: Some elements do not match. E.g. `ENCODER_DECODER_FIXED_SIZE_MISMATCH`.\n *     - `_MISSING`: Some required input is missing. E.g. `TRANSACTION_FEE_PAYER_MISSING`.\n *     - `_UNIMPLEMENTED`: Some required component is not available in the environment. E.g. `SUBTLE_CRYPTO_VERIFY_FUNCTION_UNIMPLEMENTED`.\n */\nexport const SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;\nexport const SOLANA_ERROR__INVALID_NONCE = 2;\nexport const SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;\nexport const SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;\nexport const SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;\nexport const SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;\nexport const SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;\nexport const SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;\nexport const SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;\nexport const SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;\n\n// JSON-RPC-related errors.\n// Reserve error codes in the range [-32768, -32000]\n// Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-api/src/custom_error.rs\nexport const SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;\nexport const SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;\nexport const SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE = -32019;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY = -32018;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE = -32017;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;\nexport const SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;\n\n// Addresses-related errors.\n// Reserve error codes in the range [2800000-2800999].\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 2800000;\nexport const SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;\nexport const SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;\nexport const SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;\nexport const SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;\nexport const SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;\nexport const SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;\nexport const SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011;\n\n// Account-related errors.\n// Reserve error codes in the range [3230000-3230999].\nexport const SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 3230000;\nexport const SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;\nexport const SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;\n\n// Subtle-Crypto-related errors.\n// Reserve error codes in the range [3610000-3610999].\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 3610000;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;\n\n// Crypto-related errors.\n// Reserve error codes in the range [3611000-3611050].\nexport const SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611000;\n\n// Key-related errors.\n// Reserve error codes in the range [3704000-3704999].\nexport const SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704000;\nexport const SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;\nexport const SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;\nexport const SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;\nexport const SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;\n\n// Instruction-related errors.\n// Reserve error codes in the range [4128000-4128999].\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128000;\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;\nexport const SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;\n\n// Instruction errors.\n// Reserve error codes starting with [4615000-4615999] for the Rust enum `InstructionError`.\n// Error names here are dictated by the RPC (see ./instruction-error.ts).\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615000;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;\n\n// Signer-related errors.\n// Reserve error codes in the range [5508000-5508999].\nexport const SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508000;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;\nexport const SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;\n\n// Offchain-message-related errors.\n// Reserve error codes in the range [5607000-5607999].\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED = 5607000;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE = 5607001;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE = 5607002;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH = 5607003;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH = 5607004;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO = 5607005;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED = 5607006;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH = 5607007;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH = 5607008;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY = 5607009;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO = 5607010;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING = 5607011;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH = 5607012;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE = 5607013;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION = 5607014;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED = 5607015;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE = 5607016;\nexport const SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE = 5607017;\n\n// Transaction-related errors.\n// Reserve error codes in the range [5663000-5663999].\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663000;\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;\nexport const SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;\nexport const SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;\nexport const SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;\nexport const SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;\nexport const SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;\nexport const SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;\nexport const SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020;\nexport const SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED = 5663021;\nexport const SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE = 5663022;\n\n// Transaction errors.\n// Reserve error codes starting with [7050000-7050999] for the Rust enum `TransactionError`.\n// Error names here are dictated by the RPC (see ./transaction-error.ts).\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 7050000;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;\n// `InstructionError` intentionally omitted.\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;\n\n// Instruction plan related errors.\n// Reserve error codes in the range [7618000-7618999].\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN = 7618000;\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE = 7618001;\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN = 7618002;\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN = 7618003;\n\n// Codec-related errors.\n// Reserve error codes in the range [8078000-8078999].\nexport const SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078000;\nexport const SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;\nexport const SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;\nexport const SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;\nexport const SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;\nexport const SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;\nexport const SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;\nexport const SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;\nexport const SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;\nexport const SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;\nexport const SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;\nexport const SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;\nexport const SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;\nexport const SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;\nexport const SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;\nexport const SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;\nexport const SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;\nexport const SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;\nexport const SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;\nexport const SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;\nexport const SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY = 8078023;\n\n// RPC-related errors.\n// Reserve error codes in the range [8100000-8100999].\nexport const SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 8100000;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;\nexport const SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;\n\n// RPC-Subscriptions-related errors.\n// Reserve error codes in the range [8190000-8190999].\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 8190000;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;\n\n// Invariant violation errors.\n// Reserve error codes in the range [9900000-9900999].\n// These errors should only be thrown when there is a bug with the\n// library itself and should, in theory, never reach the end user.\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 9900000;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND = 9900005;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND = 9900006;\n\n/**\n * A union of every Solana error code\n *\n * @privateRemarks\n * You might be wondering why this is not a TypeScript enum or const enum.\n *\n * One of the goals of this library is to enable people to use some or none of it without having to\n * bundle all of it.\n *\n * If we made the set of error codes an enum then anyone who imported it (even if to only use a\n * single error code) would be forced to bundle every code and its label.\n *\n * Const enums appear to solve this problem by letting the compiler inline only the codes that are\n * actually used. Unfortunately exporting ambient (const) enums from a library like `@solana/errors`\n * is not safe, for a variety of reasons covered here: https://stackoverflow.com/a/28818850\n */\nexport type SolanaErrorCode =\n    | typeof SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND\n    | typeof SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE\n    | typeof SOLANA_ERROR__ADDRESSES__MALFORMED_PDA\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER\n    | typeof SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED\n    | typeof SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY\n    | typeof SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS\n    | typeof SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE\n    | typeof SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__INVALID_CONSTANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS\n    | typeof SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE\n    | typeof SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES\n    | typeof SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE\n    | typeof SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH\n    | typeof SOLANA_ERROR__INVALID_NONCE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE\n    | typeof SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_PARAMS\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_REQUEST\n    | typeof SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND\n    | typeof SOLANA_ERROR__JSON_RPC__PARSE_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SCAN_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION\n    | typeof SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY\n    | typeof SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__MALFORMED_BIGINT_STRING\n    | typeof SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR\n    | typeof SOLANA_ERROR__MALFORMED_NUMBER_STRING\n    | typeof SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION\n    | typeof SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED\n    | typeof SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD\n    | typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID\n    | typeof SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING\n    | typeof SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES\n    | typeof SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE\n    | typeof SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH\n    | typeof SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE\n    | typeof SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED\n    | typeof SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT;\n\n/**\n * Errors of this type are understood to have an optional {@link SolanaError} nested inside as\n * `cause`.\n */\nexport type SolanaErrorCodeWithCause = typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE;\n","/**\n * To add a new error, follow the instructions at\n * https://github.com/anza-xyz/kit/tree/main/packages/errors/#adding-a-new-error\n *\n * @privateRemarks\n * WARNING:\n *   - Don't change or remove members of an error's context.\n */\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_CONSTANT,\n    SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND,\n    SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR,\n    SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SOLANA_ERROR__INVALID_NONCE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__MALFORMED_BIGINT_STRING,\n    SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR,\n    SOLANA_ERROR__MALFORMED_NUMBER_STRING,\n    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED,\n    SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD,\n    SOLANA_ERROR__RPC__INTEGER_OVERFLOW,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS,\n    SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER,\n    SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY,\n    SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING,\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n    SolanaErrorCode,\n} from './codes';\nimport { RpcSimulateTransactionResult } from './json-rpc-error';\n\ntype BasicInstructionErrorContext<T extends SolanaErrorCode> = { [P in T]: { index: number } };\n\ntype DefaultUnspecifiedErrorContextToUndefined<T> = {\n    [P in SolanaErrorCode]: P extends keyof T ? T[P] : undefined;\n};\n\ntype ReadonlyContextValue<T> = {\n    [P in keyof T]: Readonly<T[P]>;\n};\n\ntype TypedArrayMutableProperties = 'copyWithin' | 'fill' | 'reverse' | 'set' | 'sort';\ninterface ReadonlyUint8Array extends Omit<Uint8Array, TypedArrayMutableProperties> {\n    readonly [n: number]: number;\n}\n\n/** A amount of bytes. */\ntype Bytes = number;\n\n/**\n * A map of every {@link SolanaError} code to the type of its `context` property.\n */\nexport type SolanaErrorContext = ReadonlyContextValue<\n    DefaultUnspecifiedErrorContextToUndefined<\n        BasicInstructionErrorContext<\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID\n            | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR\n        > & {\n            [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: {\n                address: string;\n            };\n            [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: {\n                addresses: readonly string[];\n            };\n            [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: {\n                address: string;\n            };\n            [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: {\n                address: string;\n            };\n            [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: {\n                addresses: readonly string[];\n            };\n            [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: {\n                putativeAddress: string;\n            };\n            [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: {\n                actualLength: number;\n            };\n            [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: {\n                actual: number;\n                maxSeeds: number;\n            };\n            [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: {\n                actual: number;\n                index: number;\n                maxSeedLength: number;\n            };\n            [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: {\n                bump: number;\n            };\n            [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: {\n                actualLength: number;\n            };\n            [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: {\n                actualLength: number;\n            };\n            [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: {\n                currentBlockHeight: bigint;\n                lastValidBlockHeight: bigint;\n            };\n            [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: {\n                codecDescription: string;\n            };\n            [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: {\n                stringValues: readonly string[];\n            };\n            [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: {\n                encodedBytes: ReadonlyUint8Array;\n                hexEncodedBytes: string;\n                hexSentinel: string;\n                sentinel: ReadonlyUint8Array;\n            };\n            [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: {\n                decoderFixedSize: number;\n                encoderFixedSize: number;\n            };\n            [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: {\n                decoderMaxSize: number | undefined;\n                encoderMaxSize: number | undefined;\n            };\n            [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: {\n                discriminator: bigint | number;\n                formattedValidDiscriminators: string;\n                validDiscriminators: readonly number[];\n            };\n            [SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY]: {\n                expectedLength: number;\n                numExcessBytes: number;\n            };\n            [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: {\n                bytesLength: number;\n                codecDescription: string;\n            };\n            [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: {\n                codecDescription: string;\n                expectedSize: number;\n                hexZeroValue: string;\n                zeroValue: ReadonlyUint8Array;\n            };\n            [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: {\n                bytesLength: number;\n                codecDescription: string;\n                expected: number;\n            };\n            [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: {\n                constant: ReadonlyUint8Array;\n                data: ReadonlyUint8Array;\n                hexConstant: string;\n                hexData: string;\n                offset: number;\n            };\n            [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: {\n                value: bigint | boolean | number | string | null | undefined;\n                variants: readonly (bigint | boolean | number | string | null | undefined)[];\n            };\n            [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: {\n                formattedNumericalValues: string;\n                numericalValues: readonly number[];\n                stringValues: readonly string[];\n                variant: number | string | symbol;\n            };\n            [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: {\n                value: bigint | boolean | number | string | null | undefined;\n                variants: readonly (bigint | boolean | number | string | null | undefined)[];\n            };\n            [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: {\n                actual: bigint | number;\n                codecDescription: string;\n                expected: bigint | number;\n            };\n            [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: {\n                alphabet: string;\n                base: number;\n                value: string;\n            };\n            [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: {\n                discriminator: bigint | number;\n                maxRange: number;\n                minRange: number;\n            };\n            [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: {\n                codecDescription: string;\n                max: bigint | number;\n                min: bigint | number;\n                value: bigint | number;\n            };\n            [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: {\n                bytesLength: number;\n                codecDescription: string;\n                offset: number;\n            };\n            [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: {\n                decodedBytes: ReadonlyUint8Array;\n                hexDecodedBytes: string;\n                hexSentinel: string;\n                sentinel: ReadonlyUint8Array;\n            };\n            [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: {\n                maxRange: number;\n                minRange: number;\n                variant: number;\n            };\n            [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: {\n                index: number;\n            };\n            [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: {\n                code: number;\n                index: number;\n            };\n            [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: {\n                errorName: string;\n                index: number;\n                instructionErrorContext?: unknown;\n            };\n            [SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN]: {\n                transactionPlanResult: unknown;\n            };\n            [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN]: {\n                numBytesRequired: number;\n                numFreeBytes: number;\n            };\n            [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: {\n                data?: ReadonlyUint8Array;\n                programAddress: string;\n            };\n            [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: {\n                accountAddresses?: readonly string[];\n                programAddress: string;\n            };\n            [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: {\n                actualProgramAddress: string;\n                expectedProgramAddress: string;\n            };\n            [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: {\n                actualLength: number;\n            };\n            [SOLANA_ERROR__INVALID_NONCE]: {\n                actualNonceValue: string;\n                expectedNonceValue: string;\n            };\n            [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: {\n                cacheKey: string;\n            };\n            [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: {\n                channelName: string;\n                supportedChannelNames: readonly string[];\n            };\n            [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND]: {\n                kind: string;\n            };\n            [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND]: {\n                kind: string;\n            };\n            [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: {\n                unexpectedValue: unknown;\n            };\n            [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: {\n                __serverMessage: string;\n            };\n            [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: {\n                __serverMessage: string;\n            };\n            [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: {\n                __serverMessage: string;\n            };\n            [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: {\n                __serverMessage: string;\n            };\n            [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: {\n                __serverMessage: string;\n            };\n            [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: {\n                __serverMessage: string;\n            };\n            [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: {\n                __serverMessage: string;\n            };\n            [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: {\n                __serverMessage: string;\n            };\n            [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: {\n                __serverMessage: string;\n            };\n            [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE]: {\n                currentBlockHeight: bigint;\n                rewardsCompleteBlockHeight: bigint;\n                slot: bigint;\n            };\n            [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: {\n                __serverMessage: string;\n            };\n            [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: {\n                __serverMessage: string;\n            };\n            [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: {\n                contextSlot: bigint;\n            };\n            [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: {\n                numSlotsBehind?: number;\n            };\n            [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: Omit<\n                RpcSimulateTransactionResult,\n                'err'\n            >;\n            [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY]: {\n                slot: bigint;\n            };\n            [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: {\n                __serverMessage: string;\n            };\n            [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: {\n                __serverMessage: string;\n            };\n            [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: {\n                __serverMessage: string;\n            };\n            [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: {\n                byteLength: number;\n            };\n            [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: {\n                actualLength: number;\n            };\n            [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: {\n                actualLength: number;\n            };\n            [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: {\n                actualLength: number;\n            };\n            [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: {\n                value: string;\n            };\n            [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: {\n                error: unknown;\n                message: string;\n            };\n            [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: {\n                value: string;\n            };\n            [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: {\n                nonceAccountAddress: string;\n            };\n            [SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE]: {\n                expectedAddresses: readonly string[];\n                unexpectedAddresses: readonly string[];\n            };\n            [SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE]: {\n                actualLength: number;\n            };\n            [SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH]: {\n                missingRequiredSigners: readonly string[];\n                unexpectedSigners: readonly string[];\n            };\n            [SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH]: {\n                actualLength: number;\n            };\n            [SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED]: {\n                actualBytes: number;\n                maxBytes: number;\n            };\n            [SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH]: {\n                actualMessageFormat: number;\n                expectedMessageFormat: number;\n            };\n            [SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH]: {\n                actualLength: number;\n                specifiedLength: number;\n            };\n            [SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH]: {\n                numRequiredSignatures: number;\n                signatoryAddresses: readonly string[];\n                signaturesLength: number;\n            };\n            [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING]: {\n                addresses: readonly string[];\n            };\n            [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE]: {\n                signatoriesWithInvalidSignatures: readonly string[];\n                signatoriesWithMissingSignatures: readonly string[];\n            };\n            [SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION]: {\n                actualVersion: number;\n                expectedVersion: number;\n            };\n            [SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED]: {\n                unsupportedVersion: number;\n            };\n            [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: {\n                notificationName: string;\n            };\n            [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: {\n                errorEvent: Event;\n            };\n            [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: {\n                method: string;\n                params: readonly unknown[];\n            };\n            [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: {\n                argumentLabel: string;\n                keyPath: readonly (number | string | symbol)[];\n                methodName: string;\n                optionalPathLabel: string;\n                path?: string;\n                value: bigint;\n            };\n            [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: {\n                headers: Headers;\n                message: string;\n                statusCode: number;\n            };\n            [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: {\n                headers: readonly string[];\n            };\n            [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: {\n                address: string;\n            };\n            [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: {\n                address: string;\n            };\n            [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: {\n                address: string;\n            };\n            [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: {\n                address: string;\n            };\n            [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: {\n                address: string;\n            };\n            [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: {\n                address: string;\n            };\n            [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: {\n                address: string;\n            };\n            [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: {\n                address: string;\n            };\n            [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: {\n                address: string;\n            };\n            [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: {\n                key: CryptoKey;\n            };\n            [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: {\n                value: bigint;\n            };\n            [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: {\n                index: number;\n            };\n            [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: {\n                accountIndex: number;\n            };\n            [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: {\n                accountIndex: number;\n            };\n            [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: {\n                errorName: string;\n                transactionErrorContext?: unknown;\n            };\n            [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: {\n                expectedAddresses: readonly string[];\n                unexpectedAddresses: readonly string[];\n            };\n            [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: {\n                index: number;\n            };\n            [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: {\n                transactionSize: Bytes;\n                transactionSizeLimit: Bytes;\n            };\n            [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: {\n                lookupTableAddresses: readonly string[];\n            };\n            [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: {\n                highestKnownIndex: number;\n                highestRequestedIndex: number;\n                lookupTableAddress: string;\n            };\n            [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: {\n                index: number;\n            };\n            [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: {\n                unitsConsumed: number;\n            };\n            [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: {\n                programAddress: string;\n            };\n            [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: {\n                programAddress: string;\n            };\n            [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: {\n                numRequiredSignatures: number;\n                signaturesLength: number;\n                signerAddresses: readonly string[];\n            };\n            [SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE]: {\n                nonce: string;\n            };\n            [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: {\n                addresses: readonly string[];\n            };\n            [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED]: {\n                unsupportedVersion: number;\n            };\n            [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: {\n                actualVersion: number;\n            };\n        }\n    >\n>;\n\nexport function decodeEncodedContext(encodedContext: string): object {\n    const decodedUrlString = __NODEJS__ ? Buffer.from(encodedContext, 'base64').toString('utf8') : atob(encodedContext);\n    return Object.fromEntries(new URLSearchParams(decodedUrlString).entries());\n}\n\nfunction encodeValue(value: unknown): string {\n    if (Array.isArray(value)) {\n        const commaSeparatedValues = value.map(encodeValue).join('%2C%20' /* \", \" */);\n        return '%5B' /* \"[\" */ + commaSeparatedValues + /* \"]\" */ '%5D';\n    } else if (typeof value === 'bigint') {\n        return `${value}n`;\n    } else {\n        return encodeURIComponent(\n            String(\n                value != null && Object.getPrototypeOf(value) === null\n                    ? // Plain objects with no prototype don't have a `toString` method.\n                      // Convert them before stringifying them.\n                      { ...(value as object) }\n                    : value,\n            ),\n        );\n    }\n}\n\nfunction encodeObjectContextEntry([key, value]: [string, unknown]): `${typeof key}=${string}` {\n    return `${key}=${encodeValue(value)}`;\n}\n\nexport function encodeContextObject(context: object): string {\n    const searchParamsString = Object.entries(context).map(encodeObjectContextEntry).join('&');\n    return __NODEJS__ ? Buffer.from(searchParamsString, 'utf8').toString('base64') : btoa(searchParamsString);\n}\n","/* eslint-disable sort-keys-fix/sort-keys-fix */\n/**\n * To add a new error, follow the instructions at\n * https://github.com/anza-xyz/kit/tree/main/packages/errors#adding-a-new-error\n *\n * WARNING:\n *   - Don't change the meaning of an error message.\n */\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY,\n    SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_CONSTANT,\n    SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE,\n    SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND,\n    SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR,\n    SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SOLANA_ERROR__INVALID_NONCE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE,\n    SOLANA_ERROR__MALFORMED_BIGINT_STRING,\n    SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR,\n    SOLANA_ERROR__MALFORMED_NUMBER_STRING,\n    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED,\n    SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD,\n    SOLANA_ERROR__RPC__INTEGER_OVERFLOW,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID,\n    SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS,\n    SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER,\n    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,\n    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,\n    SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT,\n    SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING,\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES,\n    SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED,\n    SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP,\n    SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE,\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT,\n    SolanaErrorCode,\n} from './codes';\n\n/**\n * A map of every {@link SolanaError} code to the error message shown to developers in development\n * mode.\n */\nexport const SolanaErrorMessages: Readonly<{\n    // This type makes this data structure exhaustive with respect to `SolanaErrorCode`.\n    // TypeScript will fail to build this project if add an error code without a message.\n    [P in SolanaErrorCode]: string;\n}> = {\n    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: 'Account not found at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]:\n        'Not all accounts were decoded. Encoded accounts found at addresses: $addresses.',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: 'Expected decoded account at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: 'Failed to decode account data at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: 'Accounts not found at addresses: $addresses',\n    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]:\n        'Unable to find a viable program address bump seed.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: '$putativeAddress is not a base58-encoded address.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]:\n        'Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: 'The `CryptoKey` must be an `Ed25519` public key.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]:\n        '$putativeOffCurveAddress is not a base58-encoded off-curve address.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: 'Invalid seeds; point must fall off the Ed25519 curve.',\n    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]:\n        'Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].',\n    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]:\n        'A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.',\n    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]:\n        'The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.',\n    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]:\n        'Expected program derived address bump to be in the range [0, 255], got: $bump.',\n    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: 'Program address cannot end with PDA marker.',\n    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]:\n        'The network has progressed past the last block for which this transaction could have been committed.',\n    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]:\n        'Codec [$codecDescription] cannot decode empty byte arrays.',\n    [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]:\n        'Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.',\n    [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]:\n        'Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]:\n        'Encoder and decoder must either both be fixed-size or variable-size.',\n    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]:\n        'Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.',\n    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: 'Expected a fixed-size codec, got a variable-size one.',\n    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected a positive byte length, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: 'Expected a variable-size codec, got a fixed-size one.',\n    [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]:\n        'Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].',\n    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected $expected bytes, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__INVALID_CONSTANT]:\n        'Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].',\n    [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]:\n        'Invalid discriminated union variant. Expected one of [$variants], got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]:\n        'Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.',\n    [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]:\n        'Invalid literal union variant. Expected one of [$variants], got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]:\n        'Expected [$codecDescription] to have $expected items, got $actual.',\n    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: 'Invalid value $value for base $base with alphabet $alphabet.',\n    [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]:\n        'Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.',\n    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.',\n    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.',\n    [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]:\n        'Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].',\n    [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]:\n        'Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.',\n    [SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY]:\n        'This decoder expected a byte array of exactly $expectedLength bytes, but $numExcessBytes unexpected excess bytes remained after decoding. Are you sure that you have chosen the correct decoder for this data?',\n    [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: 'No random values implementation could be found.',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: 'instruction requires an uninitialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]:\n        'instruction tries to borrow reference for an account which is already borrowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'instruction left account with an outstanding borrowed reference',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]:\n        \"program other than the account's owner changed the size of the account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: 'account data too small for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: 'instruction expected an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]:\n        'An account does not have enough lamports to be rent-exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: 'Program arithmetic overflowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: 'Failed to serialize or deserialize account data: $encodedData',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]:\n        'Builtin programs must consume compute units',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: 'Cross-program invocation call depth too deep',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: 'Computational budget exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: 'custom program error: #$code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: 'instruction contains duplicate accounts',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]:\n        'instruction modifications of multiply-passed account differ',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: 'executable accounts must be rent exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: 'instruction changed executable accounts data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]:\n        'instruction changed the balance of an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: 'instruction changed executable bit of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]:\n        'instruction modified data of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]:\n        'instruction spent from the balance of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: 'generic instruction error',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: 'Provided owner is not allowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: 'Account is immutable',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: 'Incorrect authority provided',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: 'incorrect program id for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: 'insufficient funds for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: 'invalid account data for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: 'Invalid account owner',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: 'invalid program argument',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: 'program returned invalid error code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: 'invalid instruction data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: 'Failed to reallocate account data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: 'Provided seeds do not result in a valid address',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]:\n        'Accounts data allocations exceeded the maximum allowed per transaction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: 'Max accounts exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: 'Max instruction trace length exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]:\n        'Length of the seed is too long for address generation',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: 'An account required by the instruction is missing',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: 'missing required signature for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]:\n        'instruction illegally modified the program id of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: 'insufficient account keys for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]:\n        'Cross-program invocation with unauthorized signer or writable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]:\n        'Failed to create program execution environment',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: 'Program failed to compile',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: 'Program failed to complete',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: 'instruction modified data of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]:\n        'instruction changed the balance of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]:\n        'Cross-program invocation reentrancy not allowed for this instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: 'instruction modified rent epoch of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]:\n        'sum of account balances before and after instruction do not match',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: 'instruction requires an initialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: '',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: 'Unsupported program id',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: 'Unsupported sysvar',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND]: 'Invalid instruction plan kind: $kind.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN]: 'The provided instruction plan is empty.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN]:\n        'The provided transaction plan failed to execute. See the `transactionPlanResult` attribute and the `cause` error for more details.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN]:\n        'The provided message has insufficient capacity to accommodate the next instruction(s) in this plan. Expected at least $numBytesRequired free byte(s), got $numFreeBytes byte(s).',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND]: 'Invalid transaction plan kind: $kind.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE]:\n        'No more instructions to pack; the message packer has completed the instruction plan.',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: 'The instruction does not have any accounts.',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: 'The instruction does not have any data.',\n    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]:\n        'Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.',\n    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]:\n        'Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__INVALID_NONCE]:\n        'The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]:\n        'Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It ' +\n        'should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]:\n        'Invariant violation: This data publisher does not publish to the channel named ' +\n        '`$channelName`. Supported channels include $supportedChannelNames.',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]:\n        'Invariant violation: WebSocket message iterator state is corrupt; iterated without first ' +\n        'resolving existing message promise. It should be impossible to hit this error; please ' +\n        'file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]:\n        'Invariant violation: WebSocket message iterator is missing state storage. It should be ' +\n        'impossible to hit this error; please file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]:\n        'Invariant violation: Switch statement non-exhaustive. Received unexpected value ' +\n        '`$unexpectedValue`. It should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: 'JSON-RPC error: Internal JSON-RPC error ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: 'JSON-RPC error: Invalid method parameter(s) ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]:\n        'JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]:\n        'JSON-RPC error: The method does not exist / is not available ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]:\n        'JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE]:\n        'Epoch rewards period still active at slot $slot',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE]:\n        'Failed to query long-term storage; please try again',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: 'Minimum context slot has not been reached',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: 'Node is unhealthy; behind by $numSlotsBehind slots',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: 'No snapshot',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: 'Transaction simulation failed',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY]:\n        \"Rewards cannot be found because slot $slot is not the epoch boundary. This may be due to gap in the queried node's local ledger or long-term storage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]:\n        'Transaction history is not available from this node',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: 'Transaction signature length mismatch',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]:\n        'Transaction signature verification failure',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: '$__serverMessage',\n    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: 'Key pair bytes must be of length 64, got $byteLength.',\n    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]:\n        'Expected private key bytes with length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]:\n        'Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]:\n        'The provided private key does not match the provided public key.',\n    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.',\n    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: 'Lamports value must be in the range [0, 2e64-1]',\n    [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: '`$value` cannot be parsed as a `BigInt`',\n    [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: '$message',\n    [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: '`$value` cannot be parsed as a `Number`',\n    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: 'No nonce account could be found at address `$nonceAccountAddress`',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH]:\n        'Expected base58 encoded application domain to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE]:\n        'Attempted to sign an offchain message with an address that is not a signer for it',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded application domain string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH]:\n        'The signer addresses in this offchain message envelope do not match the list of ' +\n        'required signers in the message preamble. These unexpected signers were present in the ' +\n        'envelope: `[$unexpectedSigners]`. These required signers were missing from the envelope ' +\n        '`[$missingSigners]`.',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED]:\n        'The message body provided has a byte-length of $actualBytes. The maximum allowable ' +\n        'byte-length is $maxBytes',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH]:\n        'Expected message format $expectedMessageFormat, got $actualMessageFormat',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH]:\n        'The message length specified in the message preamble is $specifiedLength bytes. The actual length of the message is $actualLength bytes.',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY]: 'Offchain message content must be non-empty',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO]:\n        'Offchain message must specify the address of at least one required signer',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO]:\n        'Offchain message envelope must reserve space for at least one signature',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH]:\n        'The offchain message preamble specifies $numRequiredSignatures required signature(s), got $signaturesLength.',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED]:\n        'The signatories of this offchain message must be listed in lexicographical order',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE]:\n        'An address must be listed no more than once among the signatories of an offchain message',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING]:\n        'Offchain message is missing signatures for addresses: $addresses.',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE]:\n        'Offchain message signature verification failed. Signature mismatch for required ' +\n        'signatories [$signatoriesWithInvalidSignatures]. Missing signatures for signatories ' +\n        '[$signatoriesWithMissingSignatures]',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE]:\n        'The message body provided contains characters whose codes fall outside the allowed ' +\n        'range. In order to ensure clear-signing compatiblity with hardware wallets, the message ' +\n        'may only contain line feeds and characters in the range [\\\\x20-\\\\x7e].',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION]:\n        'Expected offchain message version $expectedVersion. Got $actualVersion.',\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED]:\n        'This version of Kit does not support decoding offchain messages with version ' +\n        '$unsupportedVersion. The current max supported version is 0.',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]:\n        \"The notification name must end in 'Notifications' and the API must supply a \" +\n        \"subscription plan creator function for the notification '$notificationName'.\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]:\n        'WebSocket was closed before payload could be added to the send buffer',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: 'WebSocket connection closed',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: 'WebSocket failed to connect',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]:\n        'Failed to obtain a subscription id from the server',\n    [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: 'Could not find an API plan for RPC method: `$method`',\n    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]:\n        'The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was ' +\n        '`$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds ' +\n        '`Number.MAX_SAFE_INTEGER`.',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: 'HTTP error ($statusCode): $message',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]:\n        'HTTP header(s) forbidden: $headers. Learn more at ' +\n        'https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.',\n    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]:\n        'Multiple distinct signers were identified for address `$address`. Please ensure that ' +\n        'you are using the same signer instance for each address.',\n    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]:\n        'The provided value does not implement the `KeyPairSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]:\n        'The provided value does not implement the `MessageModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]:\n        'The provided value does not implement the `MessagePartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]:\n        'The provided value does not implement any of the `MessageSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]:\n        'The provided value does not implement the `TransactionModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]:\n        'The provided value does not implement the `TransactionPartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]:\n        'The provided value does not implement the `TransactionSendingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]:\n        'The provided value does not implement any of the `TransactionSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]:\n        'More than one `TransactionSendingSigner` was identified.',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]:\n        'No `TransactionSendingSigner` was identified. Please provide a valid ' +\n        '`TransactionWithSingleSendingSigner` transaction.',\n    [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]:\n        'Wallet account signers do not support signing multiple messages/transactions in a single operation',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: 'Cannot export a non-extractable key.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: 'No digest implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]:\n        'Cryptographic operations are only allowed in secure browser contexts. Read more ' +\n        'here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]:\n        'This runtime does not support the generation of Ed25519 key pairs.\\n\\nInstall ' +\n        '@solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in ' +\n        'environments that do not support Ed25519.\\n\\nFor a list of runtimes that ' +\n        'currently support Ed25519 operations, visit ' +\n        'https://github.com/WICG/webcrypto-secure-curves/issues/20.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]:\n        'No signature verification implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: 'No key generation implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: 'No signing implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: 'No key export implementation could be found.',\n    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]:\n        'Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'Transaction processing left an account with an outstanding borrowed reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: 'Account in use',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: 'Account loaded twice',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]:\n        'Attempt to debit an account but found no record of a prior credit.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]:\n        \"Transaction loads an address table account that doesn't exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: 'This transaction has already been processed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: 'Blockhash not found',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: 'Loader call chain is too deep',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]:\n        'Transactions are currently disabled due to cluster maintenance',\n    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]:\n        'Transaction contains a duplicate instruction ($index) that is not allowed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: 'Insufficient funds for fee',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]:\n        'Transaction results in an account ($accountIndex) with insufficient funds for rent',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: 'This account may not be used to pay transaction fees',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: 'Transaction contains an invalid account reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]:\n        'Transaction loads an address table account with invalid data',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]:\n        'Transaction address table lookup uses an invalid index',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]:\n        'Transaction loads an address table account with an invalid owner',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]:\n        'LoadedAccountsDataSizeLimit set for transaction must be greater than 0.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]:\n        'This program may not be used for executing instructions',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]:\n        'Transaction leaves an account with a lower balance than rent-exempt minimum',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]:\n        'Transaction loads a writable account that cannot be written',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]:\n        'Transaction exceeded max loaded accounts data size cap',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]:\n        'Transaction requires a fee but has no signature present',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: 'Attempt to load a program that does not exist',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]:\n        'Execution of the program referenced by account at index $accountIndex is temporarily restricted.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: 'ResanitizationNeeded',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: 'Transaction failed to sanitize accounts offsets correctly',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: 'Transaction did not pass signature verification',\n    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: 'Transaction locked too many accounts',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]:\n        'Sum of account balances before and after transaction do not match',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: 'The transaction failed with the error `$errorName`',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: 'Transaction version is unsupported',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]:\n        'Transaction would exceed account data limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]:\n        'Transaction would exceed total account data limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]:\n        'Transaction would exceed max account limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]:\n        'Transaction would exceed max Block Cost Limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: 'Transaction would exceed max Vote Cost Limit',\n    [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]:\n        'Attempted to sign a transaction with an address that is not a signer for it',\n    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: 'Transaction is missing an address at index: $index.',\n    [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]:\n        'Transaction has no expected signers therefore it cannot be encoded',\n    [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]:\n        'Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: 'Transaction does not have a blockhash lifetime',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: 'Transaction is not a durable nonce transaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]:\n        'Contents of these address lookup tables unknown: $lookupTableAddresses',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]:\n        'Lookup of address at index $highestRequestedIndex failed for lookup table ' +\n        '`$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table ' +\n        'may have been extended since its contents were retrieved',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: 'No fee payer set in CompiledTransaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]:\n        'Could not find program address at index $index',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]:\n        'Failed to estimate the compute unit consumption for this transaction message. This is ' +\n        'likely because simulating the transaction failed. Inspect the `cause` property of this ' +\n        'error to learn more',\n    [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]:\n        'Transaction failed when it was simulated in order to estimate the compute unit consumption. ' +\n        'The compute unit estimate provided is for a transaction that failed when simulated and may not ' +\n        'be representative of the compute units this transaction would consume if successful. Inspect the ' +\n        '`cause` property of this error to learn more',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: 'Transaction is missing a fee payer.',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]:\n        \"Could not determine this transaction's signature. Make sure that the transaction has \" +\n        'been signed by its fee payer.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]:\n        'Transaction first instruction is not advance nonce account instruction.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]:\n        'Transaction with no instructions cannot be durable nonce transaction.',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]:\n        'This transaction includes an address (`$programAddress`) which is both ' +\n        'invoked and set as the fee payer. Program addresses may not pay fees',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]:\n        'This transaction includes an address (`$programAddress`) which is both invoked and ' +\n        'marked writable. Program addresses may not be writable',\n    [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]:\n        'The transaction message expected the transaction to have $numRequiredSignatures signatures, got $signaturesLength.',\n    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: 'Transaction is missing signatures for addresses: $addresses.',\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]:\n        'Transaction version must be in the range [0, 127]. `$actualVersion` given',\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED]:\n        'This version of Kit does not support decoding transactions with version $unsupportedVersion. The current max supported version is 0.',\n    [SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE]:\n        'The transaction has a durable nonce lifetime (with nonce `$nonce`), but the nonce account address is in a lookup table. The lifetime constraint cannot be constructed without fetching the lookup tables for the transaction.',\n};\n","import { SolanaErrorCode } from './codes';\nimport { encodeContextObject } from './context';\nimport { SolanaErrorMessages } from './messages';\n\nconst enum StateType {\n    EscapeSequence,\n    Text,\n    Variable,\n}\ntype State = Readonly<{\n    [START_INDEX]: number;\n    [TYPE]: StateType;\n}>;\nconst START_INDEX = 'i';\nconst TYPE = 't';\n\nexport function getHumanReadableErrorMessage<TErrorCode extends SolanaErrorCode>(\n    code: TErrorCode,\n    context: object = {},\n): string {\n    const messageFormatString = SolanaErrorMessages[code];\n    if (messageFormatString.length === 0) {\n        return '';\n    }\n    let state: State;\n    function commitStateUpTo(endIndex?: number) {\n        if (state[TYPE] === StateType.Variable) {\n            const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n\n            fragments.push(\n                variableName in context\n                    ? // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                      `${context[variableName as keyof typeof context]}`\n                    : `$${variableName}`,\n            );\n        } else if (state[TYPE] === StateType.Text) {\n            fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n        }\n    }\n    const fragments: string[] = [];\n    messageFormatString.split('').forEach((char, ii) => {\n        if (ii === 0) {\n            state = {\n                [START_INDEX]: 0,\n                [TYPE]:\n                    messageFormatString[0] === '\\\\'\n                        ? StateType.EscapeSequence\n                        : messageFormatString[0] === '$'\n                          ? StateType.Variable\n                          : StateType.Text,\n            };\n            return;\n        }\n        let nextState;\n        switch (state[TYPE]) {\n            case StateType.EscapeSequence:\n                nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                break;\n            case StateType.Text:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                }\n                break;\n            case StateType.Variable:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                } else if (!char.match(/\\w/)) {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                }\n                break;\n        }\n        if (nextState) {\n            if (state !== nextState) {\n                commitStateUpTo(ii);\n            }\n            state = nextState;\n        }\n    });\n    commitStateUpTo();\n    return fragments.join('');\n}\n\nexport function getErrorMessage<TErrorCode extends SolanaErrorCode>(\n    code: TErrorCode,\n    context: Record<string, unknown> = {},\n): string {\n    if (process.env.NODE_ENV !== \"production\") {\n        return getHumanReadableErrorMessage(code, context);\n    } else {\n        let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \\`npx @solana/errors decode -- ${code}`;\n        if (Object.keys(context).length) {\n            /**\n             * DANGER: Be sure that the shell command is escaped in such a way that makes it\n             *         impossible for someone to craft malicious context values that would result in\n             *         an exploit against anyone who bindly copy/pastes it into their terminal.\n             */\n            decodingAdviceMessage += ` '${encodeContextObject(context)}'`;\n        }\n        return `${decodingAdviceMessage}\\``;\n    }\n}\n","import { SolanaErrorCode, SolanaErrorCodeWithCause } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { getErrorMessage } from './message-formatter';\n\n/**\n * A type guard that returns `true` if the input is a {@link SolanaError}, optionally with a\n * particular error code.\n *\n * When the `code` argument is supplied and the input is a {@link SolanaError}, TypeScript will\n * refine the error's {@link SolanaError#context | `context`} property to the type associated with\n * that error code. You can use that context to render useful error messages, or to make\n * context-aware decisions that help your application to recover from the error.\n *\n * @example\n * ```ts\n * import {\n *     SOLANA_ERROR__TRANSACTION__MISSING_SIGNATURE,\n *     SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n *     isSolanaError,\n * } from '@solana/errors';\n * import { assertIsFullySignedTransaction, getSignatureFromTransaction } from '@solana/transactions';\n *\n * try {\n *     const transactionSignature = getSignatureFromTransaction(tx);\n *     assertIsFullySignedTransaction(tx);\n *     /* ... *\\/\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n *         displayError(\n *             \"We can't send this transaction without signatures for these addresses:\\n- %s\",\n *             // The type of the `context` object is now refined to contain `addresses`.\n *             e.context.addresses.join('\\n- '),\n *         );\n *         return;\n *     } else if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING)) {\n *         if (!tx.feePayer) {\n *             displayError('Choose a fee payer for this transaction before sending it');\n *         } else {\n *             displayError('The fee payer still needs to sign for this transaction');\n *         }\n *         return;\n *     }\n *     throw e;\n * }\n * ```\n */\nexport function isSolanaError<TErrorCode extends SolanaErrorCode>(\n    e: unknown,\n    /**\n     * When supplied, this function will require that the input is a {@link SolanaError} _and_ that\n     * its error code is exactly this value.\n     */\n    code?: TErrorCode,\n): e is SolanaError<TErrorCode> {\n    const isSolanaError = e instanceof Error && e.name === 'SolanaError';\n    if (isSolanaError) {\n        if (code !== undefined) {\n            return (e as SolanaError<TErrorCode>).context.__code === code;\n        }\n        return true;\n    }\n    return false;\n}\n\ntype SolanaErrorCodedContext = {\n    [P in SolanaErrorCode]: Readonly<{\n        __code: P;\n    }> &\n        (SolanaErrorContext[P] extends undefined ? object : SolanaErrorContext[P]);\n};\n\n/**\n * Encapsulates an error's stacktrace, a Solana-specific numeric code that indicates what went\n * wrong, and optional context if the type of error indicated by the code supports it.\n */\nexport class SolanaError<TErrorCode extends SolanaErrorCode = SolanaErrorCode> extends Error {\n    /**\n     * Indicates the root cause of this {@link SolanaError}, if any.\n     *\n     * For example, a transaction error might have an instruction error as its root cause. In this\n     * case, you will be able to access the instruction error on the transaction error as `cause`.\n     */\n    readonly cause?: TErrorCode extends SolanaErrorCodeWithCause ? SolanaError : unknown = this.cause;\n    /**\n     * Contains context that can assist in understanding or recovering from a {@link SolanaError}.\n     */\n    readonly context: SolanaErrorCodedContext[TErrorCode];\n    constructor(\n        ...[code, contextAndErrorOptions]: SolanaErrorContext[TErrorCode] extends undefined\n            ? [code: TErrorCode, errorOptions?: ErrorOptions | undefined]\n            : [code: TErrorCode, contextAndErrorOptions: SolanaErrorContext[TErrorCode] & (ErrorOptions | undefined)]\n    ) {\n        let context: SolanaErrorContext[TErrorCode] | undefined;\n        let errorOptions: ErrorOptions | undefined;\n        if (contextAndErrorOptions) {\n            Object.entries(Object.getOwnPropertyDescriptors(contextAndErrorOptions)).forEach(([name, descriptor]) => {\n                // If the `ErrorOptions` type ever changes, update this code.\n                if (name === 'cause') {\n                    errorOptions = { cause: descriptor.value };\n                } else {\n                    if (context === undefined) {\n                        context = {\n                            __code: code,\n                        } as unknown as SolanaErrorContext[TErrorCode];\n                    }\n                    Object.defineProperty(context, name, descriptor);\n                }\n            });\n        }\n        const message = getErrorMessage(code, context);\n        super(message, errorOptions);\n        this.context = Object.freeze(\n            context === undefined\n                ? {\n                      __code: code,\n                  }\n                : context,\n        ) as SolanaErrorCodedContext[TErrorCode];\n        // This is necessary so that `isSolanaError()` can identify a `SolanaError` without having\n        // to import the class for use in an `instanceof` check.\n        this.name = 'SolanaError';\n    }\n}\n","export function safeCaptureStackTrace(...args: Parameters<typeof Error.captureStackTrace>): void {\n    if ('captureStackTrace' in Error && typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(...args);\n    }\n}\n","import { SolanaErrorCode } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\n\ntype Config = Readonly<{\n    /**\n     * Oh, hello. You might wonder what in tarnation is going on here. Allow us to explain.\n     *\n     * One of the goals of `@solana/errors` is to allow errors that are not interesting to your\n     * application to shake out of your app bundle in production. This means that we must never\n     * export large hardcoded maps of error codes/messages.\n     *\n     * Unfortunately, where instruction and transaction errors from the RPC are concerned, we have\n     * no choice but to keep a map between the RPC `rpcEnumError` enum name and its corresponding\n     * `SolanaError` code. In the interest of implementing that map in as few bytes of source code\n     * as possible, we do the following:\n     *\n     *   1. Reserve a block of sequential error codes for the enum in question\n     *   2. Hardcode the list of enum names in that same order\n     *   3. Match the enum error name from the RPC with its index in that list, and reconstruct the\n     *      `SolanaError` code by adding the `errorCodeBaseOffset` to that index\n     */\n    errorCodeBaseOffset: number;\n    getErrorContext: (\n        errorCode: SolanaErrorCode,\n        rpcErrorName: string,\n        rpcErrorContext?: unknown,\n    ) => SolanaErrorContext[SolanaErrorCode];\n    orderedErrorNames: string[];\n    rpcEnumError: string | { [key: string]: unknown };\n}>;\n\nexport function getSolanaErrorFromRpcError(\n    { errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }: Config,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    constructorOpt: Function,\n): SolanaError {\n    let rpcErrorName;\n    let rpcErrorContext;\n    if (typeof rpcEnumError === 'string') {\n        rpcErrorName = rpcEnumError;\n    } else {\n        rpcErrorName = Object.keys(rpcEnumError)[0];\n        rpcErrorContext = rpcEnumError[rpcErrorName];\n    }\n    const codeOffset = orderedErrorNames.indexOf(rpcErrorName);\n    const errorCode = (errorCodeBaseOffset + codeOffset) as SolanaErrorCode;\n    const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);\n    const err = new SolanaError(errorCode, errorContext);\n    safeCaptureStackTrace(err, constructorOpt);\n    return err;\n}\n","import { SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM, SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN } from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/solana-sdk/blob/master/instruction-error/src/lib.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'GenericError',\n    'InvalidArgument',\n    'InvalidInstructionData',\n    'InvalidAccountData',\n    'AccountDataTooSmall',\n    'InsufficientFunds',\n    'IncorrectProgramId',\n    'MissingRequiredSignature',\n    'AccountAlreadyInitialized',\n    'UninitializedAccount',\n    'UnbalancedInstruction',\n    'ModifiedProgramId',\n    'ExternalAccountLamportSpend',\n    'ExternalAccountDataModified',\n    'ReadonlyLamportChange',\n    'ReadonlyDataModified',\n    'DuplicateAccountIndex',\n    'ExecutableModified',\n    'RentEpochModified',\n    'NotEnoughAccountKeys',\n    'AccountDataSizeChanged',\n    'AccountNotExecutable',\n    'AccountBorrowFailed',\n    'AccountBorrowOutstanding',\n    'DuplicateAccountOutOfSync',\n    'Custom',\n    'InvalidError',\n    'ExecutableDataModified',\n    'ExecutableLamportChange',\n    'ExecutableAccountNotRentExempt',\n    'UnsupportedProgramId',\n    'CallDepth',\n    'MissingAccount',\n    'ReentrancyNotAllowed',\n    'MaxSeedLengthExceeded',\n    'InvalidSeeds',\n    'InvalidRealloc',\n    'ComputationalBudgetExceeded',\n    'PrivilegeEscalation',\n    'ProgramEnvironmentSetupFailure',\n    'ProgramFailedToComplete',\n    'ProgramFailedToCompile',\n    'Immutable',\n    'IncorrectAuthority',\n    'BorshIoError',\n    'AccountNotRentExempt',\n    'InvalidAccountOwner',\n    'ArithmeticOverflow',\n    'UnsupportedSysvar',\n    'IllegalOwner',\n    'MaxAccountsDataAllocationsExceeded',\n    'MaxAccountsExceeded',\n    'MaxInstructionTraceLengthExceeded',\n    'BuiltinProgramsMustConsumeComputeUnits',\n];\n\nexport function getSolanaErrorFromInstructionError(\n    /**\n     * The index of the instruction inside the transaction.\n     */\n    index: bigint | number,\n    instructionError: string | { [key: string]: unknown },\n): SolanaError {\n    const numberIndex = Number(index);\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 4615001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        index: numberIndex,\n                        ...(rpcErrorContext !== undefined ? { instructionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {\n                    return {\n                        code: Number(rpcErrorContext as bigint | number),\n                        index: numberIndex,\n                    };\n                }\n                return { index: numberIndex };\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: instructionError,\n        },\n        getSolanaErrorFromInstructionError,\n    );\n}\n","import {\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n} from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromInstructionError } from './instruction-error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\n/**\n * How to add an error when an entry is added to the RPC `TransactionError` enum:\n *\n *   1. Follow the instructions in `./codes.ts` to add a corresponding Solana error code\n *   2. Add the `TransactionError` enum name in the same order as it appears in `./codes.ts`\n *   3. Add the new error name/code mapping to `./__tests__/transaction-error-test.ts`\n */\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'AccountInUse',\n    'AccountLoadedTwice',\n    'AccountNotFound',\n    'ProgramAccountNotFound',\n    'InsufficientFundsForFee',\n    'InvalidAccountForFee',\n    'AlreadyProcessed',\n    'BlockhashNotFound',\n    // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`\n    'CallChainTooDeep',\n    'MissingSignatureForFee',\n    'InvalidAccountIndex',\n    'SignatureFailure',\n    'InvalidProgramForExecution',\n    'SanitizeFailure',\n    'ClusterMaintenance',\n    'AccountBorrowOutstanding',\n    'WouldExceedMaxBlockCostLimit',\n    'UnsupportedVersion',\n    'InvalidWritableAccount',\n    'WouldExceedMaxAccountCostLimit',\n    'WouldExceedAccountDataBlockLimit',\n    'TooManyAccountLocks',\n    'AddressLookupTableNotFound',\n    'InvalidAddressLookupTableOwner',\n    'InvalidAddressLookupTableData',\n    'InvalidAddressLookupTableIndex',\n    'InvalidRentPayingAccount',\n    'WouldExceedMaxVoteCostLimit',\n    'WouldExceedAccountDataTotalLimit',\n    'DuplicateInstruction',\n    'InsufficientFundsForRent',\n    'MaxLoadedAccountsDataSizeExceeded',\n    'InvalidLoadedAccountsDataSizeLimit',\n    'ResanitizationNeeded',\n    'ProgramExecutionTemporarilyRestricted',\n    'UnbalancedTransaction',\n];\n\nexport function getSolanaErrorFromTransactionError(transactionError: string | { [key: string]: unknown }): SolanaError {\n    if (typeof transactionError === 'object' && 'InstructionError' in transactionError) {\n        return getSolanaErrorFromInstructionError(\n            ...(transactionError.InstructionError as Parameters<typeof getSolanaErrorFromInstructionError>),\n        );\n    }\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 7050001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        ...(rpcErrorContext !== undefined ? { transactionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {\n                    return {\n                        index: Number(rpcErrorContext as bigint | number),\n                    };\n                } else if (\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT ||\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n                ) {\n                    return {\n                        accountIndex: Number((rpcErrorContext as { account_index: bigint | number }).account_index),\n                    };\n                }\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: transactionError,\n        },\n        getSolanaErrorFromTransactionError,\n    );\n}\n","import {\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR,\n    SolanaErrorCode,\n} from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\nimport { getSolanaErrorFromTransactionError } from './transaction-error';\n\ninterface RpcErrorResponse {\n    code: bigint | number;\n    data?: unknown;\n    message: string;\n}\n\ntype TransactionError = string | { [key: string]: unknown };\n\n/**\n * Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-types/src/response.rs\n * @hidden\n */\nexport interface RpcSimulateTransactionResult {\n    accounts:\n        | ({\n              data:\n                  | string // LegacyBinary\n                  | {\n                        // Json\n                        parsed: unknown;\n                        program: string;\n                        space: number;\n                    }\n                  // Binary\n                  | [encodedBytes: string, encoding: 'base58' | 'base64' | 'base64+zstd' | 'binary' | 'jsonParsed'];\n              executable: boolean;\n              lamports: number;\n              owner: string;\n              rentEpoch: number;\n              space?: number;\n          } | null)[]\n        | null;\n    err: TransactionError | null;\n    // Enabled by `enable_cpi_recording`\n    innerInstructions?:\n        | {\n              index: number;\n              instructions: (\n                  | {\n                        // Compiled\n                        accounts: number[];\n                        data: string;\n                        programIdIndex: number;\n                        stackHeight?: number;\n                    }\n                  | {\n                        // Parsed\n                        parsed: unknown;\n                        program: string;\n                        programId: string;\n                        stackHeight?: number;\n                    }\n                  | {\n                        // PartiallyDecoded\n                        accounts: string[];\n                        data: string;\n                        programId: string;\n                        stackHeight?: number;\n                    }\n              )[];\n          }[]\n        | null;\n    loadedAccountsDataSize: number | null;\n    logs: string[] | null;\n    replacementBlockhash: string | null;\n    returnData: {\n        data: [string, 'base64'];\n        programId: string;\n    } | null;\n    unitsConsumed: bigint | null;\n}\n\nexport function getSolanaErrorFromJsonRpcError(putativeErrorResponse: unknown): SolanaError {\n    let out: SolanaError;\n    if (isRpcErrorResponse(putativeErrorResponse)) {\n        const { code: rawCode, data, message } = putativeErrorResponse;\n        const code = Number(rawCode);\n        if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {\n            const { err, ...preflightErrorContext } = data as RpcSimulateTransactionResult;\n            const causeObject = err ? { cause: getSolanaErrorFromTransactionError(err) } : null;\n            out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {\n                ...preflightErrorContext,\n                ...causeObject,\n            });\n        } else {\n            let errorContext;\n            switch (code) {\n                case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:\n                case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:\n                case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:\n                case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:\n                case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:\n                    // The server supplies no structured data, but rather a pre-formatted message. Put\n                    // the server message in `context` so as not to completely lose the data. The long\n                    // term fix for this is to add data to the server responses and modify the\n                    // messages in `@solana/errors` to be actual format strings.\n                    errorContext = { __serverMessage: message };\n                    break;\n                default:\n                    if (typeof data === 'object' && !Array.isArray(data)) {\n                        errorContext = data;\n                    }\n            }\n            out = new SolanaError(code as SolanaErrorCode, errorContext as SolanaErrorContext[SolanaErrorCode]);\n        }\n    } else {\n        const message =\n            typeof putativeErrorResponse === 'object' &&\n            putativeErrorResponse !== null &&\n            'message' in putativeErrorResponse &&\n            typeof putativeErrorResponse.message === 'string'\n                ? putativeErrorResponse.message\n                : 'Malformed JSON-RPC error with no message attribute';\n        out = new SolanaError(SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR, { error: putativeErrorResponse, message });\n    }\n    safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);\n    return out;\n}\n\nfunction isRpcErrorResponse(value: unknown): value is RpcErrorResponse {\n    return (\n        typeof value === 'object' &&\n        value !== null &&\n        'code' in value &&\n        'message' in value &&\n        (typeof value.code === 'number' || typeof value.code === 'bigint') &&\n        typeof value.message === 'string'\n    );\n}\n"],"names":["isSolanaError","ORDERED_ERROR_NAMES"],"mappings":"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"}},
    {"offset": {"line": 1448, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/instructions/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/instructions/src/instruction.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/instructions/src/roles.ts"],"sourcesContent":["import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { AccountLookupMeta, AccountMeta } from './accounts';\n\n/**\n * An instruction destined for a given program.\n *\n * @example\n * ```ts\n * type StakeProgramInstruction = Instruction<'StakeConfig11111111111111111111111111111111'>;\n * ```\n */\nexport interface Instruction<\n    TProgramAddress extends string = string,\n    TAccounts extends readonly (AccountLookupMeta | AccountMeta)[] = readonly (AccountLookupMeta | AccountMeta)[],\n> {\n    readonly accounts?: TAccounts;\n    readonly data?: ReadonlyUint8Array;\n    readonly programAddress: Address<TProgramAddress>;\n}\n\n/**\n * An instruction that loads certain accounts.\n *\n * @example\n * ```ts\n * type InstructionWithTwoAccounts = InstructionWithAccounts<\n *     [\n *         WritableAccount, // First account\n *         RentSysvar, // Second account\n *     ]\n * >;\n * ```\n */\nexport interface InstructionWithAccounts<TAccounts extends readonly (AccountLookupMeta | AccountMeta)[]>\n    extends Instruction {\n    readonly accounts: TAccounts;\n}\n\nexport function isInstructionForProgram<TProgramAddress extends string, TInstruction extends Instruction>(\n    instruction: TInstruction,\n    programAddress: Address<TProgramAddress>,\n): instruction is TInstruction & { programAddress: Address<TProgramAddress> } {\n    return instruction.programAddress === programAddress;\n}\n\nexport function assertIsInstructionForProgram<TProgramAddress extends string, TInstruction extends Instruction>(\n    instruction: TInstruction,\n    programAddress: Address<TProgramAddress>,\n): asserts instruction is TInstruction & { programAddress: Address<TProgramAddress> } {\n    if (instruction.programAddress !== programAddress) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH, {\n            actualProgramAddress: instruction.programAddress,\n            expectedProgramAddress: programAddress,\n        });\n    }\n}\n\nexport function isInstructionWithAccounts<\n    TAccounts extends readonly (AccountLookupMeta | AccountMeta)[] = readonly (AccountLookupMeta | AccountMeta)[],\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): instruction is InstructionWithAccounts<TAccounts> & TInstruction {\n    return instruction.accounts !== undefined;\n}\n\nexport function assertIsInstructionWithAccounts<\n    TAccounts extends readonly (AccountLookupMeta | AccountMeta)[] = readonly (AccountLookupMeta | AccountMeta)[],\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): asserts instruction is InstructionWithAccounts<TAccounts> & TInstruction {\n    if (instruction.accounts === undefined) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS, {\n            data: instruction.data,\n            programAddress: instruction.programAddress,\n        });\n    }\n}\n\n/**\n * An instruction whose data conforms to a certain type.\n *\n * This is most useful when you have a branded `Uint8Array` that represents a particular\n * instruction's data.\n *\n * @example A type for the \\`AdvanceNonce\\` instruction of the System program\n * ```ts\n * type AdvanceNonceAccountInstruction<\n *     TNonceAccountAddress extends string = string,\n *     TNonceAuthorityAddress extends string = string,\n * > = Instruction<'11111111111111111111111111111111'> &\n *     InstructionWithAccounts<\n *         [\n *             WritableAccount<TNonceAccountAddress>,\n *             ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n *             ReadonlySignerAccount<TNonceAuthorityAddress>,\n *         ]\n *     > &\n *     InstructionWithData<AdvanceNonceAccountInstructionData>;\n * ```\n */\nexport interface InstructionWithData<TData extends ReadonlyUint8Array> extends Instruction {\n    readonly data: TData;\n}\n\nexport function isInstructionWithData<\n    TData extends ReadonlyUint8Array = ReadonlyUint8Array,\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): instruction is InstructionWithData<TData> & TInstruction {\n    return instruction.data !== undefined;\n}\n\nexport function assertIsInstructionWithData<\n    TData extends ReadonlyUint8Array = ReadonlyUint8Array,\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): asserts instruction is InstructionWithData<TData> & TInstruction {\n    if (instruction.data === undefined) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA, {\n            accountAddresses: instruction.accounts?.map(a => a.address),\n            programAddress: instruction.programAddress,\n        });\n    }\n}\n","/**\n * Describes the purpose for which an account participates in a transaction.\n *\n * Every account that participates in a transaction can be read from, but only ones that you mark as\n * writable may be written to, and only ones that you indicate must sign the transaction will gain\n * the privileges associated with signers at runtime.\n *\n * |                               | `isSigner` | `isWritable` |\n * | ----------------------------- | ---------- | ------------ |\n * | `AccountRole.READONLY`        | &#x274c;   | &#x274c;     |\n * | `AccountRole.WRITABLE`        | &#x274c;   | &#x2705;     |\n * | `AccountRole.READONLY_SIGNER` | &#x2705;   | &#x274c;     |\n * | `AccountRole.WRITABLE_SIGNER` | &#x2705;   | &#x2705;     |\n */\nexport enum AccountRole {\n    // Bitflag guide: is signer ⌄⌄ is writable\n    WRITABLE_SIGNER = /* 3 */ 0b11, // prettier-ignore\n    READONLY_SIGNER = /* 2 */ 0b10, // prettier-ignore\n    WRITABLE =        /* 1 */ 0b01, // prettier-ignore\n    READONLY =        /* 0 */ 0b00, // prettier-ignore\n}\n\n// Quick primer on bitwise operations: https://stackoverflow.com/a/1436448/802047\nconst IS_SIGNER_BITMASK = 0b10;\nconst IS_WRITABLE_BITMASK = 0b01;\n\n/**\n * @returns An {@link AccountRole} representing the non-signer variant of the supplied role.\n */\nexport function downgradeRoleToNonSigner(role: AccountRole.READONLY_SIGNER): AccountRole.READONLY;\nexport function downgradeRoleToNonSigner(role: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole {\n    return role & ~IS_SIGNER_BITMASK;\n}\n\n/**\n * @returns An {@link AccountRole} representing the read-only variant of the supplied role.\n */\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE): AccountRole.READONLY;\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE_SIGNER): AccountRole.READONLY_SIGNER;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole {\n    return role & ~IS_WRITABLE_BITMASK;\n}\n\n/**\n * Returns `true` if the {@link AccountRole} given represents that of a signer. Also refines the\n * TypeScript type of the supplied role.\n */\nexport function isSignerRole(role: AccountRole): role is AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER {\n    return role >= AccountRole.READONLY_SIGNER;\n}\n\n/**\n * Returns `true` if the {@link AccountRole} given represents that of a writable account. Also\n * refines the TypeScript type of the supplied role.\n */\nexport function isWritableRole(role: AccountRole): role is AccountRole.WRITABLE | AccountRole.WRITABLE_SIGNER {\n    return (role & IS_WRITABLE_BITMASK) !== 0;\n}\n\n/**\n * Given two {@link AccountRole | AccountRoles}, will return the {@link AccountRole} that grants the\n * highest privileges of both.\n *\n * @example\n * ```ts\n * // Returns `AccountRole.WRITABLE_SIGNER`\n * mergeRoles(AccountRole.READONLY_SIGNER, AccountRole.WRITABLE);\n * ```\n */\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE_SIGNER, roleB: AccountRole): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.READONLY_SIGNER): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY, roleB: AccountRole.READONLY): AccountRole.READONLY; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole {\n    return roleA | roleB;\n}\n\n/**\n * @returns An {@link AccountRole} representing the signer variant of the supplied role.\n */\nexport function upgradeRoleToSigner(role: AccountRole.READONLY): AccountRole.READONLY_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole {\n    return role | IS_SIGNER_BITMASK;\n}\n\n/**\n * @returns An {@link AccountRole} representing the writable variant of the supplied role.\n */\nexport function upgradeRoleToWritable(role: AccountRole.READONLY): AccountRole.WRITABLE;\nexport function upgradeRoleToWritable(role: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole {\n    return role | IS_WRITABLE_BITMASK;\n}\n"],"names":["AccountRole"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CO,SAAS,uBAAA,CACZ,WAAA,EACA,cAAA,EAC0E;IAC1E,OAAO,YAAY,cAAA,KAAmB,cAAA;AAC1C;AAEO,SAAS,6BAAA,CACZ,WAAA,EACA,cAAA,EACkF;IAClF,IAAI,WAAA,CAAY,cAAA,KAAmB,cAAA,EAAgB;QAC/C,MAAM,IAAI,iLAAA,CAAY,oNAAA,EAAgD;YAClE,sBAAsB,WAAA,CAAY,cAAA;YAClC,sBAAA,EAAwB;QAAA,CAC3B,CAAA;IACL;AACJ;AAEO,SAAS,0BAGd,WAAA,EAA6F;IAC3F,OAAO,YAAY,QAAA,KAAa,KAAA,CAAA;AACpC;AAEO,SAAS,gCAGd,WAAA,EAAqG;IACnG,IAAI,WAAA,CAAY,QAAA,KAAa,KAAA,CAAA,EAAW;QACpC,MAAM,IAAI,iLAAA,CAAY,0NAAA,EAAsD;YACxE,MAAM,WAAA,CAAY,IAAA;YAClB,gBAAgB,WAAA,CAAY,cAAA;QAAA,CAC/B,CAAA;IACL;AACJ;AA4BO,SAAS,sBAGd,WAAA,EAAqF;IACnF,OAAO,YAAY,IAAA,KAAS,KAAA,CAAA;AAChC;AAEO,SAAS,4BAGd,WAAA,EAA6F;IAC3F,IAAI,WAAA,CAAY,IAAA,KAAS,KAAA,CAAA,EAAW;QAChC,MAAM,IAAI,iLAAA,CAAY,sNAAA,EAAkD;YACpE,kBAAkB,WAAA,CAAY,QAAA,EAAU,GAAA,CAAI,CAAA,CAAA,GAAK,EAAE,OAAO,CAAA;YAC1D,gBAAgB,WAAA,CAAY,cAAA;QAAA,CAC/B,CAAA;IACL;AACJ;;ACjHO,IAAK,WAAA,GAAA,aAAA,GAAA,CAAA,CAAAA,YAAAA,KAAL;IAEHA,YAAAA,CAAAA,YAAAA,CAAA,iBAAA,CAAA,GAAA,KAAA,GAA0B,CAAA,CAAA,GAA1B,iBAAA;IACAA,YAAAA,CAAAA,YAAAA,CAAA,iBAAA,CAAA,GAAA,KAAA,GAA0B,CAAA,CAAA,GAA1B,iBAAA;IACAA,YAAAA,CAAAA,YAAAA,CAAA,UAAA,CAAA,GAAA,KAAA,GAA0B,CAAA,CAAA,GAA1B,UAAA;IACAA,YAAAA,CAAAA,YAAAA,CAAA,UAAA,CAAA,GAAA,KAAA,GAA0B,CAAA,CAAA,GAA1B,UAAA;IALQ,OAAAA,YAAAA;AAAA,CAAA,EAAA,WAAA,IAAA,CAAA,CAAA;AASZ,IAAM,iBAAA,GAAoB,CAAA;AAC1B,IAAM,mBAAA,GAAsB,CAAA;AAQrB,SAAS,yBAAyB,IAAA,EAAgC;IACrE,OAAO,OAAO,CAAC,iBAAA;AACnB;AAQO,SAAS,wBAAwB,IAAA,EAAgC;IACpE,OAAO,OAAO,CAAC,mBAAA;AACnB;AAMO,SAAS,aAAa,IAAA,EAAsF;IAC/G,OAAO,IAAA,IAAQ,CAAA,CAAA,mBAAA;AACnB;AAMO,SAAS,eAAe,IAAA,EAA+E;IAC1G,OAAA,CAAQ,OAAO,mBAAA,MAAyB,CAAA;AAC5C;AAsBO,SAAS,UAAA,CAAW,KAAA,EAAoB,KAAA,EAAiC;IAC5E,OAAO,KAAA,GAAQ,KAAA;AACnB;AAQO,SAAS,oBAAoB,IAAA,EAAgC;IAChE,OAAO,IAAA,GAAO,iBAAA;AAClB;AAQO,SAAS,sBAAsB,IAAA,EAAgC;IAClE,OAAO,IAAA,GAAO,mBAAA;AAClB"}},
    {"offset": {"line": 1552, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/codecs-core/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-core/src/bytes.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-core/src/codec.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-core/src/combine-codec.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-core/src/add-codec-sentinel.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-core/src/assertions.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-core/src/add-codec-size-prefix.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-core/src/decoder-entire-byte-array.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-core/src/fix-codec-size.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-core/src/offset-codec.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-core/src/resize-codec.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-core/src/pad-codec.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-core/src/reverse-codec.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-core/src/transform-codec.ts"],"sourcesContent":["import { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n *\n * @param byteArrays - The array of byte arrays to concatenate.\n *\n * @example\n * ```ts\n * const bytes1 = new Uint8Array([0x01, 0x02]);\n * const bytes2 = new Uint8Array([]);\n * const bytes3 = new Uint8Array([0x03, 0x04]);\n * const bytes = mergeBytes([bytes1, bytes2, bytes3]);\n * //    ^ [0x01, 0x02, 0x03, 0x04]\n * ```\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n *\n * @param bytes - The byte array to pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 2);\n * // bytes === paddedBytes\n * ```\n */\nexport function padBytes(bytes: Uint8Array, length: number): Uint8Array;\nexport function padBytes(bytes: ReadonlyUint8Array, length: number): ReadonlyUint8Array;\nexport function padBytes(bytes: ReadonlyUint8Array, length: number): ReadonlyUint8Array {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n}\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n *\n * @param bytes - The byte array to truncate or pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Truncates the byte array to the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const fixedBytes = fixBytes(bytes, 2);\n * //    ^ [0x01, 0x02]\n * ```\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 2);\n * // bytes === fixedBytes\n * ```\n */\nexport const fixBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n\n/**\n * Returns true if and only if the provided `data` byte array contains\n * the provided `bytes` byte array at the specified `offset`.\n *\n * @param data - The byte sequence to search for.\n * @param bytes - The byte array in which to search for `data`.\n * @param offset - The position in `bytes` where the search begins.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const data = new Uint8Array([0x02, 0x03]);\n * containsBytes(bytes, data, 1); // true\n * containsBytes(bytes, data, 2); // false\n * ```\n */\nexport function containsBytes(\n    data: ReadonlyUint8Array | Uint8Array,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset: number,\n): boolean {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    return bytesEqual(slice, bytes);\n}\n\n/**\n * Returns true if and only if the provided `bytes1` and `bytes2` byte arrays are equal.\n *\n * @param bytes1 - The first byte array to compare.\n * @param bytes2 - The second byte array to compare.\n *\n * @example\n * ```ts\n * const bytes1 = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const bytes2 = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * bytesEqual(bytes1, bytes2); // true\n * ```\n */\nexport function bytesEqual(bytes1: ReadonlyUint8Array | Uint8Array, bytes2: ReadonlyUint8Array | Uint8Array): boolean {\n    return bytes1.length === bytes2.length && bytes1.every((value, index) => value === bytes2[index]);\n}\n","import {\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Defines an offset in bytes.\n */\nexport type Offset = number;\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * This is a common interface for {@link FixedSizeEncoder} and {@link VariableSizeEncoder}.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n */\ntype BaseEncoder<TFrom> = {\n    /** Encode the provided value and return the encoded bytes directly. */\n    readonly encode: (value: TFrom) => ReadonlyUint8Array;\n    /**\n     * Writes the encoded value into the provided byte array at the given offset.\n     * Returns the offset of the next byte after the encoded value.\n     */\n    readonly write: (value: TFrom, bytes: Uint8Array, offset: Offset) => Offset;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a fixed-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const encoder: FixedSizeEncoder<number, 4>;\n * const bytes = encoder.encode(42);\n * const size = encoder.fixedSize; // 4\n * ```\n *\n * @see {@link Encoder}\n * @see {@link VariableSizeEncoder}\n */\nexport type FixedSizeEncoder<TFrom, TSize extends number = number> = BaseEncoder<TFrom> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a variable-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * ```ts\n * const encoder: VariableSizeEncoder<string>;\n * const bytes = encoder.encode('hello');\n * const size = encoder.getSizeFromValue('hello');\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n */\nexport type VariableSizeEncoder<TFrom> = BaseEncoder<TFrom> & {\n    /** Returns the size of the encoded value in bytes for a given input. */\n    readonly getSizeFromValue: (value: TFrom) => number;\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * An `Encoder` can be either:\n * - A {@link FixedSizeEncoder}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeEncoder}, where encoded values can vary in size.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * Encoding a value into a new byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = encoder.encode('hello');\n * ```\n *\n * @example\n * Writing the encoded value into an existing byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = new Uint8Array(100);\n * const nextOffset = encoder.write('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Encoders` manually using the {@link createEncoder} function but it is more common\n * to compose multiple `Encoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Encoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructEncoder, addEncoderSizePrefix, getUtf8Encoder, getU32Encoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonEncoder = (): Encoder<Person> =>\n *     getStructEncoder([\n *         ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *         ['age', getU32Encoder()],\n *     ]);\n * ```\n *\n * Note that composed `Encoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Encoder()` is\n * a fixed-size encoder, while `addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())`\n * is a variable-size encoder. This makes the final `Person` encoder a variable-size encoder.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link createEncoder}\n */\nexport type Encoder<TFrom> = FixedSizeEncoder<TFrom> | VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * This is a common interface for {@link FixedSizeDecoder} and {@link VariableSizeDecoder}.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n */\ntype BaseDecoder<TTo> = {\n    /** Decodes the provided byte array at the given offset (or zero) and returns the value directly. */\n    readonly decode: (bytes: ReadonlyUint8Array | Uint8Array, offset?: Offset) => TTo;\n    /**\n     * Reads the encoded value from the provided byte array at the given offset.\n     * Returns the decoded value and the offset of the next byte after the encoded value.\n     */\n    readonly read: (bytes: ReadonlyUint8Array | Uint8Array, offset: Offset) => [TTo, Offset];\n};\n\n/**\n * An object that can decode a fixed-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const decoder: FixedSizeDecoder<number, 4>;\n * const value = decoder.decode(bytes);\n * const size = decoder.fixedSize; // 4\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type FixedSizeDecoder<TTo, TSize extends number = number> = BaseDecoder<TTo> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can decode a variable-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const decoder: VariableSizeDecoder<number>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type VariableSizeDecoder<TTo> = BaseDecoder<TTo> & {\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * An `Decoder` can be either:\n * - A {@link FixedSizeDecoder}, where all byte arrays have the same fixed size.\n * - A {@link VariableSizeDecoder}, where byte arrays can vary in size.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * Getting the decoded value from a byte array.\n * ```ts\n * const decoder: Decoder<string>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @example\n * Reading the decoded value from a byte array at a specific offset\n * and getting the offset of the next byte to read.\n * ```ts\n * const decoder: Decoder<string>;\n * const [value, nextOffset] = decoder.read('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Decoders` manually using the {@link createDecoder} function but it is more common\n * to compose multiple `Decoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Decoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructDecoder, addDecoderSizePrefix, getUtf8Decoder, getU32Decoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonDecoder = (): Decoder<Person> =>\n *     getStructDecoder([\n *         ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *         ['age', getU32Decoder()],\n *     ]);\n * ```\n *\n * Note that composed `Decoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Decoder()` is\n * a fixed-size decoder, while `addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())`\n * is a variable-size decoder. This makes the final `Person` decoder a variable-size decoder.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link createDecoder}\n */\nexport type Decoder<TTo> = FixedSizeDecoder<TTo> | VariableSizeDecoder<TTo>;\n\n/**\n * An object that can encode and decode a value to and from a fixed-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const codec: FixedSizeCodec<number | bigint, bigint, 8>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.fixedSize; // 8\n * ```\n *\n * @see {@link Codec}\n * @see {@link VariableSizeCodec}\n */\nexport type FixedSizeCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number> = FixedSizeDecoder<\n    TTo,\n    TSize\n> &\n    FixedSizeEncoder<TFrom, TSize>;\n\n/**\n * An object that can encode and decode a value to and from a variable-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const codec: VariableSizeCodec<number | bigint, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.getSizeFromValue(42);\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n */\nexport type VariableSizeCodec<TFrom, TTo extends TFrom = TFrom> = VariableSizeDecoder<TTo> & VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can encode and decode a value to and from a byte array.\n *\n * A `Codec` can be either:\n * - A {@link FixedSizeCodec}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeCodec}, where encoded values can vary in size.\n *\n * @example\n * ```ts\n * const codec: Codec<string>;\n * const bytes = codec.encode('hello');\n * const value = codec.decode(bytes); // 'hello'\n * ```\n *\n * @remarks\n * For convenience, codecs can encode looser types than they decode.\n * That is, type {@link TFrom} can be a superset of type {@link TTo}.\n * For instance, a `Codec<bigint | number, bigint>` can encode both\n * `bigint` and `number` values, but will always decode to a `bigint`.\n *\n * ```ts\n * const codec: Codec<bigint | number, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * It is worth noting that codecs are the union of encoders and decoders.\n * This means that a `Codec<TFrom, TTo>` can be combined from an `Encoder<TFrom>`\n * and a `Decoder<TTo>` using the {@link combineCodec} function. This is particularly\n * useful for library authors who want to expose all three types of objects to their users.\n *\n * ```ts\n * const encoder: Encoder<bigint | number>;\n * const decoder: Decoder<bigint>;\n * const codec: Codec<bigint | number, bigint> = combineCodec(encoder, decoder);\n * ```\n *\n * Aside from combining encoders and decoders, codecs can also be created from scratch using\n * the {@link createCodec} function but it is more common to compose multiple codecs together\n * using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create a `Codec` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructCodec, addCodecSizePrefix, getUtf8Codec, getU32Codec } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonCodec = (): Codec<Person> =>\n *     getStructCodec([\n *         ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *         ['age', getU32Codec()],\n *     ]);\n * ```\n *\n * Note that composed `Codec` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Codec()` is\n * a fixed-size codec, while `addCodecSizePrefix(getUtf8Codec(), getU32Codec())`\n * is a variable-size codec. This makes the final `Person` codec a variable-size codec.\n *\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link combineCodec}\n * @see {@link createCodec}\n */\nexport type Codec<TFrom, TTo extends TFrom = TFrom> = FixedSizeCodec<TFrom, TTo> | VariableSizeCodec<TFrom, TTo>;\n\n/**\n * Gets the encoded size of a given value in bytes using the provided encoder.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @param value - The value to be encoded.\n * @param encoder - The encoder used to determine the encoded size.\n * @returns The size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const fixedSizeEncoder = { fixedSize: 4 };\n * getEncodedSize(123, fixedSizeEncoder); // Returns 4.\n *\n * const variableSizeEncoder = { getSizeFromValue: (value: string) => value.length };\n * getEncodedSize(\"hello\", variableSizeEncoder); // Returns 5.\n * ```\n *\n * @see {@link Encoder}\n */\nexport function getEncodedSize<TFrom>(\n    value: TFrom,\n    encoder: { fixedSize: number } | { getSizeFromValue: (value: TFrom) => number },\n): number {\n    return 'fixedSize' in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\n\n/**\n * Creates an `Encoder` by filling in the missing `encode` function using the provided `write` function and\n * either the `fixedSize` property (for {@link FixedSizeEncoder | FixedSizeEncoders}) or\n * the `getSizeFromValue` function (for {@link VariableSizeEncoder | VariableSizeEncoders}).\n *\n * Instead of manually implementing `encode`, this utility leverages the existing `write` function\n * and the size helpers to generate a complete encoder. The provided `encode` method will allocate\n * a new `Uint8Array` of the correct size and use `write` to populate it.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size encoders).\n *\n * @param encoder - An encoder object that implements `write`, but not `encode`.\n * - If the encoder has a `fixedSize` property, it is treated as a {@link FixedSizeEncoder}.\n * - Otherwise, it is treated as a {@link VariableSizeEncoder}.\n *\n * @returns A fully functional `Encoder` with both `write` and `encode` methods.\n *\n * @example\n * Creating a custom fixed-size encoder.\n * ```ts\n * const encoder = createEncoder({\n *     fixedSize: 4,\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n * ```\n *\n * @example\n * Creating a custom variable-size encoder:\n * ```ts\n * const encoder = createEncoder({\n *     getSizeFromValue: (value: string) => value.length,\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = encoder.encode(\"hello\");\n * // 0x68656c6c6f\n * ```\n *\n * @remarks\n * Note that, while `createEncoder` is useful for defining more complex encoders, it is more common to compose\n * encoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createEncoder`.\n *\n * ```ts\n * // Fixed-size encoder for unsigned 32-bit integers.\n * const encoder = getU32Encoder();\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n *\n * // Variable-size encoder for 32-bytes prefixed UTF-8 strings.\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * const bytes = encoder.encode(\"hello\");\n * // 0x0500000068656c6c6f\n *\n * // Variable-size encoder for custom objects.\n * type Person = { name: string; age: number };\n * const encoder: Encoder<Person> = getStructEncoder([\n *     ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *     ['age', getU32Encoder()],\n * ]);\n * const bytes = encoder.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link getStructEncoder}\n * @see {@link getU32Encoder}\n * @see {@link getUtf8Encoder}\n * @see {@link addEncoderSizePrefix}\n */\nexport function createEncoder<TFrom, TSize extends number>(\n    encoder: Omit<FixedSizeEncoder<TFrom, TSize>, 'encode'>,\n): FixedSizeEncoder<TFrom, TSize>;\nexport function createEncoder<TFrom>(encoder: Omit<VariableSizeEncoder<TFrom>, 'encode'>): VariableSizeEncoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom> {\n    return Object.freeze({\n        ...encoder,\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Creates a `Decoder` by filling in the missing `decode` function using the provided `read` function.\n *\n * Instead of manually implementing `decode`, this utility leverages the existing `read` function\n * and the size properties to generate a complete decoder. The provided `decode` method will read\n * from a `Uint8Array` at the given offset and return the decoded value.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeDecoder} will be created, otherwise\n * a {@link VariableSizeDecoder} will be created.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size decoders).\n *\n * @param decoder - A decoder object that implements `read`, but not `decode`.\n * - If the decoder has a `fixedSize` property, it is treated as a {@link FixedSizeDecoder}.\n * - Otherwise, it is treated as a {@link VariableSizeDecoder}.\n *\n * @returns A fully functional `Decoder` with both `read` and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size decoder.\n * ```ts\n * const decoder = createDecoder({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size decoder:\n * ```ts\n * const decoder = createDecoder({\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([104, 101, 108, 108, 111]));\n * // \"hello\"\n * ```\n *\n * @remarks\n * Note that, while `createDecoder` is useful for defining more complex decoders, it is more common to compose\n * decoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createDecoder`.\n *\n * ```ts\n * // Fixed-size decoder for unsigned 32-bit integers.\n * const decoder = getU32Decoder();\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n *\n * // Variable-size decoder for 32-bytes prefixed UTF-8 strings.\n * const decoder = addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder());\n * const value = decoder.decode(new Uint8Array([5, 0, 0, 0, 104, 101, 108, 108, 111]));\n * // \"hello\"\n *\n * // Variable-size decoder for custom objects.\n * type Person = { name: string; age: number };\n * const decoder: Decoder<Person> = getStructDecoder([\n *     ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *     ['age', getU32Decoder()],\n * ]);\n * const value = decoder.decode(new Uint8Array([3, 0, 0, 0, 66, 111, 98, 42, 0, 0, 0]));\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Decoder}\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link getStructDecoder}\n * @see {@link getU32Decoder}\n * @see {@link getUtf8Decoder}\n * @see {@link addDecoderSizePrefix}\n */\nexport function createDecoder<TTo, TSize extends number>(\n    decoder: Omit<FixedSizeDecoder<TTo, TSize>, 'decode'>,\n): FixedSizeDecoder<TTo, TSize>;\nexport function createDecoder<TTo>(decoder: Omit<VariableSizeDecoder<TTo>, 'decode'>): VariableSizeDecoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo> {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0],\n    });\n}\n\n/**\n * Creates a `Codec` by filling in the missing `encode` and `decode` functions using the provided `write` and `read` functions.\n *\n * This utility combines the behavior of {@link createEncoder} and {@link createDecoder} to produce a fully functional `Codec`.\n * The `encode` method is derived from the `write` function, while the `decode` method is derived from the `read` function.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeCodec} will be created, otherwise\n * a {@link VariableSizeCodec} will be created.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size codecs).\n *\n * @param codec - A codec object that implements `write` and `read`, but not `encode` or `decode`.\n * - If the codec has a `fixedSize` property, it is treated as a {@link FixedSizeCodec}.\n * - Otherwise, it is treated as a {@link VariableSizeCodec}.\n *\n * @returns A fully functional `Codec` with `write`, `read`, `encode`, and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size codec.\n * ```ts\n * const codec = createCodec({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size codec:\n * ```ts\n * const codec = createCodec({\n *     getSizeFromValue: (value: string) => value.length,\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = codec.encode(\"hello\");\n * // 0x68656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n * ```\n *\n * @remarks\n * This function effectively combines the behavior of {@link createEncoder} and {@link createDecoder}.\n * If you only need to encode or decode (but not both), consider using those functions instead.\n *\n * Here are some alternative examples using codec primitives instead of `createCodec`.\n *\n * ```ts\n * // Fixed-size codec for unsigned 32-bit integers.\n * const codec = getU32Codec();\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n *\n * // Variable-size codec for 32-bytes prefixed UTF-8 strings.\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const bytes = codec.encode(\"hello\");\n * // 0x0500000068656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n *\n * // Variable-size codec for custom objects.\n * type Person = { name: string; age: number };\n * const codec: Codec<PersonInput, Person> = getStructCodec([\n *     ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *     ['age', getU32Codec()],\n * ]);\n * const bytes = codec.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * const value = codec.decode(bytes);\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link createEncoder}\n * @see {@link createDecoder}\n * @see {@link getStructCodec}\n * @see {@link getU32Codec}\n * @see {@link getUtf8Codec}\n * @see {@link addCodecSizePrefix}\n */\nexport function createCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number>(\n    codec: Omit<FixedSizeCodec<TFrom, TTo, TSize>, 'decode' | 'encode'>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec: Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo> {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Determines whether the given codec, encoder, or decoder is fixed-size.\n *\n * A fixed-size object is identified by the presence of a `fixedSize` property.\n * If this property exists, the object is considered a {@link FixedSizeCodec},\n * {@link FixedSizeEncoder}, or {@link FixedSizeDecoder}.\n * Otherwise, it is assumed to be a {@link VariableSizeCodec},\n * {@link VariableSizeEncoder}, or {@link VariableSizeDecoder}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @returns `true` if the object is fixed-size, `false` otherwise.\n *\n * @example\n * Checking a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * isFixedSize(encoder); // true\n * ```\n *\n * @example\n * Checking a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * isFixedSize(encoder); // false\n * ```\n *\n * @remarks\n * This function is commonly used to distinguish between fixed-size and variable-size objects at runtime.\n * If you need to enforce this distinction with type assertions, consider using {@link assertIsFixedSize}.\n *\n * @see {@link assertIsFixedSize}\n */\nexport function isFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function isFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): decoder is FixedSizeDecoder<TTo, TSize>;\nexport function isFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function isFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): codec is { fixedSize: TSize };\nexport function isFixedSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { fixedSize: number } {\n    return 'fixedSize' in codec && typeof codec.fixedSize === 'number';\n}\n\n/**\n * Asserts that the given codec, encoder, or decoder is fixed-size.\n *\n * If the object is not fixed-size (i.e., it lacks a `fixedSize` property),\n * this function throws a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @throws {SolanaError} If the object is not fixed-size.\n *\n * @example\n * Asserting a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * assertIsFixedSize(encoder); // Passes\n * ```\n *\n * @example\n * Attempting to assert a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * assertIsFixedSize(encoder); // Throws SolanaError\n * ```\n *\n * @remarks\n * This function is the assertion-based counterpart of {@link isFixedSize}.\n * If you only need to check whether an object is fixed-size without throwing an error, use {@link isFixedSize} instead.\n *\n * @see {@link isFixedSize}\n */\nexport function assertIsFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): asserts encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function assertIsFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): asserts decoder is FixedSizeDecoder<TTo, TSize>;\nexport function assertIsFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): asserts codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function assertIsFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): asserts codec is { fixedSize: TSize };\nexport function assertIsFixedSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { fixedSize: number } {\n    if (!isFixedSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\n\n/**\n * Determines whether the given codec, encoder, or decoder is variable-size.\n *\n * A variable-size object is identified by the absence of a `fixedSize` property.\n * If this property is missing, the object is considered a {@link VariableSizeCodec},\n * {@link VariableSizeEncoder}, or {@link VariableSizeDecoder}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @returns `true` if the object is variable-size, `false` otherwise.\n *\n * @example\n * Checking a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * isVariableSize(encoder); // true\n * ```\n *\n * @example\n * Checking a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * isVariableSize(encoder); // false\n * ```\n *\n * @remarks\n * This function is the inverse of {@link isFixedSize}.\n *\n * @see {@link isFixedSize}\n * @see {@link assertIsVariableSize}\n */\nexport function isVariableSize<TFrom>(encoder: Encoder<TFrom>): encoder is VariableSizeEncoder<TFrom>;\nexport function isVariableSize<TTo>(decoder: Decoder<TTo>): decoder is VariableSizeDecoder<TTo>;\nexport function isVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): codec is VariableSizeCodec<TFrom, TTo>;\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number };\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number } {\n    return !isFixedSize(codec);\n}\n\n/**\n * Asserts that the given codec, encoder, or decoder is variable-size.\n *\n * If the object is not variable-size (i.e., it has a `fixedSize` property),\n * this function throws a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @throws {SolanaError} If the object is not variable-size.\n *\n * @example\n * Asserting a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * assertIsVariableSize(encoder); // Passes\n * ```\n *\n * @example\n * Attempting to assert a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * assertIsVariableSize(encoder); // Throws SolanaError\n * ```\n *\n * @remarks\n * This function is the assertion-based counterpart of {@link isVariableSize}.\n * If you only need to check whether an object is variable-size without throwing an error, use {@link isVariableSize} instead.\n *\n * Also note that this function is the inverse of {@link assertIsFixedSize}.\n *\n * @see {@link isVariableSize}\n * @see {@link assertIsFixedSize}\n */\nexport function assertIsVariableSize<TFrom>(encoder: Encoder<TFrom>): asserts encoder is VariableSizeEncoder<TFrom>;\nexport function assertIsVariableSize<TTo>(decoder: Decoder<TTo>): asserts decoder is VariableSizeDecoder<TTo>;\nexport function assertIsVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): asserts codec is VariableSizeCodec<TFrom, TTo>;\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number };\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number } {\n    if (!isVariableSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    Codec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\n\n/**\n * Combines an `Encoder` and a `Decoder` into a `Codec`.\n *\n * That is, given a `Encoder<TFrom>` and a `Decoder<TTo>`, this function returns a `Codec<TFrom, TTo>`.\n *\n * This allows for modular composition by keeping encoding and decoding logic separate\n * while still offering a convenient way to bundle them into a single `Codec`.\n * This is particularly useful for library maintainers who want to expose `Encoders`,\n * `Decoders`, and `Codecs` separately, enabling tree-shaking of unused logic.\n *\n * The provided `Encoder` and `Decoder` must be compatible in terms of:\n * - **Fixed Size:** If both are fixed-size, they must have the same `fixedSize` value.\n * - **Variable Size:** If either has a `maxSize` attribute, it must match the other.\n *\n * If these conditions are not met, a {@link SolanaError} will be thrown.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size codecs).\n *\n * @param encoder - The `Encoder` to combine.\n * @param decoder - The `Decoder` to combine.\n * @returns A `Codec` that provides both `encode` and `decode` methods.\n *\n * @throws {SolanaError}\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH`\n *   Thrown if the encoder and decoder have mismatched size types (fixed vs. variable).\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH`\n *   Thrown if both are fixed-size but have different `fixedSize` values.\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH`\n *   Thrown if the `maxSize` attributes do not match.\n *\n * @example\n * Creating a fixed-size `Codec` from an encoder and a decoder.\n * ```ts\n * const encoder = getU32Encoder();\n * const decoder = getU32Decoder();\n * const codec = combineCodec(encoder, decoder);\n *\n * const bytes = codec.encode(42); // 0x2a000000\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Creating a variable-size `Codec` from an encoder and a decoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * const decoder = addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder());\n * const codec = combineCodec(encoder, decoder);\n *\n * const bytes = codec.encode(\"hello\"); // 0x0500000068656c6c6f\n * const value = codec.decode(bytes); // \"hello\"\n * ```\n *\n * @remarks\n * The recommended pattern for defining codecs in libraries is to expose separate functions for the encoder, decoder, and codec.\n * This allows users to import only what they need, improving tree-shaking efficiency.\n *\n * ```ts\n * type MyType = \\/* ... *\\/;\n * const getMyTypeEncoder = (): Encoder<MyType> => { \\/* ... *\\/ };\n * const getMyTypeDecoder = (): Decoder<MyType> => { \\/* ... *\\/ };\n * const getMyTypeCodec = (): Codec<MyType> =>\n *     combineCodec(getMyTypeEncoder(), getMyTypeDecoder());\n * ```\n *\n * @see {@link Codec}\n * @see {@link Encoder}\n * @see {@link Decoder}\n */\nexport function combineCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: VariableSizeEncoder<TFrom>,\n    decoder: VariableSizeDecoder<TTo>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo> {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize,\n        });\n    }\n\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize,\n        });\n    }\n\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write,\n    };\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SolanaError,\n} from '@solana/errors';\n\nimport { containsBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Creates an encoder that writes a `Uint8Array` sentinel after the encoded value.\n * This is useful to delimit the encoded value when being read by a decoder.\n *\n * See {@link addCodecSentinel} for more information.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link addCodecSentinel}\n */\nexport function addEncoderSentinel<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(\n    encoder: Encoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(encoder: Encoder<TFrom>, sentinel: ReadonlyUint8Array): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds\n        // and to avoid writing the sentinel as part of the encoded value.\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });\n    }\n\n    return createEncoder({\n        ...encoder,\n        ...(encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {}),\n        getSizeFromValue: value => encoder.getSizeFromValue(value) + sentinel.length,\n        write,\n    });\n}\n\n/**\n * Creates a decoder that continues reading until\n * a given `Uint8Array` sentinel is found.\n *\n * See {@link addCodecSentinel} for more information.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link addCodecSentinel}\n */\nexport function addDecoderSentinel<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): VariableSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds\n        // and ensure that the sentinel is not part of the decoded value.\n        return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });\n    }\n\n    return createDecoder({\n        ...decoder,\n        ...(decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {}),\n        read,\n    });\n}\n\n/**\n * Creates a Codec that writes a given `Uint8Array` sentinel after the encoded\n * value and, when decoding, continues reading until the sentinel is found.\n *\n * This sets a limit on variable-size codecs and tells us when to stop decoding.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const codec = addCodecSentinel(getUtf8Codec(), new Uint8Array([255, 255]));\n * codec.encode('hello');\n * // 0x68656c6c6fffff\n * //   |        └-- Our sentinel.\n * //   └-- Our encoded string.\n * ```\n *\n * @remarks\n * Note that the sentinel _must not_ be present in the encoded data and\n * _must_ be present in the decoded data for this to work.\n * If this is not the case, dedicated errors will be thrown.\n *\n * ```ts\n * const sentinel = new Uint8Array([108, 108]); // 'll'\n * const codec = addCodecSentinel(getUtf8Codec(), sentinel);\n *\n * codec.encode('hello'); // Throws: sentinel is in encoded data.\n * codec.decode(new Uint8Array([1, 2, 3])); // Throws: sentinel missing in decoded data.\n * ```\n *\n * Separate {@link addEncoderSentinel} and {@link addDecoderSentinel} functions are also available.\n *\n * ```ts\n * const bytes = addEncoderSentinel(getUtf8Encoder(), sentinel).encode('hello');\n * const value = addDecoderSentinel(getUtf8Decoder(), sentinel).decode(bytes);\n * ```\n *\n * @see {@link addEncoderSentinel}\n * @see {@link addDecoderSentinel}\n */\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\n\nfunction findSentinelIndex(bytes: ReadonlyUint8Array, sentinel: ReadonlyUint8Array) {\n    return bytes.findIndex((byte, index, arr) => {\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\n\nfunction hexBytes(bytes: ReadonlyUint8Array): string {\n    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","import {\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Asserts that a given byte array is not empty (after the optional provided offset).\n *\n * Returns void if the byte array is not empty but throws a {@link SolanaError} otherwise.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param bytes - The byte array to check.\n * @param offset - The offset from which to start checking the byte array.\n * If provided, the byte array is considered empty if it has no bytes after the offset.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes); // OK\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes, 1); // OK\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes, 3); // Throws\n * ```\n */\nexport function assertByteArrayIsNotEmptyForCodec(\n    codecDescription: string,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    if (bytes.length - offset <= 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription,\n        });\n    }\n}\n\n/**\n * Asserts that a given byte array has enough bytes to decode\n * (after the optional provided offset).\n *\n * Returns void if the byte array has at least the expected number\n * of bytes but throws a {@link SolanaError} otherwise.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param expected - The minimum number of bytes expected in the byte array.\n * @param bytes - The byte array to check.\n * @param offset - The offset from which to start checking the byte array.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 3, bytes); // OK\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 4, bytes); // Throws\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 2, bytes, 1); // OK\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 3, bytes, 1); // Throws\n * ```\n */\nexport function assertByteArrayHasEnoughBytesForCodec(\n    codecDescription: string,\n    expected: number,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected,\n        });\n    }\n}\n\n/**\n * Asserts that a given offset is within the byte array bounds.\n * This range is between 0 and the byte array length and is inclusive.\n * An offset equals to the byte array length is considered a valid offset\n * as it allows the post-offset of codecs to signal the end of the byte array.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param offset - The offset to check.\n * @param bytesLength - The length of the byte array from which the offset should be within bounds.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 0, bytes.length); // OK\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 3, bytes.length); // OK\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 4, bytes.length); // Throws\n * ```\n */\nexport function assertByteArrayOffsetIsNotOutOfRange(codecDescription: string, offset: number, bytesLength: number) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset,\n        });\n    }\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\ntype NumberEncoder = Encoder<bigint | number> | Encoder<number>;\ntype FixedSizeNumberEncoder<TSize extends number = number> =\n    | FixedSizeEncoder<bigint | number, TSize>\n    | FixedSizeEncoder<number, TSize>;\ntype NumberDecoder = Decoder<bigint> | Decoder<number>;\ntype FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\ntype NumberCodec = Codec<bigint | number, bigint> | Codec<number>;\ntype FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<number, number, TSize>;\n\n/**\n * Stores the size of the `encoder` in bytes as a prefix using the `prefix` encoder.\n *\n * See {@link addCodecSizePrefix} for more information.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link addCodecSizePrefix}\n */\nexport function addEncoderSizePrefix<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefix: FixedSizeNumberEncoder,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): VariableSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds.\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : (encoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n\n    return createEncoder({\n        ...encoder,\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: value => {\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write,\n    });\n}\n\n/**\n * Bounds the size of the nested `decoder` by reading its encoded `prefix`.\n *\n * See {@link addCodecSizePrefix} for more information.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link addCodecSizePrefix}\n */\nexport function addDecoderSizePrefix<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefix: FixedSizeNumberDecoder,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): VariableSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        // Slice the byte array to the contained size if necessary.\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec('addDecoderSizePrefix', size, bytes);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds.\n        return [decoder.decode(bytes), offset + size];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : (decoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({ ...decoder, ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Stores the byte size of any given codec as an encoded number prefix.\n *\n * This sets a limit on variable-size codecs and tells us when to stop decoding.\n * When encoding, the size of the encoded data is stored before the encoded data itself.\n * When decoding, the size is read first to know how many bytes to read next.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * For example, say we want to bound a variable-size base-58 string using a `u32` size prefix.\n * Here’s how you can use the `addCodecSizePrefix` function to achieve that.\n *\n * ```ts\n * const getU32Base58Codec = () => addCodecSizePrefix(getBase58Codec(), getU32Codec());\n *\n * getU32Base58Codec().encode('hello world');\n * // 0x0b00000068656c6c6f20776f726c64\n * //   |       └-- Our encoded base-58 string.\n * //   └-- Our encoded u32 size prefix.\n * ```\n *\n * @remarks\n * Separate {@link addEncoderSizePrefix} and {@link addDecoderSizePrefix} functions are also available.\n *\n * ```ts\n * const bytes = addEncoderSizePrefix(getBase58Encoder(), getU32Encoder()).encode('hello');\n * const value = addDecoderSizePrefix(getBase58Decoder(), getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link addEncoderSizePrefix}\n * @see {@link addDecoderSizePrefix}\n */\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefix: FixedSizeNumberCodec,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n","import { SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY, SolanaError } from '@solana/errors';\n\nimport { createDecoder, Decoder } from './codec';\n\n/**\n * Create a {@link Decoder} that asserts that the bytes provided to `decode` or `read` are fully consumed by the inner decoder\n * @param decoder A decoder to wrap\n * @returns A new decoder that will throw if provided with a byte array that it does not fully consume\n *\n * @typeParam T - The type of the decoder\n *\n * @remarks\n * Note that this compares the offset after encoding to the length of the input byte array\n *\n * The `offset` parameter to `decode` and `read` is still considered, and will affect the new offset that is compared to the byte array length\n *\n * The error that is thrown by the returned decoder is a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY`\n *\n * @example\n * Create a decoder that decodes a `u32` (4 bytes) and ensures the entire byte array is consumed\n * ```ts\n * const decoder = createDecoderThatUsesExactByteArray(getU32Decoder());\n * decoder.decode(new Uint8Array([0, 0, 0, 0])); // 0\n * decoder.decode(new Uint8Array([0, 0, 0, 0, 0])); // throws\n *\n * // with an offset\n * decoder.decode(new Uint8Array([0, 0, 0, 0, 0]), 1); // 0\n * decoder.decode(new Uint8Array([0, 0, 0, 0, 0, 0]), 1); // throws\n * ```\n */\nexport function createDecoderThatConsumesEntireByteArray<T>(decoder: Decoder<T>): Decoder<T> {\n    return createDecoder({\n        ...decoder,\n        read(bytes, offset) {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            if (bytes.length > newOffset) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY, {\n                    expectedLength: newOffset,\n                    numExcessBytes: bytes.length - newOffset,\n                });\n            }\n            return [value, newOffset];\n        },\n    });\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport { fixBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    Offset,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Creates a fixed-size encoder from a given encoder.\n *\n * The resulting encoder ensures that encoded values always have the specified number of bytes.\n * If the original encoded value is larger than `fixedBytes`, it is truncated.\n * If it is smaller, it is padded with trailing zeroes.\n *\n * For more details, see {@link fixCodecSize}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param encoder - The encoder to wrap into a fixed-size encoder.\n * @param fixedBytes - The fixed number of bytes to write.\n * @returns A `FixedSizeEncoder` that ensures a consistent output size.\n *\n * @example\n * ```ts\n * const encoder = fixEncoderSize(getUtf8Encoder(), 4);\n * encoder.encode(\"Hello\"); // 0x48656c6c (truncated)\n * encoder.encode(\"Hi\");    // 0x48690000 (padded)\n * encoder.encode(\"Hiya\");  // 0x48697961 (same length)\n * ```\n *\n * @remarks\n * If you need a full codec with both encoding and decoding, use {@link fixCodecSize}.\n *\n * @see {@link fixCodecSize}\n * @see {@link fixDecoderSize}\n */\nexport function fixEncoderSize<TFrom, TSize extends number>(\n    encoder: Encoder<TFrom>,\n    fixedBytes: TSize,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value: TFrom, bytes: Uint8Array, offset: Offset) => {\n            // Here we exceptionally use the `encode` function instead of the `write`\n            // function as using the nested `write` function on a fixed-sized byte\n            // array may result in a out-of-bounds error on the nested encoder.\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray =\n                variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        },\n    });\n}\n\n/**\n * Creates a fixed-size decoder from a given decoder.\n *\n * The resulting decoder always reads exactly `fixedBytes` bytes from the input.\n * If the nested decoder is also fixed-size, the bytes are truncated or padded as needed.\n *\n * For more details, see {@link fixCodecSize}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param decoder - The decoder to wrap into a fixed-size decoder.\n * @param fixedBytes - The fixed number of bytes to read.\n * @returns A `FixedSizeDecoder` that ensures a consistent input size.\n *\n * @example\n * ```ts\n * const decoder = fixDecoderSize(getUtf8Decoder(), 4);\n * decoder.decode(new Uint8Array([72, 101, 108, 108, 111])); // \"Hell\" (truncated)\n * decoder.decode(new Uint8Array([72, 105, 0, 0]));          // \"Hi\" (zeroes ignored)\n * decoder.decode(new Uint8Array([72, 105, 121, 97]));       // \"Hiya\" (same length)\n * ```\n *\n * @remarks\n * If you need a full codec with both encoding and decoding, use {@link fixCodecSize}.\n *\n * @see {@link fixCodecSize}\n * @see {@link fixEncoderSize}\n */\nexport function fixDecoderSize<TTo, TSize extends number>(\n    decoder: Decoder<TTo>,\n    fixedBytes: TSize,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset) => {\n            assertByteArrayHasEnoughBytesForCodec('fixCodecSize', fixedBytes, bytes, offset);\n            // Slice the byte array to the fixed size if necessary.\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            // If the nested decoder is fixed-size, pad and truncate the byte array accordingly.\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            // Decode the value using the nested decoder.\n            const [value] = decoder.read(bytes, 0);\n            return [value, offset + fixedBytes];\n        },\n    });\n}\n\n/**\n * Creates a fixed-size codec from a given codec.\n *\n * The resulting codec ensures that both encoding and decoding operate on a fixed number of bytes.\n * When encoding:\n * - If the encoded value is larger than `fixedBytes`, it is truncated.\n * - If it is smaller, it is padded with trailing zeroes.\n * - If it is exactly `fixedBytes`, it remains unchanged.\n *\n * When decoding:\n * - Exactly `fixedBytes` bytes are read from the input.\n * - If the nested decoder has a smaller fixed size, bytes are truncated or padded as necessary.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param codec - The codec to wrap into a fixed-size codec.\n * @param fixedBytes - The fixed number of bytes to read/write.\n * @returns A `FixedSizeCodec` that ensures both encoding and decoding conform to a fixed size.\n *\n * @example\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 4);\n *\n * const bytes1 = codec.encode(\"Hello\"); // 0x48656c6c (truncated)\n * const value1 = codec.decode(bytes1);  // \"Hell\"\n *\n * const bytes2 = codec.encode(\"Hi\");    // 0x48690000 (padded)\n * const value2 = codec.decode(bytes2);  // \"Hi\"\n *\n * const bytes3 = codec.encode(\"Hiya\");  // 0x48697961 (same length)\n * const value3 = codec.decode(bytes3);  // \"Hiya\"\n * ```\n *\n * @remarks\n * If you only need to enforce a fixed size for encoding, use {@link fixEncoderSize}.\n * If you only need to enforce a fixed size for decoding, use {@link fixDecoderSize}.\n *\n * ```ts\n * const bytes = fixEncoderSize(getUtf8Encoder(), 4).encode(\"Hiya\");\n * const value = fixDecoderSize(getUtf8Decoder(), 4).decode(bytes);\n * ```\n *\n * @see {@link fixEncoderSize}\n * @see {@link fixDecoderSize}\n */\nexport function fixCodecSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: Codec<TFrom, TTo>,\n    fixedBytes: TSize,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n","import { assertByteArrayOffsetIsNotOutOfRange } from './assertions';\nimport { Codec, createDecoder, createEncoder, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Configuration object for modifying the offset of an encoder, decoder, or codec.\n *\n * This type defines optional functions for adjusting the **pre-offset** (before encoding/decoding)\n * and the **post-offset** (after encoding/decoding). These functions allow precise control\n * over where data is written or read within a byte array.\n *\n * @property preOffset - A function that modifies the offset before encoding or decoding.\n * @property postOffset - A function that modifies the offset after encoding or decoding.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * };\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const config: OffsetConfig = {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * };\n * ```\n *\n * @example\n * Using both pre-offset and post-offset together.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n *     postOffset: ({ postOffset }) => postOffset + 4,\n * };\n * ```\n *\n * @see {@link offsetEncoder}\n * @see {@link offsetDecoder}\n * @see {@link offsetCodec}\n */\ntype OffsetConfig = {\n    postOffset?: PostOffsetFunction;\n    preOffset?: PreOffsetFunction;\n};\n\n/**\n * Scope provided to the `preOffset` and `postOffset` functions,\n * containing contextual information about the current encoding or decoding process.\n *\n * The pre-offset function modifies where encoding or decoding begins,\n * while the post-offset function modifies where the next operation continues.\n *\n * @property bytes - The entire byte array being encoded or decoded.\n * @property preOffset - The original offset before encoding or decoding starts.\n * @property wrapBytes - A helper function that wraps offsets around the byte array length.\n *\n * @example\n * Using `wrapBytes` to wrap a negative offset to the end of the byte array.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves to last 4 bytes\n * };\n * ```\n *\n * @example\n * Adjusting the offset dynamically based on the byte array size.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ bytes }) => bytes.length > 10 ? 4 : 2,\n * };\n * ```\n *\n * @see {@link PreOffsetFunction}\n * @see {@link PostOffsetFunction}\n */\ntype PreOffsetFunctionScope = {\n    /** The entire byte array. */\n    bytes: ReadonlyUint8Array | Uint8Array;\n    /** The original offset prior to encode or decode. */\n    preOffset: Offset;\n    /** Wraps the offset to the byte array length. */\n    wrapBytes: (offset: Offset) => Offset;\n};\n\n/**\n * A function that modifies the pre-offset before encoding or decoding.\n *\n * This function is used to adjust the starting position before writing\n * or reading data in a byte array.\n *\n * @param scope - The current encoding or decoding context.\n * @returns The new offset at which encoding or decoding should start.\n *\n * @example\n * Skipping the first 2 bytes before writing or reading.\n * ```ts\n * const preOffset: PreOffsetFunction = ({ preOffset }) => preOffset + 2;\n * ```\n *\n * @example\n * Wrapping the offset to ensure it stays within bounds.\n * ```ts\n * const preOffset: PreOffsetFunction = ({ wrapBytes, preOffset }) => wrapBytes(preOffset + 10);\n * ```\n *\n * @see {@link OffsetConfig}\n * @see {@link PreOffsetFunctionScope}\n */\ntype PreOffsetFunction = (scope: PreOffsetFunctionScope) => Offset;\n\n/**\n * A function that modifies the post-offset after encoding or decoding.\n *\n * This function adjusts where the next encoder or decoder should start\n * after the current operation has completed.\n *\n * @param scope - The current encoding or decoding context, including the modified pre-offset\n * and the original post-offset.\n * @returns The new offset at which the next operation should begin.\n *\n * @example\n * Moving the post-offset forward by 4 bytes.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ postOffset }) => postOffset + 4;\n * ```\n *\n * @example\n * Wrapping the post-offset within the byte array length.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ wrapBytes, postOffset }) => wrapBytes(postOffset);\n * ```\n *\n * @example\n * Ensuring a minimum spacing of 8 bytes between values.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ postOffset, newPreOffset }) =>\n *     Math.max(postOffset, newPreOffset + 8);\n * ```\n *\n * @see {@link OffsetConfig}\n * @see {@link PreOffsetFunctionScope}\n */\ntype PostOffsetFunction = (\n    scope: PreOffsetFunctionScope & {\n        /** The modified offset used to encode or decode. */\n        newPreOffset: Offset;\n        /** The original offset returned by the encoder or decoder. */\n        postOffset: Offset;\n    },\n) => Offset;\n\n/**\n * Moves the offset of a given encoder before and/or after encoding.\n *\n * This function allows an encoder to write its encoded value at a different offset\n * than the one originally provided. It supports both pre-offset adjustments\n * (before encoding) and post-offset adjustments (after encoding).\n *\n * The pre-offset function determines where encoding should start, while the\n * post-offset function adjusts where the next encoder should continue writing.\n *\n * For more details, see {@link offsetCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new encoder with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * encoder.write(42, bytes, 0); // Actually written at offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * const nextOffset = encoder.write(42, bytes, 0); // Next encoder starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to ensure an offset wraps around the byte array length.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes of the array\n * });\n * const bytes = new Uint8Array(10);\n * encoder.write(42, bytes, 0); // Writes at bytes.length - 4\n * ```\n *\n * @remarks\n * If you need both encoding and decoding offsets to be adjusted, use {@link offsetCodec}.\n *\n * @see {@link offsetCodec}\n * @see {@link offsetDecoder}\n */\nexport function offsetEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, config: OffsetConfig): TEncoder {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPostOffset, bytes.length);\n            return newPostOffset;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Moves the offset of a given decoder before and/or after decoding.\n *\n * This function allows a decoder to read its input from a different offset\n * than the one originally provided. It supports both pre-offset adjustments\n * (before decoding) and post-offset adjustments (after decoding).\n *\n * The pre-offset function determines where decoding should start, while the\n * post-offset function adjusts where the next decoder should continue reading.\n *\n * For more details, see {@link offsetCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new decoder with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array([0, 0, 42, 0]); // Value starts at offset 2\n * decoder.read(bytes, 0); // Actually reads from offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array([42, 0, 0, 0]);\n * const [value, nextOffset] = decoder.read(bytes, 0); // Next decoder starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to read from the last 4 bytes of an array.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes of the array\n * });\n * const bytes = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 42]); // Value stored at the last 4 bytes\n * decoder.read(bytes, 0); // Reads from bytes.length - 4\n * ```\n *\n * @remarks\n * If you need both encoding and decoding offsets to be adjusted, use {@link offsetCodec}.\n *\n * @see {@link offsetCodec}\n * @see {@link offsetEncoder}\n */\nexport function offsetDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, config: OffsetConfig): TDecoder {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPostOffset, bytes.length);\n            return [value, newPostOffset];\n        },\n    }) as TDecoder;\n}\n\n/**\n * Moves the offset of a given codec before and/or after encoding and decoding.\n *\n * This function allows a codec to encode and decode values at custom offsets\n * within a byte array. It modifies both the **pre-offset** (where encoding/decoding starts)\n * and the **post-offset** (where the next operation should continue).\n *\n * This is particularly useful when working with structured binary formats\n * that require skipping reserved bytes, inserting padding, or aligning fields at\n * specific locations.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new codec with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes when encoding and decoding.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0); // Actually written at offset 2\n * codec.read(bytes, 0);      // Actually read from offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes when encoding and decoding.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0);\n * // Next encoding starts at offset 6 instead of 4\n * codec.read(bytes, 0);\n * // Next decoding starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to loop around negative offsets.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0); // Writes at bytes.length - 4\n * codec.read(bytes, 0); // Reads from bytes.length - 4\n * ```\n *\n * @remarks\n * If you only need to adjust offsets for encoding, use {@link offsetEncoder}.\n * If you only need to adjust offsets for decoding, use {@link offsetDecoder}.\n *\n * ```ts\n * const bytes = new Uint8Array(10);\n * offsetEncoder(getU32Encoder(), { preOffset: ({ preOffset }) => preOffset + 2 }).write(42, bytes, 0);\n * const [value] = offsetDecoder(getU32Decoder(), { preOffset: ({ preOffset }) => preOffset + 2 }).read(bytes, 0);\n * ```\n *\n * @see {@link offsetEncoder}\n * @see {@link offsetDecoder}\n */\nexport function offsetCodec<TCodec extends AnyCodec>(codec: TCodec, config: OffsetConfig): TCodec {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config)) as TCodec;\n}\n\n/** A modulo function that handles negative dividends and zero divisors. */\nfunction modulo(dividend: number, divisor: number) {\n    if (divisor === 0) return 0;\n    return ((dividend % divisor) + divisor) % divisor;\n}\n","import { SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Updates the size of a given encoder.\n *\n * This function modifies the size of an encoder using a provided transformation function.\n * For fixed-size encoders, it updates the `fixedSize` property, and for variable-size\n * encoders, it adjusts the size calculation based on the encoded value.\n *\n * If the new size is negative, an error will be thrown.\n *\n * For more details, see {@link resizeCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The original fixed size of the encoded value.\n * @typeParam TNewSize - The new fixed size after resizing.\n *\n * @param encoder - The encoder whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new encoder with the updated size.\n *\n * @example\n * Increasing the size of a `u16` encoder by 2 bytes.\n * ```ts\n * const encoder = resizeEncoder(getU16Encoder(), size => size + 2);\n * encoder.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * ```\n *\n * @example\n * Shrinking a `u32` encoder to only use 2 bytes.\n * ```ts\n * const encoder = resizeEncoder(getU32Encoder(), () => 2);\n * encoder.fixedSize; // 2\n * ```\n *\n * @see {@link resizeCodec}\n * @see {@link resizeDecoder}\n */\nexport function resizeEncoder<TFrom, TSize extends number, TNewSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeEncoder<TFrom, TNewSize>;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeEncoder',\n            });\n        }\n        return createEncoder({ ...encoder, fixedSize }) as TEncoder;\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: value => {\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: 'resizeEncoder',\n                });\n            }\n            return newSize;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Updates the size of a given decoder.\n *\n * This function modifies the size of a decoder using a provided transformation function.\n * For fixed-size decoders, it updates the `fixedSize` property to reflect the new size.\n * Variable-size decoders remain unchanged, as their size is determined dynamically.\n *\n * If the new size is negative, an error will be thrown.\n *\n * For more details, see {@link resizeCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The original fixed size of the decoded value.\n * @typeParam TNewSize - The new fixed size after resizing.\n *\n * @param decoder - The decoder whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new decoder with the updated size.\n *\n * @example\n * Expanding a `u16` decoder to read 4 bytes instead of 2.\n * ```ts\n * const decoder = resizeDecoder(getU16Decoder(), size => size + 2);\n * decoder.fixedSize; // 4\n * ```\n *\n * @example\n * Shrinking a `u32` decoder to only read 2 bytes.\n * ```ts\n * const decoder = resizeDecoder(getU32Decoder(), () => 2);\n * decoder.fixedSize; // 2\n * ```\n *\n * @see {@link resizeCodec}\n * @see {@link resizeEncoder}\n */\nexport function resizeDecoder<TFrom, TSize extends number, TNewSize extends number>(\n    decoder: FixedSizeDecoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeDecoder<TFrom, TNewSize>;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeDecoder',\n            });\n        }\n        return createDecoder({ ...decoder, fixedSize }) as TDecoder;\n    }\n    return decoder;\n}\n\n/**\n * Updates the size of a given codec.\n *\n * This function modifies the size of both the codec using a provided\n * transformation function. It is useful for adjusting the allocated byte size for\n * encoding and decoding without altering the underlying data structure.\n *\n * If the new size is negative, an error will be thrown.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The original fixed size of the encoded/decoded value (for fixed-size codecs).\n * @typeParam TNewSize - The new fixed size after resizing (for fixed-size codecs).\n *\n * @param codec - The codec whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new codec with the updated size.\n *\n * @example\n * Expanding a `u16` codec from 2 to 4 bytes.\n * ```ts\n * const codec = resizeCodec(getU16Codec(), size => size + 2);\n * const bytes = codec.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * const value = codec.decode(bytes);  // 0xffff (reads original two bytes)\n * ```\n *\n * @example\n * Shrinking a `u32` codec to only use 2 bytes.\n * ```ts\n * const codec = resizeCodec(getU32Codec(), () => 2);\n * codec.fixedSize; // 2\n * ```\n *\n * @remarks\n * If you only need to resize an encoder, use {@link resizeEncoder}.\n * If you only need to resize a decoder, use {@link resizeDecoder}.\n *\n * ```ts\n * const bytes = resizeEncoder(getU32Encoder(), (size) => size + 2).encode(0xffff);\n * const value = resizeDecoder(getU32Decoder(), (size) => size + 2).decode(bytes);\n * ```\n *\n * @see {@link resizeEncoder}\n * @see {@link resizeDecoder}\n */\nexport function resizeCodec<TFrom, TTo extends TFrom, TSize extends number, TNewSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeCodec<TFrom, TTo, TNewSize>;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize)) as TCodec;\n}\n","import { Codec, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { offsetDecoder, offsetEncoder } from './offset-codec';\nimport { resizeDecoder, resizeEncoder } from './resize-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Adds left padding to the given encoder, shifting the encoded value forward\n * by `offset` bytes whilst increasing the size of the encoder accordingly.\n *\n * For more details, see {@link padLeftCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to pad.\n * @param offset - The number of padding bytes to add before encoding.\n * @returns A new encoder with left padding applied.\n *\n * @example\n * ```ts\n * const encoder = padLeftEncoder(getU16Encoder(), 2);\n * const bytes = encoder.encode(0xffff); // 0x0000ffff (0xffff written at offset 2)\n * ```\n *\n * @see {@link padLeftCodec}\n * @see {@link padLeftDecoder}\n */\nexport function padLeftEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given encoder, extending the encoded value by `offset`\n * bytes whilst increasing the size of the encoder accordingly.\n *\n * For more details, see {@link padRightCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to pad.\n * @param offset - The number of padding bytes to add after encoding.\n * @returns A new encoder with right padding applied.\n *\n * @example\n * ```ts\n * const encoder = padRightEncoder(getU16Encoder(), 2);\n * const bytes = encoder.encode(0xffff); // 0xffff0000 (two extra bytes added at the end)\n * ```\n *\n * @see {@link padRightCodec}\n * @see {@link padRightDecoder}\n */\nexport function padRightEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given decoder, shifting the decoding position forward\n * by `offset` bytes whilst increasing the size of the decoder accordingly.\n *\n * For more details, see {@link padLeftCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to pad.\n * @param offset - The number of padding bytes to skip before decoding.\n * @returns A new decoder with left padding applied.\n *\n * @example\n * ```ts\n * const decoder = padLeftDecoder(getU16Decoder(), 2);\n * const value = decoder.decode(new Uint8Array([0, 0, 0x12, 0x34])); // 0xffff (reads from offset 2)\n * ```\n *\n * @see {@link padLeftCodec}\n * @see {@link padLeftEncoder}\n */\nexport function padLeftDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given decoder, extending the post-offset by `offset`\n * bytes whilst increasing the size of the decoder accordingly.\n *\n * For more details, see {@link padRightCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to pad.\n * @param offset - The number of padding bytes to skip after decoding.\n * @returns A new decoder with right padding applied.\n *\n * @example\n * ```ts\n * const decoder = padRightDecoder(getU16Decoder(), 2);\n * const value = decoder.decode(new Uint8Array([0x12, 0x34, 0, 0])); // 0xffff (ignores trailing bytes)\n * ```\n *\n * @see {@link padRightCodec}\n * @see {@link padRightEncoder}\n */\nexport function padRightDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given codec, shifting the encoding and decoding positions\n * forward by `offset` bytes whilst increasing the size of the codec accordingly.\n *\n * This ensures that values are read and written at a later position in the byte array,\n * while the padding bytes remain unused.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to pad.\n * @param offset - The number of padding bytes to add before encoding and decoding.\n * @returns A new codec with left padding applied.\n *\n * @example\n * ```ts\n * const codec = padLeftCodec(getU16Codec(), 2);\n * const bytes = codec.encode(0xffff); // 0x0000ffff (0xffff written at offset 2)\n * const value = codec.decode(bytes);  // 0xffff (reads from offset 2)\n * ```\n *\n * @remarks\n * If you only need to apply padding for encoding, use {@link padLeftEncoder}.\n * If you only need to apply padding for decoding, use {@link padLeftDecoder}.\n *\n * ```ts\n * const bytes = padLeftEncoder(getU16Encoder(), 2).encode(0xffff);\n * const value = padLeftDecoder(getU16Decoder(), 2).decode(bytes);\n * ```\n *\n * @see {@link padLeftEncoder}\n * @see {@link padLeftDecoder}\n */\nexport function padLeftCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset)) as TCodec;\n}\n\n/**\n * Adds right padding to the given codec, extending the encoded and decoded value\n * by `offset` bytes whilst increasing the size of the codec accordingly.\n *\n * The extra bytes remain unused, ensuring that the next operation starts further\n * along the byte array.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to pad.\n * @param offset - The number of padding bytes to add after encoding and decoding.\n * @returns A new codec with right padding applied.\n *\n * @example\n * ```ts\n * const codec = padRightCodec(getU16Codec(), 2);\n * const bytes = codec.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * const value = codec.decode(bytes);  // 0xffff (ignores padding bytes)\n * ```\n *\n * @remarks\n * If you only need to apply padding for encoding, use {@link padRightEncoder}.\n * If you only need to apply padding for decoding, use {@link padRightDecoder}.\n *\n * ```ts\n * const bytes = padRightEncoder(getU16Encoder(), 2).encode(0xffff);\n * const value = padRightDecoder(getU16Decoder(), 2).decode(bytes);\n * ```\n *\n * @see {@link padRightEncoder}\n * @see {@link padRightDecoder}\n */\nexport function padRightCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset)) as TCodec;\n}\n","import {\n    assertIsFixedSize,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\nfunction copySourceToTargetInReverse(\n    source: ReadonlyUint8Array,\n    target_WILL_MUTATE: Uint8Array,\n    sourceOffset: number,\n    sourceLength: number,\n    targetOffset: number = 0,\n) {\n    while (sourceOffset < --sourceLength) {\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\n\n/**\n * Reverses the bytes of a fixed-size encoder.\n *\n * Given a `FixedSizeEncoder`, this function returns a new `FixedSizeEncoder` that\n * reverses the bytes within the fixed-size byte array when encoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * For more details, see {@link reverseCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param encoder - The fixed-size encoder to reverse.\n * @returns A new encoder that writes bytes in reverse order.\n *\n * @example\n * Encoding a `u16` value in reverse order.\n * ```ts\n * const encoder = reverseEncoder(getU16Encoder({ endian: Endian.Big }));\n * const bytes = encoder.encode(0x1234); // 0x3412 (bytes are flipped)\n * ```\n *\n * @see {@link reverseCodec}\n * @see {@link reverseDecoder}\n */\nexport function reverseEncoder<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value: TFrom, bytes, offset) => {\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                bytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + encoder.fixedSize /* sourceLength */,\n            );\n            return newOffset;\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size decoder.\n *\n * Given a `FixedSizeDecoder`, this function returns a new `FixedSizeDecoder` that\n * reverses the bytes within the fixed-size byte array before decoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * For more details, see {@link reverseCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the decoded value in bytes.\n *\n * @param decoder - The fixed-size decoder to reverse.\n * @returns A new decoder that reads bytes in reverse order.\n *\n * @example\n * Decoding a reversed `u16` value.\n * ```ts\n * const decoder = reverseDecoder(getU16Decoder({ endian: Endian.Big }));\n * const value = decoder.decode(new Uint8Array([0x34, 0x12])); // 0x1234 (bytes are flipped back)\n * ```\n *\n * @see {@link reverseCodec}\n * @see {@link reverseEncoder}\n */\nexport function reverseDecoder<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset) => {\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                reversedBytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + decoder.fixedSize /* sourceLength */,\n            );\n            return decoder.read(reversedBytes, offset);\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size codec.\n *\n * Given a `FixedSizeCodec`, this function returns a new `FixedSizeCodec` that\n * reverses the bytes within the fixed-size byte array during encoding and decoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded/decoded value in bytes.\n *\n * @param codec - The fixed-size codec to reverse.\n * @returns A new codec that encodes and decodes bytes in reverse order.\n *\n * @example\n * Reversing a `u16` codec.\n * ```ts\n * const codec = reverseCodec(getU16Codec({ endian: Endian.Big }));\n * const bytes = codec.encode(0x1234); // 0x3412 (bytes are flipped)\n * const value = codec.decode(bytes);  // 0x1234 (bytes are flipped back)\n * ```\n *\n * @remarks\n * If you only need to reverse an encoder, use {@link reverseEncoder}.\n * If you only need to reverse a decoder, use {@link reverseDecoder}.\n *\n * ```ts\n * const bytes = reverseEncoder(getU16Encoder()).encode(0x1234);\n * const value = reverseDecoder(getU16Decoder()).decode(bytes);\n * ```\n *\n * @see {@link reverseEncoder}\n * @see {@link reverseDecoder}\n */\nexport function reverseCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n","import {\n    Codec,\n    createCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isVariableSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Transforms an encoder by mapping its input values.\n *\n * This function takes an existing `Encoder<A>` and returns an `Encoder<B>`, allowing values of type `B`\n * to be converted into values of type `A` before encoding. The transformation is applied via the `unmap` function.\n *\n * This is useful for handling type conversions, applying default values, or structuring data before encoding.\n *\n * For more details, see {@link transformCodec}.\n *\n * @typeParam TOldFrom - The original type expected by the encoder.\n * @typeParam TNewFrom - The new type that will be transformed before encoding.\n *\n * @param encoder - The encoder to transform.\n * @param unmap - A function that converts values of `TNewFrom` into `TOldFrom` before encoding.\n * @returns A new encoder that accepts `TNewFrom` values and transforms them before encoding.\n *\n * @example\n * Encoding a string by counting its characters and storing the length as a `u32`.\n * ```ts\n * const encoder = transformEncoder(getU32Encoder(), (value: string) => value.length);\n * encoder.encode(\"hello\"); // 0x05000000 (stores length 5)\n * ```\n *\n * @see {@link transformCodec}\n * @see {@link transformDecoder}\n */\nexport function transformEncoder<TOldFrom, TNewFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TOldFrom, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeEncoder<TNewFrom, TSize>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: VariableSizeEncoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeEncoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom> {\n    return createEncoder({\n        ...(isVariableSize(encoder)\n            ? { ...encoder, getSizeFromValue: (value: TNewFrom) => encoder.getSizeFromValue(unmap(value)) }\n            : encoder),\n        write: (value: TNewFrom, bytes, offset) => encoder.write(unmap(value), bytes, offset),\n    });\n}\n\n/**\n * Transforms a decoder by mapping its output values.\n *\n * This function takes an existing `Decoder<A>` and returns a `Decoder<B>`, allowing values of type `A`\n * to be converted into values of type `B` after decoding. The transformation is applied via the `map` function.\n *\n * This is useful for post-processing, type conversions, or enriching decoded data.\n *\n * For more details, see {@link transformCodec}.\n *\n * @typeParam TOldTo - The original type returned by the decoder.\n * @typeParam TNewTo - The new type that will be transformed after decoding.\n *\n * @param decoder - The decoder to transform.\n * @param map - A function that converts values of `TOldTo` into `TNewTo` after decoding.\n * @returns A new decoder that decodes into `TNewTo`.\n *\n * @example\n * Decoding a stored `u32` length into a string of `'x'` characters.\n * ```ts\n * const decoder = transformDecoder(getU32Decoder(), (length) => 'x'.repeat(length));\n * decoder.decode(new Uint8Array([0x05, 0x00, 0x00, 0x00])); // \"xxxxx\"\n * ```\n *\n * @see {@link transformCodec}\n * @see {@link transformEncoder}\n */\nexport function transformDecoder<TOldTo, TNewTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TOldTo, TSize>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeDecoder<TNewTo, TSize>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: VariableSizeDecoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeDecoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo> {\n    return createDecoder({\n        ...decoder,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [map(value, bytes, offset), newOffset];\n        },\n    });\n}\n\n/**\n * Transforms a codec by mapping its input and output values.\n *\n * This function takes an existing `Codec<A, B>` and returns a `Codec<C, D>`, allowing:\n * - Values of type `C` to be transformed into `A` before encoding.\n * - Values of type `B` to be transformed into `D` after decoding.\n *\n * This is useful for adapting codecs to work with different representations, handling default values, or\n * converting between primitive and structured types.\n *\n * @typeParam TOldFrom - The original type expected by the codec.\n * @typeParam TNewFrom - The new type that will be transformed before encoding.\n * @typeParam TOldTo - The original type returned by the codec.\n * @typeParam TNewTo - The new type that will be transformed after decoding.\n *\n * @param codec - The codec to transform.\n * @param unmap - A function that converts values of `TNewFrom` into `TOldFrom` before encoding.\n * @param map - A function that converts values of `TOldTo` into `TNewTo` after decoding (optional).\n * @returns A new codec that encodes `TNewFrom` and decodes into `TNewTo`.\n *\n * @example\n * Mapping a `u32` codec to encode string lengths and decode them into `'x'` characters.\n * ```ts\n * const codec = transformCodec(\n *     getU32Codec(),\n *     (value: string) => value.length, // Encode string length\n *     (length) => 'x'.repeat(length)  // Decode length into a string of 'x's\n * );\n *\n * const bytes = codec.encode(\"hello\"); // 0x05000000 (stores length 5)\n * const value = codec.decode(bytes);   // \"xxxxx\"\n * ```\n *\n * @remarks\n * If only input transformation is needed, use {@link transformEncoder}.\n * If only output transformation is needed, use {@link transformDecoder}.\n *\n * ```ts\n * const bytes = transformEncoder(getU32Encoder(), (value: string) => value.length).encode(\"hello\");\n * const value = transformDecoder(getU32Decoder(), (length) => 'x'.repeat(length)).decode(bytes);\n * ```\n *\n * @see {@link transformEncoder}\n * @see {@link transformDecoder}\n */\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom, TSize extends number>(\n    codec: FixedSizeCodec<TOldFrom, TTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeCodec<TNewFrom, TTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: VariableSizeCodec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeCodec<TNewFrom, TTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: Codec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Codec<TNewFrom, TTo>;\nexport function transformCodec<\n    TOldFrom,\n    TNewFrom,\n    TOldTo extends TOldFrom,\n    TNewTo extends TNewFrom,\n    TSize extends number,\n>(\n    codec: FixedSizeCodec<TOldFrom, TOldTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeCodec<TNewFrom, TNewTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: VariableSizeCodec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeCodec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map?: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo> {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : (codec.read as unknown as Decoder<TNewTo>['read']),\n    });\n}\n"],"names":["SolanaError"],"mappings":"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"}},
    {"offset": {"line": 2177, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/codecs-strings/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-strings/src/assertions.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-strings/src/baseX.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-strings/src/base10.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-strings/src/base16.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-strings/src/base58.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-strings/src/baseX-reslice.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-strings/src/base64.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-strings/src/null-characters.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/text-encoding-impl/src/index.browser.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-strings/src/utf8.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/**\n * Returns an encoder for base-10 strings.\n *\n * This encoder serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-10 strings.\n *\n * @example\n * Encoding a base-10 string.\n * ```ts\n * const encoder = getBase10Encoder();\n * const bytes = encoder.encode('1024'); // 0x0400\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-10 strings.\n *\n * This decoder deserializes base-10 encoded strings from a byte array.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-10 strings.\n *\n * @example\n * Decoding a base-10 string.\n * ```ts\n * const decoder = getBase10Decoder();\n * const value = decoder.decode(new Uint8Array([0x04, 0x00])); // \"1024\"\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-10 strings.\n *\n * This codec serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-10 strings.\n *\n * @example\n * Encoding and decoding a base-10 string.\n * ```ts\n * const codec = getBase10Codec();\n * const bytes = codec.encode('1024'); // 0x0400\n * const value = codec.decode(bytes);  // \"1024\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-10 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase10Codec(), 5);\n * ```\n *\n * If you need a size-prefixed base-10 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase10Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase10Encoder} and {@link getBase10Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase10Encoder().encode('1024');\n * const value = getBase10Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase10Encoder}\n * @see {@link getBase10Decoder}\n */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/**\n * Returns an encoder for base-16 (hexadecimal) strings.\n *\n * This encoder serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-16 strings.\n *\n * @example\n * Encoding a base-16 string.\n * ```ts\n * const encoder = getBase16Encoder();\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-16 (hexadecimal) strings.\n *\n * This decoder deserializes base-16 encoded strings from a byte array.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-16 strings.\n *\n * @example\n * Decoding a base-16 string.\n * ```ts\n * const decoder = getBase16Decoder();\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-16 (hexadecimal) strings.\n *\n * This codec serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-16 strings.\n *\n * @example\n * Encoding and decoding a base-16 string.\n * ```ts\n * const codec = getBase16Codec();\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-16 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase16Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-16 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase16Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase16Encoder} and {@link getBase16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase16Encoder().encode('deadface');\n * const value = getBase16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase16Encoder}\n * @see {@link getBase16Decoder}\n */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings using bit re-slicing.\n *\n * This encoder serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to an alphabet, and encoding the result into a byte array.\n * This approach is commonly used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding a base-X string using bit re-slicing.\n * ```ts\n * const encoder = getBaseXResliceEncoder('elho', 2);\n * const bytes = encoder.encode('hellolol'); // 0x4aee\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-X encoded strings using bit re-slicing.\n *\n * This decoder deserializes base-X encoded strings by re-slicing the bits of a byte array into\n * custom-sized chunks and mapping them to a specified alphabet.\n * This is typically used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings using bit re-slicing.\n *\n * @example\n * Decoding a base-X string using bit re-slicing.\n * ```ts\n * const decoder = getBaseXResliceDecoder('elho', 2);\n * const value = decoder.decode(new Uint8Array([0x4a, 0xee])); // \"hellolol\"\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-X strings using bit re-slicing.\n *\n * This codec serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to a given alphabet, and encoding the result into bytes.\n * It is particularly suited for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding and decoding a base-X string using bit re-slicing.\n * ```ts\n * const codec = getBaseXResliceCodec('elho', 2);\n * const bytes = codec.encode('hellolol'); // 0x4aee\n * const value = codec.decode(bytes);      // \"hellolol\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXResliceCodec('elho', 2), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXResliceCodec('elho', 2), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXResliceEncoder} and {@link getBaseXResliceDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXResliceEncoder('elho', 2).encode('hellolol');\n * const value = getBaseXResliceDecoder('elho', 2).decode(bytes);\n * ```\n *\n * @see {@link getBaseXResliceEncoder}\n * @see {@link getBaseXResliceDecoder}\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/**\n * Returns an encoder for base-64 strings.\n *\n * This encoder serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-64 strings.\n *\n * @example\n * Encoding a base-64 string.\n * ```ts\n * const encoder = getBase64Encoder();\n * const bytes = encoder.encode('hello+world'); // 0x85e965a3ec28ae57\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/**\n * Returns a decoder for base-64 strings.\n *\n * This decoder deserializes base-64 encoded strings from a byte array.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-64 strings.\n *\n * @example\n * Decoding a base-64 string.\n * ```ts\n * const decoder = getBase64Decoder();\n * const value = decoder.decode(new Uint8Array([0x85, 0xe9, 0x65, 0xa3, 0xec, 0x28, 0xae, 0x57])); // \"hello+world\"\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/**\n * Returns a codec for encoding and decoding base-64 strings.\n *\n * This codec serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-64 strings.\n *\n * @example\n * Encoding and decoding a base-64 string.\n * ```ts\n * const codec = getBase64Codec();\n * const bytes = codec.encode('hello+world'); // 0x85e965a3ec28ae57\n * const value = codec.decode(bytes);         // \"hello+world\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-64 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase64Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-64 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase64Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase64Encoder} and {@link getBase64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase64Encoder().encode('hello+world');\n * const value = getBase64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase64Encoder}\n * @see {@link getBase64Decoder}\n */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","/**\n * Removes all null characters (`\\u0000`) from a string.\n *\n * This function cleans a string by stripping out any null characters,\n * which are often used as padding in fixed-size string encodings.\n *\n * @param value - The string to process.\n * @returns The input string with all null characters removed.\n *\n * @example\n * Removing null characters from a string.\n * ```ts\n * removeNullCharacters('hello\\u0000\\u0000'); // \"hello\"\n * ```\n */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/**\n * Pads a string with null characters (`\\u0000`) at the end to reach a fixed length.\n *\n * If the input string is shorter than the specified length, it is padded with null characters\n * until it reaches the desired size. If it is already long enough, it remains unchanged.\n *\n * @param value - The string to pad.\n * @param chars - The total length of the resulting string, including padding.\n * @returns The input string padded with null characters up to the specified length.\n *\n * @example\n * Padding a string with null characters.\n * ```ts\n * padNullCharacters('hello', 8); // \"hello\\u0000\\u0000\\u0000\"\n * ```\n */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/**\n * Returns an encoder for UTF-8 strings.\n *\n * This encoder serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding UTF-8 strings.\n *\n * @example\n * Encoding a UTF-8 string.\n * ```ts\n * const encoder = getUtf8Encoder();\n * const bytes = encoder.encode('hello'); // 0x68656c6c6f\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for UTF-8 strings.\n *\n * This decoder deserializes UTF-8 encoded strings from a byte array.\n * It reads all available bytes starting from the given offset.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding UTF-8 strings.\n *\n * @example\n * Decoding a UTF-8 string.\n * ```ts\n * const decoder = getUtf8Decoder();\n * const value = decoder.decode(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f])); // \"hello\"\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding UTF-8 strings.\n *\n * This codec serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding UTF-8 strings.\n *\n * @example\n * Encoding and decoding a UTF-8 string.\n * ```ts\n * const codec = getUtf8Codec();\n * const bytes = codec.encode('hello'); // 0x68656c6c6f\n * const value = codec.decode(bytes);   // \"hello\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size UTF-8 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 5);\n * ```\n *\n * If you need a size-prefixed UTF-8 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getUtf8Encoder} and {@link getUtf8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getUtf8Encoder().encode('hello');\n * const value = getUtf8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getUtf8Encoder}\n * @see {@link getUtf8Decoder}\n */\nexport const getUtf8Codec = (): VariableSizeCodec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n"],"names":["alphabet","createEncoder","SolanaError","SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE","createDecoder","combineCodec","TextDecoder","TextEncoder"],"mappings":"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"}},
    {"offset": {"line": 2522, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/assertions/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/assertions/src/crypto.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/assertions/src/subtle-crypto.ts"],"sourcesContent":["import { SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED, SolanaError } from '@solana/errors';\n\n/**\n * Throws an exception unless {@link Crypto#getRandomValues | `crypto.getRandomValues()`} is\n * available in the current JavaScript environment.\n */\nexport function assertPRNGIsAvailable() {\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.getRandomValues !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED);\n    }\n}\n","import {\n    SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT,\n    SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED,\n    SolanaError,\n} from '@solana/errors';\n\nfunction assertIsSecureContext() {\n    if (__BROWSER__ && !globalThis.isSecureContext) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT);\n    }\n}\n\nlet cachedEd25519Decision: PromiseLike<boolean> | boolean | undefined;\nasync function isEd25519CurveSupported(subtle: SubtleCrypto): Promise<boolean> {\n    if (cachedEd25519Decision === undefined) {\n        cachedEd25519Decision = new Promise(resolve => {\n            subtle\n                .generateKey('Ed25519', /* extractable */ false, ['sign', 'verify'])\n                .then(() => {\n                    resolve((cachedEd25519Decision = true));\n                })\n                .catch(() => {\n                    resolve((cachedEd25519Decision = false));\n                });\n        });\n    }\n    if (typeof cachedEd25519Decision === 'boolean') {\n        return cachedEd25519Decision;\n    } else {\n        return await cachedEd25519Decision;\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#digest | `crypto.subtle.digest()`} is available in\n * the current JavaScript environment.\n */\nexport function assertDigestCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.digest !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED);\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#generateKey | `crypto.subtle.generateKey()`} is\n * available in the current JavaScript environment and has support for the Ed25519 curve.\n */\nexport async function assertKeyGenerationIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.generateKey !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED);\n    }\n    if (!(await isEd25519CurveSupported(globalThis.crypto.subtle))) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED);\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#exportKey | `crypto.subtle.exportKey()`} is\n * available in the current JavaScript environment.\n */\nexport function assertKeyExporterIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.exportKey !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED);\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#sign | `crypto.subtle.sign()`} is available in the\n * current JavaScript environment.\n */\nexport function assertSigningCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.sign !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED);\n    }\n}\n/**\n * Throws an exception unless {@link SubtleCrypto#verify | `crypto.subtle.verify()`} is available in\n * the current JavaScript environment.\n */\nexport function assertVerificationCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.verify !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED);\n    }\n}\n"],"names":["SolanaError"],"mappings":";;;;;;;;;;;;;;;;;AAMO,SAAS,qBAAA,GAAwB;IACpC,IAAI,OAAO,WAAW,MAAA,KAAW,WAAA,IAAe,OAAO,UAAA,CAAW,MAAA,CAAO,eAAA,KAAoB,UAAA,EAAY;QACrG,MAAM,IAAI,iLAAA,CAAY,gOAA0D,CAAA;IACpF;AACJ;ACCA,SAAS,qBAAA,GAAwB;IAC7B,IAAmB,CAAC,WAAW,eAAA,EAAiB;QAC5C,MAAM,IAAIA,iLAAAA,CAAY,iOAA2D,CAAA;IACrF;AACJ;AAEA,IAAI,qBAAA;AACJ,eAAe,wBAAwB,MAAA,EAAwC;IAC3E,IAAI,0BAA0B,KAAA,CAAA,EAAW;QACrC,qBAAA,GAAwB,IAAI,QAAQ,CAAA,OAAA,KAAW;YAC3C,MAAA,CACK,WAAA,CAAY,SAAA,EAAA,eAAA,GAA6B,KAAA,EAAO;gBAAC;gBAAQ,QAAQ;aAAA,EACjE,IAAA,CAAK,MAAM;gBACR,OAAA,CAAS,wBAAwB,IAAK,CAAA;YAC1C,CAAC,CAAA,CACA,KAAA,CAAM,MAAM;gBACT,OAAA,CAAS,wBAAwB,KAAM,CAAA;YAC3C,CAAC,CAAA;QACT,CAAC,CAAA;IACL;IACA,IAAI,OAAO,0BAA0B,SAAA,EAAW;QAC5C,OAAO,qBAAA;IACX,CAAA,MAAO;QACH,OAAO,MAAM,qBAAA;IACjB;AACJ;AAMO,SAAS,iCAAA,GAAoC;IAChD,qBAAA,EAAsB;IACtB,IAAI,OAAO,WAAW,MAAA,KAAW,WAAA,IAAe,OAAO,UAAA,CAAW,MAAA,CAAO,MAAA,EAAQ,MAAA,KAAW,UAAA,EAAY;QACpG,MAAM,IAAIA,iLAAAA,CAAY,uNAAiD,CAAA;IAC3E;AACJ;AAMA,eAAsB,8BAAA,GAAiC;IACnD,qBAAA,EAAsB;IACtB,IAAI,OAAO,WAAW,MAAA,KAAW,WAAA,IAAe,OAAO,UAAA,CAAW,MAAA,CAAO,MAAA,EAAQ,WAAA,KAAgB,UAAA,EAAY;QACzG,MAAM,IAAIA,iLAAAA,CAAY,kOAA4D,CAAA;IACtF;IACA,IAAI,CAAE,MAAM,uBAAA,CAAwB,UAAA,CAAW,MAAA,CAAO,MAAM,CAAA,EAAI;QAC5D,MAAM,IAAIA,iLAAAA,CAAY,kOAA4D,CAAA;IACtF;AACJ;AAMO,SAAS,4BAAA,GAA+B;IAC3C,qBAAA,EAAsB;IACtB,IAAI,OAAO,WAAW,MAAA,KAAW,WAAA,IAAe,OAAO,UAAA,CAAW,MAAA,CAAO,MAAA,EAAQ,SAAA,KAAc,UAAA,EAAY;QACvG,MAAM,IAAIA,iLAAAA,CAAY,gOAA0D,CAAA;IACpF;AACJ;AAMO,SAAS,kCAAA,GAAqC;IACjD,qBAAA,EAAsB;IACtB,IAAI,OAAO,WAAW,MAAA,KAAW,WAAA,IAAe,OAAO,UAAA,CAAW,MAAA,CAAO,MAAA,EAAQ,IAAA,KAAS,UAAA,EAAY;QAClG,MAAM,IAAIA,iLAAAA,CAAY,8NAAwD,CAAA;IAClF;AACJ;AAKO,SAAS,uCAAA,GAA0C;IACtD,qBAAA,EAAsB;IACtB,IAAI,OAAO,WAAW,MAAA,KAAW,WAAA,IAAe,OAAO,UAAA,CAAW,MAAA,CAAO,MAAA,EAAQ,MAAA,KAAW,UAAA,EAAY;QACpG,MAAM,IAAIA,iLAAAA,CAAY,gOAA0D,CAAA;IACpF;AACJ"}},
    {"offset": {"line": 2609, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/addresses/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/addresses/src/address.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/addresses/src/vendor/noble/ed25519.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/addresses/src/curve-internal.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/addresses/src/curve.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/addresses/src/program-derived-address.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/addresses/src/public-key.ts"],"sourcesContent":["import {\n    combineCodec,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    transformEncoder,\n} from '@solana/codecs-core';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\n/**\n * Represents a string that validates as a Solana address. Functions that require well-formed\n * addresses should specify their inputs in terms of this type.\n *\n * Whenever you need to validate an arbitrary string as a base58-encoded address, use the\n * {@link address}, {@link assertIsAddress}, or {@link isAddress} functions in this package.\n */\nexport type Address<TAddress extends string = string> = Brand<EncodedString<TAddress, 'base58'>, 'Address'>;\n\nlet memoizedBase58Encoder: Encoder<string> | undefined;\nlet memoizedBase58Decoder: Decoder<string> | undefined;\n\nfunction getMemoizedBase58Encoder(): Encoder<string> {\n    if (!memoizedBase58Encoder) memoizedBase58Encoder = getBase58Encoder();\n    return memoizedBase58Encoder;\n}\n\nfunction getMemoizedBase58Decoder(): Decoder<string> {\n    if (!memoizedBase58Decoder) memoizedBase58Decoder = getBase58Decoder();\n    return memoizedBase58Decoder;\n}\n\n/**\n * A type guard that returns `true` if the input string conforms to the {@link Address} type, and\n * refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isAddress } from '@solana/addresses';\n *\n * if (isAddress(ownerAddress)) {\n *     // At this point, `ownerAddress` has been refined to a\n *     // `Address` that can be used with the RPC.\n *     const { value: lamports } = await rpc.getBalance(ownerAddress).send();\n *     setBalanceLamports(lamports);\n * } else {\n *     setError(`${ownerAddress} is not an address`);\n * }\n * ```\n */\nexport function isAddress(putativeAddress: string): putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    try {\n        return base58Encoder.encode(putativeAddress).byteLength === 32;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * From time to time you might acquire a string, that you expect to validate as an address or public\n * key, from an untrusted network API or user input. Use this function to assert that such an\n * arbitrary string is a base58-encoded address.\n *\n * @example\n * ```ts\n * import { assertIsAddress } from '@solana/addresses';\n *\n * // Imagine a function that fetches an account's balance when a user submits a form.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const address: string = accountAddressInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `address` to `Address`.\n *         assertIsAddress(address);\n *         // At this point, `address` is an `Address` that can be used with the RPC.\n *         const balanceInLamports = await rpc.getBalance(address).send();\n *     } catch (e) {\n *         // `address` turned out not to be a base58-encoded address\n *     }\n * }\n * ```\n */\nexport function assertIsAddress(putativeAddress: string): asserts putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeAddress.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeAddress);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\n/**\n * Combines _asserting_ that a string is an address with _coercing_ it to the {@link Address} type.\n * It's most useful with untrusted input.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n *\n * await transfer(address(fromAddress), address(toAddress), lamports(100000n));\n * ```\n *\n * > [!TIP]\n * > When starting from a known-good address as a string, it's more efficient to typecast it rather\n * than to use the {@link address} helper, because the helper unconditionally performs validation on\n * its input.\n * >\n * > ```ts\n * > import { Address } from '@solana/addresses';\n * >\n * > const MEMO_PROGRAM_ADDRESS =\n * >     'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr' as Address<'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'>;\n * > ```\n */\nexport function address<TAddress extends string = string>(putativeAddress: TAddress): Address<TAddress> {\n    assertIsAddress(putativeAddress);\n    return putativeAddress as Address<TAddress>;\n}\n\n/**\n * Returns an encoder that you can use to encode a base58-encoded address to a byte array.\n *\n * @example\n * ```ts\n * import { getAddressEncoder } from '@solana/addresses';\n *\n * const address = 'B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka' as Address;\n * const addressEncoder = getAddressEncoder();\n * const addressBytes = addressEncoder.encode(address);\n * // Uint8Array(32) [\n * //   150, 183, 190,  48, 171,   8, 39, 156,\n * //   122, 213, 172, 108, 193,  95, 26, 158,\n * //   149, 243, 115, 254,  20, 200, 36,  30,\n * //   248, 179, 178, 232, 220,  89, 53, 127\n * // ]\n * ```\n */\nexport function getAddressEncoder(): FixedSizeEncoder<Address, 32> {\n    return transformEncoder(fixEncoderSize(getMemoizedBase58Encoder(), 32), putativeAddress =>\n        address(putativeAddress),\n    );\n}\n\n/**\n * Returns a decoder that you can use to convert an array of 32 bytes representing an address to the\n * base58-encoded representation of that address.\n *\n * @example\n * ```ts\n * import { getAddressDecoder } from '@solana/addresses';\n *\n * const addressBytes = new Uint8Array([\n *     150, 183, 190,  48, 171,   8, 39, 156,\n *     122, 213, 172, 108, 193,  95, 26, 158,\n *     149, 243, 115, 254,  20, 200, 36,  30,\n *     248, 179, 178, 232, 220,  89, 53, 127\n * ]);\n * const addressDecoder = getAddressDecoder();\n * const address = addressDecoder.decode(addressBytes); // B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka\n * ```\n */\nexport function getAddressDecoder(): FixedSizeDecoder<Address, 32> {\n    return fixDecoderSize(getMemoizedBase58Decoder(), 32) as FixedSizeDecoder<Address, 32>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a base-58 encoded address.\n *\n * @see {@link getAddressDecoder}\n * @see {@link getAddressEncoder}\n */\nexport function getAddressCodec(): FixedSizeCodec<Address, Address, 32> {\n    return combineCodec(getAddressEncoder(), getAddressDecoder());\n}\n\nexport function getAddressComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n","/**!\n * noble-ed25519\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2019 Paul Miller (https://paulmillr.com)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the “Software”), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nconst D = 37095705934669439343138083508754565189542113879843219016388785533085940283555n;\nconst P = 57896044618658097711785492504343953926634992332820282019728792003956564819949n; // 2n ** 255n - 19n;  ed25519 is twisted edwards curve\nconst RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n; // √-1\n\n// mod division\nfunction mod(a: bigint): bigint {\n    const r = a % P;\n    return r >= 0n ? r : P + r;\n}\nfunction pow2(x: bigint, power: bigint): bigint {\n    // pow2(x, 4) == x^(2^4)\n    let r = x;\n    while (power-- > 0n) {\n        r *= r;\n        r %= P;\n    }\n    return r;\n}\nfunction pow_2_252_3(x: bigint): bigint {\n    // x^(2^252-3) unrolled util for square root\n    const x2 = (x * x) % P; // x^2,       bits 1\n    const b2 = (x2 * x) % P; // x^3,       bits 11\n    const b4 = (pow2(b2, 2n) * b2) % P; // x^(2^4-1), bits 1111\n    const b5 = (pow2(b4, 1n) * x) % P; // x^(2^5-1), bits 11111\n    const b10 = (pow2(b5, 5n) * b5) % P; // x^(2^10)\n    const b20 = (pow2(b10, 10n) * b10) % P; // x^(2^20)\n    const b40 = (pow2(b20, 20n) * b20) % P; // x^(2^40)\n    const b80 = (pow2(b40, 40n) * b40) % P; // x^(2^80)\n    const b160 = (pow2(b80, 80n) * b80) % P; // x^(2^160)\n    const b240 = (pow2(b160, 80n) * b80) % P; // x^(2^240)\n    const b250 = (pow2(b240, 10n) * b10) % P; // x^(2^250)\n    const pow_p_5_8 = (pow2(b250, 2n) * x) % P; // < To pow to (p+3)/8, multiply it by x.\n    return pow_p_5_8;\n}\nfunction uvRatio(u: bigint, v: bigint): bigint | null {\n    // for sqrt comp\n    const v3 = mod(v * v * v); // v³\n    const v7 = mod(v3 * v3 * v); // v⁷\n    const pow = pow_2_252_3(u * v7); // (uv⁷)^(p-5)/8\n    let x = mod(u * v3 * pow); // (uv³)(uv⁷)^(p-5)/8\n    const vx2 = mod(v * x * x); // vx²\n    const root1 = x; // First root candidate\n    const root2 = mod(x * RM1); // Second root candidate; RM1 is √-1\n    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n    const useRoot2 = vx2 === mod(-u); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === mod(-u * RM1); // There is no valid root, vx² = -u√-1\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n    if ((mod(x) & 1n) === 1n) x = mod(-x); // edIsNegative\n    if (!useRoot1 && !useRoot2) {\n        return null;\n    }\n    return x;\n}\n// https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.3\nexport function pointIsOnCurve(y: bigint, lastByte: number): boolean {\n    const y2 = mod(y * y); // y²\n    const u = mod(y2 - 1n); // u=y²-1\n    const v = mod(D * y2 + 1n);\n    const x = uvRatio(u, v); // (uv³)(uv⁷)^(p-5)/8; square root\n    if (x === null) {\n        return false;\n    }\n    const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n    if (x === 0n && isLastByteOdd) {\n        return false;\n    }\n    return true;\n}\n","import { ReadonlyUint8Array } from '@solana/codecs-core';\n\nimport { pointIsOnCurve } from './vendor/noble/ed25519';\n\nfunction byteToHex(byte: number): string {\n    const hexString = byte.toString(16);\n    if (hexString.length === 1) {\n        return `0${hexString}`;\n    } else {\n        return hexString;\n    }\n}\n\nfunction decompressPointBytes(bytes: ReadonlyUint8Array): bigint {\n    const hexString = bytes.reduce((acc, byte, ii) => `${byteToHex(ii === 31 ? byte & ~0x80 : byte)}${acc}`, '');\n    const integerLiteralString = `0x${hexString}`;\n    return BigInt(integerLiteralString);\n}\n\nexport function compressedPointBytesAreOnCurve(bytes: ReadonlyUint8Array): boolean {\n    if (bytes.byteLength !== 32) {\n        return false;\n    }\n    const y = decompressPointBytes(bytes);\n    return pointIsOnCurve(y, bytes[31]);\n}\n","import { SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS, SolanaError } from '@solana/errors';\nimport type { AffinePoint } from '@solana/nominal-types';\n\nimport { type Address, getAddressCodec } from './address';\nimport { compressedPointBytesAreOnCurve } from './curve-internal';\n\n/**\n * Represents an {@link Address} that validates as being off-curve. Functions that require off-curve\n * addresses should specify their inputs in terms of this type.\n *\n * Whenever you need to validate an address as being off-curve, use the {@link offCurveAddress},\n * {@link assertIsOffCurveAddress}, or {@link isOffCurveAddress} functions in this package.\n */\nexport type OffCurveAddress<TAddress extends string = string> = AffinePoint<Address<TAddress>, 'invalid'>;\n\n/**\n * A type guard that returns `true` if the input address conforms to the {@link OffCurveAddress}\n * type, and refines its type for use in your application.\n *\n * @example\n * ```ts\n * import { isOffCurveAddress } from '@solana/addresses';\n *\n * if (isOffCurveAddress(accountAddress)) {\n *     // At this point, `accountAddress` has been refined to a\n *     // `OffCurveAddress` that can be used within your business logic.\n *     const { value: account } = await rpc.getAccountInfo(accountAddress).send();\n * } else {\n *     setError(`${accountAddress} is not off-curve`);\n * }\n * ```\n */\nexport function isOffCurveAddress<TAddress extends Address>(\n    putativeOffCurveAddress: TAddress,\n): putativeOffCurveAddress is OffCurveAddress<TAddress> {\n    const addressBytes = getAddressCodec().encode(putativeOffCurveAddress);\n    return compressedPointBytesAreOnCurve(addressBytes) === false;\n}\n\n/**\n * From time to time you might acquire an {@link Address}, that you expect to validate as an\n * off-curve address, from an untrusted source. Use this function to assert that such an address is\n * off-curve.\n *\n * @example\n * ```ts\n * import { assertIsOffCurveAddress } from '@solana/addresses';\n *\n * // Imagine a function that fetches an account's balance when a user submits a form.\n * function handleSubmit() {\n *     // We know only that the input conforms to the `string` type.\n *     const address: string = accountAddressInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `address` to `Address`.\n *         assertIsAddress(address);\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `address` to `OffCurveAddress`.\n *         assertIsOffCurveAddress(address);\n *         // At this point, `address` is an `OffCurveAddress` that can be used with the RPC.\n *         const balanceInLamports = await rpc.getBalance(address).send();\n *     } catch (e) {\n *         // `address` turned out to NOT be a base58-encoded off-curve address\n *     }\n * }\n * ```\n */\nexport function assertIsOffCurveAddress<TAddress extends Address>(\n    putativeOffCurveAddress: TAddress,\n): asserts putativeOffCurveAddress is OffCurveAddress<TAddress> {\n    if (!isOffCurveAddress(putativeOffCurveAddress)) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS);\n    }\n}\n\n/**\n * Combines _asserting_ that an {@link Address} is off-curve with _coercing_ it to the\n * {@link OffCurveAddress} type. It's most useful with untrusted input.\n */\nexport function offCurveAddress<TAddress extends Address>(\n    putativeOffCurveAddress: TAddress,\n): OffCurveAddress<TAddress> {\n    assertIsOffCurveAddress(putativeOffCurveAddress);\n    return putativeOffCurveAddress;\n}\n","import { assertDigestCapabilityIsAvailable } from '@solana/assertions';\nimport { bytesEqual, type ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\nimport { Address, assertIsAddress, getAddressCodec, isAddress } from './address';\nimport { compressedPointBytesAreOnCurve } from './curve-internal';\n\n/**\n * A tuple representing a program derived address (derived from the address of some program and a\n * set of seeds) and the associated bump seed used to ensure that the address, as derived, does not\n * fall on the Ed25519 curve.\n *\n * Whenever you need to validate an arbitrary tuple as one that represents a program derived\n * address, use the {@link assertIsProgramDerivedAddress} or {@link isProgramDerivedAddress}\n * functions in this package.\n */\nexport type ProgramDerivedAddress<TAddress extends string = string> = Readonly<\n    [Address<TAddress>, ProgramDerivedAddressBump]\n>;\n\n/**\n * Represents an integer in the range [0,255] used in the derivation of a program derived address to\n * ensure that it does not fall on the Ed25519 curve.\n */\nexport type ProgramDerivedAddressBump = Brand<number, 'ProgramDerivedAddressBump'>;\n\n/**\n * A type guard that returns `true` if the input tuple conforms to the {@link ProgramDerivedAddress}\n * type, and refines its type for use in your program.\n *\n * @see The {@link isAddress} function for an example of how to use a type guard.\n */\nexport function isProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): value is ProgramDerivedAddress<TAddress> {\n    return (\n        Array.isArray(value) &&\n        value.length === 2 &&\n        typeof value[0] === 'string' &&\n        typeof value[1] === 'number' &&\n        value[1] >= 0 &&\n        value[1] <= 255 &&\n        isAddress(value[0])\n    );\n}\n\n/**\n * In the event that you receive an address/bump-seed tuple from some untrusted source, use this\n * function to assert that it conforms to the {@link ProgramDerivedAddress} interface.\n *\n * @see The {@link assertIsAddress} function for an example of how to use an assertion function.\n */\nexport function assertIsProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): asserts value is ProgramDerivedAddress<TAddress> {\n    const validFormat =\n        Array.isArray(value) && value.length === 2 && typeof value[0] === 'string' && typeof value[1] === 'number';\n    if (!validFormat) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MALFORMED_PDA);\n    }\n    if (value[1] < 0 || value[1] > 255) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE, {\n            bump: value[1],\n        });\n    }\n    assertIsAddress(value[0]);\n}\n\ntype ProgramDerivedAddressInput = Readonly<{\n    programAddress: Address;\n    seeds: Seed[];\n}>;\n\ntype SeedInput = Readonly<{\n    baseAddress: Address;\n    programAddress: Address;\n    seed: Seed;\n}>;\n\ntype Seed = ReadonlyUint8Array | string;\n\nconst MAX_SEED_LENGTH = 32;\nconst MAX_SEEDS = 16;\nconst PDA_MARKER_BYTES = [\n    // The string 'ProgramDerivedAddress'\n    80, 114, 111, 103, 114, 97, 109, 68, 101, 114, 105, 118, 101, 100, 65, 100, 100, 114, 101, 115, 115,\n] as const;\n\nasync function createProgramDerivedAddress({ programAddress, seeds }: ProgramDerivedAddressInput): Promise<Address> {\n    assertDigestCapabilityIsAvailable();\n    if (seeds.length > MAX_SEEDS) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED, {\n            actual: seeds.length,\n            maxSeeds: MAX_SEEDS,\n        });\n    }\n    let textEncoder: TextEncoder;\n    const seedBytes = seeds.reduce((acc, seed, ii) => {\n        const bytes = typeof seed === 'string' ? (textEncoder ||= new TextEncoder()).encode(seed) : seed;\n        if (bytes.byteLength > MAX_SEED_LENGTH) {\n            throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n                actual: bytes.byteLength,\n                index: ii,\n                maxSeedLength: MAX_SEED_LENGTH,\n            });\n        }\n        acc.push(...bytes);\n        return acc;\n    }, [] as number[]);\n    const base58EncodedAddressCodec = getAddressCodec();\n    const programAddressBytes = base58EncodedAddressCodec.encode(programAddress);\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...seedBytes, ...programAddressBytes, ...PDA_MARKER_BYTES]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n    if (compressedPointBytesAreOnCurve(addressBytes)) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE);\n    }\n    return base58EncodedAddressCodec.decode(addressBytes);\n}\n\n/**\n * Given a program's {@link Address} and up to 16 {@link Seed | Seeds}, this method will return the\n * program derived address (PDA) associated with each.\n *\n * @example\n * ```ts\n * import { getAddressEncoder, getProgramDerivedAddress } from '@solana/addresses';\n *\n * const addressEncoder = getAddressEncoder();\n * const [pda, bumpSeed] = await getProgramDerivedAddress({\n *     programAddress: 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address,\n *     seeds: [\n *         // Owner\n *         addressEncoder.encode('9fYLFVoVqwH37C3dyPi6cpeobfbQ2jtLpN5HgAYDDdkm' as Address),\n *         // Token program\n *         addressEncoder.encode('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address),\n *         // Mint\n *         addressEncoder.encode('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v' as Address),\n *     ],\n * });\n * ```\n */\nexport async function getProgramDerivedAddress({\n    programAddress,\n    seeds,\n}: ProgramDerivedAddressInput): Promise<ProgramDerivedAddress> {\n    let bumpSeed = 255;\n    while (bumpSeed > 0) {\n        try {\n            const address = await createProgramDerivedAddress({\n                programAddress,\n                seeds: [...seeds, new Uint8Array([bumpSeed])],\n            });\n            return [address, bumpSeed as ProgramDerivedAddressBump];\n        } catch (e) {\n            if (isSolanaError(e, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE)) {\n                bumpSeed--;\n            } else {\n                throw e;\n            }\n        }\n    }\n    throw new SolanaError(SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED);\n}\n\n/**\n * Returns a base58-encoded address derived from some base address, some program address, and a seed\n * string or byte array.\n *\n * @example\n * ```ts\n * import { createAddressWithSeed } from '@solana/addresses';\n *\n * const derivedAddress = await createAddressWithSeed({\n *     // The private key associated with this address will be able to sign for `derivedAddress`.\n *     baseAddress: 'B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka' as Address,\n *     // Only this program will be able to write data to this account.\n *     programAddress: '445erYq578p2aERrGW9mn9KiYe3fuG6uHdcJ2LPPShGw' as Address,\n *     seed: 'data-account',\n * });\n * ```\n */\nexport async function createAddressWithSeed({ baseAddress, programAddress, seed }: SeedInput): Promise<Address> {\n    const { encode, decode } = getAddressCodec();\n\n    const seedBytes = typeof seed === 'string' ? new TextEncoder().encode(seed) : seed;\n    if (seedBytes.byteLength > MAX_SEED_LENGTH) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n            actual: seedBytes.byteLength,\n            index: 0,\n            maxSeedLength: MAX_SEED_LENGTH,\n        });\n    }\n\n    const programAddressBytes = encode(programAddress);\n    if (\n        programAddressBytes.length >= PDA_MARKER_BYTES.length &&\n        bytesEqual(programAddressBytes.slice(-PDA_MARKER_BYTES.length), new Uint8Array(PDA_MARKER_BYTES))\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER);\n    }\n\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...encode(baseAddress), ...seedBytes, ...programAddressBytes]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n\n    return decode(addressBytes);\n}\n","import { assertKeyExporterIsAvailable } from '@solana/assertions';\nimport { SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY, SolanaError } from '@solana/errors';\n\nimport { Address, getAddressDecoder, getAddressEncoder } from './address';\n\n/**\n * Given a public {@link CryptoKey}, this method will return its associated {@link Address}.\n *\n * @example\n * ```ts\n * import { getAddressFromPublicKey } from '@solana/addresses';\n *\n * const address = await getAddressFromPublicKey(publicKey);\n * ```\n */\nexport async function getAddressFromPublicKey(publicKey: CryptoKey): Promise<Address> {\n    assertKeyExporterIsAvailable();\n    if (publicKey.type !== 'public' || publicKey.algorithm.name !== 'Ed25519') {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY);\n    }\n    const publicKeyBytes = await crypto.subtle.exportKey('raw', publicKey);\n    return getAddressDecoder().decode(new Uint8Array(publicKeyBytes));\n}\n\n/**\n * Given an {@link Address}, return a {@link CryptoKey} that can be used to verify signatures.\n *\n * @example\n * ```ts\n * import { getAddressFromPublicKey } from '@solana/addresses';\n *\n * const publicKey = await getPublicKeyFromAddress(address);\n * ```\n */\nexport async function getPublicKeyFromAddress(address: Address) {\n    const addressBytes = getAddressEncoder().encode(address);\n    return await crypto.subtle.importKey('raw', addressBytes, { name: 'Ed25519' }, true /* extractable */, ['verify']);\n}\n"],"names":["SolanaError","address"],"mappings":"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"}},
    {"offset": {"line": 2961, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/keys/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/keys/src/algorithm.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/keys/src/private-key.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/keys/src/public-key.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/keys/src/signatures.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/keys/src/key-pair.ts"],"sourcesContent":["export const ED25519_ALGORITHM_IDENTIFIER =\n    // Resist the temptation to convert this to a simple string; As of version 133.0.3, Firefox\n    // requires the object form of `AlgorithmIdentifier` and will throw a `DOMException` otherwise.\n    Object.freeze({ name: 'Ed25519' });\n","import { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport { ED25519_ALGORITHM_IDENTIFIER } from './algorithm';\n\nfunction addPkcs8Header(bytes: ReadonlyUint8Array): ReadonlyUint8Array {\n    // prettier-ignore\n    return new Uint8Array([\n        /**\n         * PKCS#8 header\n         */\n        0x30, // ASN.1 sequence tag\n        0x2e, // Length of sequence (46 more bytes)\n\n            0x02, // ASN.1 integer tag\n            0x01, // Length of integer\n                0x00, // Version number\n\n            0x30, // ASN.1 sequence tag\n            0x05, // Length of sequence\n                0x06, // ASN.1 object identifier tag\n                0x03, // Length of object identifier\n                    // Edwards curve algorithms identifier https://oid-rep.orange-labs.fr/get/1.3.101.112\n                        0x2b, // iso(1) / identified-organization(3) (The first node is multiplied by the decimal 40 and the result is added to the value of the second node)\n                        0x65, // thawte(101)\n                    // Ed25519 identifier\n                        0x70, // id-Ed25519(112)\n\n        /**\n         * Private key payload\n         */\n        0x04, // ASN.1 octet string tag\n        0x22, // String length (34 more bytes)\n\n            // Private key bytes as octet string\n            0x04, // ASN.1 octet string tag\n            0x20, // String length (32 bytes)\n\n        ...bytes\n    ]);\n}\n\n/**\n * Given a private key represented as a 32-byte `Uint8Array`, creates an Ed25519 private key for use\n * with other methods in this package that accept\n * [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) objects.\n *\n * @param bytes 32 bytes that represent the private key\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the private\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import { createPrivateKeyFromBytes } from '@solana/keys';\n *\n * const privateKey = await createPrivateKeyFromBytes(new Uint8Array([...]));\n * const extractablePrivateKey = await createPrivateKeyFromBytes(new Uint8Array([...]), true);\n * ```\n */\nexport async function createPrivateKeyFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKey> {\n    const actualLength = bytes.byteLength;\n    if (actualLength !== 32) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, {\n            actualLength,\n        });\n    }\n    const privateKeyBytesPkcs8 = addPkcs8Header(bytes);\n    return await crypto.subtle.importKey('pkcs8', privateKeyBytesPkcs8, ED25519_ALGORITHM_IDENTIFIER, extractable, [\n        'sign',\n    ]);\n}\n","import { assertKeyExporterIsAvailable } from '@solana/assertions';\nimport { SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, SolanaError } from '@solana/errors';\n\n/**\n * Given an extractable [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * private key, gets the corresponding public key as a\n * [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey).\n *\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the public\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import { createPrivateKeyFromBytes, getPublicKeyFromPrivateKey } from '@solana/keys';\n *\n * const privateKey = await createPrivateKeyFromBytes(new Uint8Array([...]), true);\n *\n * const publicKey = await getPublicKeyFromPrivateKey(privateKey);\n * const extractablePublicKey = await getPublicKeyFromPrivateKey(privateKey, true);\n * ```\n */\nexport async function getPublicKeyFromPrivateKey(\n    privateKey: CryptoKey,\n    extractable: boolean = false,\n): Promise<CryptoKey> {\n    assertKeyExporterIsAvailable();\n\n    if (privateKey.extractable === false) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, { key: privateKey });\n    }\n\n    // Export private key.\n    const jwk = await crypto.subtle.exportKey('jwk', privateKey);\n\n    // Import public key.\n    return await crypto.subtle.importKey(\n        'jwk',\n        {\n            crv /* curve */: 'Ed25519',\n            ext /* extractable */: extractable,\n            key_ops /* key operations */: ['verify'],\n            kty /* key type */: 'OKP' /* octet key pair */,\n            x /* public key x-coordinate */: jwk.x,\n        },\n        'Ed25519',\n        extractable,\n        ['verify'],\n    );\n}\n","import { assertSigningCapabilityIsAvailable, assertVerificationCapabilityIsAvailable } from '@solana/assertions';\nimport { Encoder, ReadonlyUint8Array } from '@solana/codecs-core';\nimport { getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\nimport { ED25519_ALGORITHM_IDENTIFIER } from './algorithm';\n\n/**\n * A 64-byte Ed25519 signature as a base58-encoded string.\n */\nexport type Signature = Brand<EncodedString<string, 'base58'>, 'Signature'>;\n/**\n * A 64-byte Ed25519 signature.\n *\n * Whenever you need to verify that a particular signature is, in fact, the one that would have been\n * produced by signing some known bytes using the private key associated with some known public key,\n * use the {@link verifySignature} function in this package.\n */\nexport type SignatureBytes = Brand<Uint8Array, 'SignatureBytes'>;\n\nlet base58Encoder: Encoder<string> | undefined;\n\n/**\n * Asserts that an arbitrary string is a base58-encoded Ed25519 signature.\n *\n * Useful when you receive a string from user input or an untrusted network API that you expect to\n * represent an Ed25519 signature (eg. of a transaction).\n *\n * @example\n * ```ts\n * import { assertIsSignature } from '@solana/keys';\n *\n * // Imagine a function that asserts whether a user-supplied signature is valid or not.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const signature: string = signatureInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `signature` to `Signature`.\n *         assertIsSignature(signature);\n *         // At this point, `signature` is a `Signature` that can be used with the RPC.\n *         const {\n *             value: [status],\n *         } = await rpc.getSignatureStatuses([signature]).send();\n *     } catch (e) {\n *         // `signature` turned out not to be a base58-encoded signature\n *     }\n * }\n * ```\n */\nexport function assertIsSignature(putativeSignature: string): asserts putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeSignature.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    assertIsSignatureBytes(bytes);\n}\n\n/**\n * Asserts that an arbitrary `ReadonlyUint8Array` is an Ed25519 signature.\n *\n * Useful when you receive a `ReadonlyUint8Array` from an external interface (like the browser wallets' `signMessage` API) that you expect to\n * represent an Ed25519 signature.\n *\n * @example\n * ```ts\n * import { assertIsSignatureBytes } from '@solana/keys';\n *\n * // Imagine a function that verifies a signature.\n * function verifySignature() {\n *     // We know only that the input conforms to the `ReadonlyUint8Array` type.\n *     const signatureBytes: ReadonlyUint8Array = signatureBytesInput;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `signatureBytes` to `SignatureBytes`.\n *         assertIsSignatureBytes(signatureBytes);\n *         // At this point, `signatureBytes` is a `SignatureBytes` that can be used with `verifySignature`.\n *         if (!(await verifySignature(publicKey, signatureBytes, data))) {\n *             throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n *         }\n *     } catch (e) {\n *         // `signatureBytes` turned out not to be a 64-byte Ed25519 signature\n *     }\n * }\n * ```\n */\nexport function assertIsSignatureBytes(\n    putativeSignatureBytes: ReadonlyUint8Array,\n): asserts putativeSignatureBytes is SignatureBytes {\n    const numBytes = putativeSignatureBytes.byteLength;\n    if (numBytes !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\n/**\n * A type guard that accepts a string as input. It will both return `true` if the string conforms to\n * the {@link Signature} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isSignature } from '@solana/keys';\n *\n * if (isSignature(signature)) {\n *     // At this point, `signature` has been refined to a\n *     // `Signature` that can be used with the RPC.\n *     const {\n *         value: [status],\n *     } = await rpc.getSignatureStatuses([signature]).send();\n *     setSignatureStatus(status);\n * } else {\n *     setError(`${signature} is not a transaction signature`);\n * }\n * ```\n */\nexport function isSignature(putativeSignature: string): putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    return isSignatureBytes(bytes);\n}\n\n/**\n * A type guard that accepts a `ReadonlyUint8Array` as input. It will both return `true` if the `ReadonlyUint8Array` conforms to\n * the {@link SignatureBytes} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isSignatureBytes } from '@solana/keys';\n *\n * if (isSignatureBytes(signatureBytes)) {\n *     // At this point, `signatureBytes` has been refined to a\n *     // `SignatureBytes` that can be used with `verifySignature`.\n *     if (!(await verifySignature(publicKey, signatureBytes, data))) {\n *         throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n *     }\n * } else {\n *     setError(`${signatureBytes} is not a 64-byte Ed25519 signature`);\n * }\n * ```\n */\nexport function isSignatureBytes(putativeSignatureBytes: ReadonlyUint8Array): putativeSignatureBytes is SignatureBytes {\n    return putativeSignatureBytes.byteLength === 64;\n}\n\n/**\n * Given a private [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) and a\n * `Uint8Array` of bytes, this method will return the 64-byte Ed25519 signature of that data as a\n * `Uint8Array`.\n *\n * @example\n * ```ts\n * import { signBytes } from '@solana/keys';\n *\n * const data = new Uint8Array([1, 2, 3]);\n * const signature = await signBytes(privateKey, data);\n * ```\n */\nexport async function signBytes(key: CryptoKey, data: ReadonlyUint8Array): Promise<SignatureBytes> {\n    assertSigningCapabilityIsAvailable();\n    const signedData = await crypto.subtle.sign(ED25519_ALGORITHM_IDENTIFIER, key, data);\n    return new Uint8Array(signedData) as SignatureBytes;\n}\n\n/**\n * This helper combines _asserting_ that a string is an Ed25519 signature with _coercing_ it to the\n * {@link Signature} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { signature } from '@solana/keys';\n *\n * const signature = signature(userSuppliedSignature);\n * const {\n *     value: [status],\n * } = await rpc.getSignatureStatuses([signature]).send();\n * ```\n */\nexport function signature(putativeSignature: string): Signature {\n    assertIsSignature(putativeSignature);\n    return putativeSignature;\n}\n\n/**\n * This helper combines _asserting_ that a `ReadonlyUint8Array` is an Ed25519 signature with _coercing_ it to the\n * {@link SignatureBytes} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { signatureBytes } from '@solana/keys';\n *\n * const signature = signatureBytes(userSuppliedSignatureBytes);\n * if (!(await verifySignature(publicKey, signature, data))) {\n *     throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n * }\n * ```\n */\nexport function signatureBytes(putativeSignatureBytes: ReadonlyUint8Array): SignatureBytes {\n    assertIsSignatureBytes(putativeSignatureBytes);\n    return putativeSignatureBytes;\n}\n\n/**\n * Given a public [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey), some\n * {@link SignatureBytes}, and a `Uint8Array` of data, this method will return `true` if the\n * signature was produced by signing the data using the private key associated with the public key,\n * and `false` otherwise.\n *\n * @example\n * ```ts\n * import { verifySignature } from '@solana/keys';\n *\n * const data = new Uint8Array([1, 2, 3]);\n * if (!(await verifySignature(publicKey, signature, data))) {\n *     throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n * }\n * ```\n */\nexport async function verifySignature(\n    key: CryptoKey,\n    signature: SignatureBytes,\n    data: ReadonlyUint8Array,\n): Promise<boolean> {\n    assertVerificationCapabilityIsAvailable();\n    return await crypto.subtle.verify(ED25519_ALGORITHM_IDENTIFIER, key, signature, data);\n}\n","import { assertKeyGenerationIsAvailable, assertPRNGIsAvailable } from '@solana/assertions';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ED25519_ALGORITHM_IDENTIFIER } from './algorithm';\nimport { createPrivateKeyFromBytes } from './private-key';\nimport { getPublicKeyFromPrivateKey } from './public-key';\nimport { signBytes, verifySignature } from './signatures';\n\n/**\n * Generates an Ed25519 public/private key pair for use with other methods in this package that\n * accept [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) objects.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n *\n * const { privateKey, publicKey } = await generateKeyPair();\n * ```\n */\nexport async function generateKeyPair(): Promise<CryptoKeyPair> {\n    await assertKeyGenerationIsAvailable();\n    const keyPair = await crypto.subtle.generateKey(\n        /* algorithm */ ED25519_ALGORITHM_IDENTIFIER, // Native implementation status: https://github.com/WICG/webcrypto-secure-curves/issues/20\n        /* extractable */ false, // Prevents the bytes of the private key from being visible to JS.\n        /* allowed uses */ ['sign', 'verify'],\n    );\n    return keyPair;\n}\n\n/**\n * Given a 64-byte `Uint8Array` secret key, creates an Ed25519 public/private key pair for use with\n * other methods in this package that accept [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * objects.\n *\n * @param bytes 64 bytes, the first 32 of which represent the private key and the last 32 of which\n * represent its associated public key\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the private\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import fs from 'fs';\n * import { createKeyPairFromBytes } from '@solana/keys';\n *\n * // Get bytes from local keypair file.\n * const keypairFile = fs.readFileSync('~/.config/solana/id.json');\n * const keypairBytes = new Uint8Array(JSON.parse(keypairFile.toString()));\n *\n * // Create a CryptoKeyPair from the bytes.\n * const { privateKey, publicKey } = await createKeyPairFromBytes(keypairBytes);\n * ```\n */\nexport async function createKeyPairFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKeyPair> {\n    assertPRNGIsAvailable();\n\n    if (bytes.byteLength !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH, { byteLength: bytes.byteLength });\n    }\n    const [publicKey, privateKey] = await Promise.all([\n        crypto.subtle.importKey('raw', bytes.slice(32), ED25519_ALGORITHM_IDENTIFIER, /* extractable */ true, [\n            'verify',\n        ]),\n        createPrivateKeyFromBytes(bytes.slice(0, 32), extractable),\n    ]);\n\n    // Verify the key pair\n    const randomBytes = new Uint8Array(32);\n    crypto.getRandomValues(randomBytes);\n    const signedData = await signBytes(privateKey, randomBytes);\n    const isValid = await verifySignature(publicKey, signedData, randomBytes);\n    if (!isValid) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY);\n    }\n\n    return { privateKey, publicKey } as CryptoKeyPair;\n}\n\n/**\n * Given a private key represented as a 32-byte `Uint8Array`, creates an Ed25519 public/private key\n * pair for use with other methods in this package that accept [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * objects.\n *\n * @param bytes 32 bytes that represent the private key\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the private\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import { createKeyPairFromPrivateKeyBytes } from '@solana/keys';\n *\n * const { privateKey, publicKey } = await createKeyPairFromPrivateKeyBytes(new Uint8Array([...]));\n * ```\n *\n * This can be useful when you have a private key but not the corresponding public key or when you\n * need to derive key pairs from seeds. For instance, the following code snippet derives a key pair\n * from the hash of a message.\n *\n * ```ts\n * import { getUtf8Encoder } from '@solana/codecs-strings';\n * import { createKeyPairFromPrivateKeyBytes } from '@solana/keys';\n *\n * const message = getUtf8Encoder().encode('Hello, World!');\n * const seed = new Uint8Array(await crypto.subtle.digest('SHA-256', message));\n *\n * const derivedKeypair = await createKeyPairFromPrivateKeyBytes(seed);\n * ```\n */\nexport async function createKeyPairFromPrivateKeyBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKeyPair> {\n    const privateKeyPromise = createPrivateKeyFromBytes(bytes, extractable);\n\n    // Here we need the private key to be extractable in order to export\n    // it as a public key. Therefore, if the `extractable` parameter\n    // is `false`, we need to create two private keys such that:\n    //   - The extractable one is used to create the public key and\n    //   - The non-extractable one is the one we will return.\n    const [publicKey, privateKey] = await Promise.all([\n        // This nested promise makes things efficient by\n        // creating the public key in parallel with the\n        // second private key creation, if it is needed.\n        (extractable ? privateKeyPromise : createPrivateKeyFromBytes(bytes, true /* extractable */)).then(\n            async privateKey => await getPublicKeyFromPrivateKey(privateKey, true /* extractable */),\n        ),\n        privateKeyPromise,\n    ]);\n\n    return { privateKey, publicKey };\n}\n"],"names":["SolanaError","signature","privateKey"],"mappings":"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"}},
    {"offset": {"line": 3186, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/codecs-numbers/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-numbers/src/assertions.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-numbers/src/common.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-numbers/src/utils.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-numbers/src/f32.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-numbers/src/f64.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-numbers/src/i128.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-numbers/src/i16.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-numbers/src/i32.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-numbers/src/i64.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-numbers/src/i8.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-numbers/src/short-u16.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-numbers/src/u128.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-numbers/src/u16.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-numbers/src/u32.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-numbers/src/u64.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-numbers/src/u8.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\n/**\n * Ensures that a given number falls within a specified range.\n *\n * If the number is outside the allowed range, an error is thrown.\n * This function is primarily used to validate values before encoding them in a codec.\n *\n * @param codecDescription - A string describing the codec that is performing the validation.\n * @param min - The minimum allowed value (inclusive).\n * @param max - The maximum allowed value (inclusive).\n * @param value - The number to validate.\n *\n * @throws {@link SolanaError} if the value is out of range.\n *\n * @example\n * Validating a number within range.\n * ```ts\n * assertNumberIsBetweenForCodec('u8', 0, 255, 42); // Passes\n * ```\n *\n * @example\n * Throwing an error for an out-of-range value.\n * ```ts\n * assertNumberIsBetweenForCodec('u8', 0, 255, 300); // Throws\n * ```\n */\nexport function assertNumberIsBetweenForCodec(\n    codecDescription: string,\n    min: bigint | number,\n    max: bigint | number,\n    value: bigint | number,\n) {\n    if (value < min || value > max) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n            codecDescription,\n            max,\n            min,\n            value,\n        });\n    }\n}\n","import { Codec, Decoder, Encoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n/**\n * Represents an encoder for numbers and bigints.\n *\n * This type allows encoding values that are either `number` or `bigint`.\n * Depending on the specific implementation, the encoded output may have a fixed or variable size.\n *\n * @see {@link FixedSizeNumberEncoder}\n */\nexport type NumberEncoder = Encoder<bigint | number>;\n\n/**\n * Represents a fixed-size encoder for numbers and bigints.\n *\n * This encoder serializes values using an exact number of bytes, defined by `TSize`.\n *\n * @typeParam TSize - The number of bytes used for encoding.\n *\n * @see {@link NumberEncoder}\n */\nexport type FixedSizeNumberEncoder<TSize extends number = number> = FixedSizeEncoder<bigint | number, TSize>;\n\n/**\n * Represents a decoder for numbers and bigints.\n *\n * This type supports decoding values as either `number` or `bigint`, depending on the implementation.\n *\n * @see {@link FixedSizeNumberDecoder}\n */\nexport type NumberDecoder = Decoder<bigint> | Decoder<number>;\n\n/**\n * Represents a fixed-size decoder for numbers and bigints.\n *\n * This decoder reads a fixed number of bytes (`TSize`) and converts them into a `number` or `bigint`.\n *\n * @typeParam TSize - The number of bytes expected for decoding.\n *\n * @see {@link NumberDecoder}\n */\nexport type FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\n\n/**\n * Represents a codec for encoding and decoding numbers and bigints.\n *\n * - The encoded value can be either a `number` or a `bigint`.\n * - The decoded value will always be either a `number` or `bigint`, depending on the implementation.\n *\n * @see {@link FixedSizeNumberCodec}\n */\nexport type NumberCodec = Codec<bigint | number, bigint> | Codec<bigint | number, number>;\n\n/**\n * Represents a fixed-size codec for encoding and decoding numbers and bigints.\n *\n * This codec uses a specific number of bytes (`TSize`) for serialization.\n * The encoded value can be either a `number` or `bigint`, but the decoded value will always be a `number` or `bigint`,\n * depending on the implementation.\n *\n * @typeParam TSize - The number of bytes used for encoding and decoding.\n *\n * @see {@link NumberCodec}\n */\nexport type FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<bigint | number, number, TSize>;\n\n/**\n * Configuration options for number codecs that use more than one byte.\n *\n * This configuration applies to all number codecs except `u8` and `i8`,\n * allowing the user to specify the endianness of serialization.\n */\nexport type NumberCodecConfig = {\n    /**\n     * Specifies whether numbers should be encoded in little-endian or big-endian format.\n     *\n     * @defaultValue `Endian.Little`\n     */\n    endian?: Endian;\n};\n\n/**\n * Defines the byte order used for number serialization.\n *\n * - `Little`: The least significant byte is stored first.\n * - `Big`: The most significant byte is stored first.\n */\nexport enum Endian {\n    Little,\n    Big,\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\nimport { Endian, NumberCodecConfig } from './common';\n\ntype NumberFactorySharedInput<TSize extends number> = {\n    config?: NumberCodecConfig;\n    name: string;\n    size: TSize;\n};\n\ntype NumberFactoryEncoderInput<TFrom, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    range?: [bigint | number, bigint | number];\n    set: (view: DataView, value: TFrom, littleEndian?: boolean) => void;\n};\n\ntype NumberFactoryDecoderInput<TTo, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    get: (view: DataView, littleEndian?: boolean) => TTo;\n};\n\nfunction isLittleEndian(config?: NumberCodecConfig): boolean {\n    return config?.endian === Endian.Big ? false : true;\n}\n\nexport function numberEncoderFactory<TFrom extends bigint | number, TSize extends number>(\n    input: NumberFactoryEncoderInput<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: input.size,\n        write(value: TFrom, bytes: Uint8Array, offset: Offset): Offset {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        },\n    });\n}\n\nexport function numberDecoderFactory<TTo extends bigint | number, TSize extends number>(\n    input: NumberFactoryDecoderInput<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: input.size,\n        read(bytes, offset = 0): [TTo, number] {\n            assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);\n            assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [input.get(view, isLittleEndian(input.config)), offset + input.size];\n        },\n    });\n}\n\n/**\n * Helper function to ensure that the ArrayBuffer is converted properly from a Uint8Array\n * Source: https://stackoverflow.com/questions/37228285/uint8array-to-arraybuffer\n */\nfunction toArrayBuffer(bytes: ReadonlyUint8Array | Uint8Array, offset?: number, length?: number): ArrayBuffer {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit floating-point numbers (`f32`).\n *\n * This encoder serializes `f32` values using 4 bytes.\n * Floating-point values may lose precision when encoded.\n *\n * For more details, see {@link getF32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number, 4>` for encoding `f32` values.\n *\n * @example\n * Encoding an `f32` value.\n * ```ts\n * const encoder = getF32Encoder();\n * const bytes = encoder.encode(-1.5); // 0x0000c0bf\n * ```\n *\n * @see {@link getF32Codec}\n */\nexport const getF32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'f32',\n        set: (view, value, le) => view.setFloat32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit floating-point numbers (`f32`).\n *\n * This decoder deserializes `f32` values from 4 bytes.\n * Some precision may be lost during decoding due to floating-point representation.\n *\n * For more details, see {@link getF32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `f32` values.\n *\n * @example\n * Decoding an `f32` value.\n * ```ts\n * const decoder = getF32Decoder();\n * const value = decoder.decode(new Uint8Array([0x00, 0x00, 0xc0, 0xbf])); // -1.5\n * ```\n *\n * @see {@link getF32Codec}\n */\nexport const getF32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat32(0, le),\n        name: 'f32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit floating-point numbers (`f32`).\n *\n * This codec serializes `f32` values using 4 bytes.\n * Due to the IEEE 754 floating-point representation, some precision loss may occur.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number, number, 4>` for encoding and decoding `f32` values.\n *\n * @example\n * Encoding and decoding an `f32` value.\n * ```ts\n * const codec = getF32Codec();\n * const bytes = codec.encode(-1.5); // 0x0000c0bf\n * const value = codec.decode(bytes); // -1.5\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getF32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-1.5); // 0xbfc00000\n * ```\n *\n * @remarks\n * `f32` values follow the IEEE 754 single-precision floating-point standard.\n * Precision loss may occur for certain values.\n *\n * - If you need higher precision, consider using {@link getF64Codec}.\n * - If you need integer values, consider using {@link getI32Codec} or {@link getU32Codec}.\n *\n * Separate {@link getF32Encoder} and {@link getF32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getF32Encoder().encode(-1.5);\n * const value = getF32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getF32Encoder}\n * @see {@link getF32Decoder}\n */\nexport const getF32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getF32Encoder(config), getF32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit floating-point numbers (`f64`).\n *\n * This encoder serializes `f64` values using 8 bytes.\n * Floating-point values may lose precision when encoded.\n *\n * For more details, see {@link getF64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number, 8>` for encoding `f64` values.\n *\n * @example\n * Encoding an `f64` value.\n * ```ts\n * const encoder = getF64Encoder();\n * const bytes = encoder.encode(-1.5); // 0x000000000000f8bf\n * ```\n *\n * @see {@link getF64Codec}\n */\nexport const getF64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'f64',\n        set: (view, value, le) => view.setFloat64(0, Number(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit floating-point numbers (`f64`).\n *\n * This decoder deserializes `f64` values from 8 bytes.\n * Some precision may be lost during decoding due to floating-point representation.\n *\n * For more details, see {@link getF64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 8>` for decoding `f64` values.\n *\n * @example\n * Decoding an `f64` value.\n * ```ts\n * const decoder = getF64Decoder();\n * const value = decoder.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xbf])); // -1.5\n * ```\n *\n * @see {@link getF64Codec}\n */\nexport const getF64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat64(0, le),\n        name: 'f64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit floating-point numbers (`f64`).\n *\n * This codec serializes `f64` values using 8 bytes.\n * Due to the IEEE 754 floating-point representation, some precision loss may occur.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number, number, 8>` for encoding and decoding `f64` values.\n *\n * @example\n * Encoding and decoding an `f64` value.\n * ```ts\n * const codec = getF64Codec();\n * const bytes = codec.encode(-1.5); // 0x000000000000f8bf\n * const value = codec.decode(bytes); // -1.5\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getF64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-1.5); // 0xbff8000000000000\n * ```\n *\n * @remarks\n * `f64` values follow the IEEE 754 double-precision floating-point standard.\n * Precision loss may still occur but is significantly lower than `f32`.\n *\n * - If you need smaller floating-point values, consider using {@link getF32Codec}.\n * - If you need integer values, consider using {@link getI64Codec} or {@link getU64Codec}.\n *\n * Separate {@link getF64Encoder} and {@link getF64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getF64Encoder().encode(-1.5);\n * const value = getF64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getF64Encoder}\n * @see {@link getF64Decoder}\n */\nexport const getF64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 8> =>\n    combineCodec(getF64Encoder(config), getF64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 128-bit signed integers (`i128`).\n *\n * This encoder serializes `i128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI128Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 16>` for encoding `i128` values.\n *\n * @example\n * Encoding an `i128` value.\n * ```ts\n * const encoder = getI128Encoder();\n * const bytes = encoder.encode(-42n); // 0xd6ffffffffffffffffffffffffffffff\n * ```\n *\n * @see {@link getI128Codec}\n */\nexport const getI128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'i128',\n        range: [-BigInt('0x7fffffffffffffffffffffffffffffff') - 1n, BigInt('0x7fffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\n/**\n * Returns a decoder for 128-bit signed integers (`i128`).\n *\n * This decoder deserializes `i128` values from 16 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getI128Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 16>` for decoding `i128` values.\n *\n * @example\n * Decoding an `i128` value.\n * ```ts\n * const decoder = getI128Decoder();\n * const value = decoder.decode(new Uint8Array([\n *   0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n *   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n * ])); // -42n\n * ```\n *\n * @see {@link getI128Codec}\n */\nexport const getI128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'i128',\n        size: 16,\n    });\n\n/**\n * Returns a codec for encoding and decoding 128-bit signed integers (`i128`).\n *\n * This codec serializes `i128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 16>` for encoding and decoding `i128` values.\n *\n * @example\n * Encoding and decoding an `i128` value.\n * ```ts\n * const codec = getI128Codec();\n * const bytes = codec.encode(-42n); // 0xd6ffffffffffffffffffffffffffffff\n * const value = codec.decode(bytes); // -42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI128Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42n); // 0xffffffffffffffffffffffffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^127` and `2^127 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller signed integer, consider using {@link getI64Codec} or {@link getI32Codec}.\n * - If you need a larger signed integer, consider using a custom codec.\n * - If you need unsigned integers, consider using {@link getU128Codec}.\n *\n * Separate {@link getI128Encoder} and {@link getI128Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI128Encoder().encode(-42);\n * const value = getI128Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI128Encoder}\n * @see {@link getI128Decoder}\n */\nexport const getI128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getI128Encoder(config), getI128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 16-bit signed integers (`i16`).\n *\n * This encoder serializes `i16` values using 2 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI16Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 2>` for encoding `i16` values.\n *\n * @example\n * Encoding an `i16` value.\n * ```ts\n * const encoder = getI16Encoder();\n * const bytes = encoder.encode(-42); // 0xd6ff\n * ```\n *\n * @see {@link getI16Codec}\n */\nexport const getI16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'i16',\n        range: [-Number('0x7fff') - 1, Number('0x7fff')],\n        set: (view, value, le) => view.setInt16(0, Number(value), le),\n        size: 2,\n    });\n\n/**\n * Returns a decoder for 16-bit signed integers (`i16`).\n *\n * This decoder deserializes `i16` values from 2 bytes.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI16Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 2>` for decoding `i16` values.\n *\n * @example\n * Decoding an `i16` value.\n * ```ts\n * const decoder = getI16Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6, 0xff])); // -42\n * ```\n *\n * @see {@link getI16Codec}\n */\nexport const getI16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt16(0, le),\n        name: 'i16',\n        size: 2,\n    });\n\n/**\n * Returns a codec for encoding and decoding 16-bit signed integers (`i16`).\n *\n * This codec serializes `i16` values using 2 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, number, 2>` for encoding and decoding `i16` values.\n *\n * @example\n * Encoding and decoding an `i16` value.\n * ```ts\n * const codec = getI16Codec();\n * const bytes = codec.encode(-42); // 0xd6ff\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI16Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42); // 0xffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^15` (`-32,768`) and `2^15 - 1` (`32,767`).\n *\n * - If you need a smaller signed integer, consider using {@link getI8Codec}.\n * - If you need a larger signed integer, consider using {@link getI32Codec}.\n * - If you need unsigned integers, consider using {@link getU16Codec}.\n *\n * Separate {@link getI16Encoder} and {@link getI16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI16Encoder().encode(-42);\n * const value = getI16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI16Encoder}\n * @see {@link getI16Decoder}\n */\nexport const getI16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getI16Encoder(config), getI16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit signed integers (`i32`).\n *\n * This encoder serializes `i32` values using 4 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 4>` for encoding `i32` values.\n *\n * @example\n * Encoding an `i32` value.\n * ```ts\n * const encoder = getI32Encoder();\n * const bytes = encoder.encode(-42); // 0xd6ffffff\n * ```\n *\n * @see {@link getI32Codec}\n */\nexport const getI32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'i32',\n        range: [-Number('0x7fffffff') - 1, Number('0x7fffffff')],\n        set: (view, value, le) => view.setInt32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit signed integers (`i32`).\n *\n * This decoder deserializes `i32` values from 4 bytes.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `i32` values.\n *\n * @example\n * Decoding an `i32` value.\n * ```ts\n * const decoder = getI32Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6, 0xff, 0xff, 0xff])); // -42\n * ```\n *\n * @see {@link getI32Codec}\n */\nexport const getI32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt32(0, le),\n        name: 'i32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit signed integers (`i32`).\n *\n * This codec serializes `i32` values using 4 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, number, 4>` for encoding and decoding `i32` values.\n *\n * @example\n * Encoding and decoding an `i32` value.\n * ```ts\n * const codec = getI32Codec();\n * const bytes = codec.encode(-42); // 0xd6ffffff\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42); // 0xffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^31` (`-2,147,483,648`) and `2^31 - 1` (`2,147,483,647`).\n *\n * - If you need a smaller signed integer, consider using {@link getI16Codec} or {@link getI8Codec}.\n * - If you need a larger signed integer, consider using {@link getI64Codec}.\n * - If you need unsigned integers, consider using {@link getU32Codec}.\n *\n * Separate {@link getI32Encoder} and {@link getI32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI32Encoder().encode(-42);\n * const value = getI32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI32Encoder}\n * @see {@link getI32Decoder}\n */\nexport const getI32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getI32Encoder(config), getI32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit signed integers (`i64`).\n *\n * This encoder serializes `i64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 8>` for encoding `i64` values.\n *\n * @example\n * Encoding an `i64` value.\n * ```ts\n * const encoder = getI64Encoder();\n * const bytes = encoder.encode(-42n); // 0xd6ffffffffffffff\n * ```\n *\n * @see {@link getI64Codec}\n */\nexport const getI64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'i64',\n        range: [-BigInt('0x7fffffffffffffff') - 1n, BigInt('0x7fffffffffffffff')],\n        set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit signed integers (`i64`).\n *\n * This decoder deserializes `i64` values from 8 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getI64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 8>` for decoding `i64` values.\n *\n * @example\n * Decoding an `i64` value.\n * ```ts\n * const decoder = getI64Decoder();\n * const value = decoder.decode(new Uint8Array([\n *   0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n * ])); // -42n\n * ```\n *\n * @see {@link getI64Codec}\n */\nexport const getI64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigInt64(0, le),\n        name: 'i64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit signed integers (`i64`).\n *\n * This codec serializes `i64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 8>` for encoding and decoding `i64` values.\n *\n * @example\n * Encoding and decoding an `i64` value.\n * ```ts\n * const codec = getI64Codec();\n * const bytes = codec.encode(-42n); // 0xd6ffffffffffffff\n * const value = codec.decode(bytes); // -42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42n); // 0xffffffffffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^63` and `2^63 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller signed integer, consider using {@link getI32Codec} or {@link getI16Codec}.\n * - If you need a larger signed integer, consider using {@link getI128Codec}.\n * - If you need unsigned integers, consider using {@link getU64Codec}.\n *\n * Separate {@link getI64Encoder} and {@link getI64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI64Encoder().encode(-42);\n * const value = getI64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI64Encoder}\n * @see {@link getI64Decoder}\n */\nexport const getI64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getI64Encoder(config), getI64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 8-bit signed integers (`i8`).\n *\n * This encoder serializes `i8` values using 1 byte.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI8Codec}.\n *\n * @returns A `FixedSizeEncoder<number | bigint, 1>` for encoding `i8` values.\n *\n * @example\n * Encoding an `i8` value.\n * ```ts\n * const encoder = getI8Encoder();\n * const bytes = encoder.encode(-42); // 0xd6\n * ```\n *\n * @see {@link getI8Codec}\n */\nexport const getI8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'i8',\n        range: [-Number('0x7f') - 1, Number('0x7f')],\n        set: (view, value) => view.setInt8(0, Number(value)),\n        size: 1,\n    });\n\n/**\n * Returns a decoder for 8-bit signed integers (`i8`).\n *\n * This decoder deserializes `i8` values from 1 byte.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI8Codec}.\n *\n * @returns A `FixedSizeDecoder<number, 1>` for decoding `i8` values.\n *\n * @example\n * Decoding an `i8` value.\n * ```ts\n * const decoder = getI8Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6])); // -42\n * ```\n *\n * @see {@link getI8Codec}\n */\nexport const getI8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getInt8(0),\n        name: 'i8',\n        size: 1,\n    });\n\n/**\n * Returns a codec for encoding and decoding 8-bit signed integers (`i8`).\n *\n * This codec serializes `i8` values using 1 byte.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @returns A `FixedSizeCodec<number | bigint, number, 1>` for encoding and decoding `i8` values.\n *\n * @example\n * Encoding and decoding an `i8` value.\n * ```ts\n * const codec = getI8Codec();\n * const bytes = codec.encode(-42); // 0xd6\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @remarks\n * This codec supports values between `-2^7` (`-128`) and `2^7 - 1` (`127`).\n *\n * - If you need a larger signed integer, consider using {@link getI16Codec}.\n * - If you need an unsigned integer, consider using {@link getU8Codec}.\n *\n * Separate {@link getI8Encoder} and {@link getI8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI8Encoder().encode(-42);\n * const value = getI8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI8Encoder}\n * @see {@link getI8Decoder}\n */\nexport const getI8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getI8Encoder(), getI8Decoder());\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Offset,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\n\n/**\n * Returns an encoder for `shortU16` values.\n *\n * This encoder serializes `shortU16` values using **1 to 3 bytes**.\n * Smaller values use fewer bytes, while larger values take up more space.\n *\n * For more details, see {@link getShortU16Codec}.\n *\n * @returns A `VariableSizeEncoder<number | bigint>` for encoding `shortU16` values.\n *\n * @example\n * Encoding a `shortU16` value.\n * ```ts\n * const encoder = getShortU16Encoder();\n * encoder.encode(42);    // 0x2a\n * encoder.encode(128);   // 0x8001\n * encoder.encode(16384); // 0x808001\n * ```\n *\n * @see {@link getShortU16Codec}\n */\nexport const getShortU16Encoder = (): VariableSizeEncoder<bigint | number> =>\n    createEncoder({\n        getSizeFromValue: (value: bigint | number): number => {\n            if (value <= 0b01111111) return 1;\n            if (value <= 0b0011111111111111) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value: bigint | number, bytes: Uint8Array, offset: Offset): Offset => {\n            assertNumberIsBetweenForCodec('shortU16', 0, 65535, value);\n            const shortU16Bytes = [0];\n            for (let ii = 0; ; ii += 1) {\n                // Shift the bits of the value over such that the next 7 bits are at the right edge.\n                const alignedValue = Number(value) >> (ii * 7);\n                if (alignedValue === 0) {\n                    // No more bits to consume.\n                    break;\n                }\n                // Extract those 7 bits using a mask.\n                const nextSevenBits = 0b1111111 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    // Set the continuation bit of the previous slice.\n                    shortU16Bytes[ii - 1] |= 0b10000000;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        },\n    });\n\n/**\n * Returns a decoder for `shortU16` values.\n *\n * This decoder deserializes `shortU16` values from **1 to 3 bytes**.\n * The number of bytes used depends on the encoded value.\n *\n * For more details, see {@link getShortU16Codec}.\n *\n * @returns A `VariableSizeDecoder<number>` for decoding `shortU16` values.\n *\n * @example\n * Decoding a `shortU16` value.\n * ```ts\n * const decoder = getShortU16Decoder();\n * decoder.decode(new Uint8Array([0x2a]));             // 42\n * decoder.decode(new Uint8Array([0x80, 0x01]));       // 128\n * decoder.decode(new Uint8Array([0x80, 0x80, 0x01])); // 16384\n * ```\n *\n * @see {@link getShortU16Codec}\n */\nexport const getShortU16Decoder = (): VariableSizeDecoder<number> =>\n    createDecoder({\n        maxSize: 3,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset): [number, Offset] => {\n            let value = 0;\n            let byteCount = 0;\n            while (++byteCount) {\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 0b1111111 & currentByte;\n                // Insert the next group of seven bits into the correct slot of the output value.\n                value |= nextSevenBits << (byteIndex * 7);\n                if ((currentByte & 0b10000000) === 0) {\n                    // This byte does not have its continuation bit set. We're done.\n                    break;\n                }\n            }\n            return [value, offset + byteCount];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding `shortU16` values.\n *\n * It serializes unsigned integers using **1 to 3 bytes** based on the encoded value.\n * The larger the value, the more bytes it uses.\n *\n * - If the value is `<= 0x7f` (127), it is stored in a **single byte**\n *   and the first bit is set to `0` to indicate the end of the value.\n * - Otherwise, the first bit is set to `1` to indicate that the value continues in the next byte, which follows the same pattern.\n * - This process repeats until the value is fully encoded in up to 3 bytes. The third and last byte, if needed, uses all 8 bits to store the remaining value.\n *\n * In other words, the encoding scheme follows this structure:\n *\n * ```txt\n * 0XXXXXXX                   <- Values 0 to 127 (1 byte)\n * 1XXXXXXX 0XXXXXXX          <- Values 128 to 16,383 (2 bytes)\n * 1XXXXXXX 1XXXXXXX XXXXXXXX <- Values 16,384 to 4,194,303 (3 bytes)\n * ```\n *\n * @returns A `VariableSizeCodec<number | bigint, number>` for encoding and decoding `shortU16` values.\n *\n * @example\n * Encoding and decoding `shortU16` values.\n * ```ts\n * const codec = getShortU16Codec();\n * const bytes1 = codec.encode(42);    // 0x2a\n * const bytes2 = codec.encode(128);   // 0x8001\n * const bytes3 = codec.encode(16384); // 0x808001\n *\n * codec.decode(bytes1); // 42\n * codec.decode(bytes2); // 128\n * codec.decode(bytes3); // 16384\n * ```\n *\n * @remarks\n * This codec efficiently stores small numbers, making it useful for transactions and compact representations.\n *\n * If you need a fixed-size `u16` codec, consider using {@link getU16Codec}.\n *\n * Separate {@link getShortU16Encoder} and {@link getShortU16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getShortU16Encoder().encode(42);\n * const value = getShortU16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getShortU16Encoder}\n * @see {@link getShortU16Decoder}\n */\nexport const getShortU16Codec = (): VariableSizeCodec<bigint | number, number> =>\n    combineCodec(getShortU16Encoder(), getShortU16Decoder());\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 128-bit unsigned integers (`u128`).\n *\n * This encoder serializes `u128` values using sixteen bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU128Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<number | bigint, 16>` for encoding `u128` values.\n *\n * @example\n * Encoding a `u128` value.\n * ```ts\n * const encoder = getU128Encoder();\n * const bytes = encoder.encode(42n); // 0x2a000000000000000000000000000000\n * ```\n *\n * @see {@link getU128Codec}\n */\nexport const getU128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'u128',\n        range: [0n, BigInt('0xffffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\n/**\n * Returns a decoder for 128-bit unsigned integers (`u128`).\n *\n * This decoder deserializes `u128` values from sixteen bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU128Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<bigint, 16>` for decoding `u128` values.\n *\n * @example\n * Decoding a `u128` value.\n * ```ts\n * const decoder = getU128Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])); // 42n\n * ```\n *\n * @see {@link getU128Codec}\n */\nexport const getU128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'u128',\n        size: 16,\n    });\n\n/**\n * Returns a codec for encoding and decoding 128-bit unsigned integers (`u128`).\n *\n * This codec serializes `u128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 16>` for encoding and decoding `u128` values.\n *\n * @example\n * Encoding and decoding a `u128` value.\n * ```ts\n * const codec = getU128Codec();\n * const bytes = codec.encode(42); // 0x2a000000000000000000000000000000\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getU128Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x0000000000000000000000000000002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^128 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller unsigned integer, consider using {@link getU64Codec} or {@link getU32Codec}.\n * - If you need signed integers, consider using {@link getI128Codec}.\n *\n * Separate {@link getU128Encoder} and {@link getU128Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU128Encoder().encode(42);\n * const value = getU128Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU128Encoder}\n * @see {@link getU128Decoder}\n */\nexport const getU128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getU128Encoder(config), getU128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 16-bit unsigned integers (`u16`).\n *\n * This encoder serializes `u16` values using two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU16Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<number | bigint, 2>` for encoding `u16` values.\n *\n * @example\n * Encoding a `u16` value.\n * ```ts\n * const encoder = getU16Encoder();\n * const bytes = encoder.encode(42); // 0x2a00\n * ```\n *\n * @see {@link getU16Codec}\n */\nexport const getU16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'u16',\n        range: [0, Number('0xffff')],\n        set: (view, value, le) => view.setUint16(0, Number(value), le),\n        size: 2,\n    });\n\n/**\n * Returns a decoder for 16-bit unsigned integers (`u16`).\n *\n * This decoder deserializes `u16` values from two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU16Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<number, 2>` for decoding `u16` values.\n *\n * @example\n * Decoding a `u16` value.\n * ```ts\n * const decoder = getU16Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @see {@link getU16Codec}\n */\nexport const getU16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint16(0, le),\n        name: 'u16',\n        size: 2,\n    });\n\n/**\n * Returns a codec for encoding and decoding 16-bit unsigned integers (`u16`).\n *\n * This codec serializes `u16` values using two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeCodec<number | bigint, number, 2>` for encoding and decoding `u16` values.\n *\n * @example\n * Encoding and decoding a `u16` value.\n * ```ts\n * const codec = getU16Codec();\n * const bytes = codec.encode(42); // 0x2a00 (little-endian)\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Storing values in big-endian format.\n * ```ts\n * const codec = getU16Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^16 - 1`.\n * If you need a larger range, consider using {@link getU32Codec} or {@link getU64Codec}.\n * For signed integers, use {@link getI16Codec}.\n *\n * Separate {@link getU16Encoder} and {@link getU16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU16Encoder().encode(42);\n * const value = getU16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU16Encoder}\n * @see {@link getU16Decoder}\n */\nexport const getU16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getU16Encoder(config), getU16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit unsigned integers (`u32`).\n *\n * This encoder serializes `u32` values using four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU32Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<bigint | number, 4>` for encoding `u32` values.\n *\n * @example\n * Encoding a `u32` value.\n * ```ts\n * const encoder = getU32Encoder();\n * const bytes = encoder.encode(42); // 0x2a000000\n * ```\n *\n * @see {@link getU32Codec}\n */\nexport const getU32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'u32',\n        range: [0, Number('0xffffffff')],\n        set: (view, value, le) => view.setUint32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit unsigned integers (`u32`).\n *\n * This decoder deserializes `u32` values from four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU32Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `u32` values.\n *\n * @example\n * Decoding a `u32` value.\n * ```ts\n * const decoder = getU32Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @see {@link getU32Codec}\n */\nexport const getU32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint32(0, le),\n        name: 'u32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit unsigned integers (`u32`).\n *\n * This codec serializes `u32` values using four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeCodec<bigint | number, number, 4>` for encoding and decoding `u32` values.\n *\n * @example\n * Encoding and decoding a `u32` value.\n * ```ts\n * const codec = getU32Codec();\n * const bytes = codec.encode(42); // 0x2a000000 (little-endian)\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Storing values in big-endian format.\n * ```ts\n * const codec = getU32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x0000002a\n * ```\n *\n * @remarks\n * This codec only supports values between `0` and `2^32 - 1`.\n * If you need a larger range, consider using {@link getU64Codec} or {@link getU128Codec}.\n * For signed integers, use {@link getI32Codec}.\n *\n * Separate {@link getU32Encoder} and {@link getU32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU32Encoder().encode(42);\n * const value = getU32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU32Encoder}\n * @see {@link getU32Decoder}\n */\nexport const getU32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getU32Encoder(config), getU32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit unsigned integers (`u64`).\n *\n * This encoder serializes `u64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getU64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 8>` for encoding `u64` values.\n *\n * @example\n * Encoding a `u64` value.\n * ```ts\n * const encoder = getU64Encoder();\n * const bytes = encoder.encode(42); // 0x2a00000000000000\n * ```\n *\n * @see {@link getU64Codec}\n */\nexport const getU64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'u64',\n        range: [0n, BigInt('0xffffffffffffffff')],\n        set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit unsigned integers (`u64`).\n *\n * This decoder deserializes `u64` values from 8 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getU64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 8>` for decoding `u64` values.\n *\n * @example\n * Decoding a `u64` value.\n * ```ts\n * const decoder = getU64Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])); // 42n\n * ```\n *\n * @see {@link getU64Codec}\n */\nexport const getU64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigUint64(0, le),\n        name: 'u64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit unsigned integers (`u64`).\n *\n * This codec serializes `u64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 8>` for encoding and decoding `u64` values.\n *\n * @example\n * Encoding and decoding a `u64` value.\n * ```ts\n * const codec = getU64Codec();\n * const bytes = codec.encode(42); // 0x2a00000000000000\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getU64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x000000000000002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^64 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller unsigned integer, consider using {@link getU32Codec} or {@link getU16Codec}.\n * - If you need a larger unsigned integer, consider using {@link getU128Codec}.\n * - If you need signed integers, consider using {@link getI64Codec}.\n *\n * Separate {@link getU64Encoder} and {@link getU64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU64Encoder().encode(42);\n * const value = getU64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU64Encoder}\n * @see {@link getU64Decoder}\n */\nexport const getU64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getU64Encoder(config), getU64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 8-bit unsigned integers (`u8`).\n *\n * This encoder serializes `u8` values using a single byte.\n *\n * For more details, see {@link getU8Codec}.\n *\n * @returns A `FixedSizeEncoder<number | bigint, 1>` for encoding `u8` values.\n *\n * @example\n * Encoding a `u8` value.\n * ```ts\n * const encoder = getU8Encoder();\n * const bytes = encoder.encode(42); // 0x2a\n * ```\n *\n * @see {@link getU8Codec}\n */\nexport const getU8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'u8',\n        range: [0, Number('0xff')],\n        set: (view, value) => view.setUint8(0, Number(value)),\n        size: 1,\n    });\n\n/**\n * Returns a decoder for 8-bit unsigned integers (`u8`).\n *\n * This decoder deserializes `u8` values from a single byte.\n *\n * For more details, see {@link getU8Codec}.\n *\n * @returns A `FixedSizeDecoder<number, 1>` for decoding `u8` values.\n *\n * @example\n * Decoding a `u8` value.\n * ```ts\n * const decoder = getU8Decoder();\n * const value = decoder.decode(new Uint8Array([0xff])); // 255\n * ```\n *\n * @see {@link getU8Codec}\n */\nexport const getU8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getUint8(0),\n        name: 'u8',\n        size: 1,\n    });\n\n/**\n * Returns a codec for encoding and decoding 8-bit unsigned integers (`u8`).\n *\n * This codec serializes `u8` values using a single byte.\n *\n * @returns A `FixedSizeCodec<number | bigint, number, 1>` for encoding and decoding `u8` values.\n *\n * @example\n * Encoding and decoding a `u8` value.\n * ```ts\n * const codec = getU8Codec();\n * const bytes = codec.encode(255); // 0xff\n * const value = codec.decode(bytes); // 255\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^8 - 1` (0 to 255).\n * If you need larger integers, consider using {@link getU16Codec}, {@link getU32Codec}, or {@link getU64Codec}.\n * For signed integers, use {@link getI8Codec}.\n *\n * Separate {@link getU8Encoder} and {@link getU8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU8Encoder().encode(42);\n * const value = getU8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU8Encoder}\n * @see {@link getU8Decoder}\n */\nexport const getU8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getU8Encoder(), getU8Decoder());\n"],"names":["Endian","combineCodec","createEncoder","createDecoder"],"mappings":"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"}},
    {"offset": {"line": 3599, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/codecs-data-structures/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-data-structures/src/assertions.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-data-structures/src/utils.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-data-structures/src/array.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-data-structures/src/bit-array.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-data-structures/src/boolean.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-data-structures/src/bytes.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-strings/src/base16.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-data-structures/src/constant.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-data-structures/src/tuple.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-data-structures/src/union.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-data-structures/src/discriminated-union.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-data-structures/src/enum-helpers.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-data-structures/src/enum.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-data-structures/src/hidden-prefix.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-data-structures/src/hidden-suffix.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-data-structures/src/literal-union.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-data-structures/src/map.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-data-structures/src/unit.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-data-structures/src/nullable.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-data-structures/src/set.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-data-structures/src/struct.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SolanaError } from '@solana/errors';\n\n/** Checks the number of items in an array-like structure is expected. */\nexport function assertValidNumberOfItemsForCodec(\n    codecDescription: string,\n    expected: bigint | number,\n    actual: bigint | number,\n) {\n    if (expected !== actual) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n            actual,\n            codecDescription,\n            expected,\n        });\n    }\n}\n","import { isFixedSize } from '@solana/codecs-core';\n\n/**\n * Functionally, this type helper is equivalent to the identity type — i.e. `type Identity<T> = T`.\n * However, wrapping generic object mappings in this type significantly reduces the number\n * of instantiation expressions processed, which increases TypeScript performance and\n * prevents \"Type instantiation is excessively deep and possibly infinite\" errors.\n *\n * This works because TypeScript doesn't create a new level of nesting when encountering conditional generic types.\n * @see https://github.com/microsoft/TypeScript/issues/34933\n * @see https://github.com/kysely-org/kysely/pull/483\n */\nexport type DrainOuterGeneric<T> = [T] extends [unknown] ? T : never;\n\nexport function maxCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce(\n        (all, size) => (all === null || size === null ? null : Math.max(all, size)),\n        0 as number | null,\n    );\n}\n\nexport function sumCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce((all, size) => (all === null || size === null ? null : all + size), 0 as number | null);\n}\n\nexport function getFixedSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : null;\n}\n\nexport function getMaxSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : (codec.maxSize ?? null);\n}\n","import {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getU32Decoder, getU32Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { getFixedSize, getMaxSize } from './utils';\n\n/**\n * Defines the possible size strategies for array-like codecs (`array`, `map`, and `set`).\n *\n * The size of the collection can be determined using one of the following approaches:\n * - A {@link NumberCodec}, {@link NumberDecoder}, or {@link NumberEncoder} to store a size prefix.\n * - A fixed `number` of items, enforcing an exact length.\n * - The string `\"remainder\"`, which infers the number of items by consuming the rest of the available bytes.\n *   This option is only available when encoding fixed-size items.\n *\n * @typeParam TPrefix - A number codec, decoder, or encoder used for size prefixing.\n */\nexport type ArrayLikeCodecSize<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> =\n    | TPrefix\n    | number\n    | 'remainder';\n\n/**\n * Defines the configuration options for array codecs.\n *\n * @typeParam TPrefix - A number codec, decoder, or encoder used for size prefixing.\n */\nexport type ArrayCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Specifies how the size of the array is determined.\n     *\n     * - A {@link NumberCodec}, {@link NumberDecoder}, or {@link NumberEncoder} stores a size prefix before encoding the array.\n     * - A `number` enforces a fixed number of elements.\n     * - `\"remainder\"` uses all remaining bytes to infer the array length (only for fixed-size items).\n     *\n     * @defaultValue A `u32` size prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Returns an encoder for arrays of values.\n *\n * This encoder serializes arrays by encoding each element using the provided item encoder.\n * By default, a `u32` size prefix is included to indicate the number of items in the array.\n * The `size` option can be used to modify this behaviour.\n *\n * For more details, see {@link getArrayCodec}.\n *\n * @typeParam TFrom - The type of the elements in the array.\n *\n * @param item - The encoder for each item in the array.\n * @param config - Optional configuration for the size encoding strategy.\n * @returns A `VariableSizeEncoder<TFrom[]>` for encoding arrays.\n *\n * @example\n * Encoding an array of `u8` numbers.\n * ```ts\n * const encoder = getArrayEncoder(getU8Encoder());\n * const bytes = encoder.encode([1, 2, 3]);\n * // 0x03000000010203\n * //   |       └-- 3 items of 1 byte each.\n * //   └-- 4-byte prefix telling us to read 3 items.\n * ```\n *\n * @see {@link getArrayCodec}\n */\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<TFrom[], 0>;\nexport function getArrayEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: ArrayCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom[]> {\n    const size = config.size ?? getU32Encoder();\n    const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize !== null\n            ? { fixedSize }\n            : {\n                  getSizeFromValue: (array: TFrom[]) => {\n                      const prefixSize = typeof size === 'object' ? getEncodedSize(array.length, size) : 0;\n                      return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);\n                  },\n                  maxSize,\n              }),\n        write: (array: TFrom[], bytes, offset) => {\n            if (typeof size === 'number') {\n                assertValidNumberOfItemsForCodec('array', size, array.length);\n            }\n            if (typeof size === 'object') {\n                offset = size.write(array.length, bytes, offset);\n            }\n            array.forEach(value => {\n                offset = item.write(value, bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder for arrays of values.\n *\n * This decoder deserializes arrays by decoding each element using the provided item decoder.\n * By default, a `u32` size prefix is expected to indicate the number of items in the array.\n * The `size` option can be used to modify this behaviour.\n *\n * For more details, see {@link getArrayCodec}.\n *\n * @typeParam TTo - The type of the decoded elements in the array.\n *\n * @param item - The decoder for each item in the array.\n * @param config - Optional configuration for the size decoding strategy.\n * @returns A `VariableSizeDecoder<TTo[]>` for decoding arrays.\n *\n * @example\n * Decoding an array of `u8` numbers.\n * ```ts\n * const decoder = getArrayDecoder(getU8Decoder());\n * const array = decoder.decode(new Uint8Array([0x03, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03]));\n * // [1, 2, 3]\n * // 0x03000000010203\n * //   |       └-- 3 items of 1 byte each.\n * //   └-- 4-byte prefix telling us to read 3 items.\n * ```\n *\n * @see {@link getArrayCodec}\n */\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<TTo[], 0>;\nexport function getArrayDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: ArrayCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(item: Decoder<TTo>, config: ArrayCodecConfig<NumberDecoder> = {}): Decoder<TTo[]> {\n    const size = config.size ?? getU32Decoder();\n    const itemSize = getFixedSize(item);\n    const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize !== null ? { fixedSize } : { maxSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const array: TTo[] = [];\n            if (typeof size === 'object' && bytes.slice(offset).length === 0) {\n                return [array, offset];\n            }\n\n            if (size === 'remainder') {\n                while (offset < bytes.length) {\n                    const [value, newOffset] = item.read(bytes, offset);\n                    offset = newOffset;\n                    array.push(value);\n                }\n                return [array, offset];\n            }\n\n            const [resolvedSize, newOffset] = typeof size === 'number' ? [size, offset] : size.read(bytes, offset);\n            offset = newOffset;\n            for (let i = 0; i < resolvedSize; i += 1) {\n                const [value, newOffset] = item.read(bytes, offset);\n                offset = newOffset;\n                array.push(value);\n            }\n            return [array, offset];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding arrays of values.\n *\n * This codec serializes arrays by encoding each element using the provided item codec.\n * By default, a `u32` size prefix is included to indicate the number of items in the array.\n * The `size` option can be used to modify this behaviour.\n *\n * @typeParam TFrom - The type of the elements to encode.\n * @typeParam TTo - The type of the decoded elements.\n *\n * @param item - The codec for each item in the array.\n * @param config - Optional configuration for the size encoding/decoding strategy.\n * @returns A `VariableSizeCodec<TFrom[], TTo[]>` for encoding and decoding arrays.\n *\n * @example\n * Encoding and decoding an array of `u8` numbers.\n * ```ts\n * const codec = getArrayCodec(getU8Codec());\n * const bytes = codec.encode([1, 2, 3]);\n * // 0x03000000010203\n * //   |       └-- 3 items of 1 byte each.\n * //   └-- 4-byte prefix telling us to read 3 items.\n *\n * const array = codec.decode(bytes);\n * // [1, 2, 3]\n * ```\n *\n * @example\n * Using a `u16` size prefix instead of `u32`.\n * ```ts\n * const codec = getArrayCodec(getU8Codec(), { size: getU16Codec() });\n * const bytes = codec.encode([1, 2, 3]);\n * // 0x0300010203\n * //   |   └-- 3 items of 1 byte each.\n * //   └-- 2-byte prefix telling us to read 3 items.\n * ```\n *\n * @example\n * Using a fixed-size array of 3 items.\n * ```ts\n * const codec = getArrayCodec(getU8Codec(), { size: 3 });\n * codec.encode([1, 2, 3]);\n * // 0x010203\n * //   └-- 3 items of 1 byte each. There must always be 3 items in the array.\n * ```\n *\n * @example\n * Using the `\"remainder\"` size strategy.\n * ```ts\n * const codec = getArrayCodec(getU8Codec(), { size: 'remainder' });\n * codec.encode([1, 2, 3]);\n * // 0x010203\n * //   └-- 3 items of 1 byte each. The size is inferred from the remainder of the bytes.\n * ```\n *\n * @remarks\n * The size of the array can be controlled using the `size` option:\n * - A `Codec<number>` (e.g. `getU16Codec()`) stores a size prefix before the array.\n * - A `number` enforces a fixed number of elements.\n * - `\"remainder\"` uses all remaining bytes to infer the array length.\n *\n * Separate {@link getArrayEncoder} and {@link getArrayDecoder} functions are available.\n *\n * ```ts\n * const bytes = getArrayEncoder(getU8Encoder()).encode([1, 2, 3]);\n * const array = getArrayDecoder(getU8Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getArrayEncoder}\n * @see {@link getArrayDecoder}\n */\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<TFrom[], TTo[], 0>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: ArrayCodecConfig<NumberCodec>,\n): VariableSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> = {},\n): Codec<TFrom[], TTo[]> {\n    return combineCodec(getArrayEncoder(item, config as object), getArrayDecoder(item, config as object));\n}\n\nfunction computeArrayLikeCodecSize(size: number | object | 'remainder', itemSize: number | null): number | null {\n    if (typeof size !== 'number') return null;\n    if (size === 0) return 0;\n    return itemSize === null ? null : itemSize * size;\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from '@solana/codecs-core';\n\n/**\n * Defines the configuration options for bit array codecs.\n *\n * A bit array codec encodes an array of booleans into bits, packing them into bytes.\n * This configuration allows adjusting the bit ordering.\n *\n * @see {@link getBitArrayEncoder}\n * @see {@link getBitArrayDecoder}\n * @see {@link getBitArrayCodec}\n */\nexport type BitArrayCodecConfig = {\n    /**\n     * Determines whether the bits should be read in reverse order.\n     *\n     * - `false` (default): The first boolean is stored in the most significant bit (MSB-first).\n     * - `true`: The first boolean is stored in the least significant bit (LSB-first).\n     *\n     * @defaultValue `false`\n     */\n    backward?: boolean;\n};\n\n/**\n * Returns an encoder that packs an array of booleans into bits.\n *\n * This encoder converts a list of `boolean` values into a compact bit representation,\n * storing 8 booleans per byte.\n *\n * The `backward` config option determines whether the bits are stored in MSB-first (`false`)\n * or LSB-first (`true`).\n *\n * For more details, see {@link getBitArrayCodec}.\n *\n * @typeParam TSize - The number of bytes used to store the bit array.\n *\n * @param size - The number of bytes allocated for the bit array (must be sufficient for the expected boolean count).\n * @param config - Configuration options for encoding the bit array.\n * @returns A `FixedSizeEncoder<boolean[], TSize>` for encoding bit arrays.\n *\n * @example\n * Encoding a bit array.\n * ```ts\n * const encoder = getBitArrayEncoder(1);\n *\n * encoder.encode([true, false, true, false, false, false, false, false]);\n * // 0xa0 (0b10100000)\n * ```\n *\n * @see {@link getBitArrayCodec}\n */\nexport function getBitArrayEncoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeEncoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createEncoder({\n        fixedSize: size,\n        write(value: boolean[], bytes, offset) {\n            const bytesToAdd: number[] = [];\n\n            for (let i = 0; i < size; i += 1) {\n                let byte = 0;\n                for (let j = 0; j < 8; j += 1) {\n                    const feature = Number(value[i * 8 + j] ?? 0);\n                    byte |= feature << (backward ? j : 7 - j);\n                }\n                if (backward) {\n                    bytesToAdd.unshift(byte);\n                } else {\n                    bytesToAdd.push(byte);\n                }\n            }\n\n            bytes.set(bytesToAdd, offset);\n            return size;\n        },\n    });\n}\n\n/**\n * Returns a decoder that unpacks bits into an array of booleans.\n *\n * This decoder converts a compact bit representation back into a list of `boolean` values.\n * Each byte is expanded into 8 booleans.\n *\n * The `backward` config option determines whether the bits are read in MSB-first (`false`)\n * or LSB-first (`true`).\n *\n * For more details, see {@link getBitArrayCodec}.\n *\n * @typeParam TSize - The number of bytes used to store the bit array.\n *\n * @param size - The number of bytes allocated for the bit array (must be sufficient for the expected boolean count).\n * @param config - Configuration options for decoding the bit array.\n * @returns A `FixedSizeDecoder<boolean[], TSize>` for decoding bit arrays.\n *\n * @example\n * Decoding a bit array.\n * ```ts\n * const decoder = getBitArrayDecoder(1);\n *\n * decoder.decode(new Uint8Array([0xa0]));\n * // [true, false, true, false, false, false, false, false]\n * ```\n *\n * @see {@link getBitArrayCodec}\n */\nexport function getBitArrayDecoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeDecoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createDecoder({\n        fixedSize: size,\n        read(bytes, offset) {\n            assertByteArrayHasEnoughBytesForCodec('bitArray', size, bytes, offset);\n            const booleans: boolean[] = [];\n            let slice = bytes.slice(offset, offset + size);\n            slice = backward ? slice.reverse() : slice;\n\n            slice.forEach(byte => {\n                for (let i = 0; i < 8; i += 1) {\n                    if (backward) {\n                        booleans.push(Boolean(byte & 1));\n                        byte >>= 1;\n                    } else {\n                        booleans.push(Boolean(byte & 0b1000_0000));\n                        byte <<= 1;\n                    }\n                }\n            });\n\n            return [booleans, offset + size];\n        },\n    });\n}\n\n/**\n * Returns a codec that encodes and decodes boolean arrays as compact bit representations.\n *\n * This codec efficiently stores boolean arrays as bits, packing 8 values per byte.\n * The `backward` config option determines whether bits are stored in MSB-first (`false`)\n * or LSB-first (`true`).\n *\n * @typeParam TSize - The number of bytes used to store the bit array.\n *\n * @param size - The number of bytes allocated for the bit array (must be sufficient for the expected boolean count).\n * @param config - Configuration options for encoding and decoding the bit array.\n * @returns A `FixedSizeCodec<boolean[], boolean[], TSize>` for encoding and decoding bit arrays.\n *\n * @example\n * Encoding and decoding a bit array.\n * ```ts\n * const codec = getBitArrayCodec(1);\n *\n * codec.encode([true, false, true, false, false, false, false, false]);\n * // 0xa0 (0b10100000)\n *\n * codec.decode(new Uint8Array([0xa0]));\n * // [true, false, true, false, false, false, false, false]\n * ```\n *\n * @example\n * Encoding and decoding a bit array backwards.\n * ```ts\n * const codec = getBitArrayCodec(1, { backward: true });\n *\n * codec.encode([true, false, true, false, false, false, false, false]);\n * // 0x05 (0b00000101)\n *\n * codec.decode(new Uint8Array([0x05]));\n * // [true, false, true, false, false, false, false, false]\n * ```\n *\n * @remarks\n * Separate {@link getBitArrayEncoder} and {@link getBitArrayDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBitArrayEncoder(1).encode([true, false, true, false]);\n * const value = getBitArrayDecoder(1).decode(bytes);\n * ```\n *\n * @see {@link getBitArrayEncoder}\n * @see {@link getBitArrayDecoder}\n */\nexport function getBitArrayCodec<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeCodec<boolean[], boolean[], TSize> {\n    return combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\n/**\n * Defines the configuration options for boolean codecs.\n *\n * A boolean codec encodes `true` as `1` and `false` as `0`.\n * The `size` option allows customizing the number codec used for storage.\n *\n * @typeParam TSize - A number codec, encoder, or decoder used for boolean representation.\n *\n * @see {@link getBooleanEncoder}\n * @see {@link getBooleanDecoder}\n * @see {@link getBooleanCodec}\n */\nexport type BooleanCodecConfig<TSize extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The number codec used to store boolean values.\n     *\n     * - By default, booleans are stored as a `u8` (`1` for `true`, `0` for `false`).\n     * - A custom number codec can be provided to change the storage size.\n     *\n     * @defaultValue `u8`\n     */\n    size?: TSize;\n};\n\n/**\n * Returns an encoder for boolean values.\n *\n * This encoder converts `true` into `1` and `false` into `0`.\n * The `size` option allows customizing the number codec used for storage.\n *\n * For more details, see {@link getBooleanCodec}.\n *\n * @param config - Configuration options for encoding booleans.\n * @returns A `FixedSizeEncoder<boolean, N>` where `N` is the size of the number codec.\n *\n * @example\n * Encoding booleans.\n * ```ts\n * const encoder = getBooleanEncoder();\n *\n * encoder.encode(false); // 0x00\n * encoder.encode(true);  // 0x01\n * ```\n *\n * @see {@link getBooleanCodec}\n */\nexport function getBooleanEncoder(): FixedSizeEncoder<boolean, 1>;\nexport function getBooleanEncoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<boolean, TSize>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder>): VariableSizeEncoder<boolean>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder> = {}): Encoder<boolean> {\n    return transformEncoder(config.size ?? getU8Encoder(), (value: boolean) => (value ? 1 : 0));\n}\n\n/**\n * Returns a decoder for boolean values.\n *\n * This decoder reads a number and interprets `1` as `true` and `0` as `false`.\n * The `size` option allows customizing the number codec used for storage.\n *\n * For more details, see {@link getBooleanCodec}.\n *\n * @param config - Configuration options for decoding booleans.\n * @returns A `FixedSizeDecoder<boolean, N>` where `N` is the size of the number codec.\n *\n * @example\n * Decoding booleans.\n * ```ts\n * const decoder = getBooleanDecoder();\n *\n * decoder.decode(new Uint8Array([0x00])); // false\n * decoder.decode(new Uint8Array([0x01])); // true\n * ```\n *\n * @see {@link getBooleanCodec}\n */\nexport function getBooleanDecoder(): FixedSizeDecoder<boolean, 1>;\nexport function getBooleanDecoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<boolean, TSize>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder>): VariableSizeDecoder<boolean>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder> = {}): Decoder<boolean> {\n    return transformDecoder(config.size ?? getU8Decoder(), (value: bigint | number): boolean => Number(value) === 1);\n}\n\n/**\n * Returns a codec for encoding and decoding boolean values.\n *\n * By default, booleans are stored as a `u8` (`1` for `true`, `0` for `false`).\n * The `size` option allows customizing the number codec used for storage.\n *\n * @param config - Configuration options for encoding and decoding booleans.\n * @returns A `FixedSizeCodec<boolean, boolean, N>` where `N` is the size of the number codec.\n *\n * @example\n * Encoding and decoding booleans using a `u8` (default).\n * ```ts\n * const codec = getBooleanCodec();\n *\n * codec.encode(false); // 0x00\n * codec.encode(true);  // 0x01\n *\n * codec.decode(new Uint8Array([0x00])); // false\n * codec.decode(new Uint8Array([0x01])); // true\n * ```\n *\n * @example\n * Encoding and decoding booleans using a custom number codec.\n * ```ts\n * const codec = getBooleanCodec({ size: getU16Codec() });\n *\n * codec.encode(false); // 0x0000\n * codec.encode(true);  // 0x0100\n *\n * codec.decode(new Uint8Array([0x00, 0x00])); // false\n * codec.decode(new Uint8Array([0x01, 0x00])); // true\n * ```\n *\n * @remarks\n * Separate {@link getBooleanEncoder} and {@link getBooleanDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBooleanEncoder().encode(true);\n * const value = getBooleanDecoder().decode(bytes);\n * ```\n *\n * @see {@link getBooleanEncoder}\n * @see {@link getBooleanDecoder}\n */\nexport function getBooleanCodec(): FixedSizeCodec<boolean, boolean, 1>;\nexport function getBooleanCodec<TSize extends number>(\n    config: BooleanCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<boolean, boolean, TSize>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec>): VariableSizeCodec<boolean>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec> = {}): Codec<boolean> {\n    return combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\n/**\n * Returns an encoder for raw byte arrays.\n *\n * This encoder writes byte arrays exactly as provided without modification.\n *\n * The size of the encoded byte array is determined by the length of the input.\n * - To enforce a fixed size, consider using {@link fixEncoderSize}.\n * - To add a size prefix, use {@link addEncoderSizePrefix}.\n * - To add a sentinel value, use {@link addEncoderSentinel}.\n *\n * For more details, see {@link getBytesCodec}.\n *\n * @returns A `VariableSizeEncoder<ReadonlyUint8Array | Uint8Array>`.\n *\n * @example\n * Encoding a byte array as-is.\n * ```ts\n * const encoder = getBytesEncoder();\n *\n * encoder.encode(new Uint8Array([1, 2, 3])); // 0x010203\n * encoder.encode(new Uint8Array([255, 0, 127])); // 0xff007f\n * ```\n *\n * @see {@link getBytesCodec}\n */\nexport function getBytesEncoder(): VariableSizeEncoder<ReadonlyUint8Array | Uint8Array> {\n    return createEncoder({\n        getSizeFromValue: value => value.length,\n        write: (value, bytes, offset) => {\n            bytes.set(value, offset);\n            return offset + value.length;\n        },\n    });\n}\n\n/**\n * Returns a decoder for raw byte arrays.\n *\n * This decoder reads byte arrays exactly as provided without modification.\n *\n * The decoded byte array extends from the provided offset to the end of the input.\n * - To enforce a fixed size, consider using {@link fixDecoderSize}.\n * - To add a size prefix, use {@link addDecoderSizePrefix}.\n * - To add a sentinel value, use {@link addDecoderSentinel}.\n *\n * For more details, see {@link getBytesCodec}.\n *\n * @returns A `VariableSizeDecoder<ReadonlyUint8Array>`.\n *\n * @example\n * Decoding a byte array as-is.\n * ```ts\n * const decoder = getBytesDecoder();\n *\n * decoder.decode(new Uint8Array([1, 2, 3])); // Uint8Array([1, 2, 3])\n * decoder.decode(new Uint8Array([255, 0, 127])); // Uint8Array([255, 0, 127])\n * ```\n *\n * @see {@link getBytesCodec}\n */\nexport function getBytesDecoder(): VariableSizeDecoder<ReadonlyUint8Array> {\n    return createDecoder({\n        read: (bytes, offset) => {\n            const slice = bytes.slice(offset);\n            return [slice, offset + slice.length];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding raw byte arrays.\n *\n * This codec serializes and deserializes byte arrays without modification.\n *\n * The size of the encoded and decoded byte array is determined dynamically.\n * This means, when reading, the codec will consume all remaining bytes in the input.\n * - To enforce a fixed size, consider using {@link fixCodecSize}.\n * - To add a size prefix, use {@link addCodecSizePrefix}.\n * - To add a sentinel value, use {@link addCodecSentinel}.\n *\n * @returns A `VariableSizeCodec<ReadonlyUint8Array | Uint8Array, ReadonlyUint8Array>`.\n *\n * @example\n * Encoding and decoding a byte array.\n * ```ts\n * const codec = getBytesCodec();\n *\n * codec.encode(new Uint8Array([1, 2, 3])); // 0x010203\n * codec.decode(new Uint8Array([255, 0, 127])); // Uint8Array([255, 0, 127])\n * ```\n *\n * @remarks\n * Separate {@link getBytesEncoder} and {@link getBytesDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBytesEncoder().encode(new Uint8Array([1, 2, 3]));\n * const value = getBytesDecoder().decode(bytes);\n * ```\n *\n * @see {@link getBytesEncoder}\n * @see {@link getBytesDecoder}\n */\nexport function getBytesCodec(): VariableSizeCodec<ReadonlyUint8Array | Uint8Array, ReadonlyUint8Array> {\n    return combineCodec(getBytesEncoder(), getBytesDecoder());\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/**\n * Returns an encoder for base-16 (hexadecimal) strings.\n *\n * This encoder serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-16 strings.\n *\n * @example\n * Encoding a base-16 string.\n * ```ts\n * const encoder = getBase16Encoder();\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-16 (hexadecimal) strings.\n *\n * This decoder deserializes base-16 encoded strings from a byte array.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-16 strings.\n *\n * @example\n * Decoding a base-16 string.\n * ```ts\n * const decoder = getBase16Decoder();\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-16 (hexadecimal) strings.\n *\n * This codec serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-16 strings.\n *\n * @example\n * Encoding and decoding a base-16 string.\n * ```ts\n * const codec = getBase16Codec();\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-16 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase16Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-16 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase16Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase16Encoder} and {@link getBase16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase16Encoder().encode('deadface');\n * const value = getBase16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase16Encoder}\n * @see {@link getBase16Decoder}\n */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import {\n    combineCodec,\n    containsBytes,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { getBase16Decoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__CODECS__INVALID_CONSTANT, SolanaError } from '@solana/errors';\n\n/**\n * Returns an encoder that always writes a predefined constant byte sequence.\n *\n * This encoder ensures that encoding always produces the specified byte array,\n * ignoring any input values.\n *\n * For more details, see {@link getConstantCodec}.\n *\n * @typeParam TConstant - The fixed byte sequence that will be written during encoding.\n *\n * @param constant - The predefined byte array to encode.\n * @returns A `FixedSizeEncoder<void, N>` where `N` is the length of the constant.\n *\n * @example\n * Encoding a constant magic number.\n * ```ts\n * const encoder = getConstantEncoder(new Uint8Array([1, 2, 3, 4]));\n *\n * const bytes = encoder.encode();\n * // 0x01020304\n * //   └──────┘ The predefined 4-byte constant.\n * ```\n *\n * @see {@link getConstantCodec}\n */\nexport function getConstantEncoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeEncoder<void, TConstant['length']> {\n    return createEncoder({\n        fixedSize: constant.length,\n        write: (_, bytes, offset) => {\n            bytes.set(constant, offset);\n            return offset + constant.length;\n        },\n    });\n}\n\n/**\n * Returns a decoder that verifies a predefined constant byte sequence.\n *\n * This decoder reads the next bytes and checks that they match the provided constant.\n * If the bytes differ, it throws an error.\n *\n * For more details, see {@link getConstantCodec}.\n *\n * @typeParam TConstant - The fixed byte sequence expected during decoding.\n *\n * @param constant - The predefined byte array to verify.\n * @returns A `FixedSizeDecoder<void, N>` where `N` is the length of the constant.\n *\n * @example\n * Decoding a constant magic number.\n * ```ts\n * const decoder = getConstantDecoder(new Uint8Array([1, 2, 3]));\n *\n * decoder.decode(new Uint8Array([1, 2, 3])); // Passes\n * decoder.decode(new Uint8Array([1, 2, 4])); // Throws an error\n * ```\n *\n * @see {@link getConstantCodec}\n */\nexport function getConstantDecoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeDecoder<void, TConstant['length']> {\n    return createDecoder({\n        fixedSize: constant.length,\n        read: (bytes, offset) => {\n            const base16 = getBase16Decoder();\n            if (!containsBytes(bytes, constant, offset)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_CONSTANT, {\n                    constant,\n                    data: bytes,\n                    hexConstant: base16.decode(constant),\n                    hexData: base16.decode(bytes),\n                    offset,\n                });\n            }\n            return [undefined, offset + constant.length];\n        },\n    });\n}\n\n/**\n * Returns a codec that encodes and decodes a predefined constant byte sequence.\n *\n * - **Encoding:** Always writes the specified byte array.\n * - **Decoding:** Asserts that the next bytes match the constant, throwing an error if they do not.\n *\n * This is useful for encoding fixed byte patterns required in a binary format or to use in\n * conjunction with other codecs such as {@link getHiddenPrefixCodec} or {@link getHiddenSuffixCodec}.\n *\n * @typeParam TConstant - The fixed byte sequence to encode and verify during decoding.\n *\n * @param constant - The predefined byte array to encode and assert during decoding.\n * @returns A `FixedSizeCodec<void, void, N>` where `N` is the length of the constant.\n *\n * @example\n * Encoding and decoding a constant magic number.\n * ```ts\n * const codec = getConstantCodec(new Uint8Array([1, 2, 3]));\n *\n * codec.encode(); // 0x010203\n * codec.decode(new Uint8Array([1, 2, 3])); // Passes\n * codec.decode(new Uint8Array([1, 2, 4])); // Throws an error\n * ```\n *\n * @remarks\n * Separate {@link getConstantEncoder} and {@link getConstantDecoder} functions are available.\n *\n * ```ts\n * const bytes = getConstantEncoder(new Uint8Array([1, 2, 3])).encode();\n * getConstantDecoder(new Uint8Array([1, 2, 3])).decode(bytes);\n * ```\n *\n * @see {@link getConstantEncoder}\n * @see {@link getConstantDecoder}\n */\nexport function getConstantCodec<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeCodec<void, void, TConstant['length']> {\n    return combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\n/**\n * Infers the TypeScript type for a tuple that can be encoded using a tuple codec.\n *\n * This type maps each provided item encoder to its corresponding value type.\n *\n * @typeParam TItems - An array of encoders, each corresponding to a tuple element.\n */\ntype GetEncoderTypeFromItems<TItems extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\n/**\n * Infers the TypeScript type for a tuple that can be decoded using a tuple codec.\n *\n * This type maps each provided item decoder to its corresponding value type.\n *\n * @typeParam TItems - An array of decoders, each corresponding to a tuple element.\n */\ntype GetDecoderTypeFromItems<TItems extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Returns an encoder for tuples.\n *\n * This encoder serializes a fixed-size array (tuple) by encoding its items\n * sequentially using the provided item encoders.\n *\n * For more details, see {@link getTupleCodec}.\n *\n * @typeParam TItems - An array of encoders, each corresponding to a tuple element.\n *\n * @param items - The encoders for each item in the tuple.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding tuples.\n *\n * @example\n * Encoding a tuple with 2 items.\n * ```ts\n * const encoder = getTupleEncoder([fixCodecSize(getUtf8Encoder(), 5), getU8Encoder()]);\n *\n * const bytes = encoder.encode(['Alice', 42]);\n * // 0x416c6963652a\n * //   |         └── Second item (42)\n * //   └── First item (\"Alice\")\n * ```\n *\n * @see {@link getTupleCodec}\n */\nexport function getTupleEncoder<const TItems extends readonly FixedSizeEncoder<any>[]>(\n    items: TItems,\n): FixedSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): VariableSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): Encoder<GetEncoderTypeFromItems<TItems>> {\n    type TFrom = GetEncoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      items.map((item, index) => getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (value: TFrom, bytes, offset) => {\n            assertValidNumberOfItemsForCodec('tuple', items.length, value.length);\n            items.forEach((item, index) => {\n                offset = item.write(value[index], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder for tuples.\n *\n * This decoder deserializes a fixed-size array (tuple) by decoding its items\n * sequentially using the provided item decoders.\n *\n * For more details, see {@link getTupleCodec}.\n *\n * @typeParam TItems - An array of decoders, each corresponding to a tuple element.\n *\n * @param items - The decoders for each item in the tuple.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding tuples.\n *\n * @example\n * Decoding a tuple with 2 items.\n * ```ts\n * const decoder = getTupleDecoder([fixCodecSize(getUtf8Decoder(), 5), getU8Decoder()]);\n *\n * const tuple = decoder.decode(new Uint8Array([\n *   0x41,0x6c,0x69,0x63,0x65,0x2a\n * ]));\n * // ['Alice', 42]\n * ```\n *\n * @see {@link getTupleCodec}\n */\nexport function getTupleDecoder<const TItems extends readonly FixedSizeDecoder<any>[]>(\n    items: TItems,\n): FixedSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): VariableSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): Decoder<GetDecoderTypeFromItems<TItems>> {\n    type TTo = GetDecoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const values = [] as Array<any> & TTo;\n            items.forEach(item => {\n                const [newValue, newOffset] = item.read(bytes, offset);\n                values.push(newValue);\n                offset = newOffset;\n            });\n            return [values, offset];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding tuples.\n *\n * This codec serializes tuples by encoding and decoding each item sequentially.\n *\n * Unlike the {@link getArrayCodec} codec, each item in the tuple has its own codec\n * and, therefore, can be of a different type.\n *\n * @typeParam TItems - An array of codecs, each corresponding to a tuple element.\n *\n * @param items - The codecs for each item in the tuple.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding tuples.\n *\n * @example\n * Encoding and decoding a tuple with 2 items.\n * ```ts\n * const codec = getTupleCodec([fixCodecSize(getUtf8Codec(), 5), getU8Codec()]);\n *\n * const bytes = codec.encode(['Alice', 42]);\n * // 0x416c6963652a\n * //   |         └── Second item (42)\n * //   └── First item (\"Alice\")\n *\n * const tuple = codec.decode(bytes);\n * // ['Alice', 42]\n * ```\n *\n * @remarks\n * Separate {@link getTupleEncoder} and {@link getTupleDecoder} functions are available.\n *\n * ```ts\n * const bytes = getTupleEncoder([fixCodecSize(getUtf8Encoder(), 5), getU8Encoder()])\n *   .encode(['Alice', 42]);\n *\n * const tuple = getTupleDecoder([fixCodecSize(getUtf8Decoder(), 5), getU8Decoder()])\n *   .decode(bytes);\n * ```\n *\n * @see {@link getTupleEncoder}\n * @see {@link getTupleDecoder}\n */\nexport function getTupleCodec<const TItems extends readonly FixedSizeCodec<any>[]>(\n    items: TItems,\n): FixedSizeCodec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): VariableSizeCodec<\n    GetEncoderTypeFromItems<TItems>,\n    GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>\n>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): Codec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>> {\n    return combineCodec(\n        getTupleEncoder(items),\n        getTupleDecoder(items) as Decoder<GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>,\n    );\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { DrainOuterGeneric, getMaxSize, maxCodecSizes } from './utils';\n\n/**\n * Infers the TypeScript type for values that can be encoded using a union codec.\n *\n * This type maps the provided variant encoders to their corresponding value types.\n *\n * @typeParam TVariants - An array of encoders, each corresponding to a union variant.\n */\ntype GetEncoderTypeFromVariants<TVariants extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>[number];\n\n/**\n * Infers the TypeScript type for values that can be decoded using a union codec.\n *\n * This type maps the provided variant decoders to their corresponding value types.\n *\n * @typeParam TVariants - An array of decoders, each corresponding to a union variant.\n */\ntype GetDecoderTypeFromVariants<TVariants extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Decoder<infer TFrom> ? TFrom : never;\n}>[number];\n\ntype UnionEncoder<TVariants extends readonly Encoder<unknown>[]> = TVariants extends readonly FixedSizeEncoder<any>[]\n    ? FixedSizeEncoder<GetEncoderTypeFromVariants<TVariants>>\n    : Encoder<GetEncoderTypeFromVariants<TVariants>>;\n\ntype UnionDecoder<TVariants extends readonly Decoder<unknown>[]> = TVariants extends readonly FixedSizeDecoder<any>[]\n    ? FixedSizeDecoder<GetDecoderTypeFromVariants<TVariants>>\n    : Decoder<GetDecoderTypeFromVariants<TVariants>>;\n\ntype UnionCodec<TVariants extends readonly Codec<unknown>[]> = TVariants extends readonly FixedSizeCodec<any>[]\n    ? FixedSizeCodec<\n          GetEncoderTypeFromVariants<TVariants>,\n          GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n      >\n    : Codec<\n          GetEncoderTypeFromVariants<TVariants>,\n          GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n      >;\n\n/**\n * Returns an encoder for union types.\n *\n * This encoder serializes values by selecting the correct variant encoder\n * based on the `getIndexFromValue` function.\n *\n * Unlike other codecs, this encoder does not store the variant index.\n * It is the user's responsibility to manage discriminators separately.\n *\n * For more details, see {@link getUnionCodec}.\n *\n * @typeParam TVariants - An array of encoders, each corresponding to a union variant.\n *\n * @param variants - The encoders for each variant of the union.\n * @param getIndexFromValue - A function that determines the variant index from the provided value.\n * @returns An `Encoder` for encoding union values.\n *\n * @example\n * Encoding a union of numbers and booleans.\n * ```ts\n * const encoder = getUnionEncoder(\n *   [getU16Encoder(), getBooleanEncoder()],\n *   value => (typeof value === 'number' ? 0 : 1)\n * );\n *\n * encoder.encode(42);\n * // 0x2a00\n * //   └── Encoded number (42) as `u16`\n *\n * encoder.encode(true);\n * // 0x01\n * //   └── Encoded boolean (`true`) as `u8`\n * ```\n *\n * @see {@link getUnionCodec}\n */\nexport function getUnionEncoder<const TVariants extends readonly Encoder<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n): UnionEncoder<TVariants> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const write: Encoder<TFrom>['write'] = (variant, bytes, offset) => {\n        const index = getIndexFromValue(variant);\n        assertValidVariantIndex(variants, index);\n        return variants[index].write(variant, bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createEncoder({ fixedSize, write }) as UnionEncoder<TVariants>;\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createEncoder({\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: variant => {\n            const index = getIndexFromValue(variant);\n            assertValidVariantIndex(variants, index);\n            return getEncodedSize(variant, variants[index]);\n        },\n        write,\n    }) as UnionEncoder<TVariants>;\n}\n\n/**\n * Returns a decoder for union types.\n *\n * This decoder deserializes values by selecting the correct variant decoder\n * based on the `getIndexFromBytes` function.\n *\n * Unlike other codecs, this decoder does not assume a stored discriminator.\n * It is the user's responsibility to manage discriminators separately.\n *\n * For more details, see {@link getUnionCodec}.\n *\n * @typeParam TVariants - An array of decoders, each corresponding to a union variant.\n *\n * @param variants - The decoders for each variant of the union.\n * @param getIndexFromBytes - A function that determines the variant index from the byte array.\n * @returns A `Decoder` for decoding union values.\n *\n * @example\n * Decoding a union of numbers and booleans.\n * ```ts\n * const decoder = getUnionDecoder(\n *   [getU16Decoder(), getBooleanDecoder()],\n *   (bytes, offset) => (bytes.length - offset > 1 ? 0 : 1)\n * );\n *\n * decoder.decode(new Uint8Array([0x2a, 0x00])); // 42\n * decoder.decode(new Uint8Array([0x01]));       // true\n * // Type is inferred as `number | boolean`\n * ```\n *\n * @see {@link getUnionCodec}\n */\nexport function getUnionDecoder<const TVariants extends readonly Decoder<any>[]>(\n    variants: TVariants,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): UnionDecoder<TVariants> {\n    type TTo = GetDecoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const read: Decoder<TTo>['read'] = (bytes, offset) => {\n        const index = getIndexFromBytes(bytes, offset);\n        assertValidVariantIndex(variants, index);\n        return variants[index].read(bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createDecoder({ fixedSize, read }) as UnionDecoder<TVariants>;\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createDecoder({ ...(maxSize !== null ? { maxSize } : {}), read }) as UnionDecoder<TVariants>;\n}\n\n/**\n * Returns a codec for encoding and decoding union types.\n *\n * This codec serializes and deserializes union values by selecting the correct variant\n * based on the provided index functions.\n *\n * Unlike the {@link getDiscriminatedUnionCodec}, this codec does not assume a stored\n * discriminator and must be used with an explicit mechanism for managing discriminators.\n *\n * @typeParam TVariants - An array of codecs, each corresponding to a union variant.\n *\n * @param variants - The codecs for each variant of the union.\n * @param getIndexFromValue - A function that determines the variant index from the provided value.\n * @param getIndexFromBytes - A function that determines the variant index from the byte array.\n * @returns A `Codec` for encoding and decoding union values.\n *\n * @example\n * Encoding and decoding a union of numbers and booleans.\n * ```ts\n * const codec = getUnionCodec(\n *   [getU16Codec(), getBooleanCodec()],\n *   value => (typeof value === 'number' ? 0 : 1),\n *   (bytes, offset) => (bytes.length - offset > 1 ? 0 : 1)\n * );\n *\n * const bytes1 = codec.encode(42); // 0x2a00\n * const value1: number | boolean = codec.decode(bytes1); // 42\n *\n * const bytes2 = codec.encode(true); // 0x01\n * const value2: number | boolean = codec.decode(bytes2); // true\n * ```\n *\n * @remarks\n * If you need a codec that includes a stored discriminator,\n * consider using {@link getDiscriminatedUnionCodec}.\n *\n * Separate {@link getUnionEncoder} and {@link getUnionDecoder} functions are also available.\n *\n * ```ts\n * const bytes = getUnionEncoder(variantEncoders, getIndexFromValue).encode(42);\n * const value = getUnionDecoder(variantDecoders, getIndexFromBytes).decode(bytes);\n * ```\n *\n * @see {@link getUnionEncoder}\n * @see {@link getUnionDecoder}\n * @see {@link getDiscriminatedUnionCodec}\n */\nexport function getUnionCodec<const TVariants extends readonly Codec<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): UnionCodec<TVariants> {\n    return combineCodec(\n        getUnionEncoder(variants, getIndexFromValue),\n        getUnionDecoder(variants as readonly Decoder<any>[], getIndexFromBytes) as Decoder<\n            GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n        >,\n    ) as UnionCodec<TVariants>;\n}\n\nfunction assertValidVariantIndex(variants: readonly unknown[], index: number) {\n    if (typeof variants[index] === 'undefined') {\n        throw new SolanaError(SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {\n            maxRange: variants.length - 1,\n            minRange: 0,\n            variant: index,\n        });\n    }\n}\n\nfunction getUnionFixedSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    if (variants.length === 0) return 0;\n    if (!isFixedSize(variants[0])) return null;\n    const variantSize = variants[0].fixedSize;\n    const sameSizedVariants = variants.every(variant => isFixedSize(variant) && variant.fixedSize === variantSize);\n    return sameSizedVariants ? variantSize : null;\n}\n\nfunction getUnionMaxSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    return maxCodecSizes(variants.map(variant => getMaxSize(variant)));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n} from '@solana/codecs-core';\nimport { getU8Decoder, getU8Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, SolanaError } from '@solana/errors';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { DrainOuterGeneric } from './utils';\n\n/**\n * Represents a discriminated union using a specific discriminator property.\n *\n * A discriminated union is a TypeScript-friendly way to represent Rust-like enums.\n * Each variant in the union is distinguished by a shared discriminator property.\n *\n * @typeParam TDiscriminatorProperty - The name of the discriminator property.\n * @typeParam TDiscriminatorValue - The type of the discriminator value.\n *\n * @example\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant\n * ```\n */\nexport type DiscriminatedUnion<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorValue extends string = string,\n> = {\n    [P in TDiscriminatorProperty]: TDiscriminatorValue;\n};\n\n/**\n * Extracts a variant from a discriminated union based on its discriminator value.\n *\n * @typeParam TUnion - The discriminated union type.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n * @typeParam TDiscriminatorValue - The specific variant to extract.\n *\n * @example\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' }\n *   | { __kind: 'Write'; fields: [string] }\n *   | { __kind: 'Move'; x: number; y: number };\n *\n * type ClickEvent = GetDiscriminatedUnionVariant<Message, '__kind', 'Move'>;\n * // -> { __kind: 'Move'; x: number; y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariant<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Extract<TUnion, DiscriminatedUnion<TDiscriminatorProperty, TDiscriminatorValue>>;\n\n/**\n * Extracts a variant from a discriminated union without its discriminator property.\n *\n * @typeParam TUnion - The discriminated union type.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n * @typeParam TDiscriminatorValue - The specific variant to extract.\n *\n * @example\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' }\n *   | { __kind: 'Write'; fields: [string] }\n *   | { __kind: 'Move'; x: number; y: number };\n *\n * type MoveContent = GetDiscriminatedUnionVariantContent<Message, '__kind', 'Move'>;\n * // -> { x: number; y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariantContent<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Omit<GetDiscriminatedUnionVariant<TUnion, TDiscriminatorProperty, TDiscriminatorValue>, TDiscriminatorProperty>;\n\n/**\n * Defines the configuration for discriminated union codecs.\n *\n * This configuration controls how the discriminator is stored and named.\n *\n * @typeParam TDiscriminatorProperty - The property name of the discriminator.\n * @typeParam TDiscriminatorSize - The codec used for the discriminator prefix.\n */\nexport type DiscriminatedUnionCodecConfig<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorSize = NumberCodec | NumberDecoder | NumberEncoder,\n> = {\n    /**\n     * The property name of the discriminator.\n     * @defaultValue `__kind`\n     */\n    discriminator?: TDiscriminatorProperty;\n    /**\n     * The codec used to encode/decode the discriminator prefix.\n     * @defaultValue `u8` prefix\n     */\n    size?: TDiscriminatorSize;\n};\n\ntype DiscriminatorValue = bigint | boolean | number | string | null | undefined;\ntype Variants<T> = readonly (readonly [DiscriminatorValue, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromVariants<\n    TVariants extends Variants<Encoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Encoder<infer TFrom>\n        ? TFrom extends object\n            ? TFrom\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\ntype GetDecoderTypeFromVariants<\n    TVariants extends Variants<Decoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Decoder<infer TTo>\n        ? TTo extends object\n            ? TTo\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\ntype UnionEncoder<TVariants extends Variants<Encoder<unknown>>, TDiscriminatorProperty extends string> =\n    TVariants extends Variants<FixedSizeEncoder<any>>\n        ? FixedSizeEncoder<GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>>\n        : Encoder<GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>>;\n\ntype UnionDecoder<TVariants extends Variants<Decoder<unknown>>, TDiscriminatorProperty extends string> =\n    TVariants extends Variants<FixedSizeDecoder<any>>\n        ? FixedSizeDecoder<GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty>>\n        : Decoder<GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty>>;\n\ntype UnionCodec<TVariants extends Variants<Codec<unknown, unknown>>, TDiscriminatorProperty extends string> =\n    TVariants extends Variants<FixedSizeCodec<any, any>>\n        ? FixedSizeCodec<\n              GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>,\n              GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                  GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n          >\n        : Codec<\n              GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>,\n              GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                  GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n          >;\n\n/**\n * Returns an encoder for discriminated unions.\n *\n * This encoder serializes objects that follow the discriminated union pattern\n * by prefixing them with a numerical discriminator that represents their variant.\n *\n * Unlike {@link getUnionEncoder}, this encoder automatically extracts and processes\n * the discriminator property (default: `__kind`) from each variant.\n *\n * For more details, see {@link getDiscriminatedUnionCodec}.\n *\n * @typeParam TVariants - The variants of the discriminated union.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n *\n * @param variants - The variant encoders as `[discriminator, encoder]` pairs.\n * @param config - Configuration options for encoding.\n * @returns An `Encoder` for encoding discriminated union objects.\n *\n * @example\n * Encoding a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant.\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant.\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n *\n * const messageEncoder = getDiscriminatedUnionEncoder([\n *   ['Quit', getUnitEncoder()],\n *   ['Write', getStructEncoder([['fields', getTupleEncoder([addCodecSizePrefix(getUtf8Encoder(), getU32Encoder())])]])],\n *   ['Move', getStructEncoder([['x', getI32Encoder()], ['y', getI32Encoder()]])]\n * ]);\n *\n * messageEncoder.encode({ __kind: 'Move', x: 5, y: 6 });\n * // 0x020500000006000000\n * //   | |       └── Field y (6)\n * //   | └── Field x (5)\n * //   └── 1-byte discriminator (Index 2 — the \"Move\" variant)\n * ```\n *\n * @see {@link getDiscriminatedUnionCodec}\n */\nexport function getDiscriminatedUnionEncoder<\n    const TVariants extends Variants<Encoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberEncoder> = {},\n): UnionEncoder<TVariants, TDiscriminatorProperty> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>;\n    const discriminatorProperty = (config.discriminator ?? '__kind') as TDiscriminatorProperty;\n    const prefix = config.size ?? getU8Encoder();\n    return getUnionEncoder(\n        variants.map(([, variant], index) =>\n            transformEncoder(getTupleEncoder([prefix, variant]), (value: TFrom): [number, TFrom] => [index, value]),\n        ),\n        value => getVariantDiscriminator(variants, value[discriminatorProperty]),\n    ) as UnionEncoder<TVariants, TDiscriminatorProperty>;\n}\n\n/**\n * Returns a decoder for discriminated unions.\n *\n * This decoder deserializes objects that follow the discriminated union pattern\n * by **reading a numerical discriminator** and mapping it to the corresponding variant.\n *\n * Unlike {@link getUnionDecoder}, this decoder automatically inserts the discriminator\n * property (default: `__kind`) into the decoded object.\n *\n * For more details, see {@link getDiscriminatedUnionCodec}.\n *\n * @typeParam TVariants - The variants of the discriminated union.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n *\n * @param variants - The variant decoders as `[discriminator, decoder]` pairs.\n * @param config - Configuration options for decoding.\n * @returns A `Decoder` for decoding discriminated union objects.\n *\n * @example\n * Decoding a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant.\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant.\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n *\n * const messageDecoder = getDiscriminatedUnionDecoder([\n *   ['Quit', getUnitDecoder()],\n *   ['Write', getStructDecoder([['fields', getTupleDecoder([addCodecSizePrefix(getUtf8Decoder(), getU32Decoder())])]])],\n *   ['Move', getStructDecoder([['x', getI32Decoder()], ['y', getI32Decoder()]])]\n * ]);\n *\n * messageDecoder.decode(new Uint8Array([0x02,0x05,0x00,0x00,0x00,0x06,0x00,0x00,0x00]));\n * // { __kind: 'Move', x: 5, y: 6 }\n * ```\n *\n * @see {@link getDiscriminatedUnionCodec}\n */\nexport function getDiscriminatedUnionDecoder<\n    const TVariants extends Variants<Decoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberDecoder> = {},\n): UnionDecoder<TVariants, TDiscriminatorProperty> {\n    const discriminatorProperty = config.discriminator ?? '__kind';\n    const prefix = config.size ?? getU8Decoder();\n    return getUnionDecoder(\n        variants.map(([discriminator, variant]) =>\n            transformDecoder(getTupleDecoder([prefix, variant]), ([, value]) => ({\n                [discriminatorProperty]: discriminator,\n                ...value,\n            })),\n        ),\n        (bytes, offset) => Number(prefix.read(bytes, offset)[0]),\n    ) as UnionDecoder<TVariants, TDiscriminatorProperty>;\n}\n\n/**\n * Returns a codec for encoding and decoding {@link DiscriminatedUnion}.\n *\n * A {@link DiscriminatedUnion} is a TypeScript representation of Rust-like enums, where\n * each variant is distinguished by a discriminator field (default: `__kind`).\n *\n * This codec inserts a numerical prefix to represent the variant index.\n *\n * @typeParam TVariants - The variants of the discriminated union.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n *\n * @param variants - The variant codecs as `[discriminator, codec]` pairs.\n * @param config - Configuration options for encoding/decoding.\n * @returns A `Codec` for encoding and decoding discriminated union objects.\n *\n * @example\n * Encoding and decoding a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant.\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant.\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n *\n * const messageCodec = getDiscriminatedUnionCodec([\n *   ['Quit', getUnitCodec()],\n *   ['Write', getStructCodec([['fields', getTupleCodec([addCodecSizePrefix(getUtf8Codec(), getU32Codec())])]])],\n *   ['Move', getStructCodec([['x', getI32Codec()], ['y', getI32Codec()]])]\n * ]);\n *\n * messageCodec.encode({ __kind: 'Move', x: 5, y: 6 });\n * // 0x020500000006000000\n * //   | |       └── Field y (6)\n * //   | └── Field x (5)\n * //   └── 1-byte discriminator (Index 2 — the \"Move\" variant)\n *\n * const value = messageCodec.decode(bytes);\n * // { __kind: 'Move', x: 5, y: 6 }\n * ```\n *\n * @example\n * Using a `u32` discriminator instead of `u8`.\n * ```ts\n * const codec = getDiscriminatedUnionCodec([...], { size: getU32Codec() });\n *\n * codec.encode({ __kind: 'Quit' });\n * // 0x00000000\n * //   └------┘ 4-byte discriminator (Index 0)\n *\n * codec.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00]));\n * // { __kind: 'Quit' }\n * ```\n *\n * @example\n * Customizing the discriminator property.\n * ```ts\n * const codec = getDiscriminatedUnionCodec([...], { discriminator: 'message' });\n *\n * codec.encode({ message: 'Quit' }); // 0x00\n * codec.decode(new Uint8Array([0x00])); // { message: 'Quit' }\n * ```\n *\n * @remarks\n * Separate `getDiscriminatedUnionEncoder` and `getDiscriminatedUnionDecoder` functions are available.\n *\n * ```ts\n * const bytes = getDiscriminatedUnionEncoder(variantEncoders).encode({ __kind: 'Quit' });\n * const message = getDiscriminatedUnionDecoder(variantDecoders).decode(bytes);\n * ```\n *\n * @see {@link getDiscriminatedUnionEncoder}\n * @see {@link getDiscriminatedUnionDecoder}\n */\nexport function getDiscriminatedUnionCodec<\n    const TVariants extends Variants<Codec<any, any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberCodec> = {},\n): UnionCodec<TVariants, TDiscriminatorProperty> {\n    return combineCodec(\n        getDiscriminatedUnionEncoder(variants, config) as Encoder<\n            GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n        >,\n        getDiscriminatedUnionDecoder(variants, config) as Decoder<\n            GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n        >,\n    ) as UnionCodec<TVariants, TDiscriminatorProperty>;\n}\n\nfunction getVariantDiscriminator<const TVariants extends Variants<Decoder<any> | Encoder<any>>>(\n    variants: TVariants,\n    discriminatorValue: DiscriminatorValue,\n) {\n    const discriminator = variants.findIndex(([key]) => discriminatorValue === key);\n    if (discriminator < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {\n            value: discriminatorValue,\n            variants: variants.map(([key]) => key),\n        });\n    }\n    return discriminator;\n}\n","/**\n * Defines the \"lookup object\" of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * ```\n */\nexport type EnumLookupObject = { [key: string]: number | string };\n\n/**\n * Returns the allowed input for an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionInput = GetEnumFrom<Direction>; // \"Left\" | \"Right\" | 0 | 1\n * ```\n */\nexport type GetEnumFrom<TEnum extends EnumLookupObject> = TEnum[keyof TEnum] | keyof TEnum;\n\n/**\n * Returns all the available variants of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionOutput = GetEnumTo<Direction>; // 0 | 1\n * ```\n */\nexport type GetEnumTo<TEnum extends EnumLookupObject> = TEnum[keyof TEnum];\n\nexport function getEnumStats(constructor: EnumLookupObject) {\n    const numericalValues = [...new Set(Object.values(constructor).filter(v => typeof v === 'number'))].sort();\n    const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length)) as Record<\n        string,\n        number | string\n    >;\n    const enumKeys = Object.keys(enumRecord);\n    const enumValues = Object.values(enumRecord);\n    const stringValues: string[] = [\n        ...new Set([...enumKeys, ...enumValues.filter((v): v is string => typeof v === 'string')]),\n    ];\n\n    return { enumKeys, enumRecord, enumValues, numericalValues, stringValues };\n}\n\nexport function getEnumIndexFromVariant({\n    enumKeys,\n    enumValues,\n    variant,\n}: {\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    variant: number | string | symbol;\n}): number {\n    const valueIndex = findLastIndex(enumValues, value => value === variant);\n    if (valueIndex >= 0) return valueIndex;\n    return enumKeys.findIndex(key => key === variant);\n}\n\nexport function getEnumIndexFromDiscriminator({\n    discriminator,\n    enumKeys,\n    enumValues,\n    useValuesAsDiscriminators,\n}: {\n    discriminator: number;\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    useValuesAsDiscriminators: boolean;\n}): number {\n    if (!useValuesAsDiscriminators) {\n        return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;\n    }\n    return findLastIndex(enumValues, value => value === discriminator);\n}\n\nfunction findLastIndex<T>(array: Array<T>, predicate: (value: T, index: number, obj: T[]) => boolean): number {\n    let l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) return l;\n    }\n    return -1;\n}\n\nexport function formatNumericalValues(values: number[]): string {\n    if (values.length === 0) return '';\n    let range: [number, number] = [values[0], values[0]];\n    const ranges: string[] = [];\n    for (let index = 1; index < values.length; index++) {\n        const value = values[index];\n        if (range[1] + 1 === value) {\n            range[1] = value;\n        } else {\n            ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n            range = [value, value];\n        }\n    }\n    ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n    return ranges.join(', ');\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    EnumLookupObject,\n    formatNumericalValues,\n    GetEnumFrom,\n    getEnumIndexFromDiscriminator,\n    getEnumIndexFromVariant,\n    getEnumStats,\n    GetEnumTo,\n} from './enum-helpers';\n\n/**\n * Defines the configuration options for enum codecs.\n *\n * The `size` option determines the numerical encoding used for the enum's discriminant.\n * By default, enums are stored as a `u8` (1 byte).\n *\n * The `useValuesAsDiscriminators` option allows mapping the actual enum values\n * as discriminators instead of using their positional index.\n *\n * @typeParam TDiscriminator - A number codec, encoder, or decoder used for the discriminant.\n */\nexport type EnumCodecConfig<TDiscriminator extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec used to encode/decode the enum discriminator.\n     * @defaultValue `u8` discriminator.\n     */\n    size?: TDiscriminator;\n\n    /**\n     * If set to `true`, the enum values themselves will be used as discriminators.\n     * This is only valid for numerical enum values.\n     *\n     * @defaultValue `false`\n     */\n    useValuesAsDiscriminators?: boolean;\n};\n\n/**\n * Returns an encoder for enums.\n *\n * This encoder serializes enums as a numerical discriminator.\n * By default, the discriminator is based on the positional index of the enum variants.\n *\n * For more details, see {@link getEnumCodec}.\n *\n * @typeParam TEnum - The TypeScript enum or object mapping enum keys to values.\n *\n * @param constructor - The constructor of the enum.\n * @param config - Configuration options for encoding the enum.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding enums.\n *\n * @example\n * Encoding enum values.\n * ```ts\n * enum Direction { Up,  Down, Left, Right }\n * const encoder = getEnumEncoder(Direction);\n *\n * encoder.encode(Direction.Up);    // 0x00\n * encoder.encode(Direction.Down);  // 0x01\n * encoder.encode(Direction.Left);  // 0x02\n * encoder.encode(Direction.Right); // 0x03\n * ```\n *\n * @see {@link getEnumCodec}\n */\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberEncoder>, 'size'>,\n): FixedSizeEncoder<GetEnumFrom<TEnum>, 1>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<GetEnumFrom<TEnum>, TSize>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<GetEnumFrom<TEnum>>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> = {},\n): Encoder<GetEnumFrom<TEnum>> {\n    const prefix = config.size ?? getU8Encoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformEncoder(prefix, (variant: GetEnumFrom<TEnum>): number => {\n        const index = getEnumIndexFromVariant({ enumKeys, enumValues, variant });\n        if (index < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {\n                formattedNumericalValues: formatNumericalValues(numericalValues),\n                numericalValues,\n                stringValues,\n                variant,\n            });\n        }\n        return useValuesAsDiscriminators ? (enumValues[index] as number) : index;\n    });\n}\n\n/**\n * Returns a decoder for enums.\n *\n * This decoder deserializes enums from a numerical discriminator.\n * By default, the discriminator is based on the positional index of the enum variants.\n *\n * For more details, see {@link getEnumCodec}.\n *\n * @typeParam TEnum - The TypeScript enum or object mapping enum keys to values.\n *\n * @param constructor - The constructor of the enum.\n * @param config - Configuration options for decoding the enum.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding enums.\n *\n * @example\n * Decoding enum values.\n * ```ts\n * enum Direction { Up,  Down, Left, Right }\n * const decoder = getEnumDecoder(Direction);\n *\n * decoder.decode(new Uint8Array([0x00])); // Direction.Up\n * decoder.decode(new Uint8Array([0x01])); // Direction.Down\n * decoder.decode(new Uint8Array([0x02])); // Direction.Left\n * decoder.decode(new Uint8Array([0x03])); // Direction.Right\n * ```\n *\n * @see {@link getEnumCodec}\n */\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberDecoder>, 'size'>,\n): FixedSizeDecoder<GetEnumTo<TEnum>, 1>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<GetEnumTo<TEnum>, TSize>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<GetEnumTo<TEnum>>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> = {},\n): Decoder<GetEnumTo<TEnum>> {\n    const prefix = config.size ?? getU8Decoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformDecoder(prefix, (value: bigint | number): GetEnumTo<TEnum> => {\n        const discriminator = Number(value);\n        const index = getEnumIndexFromDiscriminator({\n            discriminator,\n            enumKeys,\n            enumValues,\n            useValuesAsDiscriminators,\n        });\n        if (index < 0) {\n            const validDiscriminators = useValuesAsDiscriminators\n                ? numericalValues\n                : [...Array(enumKeys.length).keys()];\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator,\n                formattedValidDiscriminators: formatNumericalValues(validDiscriminators),\n                validDiscriminators,\n            });\n        }\n        return enumValues[index] as GetEnumTo<TEnum>;\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding enums.\n *\n * This codec serializes enums as a numerical discriminator, allowing them\n * to be efficiently stored and reconstructed from binary data.\n *\n * By default, the discriminator is derived from the positional index\n * of the enum variant, but it can be configured to use the enum's numeric values instead.\n *\n * @typeParam TEnum - The TypeScript enum or object mapping enum keys to values.\n *\n * @param constructor - The constructor of the enum.\n * @param config - Configuration options for encoding and decoding the enum.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding enums.\n *\n * @example\n * Encoding and decoding enums using positional indexes.\n * ```ts\n * enum Direction { Up, Down, Left, Right }\n * const codec = getEnumCodec(Direction);\n *\n * codec.encode(Direction.Up);    // 0x00\n * codec.encode(Direction.Down);  // 0x01\n * codec.encode(Direction.Left);  // 0x02\n * codec.encode(Direction.Right); // 0x03\n *\n * codec.decode(new Uint8Array([0x00])); // Direction.Up\n * codec.decode(new Uint8Array([0x01])); // Direction.Down\n * codec.decode(new Uint8Array([0x02])); // Direction.Left\n * codec.decode(new Uint8Array([0x03])); // Direction.Right\n * ```\n *\n * @example\n * Encoding and decoding enums using their numeric values.\n * ```ts\n * enum GameDifficulty { Easy = 1, Normal = 4, Hard = 7, Expert = 9 }\n * const codec = getEnumCodec(GameDifficulty, { useValuesAsDiscriminators: true });\n *\n * codec.encode(GameDifficulty.Easy);   // 0x01\n * codec.encode(GameDifficulty.Normal); // 0x04\n * codec.encode(GameDifficulty.Hard);   // 0x07\n * codec.encode(GameDifficulty.Expert); // 0x09\n *\n * codec.decode(new Uint8Array([0x01])); // GameDifficulty.Easy\n * codec.decode(new Uint8Array([0x04])); // GameDifficulty.Normal\n * codec.decode(new Uint8Array([0x07])); // GameDifficulty.Hard\n * codec.decode(new Uint8Array([0x09])); // GameDifficulty.Expert\n * ```\n *\n * Note that, when using values as discriminators, the enum values must be numerical.\n * Otherwise, an error will be thrown.\n *\n * ```ts\n * enum GameDifficulty { Easy = 'EASY', Normal = 'NORMAL', Hard = 'HARD' }\n * getEnumCodec(GameDifficulty, { useValuesAsDiscriminators: true }); // Throws an error.\n * ```\n *\n * @example\n * Using a custom discriminator size.\n * ```ts\n * enum Status { Pending, Approved, Rejected }\n * const codec = getEnumCodec(Status, { size: getU16Codec() });\n *\n * codec.encode(Status.Pending);  // 0x0000\n * codec.encode(Status.Approved); // 0x0100\n * codec.encode(Status.Rejected); // 0x0200\n *\n * codec.decode(new Uint8Array([0x00, 0x00])); // Status.Pending\n * codec.decode(new Uint8Array([0x01, 0x00])); // Status.Approved\n * codec.decode(new Uint8Array([0x02, 0x00])); // Status.Rejected\n * ```\n *\n * @remarks\n * Separate {@link getEnumEncoder} and {@link getEnumDecoder} functions are available.\n *\n * ```ts\n * const bytes = getEnumEncoder(Direction).encode(Direction.Up);\n * const value = getEnumDecoder(Direction).decode(bytes);\n * ```\n *\n * @see {@link getEnumEncoder}\n * @see {@link getEnumDecoder}\n */\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberCodec>, 'size'>,\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, 1>;\nexport function getEnumCodec<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, TSize>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberCodec>,\n): VariableSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> = {},\n): Codec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>> {\n    return combineCodec(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Returns an encoder that prefixes encoded values with hidden data.\n *\n * This encoder applies a list of void encoders before encoding the main value.\n * The prefixed data is encoded before the main value without being exposed to the user.\n *\n * For more details, see {@link getHiddenPrefixCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param encoder - The encoder for the main value.\n * @param prefixedEncoders - A list of void encoders that produce the hidden prefix.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` that encodes the value with a hidden prefix.\n *\n * @example\n * Prefixing a value with constants.\n * ```ts\n * const encoder = getHiddenPrefixEncoder(getUtf8Encoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * encoder.encode('Hello');\n * // 0x01020304050648656c6c6f\n * //   |     |     └-- Our encoded value (\"Hello\").\n * //   |     └-- Our second hidden prefix.\n * //   └-- Our first hidden prefix.\n * ```\n *\n * @see {@link getHiddenPrefixCodec}\n */\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([...prefixedEncoders, encoder]) as Encoder<readonly [...void[], TFrom]>,\n        (value: TFrom) => [...prefixedEncoders.map(() => undefined), value] as const,\n    );\n}\n\n/**\n * Returns a decoder that skips hidden prefixed data before decoding the main value.\n *\n * This decoder applies a list of void decoders before decoding the main value.\n * The prefixed data is skipped during decoding without being exposed to the user.\n *\n * For more details, see {@link getHiddenPrefixCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param decoder - The decoder for the main value.\n * @param prefixedDecoders - A list of void decoders that produce the hidden prefix.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` that decodes values while ignoring the hidden prefix.\n *\n * @example\n * Decoding a value with prefixed constants.\n * ```ts\n * const decoder = getHiddenPrefixDecoder(getUtf8Decoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * decoder.decode(new Uint8Array([1, 2, 3, 4, 5, 6, 0x48, 0x65, 0x6C, 0x6C, 0x6F]));\n * // 'Hello'\n * ```\n *\n * @see {@link getHiddenPrefixCodec}\n */\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([...prefixedDecoders, decoder]) as Decoder<readonly [...void[], TTo]>,\n        tuple => tuple[tuple.length - 1] as TTo,\n    );\n}\n\n/**\n * Returns a codec that encodes and decodes values with a hidden prefix.\n *\n * - **Encoding:** Prefixes the value with hidden data before encoding.\n * - **Decoding:** Skips the hidden prefix before decoding the main value.\n *\n * This is useful for any implicit metadata that should be present in\n * binary formats but omitted from the API.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param codec - The codec for the main value.\n * @param prefixedCodecs - A list of void codecs that produce the hidden prefix.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding values with a hidden prefix.\n *\n * @example\n * Encoding and decoding a value with prefixed constants.\n * ```ts\n * const codec = getHiddenPrefixCodec(getUtf8Codec(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * const bytes = codec.encode('Hello');\n * // 0x01020304050648656c6c6f\n * //   |     |     └-- Our encoded value (\"Hello\").\n * //   |     └-- Our second hidden prefix.\n * //   └-- Our first hidden prefix.\n *\n * codec.decode(bytes);\n * // 'Hello'\n * ```\n *\n * @remarks\n * If all you need is padding zeroes before a value, consider using {@link padLeftCodec} instead.\n *\n * Separate {@link getHiddenPrefixEncoder} and {@link getHiddenPrefixDecoder} functions are available.\n *\n * ```ts\n * const bytes = getHiddenPrefixEncoder(getUtf8Encoder(), [\n *   getConstantEncoder(new Uint8Array([1, 2, 3])),\n *   getConstantEncoder(new Uint8Array([4, 5, 6])),\n * ]).encode('Hello');\n *\n * const value = getHiddenPrefixDecoder(getUtf8Decoder(), [\n *   getConstantDecoder(new Uint8Array([1, 2, 3])),\n *   getConstantDecoder(new Uint8Array([4, 5, 6])),\n * ]).decode(bytes);\n * ```\n *\n * @see {@link getHiddenPrefixEncoder}\n * @see {@link getHiddenPrefixDecoder}\n */\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Returns an encoder that appends hidden data after the encoded value.\n *\n * This encoder applies a list of void encoders after encoding the main value.\n * The suffixed data is encoded after the main value without being exposed to the user.\n *\n * For more details, see {@link getHiddenSuffixCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param encoder - The encoder for the main value.\n * @param suffixedEncoders - A list of void encoders that produce the hidden suffix.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` that encodes the value with a hidden suffix.\n *\n * @example\n * Suffixing a value with constants.\n * ```ts\n * const encoder = getHiddenSuffixEncoder(getUtf8Encoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * encoder.encode('Hello');\n * // 0x48656c6c6f010203040506\n * //   |         |     └-- Our second hidden suffix.\n * //   |         └-- Our first hidden suffix.\n * //   └-- Our encoded value (\"Hello\").\n * ```\n *\n * @see {@link getHiddenSuffixCodec}\n */\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    suffixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([encoder, ...suffixedEncoders]) as Encoder<readonly [TFrom, ...void[]]>,\n        (value: TFrom) => [value, ...suffixedEncoders.map(() => undefined)] as const,\n    );\n}\n\n/**\n * Returns a decoder that skips hidden suffixed data after decoding the main value.\n *\n * This decoder applies a list of void decoders after decoding the main value.\n * The suffixed data is skipped during decoding without being exposed to the user.\n *\n * For more details, see {@link getHiddenSuffixCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param decoder - The decoder for the main value.\n * @param suffixedDecoders - A list of void decoders that produce the hidden suffix.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` that decodes values while ignoring the hidden suffix.\n *\n * @example\n * Decoding a value with suffixed constants.\n * ```ts\n * const decoder = getHiddenSuffixDecoder(getUtf8Decoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * decoder.decode(new Uint8Array([0x48, 0x65, 0x6C, 0x6C, 0x6F, 1, 2, 3, 4, 5, 6]));\n * // 'Hello'\n * ```\n *\n * @see {@link getHiddenSuffixCodec}\n */\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    suffixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([decoder, ...suffixedDecoders]) as Decoder<readonly [TTo, ...void[]]>,\n        tuple => tuple[0],\n    );\n}\n\n/**\n * Returns a codec that encodes and decodes values with a hidden suffix.\n *\n * - **Encoding:** Appends hidden data after encoding the main value.\n * - **Decoding:** Skips the hidden suffix after decoding the main value.\n *\n * This is useful for any implicit metadata that should be present in\n * binary formats but omitted from the API.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param codec - The codec for the main value.\n * @param suffixedCodecs - A list of void codecs that produce the hidden suffix.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding values with a hidden suffix.\n *\n * @example\n * Encoding and decoding a value with suffixed constants.\n * ```ts\n * const codec = getHiddenSuffixCodec(getUtf8Codec(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * const bytes = codec.encode('Hello');\n * // 0x48656c6c6f010203040506\n * //   |         |     └-- Our second hidden suffix.\n * //   |         └-- Our first hidden suffix.\n * //   └-- Our encoded value (\"Hello\").\n *\n * codec.decode(bytes);\n * // 'Hello'\n * ```\n *\n * @remarks\n * If all you need is padding zeroes after a value, consider using {@link padRightCodec} instead.\n *\n * Separate {@link getHiddenSuffixEncoder} and {@link getHiddenSuffixDecoder} functions are available.\n *\n * ```ts\n * const bytes = getHiddenSuffixEncoder(getUtf8Encoder(), [\n *   getConstantEncoder(new Uint8Array([1, 2, 3])),\n *   getConstantEncoder(new Uint8Array([4, 5, 6])),\n * ]).encode('Hello');\n *\n * const value = getHiddenSuffixDecoder(getUtf8Decoder(), [\n *   getConstantDecoder(new Uint8Array([1, 2, 3])),\n *   getConstantDecoder(new Uint8Array([4, 5, 6])),\n * ]).decode(bytes);\n * ```\n *\n * @see {@link getHiddenSuffixEncoder}\n * @see {@link getHiddenSuffixDecoder}\n */\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    suffixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\n/**\n * Defines the configuration options for literal union codecs.\n *\n * A literal union codec encodes values from a predefined set of literals.\n * The `size` option determines the numerical encoding used for the discriminant.\n * By default, literals are stored as a `u8` (1 byte).\n *\n * @typeParam TDiscriminator - A number codec, encoder, or decoder used for the discriminant.\n */\nexport type LiteralUnionCodecConfig<TDiscriminator = NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec used to encode/decode the discriminator.\n     * @defaultValue `u8` discriminator.\n     */\n    size?: TDiscriminator;\n};\n\ntype Variant = bigint | boolean | number | string | null | undefined;\ntype GetTypeFromVariants<TVariants extends readonly Variant[]> = TVariants[number];\n\n/**\n * Returns an encoder for literal unions.\n *\n * This encoder serializes a value from a predefined set of literals\n * as a numerical index representing its position in the `variants` array.\n *\n * For more details, see {@link getLiteralUnionCodec}.\n *\n * @typeParam TVariants - A tuple of allowed literal values.\n *\n * @param variants - The possible literal values for the union.\n * @param config - Configuration options for encoding the literal union.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding literal unions.\n *\n * @example\n * Encoding a union of string literals.\n * ```ts\n * type Size = 'small' | 'medium' | 'large';\n * const sizeEncoder = getLiteralUnionEncoder(['small', 'medium', 'large']);\n *\n * sizeEncoder.encode('small');  // 0x00\n * sizeEncoder.encode('medium'); // 0x01\n * sizeEncoder.encode('large');  // 0x02\n * ```\n *\n * @see {@link getLiteralUnionCodec}\n */\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n): FixedSizeEncoder<GetTypeFromVariants<TVariants>, 1>;\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[], TSize extends number>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<GetTypeFromVariants<TVariants>, TSize>;\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config?: LiteralUnionCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<GetTypeFromVariants<TVariants>>;\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberEncoder> = {},\n): Encoder<GetTypeFromVariants<TVariants>> {\n    const discriminator = config.size ?? getU8Encoder();\n    return transformEncoder(discriminator, variant => {\n        const index = variants.indexOf(variant);\n        if (index < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT, {\n                value: variant,\n                variants,\n            });\n        }\n        return index;\n    });\n}\n\n/**\n * Returns a decoder for literal unions.\n *\n * This decoder deserializes a numerical index into a corresponding\n * value from a predefined set of literals.\n *\n * For more details, see {@link getLiteralUnionCodec}.\n *\n * @typeParam TVariants - A tuple of allowed literal values.\n *\n * @param variants - The possible literal values for the union.\n * @param config - Configuration options for decoding the literal union.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding literal unions.\n *\n * @example\n * Decoding a union of string literals.\n * ```ts\n * type Size = 'small' | 'medium' | 'large';\n * const sizeDecoder = getLiteralUnionDecoder(['small', 'medium', 'large']);\n *\n * sizeDecoder.decode(new Uint8Array([0x00])); // 'small'\n * sizeDecoder.decode(new Uint8Array([0x01])); // 'medium'\n * sizeDecoder.decode(new Uint8Array([0x02])); // 'large'\n * ```\n *\n * @see {@link getLiteralUnionCodec}\n */\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n): FixedSizeDecoder<GetTypeFromVariants<TVariants>, 1>;\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[], TSize extends number>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<GetTypeFromVariants<TVariants>, TSize>;\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config?: LiteralUnionCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<GetTypeFromVariants<TVariants>>;\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberDecoder> = {},\n): Decoder<GetTypeFromVariants<TVariants>> {\n    const discriminator = config.size ?? getU8Decoder();\n    return transformDecoder(discriminator, (index: bigint | number) => {\n        if (index < 0 || index >= variants.length) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator: index,\n                maxRange: variants.length - 1,\n                minRange: 0,\n            });\n        }\n        return variants[Number(index)];\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding literal unions.\n *\n * A literal union codec serializes and deserializes values\n * from a predefined set of literals, using a numerical index\n * to represent each value in the `variants` array.\n *\n * This allows efficient storage and retrieval of common\n * predefined values such as enum-like structures in TypeScript.\n *\n * @typeParam TVariants - A tuple of allowed literal values.\n *\n * @param variants - The possible literal values for the union.\n * @param config - Configuration options for encoding and decoding the literal union.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding literal unions.\n *\n * @example\n * Encoding and decoding a union of string literals.\n * ```ts\n * type Size = 'small' | 'medium' | 'large';\n * const sizeCodec = getLiteralUnionCodec(['small', 'medium', 'large']);\n *\n * sizeCodec.encode('small');  // 0x00\n * sizeCodec.encode('medium'); // 0x01\n * sizeCodec.encode('large');  // 0x02\n *\n * sizeCodec.decode(new Uint8Array([0x00])); // 'small'\n * sizeCodec.decode(new Uint8Array([0x01])); // 'medium'\n * sizeCodec.decode(new Uint8Array([0x02])); // 'large'\n * ```\n *\n * @example\n * Encoding and decoding a union of number literals.\n * ```ts\n * type Level = 10 | 20 | 30;\n * const levelCodec = getLiteralUnionCodec([10, 20, 30]);\n *\n * levelCodec.encode(10);  // 0x00\n * levelCodec.encode(20);  // 0x01\n * levelCodec.encode(30);  // 0x02\n *\n * levelCodec.decode(new Uint8Array([0x00])); // 10\n * levelCodec.decode(new Uint8Array([0x01])); // 20\n * levelCodec.decode(new Uint8Array([0x02])); // 30\n * ```\n *\n * @example\n * Using a custom discriminator size with different variant types.\n * ```ts\n * type MaybeBoolean = false | true | \"either\";\n * const codec = getLiteralUnionCodec([false, true, 'either'], { size: getU16Codec() });\n *\n * codec.encode(false);    // 0x0000\n * codec.encode(true);     // 0x0100\n * codec.encode('either'); // 0x0200\n *\n * codec.decode(new Uint8Array([0x00, 0x00])); // false\n * codec.decode(new Uint8Array([0x01, 0x00])); // true\n * codec.decode(new Uint8Array([0x02, 0x00])); // 'either'\n * ```\n *\n * @remarks\n * Separate {@link getLiteralUnionEncoder} and {@link getLiteralUnionDecoder} functions are available.\n *\n * ```ts\n * const bytes = getLiteralUnionEncoder(['red', 'green', 'blue']).encode('green');\n * const value = getLiteralUnionDecoder(['red', 'green', 'blue']).decode(bytes);\n * ```\n *\n * @see {@link getLiteralUnionEncoder}\n * @see {@link getLiteralUnionDecoder}\n */\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n): FixedSizeCodec<GetTypeFromVariants<TVariants>, GetTypeFromVariants<TVariants>, 1>;\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[], TSize extends number>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<GetTypeFromVariants<TVariants>, GetTypeFromVariants<TVariants>, TSize>;\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config?: LiteralUnionCodecConfig<NumberCodec>,\n): VariableSizeCodec<GetTypeFromVariants<TVariants>>;\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberCodec> = {},\n): Codec<GetTypeFromVariants<TVariants>> {\n    return combineCodec(getLiteralUnionEncoder(variants, config), getLiteralUnionDecoder(variants, config));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Defines the configuration options for map codecs.\n *\n * The `size` option determines how the number of entries in the map is stored.\n * It can be:\n * - A {@link NumberCodec} to prefix the map with its size.\n * - A fixed number of entries.\n * - `'remainder'`, which infers the number of entries based on the remaining bytes.\n *   This option is only available for fixed-size keys and values.\n *\n * @typeParam TPrefix - A number codec, encoder, or decoder used for the size prefix.\n */\nexport type MapCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the map.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Returns an encoder for maps.\n *\n * This encoder serializes maps where the keys and values are encoded\n * using the provided key and value encoders. The number of entries\n * is determined by the `size` configuration.\n *\n * For more details, see {@link getMapCodec}.\n *\n * @typeParam TFromKey - The type of the keys before encoding.\n * @typeParam TFromValue - The type of the values before encoding.\n *\n * @param key - The encoder for the map's keys.\n * @param value - The encoder for the map's values.\n * @param config - Configuration options for encoding the map.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding maps.\n *\n * @example\n * Encoding a map with a `u32` size prefix.\n * ```ts\n * const encoder = getMapEncoder(fixCodecSize(getUtf8Encoder(), 5), getU8Encoder());\n * const bytes = encoder.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x02000000616c6963652a626f62000005\n * //   |       |         | |         └── Value (5)\n * //   |       |         | └── Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |       |         └── Value (42)\n * //   |       └── Key (\"alice\", 5 bytes fixed)\n * //   └── 4-byte prefix (2 entries)\n * ```\n *\n * @see {@link getMapCodec}\n */\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>, 0>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: FixedSizeEncoder<TFromKey>,\n    value: FixedSizeEncoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config?: MapCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> = {},\n): Encoder<Map<TFromKey, TFromValue>> {\n    return transformEncoder(\n        getArrayEncoder(getTupleEncoder([key, value]), config as object),\n        (map: Map<TFromKey, TFromValue>): [TFromKey, TFromValue][] => [...map.entries()],\n    );\n}\n\n/**\n * Returns a decoder for maps.\n *\n * This decoder deserializes maps where the keys and values are decoded\n * using the provided key and value decoders. The number of entries\n * is determined by the `size` configuration.\n *\n * For more details, see {@link getMapCodec}.\n *\n * @typeParam TToKey - The type of the keys after decoding.\n * @typeParam TToValue - The type of the values after decoding.\n *\n * @param key - The decoder for the map's keys.\n * @param value - The decoder for the map's values.\n * @param config - Configuration options for decoding the map.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding maps.\n *\n * @example\n * Decoding a map with a `u32` size prefix.\n * ```ts\n * const decoder = getMapDecoder(fixCodecSize(getUtf8Decoder(), 5), getU8Decoder());\n * const map = decoder.decode(new Uint8Array([\n *   0x02,0x00,0x00,0x00,0x61,0x6c,0x69,0x63,0x65,0x2a,0x62,0x6f,0x62,0x00,0x00,0x05\n * ]));\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @see {@link getMapCodec}\n */\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Map<TToKey, TToValue>, 0>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: FixedSizeDecoder<TToKey>,\n    value: FixedSizeDecoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config?: MapCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> = {},\n): Decoder<Map<TToKey, TToValue>> {\n    return transformDecoder(\n        getArrayDecoder(getTupleDecoder([key, value]), config as object) as Decoder<[TToKey, TToValue][]>,\n        (entries: [TToKey, TToValue][]): Map<TToKey, TToValue> => new Map(entries),\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding maps.\n *\n * This codec serializes maps where the key/value pairs are encoded\n * and decoded one after another using the provided key and value codecs.\n * The number of entries is determined by the `size` configuration and\n * defaults to a `u32` size prefix.\n *\n * @typeParam TFromKey - The type of the keys before encoding.\n * @typeParam TFromValue - The type of the values before encoding.\n * @typeParam TToKey - The type of the keys after decoding.\n * @typeParam TToValue - The type of the values after decoding.\n *\n * @param key - The codec for the map's keys.\n * @param value - The codec for the map's values.\n * @param config - Configuration options for encoding and decoding the map.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding maps.\n *\n * @example\n * Encoding and decoding a map with a `u32` size prefix (default).\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec());\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x02000000616c6963652a626f62000005\n * //   |       |         | |         └── Value (5)\n * //   |       |         | └── Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |       |         └── Value (42)\n * //   |       └── Key (\"alice\", 5 bytes fixed)\n * //   └── 4-byte prefix (2 entries)\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @example\n * Encoding and decoding a map with a `u16` size prefix.\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec(), { size: getU16Codec() });\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x0200616c6963652a626f62000005\n * //   |   |         | |         └── Value (5)\n * //   |   |         | └── Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |   |         └── Value (42)\n * //   |   └── Key (\"alice\", 5 bytes fixed)\n * //   └── 2-byte prefix (2 entries)\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @example\n * Encoding and decoding a fixed-size map.\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec(), { size: 2 });\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x616c6963652a626f62000005\n * //   |         | |         └── Value (5)\n * //   |         | └── Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |         └── Value (42)\n * //   └── Key (\"alice\", 5 bytes fixed)\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @example\n * Encoding and decoding a map with remainder size.\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec(), { size: 'remainder' });\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x616c6963652a626f62000005\n * //   |         | |         └── Value (5)\n * //   |         | └── Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |         └── Value (42)\n * //   └── Key (\"alice\", 5 bytes fixed)\n * // No size prefix, the size is inferred from the remaining bytes.\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @remarks\n * Separate {@link getMapEncoder} and {@link getMapDecoder} functions are available.\n * ```ts\n * const bytes = getMapEncoder(fixCodecSize(getUtf8Encoder(), 5), getU8Encoder()).encode(new Map([['alice', 42]]));\n * const map = getMapDecoder(fixCodecSize(getUtf8Decoder(), 5), getU8Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getMapEncoder}\n * @see {@link getMapDecoder}\n */\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>, 0>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: FixedSizeCodec<TFromKey, TToKey>,\n    value: FixedSizeCodec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config?: MapCodecConfig<NumberCodec>,\n): VariableSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> = {},\n): Codec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>> {\n    return combineCodec(getMapEncoder(key, value, config as object), getMapDecoder(key, value, config as object));\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\n/**\n * Returns an encoder for `void` values.\n *\n * This encoder writes nothing to the byte array and has a fixed size of 0 bytes.\n * It is useful when working with structures that require a no-op encoder,\n * such as empty variants in {@link getDiscriminatedUnionEncoder}.\n *\n * For more details, see {@link getUnitCodec}.\n *\n * @returns A `FixedSizeEncoder<void, 0>`, representing an empty encoder.\n *\n * @example\n * Encoding a `void` value.\n * ```ts\n * getUnitEncoder().encode(undefined); // Produces an empty byte array.\n * ```\n *\n * @see {@link getUnitCodec}\n */\nexport function getUnitEncoder(): FixedSizeEncoder<void, 0> {\n    return createEncoder({\n        fixedSize: 0,\n        write: (_value, _bytes, offset) => offset,\n    });\n}\n\n/**\n * Returns a decoder for `void` values.\n *\n * This decoder always returns `undefined` and has a fixed size of 0 bytes.\n * It is useful when working with structures that require a no-op decoder,\n * such as empty variants in {@link getDiscriminatedUnionDecoder}.\n *\n * For more details, see {@link getUnitCodec}.\n *\n * @returns A `FixedSizeDecoder<void, 0>`, representing an empty decoder.\n *\n * @example\n * Decoding a `void` value.\n * ```ts\n * getUnitDecoder().decode(anyBytes); // Returns `undefined`.\n * ```\n *\n * @see {@link getUnitCodec}\n */\nexport function getUnitDecoder(): FixedSizeDecoder<void, 0> {\n    return createDecoder({\n        fixedSize: 0,\n        read: (_bytes: ReadonlyUint8Array | Uint8Array, offset) => [undefined, offset],\n    });\n}\n\n/**\n * Returns a codec for `void` values.\n *\n * This codec does nothing when encoding or decoding and has a fixed size of 0 bytes.\n * Namely, it always returns `undefined` when decoding and produces an empty byte array when encoding.\n *\n * This can be useful when working with structures that require a no-op codec,\n * such as empty variants in {@link getDiscriminatedUnionCodec}.\n *\n * @returns A `FixedSizeCodec<void, void, 0>`, representing an empty codec.\n *\n * @example\n * Encoding and decoding a `void` value.\n * ```ts\n * const codec = getUnitCodec();\n *\n * codec.encode(undefined); // Produces an empty byte array.\n * codec.decode(new Uint8Array([])); // Returns `undefined`.\n * ```\n *\n * @example\n * Using unit codecs as empty variants in a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Enter' }\n *   | { __kind: 'Leave' }\n *   | { __kind: 'Move'; x: number; y: number };\n *\n * const messageCodec = getDiscriminatedUnionCodec([\n *   ['Enter', getUnitCodec()], // <- No-op codec for empty data\n *   ['Leave', getUnitCodec()], // <- No-op codec for empty data\n *   ['Move', getStructCodec([...])]\n * ]);\n * ```\n *\n * @remarks\n * Separate {@link getUnitEncoder} and {@link getUnitDecoder} functions are available.\n *\n * ```ts\n * const bytes = getUnitEncoder().encode();\n * const value = getUnitDecoder().decode(bytes);\n * ```\n *\n * @see {@link getUnitEncoder}\n * @see {@link getUnitDecoder}\n */\nexport function getUnitCodec(): FixedSizeCodec<void, void, 0> {\n    return combineCodec(getUnitEncoder(), getUnitDecoder());\n}\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { getBooleanDecoder, getBooleanEncoder } from './boolean';\nimport { getConstantDecoder, getConstantEncoder } from './constant';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { getUnitDecoder, getUnitEncoder } from './unit';\n\n/**\n * Defines the configuration options for nullable codecs.\n *\n * This configuration controls how nullable values are encoded and decoded.\n *\n * By default, nullable values are prefixed with a `u8` (0 = `null`, 1 = present).\n * The `noneValue` and `prefix` options allow customizing this behavior.\n *\n * @typeParam TPrefix - A number codec, encoder, or decoder used as the presence prefix.\n *\n * @see {@link getNullableEncoder}\n * @see {@link getNullableDecoder}\n * @see {@link getNullableCodec}\n */\nexport type NullableCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Specifies how `null` values are represented in the encoded data.\n     *\n     * - By default, `null` values are omitted from encoding.\n     * - `'zeroes'`: The bytes allocated for the value are filled with zeroes. This requires a fixed-size codec.\n     * - Custom byte array: `null` values are replaced with a predefined byte sequence. This results in a variable-size codec.\n     *\n     * @defaultValue No explicit `noneValue` is used; `null` values are omitted.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The presence prefix used to distinguish between `null` and present values.\n     *\n     * - By default, a `u8` prefix is used (`0 = null`, `1 = present`).\n     * - Custom number codec: Allows defining a different number size for the prefix.\n     * - `null`: No prefix is used; `noneValue` (if provided) determines `null`.\n     *   If no `noneValue` is set, `null` is identified by the absence of bytes.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Returns an encoder for optional values, allowing `null` values to be encoded.\n *\n * This encoder serializes an optional value using a configurable approach:\n * - By default, a `u8` prefix is used (0 = `null`, 1 = present). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, `null` values are encoded as zeroes.\n * - If `noneValue` is a byte array, `null` values are replaced with the provided constant.\n *\n * For more details, see {@link getNullableCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param item - The encoder for the value that may be present.\n * @param config - Configuration options for encoding optional values.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding nullable values.\n *\n * @example\n * Encoding an optional number.\n * ```ts\n * const encoder = getNullableEncoder(getU32Encoder());\n *\n * encoder.encode(null); // 0x00\n * encoder.encode(42);   // 0x012a000000\n * ```\n *\n * @see {@link getNullableCodec}\n */\nexport function getNullableEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<TFrom | null, TSize>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: NullableCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: TFrom): [boolean, TFrom] => [true, value]),\n        ],\n        variant => Number(variant !== null),\n    );\n}\n\n/**\n * Returns a decoder for optional values, allowing `null` values to be recognized.\n *\n * This decoder deserializes an optional value using a configurable approach:\n * - By default, a `u8` prefix is used (0 = `null`, 1 = present). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, `null` values are identified by zeroes.\n * - If `noneValue` is a byte array, `null` values match the provided constant.\n *\n * For more details, see {@link getNullableCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The decoder for the value that may be present.\n * @param config - Configuration options for decoding optional values.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding nullable values.\n *\n * @example\n * Decoding an optional number.\n * ```ts\n * const decoder = getNullableDecoder(getU32Decoder());\n *\n * decoder.decode(new Uint8Array([0x00])); // null\n * decoder.decode(new Uint8Array([0x01, 0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @see {@link getNullableCodec}\n */\nexport function getNullableDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<TTo | null, TSize>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: NullableCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> = {},\n): Decoder<TTo | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => null),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]): TTo => value),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding optional values, allowing `null` values to be handled.\n *\n * This codec serializes and deserializes optional values using a configurable approach:\n * - By default, a `u8` prefix is used (0 = `null`, 1 = present).\n *    This can be customized using a custom number codec or even disabled by setting\n *    the `prefix` to `null`.\n * - If `noneValue: 'zeroes'` is set, `null` values are encoded/decoded as zeroes.\n * - If `noneValue` is a byte array, `null` values are represented by the provided constant.\n *\n * For more details on the configuration options, see {@link NullableCodecConfig}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The codec for the value that may be present.\n * @param config - Configuration options for encoding and decoding optional values.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding nullable values.\n *\n * @example\n * Encoding and decoding an optional number using a `u8` prefix (default).\n * ```ts\n * const codec = getNullableCodec(getU32Codec());\n *\n * codec.encode(null); // 0x00\n * codec.encode(42);   // 0x012a000000\n *\n * codec.decode(new Uint8Array([0x00])); // null\n * codec.decode(new Uint8Array([0x01, 0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @example\n * Encoding and decoding an optional number using a fixed-size codec, by filling `null` values with zeroes.\n * ```ts\n * const codec = getNullableCodec(getU32Codec(), { noneValue: 'zeroes' });\n *\n * codec.encode(null); // 0x0000000000\n * codec.encode(42);   // 0x012a000000\n *\n * codec.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00])); // null\n * codec.decode(new Uint8Array([0x01, 0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @example\n * Encoding and decoding `null` values with zeroes and no prefix.\n * ```ts\n * const codec = getNullableCodec(getU32Codec(), {\n *   noneValue: 'zeroes',\n *   prefix: null,\n * });\n *\n * codec.encode(null); // 0x00000000\n * codec.encode(42);   // 0x2a000000\n *\n * codec.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00])); // null\n * codec.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @example\n * Encoding and decoding `null` values with a custom byte sequence and no prefix.\n * ```ts\n * const codec = getNullableCodec(getU16Codec(), {\n *   noneValue: new Uint8Array([0xff, 0xff]),\n *   prefix: null,\n * });\n *\n * codec.encode(null); // 0xffff\n * codec.encode(42); // 0x2a00\n *\n * codec.decode(new Uint8Array([0xff, 0xff])); // null\n * codec.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @example\n * Identifying `null` values by the absence of bytes.\n * ```ts\n * const codec = getNullableCodec(getU16Codec(), { prefix: null });\n *\n * codec.encode(null); // Empty bytes\n * codec.encode(42); // 0x2a00\n *\n * codec.decode(new Uint8Array([])); // null\n * codec.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @remarks\n * Separate {@link getNullableEncoder} and {@link getNullableDecoder} functions are available.\n *\n * ```ts\n * const bytes = getNullableEncoder(getU32Encoder()).encode(42);\n * const value = getNullableDecoder(getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getNullableEncoder}\n * @see {@link getNullableDecoder}\n */\nexport function getNullableCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<TFrom | null, TTo | null, TSize>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> = {},\n): Codec<TFrom | null, TTo | null> {\n    type ConfigCast = NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getNullableEncoder<TFrom>(item, config as ConfigCast),\n        getNullableDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\n\n/**\n * Defines the configuration options for set codecs.\n *\n * This configuration allows specifying how the size of the set is encoded.\n * The `size` option can be:\n *\n * - A {@link NumberCodec}, {@link NumberEncoder}, or {@link NumberDecoder} to store the size as a prefix.\n * - A fixed number of items, enforcing a strict length.\n * - The string `'remainder'` to infer the set size from the remaining bytes (only for fixed-size items).\n *\n * @typeParam TPrefix - The type used for encoding the size of the set.\n */\nexport type SetCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size encoding strategy for the set.\n     * @defaultValue Uses a `u32` prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Returns an encoder for sets of items.\n *\n * This encoder serializes `Set<T>` values by encoding each item using the provided item encoder.\n * The number of items is stored as a prefix using a `u32` codec by default.\n *\n * For more details, see {@link getSetCodec}.\n *\n * @typeParam TFrom - The type of the items in the set before encoding.\n *\n * @param item - The encoder to use for each set item.\n * @param config - Optional configuration specifying the size strategy.\n * @returns An `Encoder<Set<TFrom>>` for encoding sets of items.\n *\n * @example\n * Encoding a set of `u8` numbers.\n * ```ts\n * const encoder = getSetEncoder(getU8Encoder());\n * const bytes = encoder.encode(new Set([1, 2, 3]));\n * // 0x03000000010203\n * //   |       └-- 3 items of 1 byte each.\n * //   └-- 4-byte prefix indicating 3 items.\n * ```\n *\n * @see {@link getSetCodec}\n */\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Set<TFrom>, 0>;\nexport function getSetEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: SetCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> = {},\n): Encoder<Set<TFrom>> {\n    return transformEncoder(getArrayEncoder(item, config as object), (set: Set<TFrom>): TFrom[] => [...set]);\n}\n\n/**\n * Returns a decoder for sets of items.\n *\n * This decoder deserializes a `Set<T>` from a byte array by decoding each item using the provided item decoder.\n * The number of items is determined by a `u32` size prefix by default.\n *\n * For more details, see {@link getSetCodec}.\n *\n * @typeParam TTo - The type of the items in the set after decoding.\n *\n * @param item - The decoder to use for each set item.\n * @param config - Optional configuration specifying the size strategy.\n * @returns A `Decoder<Set<TTo>>` for decoding sets of items.\n *\n * @example\n * Decoding a set of `u8` numbers.\n * ```ts\n * const decoder = getSetDecoder(getU8Decoder());\n * const value = decoder.decode(new Uint8Array([0x03, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03]));\n * // new Set([1, 2, 3])\n * ```\n *\n * @see {@link getSetCodec}\n */\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Set<TTo>, 0>;\nexport function getSetDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: SetCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(item: Decoder<TTo>, config: SetCodecConfig<NumberDecoder> = {}): Decoder<Set<TTo>> {\n    return transformDecoder(getArrayDecoder(item, config as object), (entries: TTo[]): Set<TTo> => new Set(entries));\n}\n\n/**\n * Returns a codec for encoding and decoding sets of items.\n *\n * This codec serializes `Set<T>` values by encoding each item using the provided item codec.\n * The number of items is stored as a prefix using a `u32` codec by default.\n *\n * @typeParam TFrom - The type of the items in the set before encoding.\n * @typeParam TTo - The type of the items in the set after decoding.\n *\n * @param item - The codec to use for each set item.\n * @param config - Optional configuration specifying the size strategy.\n * @returns A `Codec<Set<TFrom>, Set<TTo>>` for encoding and decoding sets.\n *\n * @example\n * Encoding and decoding a set of `u8` numbers.\n * ```ts\n * const codec = getSetCodec(getU8Codec());\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x03000000010203\n * //   |       └-- 3 items of 1 byte each.\n * //   └-- 4-byte prefix indicating 3 items.\n *\n * const value = codec.decode(bytes);\n * // new Set([1, 2, 3])\n * ```\n *\n * @example\n * Using a `u16` prefix for size.\n * ```ts\n * const codec = getSetCodec(getU8Codec(), { size: getU16Codec() });\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x0300010203\n * //   |   └-- 3 items of 1 byte each.\n * //   └-- 2-byte prefix indicating 3 items.\n * ```\n *\n * @example\n * Using a fixed-size set.\n * ```ts\n * const codec = getSetCodec(getU8Codec(), { size: 3 });\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x010203\n * //   └-- Exactly 3 items of 1 byte each.\n * ```\n *\n * @example\n * Using remainder to infer set size.\n * ```ts\n * const codec = getSetCodec(getU8Codec(), { size: 'remainder' });\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x010203\n * //   └-- 3 items of 1 byte each. The size is inferred from the remaining bytes.\n * ```\n *\n * @remarks\n * Separate {@link getSetEncoder} and {@link getSetDecoder} functions are available.\n *\n * ```ts\n * const bytes = getSetEncoder(getU8Encoder()).encode(new Set([1, 2, 3]));\n * const value = getSetDecoder(getU8Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getSetEncoder}\n * @see {@link getSetDecoder}\n */\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>, 0>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: SetCodecConfig<NumberCodec>,\n): VariableSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> = {},\n): Codec<Set<TFrom>, Set<TTo>> {\n    return combineCodec(getSetEncoder(item, config as object), getSetDecoder(item, config as object));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\n/**\n * Represents a collection of named fields used in struct codecs.\n *\n * Each field is defined as a tuple containing:\n * - A string key representing the field name.\n * - A codec used to encode and decode the field's value.\n *\n * @typeParam T - The codec type used for each field.\n */\ntype Fields<T> = readonly (readonly [string, T])[];\n\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\n/**\n * Infers the TypeScript type for an object that can be encoded using a struct codec.\n *\n * This type maps the provided field encoders to their corresponding values.\n *\n * @typeParam TFields - The fields of the struct, each paired with an encoder.\n */\ntype GetEncoderTypeFromFields<TFields extends Fields<Encoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\n/**\n * Infers the TypeScript type for an object that can be decoded using a struct codec.\n *\n * This type maps the provided field decoders to their corresponding values.\n *\n * @typeParam TFields - The fields of the struct, each paired with a decoder.\n */\ntype GetDecoderTypeFromFields<TFields extends Fields<Decoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Returns an encoder for custom objects.\n *\n * This encoder serializes an object by encoding its fields sequentially,\n * using the provided field encoders.\n *\n * For more details, see {@link getStructCodec}.\n *\n * @typeParam TFields - The fields of the struct, each paired with an encoder.\n *\n * @param fields - The name and encoder of each field.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding custom objects.\n *\n * @example\n * Encoding a custom struct.\n * ```ts\n * const encoder = getStructEncoder([\n *   ['name', fixCodecSize(getUtf8Encoder(), 5)],\n *   ['age', getU8Encoder()]\n * ]);\n *\n * const bytes = encoder.encode({ name: 'Alice', age: 42 });\n * // 0x416c6963652a\n * //   |         └── Age (42)\n * //   └── Name (\"Alice\")\n * ```\n *\n * @see {@link getStructCodec}\n */\nexport function getStructEncoder<const TFields extends Fields<FixedSizeEncoder<any>>>(\n    fields: TFields,\n): FixedSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): VariableSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): Encoder<GetEncoderTypeFromFields<TFields>> {\n    type TFrom = GetEncoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      fields\n                          .map(([key, codec]) => getEncodedSize(value[key as keyof TFrom], codec))\n                          .reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (struct: TFrom, bytes, offset) => {\n            fields.forEach(([key, codec]) => {\n                offset = codec.write(struct[key as keyof TFrom], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder for custom objects.\n *\n * This decoder deserializes an object by decoding its fields sequentially,\n * using the provided field decoders.\n *\n * For more details, see {@link getStructCodec}.\n *\n * @typeParam TFields - The fields of the struct, each paired with a decoder.\n *\n * @param fields - The name and decoder of each field.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding custom objects.\n *\n * @example\n * Decoding a custom struct.\n * ```ts\n * const decoder = getStructDecoder([\n *   ['name', fixCodecSize(getUtf8Decoder(), 5)],\n *   ['age', getU8Decoder()]\n * ]);\n *\n * const struct = decoder.decode(new Uint8Array([\n *   0x41,0x6c,0x69,0x63,0x65,0x2a\n * ]));\n * // { name: 'Alice', age: 42 }\n * ```\n *\n * @see {@link getStructCodec}\n */\nexport function getStructDecoder<const TFields extends Fields<FixedSizeDecoder<any>>>(\n    fields: TFields,\n): FixedSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): VariableSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): Decoder<GetDecoderTypeFromFields<TFields>> {\n    type TTo = GetDecoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const struct = {} as TTo;\n            fields.forEach(([key, codec]) => {\n                const [value, newOffset] = codec.read(bytes, offset);\n                offset = newOffset;\n                struct[key as keyof TTo] = value;\n            });\n            return [struct, offset];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding custom objects.\n *\n * This codec serializes objects by encoding and decoding each field sequentially.\n *\n * @typeParam TFields - The fields of the struct, each paired with a codec.\n *\n * @param fields - The name and codec of each field.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding custom objects.\n *\n * @example\n * Encoding and decoding a custom struct.\n * ```ts\n * const codec = getStructCodec([\n *   ['name', fixCodecSize(getUtf8Codec(), 5)],\n *   ['age', getU8Codec()]\n * ]);\n *\n * const bytes = codec.encode({ name: 'Alice', age: 42 });\n * // 0x416c6963652a\n * //   |         └── Age (42)\n * //   └── Name (\"Alice\")\n *\n * const struct = codec.decode(bytes);\n * // { name: 'Alice', age: 42 }\n * ```\n *\n * @remarks\n * Separate {@link getStructEncoder} and {@link getStructDecoder} functions are available.\n *\n * ```ts\n * const bytes = getStructEncoder([\n *   ['name', fixCodecSize(getUtf8Encoder(), 5)],\n *   ['age', getU8Encoder()]\n * ]).encode({ name: 'Alice', age: 42 });\n *\n * const struct = getStructDecoder([\n *   ['name', fixCodecSize(getUtf8Decoder(), 5)],\n *   ['age', getU8Decoder()]\n * ]).decode(bytes);\n * ```\n *\n * @see {@link getStructEncoder}\n * @see {@link getStructDecoder}\n */\nexport function getStructCodec<const TFields extends Fields<FixedSizeCodec<any>>>(\n    fields: TFields,\n): FixedSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): VariableSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): Codec<GetEncoderTypeFromFields<TFields>, GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>> {\n    return combineCodec(\n        getStructEncoder(fields),\n        getStructDecoder(fields) as Decoder<GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>>,\n    );\n}\n"],"names":["newOffset","createEncoder","createDecoder","combineCodec","SolanaError","getEncodedSize","isFixedSize","getU8Encoder","transformEncoder","getU8Decoder","transformDecoder","containsBytes"],"mappings":"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"}},
    {"offset": {"line": 4467, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/rpc-types/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-types/src/blockhash.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-types/src/cluster-url.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-types/src/commitment.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-types/src/lamports.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-types/src/stringified-bigint.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-types/src/stringified-number.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-types/src/unix-timestamp.ts"],"sourcesContent":["import { Address, assertIsAddress, getAddressDecoder, getAddressEncoder, isAddress } from '@solana/addresses';\nimport { combineCodec, createEncoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\nexport type Blockhash = Brand<EncodedString<string, 'base58'>, 'Blockhash'>;\n\n/**\n * A type guard that returns `true` if the input string conforms to the {@link Blockhash} type, and\n * refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isBlockhash } from '@solana/rpc-types';\n *\n * if (isBlockhash(blockhash)) {\n *     // At this point, `blockhash` has been refined to a\n *     // `Blockhash` that can be used with the RPC.\n *     const { value: isValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsFresh(isValid);\n * } else {\n *     setError(`${blockhash} is not a blockhash`);\n * }\n * ```\n */\nexport function isBlockhash(putativeBlockhash: string): putativeBlockhash is Blockhash {\n    return isAddress(putativeBlockhash);\n}\n\n/**\n * From time to time you might acquire a string, that you expect to validate as a blockhash, from an\n * untrusted network API or user input. Use this function to assert that such an arbitrary string is\n * a base58-encoded blockhash.\n *\n * @example\n * ```ts\n * import { assertIsBlockhash } from '@solana/rpc-types';\n *\n * // Imagine a function that determines whether a blockhash is fresh when a user submits a form.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const blockhash: string = blockhashInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `blockhash` to `Blockhash`.\n *         assertIsBlockhash(blockhash);\n *         // At this point, `blockhash` is a `Blockhash` that can be used with the RPC.\n *         const { value: isValid } = await rpc.isBlockhashValid(blockhash).send();\n *     } catch (e) {\n *         // `blockhash` turned out not to be a base58-encoded blockhash\n *     }\n * }\n * ```\n */\nexport function assertIsBlockhash(putativeBlockhash: string): asserts putativeBlockhash is Blockhash {\n    try {\n        assertIsAddress(putativeBlockhash);\n    } catch (error) {\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE)) {\n            throw new SolanaError(SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE, error.context);\n        }\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH)) {\n            throw new SolanaError(SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH, error.context);\n        }\n        throw error;\n    }\n}\n\n/**\n * Combines _asserting_ that a string is a blockhash with _coercing_ it to the {@link Blockhash}\n * type. It's most useful with untrusted input.\n *\n * @example\n * ```ts\n * import { blockhash } from '@solana/rpc-types';\n *\n * const { value: isValid } = await rpc.isBlockhashValid(blockhash(blockhashFromUserInput)).send();\n * ```\n *\n * > [!TIP]\n * > When starting from a known-good blockhash as a string, it's more efficient to typecast it\n * rather than to use the {@link blockhash} helper, because the helper unconditionally performs\n * validation on its input.\n * >\n * > ```ts\n * > import { Blockhash } from '@solana/rpc-types';\n * >\n * > const blockhash = 'ABmPH5KDXX99u6woqFS5vfBGSNyKG42SzpvBMWWqAy48' as Blockhash;\n * > ```\n */\nexport function blockhash(putativeBlockhash: string): Blockhash {\n    assertIsBlockhash(putativeBlockhash);\n    return putativeBlockhash;\n}\n\n/**\n * Returns an encoder that you can use to encode a base58-encoded blockhash to a byte array.\n *\n * @example\n * ```ts\n * import { getBlockhashEncoder } from '@solana/rpc-types';\n *\n * const blockhash = 'ABmPH5KDXX99u6woqFS5vfBGSNyKG42SzpvBMWWqAy48' as Blockhash;\n * const blockhashEncoder = getBlockhashEncoder();\n * const blockhashBytes = blockhashEncoder.encode(blockhash);\n * // Uint8Array(32) [\n * //   136, 123,  44, 249,  43,  19,  60,  14,\n * //   144,  16, 168, 241, 121, 111,  70, 232,\n * //   186,  26, 140, 202, 213,  64, 231,  82,\n * //   179,  66, 103, 237,  52, 117, 217,  93\n * // ]\n * ```\n */\nexport function getBlockhashEncoder(): FixedSizeEncoder<Blockhash, 32> {\n    const addressEncoder = getAddressEncoder();\n    return createEncoder({\n        fixedSize: 32,\n        write: (value: string, bytes, offset) => {\n            assertIsBlockhash(value);\n            return addressEncoder.write(value as string as Address, bytes, offset);\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to convert an array of 32 bytes representing a blockhash to\n * the base58-encoded representation of that blockhash.\n *\n * @example\n * ```ts\n * import { getBlockhashDecoder } from '@solana/rpc-types';\n *\n * const blockhashBytes = new Uint8Array([\n *     136, 123,  44, 249,  43,  19,  60,  14,\n *     144,  16, 168, 241, 121, 111,  70, 232,\n *     186,  26, 140, 202, 213,  64, 231,  82,\n *     179,  66, 103, 237,  52, 117, 217,  93\n * ]);\n * const blockhashDecoder = getBlockhashDecoder();\n * const blockhash = blockhashDecoder.decode(blockhashBytes); // ABmPH5KDXX99u6woqFS5vfBGSNyKG42SzpvBMWWqAy48\n * ```\n */\nexport function getBlockhashDecoder(): FixedSizeDecoder<Blockhash, 32> {\n    return getAddressDecoder() as FixedSizeDecoder<string, 32> as FixedSizeDecoder<Blockhash, 32>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a base-58 encoded blockhash.\n *\n * @see {@link getBlockhashDecoder}\n * @see {@link getBlockhashEncoder}\n */\nexport function getBlockhashCodec(): FixedSizeCodec<Blockhash, Blockhash, 32> {\n    return combineCodec(getBlockhashEncoder(), getBlockhashDecoder());\n}\n\nexport function getBlockhashComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n","export type MainnetUrl = string & { '~cluster': 'mainnet' };\nexport type DevnetUrl = string & { '~cluster': 'devnet' };\nexport type TestnetUrl = string & { '~cluster': 'testnet' };\nexport type ClusterUrl = DevnetUrl | MainnetUrl | TestnetUrl | string;\n\n/** Given a URL casts it to a type that is only accepted where mainnet URLs are expected. */\nexport function mainnet(putativeString: string): MainnetUrl {\n    return putativeString as MainnetUrl;\n}\n/** Given a URL casts it to a type that is only accepted where devnet URLs are expected. */\nexport function devnet(putativeString: string): DevnetUrl {\n    return putativeString as DevnetUrl;\n}\n/** Given a URL casts it to a type that is only accepted where testnet URLs are expected. */\nexport function testnet(putativeString: string): TestnetUrl {\n    return putativeString as TestnetUrl;\n}\n","import { SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, SolanaError } from '@solana/errors';\n\n/**\n * A union of all possible commitment statuses -- each a measure of the network confirmation and\n * stake levels on a particular block.\n *\n * Read more about the statuses themselves, [here](https://docs.solana.com/cluster/commitments).\n */\nexport type Commitment = 'confirmed' | 'finalized' | 'processed';\n\nfunction getCommitmentScore(commitment: Commitment): number {\n    switch (commitment) {\n        case 'finalized':\n            return 2;\n        case 'confirmed':\n            return 1;\n        case 'processed':\n            return 0;\n        default:\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                unexpectedValue: commitment satisfies never,\n            });\n    }\n}\n\nexport function commitmentComparator(a: Commitment, b: Commitment): -1 | 0 | 1 {\n    if (a === b) {\n        return 0;\n    }\n    return getCommitmentScore(a) < getCommitmentScore(b) ? -1 : 1;\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n} from '@solana/codecs-core';\nimport { getU64Decoder, getU64Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * Represents an integer value denominated in Lamports (ie. $1 \\times 10^{-9}$ ◎).\n *\n * It is represented as a `bigint` in client code and an `u64` in server code.\n */\nexport type Lamports = Brand<bigint, 'Lamports'>;\n\n// Largest possible value to be represented by a u64\nconst maxU64Value = 18446744073709551615n; // 2n ** 64n - 1n\n\nlet memoizedU64Encoder: FixedSizeEncoder<bigint | number, 8> | undefined;\nlet memoizedU64Decoder: FixedSizeDecoder<bigint, 8> | undefined;\n\nfunction getMemoizedU64Encoder(): FixedSizeEncoder<bigint | number, 8> {\n    if (!memoizedU64Encoder) memoizedU64Encoder = getU64Encoder();\n    return memoizedU64Encoder;\n}\n\nfunction getMemoizedU64Decoder(): FixedSizeDecoder<bigint, 8> {\n    if (!memoizedU64Decoder) memoizedU64Decoder = getU64Decoder();\n    return memoizedU64Decoder;\n}\n\n/**\n * This is a type guard that accepts a `bigint` as input. It will both return `true` if the integer\n * conforms to the {@link Lamports} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isLamports } from '@solana/rpc-types';\n *\n * if (isLamports(lamports)) {\n *     // At this point, `lamports` has been refined to a\n *     // `Lamports` that can be used anywhere Lamports are expected.\n *     await transfer(fromAddress, toAddress, lamports);\n * } else {\n *     setError(`${lamports} is not a quantity of Lamports`);\n * }\n * ```\n */\nexport function isLamports(putativeLamports: bigint): putativeLamports is Lamports {\n    return putativeLamports >= 0 && putativeLamports <= maxU64Value;\n}\n\n/**\n * Lamport values returned from the RPC API conform to the type {@link Lamports}. You can use a\n * value of that type wherever a quantity of Lamports is expected.\n *\n * @example\n * From time to time you might acquire a number that you expect to be a quantity of Lamports, from\n * an untrusted network API or user input. To assert that such an arbitrary number is usable as a\n * quantity of Lamports, use this function.\n *\n * ```ts\n * import { assertIsLamports } from '@solana/rpc-types';\n *\n * // Imagine a function that creates a transfer instruction when a user submits a form.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `number` type.\n *     const lamports: number = parseInt(quantityInput.value, 10);\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `lamports` to `Lamports`.\n *         assertIsLamports(lamports);\n *         // At this point, `lamports` is a `Lamports` that can be used anywhere Lamports are expected.\n *         await transfer(fromAddress, toAddress, lamports);\n *     } catch (e) {\n *         // `lamports` turned out not to validate as a quantity of Lamports.\n *     }\n * }\n * ```\n */\nexport function assertIsLamports(putativeLamports: bigint): asserts putativeLamports is Lamports {\n    if (putativeLamports < 0 || putativeLamports > maxU64Value) {\n        throw new SolanaError(SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE);\n    }\n}\n\n/**\n * This helper combines _asserting_ that a number is a possible number of {@link Lamports} with\n * _coercing_ it to the {@link Lamports} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { lamports } from '@solana/rpc-types';\n *\n * await transfer(address(fromAddress), address(toAddress), lamports(100000n));\n * ```\n */\nexport function lamports(putativeLamports: bigint): Lamports {\n    assertIsLamports(putativeLamports);\n    return putativeLamports;\n}\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\n/**\n * Returns an encoder that you can use to encode a 64-bit {@link Lamports} value to 8 bytes in\n * little endian order.\n */\nexport function getDefaultLamportsEncoder(): FixedSizeEncoder<Lamports, 8> {\n    return getLamportsEncoder(getMemoizedU64Encoder());\n}\n\n/**\n * Returns an encoder that you can use to encode a {@link Lamports} value to a byte array.\n *\n * You must supply a number decoder that will determine how encode the numeric value.\n *\n * @example\n * ```ts\n * import { getLamportsEncoder } from '@solana/rpc-types';\n * import { getU16Encoder } from '@solana/codecs-numbers';\n *\n * const lamports = lamports(256n);\n * const lamportsEncoder = getLamportsEncoder(getU16Encoder());\n * const lamportsBytes = lamportsEncoder.encode(lamports);\n * // Uint8Array(2) [ 0, 1 ]\n * ```\n */\nexport function getLamportsEncoder<TEncoder extends NumberEncoder>(\n    innerEncoder: TEncoder,\n): Encoder<Lamports> & ExtractAdditionalProps<TEncoder, NumberEncoder> {\n    return innerEncoder;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a 64-bit little endian\n * number to a {@link Lamports} value.\n */\nexport function getDefaultLamportsDecoder(): FixedSizeDecoder<Lamports, 8> {\n    return getLamportsDecoder(getMemoizedU64Decoder());\n}\n\n/**\n * Returns a decoder that you can use to convert an array of bytes representing a number to a\n * {@link Lamports} value.\n *\n * You must supply a number decoder that will determine how many bits to use to decode the numeric\n * value.\n *\n * @example\n * ```ts\n * import { getLamportsDecoder } from '@solana/rpc-types';\n * import { getU16Decoder } from '@solana/codecs-numbers';\n *\n * const lamportsBytes = new Uint8Array([ 0, 1 ]);\n * const lamportsDecoder = getLamportsDecoder(getU16Decoder());\n * const lamports = lamportsDecoder.decode(lamportsBytes); // lamports(256n)\n * ```\n */\nexport function getLamportsDecoder<TDecoder extends NumberDecoder>(\n    innerDecoder: TDecoder,\n): Decoder<Lamports> & ExtractAdditionalProps<TDecoder, NumberDecoder> {\n    return transformDecoder<bigint | number, Lamports>(innerDecoder, value =>\n        lamports(typeof value === 'bigint' ? value : BigInt(value)),\n    ) as Decoder<Lamports> & ExtractAdditionalProps<TDecoder, NumberDecoder>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a 64-bit {@link Lamports} value.\n *\n * @see {@link getDefaultLamportsDecoder}\n * @see {@link getDefaultLamportsEncoder}\n */\nexport function getDefaultLamportsCodec(): FixedSizeCodec<Lamports, Lamports, 8> {\n    return combineCodec(getDefaultLamportsEncoder(), getDefaultLamportsDecoder());\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link Lamports} value.\n *\n * @see {@link getLamportsDecoder}\n * @see {@link getLamportsEncoder}\n */\nexport function getLamportsCodec<TCodec extends NumberCodec>(\n    innerCodec: TCodec,\n): Codec<Lamports, Lamports> & ExtractAdditionalProps<TCodec, NumberCodec> {\n    return combineCodec(getLamportsEncoder(innerCodec), getLamportsDecoder(innerCodec)) as Codec<Lamports, Lamports> &\n        ExtractAdditionalProps<TCodec, NumberCodec>;\n}\n","import { SOLANA_ERROR__MALFORMED_BIGINT_STRING, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * This type represents a `bigint` which has been encoded as a string for transit over a transport\n * that does not support `bigint` values natively. The JSON-RPC is such a transport.\n */\nexport type StringifiedBigInt = Brand<string, 'StringifiedBigInt'>;\n\n/**\n * A type guard that returns `true` if the input string parses as a `BigInt`, and refines its type\n * for use in your program.\n *\n * @example\n * ```ts\n * import { isStringifiedBigInt } from '@solana/rpc-types';\n *\n * if (isStringifiedBigInt(bigintString)) {\n *     // At this point, `bigintString` has been refined to a `StringifiedBigInt`\n *     bigintString satisfies StringifiedBigInt; // OK\n * } else {\n *     setError(`${bigintString} does not represent a BigInt`);\n * }\n * ```\n */\nexport function isStringifiedBigInt(putativeBigInt: string): putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * From time to time you might acquire a string, that you expect to parse as a `BigInt`, from an\n * untrusted network API or user input. Use this function to assert that such an arbitrary string\n * will in fact parse as a `BigInt`.\n *\n * @example\n * ```ts\n * import { assertIsStringifiedBigInt } from '@solana/rpc-types';\n *\n * // Imagine having received a value that you presume represents the supply of some token.\n * // At this point we know only that it conforms to the `string` type.\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `supplyString` to `StringifiedBigInt`.\n *     assertIsStringifiedBigInt(supplyString);\n *     // At this point, `supplyString` is a `StringifiedBigInt`.\n *     supplyString satisfies StringifiedBigInt;\n * } catch (e) {\n *     // `supplyString` turned out not to parse as a `BigInt`\n * }\n * ```\n */\nexport function assertIsStringifiedBigInt(putativeBigInt: string): asserts putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n    } catch {\n        throw new SolanaError(SOLANA_ERROR__MALFORMED_BIGINT_STRING, {\n            value: putativeBigInt,\n        });\n    }\n}\n\n/**\n * This helper combines _asserting_ that a string will parse as a `BigInt` with _coercing_ it to the\n * {@link StringifiedBigInt} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { stringifiedBigInt } from '@solana/rpc-types';\n *\n * const supplyString = stringifiedBigInt('1000000000');\n * ```\n */\nexport function stringifiedBigInt(putativeBigInt: string): StringifiedBigInt {\n    assertIsStringifiedBigInt(putativeBigInt);\n    return putativeBigInt;\n}\n","import { SOLANA_ERROR__MALFORMED_NUMBER_STRING, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * This type represents a number which has been encoded as a string for transit over a transport\n * where loss of precision when using the native number type is a concern. The JSON-RPC is such a\n * transport.\n */\nexport type StringifiedNumber = Brand<string, 'StringifiedNumber'>;\n\n/**\n * A type guard that returns `true` if the input string parses as a `Number`, and refines its type\n * for use in your program.\n *\n * @example\n * ```ts\n * import { isStringifiedNumber } from '@solana/rpc-types';\n *\n * if (isStringifiedNumber(numericString)) {\n *     // At this point, `numericString` has been refined to a `StringifiedNumber`\n *     numericString satisfies StringifiedNumber; // OK\n * } else {\n *     setError(`${numericString} does not represent a number`);\n * }\n * ```\n */\nexport function isStringifiedNumber(putativeNumber: string): putativeNumber is StringifiedNumber {\n    return !Number.isNaN(Number(putativeNumber));\n}\n\n/**\n * From time to time you might acquire a string, that you expect to parse as a `Number`, from an\n * untrusted network API or user input. Use this function to assert that such an arbitrary string\n * will in fact parse as a `Number`.\n *\n * @example\n * ```ts\n * import { assertIsStringifiedNumber } from '@solana/rpc-types';\n *\n * // Imagine having received a value that you presume represents some decimal number.\n * // At this point we know only that it conforms to the `string` type.\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `decimalNumberString` to `StringifiedNumber`.\n *     assertIsStringifiedNumber(decimalNumberString);\n *     // At this point, `decimalNumberString` is a `StringifiedNumber`.\n *     decimalNumberString satisfies StringifiedNumber;\n * } catch (e) {\n *     // `decimalNumberString` turned out not to parse as a number.\n * }\n * ```\n */\nexport function assertIsStringifiedNumber(putativeNumber: string): asserts putativeNumber is StringifiedNumber {\n    if (Number.isNaN(Number(putativeNumber))) {\n        throw new SolanaError(SOLANA_ERROR__MALFORMED_NUMBER_STRING, {\n            value: putativeNumber,\n        });\n    }\n}\n\n/**\n * This helper combines _asserting_ that a string will parse as a `Number` with _coercing_ it to the\n * {@link StringifiedNumber} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { stringifiedNumber } from '@solana/rpc-types';\n *\n * const decimalNumberString = stringifiedNumber('-42.1');\n * ```\n */\nexport function stringifiedNumber(putativeNumber: string): StringifiedNumber {\n    assertIsStringifiedNumber(putativeNumber);\n    return putativeNumber;\n}\n","import { SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * This type represents a Unix timestamp in _seconds_.\n *\n * It is represented as a `bigint` in client code and an `i64` in server code.\n */\nexport type UnixTimestamp = Brand<bigint, 'UnixTimestamp'>;\n\n// Largest possible value to be represented by an i64\nconst maxI64Value = 9223372036854775807n; // 2n ** 63n - 1n\nconst minI64Value = -9223372036854775808n; // -(2n ** 63n)\n\n/**\n * This is a type guard that accepts a `bigint` as input. It will both return `true` if the integer\n * conforms to the {@link UnixTimestamp} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isUnixTimestamp } from '@solana/rpc-types';\n *\n * if (isUnixTimestamp(timestamp)) {\n *     // At this point, `timestamp` has been refined to a\n *     // `UnixTimestamp` that can be used anywhere timestamps are expected.\n *     timestamp satisfies UnixTimestamp;\n * } else {\n *     setError(`${timestamp} is not a Unix timestamp`);\n * }\n * ```\n */\n\nexport function isUnixTimestamp(putativeTimestamp: bigint): putativeTimestamp is UnixTimestamp {\n    return putativeTimestamp >= minI64Value && putativeTimestamp <= maxI64Value;\n}\n\n/**\n * Timestamp values returned from the RPC API conform to the type {@link UnixTimestamp}. You can use\n * a value of that type wherever a timestamp is expected.\n *\n * @example\n * From time to time you might acquire a number that you expect to be a timestamp, from an untrusted\n * network API or user input. To assert that such an arbitrary number is usable as a Unix timestamp,\n * use this function.\n *\n * ```ts\n * import { assertIsUnixTimestamp } from '@solana/rpc-types';\n *\n * // Imagine having received a value that you presume represents a timestamp.\n * // At this point we know only that it conforms to the `bigint` type.\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `timestamp` to `UnixTimestamp`.\n *     assertIsUnixTimestamp(timestamp);\n *     // At this point, `timestamp` is a `UnixTimestamp`.\n *     timestamp satisfies UnixTimestamp;\n * } catch (e) {\n *     // `timestamp` turned out not to be a valid Unix timestamp\n * }\n * ```\n */\nexport function assertIsUnixTimestamp(putativeTimestamp: bigint): asserts putativeTimestamp is UnixTimestamp {\n    if (putativeTimestamp < minI64Value || putativeTimestamp > maxI64Value) {\n        throw new SolanaError(SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, {\n            value: putativeTimestamp,\n        });\n    }\n}\n\n/**\n * This helper combines _asserting_ that a `bigint` represents a Unix timestamp with _coercing_ it\n * to the {@link UnixTimestamp} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { unixTimestamp } from '@solana/rpc-types';\n *\n * const timestamp = unixTimestamp(-42n); // Wednesday, December 31, 1969 3:59:18 PM GMT-08:00\n * ```\n */\nexport function unixTimestamp(putativeTimestamp: bigint): UnixTimestamp {\n    assertIsUnixTimestamp(putativeTimestamp);\n    return putativeTimestamp;\n}\n"],"names":["SolanaError","combineCodec"],"mappings":"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"}},
    {"offset": {"line": 4711, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/functional/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/functional/src/pipe.ts"],"sourcesContent":["/**\n * A pipeline is a solution that allows you to perform successive transforms of a value using functions. This is useful when building up a transaction message.\n *\n * Until the [pipeline operator](https://github.com/tc39/proposal-pipeline-operator) becomes part of JavaScript you can use this utility to create pipelines.\n *\n * Following common implementations of pipe functions that use TypeScript, this function supports a maximum arity of 10 for type safety.\n *\n * Note you can use nested pipes to extend this limitation, like so:\n * ```ts\n * const myValue = pipe(\n *      pipe(\n *          1,\n *          (x) => x + 1,\n *          (x) => x * 2,\n *          (x) => x - 1,\n *      ),\n *      (y) => y / 3,\n *      (y) => y + 1,\n * );\n * ```\n *\n * @see https://github.com/ramda/ramda/blob/master/source/pipe.js\n * @see https://github.com/darky/rocket-pipes/blob/master/index.ts\n *\n * @example Basic\n * ```ts\n * const add = (a, b) => a + b;\n * const add10 = x => add(x, 10);\n * const add100 = x => add(x, 100);\n * const sum = pipe(1, add10, add100);\n * sum === 111; // true\n * ```\n *\n * @example Building a Solana transaction message\n * ```ts\n * const transferTransactionMessage = pipe(\n *     // The result of the first expression...\n *     createTransactionMessage({ version: 0 }),\n *     // ...gets passed as the sole argument to the next function in the pipeline.\n *     tx => setTransactionMessageFeePayer(myAddress, tx),\n *     // The return value of that function gets passed to the next...\n *     tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n *     // ...and so on.\n *     tx => appendTransactionMessageInstruction(createTransferInstruction(myAddress, toAddress, amountInLamports), tx),\n * );\n * ```\n *\n * @returns The initial value\n */\nexport function pipe<TInitial>(\n    /** The initial value */\n    init: TInitial,\n): TInitial;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n): R1;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n): R2;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n): R3;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n): R4;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n): R5;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n): R6;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n): R7;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n    /** The function with which to transform the return value of the prior function */\n    r7_r8: (r7: R7) => R8,\n): R8;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8, R9>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n    /** The function with which to transform the return value of the prior function */\n    r7_r8: (r7: R7) => R8,\n    /** The function with which to transform the return value of the prior function */\n    r8_r9: (r8: R8) => R9,\n): R9;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n    /** The function with which to transform the return value of the prior function */\n    r7_r8: (r7: R7) => R8,\n    /** The function with which to transform the return value of the prior function */\n    r8_r9: (r8: R8) => R9,\n    /** The function with which to transform the return value of the prior function */\n    r9_r10: (r9: R9) => R10,\n): R10;\nexport function pipe<TInitial>(init: TInitial, ...fns: CallableFunction[]) {\n    return fns.reduce((acc, fn) => fn(acc), init);\n}\n"],"names":[],"mappings":";;;;;AAyOO,SAAS,IAAA,CAAe,IAAA,EAAA,GAAmB,GAAA,EAAyB;IACvE,OAAO,GAAA,CAAI,MAAA,CAAO,CAAC,GAAA,EAAK,KAAO,EAAA,CAAG,GAAG,GAAG,IAAI,CAAA;AAChD"}},
    {"offset": {"line": 4726, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/transaction-messages/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transaction-messages/src/blockhash.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-strings/src/assertions.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-strings/src/baseX.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/codecs-strings/src/base58.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transaction-messages/src/codecs/address-table-lookup.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transaction-messages/src/codecs/header.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transaction-messages/src/codecs/instruction.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transaction-messages/src/transaction-message.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transaction-messages/src/codecs/transaction-version.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transaction-messages/src/codecs/message.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transaction-messages/src/compile/accounts.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transaction-messages/src/compile/address-table-lookups.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transaction-messages/src/compile/header.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transaction-messages/src/compile/instructions.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transaction-messages/src/compile/lifetime-token.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transaction-messages/src/compile/static-accounts.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transaction-messages/src/compile/message.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transaction-messages/src/compress-transaction-message.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transaction-messages/src/create-transaction-message.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transaction-messages/src/durable-nonce-instruction.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transaction-messages/src/durable-nonce.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transaction-messages/src/fee-payer.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transaction-messages/src/instructions.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transaction-messages/src/decompile-message.ts"],"sourcesContent":["import { SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME, SolanaError } from '@solana/errors';\nimport { type Blockhash, isBlockhash } from '@solana/rpc-types';\n\nimport { ExcludeTransactionMessageLifetime, TransactionMessageWithLifetime } from './lifetime';\nimport { BaseTransactionMessage } from './transaction-message';\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network. The transaction message will continue to be eligible to land\n * until the network considers the `blockhash` to be expired.\n *\n * This can happen when the network proceeds past the `lastValidBlockHeight` for which the blockhash\n * is considered valid, or when the network switches to a fork where that blockhash is not present.\n */\nexport type BlockhashLifetimeConstraint = Readonly<{\n    /**\n     * A recent blockhash observed by the transaction proposer.\n     *\n     * The transaction message will be considered eligible to land until the network determines this\n     * blockhash to be too old, or has switched to a fork where it is not present.\n     */\n    blockhash: Blockhash;\n    /**\n     * This is the block height beyond which the network will consider the blockhash to be too old\n     * to make a transaction message eligible to land.\n     */\n    lastValidBlockHeight: bigint;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the age of the blockhash it\n * includes.\n *\n * Such a transaction can only be landed on the network if the current block height of the network\n * is less than or equal to the value of\n * `TransactionMessageWithBlockhashLifetime['lifetimeConstraint']['lastValidBlockHeight']`.\n */\nexport interface TransactionMessageWithBlockhashLifetime {\n    readonly lifetimeConstraint: BlockhashLifetimeConstraint;\n}\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithBlockhashLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * if (isTransactionMessageWithBlockhashLifetime(message)) {\n *     // At this point, `message` has been refined to a `TransactionMessageWithBlockhashLifetime`.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsValid(blockhashIsValid);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a blockhash-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithBlockhashLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n): transactionMessage is BaseTransactionMessage & TransactionMessageWithBlockhashLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.blockhash === 'string' &&\n        typeof transactionMessage.lifetimeConstraint.lastValidBlockHeight === 'bigint' &&\n        isBlockhash(transactionMessage.lifetimeConstraint.blockhash)\n    );\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * blockhash-based lifetime, from an untrusted network API or user input. Use this function to\n * assert that such a transaction message actually has a blockhash-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithBlockhashLifetime`.\n *     assertIsTransactionMessageWithBlockhashLifetime(message);\n *     // At this point, `message` is a `TransactionMessageWithBlockhashLifetime` that can be used\n *     // with the RPC.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n * } catch (e) {\n *     // `message` turned out not to have a blockhash-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithBlockhashLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n): asserts transactionMessage is BaseTransactionMessage & TransactionMessageWithBlockhashLifetime {\n    if (!isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\n\n/**\n * Given a blockhash and the last block height at which that blockhash is considered usable to land\n * transactions, this method will return a new transaction message having the same type as the one\n * supplied plus the `TransactionMessageWithBlockhashLifetime` type.\n *\n * @example\n * ```ts\n * import { setTransactionMessageLifetimeUsingBlockhash } from '@solana/transaction-messages';\n *\n * const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n * const txMessageWithBlockhashLifetime = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, txMessage);\n * ```\n */\nexport function setTransactionMessageLifetimeUsingBlockhash<\n    TTransactionMessage extends BaseTransactionMessage & Partial<TransactionMessageWithLifetime>,\n>(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageLifetime<TTransactionMessage> & TransactionMessageWithBlockhashLifetime {\n    type ReturnType = ExcludeTransactionMessageLifetime<TTransactionMessage> & TransactionMessageWithBlockhashLifetime;\n\n    if (\n        'lifetimeConstraint' in transactionMessage &&\n        transactionMessage.lifetimeConstraint &&\n        'blockhash' in transactionMessage.lifetimeConstraint &&\n        transactionMessage.lifetimeConstraint.blockhash === blockhashLifetimeConstraint.blockhash &&\n        transactionMessage.lifetimeConstraint.lastValidBlockHeight === blockhashLifetimeConstraint.lastValidBlockHeight\n    ) {\n        return transactionMessage as ReturnType;\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        lifetimeConstraint: Object.freeze(blockhashLifetimeConstraint),\n    }) as ReturnType;\n}\n","import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    type Encoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport type { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\n\ntype AddressTableLookup = ReturnType<typeof getCompiledAddressTableLookups>[number];\n\nlet memoizedAddressTableLookupEncoder: VariableSizeEncoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupEncoder(): VariableSizeEncoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupEncoder) {\n        const indexEncoder = getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() }) as Encoder<\n            readonly number[]\n        >;\n        memoizedAddressTableLookupEncoder = getStructEncoder([\n            ['lookupTableAddress', getAddressEncoder()],\n            ['writableIndexes', indexEncoder],\n            ['readonlyIndexes', indexEncoder],\n        ]);\n    }\n\n    return memoizedAddressTableLookupEncoder;\n}\n\nlet memoizedAddressTableLookupDecoder: VariableSizeDecoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupDecoder(): VariableSizeDecoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupDecoder) {\n        const indexEncoder = getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() });\n        memoizedAddressTableLookupDecoder = getStructDecoder([\n            ['lookupTableAddress', getAddressDecoder()],\n            ['writableIndexes', indexEncoder],\n            ['readonlyIndexes', indexEncoder],\n        ]);\n    }\n\n    return memoizedAddressTableLookupDecoder;\n}\n\nexport function getAddressTableLookupCodec(): VariableSizeCodec<AddressTableLookup> {\n    return combineCodec(getAddressTableLookupEncoder(), getAddressTableLookupDecoder());\n}\n","import { FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport { getStructCodec, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getU8Codec, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledMessageHeader } from '../compile/header';\n\ntype MessageHeader = ReturnType<typeof getCompiledMessageHeader>;\n\nlet memoizedU8Encoder: FixedSizeEncoder<number, 1> | undefined;\nfunction getMemoizedU8Encoder(): FixedSizeEncoder<number, 1> {\n    if (!memoizedU8Encoder) memoizedU8Encoder = getU8Encoder();\n    return memoizedU8Encoder;\n}\n\nlet memoizedU8Decoder: FixedSizeDecoder<number, 1> | undefined;\nfunction getMemoizedU8Decoder(): FixedSizeDecoder<number, 1> {\n    if (!memoizedU8Decoder) memoizedU8Decoder = getU8Decoder();\n    return memoizedU8Decoder;\n}\n\nlet memoizedU8Codec: FixedSizeCodec<number, number, 1> | undefined;\nfunction getMemoizedU8Codec(): FixedSizeCodec<number, number, 1> {\n    if (!memoizedU8Codec) memoizedU8Codec = getU8Codec();\n    return memoizedU8Codec;\n}\n\nexport function getMessageHeaderEncoder(): FixedSizeEncoder<MessageHeader, 3> {\n    return getStructEncoder([\n        ['numSignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Encoder()],\n    ]) as FixedSizeEncoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderDecoder(): FixedSizeDecoder<MessageHeader, 3> {\n    return getStructDecoder([\n        ['numSignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Decoder()],\n    ]) as FixedSizeDecoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderCodec(): FixedSizeCodec<MessageHeader, MessageHeader, 3> {\n    return getStructCodec([\n        ['numSignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlySignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Codec()],\n    ]) as FixedSizeCodec<MessageHeader, MessageHeader, 3>;\n}\n","import {\n    addDecoderSizePrefix,\n    addEncoderSizePrefix,\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledInstructions } from '../compile/instructions';\n\ntype Instruction = ReturnType<typeof getCompiledInstructions>[number];\n\nlet memoizedGetInstructionEncoder: VariableSizeEncoder<Instruction> | undefined;\nexport function getInstructionEncoder(): VariableSizeEncoder<Instruction> {\n    if (!memoizedGetInstructionEncoder) {\n        memoizedGetInstructionEncoder = transformEncoder<Required<Instruction>, Instruction>(\n            getStructEncoder([\n                ['programAddressIndex', getU8Encoder()],\n                ['accountIndices', getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() })],\n                ['data', addEncoderSizePrefix(getBytesEncoder(), getShortU16Encoder())],\n            ]),\n            // Convert an instruction to have all fields defined\n            (instruction: Instruction): Required<Instruction> => {\n                if (instruction.accountIndices !== undefined && instruction.data !== undefined) {\n                    return instruction as Required<Instruction>;\n                }\n                return {\n                    ...instruction,\n                    accountIndices: instruction.accountIndices ?? [],\n                    data: instruction.data ?? new Uint8Array(0),\n                } as Required<Instruction>;\n            },\n        );\n    }\n\n    return memoizedGetInstructionEncoder;\n}\n\nlet memoizedGetInstructionDecoder: VariableSizeDecoder<Instruction> | undefined;\nexport function getInstructionDecoder(): VariableSizeDecoder<Instruction> {\n    if (!memoizedGetInstructionDecoder) {\n        memoizedGetInstructionDecoder = transformDecoder<Required<Instruction>, Instruction>(\n            getStructDecoder([\n                ['programAddressIndex', getU8Decoder()],\n                ['accountIndices', getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n                [\n                    'data',\n                    addDecoderSizePrefix(getBytesDecoder(), getShortU16Decoder()) as VariableSizeDecoder<Uint8Array>,\n                ],\n            ]),\n            // Convert an instruction to exclude optional fields if they are empty\n            (instruction: Required<Instruction>): Instruction => {\n                if (instruction.accountIndices.length && instruction.data.byteLength) {\n                    return instruction;\n                }\n                const { accountIndices, data, ...rest } = instruction;\n                return {\n                    ...rest,\n                    ...(accountIndices.length ? { accountIndices } : null),\n                    ...(data.byteLength ? { data } : null),\n                };\n            },\n        );\n    }\n    return memoizedGetInstructionDecoder;\n}\n\nexport function getInstructionCodec(): VariableSizeCodec<Instruction> {\n    return combineCodec(getInstructionEncoder(), getInstructionDecoder());\n}\n","import { AccountMeta, Instruction } from '@solana/instructions';\n\nexport type BaseTransactionMessage<\n    TVersion extends TransactionVersion = TransactionVersion,\n    TInstruction extends Instruction = Instruction,\n> = Readonly<{\n    instructions: readonly TInstruction[];\n    version: TVersion;\n}>;\n\nexport const MAX_SUPPORTED_TRANSACTION_VERSION = 0;\n\ntype LegacyInstruction<TProgramAddress extends string = string> = Instruction<TProgramAddress, readonly AccountMeta[]>;\ntype LegacyTransactionMessage = BaseTransactionMessage<'legacy', LegacyInstruction>;\ntype V0TransactionMessage = BaseTransactionMessage<0, Instruction>;\n\nexport type TransactionMessage = LegacyTransactionMessage | V0TransactionMessage;\nexport type TransactionVersion = 'legacy' | 0;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { MAX_SUPPORTED_TRANSACTION_VERSION, TransactionVersion } from '../transaction-message';\n\nconst VERSION_FLAG_MASK = 0x80;\n\n/**\n * Returns an encoder that you can use to encode a {@link TransactionVersion} to a byte array.\n *\n * Legacy messages will produce an empty array and will not advance the offset. Versioned messages\n * will produce an array with a single byte.\n */\nexport function getTransactionVersionEncoder(): VariableSizeEncoder<TransactionVersion> {\n    return createEncoder({\n        getSizeFromValue: value => (value === 'legacy' ? 0 : 1),\n        maxSize: 1,\n        write: (value, bytes, offset) => {\n            if (value === 'legacy') {\n                return offset;\n            }\n            if (value < 0 || value > 127) {\n                throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, {\n                    actualVersion: value,\n                });\n            }\n\n            if (value > MAX_SUPPORTED_TRANSACTION_VERSION) {\n                throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED, {\n                    unsupportedVersion: value,\n                });\n            }\n            bytes.set([value | VERSION_FLAG_MASK], offset);\n            return offset + 1;\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link TransactionVersion}.\n *\n * When the byte at the current offset is determined to represent a legacy transaction, this decoder\n * will return `'legacy'` and will not advance the offset.\n */\nexport function getTransactionVersionDecoder(): VariableSizeDecoder<TransactionVersion> {\n    return createDecoder({\n        maxSize: 1,\n        read: (bytes, offset) => {\n            const firstByte = bytes[offset];\n            if ((firstByte & VERSION_FLAG_MASK) === 0) {\n                // No version flag set; it's a legacy (unversioned) transaction.\n                return ['legacy', offset];\n            } else {\n                const version = firstByte ^ VERSION_FLAG_MASK;\n                if (version > MAX_SUPPORTED_TRANSACTION_VERSION) {\n                    throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version,\n                    });\n                }\n                return [version as TransactionVersion, offset + 1];\n            }\n        },\n    });\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link TransactionVersion}\n *\n * @see {@link getTransactionVersionDecoder}\n * @see {@link getTransactionVersionEncoder}\n */\nexport function getTransactionVersionCodec(): VariableSizeCodec<TransactionVersion> {\n    return combineCodec(getTransactionVersionEncoder(), getTransactionVersionDecoder());\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    createEncoder,\n    Decoder,\n    fixDecoderSize,\n    fixEncoderSize,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getConstantEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getUnionEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder } from '@solana/codecs-numbers';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\n\nimport { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\nimport { CompiledTransactionMessage, CompiledTransactionMessageWithLifetime } from '../compile/message';\nimport { getAddressTableLookupDecoder, getAddressTableLookupEncoder } from './address-table-lookup';\nimport { getMessageHeaderDecoder, getMessageHeaderEncoder } from './header';\nimport { getInstructionDecoder, getInstructionEncoder } from './instruction';\nimport { getTransactionVersionDecoder, getTransactionVersionEncoder } from './transaction-version';\n\nfunction getCompiledMessageLegacyEncoder(): VariableSizeEncoder<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n> {\n    return getStructEncoder(getPreludeStructEncoderTuple()) as VariableSizeEncoder<\n        CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n    >;\n}\n\nfunction getCompiledMessageVersionedEncoder(): VariableSizeEncoder<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n> {\n    return transformEncoder(\n        getStructEncoder([\n            ...getPreludeStructEncoderTuple(),\n            ['addressTableLookups', getAddressTableLookupArrayEncoder()],\n        ]) as VariableSizeEncoder<\n            CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n        >,\n        value => {\n            if (value.version === 'legacy') {\n                return value;\n            }\n            return {\n                ...value,\n                addressTableLookups: value.addressTableLookups ?? [],\n            };\n        },\n    );\n}\n\nfunction getPreludeStructEncoderTuple() {\n    const lifetimeTokenEncoder = getUnionEncoder(\n        [\n            // Use a 32-byte constant encoder for a missing lifetime token (index 0).\n            getConstantEncoder(new Uint8Array(32)),\n            // Use a 32-byte base58 encoder for a valid lifetime token (index 1).\n            fixEncoderSize(getBase58Encoder(), 32),\n        ],\n        value => (value === undefined ? 0 : 1),\n    );\n\n    return [\n        ['version', getTransactionVersionEncoder()],\n        ['header', getMessageHeaderEncoder()],\n        ['staticAccounts', getArrayEncoder(getAddressEncoder(), { size: getShortU16Encoder() })],\n        ['lifetimeToken', lifetimeTokenEncoder],\n        ['instructions', getArrayEncoder(getInstructionEncoder(), { size: getShortU16Encoder() })],\n    ] as const;\n}\n\nfunction getPreludeStructDecoderTuple() {\n    return [\n        ['version', getTransactionVersionDecoder() as Decoder<number>],\n        ['header', getMessageHeaderDecoder()],\n        ['staticAccounts', getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() })],\n        ['lifetimeToken', fixDecoderSize(getBase58Decoder(), 32)],\n        ['instructions', getArrayDecoder(getInstructionDecoder(), { size: getShortU16Decoder() })],\n        ['addressTableLookups', getAddressTableLookupArrayDecoder()],\n    ] as const;\n}\n\nfunction getAddressTableLookupArrayEncoder() {\n    return getArrayEncoder(getAddressTableLookupEncoder(), { size: getShortU16Encoder() });\n}\n\nfunction getAddressTableLookupArrayDecoder() {\n    return getArrayDecoder(getAddressTableLookupDecoder(), { size: getShortU16Decoder() });\n}\n\n/**\n * Returns an encoder that you can use to encode a {@link CompiledTransactionMessage} to a byte\n * array.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. The byte array produced by this encoder is the message part.\n */\nexport function getCompiledTransactionMessageEncoder(): VariableSizeEncoder<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n> {\n    return createEncoder({\n        getSizeFromValue: compiledMessage => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().getSizeFromValue(compiledMessage);\n            } else {\n                return getCompiledMessageVersionedEncoder().getSizeFromValue(compiledMessage);\n            }\n        },\n        write: (compiledMessage, bytes, offset) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().write(compiledMessage, bytes, offset);\n            } else {\n                return getCompiledMessageVersionedEncoder().write(compiledMessage, bytes, offset);\n            }\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link CompiledTransactionMessage}.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. You can use this decoder to decode the message part.\n */\nexport function getCompiledTransactionMessageDecoder(): VariableSizeDecoder<\n    CompiledTransactionMessage & CompiledTransactionMessageWithLifetime\n> {\n    return transformDecoder(\n        getStructDecoder(getPreludeStructDecoderTuple()) as VariableSizeDecoder<\n            CompiledTransactionMessage &\n                CompiledTransactionMessageWithLifetime & {\n                    addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n                }\n        >,\n        ({ addressTableLookups, ...restOfMessage }) => {\n            if (restOfMessage.version === 'legacy' || !addressTableLookups?.length) {\n                return restOfMessage;\n            }\n            return { ...restOfMessage, addressTableLookups };\n        },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link CompiledTransactionMessage}\n *\n * @see {@link getCompiledTransactionMessageDecoder}\n * @see {@link getCompiledTransactionMessageEncoder}\n */\nexport function getCompiledTransactionMessageCodec(): VariableSizeCodec<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime),\n    CompiledTransactionMessage & CompiledTransactionMessageWithLifetime\n> {\n    return combineCodec(getCompiledTransactionMessageEncoder(), getCompiledTransactionMessageDecoder());\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SolanaError,\n} from '@solana/errors';\nimport {\n    AccountLookupMeta,\n    AccountMeta,\n    AccountRole,\n    Instruction,\n    isSignerRole,\n    isWritableRole,\n    mergeRoles,\n    ReadonlyAccount,\n    ReadonlyAccountLookup,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableAccountLookup,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport const enum AddressMapEntryType {\n    FEE_PAYER,\n    LOOKUP_TABLE,\n    STATIC,\n}\n\ntype AddressMap = {\n    [address: string]: FeePayerAccountEntry | LookupTableAccountEntry | StaticAccountEntry;\n};\ntype FeePayerAccountEntry = Omit<WritableSignerAccount, 'address'> & {\n    [TYPE]: AddressMapEntryType.FEE_PAYER;\n};\ntype LookupTableAccountEntry = Omit<ReadonlyAccountLookup | WritableAccountLookup, 'address'> & {\n    [TYPE]: AddressMapEntryType.LOOKUP_TABLE;\n};\nexport type OrderedAccounts = Brand<(AccountLookupMeta | AccountMeta)[], 'OrderedAccounts'>;\ntype StaticAccountEntry = Omit<\n    ReadonlyAccount | ReadonlySignerAccount | WritableAccount | WritableSignerAccount,\n    'address'\n> & { [TYPE]: AddressMapEntryType.STATIC };\n\nfunction upsert(\n    addressMap: AddressMap,\n    address: Address,\n    update: (\n        entry: FeePayerAccountEntry | LookupTableAccountEntry | Record<never, never> | StaticAccountEntry,\n    ) => AddressMap[Address],\n) {\n    addressMap[address] = update(addressMap[address] ?? { role: AccountRole.READONLY });\n}\n\nconst TYPE = Symbol('AddressMapTypeProperty');\nexport const ADDRESS_MAP_TYPE_PROPERTY: typeof TYPE = TYPE;\n\nexport function getAddressMapFromInstructions(feePayer: Address, instructions: readonly Instruction[]): AddressMap {\n    const addressMap: AddressMap = {\n        [feePayer]: { [TYPE]: AddressMapEntryType.FEE_PAYER, role: AccountRole.WRITABLE_SIGNER },\n    };\n    const addressesOfInvokedPrograms = new Set<Address>();\n    for (const instruction of instructions) {\n        upsert(addressMap, instruction.programAddress, entry => {\n            addressesOfInvokedPrograms.add(instruction.programAddress);\n            if (TYPE in entry) {\n                if (isWritableRole(entry.role)) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, {\n                                programAddress: instruction.programAddress,\n                            });\n                        default:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, {\n                                programAddress: instruction.programAddress,\n                            });\n                    }\n                }\n                if (entry[TYPE] === AddressMapEntryType.STATIC) {\n                    return entry;\n                }\n            }\n            return { [TYPE]: AddressMapEntryType.STATIC, role: AccountRole.READONLY };\n        });\n        let addressComparator: ReturnType<typeof getAddressComparator>;\n        if (!instruction.accounts) {\n            continue;\n        }\n        for (const account of instruction.accounts) {\n            upsert(addressMap, account.address, entry => {\n                const {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    address: _,\n                    ...accountMeta\n                } = account;\n                if (TYPE in entry) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            // The fee payer already has the highest rank -- it is by definition\n                            // writable-signer. Return it, no matter how `account` is configured\n                            return entry;\n                        case AddressMapEntryType.LOOKUP_TABLE: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if ('lookupTableAddress' in accountMeta) {\n                                const shouldReplaceEntry =\n                                    // Consider using the new LOOKUP_TABLE if its address is different...\n                                    entry.lookupTableAddress !== accountMeta.lookupTableAddress &&\n                                    // ...and sorts before the existing one.\n                                    (addressComparator ||= getAddressComparator())(\n                                        accountMeta.lookupTableAddress,\n                                        entry.lookupTableAddress,\n                                    ) < 0;\n                                if (shouldReplaceEntry) {\n                                    return {\n                                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                        ...accountMeta,\n                                        role: nextRole,\n                                    } as LookupTableAccountEntry;\n                                }\n                            } else if (isSignerRole(accountMeta.role)) {\n                                // Upgrade this LOOKUP_TABLE entry to a static entry if it must sign.\n                                return {\n                                    [TYPE]: AddressMapEntryType.STATIC,\n                                    role: nextRole,\n                                } as StaticAccountEntry;\n                            }\n                            if (entry.role !== nextRole) {\n                                return {\n                                    ...entry,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                return entry;\n                            }\n                        }\n                        case AddressMapEntryType.STATIC: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if (\n                                // Check to see if this address represents a program that is invoked\n                                // in this transaction.\n                                addressesOfInvokedPrograms.has(account.address)\n                            ) {\n                                if (isWritableRole(accountMeta.role)) {\n                                    throw new SolanaError(\n                                        SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n                                        {\n                                            programAddress: account.address,\n                                        },\n                                    );\n                                }\n                                if (entry.role !== nextRole) {\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            } else if (\n                                'lookupTableAddress' in accountMeta &&\n                                // Static accounts can be 'upgraded' to lookup table accounts as\n                                // long as they are not require to sign the transaction.\n                                !isSignerRole(entry.role)\n                            ) {\n                                return {\n                                    ...accountMeta,\n                                    [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                if (entry.role !== nextRole) {\n                                    // The account's role ranks higher than the current entry's.\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            }\n                        }\n                    }\n                }\n                if ('lookupTableAddress' in accountMeta) {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                    };\n                } else {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.STATIC,\n                    };\n                }\n            });\n        }\n    }\n    return addressMap;\n}\n\nexport function getOrderedAccountsFromAddressMap(addressMap: AddressMap): OrderedAccounts {\n    let addressComparator: ReturnType<typeof getAddressComparator>;\n    const orderedAccounts: (AccountLookupMeta | AccountMeta)[] = Object.entries(addressMap)\n        .sort(([leftAddress, leftEntry], [rightAddress, rightEntry]) => {\n            // STEP 1: Rapid precedence check. Fee payer, then static addresses, then lookups.\n            if (leftEntry[TYPE] !== rightEntry[TYPE]) {\n                if (leftEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return 1;\n                } else if (leftEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return 1;\n                }\n            }\n            // STEP 2: Sort by signer-writability.\n            const leftIsSigner = isSignerRole(leftEntry.role);\n            if (leftIsSigner !== isSignerRole(rightEntry.role)) {\n                return leftIsSigner ? -1 : 1;\n            }\n            const leftIsWritable = isWritableRole(leftEntry.role);\n            if (leftIsWritable !== isWritableRole(rightEntry.role)) {\n                return leftIsWritable ? -1 : 1;\n            }\n            // STEP 3: Sort by address.\n            addressComparator ||= getAddressComparator();\n            if (\n                leftEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                rightEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                leftEntry.lookupTableAddress !== rightEntry.lookupTableAddress\n            ) {\n                return addressComparator(leftEntry.lookupTableAddress, rightEntry.lookupTableAddress);\n            } else {\n                return addressComparator(leftAddress, rightAddress);\n            }\n        })\n        .map(([address, addressMeta]) => ({\n            address: address as Address<typeof address>,\n            ...addressMeta,\n        }));\n    return orderedAccounts as unknown as OrderedAccounts;\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport { AccountRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype AddressTableLookup = Readonly<{\n    /** The address of the address lookup table account. */\n    lookupTableAddress: Address;\n    /** Indexes of accounts in a lookup table to load as read-only. */\n    readonlyIndexes: readonly number[];\n    /** Indexes of accounts in a lookup table to load as writable. */\n    writableIndexes: readonly number[];\n}>;\n\nexport function getCompiledAddressTableLookups(orderedAccounts: OrderedAccounts): AddressTableLookup[] {\n    const index: Record<\n        Address,\n        Readonly<{\n            [K in keyof Omit<AddressTableLookup, 'lookupTableAddress'>]: number[];\n        }>\n    > = {};\n    for (const account of orderedAccounts) {\n        if (!('lookupTableAddress' in account)) {\n            continue;\n        }\n        const entry = (index[account.lookupTableAddress] ||= {\n            readonlyIndexes: [],\n            writableIndexes: [],\n        });\n        if (account.role === AccountRole.WRITABLE) {\n            entry.writableIndexes.push(account.addressIndex);\n        } else {\n            entry.readonlyIndexes.push(account.addressIndex);\n        }\n    }\n    return Object.keys(index)\n        .sort(getAddressComparator())\n        .map(lookupTableAddress => ({\n            lookupTableAddress: lookupTableAddress as Address,\n            ...index[lookupTableAddress as unknown as Address],\n        }));\n}\n","import { isSignerRole, isWritableRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype MessageHeader = Readonly<{\n    /**\n     * The number of accounts in the static accounts list that are neither writable nor\n     * signers.\n     *\n     * Adding this number to `numSignerAccounts` yields the index of the first read-only non-signer\n     * account in the static accounts list.\n     */\n    numReadonlyNonSignerAccounts: number;\n    /**\n     * The number of read-only accounts in the static accounts list that must sign this\n     * transaction.\n     *\n     * Subtracting this number from `numSignerAccounts` yields the index of the first read-only\n     * signer account in the static accounts list.\n     */\n    numReadonlySignerAccounts: number;\n    /**\n     * The number of accounts in the static accounts list that must sign this transaction.\n     *\n     * Subtracting `numReadonlySignerAccounts` from this number yields the number of\n     * writable signer accounts in the static accounts list. Writable signer accounts always\n     * begin at index zero in the static accounts list.\n     *\n     * This number itself is the index of the first non-signer account in the static\n     * accounts list.\n     */\n    numSignerAccounts: number;\n}>;\n\nexport function getCompiledMessageHeader(orderedAccounts: OrderedAccounts): MessageHeader {\n    let numReadonlyNonSignerAccounts = 0;\n    let numReadonlySignerAccounts = 0;\n    let numSignerAccounts = 0;\n    for (const account of orderedAccounts) {\n        if ('lookupTableAddress' in account) {\n            break;\n        }\n        const accountIsWritable = isWritableRole(account.role);\n        if (isSignerRole(account.role)) {\n            numSignerAccounts++;\n            if (!accountIsWritable) {\n                numReadonlySignerAccounts++;\n            }\n        } else if (!accountIsWritable) {\n            numReadonlyNonSignerAccounts++;\n        }\n    }\n    return {\n        numReadonlyNonSignerAccounts,\n        numReadonlySignerAccounts,\n        numSignerAccounts,\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { Instruction } from '@solana/instructions';\n\nimport { OrderedAccounts } from './accounts';\n\ntype CompiledInstruction = Readonly<{\n    /**\n     * An ordered list of indices that indicate which accounts in the transaction message's\n     * accounts list are loaded by this instruction.\n     */\n    accountIndices?: number[];\n    /** The input to the invoked program */\n    data?: ReadonlyUint8Array;\n    /**\n     * The index of the address in the transaction message's accounts list associated with the\n     * program to invoke.\n     */\n    programAddressIndex: number;\n}>;\n\nfunction getAccountIndex(orderedAccounts: OrderedAccounts) {\n    const out: Record<Address, number> = {};\n    for (const [index, account] of orderedAccounts.entries()) {\n        out[account.address] = index;\n    }\n    return out;\n}\n\nexport function getCompiledInstructions(\n    instructions: readonly Instruction[],\n    orderedAccounts: OrderedAccounts,\n): CompiledInstruction[] {\n    const accountIndex = getAccountIndex(orderedAccounts);\n    return instructions.map(({ accounts, data, programAddress }) => {\n        return {\n            programAddressIndex: accountIndex[programAddress],\n            ...(accounts ? { accountIndices: accounts.map(({ address }) => accountIndex[address]) } : null),\n            ...(data ? { data } : null),\n        };\n    });\n}\n","import { TransactionMessageWithBlockhashLifetime, TransactionMessageWithDurableNonceLifetime } from '../index';\n\nexport function getCompiledLifetimeToken(\n    lifetimeConstraint: (\n        | TransactionMessageWithBlockhashLifetime\n        | TransactionMessageWithDurableNonceLifetime\n    )['lifetimeConstraint'],\n): string {\n    if ('nonce' in lifetimeConstraint) {\n        return lifetimeConstraint.nonce;\n    }\n    return lifetimeConstraint.blockhash;\n}\n","import { Address } from '@solana/addresses';\n\nimport { OrderedAccounts } from './accounts';\n\nexport function getCompiledStaticAccounts(orderedAccounts: OrderedAccounts): Address[] {\n    const firstLookupTableAccountIndex = orderedAccounts.findIndex(account => 'lookupTableAddress' in account);\n    const orderedStaticAccounts =\n        firstLookupTableAccountIndex === -1 ? orderedAccounts : orderedAccounts.slice(0, firstLookupTableAccountIndex);\n    return orderedStaticAccounts.map(({ address }) => address);\n}\n","import { TransactionMessageWithFeePayer } from '../fee-payer';\nimport { TransactionMessageWithLifetime } from '../lifetime';\nimport { BaseTransactionMessage } from '../transaction-message';\nimport { getAddressMapFromInstructions, getOrderedAccountsFromAddressMap } from './accounts';\nimport { getCompiledAddressTableLookups } from './address-table-lookups';\nimport { getCompiledMessageHeader } from './header';\nimport { getCompiledInstructions } from './instructions';\nimport { getCompiledLifetimeToken } from './lifetime-token';\nimport { getCompiledStaticAccounts } from './static-accounts';\n\ntype BaseCompiledTransactionMessage = Readonly<{\n    /**\n     * Information about the version of the transaction message and the role of the accounts it\n     * loads.\n     */\n    header: ReturnType<typeof getCompiledMessageHeader>;\n    instructions: ReturnType<typeof getCompiledInstructions>;\n    /** A list of addresses indicating which accounts to load */\n    staticAccounts: ReturnType<typeof getCompiledStaticAccounts>;\n}>;\n\n/**\n * A transaction message in a form suitable for encoding for execution on the network.\n *\n * You can not fully reconstruct a source message from a compiled message without extra information.\n * In particular, supporting details about the lifetime constraint and the concrete addresses of\n * accounts sourced from account lookup tables are lost to compilation.\n */\nexport type CompiledTransactionMessage = LegacyCompiledTransactionMessage | VersionedCompiledTransactionMessage;\n\nexport type CompiledTransactionMessageWithLifetime = Readonly<{\n    /**\n     * 32 bytes of data observed by the transaction proposed that makes a transaction eligible to\n     * land on the network.\n     *\n     * In the case of a transaction message with a nonce lifetime constraint, this will be the value\n     * of the nonce itself. In all other cases this will be a recent blockhash.\n     */\n    lifetimeToken: ReturnType<typeof getCompiledLifetimeToken>;\n}>;\n\ntype LegacyCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        version: 'legacy';\n    }>;\n\ntype VersionedCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        /** A list of address tables and the accounts that this transaction loads from them */\n        addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n        version: 0;\n    }>;\n\n/**\n * Converts the type of transaction message data structure that you create in your application to\n * the type of transaction message data structure that can be encoded for execution on the network.\n *\n * This is a lossy process; you can not fully reconstruct a source message from a compiled message\n * without extra information. In particular, supporting details about the lifetime constraint and\n * the concrete addresses of accounts sourced from account lookup tables will be lost to\n * compilation.\n *\n * @see {@link decompileTransactionMessage}\n */\nexport function compileTransactionMessage<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage): CompiledTransactionMessageFromTransactionMessage<TTransactionMessage> {\n    type ReturnType = CompiledTransactionMessageFromTransactionMessage<TTransactionMessage>;\n\n    const addressMap = getAddressMapFromInstructions(\n        transactionMessage.feePayer.address,\n        transactionMessage.instructions,\n    );\n    const orderedAccounts = getOrderedAccountsFromAddressMap(addressMap);\n    const lifetimeConstraint = (transactionMessage as Partial<TransactionMessageWithLifetime>).lifetimeConstraint;\n\n    return {\n        ...(transactionMessage.version !== 'legacy'\n            ? { addressTableLookups: getCompiledAddressTableLookups(orderedAccounts) }\n            : null),\n        ...(lifetimeConstraint ? { lifetimeToken: getCompiledLifetimeToken(lifetimeConstraint) } : null),\n        header: getCompiledMessageHeader(orderedAccounts),\n        instructions: getCompiledInstructions(transactionMessage.instructions, orderedAccounts),\n        staticAccounts: getCompiledStaticAccounts(orderedAccounts),\n        version: transactionMessage.version,\n    } as ReturnType;\n}\n\ntype CompiledTransactionMessageFromTransactionMessage<TTransactionMessage extends BaseTransactionMessage> =\n    ForwardTransactionMessageLifetime<ForwardTransactionMessageVersion<TTransactionMessage>, TTransactionMessage>;\n\ntype ForwardTransactionMessageVersion<TTransactionMessage extends BaseTransactionMessage> =\n    TTransactionMessage extends Readonly<{ version: 'legacy' }>\n        ? LegacyCompiledTransactionMessage\n        : VersionedCompiledTransactionMessage;\n\ntype ForwardTransactionMessageLifetime<\n    TCompiledTransactionMessage extends CompiledTransactionMessage,\n    TTransactionMessage extends BaseTransactionMessage,\n> = TTransactionMessage extends TransactionMessageWithLifetime\n    ? CompiledTransactionMessageWithLifetime & TCompiledTransactionMessage\n    : TCompiledTransactionMessage;\n","import { Address } from '@solana/addresses';\nimport { AccountLookupMeta, AccountMeta, AccountRole, Instruction, isSignerRole } from '@solana/instructions';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { BaseTransactionMessage, TransactionMessage } from './transaction-message';\n\ntype Mutable<T> = {\n    -readonly [P in keyof T]: T[P];\n};\n\n// Look up the address in lookup tables, return a lookup meta if it is found in any of them\nfunction findAddressInLookupTables(\n    address: Address,\n    role: AccountRole.READONLY | AccountRole.WRITABLE,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): AccountLookupMeta | undefined {\n    for (const [lookupTableAddress, addresses] of Object.entries(addressesByLookupTableAddress)) {\n        for (let i = 0; i < addresses.length; i++) {\n            if (address === addresses[i]) {\n                return {\n                    address,\n                    addressIndex: i,\n                    lookupTableAddress: lookupTableAddress as Address,\n                    role,\n                };\n            }\n        }\n    }\n}\n\ntype TransactionMessageNotLegacy = Exclude<TransactionMessage, { version: 'legacy' }>;\n\n// Each account can be AccountLookupMeta | AccountMeta\ntype WidenInstructionAccounts<TInstruction extends Instruction> =\n    TInstruction extends Instruction<infer TProgramAddress, infer TAccounts>\n        ? Instruction<\n              TProgramAddress,\n              {\n                  [K in keyof TAccounts]: TAccounts[K] extends AccountMeta<infer TAddress>\n                      ? AccountLookupMeta<TAddress> | AccountMeta<TAddress>\n                      : TAccounts[K];\n              }\n          >\n        : TInstruction;\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\ntype WidenTransactionMessageInstructions<TTransactionMessage extends TransactionMessage> =\n    TTransactionMessage extends BaseTransactionMessage<infer TVersion, infer TInstruction>\n        ? BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>> &\n              ExtractAdditionalProps<\n                  TTransactionMessage,\n                  BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>>\n              >\n        : TTransactionMessage;\n\n/**\n * Given a transaction message and a mapping of lookup tables to the addresses stored in them, this\n * function will return a new transaction message with the same instructions but with all non-signer\n * accounts that are found in the given lookup tables represented by an {@link AccountLookupMeta}\n * instead of an {@link AccountMeta}.\n *\n * This means that these accounts will take up less space in the compiled transaction message. This\n * size reduction is most significant when the transaction includes many accounts from the same\n * lookup table.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import {\n *     AddressesByLookupTableAddress,\n *     compressTransactionMessageUsingAddressLookupTables,\n * } from '@solana/transaction-messages';\n * import { fetchAddressLookupTable } from '@solana-program/address-lookup-table';\n *\n * const lookupTableAddress = address('4QwSwNriKPrz8DLW4ju5uxC2TN5cksJx6tPUPj7DGLAW');\n * const {\n *     data: { addresses },\n * } = await fetchAddressLookupTable(rpc, lookupTableAddress);\n * const addressesByAddressLookupTable: AddressesByLookupTableAddress = {\n *     [lookupTableAddress]: addresses,\n * };\n *\n * const compressedTransactionMessage = compressTransactionMessageUsingAddressLookupTables(\n *     transactionMessage,\n *     addressesByAddressLookupTable,\n * );\n * ```\n */\nexport function compressTransactionMessageUsingAddressLookupTables<\n    TTransactionMessage extends TransactionMessageNotLegacy = TransactionMessageNotLegacy,\n>(\n    transactionMessage: TTransactionMessage,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): TTransactionMessage | WidenTransactionMessageInstructions<TTransactionMessage> {\n    const programAddresses = new Set(transactionMessage.instructions.map(ix => ix.programAddress));\n    const eligibleLookupAddresses = new Set(\n        Object.values(addressesByLookupTableAddress)\n            .flatMap(a => a)\n            .filter(address => !programAddresses.has(address)),\n    );\n    const newInstructions: Instruction[] = [];\n    let updatedAnyInstructions = false;\n    for (const instruction of transactionMessage.instructions) {\n        if (!instruction.accounts) {\n            newInstructions.push(instruction);\n            continue;\n        }\n\n        const newAccounts: Mutable<NonNullable<Instruction['accounts']>> = [];\n        let updatedAnyAccounts = false;\n        for (const account of instruction.accounts) {\n            // If the address is already a lookup, is not in any lookup tables, or is a signer role, return as-is\n            if (\n                'lookupTableAddress' in account ||\n                !eligibleLookupAddresses.has(account.address) ||\n                isSignerRole(account.role)\n            ) {\n                newAccounts.push(account);\n                continue;\n            }\n\n            // We already checked it's in one of the lookup tables\n            const lookupMetaAccount = findAddressInLookupTables(\n                account.address,\n                account.role,\n                addressesByLookupTableAddress,\n            )!;\n            newAccounts.push(Object.freeze(lookupMetaAccount));\n            updatedAnyAccounts = true;\n            updatedAnyInstructions = true;\n        }\n\n        newInstructions.push(\n            Object.freeze(updatedAnyAccounts ? { ...instruction, accounts: newAccounts } : instruction),\n        );\n    }\n\n    return Object.freeze(\n        updatedAnyInstructions ? { ...transactionMessage, instructions: newInstructions } : transactionMessage,\n    );\n}\n","import { TransactionMessage, TransactionVersion } from './transaction-message';\nimport { TransactionMessageWithinSizeLimit } from './transaction-message-size';\n\ntype TransactionConfig<TVersion extends TransactionVersion> = Readonly<{\n    version: TVersion;\n}>;\n\ntype EmptyTransactionMessage<TVersion extends TransactionVersion> = Omit<\n    Extract<TransactionMessage, { version: TVersion }>,\n    'instructions'\n> &\n    TransactionMessageWithinSizeLimit & { instructions: readonly [] };\n\n/**\n * Given a {@link TransactionVersion} this method will return an empty transaction having the\n * capabilities of that version.\n *\n * @example\n * ```ts\n * import { createTransactionMessage } from '@solana/transaction-messages';\n *\n * const message = createTransactionMessage({ version: 0 });\n * ```\n */\nexport function createTransactionMessage<TVersion extends TransactionVersion>(\n    config: TransactionConfig<TVersion>,\n): EmptyTransactionMessage<TVersion> {\n    return Object.freeze({\n        instructions: Object.freeze([]),\n        version: config.version,\n    }) as EmptyTransactionMessage<TVersion>;\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    AccountRole,\n    Instruction,\n    InstructionWithAccounts,\n    InstructionWithData,\n    isSignerRole,\n    ReadonlyAccount,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport type AdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n> = Instruction<'11111111111111111111111111111111'> &\n    InstructionWithAccounts<\n        readonly [\n            WritableAccount<TNonceAccountAddress>,\n            ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n            ReadonlySignerAccount<TNonceAuthorityAddress> | WritableSignerAccount<TNonceAuthorityAddress>,\n        ]\n    > &\n    InstructionWithData<AdvanceNonceAccountInstructionData>;\n\ntype AdvanceNonceAccountInstructionData = Brand<Uint8Array, 'AdvanceNonceAccountInstructionData'>;\n\nconst RECENT_BLOCKHASHES_SYSVAR_ADDRESS =\n    'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\nconst SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n\n/**\n * Creates an instruction for the System program to advance a nonce.\n *\n * This instruction is a prerequisite for a transaction with a nonce-based lifetime to be landed on\n * the network. In order to be considered valid, the transaction must meet all of these criteria.\n *\n * 1. Its lifetime constraint must be a {@link NonceLifetimeConstraint}.\n * 2. The value contained in the on-chain account at the address `nonceAccountAddress` must be equal\n *    to {@link NonceLifetimeConstraint.nonce} at the time the transaction is landed.\n * 3. The first instruction in that transaction message must be the one returned by this function.\n *\n * You could also use the `getAdvanceNonceAccountInstruction` method of `@solana-program/system`.\n */\nexport function createAdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n>(\n    nonceAccountAddress: Address<TNonceAccountAddress>,\n    nonceAuthorityAddress: Address<TNonceAuthorityAddress>,\n): AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return {\n        accounts: [\n            { address: nonceAccountAddress, role: AccountRole.WRITABLE },\n            {\n                address: RECENT_BLOCKHASHES_SYSVAR_ADDRESS,\n                role: AccountRole.READONLY,\n            },\n            { address: nonceAuthorityAddress, role: AccountRole.READONLY_SIGNER },\n        ],\n        data: new Uint8Array([4, 0, 0, 0]) as AdvanceNonceAccountInstructionData,\n        programAddress: SYSTEM_PROGRAM_ADDRESS,\n    };\n}\n\n/**\n * A type guard that returns `true` if the instruction conforms to the\n * {@link AdvanceNonceAccountInstruction} type, and refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isAdvanceNonceAccountInstruction } from '@solana/transaction-messages';\n *\n * if (isAdvanceNonceAccountInstruction(message.instructions[0])) {\n *     // At this point, the first instruction in the message has been refined to a\n *     // `AdvanceNonceAccountInstruction`.\n *     setNonceAccountAddress(message.instructions[0].accounts[0].address);\n * } else {\n *     setError('The first instruction is not an `AdvanceNonce` instruction');\n * }\n * ```\n */\nexport function isAdvanceNonceAccountInstruction(\n    instruction: Instruction,\n): instruction is AdvanceNonceAccountInstruction {\n    return (\n        instruction.programAddress === SYSTEM_PROGRAM_ADDRESS &&\n        // Test for `AdvanceNonceAccount` instruction data\n        instruction.data != null &&\n        isAdvanceNonceAccountInstructionData(instruction.data) &&\n        // Test for exactly 3 accounts\n        instruction.accounts?.length === 3 &&\n        // First account is nonce account address\n        instruction.accounts[0].address != null &&\n        instruction.accounts[0].role === AccountRole.WRITABLE &&\n        // Second account is recent blockhashes sysvar\n        instruction.accounts[1].address === RECENT_BLOCKHASHES_SYSVAR_ADDRESS &&\n        instruction.accounts[1].role === AccountRole.READONLY &&\n        // Third account is nonce authority account\n        instruction.accounts[2].address != null &&\n        isSignerRole(instruction.accounts[2].role)\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionData(data: ReadonlyUint8Array): data is AdvanceNonceAccountInstructionData {\n    // AdvanceNonceAccount is the fifth instruction in the System Program (index 4)\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME, SolanaError } from '@solana/errors';\nimport { Instruction } from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nimport {\n    AdvanceNonceAccountInstruction,\n    createAdvanceNonceAccountInstruction,\n    isAdvanceNonceAccountInstruction,\n} from './durable-nonce-instruction';\nimport { ExcludeTransactionMessageLifetime } from './lifetime';\nimport { BaseTransactionMessage } from './transaction-message';\nimport { ExcludeTransactionMessageWithinSizeLimit } from './transaction-message-size';\n\ntype DurableNonceConfig<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Readonly<{\n    readonly nonce: Nonce<TNonceValue>;\n    readonly nonceAccountAddress: Address<TNonceAccountAddress>;\n    readonly nonceAuthorityAddress: Address<TNonceAuthorityAddress>;\n}>;\n\n/** Represents a string that is particularly known to be the base58-encoded value of a nonce. */\nexport type Nonce<TNonceValue extends string = string> = Brand<TNonceValue, 'Nonce'>;\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network.\n *\n * The transaction message will continue to be eligible to land until the network considers the\n * `nonce` to have advanced. This can happen when the nonce account in which this nonce is found is\n * destroyed, or the nonce value within changes.\n */\nexport type NonceLifetimeConstraint<TNonceValue extends string = string> = Readonly<{\n    /**\n     * A value contained in the related nonce account at the time the transaction was prepared.\n     *\n     * The transaction will be considered eligible to land until the nonce account ceases to exist\n     * or contain this value.\n     */\n    nonce: Nonce<TNonceValue>;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the value of a nonce it includes.\n *\n * Such a transaction can only be landed on the network if the nonce is known to the network and has\n * not already been used to land a different transaction.\n */\nexport interface TransactionMessageWithDurableNonceLifetime<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> {\n    readonly instructions: readonly [\n        // The first instruction *must* be the system program's `AdvanceNonceAccount` instruction.\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...Instruction[],\n    ];\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n}\n\n/**\n * A helper type to exclude the durable nonce lifetime constraint from a transaction message.\n */\nexport type ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage extends BaseTransactionMessage> =\n    TTransactionMessage extends TransactionMessageWithDurableNonceLifetime\n        ? ExcludeTransactionMessageLifetime<TTransactionMessage>\n        : TTransactionMessage;\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithDurableNonceLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithDurableNonceLifetime } from '@solana/transaction-messages';\n * import { fetchNonce } from \"@solana-program/system\";\n *\n * if (isTransactionMessageWithDurableNonceLifetime(message)) {\n *     // At this point, `message` has been refined to a\n *     // `TransactionMessageWithDurableNonceLifetime`.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n *     setNonceIsValid(nonce === actualNonce);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a nonce-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithDurableNonceLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): transactionMessage is BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.nonce === 'string' &&\n        transactionMessage.instructions[0] != null &&\n        isAdvanceNonceAccountInstruction(transactionMessage.instructions[0])\n    );\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * nonce-based lifetime, from an untrusted network API or user input. Use this function to assert\n * that such a transaction message actually has a nonce-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithDurableNonceLifetime } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithDurableNonceLifetime`.\n *     assertIsTransactionMessageWithDurableNonceLifetime(message);\n *     // At this point, `message` is a `TransactionMessageWithDurableNonceLifetime` that can be used\n *     // with the RPC.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n * } catch (e) {\n *     // `message` turned out not to have a nonce-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithDurableNonceLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): asserts transactionMessage is BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    if (!isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\n\nfunction isAdvanceNonceAccountInstructionForNonce<\n    TNonceAccountAddress extends Address = Address,\n    TNonceAuthorityAddress extends Address = Address,\n>(\n    instruction: AdvanceNonceAccountInstruction,\n    nonceAccountAddress: TNonceAccountAddress,\n    nonceAuthorityAddress: TNonceAuthorityAddress,\n): instruction is AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return (\n        instruction.accounts[0].address === nonceAccountAddress &&\n        instruction.accounts[2].address === nonceAuthorityAddress\n    );\n}\n\n/**\n * Given a nonce, the account where the value of the nonce is stored, and the address of the account\n * authorized to consume that nonce, this method will return a new transaction having the same type\n * as the one supplied plus the {@link TransactionMessageWithDurableNonceLifetime} type.\n *\n * In particular, this method _prepends_ an instruction to the transaction message designed to\n * consume (or 'advance') the nonce in the same transaction whose lifetime is defined by it.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { Nonce, setTransactionMessageLifetimeUsingDurableNonce } from '@solana/transaction-messages';\n * import { fetchNonce } from '@solana-program/system';\n *\n * const nonceAccountAddress = address('EGtMh4yvXswwHhwVhyPxGrVV2TkLTgUqGodbATEPvojZ');\n * const nonceAuthorityAddress = address('4KD1Rdrd89NG7XbzW3xsX9Aqnx2EExJvExiNme6g9iAT');\n *\n * const {\n *     data: { blockhash },\n * } = await fetchNonce(rpc, nonceAccountAddress);\n * const nonce = blockhash as string as Nonce;\n *\n * const durableNonceTransactionMessage = setTransactionMessageLifetimeUsingDurableNonce(\n *     { nonce, nonceAccountAddress, nonceAuthorityAddress },\n *     tx,\n * );\n * ```\n */\nexport function setTransactionMessageLifetimeUsingDurableNonce<\n    TTransactionMessage extends BaseTransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n>(\n    {\n        nonce,\n        nonceAccountAddress,\n        nonceAuthorityAddress,\n    }: DurableNonceConfig<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue>,\n    transactionMessage: TTransactionMessage,\n): SetTransactionMessageWithDurableNonceLifetime<\n    TTransactionMessage,\n    TNonceAccountAddress,\n    TNonceAuthorityAddress,\n    TNonceValue\n> {\n    type ReturnType = SetTransactionMessageWithDurableNonceLifetime<\n        TTransactionMessage,\n        TNonceAccountAddress,\n        TNonceAuthorityAddress,\n        TNonceValue\n    >;\n\n    let newInstructions: [\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...Instruction[],\n    ];\n\n    const firstInstruction = transactionMessage.instructions[0];\n    if (firstInstruction && isAdvanceNonceAccountInstruction(firstInstruction)) {\n        if (isAdvanceNonceAccountInstructionForNonce(firstInstruction, nonceAccountAddress, nonceAuthorityAddress)) {\n            if (\n                isTransactionMessageWithDurableNonceLifetime(transactionMessage) &&\n                transactionMessage.lifetimeConstraint.nonce === nonce\n            ) {\n                return transactionMessage as unknown as ReturnType;\n            } else {\n                // we already have the right first instruction, leave it as-is\n                newInstructions = [firstInstruction, ...transactionMessage.instructions.slice(1)];\n            }\n        } else {\n            // we have a different advance nonce instruction as the first instruction, replace it\n            newInstructions = [\n                Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n                ...transactionMessage.instructions.slice(1),\n            ];\n        }\n    } else {\n        // we don't have an existing advance nonce instruction as the first instruction, prepend one\n        newInstructions = [\n            Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n            ...transactionMessage.instructions,\n        ];\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze(newInstructions),\n        lifetimeConstraint: Object.freeze({ nonce }),\n    }) as unknown as ReturnType;\n}\n\n/**\n * Helper type that transforms a given transaction message type into a new one that has the\n * `AdvanceNonceAccount` instruction as the first instruction and a lifetime constraint\n * representing the nonce value.\n */\ntype SetTransactionMessageWithDurableNonceLifetime<\n    TTransactionMessage extends BaseTransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Omit<\n    // 1. The transaction message only grows in size if it currently has a different (or no) lifetime.\n    TTransactionMessage extends TransactionMessageWithDurableNonceLifetime\n        ? TTransactionMessage\n        : ExcludeTransactionMessageWithinSizeLimit<TTransactionMessage>,\n    // 2. Remove the instructions array as we are going to replace it with a new one.\n    'instructions'\n> & {\n    // 3. Replace or prepend the first instruction with the advance nonce account instruction.\n    readonly instructions: TTransactionMessage['instructions'] extends readonly [\n        AdvanceNonceAccountInstruction,\n        ...infer TTail extends readonly Instruction[],\n    ]\n        ? readonly [AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>, ...TTail]\n        : readonly [\n              AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n              ...TTransactionMessage['instructions'],\n          ];\n    // 4. Set the lifetime constraint to the nonce value.\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n};\n","import { Address } from '@solana/addresses';\n\nimport { BaseTransactionMessage } from './transaction-message';\n\n/**\n * Represents a transaction message for which a fee payer has been declared. A transaction must\n * conform to this type to be compiled and landed on the network.\n */\nexport interface TransactionMessageWithFeePayer<TAddress extends string = string> {\n    readonly feePayer: Readonly<{ address: Address<TAddress> }>;\n}\n\n/**\n * A helper type to exclude the fee payer from a transaction message.\n */\ntype ExcludeTransactionMessageFeePayer<TTransactionMessage extends BaseTransactionMessage> = Omit<\n    TTransactionMessage,\n    'feePayer'\n>;\n\n/**\n * Given a base58-encoded address of a system account, this method will return a new transaction\n * message having the same type as the one supplied plus the {@link TransactionMessageWithFeePayer}\n * type.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { setTransactionMessageFeePayer } from '@solana/transaction-messages';\n *\n * const myAddress = address('mpngsFd4tmbUfzDYJayjKZwZcaR7aWb2793J6grLsGu');\n * const txPaidByMe = setTransactionMessageFeePayer(myAddress, tx);\n * ```\n */\nexport function setTransactionMessageFeePayer<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends BaseTransactionMessage & Partial<TransactionMessageWithFeePayer>,\n>(\n    feePayer: Address<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageFeePayer<TTransactionMessage> & TransactionMessageWithFeePayer<TFeePayerAddress> {\n    if (\n        'feePayer' in transactionMessage &&\n        feePayer === transactionMessage.feePayer?.address &&\n        isAddressOnlyFeePayer(transactionMessage.feePayer)\n    ) {\n        return transactionMessage as unknown as Omit<TTransactionMessage, 'feePayer'> &\n            TransactionMessageWithFeePayer<TFeePayerAddress>;\n    }\n    const out = {\n        ...transactionMessage,\n        feePayer: Object.freeze({ address: feePayer }),\n    };\n    Object.freeze(out);\n    return out;\n}\n\nfunction isAddressOnlyFeePayer(\n    feePayer: Partial<TransactionMessageWithFeePayer>['feePayer'],\n): feePayer is { address: Address } {\n    return (\n        !!feePayer &&\n        'address' in feePayer &&\n        typeof feePayer.address === 'string' &&\n        Object.keys(feePayer).length === 1\n    );\n}\n","import { Instruction } from '@solana/instructions';\n\nimport { ExcludeTransactionMessageDurableNonceLifetime } from './durable-nonce';\nimport { BaseTransactionMessage } from './transaction-message';\nimport { ExcludeTransactionMessageWithinSizeLimit } from './transaction-message-size';\n\n/**\n * A helper type to append instructions to a transaction message\n * without losing type information about the current instructions.\n */\ntype AppendTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstructions extends readonly Instruction[],\n> = Omit<ExcludeTransactionMessageWithinSizeLimit<TTransactionMessage>, 'instructions'> & {\n    readonly instructions: readonly [...TTransactionMessage['instructions'], ...TInstructions];\n};\n\n/**\n * A helper type to prepend instructions to a transaction message\n * without losing type information about the current instructions.\n */\ntype PrependTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstructions extends readonly Instruction[],\n> = Omit<\n    ExcludeTransactionMessageWithinSizeLimit<ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage>>,\n    'instructions'\n> & {\n    readonly instructions: readonly [...TInstructions, ...TTransactionMessage['instructions']];\n};\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstructions} if you need to append multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { getUtf8Encoder } from '@solana/codecs-strings';\n * import { appendTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransactionMessage = appendTransactionMessageInstruction(\n *     {\n *         data: getUtf8Encoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     transactionMessage,\n * );\n * ```\n */\nexport function appendTransactionMessageInstruction<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstruction extends Instruction,\n>(\n    instruction: TInstruction,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage, [TInstruction]> {\n    return appendTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstruction} if you only need to append one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { appendTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = appendTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function appendTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    const TInstructions extends readonly Instruction[],\n>(\n    instructions: TInstructions,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage, TInstructions> {\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze([\n            ...(transactionMessage.instructions as TTransactionMessage['instructions']),\n            ...instructions,\n        ] as readonly [...TTransactionMessage['instructions'], ...TInstructions]),\n    });\n}\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstructions} if you need to prepend multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstruction(\n *     {\n *         data: new TextEncoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstruction<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstruction extends Instruction,\n>(\n    instruction: TInstruction,\n    transactionMessage: TTransactionMessage,\n): PrependTransactionMessageInstructions<TTransactionMessage, [TInstruction]> {\n    return prependTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstruction} if you only need to prepend one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    const TInstructions extends readonly Instruction[],\n>(\n    instructions: TInstructions,\n    transactionMessage: TTransactionMessage,\n): PrependTransactionMessageInstructions<TTransactionMessage, TInstructions> {\n    return Object.freeze({\n        ...(transactionMessage as ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage>),\n        instructions: Object.freeze([\n            ...instructions,\n            ...(transactionMessage.instructions as TTransactionMessage['instructions']),\n        ] as readonly [...TInstructions, ...TTransactionMessage['instructions']]),\n    });\n}\n","import { Address, assertIsAddress } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\nimport { pipe } from '@solana/functional';\nimport { AccountLookupMeta, AccountMeta, AccountRole, Instruction } from '@solana/instructions';\nimport type { Blockhash } from '@solana/rpc-types';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { setTransactionMessageLifetimeUsingBlockhash } from './blockhash';\nimport { CompiledTransactionMessage, CompiledTransactionMessageWithLifetime } from './compile';\nimport type { getCompiledAddressTableLookups } from './compile/address-table-lookups';\nimport { createTransactionMessage } from './create-transaction-message';\nimport { Nonce, setTransactionMessageLifetimeUsingDurableNonce } from './durable-nonce';\nimport { isAdvanceNonceAccountInstruction } from './durable-nonce-instruction';\nimport { setTransactionMessageFeePayer, TransactionMessageWithFeePayer } from './fee-payer';\nimport { appendTransactionMessageInstruction } from './instructions';\nimport { TransactionMessageWithLifetime } from './lifetime';\nimport { BaseTransactionMessage, TransactionVersion } from './transaction-message';\n\nfunction getAccountMetas(message: CompiledTransactionMessage): AccountMeta[] {\n    const { header } = message;\n    const numWritableSignerAccounts = header.numSignerAccounts - header.numReadonlySignerAccounts;\n    const numWritableNonSignerAccounts =\n        message.staticAccounts.length - header.numSignerAccounts - header.numReadonlyNonSignerAccounts;\n\n    const accountMetas: AccountMeta[] = [];\n\n    let accountIndex = 0;\n    for (let i = 0; i < numWritableSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlySignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < numWritableNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlyNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY,\n        });\n        accountIndex++;\n    }\n\n    return accountMetas;\n}\n\nfunction getAddressLookupMetas(\n    compiledAddressTableLookups: ReturnType<typeof getCompiledAddressTableLookups>,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): AccountLookupMeta[] {\n    // check that all message lookups are known\n    const compiledAddressTableLookupAddresses = compiledAddressTableLookups.map(l => l.lookupTableAddress);\n    const missing = compiledAddressTableLookupAddresses.filter(a => addressesByLookupTableAddress[a] === undefined);\n    if (missing.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, {\n            lookupTableAddresses: missing,\n        });\n    }\n\n    const readOnlyMetas: AccountLookupMeta[] = [];\n    const writableMetas: AccountLookupMeta[] = [];\n\n    // we know that for each lookup, knownLookups[lookup.lookupTableAddress] is defined\n    for (const lookup of compiledAddressTableLookups) {\n        const addresses = addressesByLookupTableAddress[lookup.lookupTableAddress];\n        const readonlyIndexes = lookup.readonlyIndexes;\n        const writableIndexes = lookup.writableIndexes;\n\n        const highestIndex = Math.max(...readonlyIndexes, ...writableIndexes);\n        if (highestIndex >= addresses.length) {\n            throw new SolanaError(\n                SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n                {\n                    highestKnownIndex: addresses.length - 1,\n                    highestRequestedIndex: highestIndex,\n                    lookupTableAddress: lookup.lookupTableAddress,\n                },\n            );\n        }\n\n        const readOnlyForLookup: AccountLookupMeta[] = readonlyIndexes.map(r => ({\n            address: addresses[r],\n            addressIndex: r,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.READONLY,\n        }));\n        readOnlyMetas.push(...readOnlyForLookup);\n\n        const writableForLookup: AccountLookupMeta[] = writableIndexes.map(w => ({\n            address: addresses[w],\n            addressIndex: w,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.WRITABLE,\n        }));\n        writableMetas.push(...writableForLookup);\n    }\n\n    return [...writableMetas, ...readOnlyMetas];\n}\n\nfunction convertInstruction(\n    instruction: CompiledTransactionMessage['instructions'][0],\n    accountMetas: AccountMeta[],\n): Instruction {\n    const programAddress = accountMetas[instruction.programAddressIndex]?.address;\n    if (!programAddress) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, {\n            index: instruction.programAddressIndex,\n        });\n    }\n\n    const accounts = instruction.accountIndices?.map(accountIndex => accountMetas[accountIndex]);\n    const { data } = instruction;\n\n    return Object.freeze({\n        programAddress,\n        ...(accounts && accounts.length ? { accounts: Object.freeze(accounts) } : {}),\n        ...(data && data.length ? { data } : {}),\n    });\n}\n\ntype LifetimeConstraint =\n    | {\n          blockhash: Blockhash;\n          lastValidBlockHeight: bigint;\n      }\n    | {\n          nonce: Nonce;\n          nonceAccountAddress: Address;\n          nonceAuthorityAddress: Address;\n      };\n\nfunction getLifetimeConstraint(\n    messageLifetimeToken: string,\n    firstInstruction?: Instruction,\n    lastValidBlockHeight?: bigint,\n): LifetimeConstraint {\n    if (!firstInstruction || !isAdvanceNonceAccountInstruction(firstInstruction)) {\n        // first instruction is not advance durable nonce, so use blockhash lifetime constraint\n        return {\n            blockhash: messageLifetimeToken as Blockhash,\n            lastValidBlockHeight: lastValidBlockHeight ?? 2n ** 64n - 1n, // U64 MAX\n        };\n    } else {\n        // We know these accounts are defined because we checked `isAdvanceNonceAccountInstruction`\n        const nonceAccountAddress = firstInstruction.accounts[0].address;\n        assertIsAddress(nonceAccountAddress);\n\n        const nonceAuthorityAddress = firstInstruction.accounts[2].address;\n        assertIsAddress(nonceAuthorityAddress);\n\n        return {\n            nonce: messageLifetimeToken as Nonce,\n            nonceAccountAddress,\n            nonceAuthorityAddress,\n        };\n    }\n}\n\nexport type DecompileTransactionMessageConfig = {\n    /**\n     * If the compiled message loads addresses from one or more address lookup tables, you will have\n     * to supply a map of those tables to an array of the addresses they contained at the time that\n     * the transaction message was constructed.\n     *\n     * @see {@link decompileTransactionMessageFetchingLookupTables} if you do not already have this.\n     */\n    addressesByLookupTableAddress?: AddressesByLookupTableAddress;\n    /**\n     * If the compiled message has a blockhash-based lifetime constraint, you will have to supply\n     * the block height after which that blockhash is no longer valid for use as a lifetime\n     * constraint.\n     */\n    lastValidBlockHeight?: bigint;\n};\n\n/**\n * Converts the type of transaction message data structure appropriate for execution on the network\n * to the type of transaction message data structure designed for use in your application.\n *\n * Because compilation is a lossy process, you can not fully reconstruct a source message from a\n * compiled message without extra information. In order to faithfully reconstruct the original\n * source message you will need to supply supporting details about the lifetime constraint and the\n * concrete addresses of any accounts sourced from account lookup tables.\n *\n * @see {@link compileTransactionMessage}\n */\nexport function decompileTransactionMessage(\n    compiledTransactionMessage: CompiledTransactionMessage & CompiledTransactionMessageWithLifetime,\n    config?: DecompileTransactionMessageConfig,\n): BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithLifetime {\n    const feePayer = compiledTransactionMessage.staticAccounts[0];\n    if (!feePayer) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING);\n    }\n\n    const accountMetas = getAccountMetas(compiledTransactionMessage);\n    const accountLookupMetas =\n        'addressTableLookups' in compiledTransactionMessage &&\n        compiledTransactionMessage.addressTableLookups !== undefined &&\n        compiledTransactionMessage.addressTableLookups.length > 0\n            ? getAddressLookupMetas(\n                  compiledTransactionMessage.addressTableLookups,\n                  config?.addressesByLookupTableAddress ?? {},\n              )\n            : [];\n    const transactionMetas = [...accountMetas, ...accountLookupMetas];\n\n    const instructions: Instruction[] = compiledTransactionMessage.instructions.map(compiledInstruction =>\n        convertInstruction(compiledInstruction, transactionMetas),\n    );\n\n    const firstInstruction = instructions[0];\n    const lifetimeConstraint = getLifetimeConstraint(\n        compiledTransactionMessage.lifetimeToken,\n        firstInstruction,\n        config?.lastValidBlockHeight,\n    );\n\n    return pipe(\n        createTransactionMessage({ version: compiledTransactionMessage.version as TransactionVersion }),\n        m => setTransactionMessageFeePayer(feePayer, m),\n        m =>\n            instructions.reduce(\n                (acc, instruction) => appendTransactionMessageInstruction(instruction, acc),\n                m as BaseTransactionMessage & TransactionMessageWithFeePayer,\n            ),\n        m =>\n            'blockhash' in lifetimeConstraint\n                ? setTransactionMessageLifetimeUsingBlockhash(lifetimeConstraint, m)\n                : setTransactionMessageLifetimeUsingDurableNonce(lifetimeConstraint, m),\n    );\n}\n"],"names":["alphabet","SolanaError","getU8Encoder","getU8Decoder","getStructEncoder","getStructDecoder","getArrayEncoder","getShortU16Encoder","getArrayDecoder","getShortU16Decoder","createEncoder","createDecoder","combineCodec","transformEncoder","getAddressEncoder","getAddressDecoder","transformDecoder","AccountRole","getAddressComparator","isWritableRole","isSignerRole"],"mappings":"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"}},
    {"offset": {"line": 5834, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/transactions/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transactions/src/codecs/signatures-encoder.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transactions/src/codecs/transaction-codec.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transactions/src/lifetime.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transactions/src/compile-transaction.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transactions/src/signatures.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transactions/src/wire-transaction.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transactions/src/transaction-size.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transactions/src/sendable-transaction.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/transactions/src/transaction-message-size.ts"],"sourcesContent":["import { fixEncoderSize, transformEncoder, VariableSizeEncoder } from '@solana/codecs-core';\nimport { getArrayEncoder, getBytesEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Encoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { SignaturesMap } from '../transaction';\n\nfunction getSignaturesToEncode(signaturesMap: SignaturesMap): SignatureBytes[] {\n    const signatures = Object.values(signaturesMap);\n    if (signatures.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES);\n    }\n\n    return signatures.map(signature => {\n        if (!signature) {\n            return new Uint8Array(64).fill(0) as SignatureBytes;\n        }\n        return signature;\n    });\n}\n\nexport function getSignaturesEncoder(): VariableSizeEncoder<SignaturesMap> {\n    return transformEncoder(\n        getArrayEncoder(fixEncoderSize(getBytesEncoder(), 64), { size: getShortU16Encoder() }),\n        getSignaturesToEncode,\n    );\n}\n","import { getAddressDecoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    fixDecoderSize,\n    padRightDecoder,\n    ReadonlyUint8Array,\n    transformDecoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getTupleDecoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getU8Decoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { getTransactionVersionDecoder } from '@solana/transaction-messages';\n\nimport { SignaturesMap, Transaction, TransactionMessageBytes } from '../transaction';\nimport { getSignaturesEncoder } from './signatures-encoder';\n\n/**\n * Returns an encoder that you can use to encode a {@link Transaction} to a byte array in a wire\n * format appropriate for sending to the Solana network for execution.\n */\nexport function getTransactionEncoder(): VariableSizeEncoder<Transaction> {\n    return getStructEncoder([\n        ['signatures', getSignaturesEncoder()],\n        ['messageBytes', getBytesEncoder()],\n    ]);\n}\n\n/**\n * Returns a decoder that you can use to convert a byte array in the Solana transaction wire format\n * to a {@link Transaction} object.\n *\n * @example\n * ```ts\n * import { getTransactionDecoder } from '@solana/transactions';\n *\n * const transactionDecoder = getTransactionDecoder();\n * const transaction = transactionDecoder.decode(wireTransactionBytes);\n * for (const [address, signature] in Object.entries(transaction.signatures)) {\n *     console.log(`Signature by ${address}`, signature);\n * }\n * ```\n */\n\nexport function getTransactionDecoder(): VariableSizeDecoder<Transaction> {\n    return transformDecoder(\n        getStructDecoder([\n            ['signatures', getArrayDecoder(fixDecoderSize(getBytesDecoder(), 64), { size: getShortU16Decoder() })],\n            ['messageBytes', getBytesDecoder()],\n        ]),\n        decodePartiallyDecodedTransaction,\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a {@link Transaction}\n *\n * @see {@link getTransactionDecoder}\n * @see {@link getTransactionEncoder}\n */\nexport function getTransactionCodec(): VariableSizeCodec<Transaction> {\n    return combineCodec(getTransactionEncoder(), getTransactionDecoder());\n}\n\ntype PartiallyDecodedTransaction = {\n    messageBytes: ReadonlyUint8Array;\n    signatures: ReadonlyUint8Array[];\n};\n\nfunction decodePartiallyDecodedTransaction(transaction: PartiallyDecodedTransaction): Transaction {\n    const { messageBytes, signatures } = transaction;\n\n    /*\n    Relevant message structure is at the start:\n    - transaction version (0 bytes for legacy transactions, 1 byte for versioned transactions)\n    - `numRequiredSignatures` (1 byte, we verify this matches the length of signatures)\n    - `numReadOnlySignedAccounts` (1 byte, not used here)\n    - `numReadOnlyUnsignedAccounts` (1 byte, not used here)\n    - static addresses, with signers first. This is an array of addresses, prefixed with a short-u16 length\n    */\n\n    const signerAddressesDecoder = getTupleDecoder([\n        // read transaction version\n        getTransactionVersionDecoder(),\n        // read first byte of header, `numSignerAccounts`\n        // padRight to skip the next 2 bytes, `numReadOnlySignedAccounts` and `numReadOnlyUnsignedAccounts` which we don't need\n        padRightDecoder(getU8Decoder(), 2),\n        // read static addresses\n        getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() }),\n    ]);\n    const [_txVersion, numRequiredSignatures, staticAddresses] = signerAddressesDecoder.decode(messageBytes);\n\n    const signerAddresses = staticAddresses.slice(0, numRequiredSignatures);\n\n    // signer addresses and signatures must be the same length\n    // we encode an all-zero signature when the signature is missing\n    if (signerAddresses.length !== signatures.length) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, {\n            numRequiredSignatures,\n            signaturesLength: signatures.length,\n            signerAddresses,\n        });\n    }\n\n    // combine the signer addresses + signatures into the signatures map\n    const signaturesMap: SignaturesMap = {};\n    signerAddresses.forEach((address, index) => {\n        const signatureForAddress = signatures[index];\n        if (signatureForAddress.every(b => b === 0)) {\n            signaturesMap[address] = null;\n        } else {\n            signaturesMap[address] = signatureForAddress as SignatureBytes;\n        }\n    });\n\n    return {\n        messageBytes: messageBytes as TransactionMessageBytes,\n        signatures: Object.freeze(signaturesMap),\n    };\n}\n","import { type Address, isAddress } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE,\n    SolanaError,\n} from '@solana/errors';\nimport { type Blockhash, isBlockhash, type Slot } from '@solana/rpc-types';\nimport type {\n    CompiledTransactionMessage,\n    CompiledTransactionMessageWithLifetime,\n    Nonce,\n    TransactionMessage,\n    TransactionMessageWithBlockhashLifetime,\n    TransactionMessageWithDurableNonceLifetime,\n} from '@solana/transaction-messages';\n\nimport type { Transaction } from './transaction';\n\n/**\n * A constraint which, when applied to a transaction, makes that transaction eligible to land on the\n * network. The transaction will continue to be eligible to land until the network considers the\n * `blockhash` to be expired.\n *\n * This can happen when the network proceeds past the `lastValidBlockHeight` for which the blockhash\n * is considered valid, or when the network switches to a fork where that blockhash is not present.\n */\nexport type TransactionBlockhashLifetime = {\n    /**\n     * A recent blockhash observed by the transaction proposer.\n     *\n     * The transaction will be considered eligible to land until the network determines this\n     * blockhash to be too old, or has switched to a fork where it is not present.\n     */\n    blockhash: Blockhash;\n    /**\n     * This is the block height beyond which the network will consider the blockhash to be too old\n     * to make a transaction eligible to land.\n     */\n    lastValidBlockHeight: Slot;\n};\n\n/**\n * A constraint which, when applied to a transaction, makes that transaction eligible to land on the\n * network.\n *\n * The transaction will continue to be eligible to land until the network considers the `nonce` to\n * have advanced. This can happen when the nonce account in which this nonce is found is destroyed,\n * or the nonce value within changes.\n */\nexport type TransactionDurableNonceLifetime = {\n    /**\n     * A value contained in the account with address `nonceAccountAddress` at the time the\n     * transaction was prepared.\n     *\n     * The transaction will be considered eligible to land until the nonce account ceases to exist\n     * or contain this value.\n     */\n    nonce: Nonce;\n    /** The account that contains the `nonce` value */\n    nonceAccountAddress: Address;\n};\n\n/**\n * A transaction whose ability to land on the network is determined by some evanescent criteria.\n *\n * This describes a window of time after which a transaction is constructed and before which it will\n * no longer be accepted by the network.\n *\n * No transaction can land on Solana without having a `lifetimeConstraint` set.\n */\nexport type TransactionWithLifetime = {\n    readonly lifetimeConstraint: TransactionBlockhashLifetime | TransactionDurableNonceLifetime;\n};\n\n/**\n * A transaction whose lifetime is determined by the age of a blockhash observed on the network.\n *\n * The transaction will continue to be eligible to land until the network considers the `blockhash`\n * to be expired.\n */\nexport type TransactionWithBlockhashLifetime = {\n    readonly lifetimeConstraint: TransactionBlockhashLifetime;\n};\n\n/**\n * A transaction whose lifetime is determined by a nonce.\n *\n * The transaction will continue to be eligible to land until the network considers the `nonce` to\n * have advanced. This can happen when the nonce account in which this nonce is found is destroyed,\n * or the nonce value within changes.\n */\nexport type TransactionWithDurableNonceLifetime = {\n    readonly lifetimeConstraint: TransactionDurableNonceLifetime;\n};\n\n/**\n * Helper type that sets the lifetime constraint of a transaction to be the same as the\n * lifetime constraint of the provided transaction message.\n *\n * If the transaction message has no explicit lifetime constraint, neither will the transaction.\n */\nexport type SetTransactionLifetimeFromTransactionMessage<\n    TTransaction extends Transaction,\n    TTransactionMessage extends TransactionMessage,\n> = TTransactionMessage extends { lifetimeConstraint: unknown }\n    ? TTransactionMessage['lifetimeConstraint'] extends TransactionMessageWithBlockhashLifetime['lifetimeConstraint']\n        ? TransactionWithBlockhashLifetime & TTransaction\n        : TTransactionMessage['lifetimeConstraint'] extends TransactionMessageWithDurableNonceLifetime['lifetimeConstraint']\n          ? TransactionWithDurableNonceLifetime & TTransaction\n          : TransactionWithLifetime & TTransaction\n    : TTransaction;\n\nconst SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address;\n\nfunction compiledInstructionIsAdvanceNonceInstruction(\n    instruction: CompiledTransactionMessage['instructions'][number],\n    staticAddresses: Address[],\n): instruction is typeof instruction & { accountIndices: [number, number, number] } {\n    return (\n        staticAddresses[instruction.programAddressIndex] === SYSTEM_PROGRAM_ADDRESS &&\n        // Test for `AdvanceNonceAccount` instruction data\n        instruction.data != null &&\n        isAdvanceNonceAccountInstructionData(instruction.data) &&\n        // Test for exactly 3 accounts\n        instruction.accountIndices?.length === 3\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionData(data: ReadonlyUint8Array): boolean {\n    // AdvanceNonceAccount is the fifth instruction in the System Program (index 4)\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n\n/**\n * Get the lifetime constraint for a transaction from a compiled transaction message that includes a lifetime token.\n * @param compiledTransactionMessage A compiled transaction message that includes a lifetime token\n * @returns A lifetime constraint for the transaction\n * Note that this is less precise than checking a decompiled instruction, as we can't inspect\n * the address or role of input accounts (which may be in lookup tables). However, this is\n * sufficient for all valid advance durable nonce instructions.\n * Note that the program address must not be in a lookup table, see [this answer on StackExchange](https://solana.stackexchange.com/a/16224/289)\n * @see {@link isAdvanceNonceAccountInstruction}\n * Note that this function is async to allow for future implementations that may fetch `lastValidBlockHeight` using an RPC\n */\n// eslint-disable-next-line @typescript-eslint/require-await\nexport async function getTransactionLifetimeConstraintFromCompiledTransactionMessage(\n    compiledTransactionMessage: CompiledTransactionMessage & CompiledTransactionMessageWithLifetime,\n): Promise<TransactionBlockhashLifetime | TransactionDurableNonceLifetime> {\n    const firstInstruction = compiledTransactionMessage.instructions[0];\n    const { staticAccounts } = compiledTransactionMessage;\n\n    // We need to check if the first instruction is an AdvanceNonceAccount instruction\n    if (firstInstruction && compiledInstructionIsAdvanceNonceInstruction(firstInstruction, staticAccounts)) {\n        const nonceAccountAddress = staticAccounts[firstInstruction.accountIndices[0]];\n        if (!nonceAccountAddress) {\n            throw new SolanaError(SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE, {\n                nonce: compiledTransactionMessage.lifetimeToken,\n            });\n        }\n        return {\n            nonce: compiledTransactionMessage.lifetimeToken as Nonce,\n            nonceAccountAddress,\n        };\n    } else {\n        return {\n            blockhash: compiledTransactionMessage.lifetimeToken as Blockhash,\n            // This is not known from the compiled message, so we set it to the maximum possible value\n            lastValidBlockHeight: 0xffffffffffffffffn,\n        };\n    }\n}\n\n/**\n * A type guard that returns `true` if the transaction conforms to the\n * {@link TransactionWithBlockhashLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionWithBlockhashLifetime } from '@solana/transactions';\n *\n * if (isTransactionWithBlockhashLifetime(transaction)) {\n *     // At this point, `transaction` has been refined to a `TransactionWithBlockhashLifetime`.\n *     const { blockhash } = transaction.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsValid(blockhashIsValid);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a blockhash-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionWithBlockhashLifetime(\n    transaction: Transaction | (Transaction & TransactionWithLifetime),\n): transaction is Transaction & TransactionWithBlockhashLifetime {\n    return (\n        'lifetimeConstraint' in transaction &&\n        'blockhash' in transaction.lifetimeConstraint &&\n        typeof transaction.lifetimeConstraint.blockhash === 'string' &&\n        typeof transaction.lifetimeConstraint.lastValidBlockHeight === 'bigint' &&\n        isBlockhash(transaction.lifetimeConstraint.blockhash)\n    );\n}\n\n/**\n * From time to time you might acquire a transaction, that you expect to have a\n * blockhash-based lifetime, from for example a wallet. Use this function to\n * assert that such a transaction actually has a blockhash-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionWithBlockhashLifetime } from '@solana/transactions';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `transaction` to `TransactionWithBlockhashLifetime`.\n *     assertIsTransactionWithBlockhashLifetime(transaction);\n *     // At this point, `transaction` is a `TransactionWithBlockhashLifetime` that can be used\n *     // with the RPC.\n *     const { blockhash } = transaction.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n * } catch (e) {\n *     // `transaction` turned out not to have a blockhash-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionWithBlockhashLifetime(\n    transaction: Transaction | (Transaction & TransactionWithLifetime),\n): asserts transaction is Transaction & TransactionWithBlockhashLifetime {\n    if (!isTransactionWithBlockhashLifetime(transaction)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\n\n/**\n * A type guard that returns `true` if the transaction conforms to the\n * {@link TransactionWithDurableNonceLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionWithDurableNonceLifetime } from '@solana/transactions';\n * import { fetchNonce } from \"@solana-program/system\";\n *\n * if (isTransactionWithDurableNonceLifetime(transaction)) {\n *     // At this point, `transaction` has been refined to a\n *     // `TransactionWithDurableNonceLifetime`.\n *     const { nonce, nonceAccountAddress } = transaction.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n *     setNonceIsValid(nonce === actualNonce);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a nonce-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionWithDurableNonceLifetime(\n    transaction: Transaction | (Transaction & TransactionWithLifetime),\n): transaction is Transaction & TransactionWithDurableNonceLifetime {\n    return (\n        'lifetimeConstraint' in transaction &&\n        'nonce' in transaction.lifetimeConstraint &&\n        typeof transaction.lifetimeConstraint.nonce === 'string' &&\n        typeof transaction.lifetimeConstraint.nonceAccountAddress === 'string' &&\n        isAddress(transaction.lifetimeConstraint.nonceAccountAddress)\n    );\n}\n\n/**\n * From time to time you might acquire a transaction, that you expect to have a\n * nonce-based lifetime, from for example a wallet. Use this function to assert\n * that such a transaction actually has a nonce-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionWithDurableNonceLifetime } from '@solana/transactions';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `transaction` to `TransactionWithDurableNonceLifetime`.\n *     assertIsTransactionWithDurableNonceLifetime(transaction);\n *     // At this point, `transaction` is a `TransactionWithDurableNonceLifetime` that can be used\n *     // with the RPC.\n *     const { nonce, nonceAccountAddress } = transaction.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n * } catch (e) {\n *     // `transaction` turned out not to have a nonce-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionWithDurableNonceLifetime(\n    transaction: Transaction | (Transaction & TransactionWithLifetime),\n): asserts transaction is Transaction & TransactionWithDurableNonceLifetime {\n    if (!isTransactionWithDurableNonceLifetime(transaction)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\n","import {\n    BaseTransactionMessage,\n    compileTransactionMessage,\n    getCompiledTransactionMessageEncoder,\n    isTransactionMessageWithBlockhashLifetime,\n    isTransactionMessageWithDurableNonceLifetime,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\n\nimport type { TransactionWithLifetime } from './lifetime';\nimport type { SignaturesMap, TransactionFromTransactionMessage, TransactionMessageBytes } from './transaction';\n\n/**\n * Returns a {@link Transaction} object for a given {@link TransactionMessage}.\n *\n * This includes the compiled bytes of the transaction message, and a map of signatures. This map\n * will have a key for each address that is required to sign the transaction. The transaction will\n * not yet have signatures for any of these addresses.\n *\n * Whether a transaction message is ready to be compiled or not is enforced for you at the type\n * level. In order to be signable, a transaction message must:\n *\n * - have a version and a list of zero or more instructions (ie. conform to\n *   {@link BaseTransactionMessage})\n * - have a fee payer set (ie. conform to {@link TransactionMessageWithFeePayer})\n * - have a lifetime specified (ie. conform to {@link TransactionMessageWithBlockhashLifetime} or\n *   {@link TransactionMessageWithDurableNonceLifetime})\n */\nexport function compileTransaction<TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer>(\n    transactionMessage: TTransactionMessage,\n): Readonly<TransactionFromTransactionMessage<TTransactionMessage>> {\n    type ReturnType = Readonly<TransactionFromTransactionMessage<TTransactionMessage>>;\n\n    const compiledMessage = compileTransactionMessage(transactionMessage);\n    const messageBytes = getCompiledTransactionMessageEncoder().encode(compiledMessage) as TransactionMessageBytes;\n\n    const transactionSigners = compiledMessage.staticAccounts.slice(0, compiledMessage.header.numSignerAccounts);\n    const signatures: SignaturesMap = {};\n    for (const signerAddress of transactionSigners) {\n        signatures[signerAddress] = null;\n    }\n\n    let lifetimeConstraint: TransactionWithLifetime['lifetimeConstraint'] | undefined;\n    if (isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        lifetimeConstraint = {\n            blockhash: transactionMessage.lifetimeConstraint.blockhash,\n            lastValidBlockHeight: transactionMessage.lifetimeConstraint.lastValidBlockHeight,\n        };\n    } else if (isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {\n        lifetimeConstraint = {\n            nonce: transactionMessage.lifetimeConstraint.nonce,\n            nonceAccountAddress: transactionMessage.instructions[0].accounts[0].address,\n        };\n    }\n\n    return Object.freeze({\n        ...(lifetimeConstraint ? { lifetimeConstraint } : undefined),\n        messageBytes: messageBytes,\n        signatures: Object.freeze(signatures),\n    }) as ReturnType;\n}\n","import { Address, getAddressFromPublicKey } from '@solana/addresses';\nimport { bytesEqual, Decoder } from '@solana/codecs-core';\nimport { getBase58Decoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { Signature, SignatureBytes, signBytes } from '@solana/keys';\nimport { NominalType } from '@solana/nominal-types';\n\nimport { Transaction } from './transaction';\n\n/**\n * Represents a transaction that is signed by all of its required signers. Being fully signed is a\n * prerequisite of functions designed to land transactions on the network.\n */\nexport type FullySignedTransaction = NominalType<'transactionSignedness', 'fullySigned'>;\n\nlet base58Decoder: Decoder<string> | undefined;\n\n/**\n * Given a transaction signed by its fee payer, this method will return the {@link Signature} that\n * uniquely identifies it. This string can be used to look up transactions at a later date, for\n * example on a Solana block explorer.\n *\n * @example\n * ```ts\n * import { getSignatureFromTransaction } from '@solana/transactions';\n *\n * const signature = getSignatureFromTransaction(tx);\n * console.debug(`Inspect this transaction at https://explorer.solana.com/tx/${signature}`);\n * ```\n */\nexport function getSignatureFromTransaction(transaction: Transaction): Signature {\n    if (!base58Decoder) base58Decoder = getBase58Decoder();\n\n    // We have ordered signatures from the compiled message accounts\n    // first signature is the fee payer\n    const signatureBytes = Object.values(transaction.signatures)[0];\n    if (!signatureBytes) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING);\n    }\n    const transactionSignature = base58Decoder.decode(signatureBytes);\n    return transactionSignature as Signature;\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign a transaction, this method will return a new signed transaction of type\n * {@link Transaction}.\n *\n * Though the resulting transaction might have every signature it needs to land on the network, this\n * function will not assert that it does. A partially signed transaction cannot be landed on the\n * network, but can be serialized and deserialized.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { partiallySignTransaction } from '@solana/transactions';\n *\n * const partiallySignedTransaction = await partiallySignTransaction([myPrivateKey], tx);\n * ```\n *\n * @see {@link signTransaction} if you want to assert that the transaction has all of its required\n * signatures after signing.\n */\nexport async function partiallySignTransaction<TTransaction extends Transaction>(\n    keyPairs: CryptoKeyPair[],\n    transaction: TTransaction,\n): Promise<TTransaction> {\n    let newSignatures: Record<Address, SignatureBytes> | undefined;\n    let unexpectedSigners: Set<Address> | undefined;\n\n    await Promise.all(\n        keyPairs.map(async keyPair => {\n            const address = await getAddressFromPublicKey(keyPair.publicKey);\n            const existingSignature = transaction.signatures[address];\n\n            // Check if the address is expected to sign the transaction\n            if (existingSignature === undefined) {\n                // address is not an expected signer for this transaction\n                unexpectedSigners ||= new Set();\n                unexpectedSigners.add(address);\n                return;\n            }\n\n            // Return if there are any unexpected signers already since we won't be using signatures\n            if (unexpectedSigners) {\n                return;\n            }\n\n            const newSignature = await signBytes(keyPair.privateKey, transaction.messageBytes);\n\n            if (existingSignature !== null && bytesEqual(newSignature, existingSignature)) {\n                // already have the same signature set\n                return;\n            }\n\n            newSignatures ||= {};\n            newSignatures[address] = newSignature;\n        }),\n    );\n\n    if (unexpectedSigners && unexpectedSigners.size > 0) {\n        const expectedSigners = Object.keys(transaction.signatures);\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION, {\n            expectedAddresses: expectedSigners,\n            unexpectedAddresses: [...unexpectedSigners],\n        });\n    }\n\n    if (!newSignatures) {\n        return transaction;\n    }\n\n    return Object.freeze({\n        ...transaction,\n        signatures: Object.freeze({\n            ...transaction.signatures,\n            ...newSignatures,\n        }),\n    });\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign a transaction, this method will return a new signed transaction of type\n * {@link FullySignedTransaction}.\n *\n * This function will throw unless the resulting transaction is fully signed.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { signTransaction } from '@solana/transactions';\n *\n * const signedTransaction = await signTransaction([myPrivateKey], tx);\n * ```\n *\n * @see {@link partiallySignTransaction} if you want to sign the transaction without asserting that\n * the resulting transaction is fully signed.\n */\nexport async function signTransaction<TTransaction extends Transaction>(\n    keyPairs: CryptoKeyPair[],\n    transaction: TTransaction,\n): Promise<FullySignedTransaction & TTransaction> {\n    const out = await partiallySignTransaction(keyPairs, transaction);\n    assertIsFullySignedTransaction(out);\n    Object.freeze(out);\n    return out;\n}\n\n/**\n * Checks whether a given {@link Transaction} is fully signed.\n *\n * @example\n * ```ts\n * import { isFullySignedTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * if (isFullySignedTransaction(transaction)) {\n *   // At this point we know that the transaction is signed and can be sent to the network.\n * }\n * ```\n */\nexport function isFullySignedTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): transaction is FullySignedTransaction & TTransaction {\n    return Object.entries(transaction.signatures).every(([_, signatureBytes]) => !!signatureBytes);\n}\n\n/**\n * From time to time you might acquire a {@link Transaction}, that you expect to be fully signed,\n * from an untrusted network API or user input. Use this function to assert that such a transaction\n * is fully signed.\n *\n * @example\n * ```ts\n * import { assertIsFullySignedTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * try {\n *     // If this type assertion function doesn't throw, then Typescript will upcast `transaction`\n *     // to `FullySignedTransaction`.\n *     assertIsFullySignedTransaction(transaction);\n *     // At this point we know that the transaction is signed and can be sent to the network.\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n * } catch(e) {\n *     if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n *         setError(`Missing signatures for ${e.context.addresses.join(', ')}`);\n *     }\n *     throw;\n * }\n * ```\n */\nexport function assertIsFullySignedTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): asserts transaction is FullySignedTransaction & TTransaction {\n    const missingSigs: Address[] = [];\n    Object.entries(transaction.signatures).forEach(([address, signatureBytes]) => {\n        if (!signatureBytes) {\n            missingSigs.push(address as Address);\n        }\n    });\n\n    if (missingSigs.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING, {\n            addresses: missingSigs,\n        });\n    }\n}\n","import { getBase64Decoder } from '@solana/codecs-strings';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\nimport { getTransactionEncoder } from './codecs';\nimport { Transaction } from './transaction';\n\n/** Represents the wire format of a transaction as a base64-encoded string. */\nexport type Base64EncodedWireTransaction = Brand<EncodedString<string, 'base64'>, 'Base64EncodedWireTransaction'>;\n\n/**\n * Given a signed transaction, this method returns the transaction as a string that conforms to the\n * {@link Base64EncodedWireTransaction} type.\n *\n * @example\n * ```ts\n * import { getBase64EncodedWireTransaction, signTransaction } from '@solana/transactions';\n *\n * const serializedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n * const signature = await rpc.sendTransaction(serializedTransaction, { encoding: 'base64' }).send();\n * ```\n */\nexport function getBase64EncodedWireTransaction(transaction: Transaction): Base64EncodedWireTransaction {\n    const wireTransactionBytes = getTransactionEncoder().encode(transaction);\n    return getBase64Decoder().decode(wireTransactionBytes) as Base64EncodedWireTransaction;\n}\n","import { SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, SolanaError } from '@solana/errors';\nimport type { NominalType } from '@solana/nominal-types';\nimport type { BaseTransactionMessage, TransactionMessageWithinSizeLimit } from '@solana/transaction-messages';\n\nimport { getTransactionEncoder } from './codecs';\nimport { Transaction } from './transaction';\n\n/**\n * The maximum size of a transaction packet in bytes.\n */\nexport const TRANSACTION_PACKET_SIZE = 1280;\n\n/**\n * The size of the transaction packet header in bytes.\n * This includes the IPv6 header and the fragment header.\n */\nexport const TRANSACTION_PACKET_HEADER =\n    40 /* 40 bytes is the size of the IPv6 header. */ + 8; /* 8 bytes is the size of the fragment header. */\n\n/**\n * The maximum size of a transaction in bytes.\n *\n * Note that this excludes the transaction packet header.\n * In other words, this is how much content we can fit in a transaction packet.\n */\nexport const TRANSACTION_SIZE_LIMIT = TRANSACTION_PACKET_SIZE - TRANSACTION_PACKET_HEADER;\n\n/**\n * Gets the size of a given transaction in bytes.\n *\n * @example\n * ```ts\n * const transactionSize = getTransactionSize(transaction);\n * ```\n */\nexport function getTransactionSize(transaction: Transaction): number {\n    return getTransactionEncoder().getSizeFromValue(transaction);\n}\n\n/**\n * A type guard that checks if a transaction is within the size limit.\n */\nexport type TransactionWithinSizeLimit = NominalType<'transactionSize', 'withinLimit'>;\n\n/**\n * Helper type that adds the `TransactionWithinSizeLimit` flag to\n * a transaction if and only if the provided transaction message\n * is also within the size limit.\n */\nexport type SetTransactionWithinSizeLimitFromTransactionMessage<\n    TTransaction extends Transaction,\n    TTransactionMessage extends BaseTransactionMessage,\n> = TTransactionMessage extends TransactionMessageWithinSizeLimit\n    ? TransactionWithinSizeLimit & TTransaction\n    : TTransaction;\n\n/**\n * Checks if a transaction is within the size limit.\n *\n * @typeParam TTransaction - The type of the given transaction.\n *\n * @example\n * ```ts\n * if (isTransactionWithinSizeLimit(transaction)) {\n *    transaction satisfies TransactionWithinSizeLimit;\n * }\n * ```\n */\nexport function isTransactionWithinSizeLimit<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): transaction is TransactionWithinSizeLimit & TTransaction {\n    return getTransactionSize(transaction) <= TRANSACTION_SIZE_LIMIT;\n}\n\n/**\n * Asserts that a given transaction is within the size limit.\n *\n * Throws a {@link SolanaError} of code {@link SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT}\n * if the transaction exceeds the size limit.\n *\n * @typeParam TTransaction - The type of the given transaction.\n *\n * @example\n * ```ts\n * assertIsTransactionWithinSizeLimit(transaction);\n * transaction satisfies TransactionWithinSizeLimit;\n * ```\n */\nexport function assertIsTransactionWithinSizeLimit<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): asserts transaction is TransactionWithinSizeLimit & TTransaction {\n    const transactionSize = getTransactionSize(transaction);\n    if (transactionSize > TRANSACTION_SIZE_LIMIT) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, {\n            transactionSize,\n            transactionSizeLimit: TRANSACTION_SIZE_LIMIT,\n        });\n    }\n}\n","import { assertIsFullySignedTransaction, FullySignedTransaction, isFullySignedTransaction } from './signatures';\nimport { Transaction } from './transaction';\nimport {\n    assertIsTransactionWithinSizeLimit,\n    isTransactionWithinSizeLimit,\n    TransactionWithinSizeLimit,\n} from './transaction-size';\n\n/**\n * Helper type that includes all transaction types required\n * for the transaction to be sent to the network.\n *\n * @see {@link isSendableTransaction}\n * @see {@link assertIsSendableTransaction}\n */\nexport type SendableTransaction = FullySignedTransaction & TransactionWithinSizeLimit;\n\n/**\n * Checks if a transaction has all the required\n * conditions to be sent to the network.\n *\n * @example\n * ```ts\n * import { isSendableTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * if (isSendableTransaction(transaction)) {\n *   // At this point we know that the transaction can be sent to the network.\n * }\n * ```\n *\n * @see {@link assertIsSendableTransaction}\n */\nexport function isSendableTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): transaction is SendableTransaction & TTransaction {\n    return isFullySignedTransaction(transaction) && isTransactionWithinSizeLimit(transaction);\n}\n\n/**\n * Asserts that a given transaction has all the\n * required conditions to be sent to the network.\n *\n * From time to time you might acquire a {@link Transaction}\n * from an untrusted network API or user input and you are not sure\n * that it has all the required conditions to be sent to the network\n * — such as being fully signed and within the size limit.\n * This function can be used to assert that such a transaction\n * is in fact sendable.\n *\n * @example\n * ```ts\n * import { assertIsSendableTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * try {\n *     // If this type assertion function doesn't throw, then Typescript will upcast `transaction`\n *     // to `SendableTransaction`.\n *     assertIsSendableTransaction(transaction);\n *     // At this point we know that the transaction can be sent to the network.\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n * } catch(e) {\n *     if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n *         setError(`Missing signatures for ${e.context.addresses.join(', ')}`);\n *     } else if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT)) {\n *         setError(`Transaction exceeds size limit of ${e.context.transactionSizeLimit} bytes`);\n *     }\n *     throw;\n * }\n * ```\n */\nexport function assertIsSendableTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): asserts transaction is SendableTransaction & TTransaction {\n    assertIsFullySignedTransaction(transaction);\n    assertIsTransactionWithinSizeLimit(transaction);\n}\n","import { SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, SolanaError } from '@solana/errors';\nimport type {\n    BaseTransactionMessage,\n    TransactionMessageWithFeePayer,\n    TransactionMessageWithinSizeLimit,\n} from '@solana/transaction-messages';\n\nimport { compileTransaction } from './compile-transaction';\nimport { getTransactionSize, TRANSACTION_SIZE_LIMIT } from './transaction-size';\n\n/**\n * Gets the compiled transaction size of a given transaction message in bytes.\n *\n * @example\n * ```ts\n * const transactionSize = getTransactionMessageSize(transactionMessage);\n * ```\n */\nexport function getTransactionMessageSize(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer,\n): number {\n    return getTransactionSize(compileTransaction(transactionMessage));\n}\n\n/**\n * Checks if a transaction message is within the size limit\n * when compiled into a transaction.\n *\n * @typeParam TTransactionMessage - The type of the given transaction message.\n *\n * @example\n * ```ts\n * if (isTransactionMessageWithinSizeLimit(transactionMessage)) {\n *    transactionMessage satisfies TransactionMessageWithinSizeLimit;\n * }\n * ```\n */\nexport function isTransactionMessageWithinSizeLimit<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n): transactionMessage is TransactionMessageWithinSizeLimit & TTransactionMessage {\n    return getTransactionMessageSize(transactionMessage) <= TRANSACTION_SIZE_LIMIT;\n}\n\n/**\n * Asserts that a given transaction message is within the size limit\n * when compiled into a transaction.\n *\n * Throws a {@link SolanaError} of code {@link SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT}\n * if the transaction message exceeds the size limit.\n *\n * @typeParam TTransactionMessage - The type of the given transaction message.\n *\n * @example\n * ```ts\n * assertIsTransactionMessageWithinSizeLimit(transactionMessage);\n * transactionMessage satisfies TransactionMessageWithinSizeLimit;\n * ```\n */\nexport function assertIsTransactionMessageWithinSizeLimit<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n): asserts transactionMessage is TransactionMessageWithinSizeLimit & TTransactionMessage {\n    const transactionSize = getTransactionMessageSize(transactionMessage);\n    if (transactionSize > TRANSACTION_SIZE_LIMIT) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, {\n            transactionSize,\n            transactionSizeLimit: TRANSACTION_SIZE_LIMIT,\n        });\n    }\n}\n"],"names":["getBytesEncoder","SolanaError","SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT"],"mappings":"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"}},
    {"offset": {"line": 6190, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/offchain-messages/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/offchain-messages/src/application-domain.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/offchain-messages/src/codecs/application-domain.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/offchain-messages/src/codecs/signing-domain.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/offchain-messages/src/codecs/preamble-common.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/offchain-messages/src/codecs/signatures.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/offchain-messages/src/codecs/envelope.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/offchain-messages/src/content.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/offchain-messages/src/message-v0.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/offchain-messages/src/codecs/content.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/offchain-messages/src/codecs/preamble-v0.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/offchain-messages/src/codecs/message-v0.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/offchain-messages/src/codecs/preamble-v1.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/offchain-messages/src/codecs/message-v1.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/offchain-messages/src/codecs/message.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/offchain-messages/src/envelope-common.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/offchain-messages/src/envelope-v0.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/offchain-messages/src/envelope-v1.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/offchain-messages/src/envelope.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/offchain-messages/src/signatures.ts"],"sourcesContent":["import { assertIsAddress, isAddress } from '@solana/addresses';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\n/**\n * A 32-byte array identifying the application requesting off-chain message signing.\n *\n * This may be any arbitrary bytes. For instance the on-chain address of a program, DAO instance,\n * Candy Machine, et cetera.\n *\n * This field SHOULD be displayed to users as a base58-encoded ASCII string rather than interpreted\n * otherwise.\n */\nexport type OffchainMessageApplicationDomain = Brand<\n    EncodedString<string, 'base58'>,\n    'OffchainMessageApplicationDomain'\n>;\n\n/**\n * A type guard that returns `true` if the input string conforms to the\n * {@link OffchainMessageApplicationDomain} type, and refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isOffchainMessageApplicationDomain, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * if (isOffchainMessageApplicationDomain(applicationDomain)) {\n *     // At this point, `applicationDomain` has been refined to an\n *     // `OffchainMessageApplcationDomain` that can be used to craft a message.\n *     const offchainMessage: OffchainMessageV0 = {\n *         applicationDomain:\n *             offchainMessageApplicationDomain('HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx'),\n *             // ...\n *     };\n * } else {\n *     setError(`${applicationDomain} is not a valid application domain for an offchain message`);\n * }\n * ```\n */\nexport function isOffchainMessageApplicationDomain(\n    putativeApplicationDomain: string,\n): putativeApplicationDomain is OffchainMessageApplicationDomain {\n    return isAddress(putativeApplicationDomain);\n}\n\n/**\n * From time to time you might acquire a string, that you expect to validate as an offchain message\n * application domain, from an untrusted network API or user input. Use this function to assert that\n * such an arbitrary string is a base58-encoded application domain.\n *\n * @example\n * ```ts\n * import { assertIsOffchainMessageApplicationDomain, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * // Imagine a function that determines whether an application domain is valid.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const applicationDomain: string = applicationDomainInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `applicationDomain` to `OffchainMessageApplicationDomain`.\n *         assertIsOffchainMessageApplicationDomain(applicationDomain);\n *         // At this point, `applicationDomain` is a `OffchainMessageApplicationDomain` that can be\n *         // used to craft an offchain message.\n *         const offchainMessage: OffchainMessageV0 = {\n *             applicationDomain:\n *                 offchainMessageApplicationDomain('HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx'),\n *             // ...\n *         };\n *     } catch (e) {\n *         // `applicationDomain` turned out not to be a base58-encoded application domain\n *     }\n * }\n * ```\n */\nexport function assertIsOffchainMessageApplicationDomain(\n    putativeApplicationDomain: string,\n): asserts putativeApplicationDomain is OffchainMessageApplicationDomain {\n    try {\n        assertIsAddress(putativeApplicationDomain);\n    } catch (error) {\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE)) {\n            throw new SolanaError(\n                SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE,\n                error.context,\n            );\n        }\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH)) {\n            throw new SolanaError(\n                SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH,\n                error.context,\n            );\n        }\n        throw error;\n    }\n}\n\n/**\n * Combines _asserting_ that a string is an offchain message application domain with _coercing_ it\n * to the {@link OffchainMessageApplicationDomain} type. It's most useful with untrusted input.\n *\n * @example\n * ```ts\n * import { offchainMessageApplicationDomain, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * const offchainMessage: OffchainMessageV0 = {\n *     applicationDomain:\n *         offchainMessageApplicationDomain('HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx'),\n *     // ...\n * };\n * ```\n *\n * > [!TIP]\n * > When starting from a known-good application domain as a string, it's more efficient to typecast\n * > it rather than to use the {@link offchainMessageApplicationDomain} helper, because the helper\n * > unconditionally performs validation on its input.\n * >\n * > ```ts\n * > import { OffchainMessageApplicationDomain } from '@solana/offchain-messages';\n * >\n * > const applicationDomain =\n * >     'HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx' as OffchainMessageApplicationDomain;\n * > ```\n */\nexport function offchainMessageApplicationDomain(putativeApplicationDomain: string): OffchainMessageApplicationDomain {\n    assertIsOffchainMessageApplicationDomain(putativeApplicationDomain);\n    return putativeApplicationDomain;\n}\n","import { Address, getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformEncoder,\n} from '@solana/codecs-core';\n\nimport { OffchainMessageApplicationDomain, offchainMessageApplicationDomain } from '../application-domain';\n\n/**\n * Returns an encoder that you can use to encode a base58-encoded offchain message application\n * domain to a byte array.\n *\n * @example\n * ```ts\n * import { getOffchainMessageApplicationDomainEncoder } from '@solana/offchain-messages';\n *\n * const offchainMessageApplicationDomain =\n *     'HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx' as OffchainMessageApplicationDomain;\n * const offchainMessageApplicationDomainEncoder = getOffchainMessageApplicationDomainEncoder();\n * const offchainMessageApplicationDomainBytes =\n *     offchainMessageApplicationDomainEncoder.encode(offchainMessageApplicationDomain);\n * // Uint8Array(32) [\n * //   247, 203,  28,  80,  52, 240, 169,  19,\n * //    21, 103, 107, 119,  91, 235,  13,  48,\n * //   194, 169, 148, 160,  78, 105, 235,  37,\n * //   232, 160,  49,  47,  64,  89,  18, 153,\n * // ]\n * ```\n */\nexport function getOffchainMessageApplicationDomainEncoder(): FixedSizeEncoder<OffchainMessageApplicationDomain, 32> {\n    return transformEncoder(\n        getAddressEncoder(),\n        putativeApplicationDomain => offchainMessageApplicationDomain(putativeApplicationDomain) as string as Address,\n    );\n}\n\n/**\n * Returns a decoder that you can use to convert an array of 32 bytes representing an offchain\n * message application domain to the base58-encoded representation of that application domain.\n *\n * @example\n * ```ts\n * import { getOffchainMessageApplicationDomainDecoder } from '@solana/offchain-messages';\n *\n * const offchainMessageApplicationDomainBytes = new Uint8Array([\n *     247, 203,  28,  80,  52, 240, 169,  19,\n *      21, 103, 107, 119,  91, 235,  13,  48,\n *     194, 169, 148, 160,  78, 105, 235,  37,\n *     232, 160,  49,  47,  64,  89,  18, 153,\n * ]);\n * const offchainMessageApplicationDomainDecoder = getOffchainMessageApplicationDomainDecoder();\n * const offchainMessageApplicationDomain =\n *     offchainMessageApplicationDomainDecoder.decode(offchainMessageApplicationDomainBytes);\n *     // HgHLLXT3BVA5m7x66tEp3YNatXLth1hJwVeCva2T9RNx\n * ```\n */\nexport function getOffchainMessageApplicationDomainDecoder(): FixedSizeDecoder<OffchainMessageApplicationDomain, 32> {\n    return getAddressDecoder() as FixedSizeDecoder<string, 32> as FixedSizeDecoder<\n        OffchainMessageApplicationDomain,\n        32\n    >;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a base-58 encoded offchain message\n * application domain.\n *\n * @see {@link getOffchainMessageApplicationDomainDecoder}\n * @see {@link getOffchainMessageApplicationDomainEncoder}\n */\nexport function getOffchainMessageApplicationDomainCodec(): FixedSizeCodec<\n    OffchainMessageApplicationDomain,\n    OffchainMessageApplicationDomain,\n    32\n> {\n    return combineCodec(getOffchainMessageApplicationDomainEncoder(), getOffchainMessageApplicationDomainDecoder());\n}\n","import {\n    combineCodec,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { getConstantDecoder, getConstantEncoder } from '@solana/codecs-data-structures';\n\n// The string `'\\xffsolana offchain'`\nconst OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES: ReadonlyUint8Array = new Uint8Array([\n    0xff, 0x73, 0x6f, 0x6c, 0x61, 0x6e, 0x61, 0x20, 0x6f, 0x66, 0x66, 0x63, 0x68, 0x61, 0x69, 0x6e,\n]);\n\nexport function getOffchainMessageSigningDomainDecoder(): FixedSizeDecoder<void, 16> {\n    return getConstantDecoder(OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES) as FixedSizeDecoder<void, 16>;\n}\n\nexport function getOffchainMessageSigningDomainEncoder(): FixedSizeEncoder<void, 16> {\n    return getConstantEncoder(OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES) as FixedSizeEncoder<void, 16>;\n}\n\nexport function getOffchainMessageSigningDomainCodec(): FixedSizeCodec<void, void, 16> {\n    return combineCodec(getOffchainMessageSigningDomainEncoder(), getOffchainMessageSigningDomainDecoder());\n}\n","import { Address, getAddressDecoder } from '@solana/addresses';\nimport {\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    offsetDecoder,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getBytesDecoder,\n    getHiddenPrefixDecoder,\n    getHiddenPrefixEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED,\n    SolanaError,\n} from '@solana/errors';\n\nimport { OffchainMessageVersion } from '../version';\nimport { getOffchainMessageSigningDomainDecoder, getOffchainMessageSigningDomainEncoder } from './signing-domain';\n\ntype TDecoderFields = Parameters<typeof getStructDecoder>[0];\ntype TEncoderFields = Parameters<typeof getStructEncoder>[0];\n\nfunction getSigningDomainPrefixedDecoder<const T extends TDecoderFields>(...fields: T) {\n    return getHiddenPrefixDecoder(getStructDecoder(fields), [getOffchainMessageSigningDomainDecoder()]);\n}\n\nfunction getSigningDomainPrefixedEncoder<const T extends TEncoderFields>(...fields: T) {\n    return getHiddenPrefixEncoder(getStructEncoder(fields), [getOffchainMessageSigningDomainEncoder()]);\n}\n\nfunction getVersionTransformer(fixedVersion?: OffchainMessageVersion) {\n    return (version: number) => {\n        if (version > 1) {\n            throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {\n                unsupportedVersion: version,\n            });\n        }\n        if (fixedVersion != null && version !== fixedVersion) {\n            throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION, {\n                actualVersion: version,\n                expectedVersion: fixedVersion,\n            });\n        }\n        return version;\n    };\n}\n\nexport function createOffchainMessagePreambleDecoder<\n    const TVersion extends OffchainMessageVersion,\n    const TFields extends TDecoderFields,\n>(version: TVersion, ...fields: TFields) {\n    return getSigningDomainPrefixedDecoder(\n        ['version', transformDecoder(getU8Decoder(), getVersionTransformer(version)) as FixedSizeDecoder<TVersion, 1>],\n        ...fields,\n    );\n}\n\nexport function createOffchainMessagePreambleEncoder<\n    const TVersion extends OffchainMessageVersion,\n    const TFields extends TEncoderFields,\n>(version: TVersion, ...fields: TFields) {\n    return getSigningDomainPrefixedEncoder(\n        ['version', transformEncoder(getU8Encoder(), getVersionTransformer(version)) as FixedSizeEncoder<TVersion, 1>],\n        ...fields,\n    );\n}\n\nexport function decodeRequiredSignatoryAddresses(bytes: ReadonlyUint8Array): readonly Address[] {\n    const { version, bytesAfterVersion } = getSigningDomainPrefixedDecoder(\n        ['version', transformDecoder(getU8Decoder(), getVersionTransformer())],\n        ['bytesAfterVersion', getBytesDecoder()],\n    ).decode(bytes);\n    return offsetDecoder(\n        transformDecoder(getArrayDecoder(getAddressDecoder(), { size: getU8Decoder() }), signatoryAddresses => {\n            if (signatoryAddresses.length === 0) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n            }\n            return signatoryAddresses;\n        }),\n        {\n            preOffset: ({ preOffset }) =>\n                preOffset +\n                (version === 0\n                    ? 32 + 1 // skip the application domain and message format of v0 messages\n                    : 0),\n        },\n    ).decode(bytesAfterVersion);\n}\n\nexport function getSignatoriesComparator(): (a: ReadonlyUint8Array, b: ReadonlyUint8Array) => -1 | 0 | 1 {\n    return (x, y) => {\n        if (x.length !== y.length) {\n            return x.length < y.length ? -1 : 1;\n        }\n        for (let ii = 0; ii < x.length; ii++) {\n            if (x[ii] === y[ii]) {\n                continue;\n            } else {\n                return x[ii] < y[ii] ? -1 : 1;\n            }\n        }\n        return 0;\n    };\n}\n","import { fixEncoderSize, transformEncoder, VariableSizeEncoder } from '@solana/codecs-core';\nimport { getArrayEncoder, getBytesEncoder } from '@solana/codecs-data-structures';\nimport { getU8Encoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { OffchainMessageEnvelope } from '../envelope';\n\nfunction getSignaturesToEncode(signaturesMap: OffchainMessageEnvelope['signatures']): SignatureBytes[] {\n    const signatures = Object.values(signaturesMap);\n    if (signatures.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO);\n    }\n\n    return signatures.map(signature => {\n        if (!signature) {\n            return new Uint8Array(64).fill(0) as SignatureBytes;\n        }\n        return signature;\n    });\n}\n\nexport function getSignaturesEncoder(): VariableSizeEncoder<OffchainMessageEnvelope['signatures']> {\n    return transformEncoder(\n        getArrayEncoder(fixEncoderSize(getBytesEncoder(), 64), { size: getU8Encoder() }),\n        getSignaturesToEncode,\n    );\n}\n","import { Address, address } from '@solana/addresses';\nimport {\n    combineCodec,\n    fixDecoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getU8Decoder } from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { OffchainMessageEnvelope } from '../envelope';\nimport { OffchainMessageBytes } from '../message';\nimport { decodeRequiredSignatoryAddresses } from './preamble-common';\nimport { getSignaturesEncoder } from './signatures';\n\n/**\n * Returns an encoder that you can use to encode an {@link OffchainMessageEnvelope} to a byte array\n * appropriate for sharing with a third party for validation.\n */\nexport function getOffchainMessageEnvelopeEncoder(): VariableSizeEncoder<OffchainMessageEnvelope> {\n    return transformEncoder(\n        getStructEncoder([\n            ['signatures', getSignaturesEncoder()],\n            ['content', getBytesEncoder()],\n        ]),\n        envelope => {\n            const signaturesMapAddresses = Object.keys(envelope.signatures).map(address);\n            if (signaturesMapAddresses.length === 0) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO);\n            }\n            const signatoryAddresses = decodeAndValidateRequiredSignatoryAddresses(envelope.content);\n            const missingRequiredSigners = [];\n            const unexpectedSigners = [];\n            for (const address of signatoryAddresses) {\n                if (!signaturesMapAddresses.includes(address)) {\n                    missingRequiredSigners.push(address);\n                }\n            }\n            for (const address of signaturesMapAddresses) {\n                if (!signatoryAddresses.includes(address)) {\n                    unexpectedSigners.push(address);\n                }\n            }\n            if (missingRequiredSigners.length || unexpectedSigners.length) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH, {\n                    missingRequiredSigners,\n                    unexpectedSigners,\n                });\n            }\n            const orderedSignatureMap: OffchainMessageEnvelope['signatures'] = {};\n            for (const address of signatoryAddresses) {\n                orderedSignatureMap[address] = envelope.signatures[address];\n            }\n            return {\n                ...envelope,\n                signatures: orderedSignatureMap,\n            };\n        },\n    );\n}\n\n/**\n * Returns a decoder that you can use to convert a byte array in the Solana offchain message format\n * to a {@link OffchainMessageEnvelope} object.\n *\n * @example\n * ```ts\n * import { getOffchainMessageEnvelopeDecoder } from '@solana/offchain-messages';\n *\n * const offchainMessageEnvelopeDecoder = getOffchainMessageEnvelopeDecoder();\n * const offchainMessageEnvelope = offchainMessageEnvelopeDecoder.decode(offchainMessageEnvelopeBytes);\n * for (const [address, signature] in Object.entries(offchainMessageEnvelope.signatures)) {\n *     console.log(`Signature by ${address}`, signature);\n * }\n * ```\n */\nexport function getOffchainMessageEnvelopeDecoder(): VariableSizeDecoder<OffchainMessageEnvelope> {\n    return transformDecoder(\n        getStructDecoder([\n            ['signatures', getArrayDecoder(fixDecoderSize(getBytesDecoder(), 64), { size: getU8Decoder() })],\n            ['content', getBytesDecoder()],\n        ]),\n        decodePartiallyDecodedOffchainMessageEnvelope,\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to an {@link OffchainMessageEnvelope}\n *\n * @see {@link getOffchainMessageEnvelopeDecoder}\n * @see {@link getOffchainMessageEnvelopeEncoder}\n */\nexport function getOffchainMessageEnvelopeCodec() {\n    return combineCodec(getOffchainMessageEnvelopeEncoder(), getOffchainMessageEnvelopeDecoder());\n}\n\ntype PartiallyDecodedOffchainMessageEnvelope = {\n    content: ReadonlyUint8Array;\n    signatures: ReadonlyUint8Array[];\n};\n\nfunction decodePartiallyDecodedOffchainMessageEnvelope(\n    offchainMessageEnvelope: PartiallyDecodedOffchainMessageEnvelope,\n): OffchainMessageEnvelope {\n    const { content, signatures } = offchainMessageEnvelope;\n\n    if (signatures.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO);\n    }\n\n    const signatoryAddresses = decodeAndValidateRequiredSignatoryAddresses(content);\n\n    // Signer addresses and signatures must be the same length\n    // We encode an all-zero signature when the signature is missing\n    if (signatoryAddresses.length !== signatures.length) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH, {\n            numRequiredSignatures: signatoryAddresses.length,\n            signatoryAddresses,\n            signaturesLength: signatures.length,\n        });\n    }\n\n    // Combine the signer addresses + signatures into the signatures map\n    const signaturesMap: OffchainMessageEnvelope['signatures'] = {};\n    signatoryAddresses.forEach((address, index) => {\n        const signatureForAddress = signatures[index];\n        if (signatureForAddress.every(b => b === 0)) {\n            signaturesMap[address] = null;\n        } else {\n            signaturesMap[address] = signatureForAddress as SignatureBytes;\n        }\n    });\n\n    return Object.freeze({\n        content: content as OffchainMessageBytes,\n        signatures: Object.freeze(signaturesMap),\n    });\n}\n\nfunction decodeAndValidateRequiredSignatoryAddresses(bytes: ReadonlyUint8Array): readonly Address[] {\n    const signatoryAddresses = decodeRequiredSignatoryAddresses(bytes);\n\n    if (signatoryAddresses.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n    }\n\n    return signatoryAddresses;\n}\n","import { getUtf8Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\nconst MAX_BODY_BYTES =\n    // Largest 16-bit unsigned integer\n    0xffff;\nconst MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE =\n    // Space remaining in the mininum IPv6 MTU after network header overhead\n    1232;\n\n/**\n * A restriction on what characters the message text can contain and how long it can be.\n *\n * The aim of this restriction is to make a message more likely to be signable by a hardware wallet\n * that imposes limits on message size. In the case of wanting a message to be clear-signable,\n * restricting the character set to ASCII may ensure that certain models of hardware wallet without\n * extended character sets can display it onscreen.\n *\n * @remarks This only applies to v0 messages.\n */\nexport enum OffchainMessageContentFormat {\n    RESTRICTED_ASCII_1232_BYTES_MAX = 0,\n    UTF8_1232_BYTES_MAX = 1,\n    UTF8_65535_BYTES_MAX = 2,\n}\n\n/**\n * Describes message text that is no more than 1232 bytes long and made up of characters with ASCII\n * character codes in the range [0x20, 0x7e].\n *\n * @remarks This type aims to restrict text to that which can be clear-signed by hardware wallets\n * that can only display ASCII characters onscreen.\n */\nexport type OffchainMessageContentRestrictedAsciiOf1232BytesMax<TContent extends string = string> = Readonly<{\n    format: OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX;\n    text: Brand<TContent, 'offchainMessageContentRestrictedAsciiOf1232BytesMax'>;\n}>;\n\n/**\n * Describes message text that is no more than 1232 bytes long and mdae up of any UTF-8 characters.\n */\nexport type OffchainMessageContentUtf8Of1232BytesMax<TContent extends string = string> = Readonly<{\n    format: OffchainMessageContentFormat.UTF8_1232_BYTES_MAX;\n    text: Brand<TContent, 'offchainMessageContentUtf8Of1232BytesMax'>;\n}>;\n\n/**\n * Describes message text that is no more than 65535 bytes long and mdae up of any UTF-8 characters.\n */\nexport type OffchainMessageContentUtf8Of65535BytesMax<TContent extends string = string> = Readonly<{\n    format: OffchainMessageContentFormat.UTF8_65535_BYTES_MAX;\n    text: Brand<TContent, 'offchainMessageContentUtf8Of65535BytesMax'>;\n}>;\n\nexport type OffchainMessageContent =\n    | OffchainMessageContentRestrictedAsciiOf1232BytesMax\n    | OffchainMessageContentUtf8Of1232BytesMax\n    | OffchainMessageContentUtf8Of65535BytesMax;\n\n/**\n * In the event that you receive content of a v0 offchain message from an untrusted source, use this\n * function to assert that it conforms to the\n * {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} type.\n *\n * @see {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): asserts putativeContent is OffchainMessageContentRestrictedAsciiOf1232BytesMax {\n    if (putativeContent.format !== OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH, {\n            actualMessageFormat: putativeContent.format,\n            expectedMessageFormat: OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX,\n        });\n    }\n    if (putativeContent.text.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n    }\n    if (isTextRestrictedAscii(putativeContent.text) === false) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE);\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    if (length > MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED, {\n            actualBytes: length,\n            maxBytes: MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE,\n        });\n    }\n}\n\n/**\n * A type guard that returns `true` when supplied content of a v0 offchain message that conforms to\n * the {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} type, and refines its type for use in your\n * program.\n *\n * @see {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} for more detail.\n */\nexport function isOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): putativeContent is OffchainMessageContentRestrictedAsciiOf1232BytesMax {\n    if (\n        putativeContent.format !== OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX ||\n        putativeContent.text.length === 0 ||\n        isTextRestrictedAscii(putativeContent.text) === false\n    ) {\n        return false;\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    return length <= MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE;\n}\n\n/**\n * Combines _asserting_ that the content of a v0 offchain message is restricted ASCII with\n * _coercing_ it to the {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} type. It's most\n * useful with untrusted input.\n *\n * @example\n * ```ts\n * import { offchainMessageContentRestrictedAsciiOf1232BytesMax, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const text: string = textInput.value;\n *     try {\n *         const offchainMessage: OffchainMessageV0 = {\n *             content: offchainMessageContentRestrictedAsciiOf1232BytesMax(text),\n *             // ...\n *         };\n *     } catch (e) {\n *         // `text` turned out not to conform to\n *         // `OffchainMessageContentRestrictedAsciiOf1232BytesMax`\n *     }\n * }\n * ```\n *\n * > [!TIP]\n * > When starting from known-good ASCII content as a string, it's more efficient to typecast it\n * > rather than to use the {@link offchainMessageContentRestrictedAsciiOf1232BytesMax} helper,\n * > because the helper unconditionally performs validation on its input.\n * >\n * > ```ts\n * > import { OffchainMessageContentFormat, OffchainMessageV0 } from '@solana/offchain-messages';\n * >\n * > const offchainMessage: OffchainMessageV0 = {\n * >     /* ... *\\/\n * >     content: Object.freeze({\n * >         format: OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX,\n * >         text: 'Hello world',\n * >     } as OffchainMessageContentRestrictedAsciiOf1232BytesMax<'Hello world'>),\n * > };\n * > ```\n */\nexport function offchainMessageContentRestrictedAsciiOf1232BytesMax<TText extends string>(\n    text: TText,\n): OffchainMessageContentRestrictedAsciiOf1232BytesMax<TText> {\n    const putativeContent = Object.freeze({\n        format: OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX,\n        text,\n    });\n    assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeContent);\n    return putativeContent;\n}\n\n/**\n * In the event that you receive content of a v0 offchain message from an untrusted source, use this\n * function to assert that it conforms to the {@link OffchainMessageContentUtf8Of1232BytesMax} type.\n *\n * @see {@link OffchainMessageContentUtf8Of1232BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageContentUtf8Of1232BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): asserts putativeContent is OffchainMessageContentUtf8Of1232BytesMax {\n    if (putativeContent.text.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n    }\n    if (putativeContent.format !== OffchainMessageContentFormat.UTF8_1232_BYTES_MAX) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH, {\n            actualMessageFormat: putativeContent.format,\n            expectedMessageFormat: OffchainMessageContentFormat.UTF8_1232_BYTES_MAX,\n        });\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    if (length > MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED, {\n            actualBytes: length,\n            maxBytes: MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE,\n        });\n    }\n}\n\n/**\n * A type guard that returns `true` when supplied content of a v0 offchain message that conforms to\n * the {@link OffchainMessageContentUtf8Of1232BytesMax} type, and refines its type for use in your\n * program.\n *\n * @see {@link OffchainMessageContentUtf8Of1232BytesMax} for more detail.\n */\nexport function isOffchainMessageContentUtf8Of1232BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): putativeContent is OffchainMessageContentUtf8Of1232BytesMax {\n    if (\n        putativeContent.format !== OffchainMessageContentFormat.UTF8_1232_BYTES_MAX ||\n        putativeContent.text.length === 0\n    ) {\n        return false;\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    return length <= MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE;\n}\n\n/**\n * Combines _asserting_ that the content of a v0 offchain message is UTF-8 of up to 1232 characters\n * with _coercing_ it to the {@link OffchainMessageContentUtf8Of1232BytesMax} type. It's most useful\n * with untrusted input.\n *\n * @example\n * ```ts\n * import { OffchainMessageContentUtf8Of1232BytesMax, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const text: string = textInput.value;\n *     try {\n *         const offchainMessage: OffchainMessageV0 = {\n *             content: OffchainMessageContentUtf8Of1232BytesMax(text),\n *             // ...\n *         };\n *     } catch (e) {\n *         // `text` turned out not to conform to\n *         // `OffchainMessageContentUtf8Of1232BytesMax`\n *     }\n * }\n * ```\n *\n * > [!TIP]\n * > When starting from known-good UTF-8 content as a string up to 1232 bytes, it's more efficient\n * > to typecast it rather than to use the {@link offchainMessageContentUtf8Of1232BytesMax} helper,\n * > because the helper unconditionally performs validation on its input.\n * >\n * > ```ts\n * > import { OffchainMessageContentFormat, OffchainMessageV0 } from '@solana/offchain-messages';\n * >\n * > const offchainMessage: OffchainMessageV0 = {\n * >     /* ... *\\/\n * >     content: Object.freeze({\n * >         format: OffchainMessageContentFormat.UTF8_1232_BYTES_MAX,\n * >         text: '✌🏿cool',\n * >     } as OffchainMessageContentUtf8Of1232BytesMax<'✌🏿cool'>),\n * > };\n * > ```\n */\nexport function offchainMessageContentUtf8Of1232BytesMax<TText extends string>(\n    text: TText,\n): OffchainMessageContentUtf8Of1232BytesMax<TText> {\n    const putativeContent = Object.freeze({\n        format: OffchainMessageContentFormat.UTF8_1232_BYTES_MAX,\n        text,\n    });\n    assertIsOffchainMessageContentUtf8Of1232BytesMax(putativeContent);\n    return putativeContent;\n}\n\n/**\n * In the event that you receive content of a v0 offchain message from an untrusted source, use this\n * function to assert that it conforms to the {@link OffchainMessageContentUtf8Of65535BytesMax}\n * type.\n *\n * @see {@link OffchainMessageContentUtf8Of65535BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageContentUtf8Of65535BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): asserts putativeContent is OffchainMessageContentUtf8Of65535BytesMax {\n    if (putativeContent.format !== OffchainMessageContentFormat.UTF8_65535_BYTES_MAX) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH, {\n            actualMessageFormat: putativeContent.format,\n            expectedMessageFormat: OffchainMessageContentFormat.UTF8_65535_BYTES_MAX,\n        });\n    }\n    if (putativeContent.text.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    if (length > MAX_BODY_BYTES) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED, {\n            actualBytes: length,\n            maxBytes: MAX_BODY_BYTES,\n        });\n    }\n}\n\n/**\n * A type guard that returns `true` when supplied content of a v0 offchain message that conforms to\n * the {@link OffchainMessageContentUtf8Of65535BytesMax} type, and refines its type for use in your\n * program.\n *\n * @see {@link OffchainMessageContentUtf8Of65535BytesMax} for more detail.\n */\nexport function isOffchainMessageContentUtf8Of65535BytesMax(putativeContent: {\n    format: OffchainMessageContentFormat;\n    text: string;\n}): putativeContent is OffchainMessageContentUtf8Of65535BytesMax {\n    if (\n        putativeContent.format !== OffchainMessageContentFormat.UTF8_65535_BYTES_MAX ||\n        putativeContent.text.length === 0\n    ) {\n        return false;\n    }\n    const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);\n    return length <= MAX_BODY_BYTES;\n}\n\n/**\n * Combines _asserting_ that the content of a v0 offchain message is UTF-8 of up to 65535 characters\n * with _coercing_ it to the {@link OffchainMessageContentUtf8Of65535BytesMax} type. It's most useful\n * with untrusted input.\n *\n * @example\n * ```ts\n * import { OffchainMessageContentUtf8Of65535BytesMax, OffchainMessageV0 } from '@solana/offchain-messages';\n *\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const text: string = textInput.value;\n *     try {\n *         const offchainMessage: OffchainMessageV0 = {\n *             content: OffchainMessageContentUtf8Of65535BytesMax(text),\n *             // ...\n *         };\n *     } catch (e) {\n *         // `text` turned out not to conform to\n *         // `OffchainMessageContentUtf8Of65535BytesMax`\n *     }\n * }\n * ```\n *\n * > [!TIP]\n * > When starting from known-good UTF-8 content as a string up to 65535 bytes, it's more efficient\n * > to typecast it rather than to use the {@link OffchainMessageContentUtf8Of65535BytesMax} helper,\n * > because the helper unconditionally performs validation on its input.\n * >\n * > ```ts\n * > import { OffchainMessageContentFormat, OffchainMessageV0 } from '@solana/offchain-messages';\n * >\n * > const offchainMessage: OffchainMessageV0 = {\n * >     /* ... *\\/\n * >     content: Object.freeze({\n * >         format: OffchainMessageContentFormat.UTF8_65535_BYTES_MAX,\n * >         text: '✌🏿cool',\n * >     } as OffchainMessageContentUtf8Of65535BytesMax<'✌🏿cool'>),\n * > };\n * > ```\n */\nexport function offchainMessageContentUtf8Of65535BytesMax<TText extends string>(\n    text: TText,\n): OffchainMessageContentUtf8Of65535BytesMax<TText> {\n    const putativeContent = Object.freeze({\n        format: OffchainMessageContentFormat.UTF8_65535_BYTES_MAX,\n        text,\n    });\n    assertIsOffchainMessageContentUtf8Of65535BytesMax(putativeContent);\n    return putativeContent;\n}\n\nfunction isTextRestrictedAscii(putativeRestrictedAsciiString: string): boolean {\n    return /^[\\x20-\\x7e]+$/.test(putativeRestrictedAsciiString);\n}\n","import {\n    assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax,\n    assertIsOffchainMessageContentUtf8Of1232BytesMax,\n    assertIsOffchainMessageContentUtf8Of65535BytesMax,\n    OffchainMessageContentFormat,\n    OffchainMessageContentRestrictedAsciiOf1232BytesMax,\n    OffchainMessageContentUtf8Of1232BytesMax,\n    OffchainMessageContentUtf8Of65535BytesMax,\n} from './content';\nimport { OffchainMessagePreambleV0 } from './preamble-v0';\nimport { OffchainMessageWithRequiredSignatories } from './signatures';\n\nexport type BaseOffchainMessageV0 = Omit<\n    OffchainMessagePreambleV0,\n    'messageFormat' | 'messageLength' | 'requiredSignatories'\n>;\n\n/**\n * An offchain message whose content conforms to\n * {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax}\n */\nexport interface OffchainMessageWithRestrictedAsciiOf1232BytesMaxContent {\n    readonly content: OffchainMessageContentRestrictedAsciiOf1232BytesMax;\n}\n\n/**\n * An offchain message whose content conforms to\n * {@link offchainMessageContentUtf8Of1232BytesMax}\n */\nexport interface OffchainMessageWithUtf8Of1232BytesMaxContent {\n    readonly content: OffchainMessageContentUtf8Of1232BytesMax;\n}\n\n/**\n * An offchain message whose content conforms to\n * {@link OffchainMessageContentUtf8Of65535BytesMax}\n */\nexport interface OffchainMessageWithUtf8Of65535BytesMaxContent {\n    readonly content: OffchainMessageContentUtf8Of65535BytesMax;\n}\n\n/**\n * A union of the formats a v0 message's contents can take.\n *\n * @remarks From v1 and onward, an offchain message has only one format: UTF-8 text of arbitrary\n * length.\n */\nexport type OffchainMessageWithContent =\n    | OffchainMessageWithRestrictedAsciiOf1232BytesMaxContent\n    | OffchainMessageWithUtf8Of1232BytesMaxContent\n    | OffchainMessageWithUtf8Of65535BytesMaxContent;\n\nexport type OffchainMessageV0 = BaseOffchainMessageV0 &\n    OffchainMessageWithContent &\n    OffchainMessageWithRequiredSignatories;\n\n/**\n * In the event that you receive a v0 offchain message from an untrusted source, use this function\n * to assert that it is one whose content conforms to the\n * {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} type.\n *\n * @see {@link OffchainMessageContentRestrictedAsciiOf1232BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageRestrictedAsciiOf1232BytesMax<TMessage extends OffchainMessageV0>(\n    putativeMessage: Omit<TMessage, 'content'> &\n        Readonly<{\n            content: {\n                format: OffchainMessageContentFormat;\n                text: string;\n            };\n        }>,\n): asserts putativeMessage is OffchainMessageWithRestrictedAsciiOf1232BytesMaxContent & Omit<TMessage, 'content'> {\n    assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeMessage.content);\n}\n\n/**\n * In the event that you receive a v0 offchain message from an untrusted source, use this function\n * to assert that it is one whose content conforms to the\n * {@link offchainMessageContentUtf8Of1232BytesMax} type.\n *\n * @see {@link offchainMessageContentUtf8Of1232BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageUtf8Of1232BytesMax<TMessage extends OffchainMessageV0>(\n    putativeMessage: Omit<TMessage, 'content'> &\n        Readonly<{\n            content: {\n                format: OffchainMessageContentFormat;\n                text: string;\n            };\n            version: number;\n        }>,\n): asserts putativeMessage is OffchainMessageWithUtf8Of1232BytesMaxContent & Omit<TMessage, 'content'> {\n    assertIsOffchainMessageContentUtf8Of1232BytesMax(putativeMessage.content);\n}\n\n/**\n * In the event that you receive a v0 offchain message from an untrusted source, use this function\n * to assert that it is one whose content conforms to the\n * {@link OffchainMessageContentUtf8Of65535BytesMax} type.\n *\n * @see {@link OffchainMessageContentUtf8Of65535BytesMax} for more detail.\n */\nexport function assertIsOffchainMessageUtf8Of65535BytesMax<TMessage extends OffchainMessageV0>(\n    putativeMessage: Omit<TMessage, 'content'> &\n        Readonly<{\n            content: {\n                format: OffchainMessageContentFormat;\n                text: string;\n            };\n            version: number;\n        }>,\n): asserts putativeMessage is OffchainMessageWithUtf8Of65535BytesMaxContent & Omit<TMessage, 'content'> {\n    assertIsOffchainMessageContentUtf8Of65535BytesMax(putativeMessage.content);\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport { getEnumDecoder, getEnumEncoder } from '@solana/codecs-data-structures';\n\nimport { OffchainMessageContentFormat } from '../content';\n\nexport function getOffchainMessageContentFormatDecoder(): FixedSizeDecoder<OffchainMessageContentFormat, 1> {\n    return getEnumDecoder(OffchainMessageContentFormat, {\n        useValuesAsDiscriminators: true,\n    });\n}\n\nexport function getOffchainMessageContentFormatEncoder(): FixedSizeEncoder<OffchainMessageContentFormat, 1> {\n    return getEnumEncoder(OffchainMessageContentFormat, {\n        useValuesAsDiscriminators: true,\n    });\n}\n\nexport function getOffchainMessageContentFormatCodec(): FixedSizeCodec<\n    OffchainMessageContentFormat,\n    OffchainMessageContentFormat,\n    1\n> {\n    return combineCodec(getOffchainMessageContentFormatEncoder(), getOffchainMessageContentFormatDecoder());\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder } from '@solana/codecs-data-structures';\nimport { getU8Decoder, getU8Encoder, getU16Decoder, getU16Encoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO, SolanaError } from '@solana/errors';\n\nimport { OffchainMessagePreambleV0 } from '../preamble-v0';\nimport {\n    getOffchainMessageApplicationDomainDecoder,\n    getOffchainMessageApplicationDomainEncoder,\n} from './application-domain';\nimport { getOffchainMessageContentFormatDecoder, getOffchainMessageContentFormatEncoder } from './content';\nimport { createOffchainMessagePreambleDecoder, createOffchainMessagePreambleEncoder } from './preamble-common';\n\nexport function getOffchainMessageV0PreambleDecoder(): VariableSizeDecoder<OffchainMessagePreambleV0> {\n    return createOffchainMessagePreambleDecoder(\n        /* version */ 0,\n        ['applicationDomain', getOffchainMessageApplicationDomainDecoder()],\n        ['messageFormat', getOffchainMessageContentFormatDecoder()],\n        [\n            'requiredSignatories',\n            transformDecoder(getArrayDecoder(getAddressDecoder(), { size: getU8Decoder() }), signatoryAddresses => {\n                if (signatoryAddresses.length === 0) {\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n                }\n                return signatoryAddresses.map(address => Object.freeze({ address }));\n            }),\n        ],\n        ['messageLength', getU16Decoder()],\n    );\n}\n\nexport function getOffchainMessageV0PreambleEncoder(): VariableSizeEncoder<OffchainMessagePreambleV0> {\n    return createOffchainMessagePreambleEncoder(\n        /* version */ 0,\n        ['applicationDomain', getOffchainMessageApplicationDomainEncoder()],\n        ['messageFormat', getOffchainMessageContentFormatEncoder()],\n        [\n            'requiredSignatories',\n            transformEncoder(\n                getArrayEncoder(getAddressEncoder(), { size: getU8Encoder() }),\n                (signatoryAddresses: OffchainMessagePreambleV0['requiredSignatories']) => {\n                    if (signatoryAddresses.length === 0) {\n                        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n                    }\n                    return signatoryAddresses.map(({ address }) => address);\n                },\n            ),\n        ],\n        ['messageLength', getU16Encoder()],\n    );\n}\n\nexport function getOffchainMessageV0PreambleCodec(): VariableSizeCodec<OffchainMessagePreambleV0> {\n    return combineCodec(getOffchainMessageV0PreambleEncoder(), getOffchainMessageV0PreambleDecoder());\n}\n","import {\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getTupleDecoder, getTupleEncoder } from '@solana/codecs-data-structures';\nimport { getUtf8Decoder, getUtf8Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { OffchainMessageContentFormat } from '../content';\nimport {\n    assertIsOffchainMessageRestrictedAsciiOf1232BytesMax,\n    assertIsOffchainMessageUtf8Of1232BytesMax,\n    assertIsOffchainMessageUtf8Of65535BytesMax,\n    OffchainMessageV0,\n} from '../message-v0';\nimport { getOffchainMessageV0PreambleDecoder, getOffchainMessageV0PreambleEncoder } from './preamble-v0';\n\n/**\n * Returns a decoder that you can use to convert a byte array (eg. one that conforms to the\n * {@link OffchainMessageBytes} type) to an {@link OffchainMessageV0} object.\n *\n * @example\n * ```ts\n * import { getOffchainMessageV0Decoder } from '@solana/offchain-messages';\n *\n * const offchainMessageDecoder = getOffchainMessageV0Decoder();\n * const offchainMessage = offchainMessageDecoder.decode(\n *     offchainMessageEnvelope.content,\n * );\n * console.log(`Decoded a v0 offchain message`);\n * ```\n *\n * Throws in the event that the message bytes represent a message of a version other than 0.\n */\nexport function getOffchainMessageV0Decoder(): VariableSizeDecoder<OffchainMessageV0> {\n    return transformDecoder(\n        getTupleDecoder([getOffchainMessageV0PreambleDecoder(), getUtf8Decoder()]),\n        ([{ messageLength, messageFormat, requiredSignatories, ...preambleRest }, text]) => {\n            const actualLength = getUtf8Encoder().getSizeFromValue(text);\n            if (messageLength !== actualLength) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH, {\n                    actualLength: actualLength,\n                    specifiedLength: messageLength,\n                });\n            }\n            const offchainMessage: Omit<OffchainMessageV0, 'content'> &\n                Readonly<{\n                    content: {\n                        format: OffchainMessageContentFormat;\n                        text: string;\n                    };\n                }> = Object.freeze({\n                ...preambleRest,\n                content: Object.freeze({\n                    format: messageFormat,\n                    text,\n                }),\n                requiredSignatories: Object.freeze(requiredSignatories),\n            });\n            switch (messageFormat) {\n                case OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX: {\n                    assertIsOffchainMessageRestrictedAsciiOf1232BytesMax(offchainMessage);\n                    return offchainMessage;\n                }\n                case OffchainMessageContentFormat.UTF8_1232_BYTES_MAX: {\n                    assertIsOffchainMessageUtf8Of1232BytesMax(offchainMessage);\n                    return offchainMessage;\n                }\n                case OffchainMessageContentFormat.UTF8_65535_BYTES_MAX: {\n                    assertIsOffchainMessageUtf8Of65535BytesMax(offchainMessage);\n                    return offchainMessage;\n                }\n                default: {\n                    throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                        unexpectedValue: messageFormat satisfies never,\n                    });\n                }\n            }\n        },\n    );\n}\n\n/**\n * Returns an encoder that you can use to encode an {@link OffchainMessageV0} to a byte array\n * appropriate for inclusion in an {@link OffchainMessageEnvelope}.\n */\nexport function getOffchainMessageV0Encoder(): VariableSizeEncoder<OffchainMessageV0> {\n    return transformEncoder(\n        getTupleEncoder([getOffchainMessageV0PreambleEncoder(), getUtf8Encoder()]),\n        offchainMessage => {\n            const { content, ...preamble } = offchainMessage;\n            switch (offchainMessage.content.format) {\n                case OffchainMessageContentFormat.RESTRICTED_ASCII_1232_BYTES_MAX: {\n                    assertIsOffchainMessageRestrictedAsciiOf1232BytesMax(offchainMessage);\n                    break;\n                }\n                case OffchainMessageContentFormat.UTF8_1232_BYTES_MAX: {\n                    assertIsOffchainMessageUtf8Of1232BytesMax(offchainMessage);\n                    break;\n                }\n                case OffchainMessageContentFormat.UTF8_65535_BYTES_MAX: {\n                    assertIsOffchainMessageUtf8Of65535BytesMax(offchainMessage);\n                    break;\n                }\n                default: {\n                    throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                        unexpectedValue: offchainMessage.content satisfies never,\n                    });\n                }\n            }\n            const messageLength = getUtf8Encoder().getSizeFromValue(content.text);\n            const compiledPreamble = {\n                ...preamble,\n                messageFormat: content.format,\n                messageLength,\n            };\n            return [compiledPreamble, content.text] as const;\n        },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to an {@link OffchainMessageV0}\n *\n * @see {@link getOffchainMessageV0Decoder}\n * @see {@link getOffchainMessageV0Encoder}\n */\nexport function getOffchainMessageV0Codec(): VariableSizeCodec<OffchainMessageV0> {\n    return combineCodec(getOffchainMessageV0Encoder(), getOffchainMessageV0Decoder());\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    fixDecoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getBytesDecoder, getBytesEncoder } from '@solana/codecs-data-structures';\nimport { getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { OffchainMessagePreambleV1 } from '../preamble-v1';\nimport {\n    createOffchainMessagePreambleDecoder,\n    createOffchainMessagePreambleEncoder,\n    getSignatoriesComparator,\n} from './preamble-common';\n\nexport function getOffchainMessageV1PreambleDecoder(): VariableSizeDecoder<OffchainMessagePreambleV1> {\n    return createOffchainMessagePreambleDecoder(/* version */ 1, [\n        'requiredSignatories',\n        transformDecoder(\n            getArrayDecoder(fixDecoderSize(getBytesDecoder(), 32), { size: getU8Decoder() }),\n            signatoryAddressesBytes => {\n                if (signatoryAddressesBytes.length === 0) {\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n                }\n                const comparator = getSignatoriesComparator();\n                for (let ii = 0; ii < signatoryAddressesBytes.length - 1; ii++) {\n                    switch (comparator(signatoryAddressesBytes[ii], signatoryAddressesBytes[ii + 1])) {\n                        case 0:\n                            throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE);\n                        case 1:\n                            throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED);\n                    }\n                }\n                const addressDecoder = getAddressDecoder();\n                return signatoryAddressesBytes.map(addressBytes =>\n                    Object.freeze({\n                        address: addressDecoder.decode(addressBytes),\n                    }),\n                );\n            },\n        ),\n    ]);\n}\n\nexport function getOffchainMessageV1PreambleEncoder(): VariableSizeEncoder<OffchainMessagePreambleV1> {\n    return createOffchainMessagePreambleEncoder(/* version */ 1, [\n        'requiredSignatories',\n        transformEncoder(\n            transformEncoder(\n                getArrayEncoder(getBytesEncoder(), { size: getU8Encoder() }),\n                (signatoryAddressesBytes: readonly ReadonlyUint8Array[]) => {\n                    return signatoryAddressesBytes.toSorted(getSignatoriesComparator());\n                },\n            ),\n            (signatoryAddresses: OffchainMessagePreambleV1['requiredSignatories']) => {\n                if (signatoryAddresses.length === 0) {\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n                }\n                const seenSignatories = new Set();\n                for (const { address } of signatoryAddresses) {\n                    if (seenSignatories.has(address)) {\n                        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE);\n                    }\n                    seenSignatories.add(address);\n                }\n                const addressEncoder = getAddressEncoder();\n                return signatoryAddresses.map(({ address }) => addressEncoder.encode(address));\n            },\n        ),\n    ]);\n}\n\nexport function getOffchainMessageV1PreambleCodec(): VariableSizeCodec<OffchainMessagePreambleV1> {\n    return combineCodec(getOffchainMessageV1PreambleEncoder(), getOffchainMessageV1PreambleDecoder());\n}\n","import {\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getTupleDecoder, getTupleEncoder } from '@solana/codecs-data-structures';\nimport { getUtf8Decoder, getUtf8Encoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY, SolanaError } from '@solana/errors';\n\nimport { OffchainMessageV1 } from '../message-v1';\nimport { getOffchainMessageV1PreambleDecoder, getOffchainMessageV1PreambleEncoder } from './preamble-v1';\n\n/**\n * Returns a decoder that you can use to convert a byte array (eg. one that conforms to the\n * {@link OffchainMessageBytes} type) to an {@link OffchainMessageV1} object.\n *\n * @example\n * ```ts\n * import { getOffchainMessageV1Decoder } from '@solana/offchain-messages';\n *\n * const offchainMessageDecoder = getOffchainMessageV1Decoder();\n * const offchainMessage = offchainMessageDecoder.decode(\n *     offchainMessageEnvelope.content,\n * );\n * console.log(`Decoded a v1 offchain message`);\n * ```\n *\n * Throws in the event that the message bytes represent a message of a version other than 1.\n */\nexport function getOffchainMessageV1Decoder(): VariableSizeDecoder<OffchainMessageV1> {\n    return transformDecoder(\n        getTupleDecoder([getOffchainMessageV1PreambleDecoder(), getUtf8Decoder()]),\n        ([{ requiredSignatories, ...preambleRest }, text]) => {\n            if (text.length === 0) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n            }\n            return Object.freeze({\n                ...preambleRest,\n                content: text,\n                requiredSignatories: Object.freeze(requiredSignatories),\n            });\n        },\n    );\n}\n\n/**\n * Returns an encoder that you can use to encode an {@link OffchainMessageV1} to a byte array\n * appropriate for inclusion in an {@link OffchainMessageEnvelope}.\n */\nexport function getOffchainMessageV1Encoder(): VariableSizeEncoder<OffchainMessageV1> {\n    return transformEncoder(\n        getTupleEncoder([getOffchainMessageV1PreambleEncoder(), getUtf8Encoder()]),\n        offchainMessage => {\n            const { content, ...compiledPreamble } = offchainMessage;\n            if (content.length === 0) {\n                throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n            }\n            return [compiledPreamble, content] as const;\n        },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to an {@link OffchainMessageV1}\n *\n * @see {@link getOffchainMessageV1Decoder}\n * @see {@link getOffchainMessageV1Encoder}\n */\nexport function getOffchainMessageV1Codec(): VariableSizeCodec<OffchainMessageV1> {\n    return combineCodec(getOffchainMessageV1Encoder(), getOffchainMessageV1Decoder());\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getHiddenPrefixDecoder } from '@solana/codecs-data-structures';\nimport { getU8Decoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, SolanaError } from '@solana/errors';\n\nimport { OffchainMessage } from '../message';\nimport { getOffchainMessageV0Decoder, getOffchainMessageV0Encoder } from './message-v0';\nimport { getOffchainMessageV1Decoder, getOffchainMessageV1Encoder } from './message-v1';\nimport { getOffchainMessageSigningDomainDecoder } from './signing-domain';\n\n/**\n * Returns a decoder that you can use to convert a byte array (eg. one that conforms to the\n * {@link OffchainMessageBytes} type) to an {@link OffchainMessage} object.\n *\n * @example\n * ```ts\n * import { getOffchainMessageDecoder } from '@solana/offchain-messages';\n *\n * const offchainMessageDecoder = getOffchainMessageDecoder();\n * const offchainMessage = offchainMessageDecoder.decode(\n *     offchainMessageEnvelope.content,\n * );\n * console.log(`Decoded an offchain message (version: ${offchainMessage.version}`);\n * ```\n *\n * @remarks\n * If the offchain message version is known ahead of time, use one of the decoders specific to that\n * version so as not to bundle more code than you need.\n */\nexport function getOffchainMessageDecoder(): VariableSizeDecoder<OffchainMessage> {\n    return createDecoder({\n        read(bytes, offset): [OffchainMessage, number] {\n            const version = getHiddenPrefixDecoder(getU8Decoder(), [\n                // Discard the signing domain\n                getOffchainMessageSigningDomainDecoder(),\n            ]).decode(bytes, offset);\n            switch (version) {\n                case 0:\n                    return getOffchainMessageV0Decoder().read(bytes, offset);\n                case 1:\n                    return getOffchainMessageV1Decoder().read(bytes, offset);\n                default:\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version,\n                    });\n            }\n        },\n    });\n}\n\n/**\n * Returns an encoder that you can use to encode an {@link OffchainMessage} to a byte array\n * appropriate for inclusion in an {@link OffchainMessageEnvelope}.\n *\n * @remarks\n * If the offchain message version is known ahead of time, use one of the encoders specific to that\n * version so as not to bundle more code than you need.\n */\nexport function getOffchainMessageEncoder(): VariableSizeEncoder<OffchainMessage> {\n    return createEncoder({\n        getSizeFromValue: offchainMessage => {\n            const { version } = offchainMessage;\n            switch (version) {\n                case 0:\n                    return getOffchainMessageV0Encoder().getSizeFromValue(offchainMessage);\n                case 1:\n                    return getOffchainMessageV1Encoder().getSizeFromValue(offchainMessage);\n                default:\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version satisfies never,\n                    });\n            }\n        },\n        write: (offchainMessage, bytes, offset) => {\n            const { version } = offchainMessage;\n            switch (version) {\n                case 0:\n                    return getOffchainMessageV0Encoder().write(offchainMessage, bytes, offset);\n                case 1:\n                    return getOffchainMessageV1Encoder().write(offchainMessage, bytes, offset);\n                default:\n                    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version satisfies never,\n                    });\n            }\n        },\n    });\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to an {@link OffchainMessage}\n *\n * @see {@link getOffchainMessageDecoder}\n * @see {@link getOffchainMessageEncoder}\n *\n * @remarks\n * If the offchain message version is known ahead of time, use one of the codecs specific to that\n * version so as not to bundle more code than you need.\n */\nexport function getOffchainMessageCodec(): VariableSizeCodec<OffchainMessage> {\n    return combineCodec(getOffchainMessageEncoder(), getOffchainMessageDecoder());\n}\n","import { VariableSizeEncoder } from '@solana/codecs-core';\n\nimport { OffchainMessageEnvelope } from './envelope';\nimport { OffchainMessage, OffchainMessageBytes } from './message';\n\nexport function compileOffchainMessageEnvelopeUsingEncoder<T extends OffchainMessage>(\n    offchainMessage: T,\n    encoder: VariableSizeEncoder<T>,\n) {\n    const offchainMessageBytes = encoder.encode(offchainMessage) as OffchainMessageBytes;\n    const signatures: OffchainMessageEnvelope['signatures'] = {};\n    for (const { address } of offchainMessage.requiredSignatories) {\n        signatures[address] = null;\n    }\n    return Object.freeze({\n        content: offchainMessageBytes,\n        signatures: Object.freeze(signatures),\n    });\n}\n","import { getOffchainMessageV0Encoder } from './codecs/message-v0';\nimport { OffchainMessageEnvelope } from './envelope';\nimport { compileOffchainMessageEnvelopeUsingEncoder } from './envelope-common';\nimport { OffchainMessageV0 } from './message-v0';\n\n/**\n * Returns an {@link OffchainMessageEnvelope} object for a given {@link OffchainMessageV0}.\n *\n * This includes the compiled bytes of the offchain message, and a map of signatures. This map will\n * have a key for each address that is required to sign the message. The message envelope will not\n * yet have signatures for any of these signatories.\n */\nexport function compileOffchainMessageV0Envelope(offchainMessage: OffchainMessageV0): OffchainMessageEnvelope {\n    return compileOffchainMessageEnvelopeUsingEncoder(offchainMessage, getOffchainMessageV0Encoder());\n}\n","import { getOffchainMessageV1Encoder } from './codecs/message-v1';\nimport { OffchainMessageEnvelope } from './envelope';\nimport { compileOffchainMessageEnvelopeUsingEncoder } from './envelope-common';\nimport { OffchainMessageV1 } from './message-v1';\n\n/**\n * Returns an {@link OffchainMessageEnvelope} object for a given {@link OffchainMessageV1}.\n *\n * This includes the compiled bytes of the offchain message, and a map of signatures. This map will\n * have a key for each address that is required to sign the message. The message envelope will not\n * yet have signatures for any of these signatories.\n */\nexport function compileOffchainMessageV1Envelope(offchainMessage: OffchainMessageV1): OffchainMessageEnvelope {\n    return compileOffchainMessageEnvelopeUsingEncoder(offchainMessage, getOffchainMessageV1Encoder());\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { compileOffchainMessageV0Envelope } from './envelope-v0';\nimport { compileOffchainMessageV1Envelope } from './envelope-v1';\nimport { OffchainMessage, OffchainMessageBytes } from './message';\n\ntype OrderedMap<K extends string, V> = Record<K, V>;\ntype OffchainMessageSignaturesMap = OrderedMap<Address, SignatureBytes | null>;\n\nexport interface OffchainMessageEnvelope {\n    /** The bytes of the combined offchain message preamble and content */\n    readonly content: OffchainMessageBytes;\n    /**\n     * A map between the addresses of an offchain message's signers, and the 64-byte Ed25519\n     * signature of the combined message preamble and message content by the private key associated\n     * with each.\n     */\n    readonly signatures: OffchainMessageSignaturesMap;\n}\n\n/**\n * Returns an {@link OffchainMessageEnvelope} object for a given {@link OffchainMessage}.\n *\n * This includes the compiled bytes of the offchain message, and a map of signatures. This map will\n * have a key for each address that is required to sign the message. The message envelope will not\n * yet have signatures for any of these signatories.\n *\n * @remarks\n * If the offchain message version is known ahead of time, use one of the compile functions\n * specific to that version so as not to bundle more code than you need.\n */\nexport function compileOffchainMessageEnvelope(offchainMessage: OffchainMessage): OffchainMessageEnvelope {\n    const { version } = offchainMessage;\n    switch (version) {\n        case 0:\n            return compileOffchainMessageV0Envelope(offchainMessage);\n        case 1:\n            return compileOffchainMessageV1Envelope(offchainMessage);\n        default:\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                unexpectedValue: version satisfies never,\n            });\n    }\n}\n","import { Address, getAddressFromPublicKey, getPublicKeyFromAddress } from '@solana/addresses';\nimport { bytesEqual } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { SignatureBytes, signBytes, verifySignature } from '@solana/keys';\nimport { NominalType } from '@solana/nominal-types';\n\nimport { decodeRequiredSignatoryAddresses } from './codecs/preamble-common';\nimport { OffchainMessageEnvelope } from './envelope';\n\n/**\n * Represents an offchain message envelope that is signed by all of its required signers.\n */\nexport type FullySignedOffchainMessageEnvelope = NominalType<'offchainMessageEnvelopeSignedness', 'fullySigned'>;\n\n/**\n * Represents an address that is required to sign an offchain message for it to be valid.\n */\nexport type OffchainMessageSignatory<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n}>;\n\n/**\n * An offchain message having a list of accounts that must sign it in order for it to be valid.\n */\nexport interface OffchainMessageWithRequiredSignatories<\n    TSignatory extends OffchainMessageSignatory = OffchainMessageSignatory,\n> {\n    requiredSignatories: readonly TSignatory[];\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign an offchain message, this method will return a new signed offchain message\n * envelope of type {@link OffchainMessageEnvelope}.\n *\n * Though the resulting message might be signed by all required signers, this function will not\n * assert that it is. A partially signed message is not complete, but can be serialized and\n * deserialized.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { partiallySignOffchainMessageEnvelope } from '@solana/offchain-messages';\n *\n * const partiallySignedOffchainMessage = await partiallySignOffchainMessageEnvelope(\n *     [myPrivateKey],\n *     offchainMessageEnvelope,\n * );\n * ```\n *\n * @see {@link signOffchainMessageEnvelope} if you want to assert that the message is signed by all\n * its required signers after signing.\n */\nexport async function partiallySignOffchainMessageEnvelope<TOffchainMessageEnvelope extends OffchainMessageEnvelope>(\n    keyPairs: CryptoKeyPair[],\n    offchainMessageEnvelope: TOffchainMessageEnvelope,\n): Promise<TOffchainMessageEnvelope> {\n    let newSignatures: Record<Address, SignatureBytes> | undefined;\n    let unexpectedSigners: Set<Address> | undefined;\n\n    const requiredSignatoryAddresses = decodeRequiredSignatoryAddresses(offchainMessageEnvelope.content);\n\n    await Promise.all(\n        keyPairs.map(async keyPair => {\n            const address = await getAddressFromPublicKey(keyPair.publicKey);\n\n            // Check if the address is expected to sign the message\n            if (!requiredSignatoryAddresses.includes(address)) {\n                // address is not an expected signer for this message\n                unexpectedSigners ||= new Set();\n                unexpectedSigners.add(address);\n                return;\n            }\n\n            // Return if there are any unexpected signers already since we won't be using signatures\n            if (unexpectedSigners) {\n                return;\n            }\n\n            const existingSignature = offchainMessageEnvelope.signatures[address];\n            const newSignature = await signBytes(keyPair.privateKey, offchainMessageEnvelope.content);\n\n            if (existingSignature != null && bytesEqual(newSignature, existingSignature)) {\n                // already have the same signature set\n                return;\n            }\n\n            newSignatures ||= {};\n            newSignatures[address] = newSignature;\n        }),\n    );\n\n    if (unexpectedSigners && unexpectedSigners.size > 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE, {\n            expectedAddresses: requiredSignatoryAddresses,\n            unexpectedAddresses: [...unexpectedSigners],\n        });\n    }\n\n    if (!newSignatures) {\n        return offchainMessageEnvelope;\n    }\n\n    return Object.freeze({\n        ...offchainMessageEnvelope,\n        signatures: Object.freeze({\n            ...offchainMessageEnvelope.signatures,\n            ...newSignatures,\n        }),\n    });\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign an offchain message envelope, this method will return a new signed envelope of\n * type {@link FullySignedOffchainMessageEnvelope}.\n *\n * This function will throw unless the resulting message is fully signed.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { signOffchainMessageEnvelope } from '@solana/offchain-messages';\n *\n * const signedOffchainMessage = await signOffchainMessageEnvelope(\n *     [myPrivateKey],\n *     offchainMessageEnvelope,\n * );\n * ```\n *\n * @see {@link partiallySignOffchainMessageEnvelope} if you want to sign the message without\n * asserting that the resulting message envelope is fully signed.\n */\nexport async function signOffchainMessageEnvelope<TOffchainMessageEnvelope extends OffchainMessageEnvelope>(\n    keyPairs: CryptoKeyPair[],\n    offchainMessageEnvelope: TOffchainMessageEnvelope,\n): Promise<FullySignedOffchainMessageEnvelope & TOffchainMessageEnvelope> {\n    const out = await partiallySignOffchainMessageEnvelope(keyPairs, offchainMessageEnvelope);\n    assertIsFullySignedOffchainMessageEnvelope(out);\n    Object.freeze(out);\n    return out;\n}\n\n/**\n * A type guard that returns `true` if the input {@link OffchainMessageEnvelope} is fully signed,\n * and refines its type for use in your program, adding the\n * {@link FullySignedOffchainMessageEnvelope} type.\n *\n * @example\n * ```ts\n * import { isFullySignedOffchainMessageEnvelope } from '@solana/offchain-messages';\n *\n * const offchainMessageEnvelope = getOffchainMessageDecoder().decode(offchainMessageBytes);\n * if (isFullySignedOffchainMessageEnvelope(offchainMessageEnvelope)) {\n *   // At this point we know that the offchain message is fully signed.\n * }\n * ```\n */\nexport function isFullySignedOffchainMessageEnvelope<TEnvelope extends OffchainMessageEnvelope>(\n    offchainMessage: TEnvelope,\n): offchainMessage is FullySignedOffchainMessageEnvelope & TEnvelope {\n    return Object.entries(offchainMessage.signatures).every(([_, signatureBytes]) => !!signatureBytes);\n}\n\n/**\n * From time to time you might acquire a {@link OffchainMessageEnvelope}, that you expect to be\n * fully signed, from an untrusted network API or user input. Use this function to assert that such\n * an offchain message is fully signed.\n *\n * @example\n * ```ts\n * import { assertIsFullySignedOffchainMessage } from '@solana/offchain-messages';\n *\n * const offchainMessageEnvelope = getOffchainMessageDecoder().decode(offchainMessageBytes);\n * try {\n *     // If this type assertion function doesn't throw, then Typescript will upcast\n *     // `offchainMessageEnvelope` to `FullySignedOffchainMessageEnvelope`.\n *     assertIsFullySignedOffchainMessageEnvelope(offchainMessage);\n *     // At this point we know that the offchain message is signed by all required signers.\n * } catch(e) {\n *     if (isSolanaError(e, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING)) {\n *         setError(`Missing signatures for ${e.context.addresses.join(', ')}`);\n *     } else {\n *         throw e;\n *     }\n * }\n * ```\n */\nexport function assertIsFullySignedOffchainMessageEnvelope<TEnvelope extends OffchainMessageEnvelope>(\n    offchainMessage: TEnvelope,\n): asserts offchainMessage is FullySignedOffchainMessageEnvelope & TEnvelope {\n    const missingSigs: Address[] = [];\n    Object.entries(offchainMessage.signatures).forEach(([address, signatureBytes]) => {\n        if (!signatureBytes) {\n            missingSigs.push(address as Address);\n        }\n    });\n\n    if (missingSigs.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING, {\n            addresses: missingSigs,\n        });\n    }\n}\n\n/**\n * Asserts that there are signatures present for all of an offchain message's required signatories,\n * and that those signatures are valid given the message.\n *\n * @example\n * ```ts\n * import { isSolanaError, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE } from '@solana/errors';\n * import { verifyOffchainMessageEnvelope } from '@solana/offchain-messages';\n *\n * try {\n *     await verifyOffchainMessageEnvelope(offchainMessageEnvelope);\n *     // At this point the message is valid and signed by all of the required signatories.\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE)) {\n *         if (e.context.signatoriesWithMissingSignatures.length) {\n *             console.error(\n *                 'Missing signatures for the following addresses',\n *                 e.context.signatoriesWithMissingSignatures,\n *             );\n *         }\n *         if (e.context.signatoriesWithInvalidSignatures.length) {\n *             console.error(\n *                 'Signatures for the following addresses are invalid',\n *                 e.context.signatoriesWithInvalidSignatures,\n *             );\n *         }\n *     }\n *     throw e;\n * }\n */\nexport async function verifyOffchainMessageEnvelope(offchainMessageEnvelope: OffchainMessageEnvelope): Promise<void> {\n    let errorContext;\n    const requiredSignatories = decodeRequiredSignatoryAddresses(offchainMessageEnvelope.content);\n    await Promise.all(\n        requiredSignatories.map(async address => {\n            const signature = offchainMessageEnvelope.signatures[address];\n            if (signature == null) {\n                errorContext ||= {};\n                errorContext.signatoriesWithMissingSignatures ||= [];\n                errorContext.signatoriesWithMissingSignatures.push(address);\n            } else {\n                const publicKey = await getPublicKeyFromAddress(address);\n                if (await verifySignature(publicKey, signature, offchainMessageEnvelope.content)) {\n                    return true;\n                } else {\n                    errorContext ||= {};\n                    errorContext.signatoriesWithInvalidSignatures ||= [];\n                    errorContext.signatoriesWithInvalidSignatures.push(address);\n                }\n            }\n        }),\n    );\n    if (errorContext) {\n        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE, errorContext);\n    }\n}\n"],"names":["SolanaError","transformEncoder","getAddressDecoder","getU8Encoder","getStructEncoder","getBytesEncoder","SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO","address","transformDecoder","getStructDecoder","getArrayDecoder","getBytesDecoder","getU8Decoder","combineCodec","SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO","OffchainMessageContentFormat","getArrayEncoder","getAddressEncoder","getUtf8Encoder","fixDecoderSize","getTupleDecoder","getUtf8Decoder","SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY","getTupleEncoder","getHiddenPrefixDecoder","SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED","SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE"],"mappings":"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"}},
    {"offset": {"line": 7060, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/signers/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/signers/src/deduplicate-signers.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/signers/src/transaction-modifying-signer.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/signers/src/transaction-partial-signer.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/signers/src/transaction-sending-signer.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/signers/src/transaction-signer.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/signers/src/account-signer-meta.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/signers/src/add-signers.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/signers/src/fee-payer-signer.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/signers/src/message-partial-signer.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/signers/src/keypair-signer.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/signers/src/message-modifying-signer.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/signers/src/message-signer.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/signers/src/noop-signer.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/signers/src/offchain-message-signer.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/signers/src/sign-offchain-message.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/signers/src/transaction-with-single-sending-signer.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/signers/src/sign-transaction.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/text-encoding-impl/src/index.browser.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/signers/src/signable-message.ts"],"sourcesContent":["import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, SolanaError } from '@solana/errors';\n\nimport { MessageSigner } from './message-signer';\nimport { TransactionSigner } from './transaction-signer';\n\n/**\n * Removes all duplicated {@link MessageSigner | MessageSigners} and\n * {@link TransactionSigner | TransactionSigners} from a provided array\n * by comparing their {@link Address | addresses}.\n *\n * @internal\n */\nexport function deduplicateSigners<TSigner extends MessageSigner | TransactionSigner>(\n    signers: readonly TSigner[],\n): readonly TSigner[] {\n    const deduplicated: Record<Address, TSigner> = {};\n    signers.forEach(signer => {\n        if (!deduplicated[signer.address]) {\n            deduplicated[signer.address] = signer;\n        } else if (deduplicated[signer.address] !== signer) {\n            throw new SolanaError(SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, {\n                address: signer.address,\n            });\n        }\n    });\n    return Object.values(deduplicated);\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\nimport { Transaction, TransactionWithinSizeLimit, TransactionWithLifetime } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link TransactionModifyingSigner#modifyAndSignTransactions | modifyAndSignTransactions} method.\n *\n * @see {@link BaseTransactionSignerConfig}\n */\nexport type TransactionModifyingSignerConfig = BaseTransactionSignerConfig;\n\n/**\n * A signer interface that potentially modifies the provided {@link Transaction | Transactions}\n * before signing them.\n *\n * For instance, this enables wallets to inject additional instructions into the\n * transaction before signing them. For each transaction, instead of returning a\n * {@link SignatureDictionary}, its\n * {@link TransactionModifyingSigner#modifyAndSignTransactions | modifyAndSignTransactions} function\n * returns an updated {@link Transaction} with a potentially modified set of instructions and\n * signature dictionary. The returned transaction must be within the transaction size limit,\n * and include a `lifetimeConstraint`.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: TransactionModifyingSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     modifyAndSignTransactions: async (\n *         transactions: Transaction[]\n *     ): Promise<(Transaction & TransactionWithinSizeLimit & TransactionWithLifetime)[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Sequential**. Contrary to partial signers, these cannot be executed in\n *   parallel as each call can modify the provided transactions.\n * - **First signers**. For a given transaction, a modifying signer must always\n *   be used before a partial signer as the former will likely modify the\n *   transaction and thus impact the outcome of the latter.\n * - **Potential conflicts**. If more than one modifying signer is provided,\n *   the second signer may invalidate the signature of the first one. However,\n *   modifying signers may decide not to modify a transaction based on the\n *   existence of signatures for that transaction.\n *\n * @see {@link isTransactionModifyingSigner}\n * @see {@link assertIsTransactionModifyingSigner}\n */\nexport type TransactionModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignTransactions(\n        transactions: readonly (Transaction | (Transaction & TransactionWithLifetime))[],\n        config?: TransactionModifyingSignerConfig,\n    ): Promise<readonly (Transaction & TransactionWithinSizeLimit & TransactionWithLifetime)[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionModifyingSigner({ address, modifyAndSignTransactions: async () => {} }); // true\n * isTransactionModifyingSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionModifyingSigner}\n */\nexport function isTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionModifyingSigner<TAddress> {\n    return 'modifyAndSignTransactions' in value && typeof value.modifyAndSignTransactions === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionModifyingSigner({ address, modifyAndSignTransactions: async () => {} }); // void\n * assertIsTransactionModifyingSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionModifyingSigner}\n */\nexport function assertIsTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionModifyingSigner<TAddress> {\n    if (!isTransactionModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, SolanaError } from '@solana/errors';\nimport { Transaction, TransactionWithinSizeLimit, TransactionWithLifetime } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig, SignatureDictionary } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link TransactionPartialSigner#signTransactions | signTransactions} method.\n *\n * @see {@link BaseTransactionSignerConfig}\n */\nexport type TransactionPartialSignerConfig = BaseTransactionSignerConfig;\n\n/**\n * A signer interface that signs an array of {@link Transaction | Transactions}\n *  without modifying their content. It defines a\n * {@link TransactionPartialSigner#signTransactions | signTransactions}\n * function that returns a {@link SignatureDictionary} for each provided transaction.\n *\n * Such signature dictionaries are expected to be merged with the existing ones if any.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: TransactionPartialSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     signTransactions: async (\n *         transactions: Transaction[]\n *     ): Promise<SignatureDictionary[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Parallel**. It returns a signature dictionary for each provided\n *   transaction without modifying them, making it possible for multiple\n *   partial signers to sign the same transaction in parallel.\n * - **Flexible order**. The order in which we use these signers for\n *   a given transaction doesn’t matter.\n *\n * @see {@link isTransactionPartialSigner}\n * @see {@link assertIsTransactionPartialSigner}\n */\nexport type TransactionPartialSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signTransactions(\n        transactions: readonly (Transaction & TransactionWithinSizeLimit & TransactionWithLifetime)[],\n        config?: TransactionPartialSignerConfig,\n    ): Promise<readonly SignatureDictionary[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionPartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionPartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionPartialSigner({ address, signTransactions: async () => {} }); // true\n * isTransactionPartialSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionPartialSigner}\n */\nexport function isTransactionPartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionPartialSigner<TAddress> {\n    return 'signTransactions' in value && typeof value.signTransactions === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionPartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionPartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionPartialSigner({ address, signTransactions: async () => {} }); // void\n * assertIsTransactionPartialSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionPartialSigner}\n */\nexport function assertIsTransactionPartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionPartialSigner<TAddress> {\n    if (!isTransactionPartialSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { Transaction, TransactionWithLifetime } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link TransactionSendingSignerConfig#signAndSendTransactions | signAndSendTransactions} method.\n *\n * @see {@link BaseTransactionSignerConfig}\n */\nexport type TransactionSendingSignerConfig = BaseTransactionSignerConfig;\n\n/**\n * A signer interface that signs one or multiple transactions\n * before sending them immediately to the blockchain.\n *\n * It defines a {@link TransactionSendingSignerConfig#signAndSendTransactions | signAndSendTransactions}\n * function that returns the transaction signature (i.e. its identifier) for each provided\n * {@link Transaction}.\n *\n * This interface is required for PDA wallets and other types of wallets that don't provide an\n * interface for signing transactions without sending them.\n *\n * Note that it is also possible for such signers to modify the provided transactions\n * before signing and sending them. This enables use cases where the modified transactions\n * cannot be shared with the app and thus must be sent directly.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const myTransactionSendingSigner: TransactionSendingSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     signAndSendTransactions: async (transactions: Transaction[]): Promise<SignatureBytes[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Single signer**. Since this signer also sends the provided transactions,\n *   we can only use a single {@link TransactionSendingSigner} for a given set of transactions.\n * - **Last signer**. Trivially, that signer must also be the last one used.\n * - **Potential conflicts**. Since signers may decide to modify the given\n *   transactions before sending them, they may invalidate previous signatures.\n *   However, signers may decide not to modify a transaction based\n *   on the existence of signatures for that transaction.\n * - **Potential confirmation**. Whilst this is not required by this interface,\n *   it is also worth noting that most wallets will also wait for the transaction\n *   to be confirmed (typically with a `confirmed` commitment)\n *   before notifying the app that they are done.\n *\n * @see {@link isTransactionSendingSigner}\n * @see {@link assertIsTransactionSendingSigner}\n */\nexport type TransactionSendingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signAndSendTransactions(\n        transactions: readonly (Transaction | (Transaction & TransactionWithLifetime))[],\n        config?: TransactionSendingSignerConfig,\n    ): Promise<readonly SignatureBytes[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionSendingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionSendingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionSendingSigner({ address, signAndSendTransactions: async () => {} }); // true\n * isTransactionSendingSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionSendingSigner}\n */\nexport function isTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSendingSigner<TAddress> {\n    return 'signAndSendTransactions' in value && typeof value.signAndSendTransactions === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionSendingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionSendingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionSendingSigner({ address, signAndSendTransactions: async () => {} }); // void\n * assertIsTransactionSendingSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionSendingSigner}\n */\nexport function assertIsTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSendingSigner<TAddress> {\n    if (!isTransactionSendingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isTransactionModifyingSigner, TransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner, TransactionSendingSigner } from './transaction-sending-signer';\n\n/**\n * Defines a signer capable of signing transactions.\n *\n * @see {@link TransactionModifyingSigner} For signers that can modify transactions before signing them.\n * @see {@link TransactionPartialSigner} For signers that can be used in parallel.\n * @see {@link TransactionSendingSigner} For signers that send transactions after signing them.\n * @see {@link isTransactionSigner}\n * @see {@link assertIsTransactionSigner}\n */\nexport type TransactionSigner<TAddress extends string = string> =\n    | TransactionModifyingSigner<TAddress>\n    | TransactionPartialSigner<TAddress>\n    | TransactionSendingSigner<TAddress>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionSigner({ address, signTransactions: async () => {} }); // true\n * isTransactionSigner({ address, modifyAndSignTransactions: async () => {} }); // true\n * isTransactionSigner({ address, signAndSendTransactions: async () => {} }); // true\n * isTransactionSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionSigner}\n */\nexport function isTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSigner<TAddress> {\n    return (\n        isTransactionPartialSigner(value) || isTransactionModifyingSigner(value) || isTransactionSendingSigner(value)\n    );\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionSigner({ address, signTransactions: async () => {} }); // void\n * assertIsTransactionSigner({ address, modifyAndSignTransactions: async () => {} }); // void\n * assertIsTransactionSigner({ address, signAndSendTransactions: async () => {} }); // void\n * assertIsTransactionSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionSigner}\n */\nexport function assertIsTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSigner<TAddress> {\n    if (!isTransactionSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { AccountLookupMeta, AccountMeta, AccountRole, Instruction } from '@solana/instructions';\nimport {\n    BaseTransactionMessage,\n    TransactionMessageWithFeePayer,\n    TransactionVersion,\n} from '@solana/transaction-messages';\n\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { TransactionMessageWithFeePayerSigner } from './fee-payer-signer';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\n\n/**\n * An extension of the {@link AccountMeta} type that allows us to store {@link TransactionSigner | TransactionSigners} inside it.\n *\n * Note that, because this type represents a signer, it must use one the following two roles:\n * - {@link AccountRole.READONLY_SIGNER}\n * - {@link AccountRole.WRITABLE_SIGNER}\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for the {@link TransactionSigner} to use within the account meta.\n *\n * @interface\n *\n * @example\n * ```ts\n * import { AccountRole } from '@solana/instructions';\n * import { generateKeyPairSigner, AccountSignerMeta } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * const account: AccountSignerMeta = {\n *     address: signer.address,\n *     role: AccountRole.READONLY_SIGNER,\n *     signer,\n * };\n * ```\n */\nexport interface AccountSignerMeta<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> extends AccountMeta<TAddress> {\n    readonly role: AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER;\n    readonly signer: TSigner;\n}\n\n/**\n * A union type that supports base account metas as well as {@link AccountSignerMeta | signer account metas}.\n */\ntype AccountMetaWithSigner<TSigner extends TransactionSigner = TransactionSigner> =\n    | AccountLookupMeta\n    | AccountMeta\n    | AccountSignerMeta<string, TSigner>;\n\n/**\n * Composable type that allows {@link AccountSignerMeta | AccountSignerMetas} to be used inside the instruction's `accounts` array\n *\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n * @typeParam TAccounts - Optionally provide a narrower type for the account metas.\n *\n * @interface\n *\n * @example\n * ```ts\n * import { AccountRole, Instruction } from '@solana/instructions';\n * import { generateKeyPairSigner, InstructionWithSigners } from '@solana/signers';\n *\n * const [authority, buffer] = await Promise.all([\n *     generateKeyPairSigner(),\n *     generateKeyPairSigner(),\n * ]);\n * const instruction: Instruction & InstructionWithSigners = {\n *     programAddress: address('1234..5678'),\n *     accounts: [\n *         // The authority is a signer account.\n *         {\n *             address: authority.address,\n *             role: AccountRole.READONLY_SIGNER,\n *             signer: authority,\n *         },\n *         // The buffer is a writable account.\n *         { address: buffer.address, role: AccountRole.WRITABLE },\n *     ],\n * };\n * ```\n */\nexport type InstructionWithSigners<\n    TSigner extends TransactionSigner = TransactionSigner,\n    TAccounts extends readonly AccountMetaWithSigner<TSigner>[] = readonly AccountMetaWithSigner<TSigner>[],\n> = Pick<Instruction<string, TAccounts>, 'accounts'>;\n\n/**\n * A {@link BaseTransactionMessage} type extension that accept {@link TransactionSigner | TransactionSigners}.\n *\n * Namely, it allows:\n * - a {@link TransactionSigner} to be used as the fee payer and\n * - {@link InstructionWithSigners} to be used in its instructions.\n *\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n * @typeParam TAccounts - Optionally provide a narrower type for the account metas.\n *\n * @example\n * ```ts\n * import { Instruction } from '@solana/instructions';\n * import { BaseTransactionMessage } from '@solana/transaction-messages';\n * import { generateKeyPairSigner, InstructionWithSigners, TransactionMessageWithSigners } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * const firstInstruction: Instruction = { ... };\n * const secondInstruction: InstructionWithSigners = { ... };\n * const transactionMessage: BaseTransactionMessage & TransactionMessageWithSigners = {\n *     feePayer: signer,\n *     instructions: [firstInstruction, secondInstruction],\n * }\n * ```\n */\nexport type TransactionMessageWithSigners<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n    TAccounts extends readonly AccountMetaWithSigner<TSigner>[] = readonly AccountMetaWithSigner<TSigner>[],\n> = Partial<TransactionMessageWithFeePayer<TAddress> | TransactionMessageWithFeePayerSigner<TAddress, TSigner>> &\n    Pick<\n        BaseTransactionMessage<TransactionVersion, Instruction & InstructionWithSigners<TSigner, TAccounts>>,\n        'instructions'\n    >;\n\n/**\n * Extracts and deduplicates all {@link TransactionSigner | TransactionSigners} stored\n * inside the account metas of an {@link InstructionWithSigners | instruction}.\n *\n * Any extracted signers that share the same {@link Address} will be de-duplicated.\n *\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n *\n * @example\n * ```ts\n * import { InstructionWithSigners, getSignersFromInstruction } from '@solana/signers';\n *\n * const signerA = { address: address('1111..1111'), signTransactions: async () => {} };\n * const signerB = { address: address('2222..2222'), signTransactions: async () => {} };\n * const instructionWithSigners: InstructionWithSigners = {\n *     accounts: [\n *         { address: signerA.address, signer: signerA, ... },\n *         { address: signerB.address, signer: signerB, ... },\n *         { address: signerA.address, signer: signerA, ... },\n *     ],\n * };\n *\n * const instructionSigners = getSignersFromInstruction(instructionWithSigners);\n * // ^ [signerA, signerB]\n * ```\n */\nexport function getSignersFromInstruction<TSigner extends TransactionSigner = TransactionSigner>(\n    instruction: InstructionWithSigners<TSigner>,\n): readonly TSigner[] {\n    return deduplicateSigners(\n        (instruction.accounts ?? []).flatMap(account => ('signer' in account ? account.signer : [])),\n    );\n}\n\n/**\n * Extracts and deduplicates all {@link TransactionSigner | TransactionSigners} stored\n * inside a given {@link TransactionMessageWithSigners | transaction message}.\n *\n * This includes any {@link TransactionSigner | TransactionSigners} stored\n * as the fee payer or in the instructions of the transaction message.\n *\n * Any extracted signers that share the same {@link Address} will be de-duplicated.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { Instruction } from '@solana/instructions';\n * import { InstructionWithSigners, TransactionMessageWithSigners, getSignersFromTransactionMessage } from '@solana/signers';\n *\n * const signerA = { address: address('1111..1111'), signTransactions: async () => {} };\n * const signerB = { address: address('2222..2222'), signTransactions: async () => {} };\n * const firstInstruction: Instruction & InstructionWithSigners = {\n *     programAddress: address('1234..5678'),\n *     accounts: [{ address: signerA.address, signer: signerA, ... }],\n * };\n * const secondInstruction: Instruction & InstructionWithSigners = {\n *     programAddress: address('1234..5678'),\n *     accounts: [{ address: signerB.address, signer: signerB, ... }],\n * };\n * const transactionMessage: TransactionMessageWithSigners = {\n *     feePayer: signerA,\n *     instructions: [firstInstruction, secondInstruction],\n * }\n *\n * const transactionSigners = getSignersFromTransactionMessage(transactionMessage);\n * // ^ [signerA, signerB]\n * ```\n */\nexport function getSignersFromTransactionMessage<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n    TTransactionMessage extends TransactionMessageWithSigners<TAddress, TSigner> = TransactionMessageWithSigners<\n        TAddress,\n        TSigner\n    >,\n>(transaction: TTransactionMessage): readonly TSigner[] {\n    return deduplicateSigners([\n        ...(transaction.feePayer && isTransactionSigner(transaction.feePayer) ? [transaction.feePayer as TSigner] : []),\n        ...transaction.instructions.flatMap(getSignersFromInstruction),\n    ]);\n}\n","import { Address } from '@solana/addresses';\nimport { Instruction, isSignerRole } from '@solana/instructions';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { AccountSignerMeta, InstructionWithSigners, TransactionMessageWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\n\n/**\n * Attaches the provided {@link TransactionSigner | TransactionSigners} to the\n * account metas of an instruction when applicable.\n *\n * For an account meta to match a provided signer it:\n * - Must have a signer role ({@link AccountRole.READONLY_SIGNER} or {@link AccountRole.WRITABLE_SIGNER}).\n * - Must have the same address as the provided signer.\n * - Must not have an attached signer already.\n *\n * @typeParam TInstruction - The inferred type of the instruction provided.\n *\n * @example\n * ```ts\n * import { AccountRole, Instruction } from '@solana/instructions';\n * import { addSignersToInstruction, TransactionSigner } from '@solana/signers';\n *\n * const instruction: Instruction = {\n *     accounts: [\n *         { address: '1111' as Address, role: AccountRole.READONLY_SIGNER },\n *         { address: '2222' as Address, role: AccountRole.WRITABLE_SIGNER },\n *     ],\n *     // ...\n * };\n *\n * const signerA: TransactionSigner<'1111'>;\n * const signerB: TransactionSigner<'2222'>;\n * const instructionWithSigners = addSignersToInstruction(\n *     [signerA, signerB],\n *     instruction\n * );\n *\n * // instructionWithSigners.accounts[0].signer === signerA\n * // instructionWithSigners.accounts[1].signer === signerB\n * ```\n */\nexport function addSignersToInstruction<TInstruction extends Instruction>(\n    signers: TransactionSigner[],\n    instruction: TInstruction | (InstructionWithSigners & TInstruction),\n): InstructionWithSigners & TInstruction {\n    if (!instruction.accounts || instruction.accounts.length === 0) {\n        return instruction as InstructionWithSigners & TInstruction;\n    }\n\n    const signerByAddress = new Map(deduplicateSigners(signers).map(signer => [signer.address, signer]));\n    return Object.freeze({\n        ...instruction,\n        accounts: instruction.accounts.map(account => {\n            const signer = signerByAddress.get(account.address);\n            if (!isSignerRole(account.role) || 'signer' in account || !signer) {\n                return account;\n            }\n            return Object.freeze({ ...account, signer } as AccountSignerMeta);\n        }),\n    });\n}\n\n/**\n * Attaches the provided {@link TransactionSigner | TransactionSigners} to the\n * account metas of all instructions inside a transaction message and/or\n * the transaction message fee payer, when applicable.\n *\n * For an account meta to match a provided signer it:\n * - Must have a signer role ({@link AccountRole.READONLY_SIGNER} or {@link AccountRole.WRITABLE_SIGNER}).\n * - Must have the same address as the provided signer.\n * - Must not have an attached signer already.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { AccountRole, Instruction } from '@solana/instructions';\n * import { BaseTransactionMessage } from '@solana/transaction-messages';\n * import { addSignersToTransactionMessage, TransactionSigner } from '@solana/signers';\n *\n * const instructionA: Instruction = {\n *     accounts: [{ address: '1111' as Address, role: AccountRole.READONLY_SIGNER }],\n *     // ...\n * };\n * const instructionB: Instruction = {\n *     accounts: [{ address: '2222' as Address, role: AccountRole.WRITABLE_SIGNER }],\n *     // ...\n * };\n * const transactionMessage: BaseTransactionMessage = {\n *     instructions: [instructionA, instructionB],\n *     // ...\n * }\n *\n * const signerA: TransactionSigner<'1111'>;\n * const signerB: TransactionSigner<'2222'>;\n * const transactionMessageWithSigners = addSignersToTransactionMessage(\n *     [signerA, signerB],\n *     transactionMessage\n * );\n *\n * // transactionMessageWithSigners.instructions[0].accounts[0].signer === signerA\n * // transactionMessageWithSigners.instructions[1].accounts[0].signer === signerB\n * ```\n */\nexport function addSignersToTransactionMessage<TTransactionMessage extends BaseTransactionMessage>(\n    signers: TransactionSigner[],\n    transactionMessage: TTransactionMessage | (TransactionMessageWithSigners & TTransactionMessage),\n): TransactionMessageWithSigners & TTransactionMessage {\n    const feePayerSigner = hasAddressOnlyFeePayer(transactionMessage)\n        ? signers.find(signer => signer.address === transactionMessage.feePayer.address)\n        : undefined;\n\n    if (!feePayerSigner && transactionMessage.instructions.length === 0) {\n        return transactionMessage as TransactionMessageWithSigners & TTransactionMessage;\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        ...(feePayerSigner ? { feePayer: feePayerSigner } : null),\n        instructions: transactionMessage.instructions.map(instruction => addSignersToInstruction(signers, instruction)),\n    });\n}\n\nfunction hasAddressOnlyFeePayer(\n    message: BaseTransactionMessage & Partial<TransactionMessageWithFeePayer>,\n): message is BaseTransactionMessage & { feePayer: { address: Address } } {\n    return (\n        !!message &&\n        'feePayer' in message &&\n        !!message.feePayer &&\n        typeof message.feePayer.address === 'string' &&\n        !isTransactionSigner(message.feePayer)\n    );\n}\n","import { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { TransactionSigner } from './transaction-signer';\n\n/**\n * Alternative to {@link TransactionMessageWithFeePayer} that uses a {@link TransactionSigner} for the fee payer.\n *\n * @typeParam TAddress - Supply a string literal to define a fee payer having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for the {@link TransactionSigner}.\n *\n * @example\n * ```ts\n * import { BaseTransactionMessage } from '@solana/transaction-messages';\n * import { generateKeyPairSigner, TransactionMessageWithFeePayerSigner } from '@solana/signers';\n *\n * const transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayerSigner = {\n *     feePayer: await generateKeyPairSigner(),\n *     instructions: [],\n *     version: 0,\n * };\n * ```\n */\nexport interface TransactionMessageWithFeePayerSigner<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> {\n    readonly feePayer: TSigner;\n}\n\n/**\n * Sets the fee payer of a {@link BaseTransactionMessage | transaction message}\n * using a {@link TransactionSigner}.\n *\n * @typeParam TFeePayerAddress - Supply a string literal to define a fee payer having a particular address.\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { pipe } from '@solana/functional';\n * import { generateKeyPairSigner, setTransactionMessageFeePayerSigner } from '@solana/signers';\n * import { createTransactionMessage } from '@solana/transaction-messages';\n *\n * const feePayer = await generateKeyPairSigner();\n * const transactionMessage = pipe(\n *     createTransactionMessage({ version: 0 }),\n *     message => setTransactionMessageFeePayerSigner(signer, message),\n * );\n * ```\n */\nexport function setTransactionMessageFeePayerSigner<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends BaseTransactionMessage &\n        Partial<TransactionMessageWithFeePayer | TransactionMessageWithFeePayerSigner>,\n>(\n    feePayer: TransactionSigner<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): Omit<TTransactionMessage, 'feePayer'> & TransactionMessageWithFeePayerSigner<TFeePayerAddress> {\n    Object.freeze(feePayer);\n    const out = { ...transactionMessage, feePayer };\n    Object.freeze(out);\n    return out;\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig, SignatureDictionary } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link MessagePartialSigner#signMessages | signMessages} method.\n *\n * @see {@link BaseSignerConfig}\n */\nexport type MessagePartialSignerConfig = BaseSignerConfig;\n\n/**\n * A signer interface that signs an array of {@link SignableMessage | SignableMessages}\n * without modifying their content.\n *\n * It defines a {@link MessagePartialSigner#signMessages | signMessages} function\n * that returns a {@link SignatureDictionary} for each provided message.\n * Such signature dictionaries are expected to be merged with the existing ones if any.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: MessagePartialSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     signMessages: async (\n *         messages: SignableMessage[]\n *     ): Promise<SignatureDictionary[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Parallel**. When multiple signers sign the same message, we can\n *   perform this operation in parallel to obtain all their signatures.\n * - **Flexible order**. The order in which we use these signers\n *   for a given message doesn’t matter.\n *\n * @see {@link SignableMessage}\n * @see {@link createSignableMessage}\n * @see {@link isMessagePartialSigner}\n * @see {@link assertIsMessagePartialSigner}\n */\nexport type MessagePartialSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signMessages(\n        messages: readonly SignableMessage[],\n        config?: MessagePartialSignerConfig,\n    ): Promise<readonly SignatureDictionary[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link MessagePartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isMessagePartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isMessagePartialSigner({ address, signMessages: async () => {} }); // true\n * isMessagePartialSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsMessagePartialSigner}\n */\nexport function isMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessagePartialSigner<TAddress> {\n    return 'signMessages' in value && typeof value.signMessages === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link MessagePartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsMessagePartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsMessagePartialSigner({ address, signMessages: async () => {} }); // void\n * assertIsMessagePartialSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isMessagePartialSigner}\n */\nexport function assertIsMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessagePartialSigner<TAddress> {\n    if (!isMessagePartialSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address, getAddressFromPublicKey } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, SolanaError } from '@solana/errors';\nimport { createKeyPairFromBytes, createKeyPairFromPrivateKeyBytes, generateKeyPair, signBytes } from '@solana/keys';\nimport { partiallySignTransaction } from '@solana/transactions';\n\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\n\n/**\n * Defines a signer that uses a {@link CryptoKeyPair} to sign messages and transactions.\n *\n * It implements both the {@link MessagePartialSigner} and {@link TransactionPartialSigner}\n * interfaces and keeps track of the {@link CryptoKeyPair} instance used\n * to sign messages and transactions.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner } from '@solana/signers';\n *\n * const signer = generateKeyPairSigner();\n * signer.address; // Address;\n * signer.keyPair; // CryptoKeyPair;\n * const [messageSignatures] = await signer.signMessages([message]);\n * const [transactionSignatures] = await signer.signTransactions([transaction]);\n * ```\n *\n * @see {@link generateKeyPairSigner}\n * @see {@link createSignerFromKeyPair}\n * @see {@link createKeyPairSignerFromBytes}\n * @see {@link createKeyPairSignerFromPrivateKeyBytes}\n * @see {@link isKeyPairSigner}\n * @see {@link assertIsKeyPairSigner}\n */\nexport type KeyPairSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress> & { keyPair: CryptoKeyPair };\n\n/**\n * Checks whether the provided value implements the {@link KeyPairSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner, isKeyPairSigner } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * isKeyPairSigner(signer); // true\n * isKeyPairSigner({ address: address('1234..5678') }); // false\n * ```\n */\nexport function isKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is KeyPairSigner<TAddress> {\n    return (\n        'keyPair' in value &&\n        typeof value.keyPair === 'object' &&\n        isMessagePartialSigner(value) &&\n        isTransactionPartialSigner(value)\n    );\n}\n\n/**\n * Asserts that the provided value implements the {@link KeyPairSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner, assertIsKeyPairSigner } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * assertIsKeyPairSigner(signer); // void\n * assertIsKeyPairSigner({ address: address('1234..5678') }); // Throws an error.\n * ```\n */\nexport function assertIsKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is KeyPairSigner<TAddress> {\n    if (!isKeyPairSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n\n/**\n * Creates a {@link KeyPairSigner} from a provided {@link CryptoKeyPair}.\n *\n * The {@link MessagePartialSigner#signMessages | signMessages} and\n * {@link TransactionPartialSigner#signTransactions | signTransactions}\n * functions of the returned signer will use the private key of the provided\n * key pair to sign messages and transactions.\n *\n * Note that both the {@link MessagePartialSigner#signMessages | signMessages} and\n * {@link TransactionPartialSigner#signTransactions | signTransactions} implementations\n * are parallelized, meaning that they will sign all provided messages and transactions in parallel.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { createSignerFromKeyPair, KeyPairSigner } from '@solana/signers';\n *\n * const keyPair: CryptoKeyPair = await generateKeyPair();\n * const signer: KeyPairSigner = await createSignerFromKeyPair(keyPair);\n * ```\n */\nexport async function createSignerFromKeyPair(keyPair: CryptoKeyPair): Promise<KeyPairSigner> {\n    const address = await getAddressFromPublicKey(keyPair.publicKey);\n    const out: KeyPairSigner = {\n        address,\n        keyPair,\n        signMessages: messages =>\n            Promise.all(\n                messages.map(async message =>\n                    Object.freeze({ [address]: await signBytes(keyPair.privateKey, message.content) }),\n                ),\n            ),\n        signTransactions: transactions =>\n            Promise.all(\n                transactions.map(async transaction => {\n                    const signedTransaction = await partiallySignTransaction([keyPair], transaction);\n                    // we know that the address has signed `signedTransaction` because it comes from the keypair\n                    return Object.freeze({ [address]: signedTransaction.signatures[address]! });\n                }),\n            ),\n    };\n\n    return Object.freeze(out);\n}\n\n/**\n * Generates a signer capable of signing messages and transactions by generating\n * a {@link CryptoKeyPair} and creating a {@link KeyPairSigner} from it.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * ```\n *\n * @see {@link createSignerFromKeyPair}\n */\nexport async function generateKeyPairSigner(): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await generateKeyPair());\n}\n\n/**\n * Creates a new {@link KeyPairSigner} from a 64-bytes `Uint8Array` secret key (private key and public key).\n *\n * @example\n * ```ts\n * import fs from 'fs';\n * import { createKeyPairSignerFromBytes } from '@solana/signers';\n *\n * // Get bytes from local keypair file.\n * const keypairFile = fs.readFileSync('~/.config/solana/id.json');\n * const keypairBytes = new Uint8Array(JSON.parse(keypairFile.toString()));\n *\n * // Create a KeyPairSigner from the bytes.\n * const signer = await createKeyPairSignerFromBytes(keypairBytes);\n * ```\n *\n * @see {@link createKeyPairSignerFromPrivateKeyBytes} if you only have the 32-bytes private key instead.\n */\nexport async function createKeyPairSignerFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable?: boolean,\n): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await createKeyPairFromBytes(bytes, extractable));\n}\n\n/**\n * Creates a new {@link KeyPairSigner} from a 32-bytes `Uint8Array` private key.\n *\n * @example\n * ```ts\n * import { getUtf8Encoder } from '@solana/codecs-strings';\n * import { createKeyPairSignerFromPrivateKeyBytes } from '@solana/signers';\n *\n * const message = getUtf8Encoder().encode('Hello, World!');\n * const seed = new Uint8Array(await crypto.subtle.digest('SHA-256', message));\n *\n * const derivedSigner = await createKeyPairSignerFromPrivateKeyBytes(seed);\n * ```\n *\n * @see {@link createKeyPairSignerFromBytes} if you have the 64-bytes secret key instead (private key and public key).\n */\nexport async function createKeyPairSignerFromPrivateKeyBytes(\n    bytes: ReadonlyUint8Array,\n    extractable?: boolean,\n): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await createKeyPairFromPrivateKeyBytes(bytes, extractable));\n}\n","import { Address, isAddress } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link MessageModifyingSigner#modifyAndSignMessages | modifyAndSignMessages} method.\n *\n * @see {@link BaseSignerConfig}\n */\nexport type MessageModifyingSignerConfig = BaseSignerConfig;\n\n/**\n * A signer interface that _potentially_ modifies the content\n * of the provided {@link SignableMessage | SignableMessages} before signing them.\n *\n * For instance, this enables wallets to prefix or suffix nonces to the messages they sign.\n * For each message, instead of returning a {@link SignatureDictionary}, the\n * {@link MessageModifyingSigner#modifyAndSignMessages | modifyAndSignMessages} function\n * returns an updated {@link SignableMessage} with a potentially modified content and signature dictionary.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: MessageModifyingSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     modifyAndSignMessages: async (\n *         messages: SignableMessage[]\n *     ): Promise<SignableMessage[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Sequential**. Contrary to partial signers, these cannot be executed in\n *   parallel as each call can modify the content of the message.\n * - **First signers**. For a given message, a modifying signer must always be used\n *   before a partial signer as the former will likely modify the message and\n *   thus impact the outcome of the latter.\n * - **Potential conflicts**. If more than one modifying signer is provided, the second\n *   signer may invalidate the signature of the first one. However, modifying signers\n *   may decide not to modify a message based on the existence of signatures for that message.\n *\n * @see {@link SignableMessage}\n * @see {@link createSignableMessage}\n * @see {@link isMessageModifyingSigner}\n * @see {@link assertIsMessageModifyingSigner}\n */\nexport type MessageModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignMessages(\n        messages: readonly SignableMessage[],\n        config?: MessageModifyingSignerConfig,\n    ): Promise<readonly SignableMessage[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link MessageModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isMessageModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isMessageModifyingSigner({ address, modifyAndSignMessages: async () => {} }); // true\n * isMessageModifyingSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsMessageModifyingSigner}\n */\nexport function isMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageModifyingSigner<TAddress> {\n    return (\n        isAddress(value.address) &&\n        'modifyAndSignMessages' in value &&\n        typeof value.modifyAndSignMessages === 'function'\n    );\n}\n\n/**\n * Asserts that the provided value implements the {@link MessageModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsMessageModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsMessageModifyingSigner({ address, modifyAndSignMessages: async () => {} }); // void\n * assertIsMessageModifyingSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isMessageModifyingSigner}\n */\nexport function assertIsMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageModifyingSigner<TAddress> {\n    if (!isMessageModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isMessageModifyingSigner, MessageModifyingSigner } from './message-modifying-signer';\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\n\n/**\n * Defines a signer capable of signing messages.\n *\n * @see {@link MessageModifyingSigner} For signers that can modify messages before signing them.\n * @see {@link MessagePartialSigner} For signers that can be used in parallel.\n * @see {@link isMessageSigner}\n * @see {@link assertIsMessageSigner}\n */\nexport type MessageSigner<TAddress extends string = string> =\n    | MessageModifyingSigner<TAddress>\n    | MessagePartialSigner<TAddress>;\n\n/**\n * Checks whether the provided value implements the {@link MessageSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isMessageSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isMessageSigner({ address, signMessages: async () => {} }); // true\n * isMessageSigner({ address, modifyAndSignMessages: async () => {} }); // true\n * isMessageSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsMessageSigner}\n */\nexport function isMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageSigner<TAddress> {\n    return isMessagePartialSigner(value) || isMessageModifyingSigner(value);\n}\n\n/**\n * Asserts that the provided value implements the {@link MessageSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsMessageSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsMessageSigner({ address, signMessages: async () => {} }); // void\n * assertIsMessageSigner({ address, modifyAndSignMessages: async () => {} }); // void\n * assertIsMessageSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isMessageSigner}\n */\nexport function assertIsMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageSigner<TAddress> {\n    if (!isMessageSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\n\nimport { MessagePartialSigner } from './message-partial-signer';\nimport { TransactionPartialSigner } from './transaction-partial-signer';\n\n/**\n * Defines a Noop (No-Operation) signer that pretends to partially sign messages and transactions.\n *\n * For a given {@link Address}, a Noop Signer can be created to offer an implementation of both\n * the {@link MessagePartialSigner} and {@link TransactionPartialSigner} interfaces such that\n * they do not sign anything. Namely, signing a transaction or a message with a `NoopSigner`\n * will return an empty `SignatureDictionary`.\n *\n * @typeParam TAddress - Supply a string literal to define a Noop signer having a particular address.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { createNoopSigner } from '@solana/signers';\n *\n * const signer = createNoopSigner(address('1234..5678'));\n * const [messageSignatures] = await signer.signMessages([message]);\n * const [transactionSignatures] = await signer.signTransactions([transaction]);\n * // ^ Both messageSignatures and transactionSignatures are empty.\n * ```\n *\n * @remarks\n * This signer may be useful:\n *\n * - For testing purposes.\n * - For indicating that a given account is a signer and taking the responsibility to provide\n *   the signature for that account ourselves. For instance, if we need to send the transaction\n *   to a server that will sign it and send it for us.\n *\n * @see {@link createNoopSigner}\n */\nexport type NoopSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress>;\n\n/**\n * Creates a {@link NoopSigner} from the provided {@link Address}.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { createNoopSigner } from '@solana/signers';\n *\n * const signer = createNoopSigner(address('1234..5678'));\n * ```\n */\nexport function createNoopSigner<TAddress extends string = string>(address: Address<TAddress>): NoopSigner<TAddress> {\n    const out: NoopSigner<TAddress> = {\n        address,\n        signMessages: messages => Promise.resolve(messages.map(() => Object.freeze({}))),\n        signTransactions: transactions => Promise.resolve(transactions.map(() => Object.freeze({}))),\n    };\n\n    return Object.freeze(out);\n}\n","import { OffchainMessageWithRequiredSignatories } from '@solana/offchain-messages';\n\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { isMessageSigner, MessageSigner } from './message-signer';\n\n/**\n * Represents a {@link Signer} that is required to sign an offchain message for it to be valid.\n */\nexport type OffchainMessageSignatorySigner<TAddress extends string = string> = MessageSigner<TAddress>;\n\n/**\n * Extracts and deduplicates all {@link MessageSigner | MessageSigners} stored inside a given\n * {@link OffchainMessageWithSigners | offchain message}.\n *\n * Any extracted signers that share the same {@link Address} will be de-duplicated.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for {@link MessageSigner | MessageSigners}.\n * @typeParam TOffchainMessage - The inferred type of the offchain message provided.\n *\n * @example\n * ```ts\n * import { OffchainMessageWithSigners, getSignersFromOffchainMessage } from '@solana/signers';\n *\n * const signerA = { address: address('1111..1111'), signMessages: async () => {} };\n * const signerB = { address: address('2222..2222'), modifyAndSignMessages: async () => {} };\n * const OffchainMessage: OffchainMessageWithSigners = {\n *     /* ... *\\/\n *     requiredSignatories: [signerA, signerB],\n * };\n *\n * const messageSigners = getSignersFromOffchainMessage(offchainMessage);\n * // ^ [signerA, signerB]\n * ```\n */\nexport function getSignersFromOffchainMessage({\n    requiredSignatories,\n}: OffchainMessageWithRequiredSignatories): readonly MessageSigner[] {\n    const messageSigners = requiredSignatories.filter(isMessageSigner);\n    return deduplicateSigners(messageSigners);\n}\n","import {\n    assertIsFullySignedOffchainMessageEnvelope,\n    compileOffchainMessageEnvelope,\n    FullySignedOffchainMessageEnvelope,\n    OffchainMessage,\n    OffchainMessageEnvelope,\n    OffchainMessageSignatory,\n    OffchainMessageWithRequiredSignatories,\n} from '@solana/offchain-messages';\n\nimport {\n    isMessageModifyingSigner,\n    MessageModifyingSigner,\n    MessageModifyingSignerConfig,\n} from './message-modifying-signer';\nimport { isMessagePartialSigner, MessagePartialSigner, MessagePartialSignerConfig } from './message-partial-signer';\nimport { MessageSigner } from './message-signer';\nimport { getSignersFromOffchainMessage, OffchainMessageSignatorySigner } from './offchain-message-signer';\nimport { SignableMessage } from './signable-message';\n\n/**\n * Extracts all {@link MessageSigner | MessageSigners} inside the provided offchain message and uses\n * them to return a signed offchain message envelope.\n *\n * It first uses all {@link MessageModifyingSigner | MessageModifyingSigners} sequentially before\n * using all {@link MessagePartialSigner | MessagePartialSigners} in parallel.\n *\n * If a composite signer implements both interfaces, it will be used as a\n * {@link MessageModifyingSigner} if no other signer implements that interface. Otherwise, it will\n * be used as a {@link MessagePartialSigner}.\n *\n * @example\n * ```ts\n * const signedOffchainMessageEnvelope = await partiallySignOffchainMessageWithSigners(offchainMessage);\n * ```\n *\n * It also accepts an optional {@link AbortSignal} that will be propagated to all signers.\n *\n * ```ts\n * const signedOffchainMessageEnvelope = await partiallySignOffchainMessageWithSigners(offchainMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n * ```\n *\n * @see {@link signOffchainMessageWithSigners}\n */\nexport async function partiallySignOffchainMessageWithSigners(\n    offchainMessage: OffchainMessageWithRequiredSignatories<OffchainMessageSignatory | OffchainMessageSignatorySigner> &\n        Omit<OffchainMessage, 'requiredSignatories'>,\n    config?: MessagePartialSignerConfig,\n): Promise<OffchainMessageEnvelope> {\n    const { partialSigners, modifyingSigners } = categorizeMessageSigners(\n        getSignersFromOffchainMessage(offchainMessage),\n    );\n    return await signModifyingAndPartialMessageSigners(offchainMessage, modifyingSigners, partialSigners, config);\n}\n\n/**\n * Extracts all {@link MessageSigner | MessageSigners} inside the provided offchain message and uses\n * them to return a signed offchain message envelope before asserting that all signatures required\n * by the message are present.\n *\n * This function delegates to the {@link partiallySignOffchainMessageWithSigners} function\n * in order to extract signers from the offchain message and sign it.\n *\n * @example\n * ```ts\n * const mySignedOffchainMessageEnvelope = await signOffchainMessageWithSigners(myOffchainMessage);\n *\n * // With additional config.\n * const mySignedOffchainMessageEnvelope = await signOffchainMessageWithSigners(myOffchainMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n *\n * // We now know the offchain message is fully signed.\n * mySignedOffchainMessageEnvelope satisfies FullySignedOffchainMessageEnvelope;\n * ```\n *\n * @see {@link partiallySignOffchainMessageWithSigners}\n */\nexport async function signOffchainMessageWithSigners(\n    offchainMessage: OffchainMessageWithRequiredSignatories<OffchainMessageSignatory | OffchainMessageSignatorySigner> &\n        Omit<OffchainMessage, 'requiredSignatories'>,\n    config?: MessagePartialSignerConfig,\n): Promise<FullySignedOffchainMessageEnvelope & OffchainMessageEnvelope> {\n    const signedOffchainMessageEnvelope = await partiallySignOffchainMessageWithSigners(offchainMessage, config);\n    assertIsFullySignedOffchainMessageEnvelope(signedOffchainMessageEnvelope);\n    return signedOffchainMessageEnvelope;\n}\n\n/**\n * Identifies each provided {@link MessageSigner} and categorizes them into their respective types.\n * When a signer implements multiple interfaces, it will try to used to most powerful interface but\n * fall back to the least powerful interface when necessary.\n *\n * For instance, if a signer implements {@link MessageSigner} and {@link MessageModifyingSigner},\n * it will be categorized as a `MessageModifyingSigner`.\n */\nfunction categorizeMessageSigners(signers: readonly MessageSigner[]): Readonly<{\n    modifyingSigners: readonly MessageModifyingSigner[];\n    partialSigners: readonly MessagePartialSigner[];\n}> {\n    // Identify the modifying signers from the other signers.\n    const modifyingSigners = identifyMessageModifyingSigners(signers);\n\n    // Use any remaining signers as partial signers.\n    const partialSigners = signers\n        .filter(isMessagePartialSigner)\n        .filter(signer => !(modifyingSigners as typeof signers).includes(signer));\n\n    return Object.freeze({ modifyingSigners, partialSigners });\n}\n\n/** Identifies the best signers to use as MessageModifyingSigners, if any */\nfunction identifyMessageModifyingSigners(\n    signers: readonly (MessageModifyingSigner | MessagePartialSigner)[],\n): readonly MessageModifyingSigner[] {\n    // Ensure there are any MessageModifyingSigner in the first place.\n    const modifyingSigners = signers.filter(isMessageModifyingSigner);\n    if (modifyingSigners.length === 0) return [];\n\n    // Prefer modifying signers that do not offer partial signing.\n    const nonPartialSigners = modifyingSigners.filter(signer => !isMessagePartialSigner(signer));\n    if (nonPartialSigners.length > 0) return nonPartialSigners;\n\n    // Otherwise, choose only one modifying signer (whichever).\n    return [modifyingSigners[0]];\n}\n\n/**\n * Signs an offchain message using the provided\n * {@link MessageModifyingSigner | MessageModifyingSigners} sequentially followed by the\n * {@link MessagePartialSigner | MessagePartialSigners} in parallel.\n */\nasync function signModifyingAndPartialMessageSigners(\n    offchainMessage: OffchainMessageWithRequiredSignatories<OffchainMessageSignatory | OffchainMessageSignatorySigner> &\n        Omit<OffchainMessage, 'requiredSignatories'>,\n    modifyingSigners: readonly MessageModifyingSigner[] = [],\n    partialSigners: readonly MessagePartialSigner[] = [],\n    config?: MessageModifyingSignerConfig,\n): Promise<OffchainMessageEnvelope> {\n    // @ts-expect-error SignableMessage should probably specify `ReadonlyUint8Array` here.\n    const offchainMessageEnvelope: SignableMessage = compileOffchainMessageEnvelope(offchainMessage);\n\n    // Handle modifying signers sequentially.\n    const modifiedOffchainMessage = await modifyingSigners.reduce(async (offchainMessageEnvelope, modifyingSigner) => {\n        config?.abortSignal?.throwIfAborted();\n        const [message] = await modifyingSigner.modifyAndSignMessages([await offchainMessageEnvelope], config);\n        return Object.freeze(message);\n    }, Promise.resolve(offchainMessageEnvelope));\n\n    // Handle partial signers in parallel.\n    config?.abortSignal?.throwIfAborted();\n    const signatureDictionaries = await Promise.all(\n        partialSigners.map(async partialSigner => {\n            const [signatures] = await partialSigner.signMessages([modifiedOffchainMessage], config);\n            return signatures;\n        }),\n    );\n\n    // @ts-expect-error SignableMessage should probably specify `ReadonlyUint8Array` here.\n    return Object.freeze({\n        ...modifiedOffchainMessage,\n        signatures: Object.freeze(\n            signatureDictionaries.reduce((signatures, signatureDictionary) => {\n                return { ...signatures, ...signatureDictionary };\n            }, modifiedOffchainMessage.signatures ?? {}),\n        ),\n    } as OffchainMessageEnvelope);\n}\n","import {\n    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,\n    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { getSignersFromTransactionMessage, TransactionMessageWithSigners } from './account-signer-meta';\nimport { isTransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner } from './transaction-sending-signer';\n\n/**\n * Defines a transaction message with exactly one {@link TransactionSendingSigner}.\n *\n * This type is used to narrow the type of transaction messages that have been\n * checked to have exactly one sending signer.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithSingleSendingSigner } from '@solana/signers';\n *\n * assertIsTransactionMessageWithSingleSendingSigner(transactionMessage);\n * transactionMessage satisfies TransactionMessageWithSingleSendingSigner;\n * ```\n *\n * @see {@link isTransactionMessageWithSingleSendingSigner}\n * @see {@link assertIsTransactionMessageWithSingleSendingSigner}\n */\nexport type TransactionMessageWithSingleSendingSigner = Brand<\n    TransactionMessageWithSigners,\n    'TransactionMessageWithSingleSendingSigner'\n>;\n\n/**\n * Checks whether the provided transaction has exactly one {@link TransactionSendingSigner}.\n *\n * This can be useful when using {@link signAndSendTransactionMessageWithSigners} to provide\n * a fallback strategy in case the transaction message cannot be send using this function.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import {\n *     isTransactionMessageWithSingleSendingSigner,\n *     signAndSendTransactionMessageWithSigners,\n *     signTransactionMessageWithSigners,\n * } from '@solana/signers';\n * import { getBase64EncodedWireTransaction } from '@solana/transactions';\n *\n * let transactionSignature: SignatureBytes;\n * if (isTransactionMessageWithSingleSendingSigner(transactionMessage)) {\n *     transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n * } else {\n *     const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);\n *     const encodedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n *     transactionSignature = await rpc.sendTransaction(encodedTransaction).send();\n * }\n * ```\n *\n * @see {@link signAndSendTransactionMessageWithSigners}\n * @see {@link assertIsTransactionMessageWithSingleSendingSigner}\n */\nexport function isTransactionMessageWithSingleSendingSigner<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(transaction: TTransactionMessage): transaction is TransactionMessageWithSingleSendingSigner & TTransactionMessage {\n    try {\n        assertIsTransactionMessageWithSingleSendingSigner(transaction);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Asserts that the provided transaction message has exactly one {@link TransactionSendingSigner}.\n *\n * This can be useful when using the {@link signAndSendTransactionMessageWithSigners} function\n * to ensure it will be able to select the correct signer to send the transaction.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import {\n *     assertIsTransactionMessageWithSingleSendingSigner,\n *     signAndSendTransactionMessageWithSigners\n * } from '@solana/signers';\n *\n * assertIsTransactionMessageWithSingleSendingSigner(transactionMessage);\n * const transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n * ```\n *\n * @see {@link signAndSendTransactionMessageWithSigners}\n * @see {@link isTransactionMessageWithSingleSendingSigner}\n */\nexport function assertIsTransactionMessageWithSingleSendingSigner<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(\n    transaction: TTransactionMessage,\n): asserts transaction is TransactionMessageWithSingleSendingSigner & TTransactionMessage {\n    const signers = getSignersFromTransactionMessage(transaction);\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n\n    if (sendingSigners.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n\n    // When identifying if there are multiple sending signers, we only need to check for\n    // sending signers that do not implement other transaction signer interfaces as\n    // they will be used as these other signer interfaces in case of a conflict.\n    const sendingOnlySigners = sendingSigners.filter(\n        signer => !isTransactionPartialSigner(signer) && !isTransactionModifyingSigner(signer),\n    );\n\n    if (sendingOnlySigners.length > 1) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS);\n    }\n}\n","import { SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\nimport {\n    assertIsFullySignedTransaction,\n    compileTransaction,\n    SendableTransaction,\n    Transaction,\n    TransactionWithinSizeLimit,\n    TransactionWithLifetime,\n} from '@solana/transactions';\n\nimport { getSignersFromTransactionMessage, TransactionMessageWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport {\n    isTransactionModifyingSigner,\n    TransactionModifyingSigner,\n    TransactionModifyingSignerConfig,\n} from './transaction-modifying-signer';\nimport {\n    isTransactionPartialSigner,\n    TransactionPartialSigner,\n    TransactionPartialSignerConfig,\n} from './transaction-partial-signer';\nimport {\n    isTransactionSendingSigner,\n    TransactionSendingSigner,\n    TransactionSendingSignerConfig,\n} from './transaction-sending-signer';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\nimport { assertIsTransactionMessageWithSingleSendingSigner } from './transaction-with-single-sending-signer';\n\n/**\n * Extracts all {@link TransactionSigner | TransactionSigners} inside the provided\n * transaction message and uses them to return a signed transaction.\n *\n * It first uses all {@link TransactionModifyingSigner | TransactionModifyingSigners} sequentially before\n * using all {@link TransactionPartialSigner | TransactionPartialSigners} in parallel.\n *\n * If a composite signer implements both interfaces, it will be used as a\n * {@link TransactionModifyingSigner} if no other signer implements that interface.\n * Otherwise, it will be used as a {@link TransactionPartialSigner}.\n *\n * @example\n * ```ts\n * const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage);\n * ```\n *\n * It also accepts an optional {@link AbortSignal} that will be propagated to all signers.\n *\n * ```ts\n * const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n * ```\n *\n * @remarks\n * Finally, note that this function ignores {@link TransactionSendingSigner | TransactionSendingSigners}\n * as it does not send the transaction. Check out the {@link signAndSendTransactionMessageWithSigners}\n * function for more details on how to use sending signers.\n *\n * @see {@link signTransactionMessageWithSigners}\n * @see {@link signAndSendTransactionMessageWithSigners}\n */\nexport async function partiallySignTransactionMessageWithSigners(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n    config?: TransactionPartialSignerConfig,\n): Promise<Transaction & TransactionWithinSizeLimit & TransactionWithLifetime> {\n    const { partialSigners, modifyingSigners } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransactionMessage(transactionMessage).filter(isTransactionSigner)),\n        { identifySendingSigner: false },\n    );\n\n    return await signModifyingAndPartialTransactionSigners(\n        transactionMessage,\n        modifyingSigners,\n        partialSigners,\n        config,\n    );\n}\n\n/**\n * Extracts all {@link TransactionSigner | TransactionSigners} inside the provided\n * transaction message and uses them to return a signed transaction before asserting\n * that all signatures required by the transaction are present.\n *\n * This function delegates to the {@link partiallySignTransactionMessageWithSigners} function\n * in order to extract signers from the transaction message and sign the transaction.\n *\n * @example\n * ```ts\n * const mySignedTransaction = await signTransactionMessageWithSigners(myTransactionMessage);\n *\n * // With additional config.\n * const mySignedTransaction = await signTransactionMessageWithSigners(myTransactionMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n *\n * // We now know the transaction is fully signed.\n * mySignedTransaction satisfies FullySignedTransaction;\n * ```\n *\n * @see {@link partiallySignTransactionMessageWithSigners}\n * @see {@link signAndSendTransactionMessageWithSigners}\n */\nexport async function signTransactionMessageWithSigners(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n    config?: TransactionPartialSignerConfig,\n): Promise<SendableTransaction & Transaction & TransactionWithLifetime> {\n    const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage, config);\n    assertIsFullySignedTransaction(signedTransaction);\n    return signedTransaction;\n}\n\n/**\n * Extracts all {@link TransactionSigner | TransactionSigners} inside the provided\n * transaction message and uses them to sign it before sending it immediately to the blockchain.\n *\n * It returns the signature of the sent transaction (i.e. its identifier) as bytes.\n *\n * @example\n * ```ts\n * import { signAndSendTransactionMessageWithSigners } from '@solana/signers';\n *\n * const transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n *\n * // With additional config.\n * const transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n * ```\n *\n * @remarks\n * Similarly to the {@link partiallySignTransactionMessageWithSigners} function, it first uses all\n * {@link TransactionModifyingSigner | TransactionModifyingSigners} sequentially before using all\n * {@link TransactionPartialSigner | TransactionPartialSigners} in parallel.\n * It then sends the transaction using the {@link TransactionSendingSigner} it identified.\n *\n * Composite transaction signers are treated such that at least one sending signer is used if any.\n * When a {@link TransactionSigner} implements more than one interface, we use it as a:\n *\n * - {@link TransactionSendingSigner}, if no other {@link TransactionSendingSigner} exists.\n * - {@link TransactionModifyingSigner}, if no other {@link TransactionModifyingSigner} exists.\n * - {@link TransactionPartialSigner}, otherwise.\n *\n * The provided transaction must contain exactly one {@link TransactionSendingSigner} inside its account metas.\n * If more than one composite signers implement the {@link TransactionSendingSigner} interface,\n * one of them will be selected as the sending signer. Otherwise, if multiple\n * {@link TransactionSendingSigner | TransactionSendingSigners} must be selected, the function will throw an error.\n *\n * If you'd like to assert that a transaction makes use of exactly one {@link TransactionSendingSigner}\n * _before_ calling this function, you may use the {@link assertIsTransactionMessageWithSingleSendingSigner} function.\n *\n * Alternatively, you may use the {@link isTransactionMessageWithSingleSendingSigner} function to provide a\n * fallback in case the transaction does not contain any sending signer.\n *\n * @see {@link assertIsTransactionMessageWithSingleSendingSigner}\n * @see {@link isTransactionMessageWithSingleSendingSigner}\n * @see {@link partiallySignTransactionMessageWithSigners}\n * @see {@link signTransactionMessageWithSigners}\n *\n */\nexport async function signAndSendTransactionMessageWithSigners(\n    transaction: BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n    config?: TransactionSendingSignerConfig,\n): Promise<SignatureBytes> {\n    assertIsTransactionMessageWithSingleSendingSigner(transaction);\n\n    const abortSignal = config?.abortSignal;\n    const { partialSigners, modifyingSigners, sendingSigner } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransactionMessage(transaction).filter(isTransactionSigner)),\n    );\n\n    abortSignal?.throwIfAborted();\n    const signedTransaction = await signModifyingAndPartialTransactionSigners(\n        transaction,\n        modifyingSigners,\n        partialSigners,\n        config,\n    );\n\n    if (!sendingSigner) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n\n    abortSignal?.throwIfAborted();\n    const [signature] = await sendingSigner.signAndSendTransactions([signedTransaction], config);\n    abortSignal?.throwIfAborted();\n\n    return signature;\n}\n\n/**\n * Identifies each provided TransactionSigner and categorizes them into their respective types.\n * When a signer implements multiple interface, it will try to used to most powerful interface\n * but fallback to the least powerful interface when necessary.\n * For instance, if a signer implements TransactionSendingSigner and TransactionModifyingSigner,\n * it will be categorized as a TransactionSendingSigner if and only if no other signers implement\n * the TransactionSendingSigner interface.\n */\nfunction categorizeTransactionSigners(\n    signers: readonly TransactionSigner[],\n    config: { identifySendingSigner?: boolean } = {},\n): Readonly<{\n    modifyingSigners: readonly TransactionModifyingSigner[];\n    partialSigners: readonly TransactionPartialSigner[];\n    sendingSigner: TransactionSendingSigner | null;\n}> {\n    // Identify the unique sending signer that should be used.\n    const identifySendingSigner = config.identifySendingSigner ?? true;\n    const sendingSigner = identifySendingSigner ? identifyTransactionSendingSigner(signers) : null;\n\n    // Now, focus on the other signers.\n    // I.e. the modifying or partial signers that are not the identified sending signer.\n    // Note that any other sending only signers will be discarded.\n    const otherSigners = signers.filter(\n        (signer): signer is TransactionModifyingSigner | TransactionPartialSigner =>\n            signer !== sendingSigner && (isTransactionModifyingSigner(signer) || isTransactionPartialSigner(signer)),\n    );\n\n    // Identify the modifying signers from the other signers.\n    const modifyingSigners = identifyTransactionModifyingSigners(otherSigners);\n\n    // Use any remaining signers as partial signers.\n    const partialSigners = otherSigners\n        .filter(isTransactionPartialSigner)\n        .filter(signer => !(modifyingSigners as typeof otherSigners).includes(signer));\n\n    return Object.freeze({ modifyingSigners, partialSigners, sendingSigner });\n}\n\n/** Identifies the best signer to use as a TransactionSendingSigner, if any */\nfunction identifyTransactionSendingSigner(signers: readonly TransactionSigner[]): TransactionSendingSigner | null {\n    // Ensure there are any TransactionSendingSigners in the first place.\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n    if (sendingSigners.length === 0) return null;\n\n    // Prefer sending signers that do not offer other interfaces.\n    const sendingOnlySigners = sendingSigners.filter(\n        signer => !isTransactionModifyingSigner(signer) && !isTransactionPartialSigner(signer),\n    );\n    if (sendingOnlySigners.length > 0) {\n        return sendingOnlySigners[0];\n    }\n\n    // Otherwise, choose any sending signer.\n    return sendingSigners[0];\n}\n\n/** Identifies the best signers to use as TransactionModifyingSigners, if any */\nfunction identifyTransactionModifyingSigners(\n    signers: readonly (TransactionModifyingSigner | TransactionPartialSigner)[],\n): readonly TransactionModifyingSigner[] {\n    // Ensure there are any TransactionModifyingSigner in the first place.\n    const modifyingSigners = signers.filter(isTransactionModifyingSigner);\n    if (modifyingSigners.length === 0) return [];\n\n    // Prefer modifying signers that do not offer partial signing.\n    const nonPartialSigners = modifyingSigners.filter(signer => !isTransactionPartialSigner(signer));\n    if (nonPartialSigners.length > 0) return nonPartialSigners;\n\n    // Otherwise, choose only one modifying signer (whichever).\n    return [modifyingSigners[0]];\n}\n\n/**\n * Signs a transaction using the provided TransactionModifyingSigners\n * sequentially followed by the TransactionPartialSigners in parallel.\n */\nasync function signModifyingAndPartialTransactionSigners(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n    modifyingSigners: readonly TransactionModifyingSigner[] = [],\n    partialSigners: readonly TransactionPartialSigner[] = [],\n    config?: TransactionModifyingSignerConfig,\n): Promise<Transaction & TransactionWithinSizeLimit & TransactionWithLifetime> {\n    // serialize the transaction\n    const transaction = compileTransaction(transactionMessage);\n\n    // Handle modifying signers sequentially.\n    const modifiedTransaction = (await modifyingSigners.reduce(\n        async (transaction, modifyingSigner) => {\n            config?.abortSignal?.throwIfAborted();\n            const [tx] = await modifyingSigner.modifyAndSignTransactions([await transaction], config);\n            return Object.freeze(tx);\n        },\n        Promise.resolve(transaction) as Promise<Readonly<Transaction & TransactionWithLifetime>>,\n    )) as Transaction & TransactionWithinSizeLimit & TransactionWithLifetime;\n\n    // Handle partial signers in parallel.\n    config?.abortSignal?.throwIfAborted();\n    const signatureDictionaries = await Promise.all(\n        partialSigners.map(async partialSigner => {\n            const [signatures] = await partialSigner.signTransactions([modifiedTransaction], config);\n            return signatures;\n        }),\n    );\n\n    return Object.freeze({\n        ...modifiedTransaction,\n        signatures: Object.freeze(\n            signatureDictionaries.reduce((signatures, signatureDictionary) => {\n                return { ...signatures, ...signatureDictionary };\n            }, modifiedTransaction.signatures ?? {}),\n        ),\n    });\n}\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import { TextEncoder } from '@solana/text-encoding-impl';\n\nimport { SignatureDictionary } from './types';\n\n/**\n * Defines a message that needs signing and its current set of signatures if any.\n *\n * This interface allows {@link MessageModifyingSigner | MessageModifyingSigners}\n * to decide on whether or not they should modify the provided message depending\n * on whether or not signatures already exist for such message.\n *\n * It also helps create a more consistent API by providing a structure analogous\n * to transactions which also keep track of their {@link SignatureDictionary}.\n *\n * @example\n * ```ts\n * import { createSignableMessage } from '@solana/signers';\n *\n * const message = createSignableMessage(new Uint8Array([1, 2, 3]));\n * message.content; // The content of the message as bytes.\n * message.signatures; // The current set of signatures for this message.\n * ```\n *\n * @see {@link createSignableMessage}\n */\nexport type SignableMessage = Readonly<{\n    content: Uint8Array;\n    signatures: SignatureDictionary;\n}>;\n\n/**\n * Creates a {@link SignableMessage} from a `Uint8Array` or a UTF-8 string.\n *\n * It optionally accepts a signature dictionary if the message already contains signatures.\n *\n * @example\n * ```ts\n * const message = createSignableMessage(new Uint8Array([1, 2, 3]));\n * const messageFromText = createSignableMessage('Hello world!');\n * const messageWithSignatures = createSignableMessage('Hello world!', {\n *     [address('1234..5678')]: new Uint8Array([1, 2, 3]) as SignatureBytes,\n * });\n * ```\n */\nexport function createSignableMessage(\n    content: Uint8Array | string,\n    signatures: SignatureDictionary = {},\n): SignableMessage {\n    return Object.freeze({\n        content: typeof content === 'string' ? new TextEncoder().encode(content) : content,\n        signatures: Object.freeze({ ...signatures }),\n    });\n}\n"],"names":["SolanaError","offchainMessageEnvelope","SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING","transaction","TextEncoder"],"mappings":"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"}},
    {"offset": {"line": 7514, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/rpc-spec-types/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-spec-types/src/parse-json-with-bigints.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-spec-types/src/rpc-message.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-spec-types/src/stringify-json-with-bigints.ts"],"sourcesContent":["/**\n * This function is a replacement for `JSON.parse` that can handle large\n * unsafe integers by parsing them as BigInts. It transforms every\n * numerical value into a BigInt without loss of precision.\n */\nexport function parseJsonWithBigInts(json: string): unknown {\n    return JSON.parse(wrapIntegersInBigIntValueObject(json), (_, value) => {\n        return isBigIntValueObject(value) ? unwrapBigIntValueObject(value) : value;\n    });\n}\n\nfunction wrapIntegersInBigIntValueObject(json: string): string {\n    const out = [];\n    let inQuote = false;\n    for (let ii = 0; ii < json.length; ii++) {\n        let isEscaped = false;\n        if (json[ii] === '\\\\') {\n            out.push(json[ii++]);\n            isEscaped = !isEscaped;\n        }\n        if (json[ii] === '\"') {\n            out.push(json[ii]);\n            if (!isEscaped) {\n                inQuote = !inQuote;\n            }\n            continue;\n        }\n        if (!inQuote) {\n            const consumedNumber = consumeNumber(json, ii);\n            if (consumedNumber?.length) {\n                ii += consumedNumber.length - 1;\n                // Don't wrap numbers that contain a decimal point or a negative exponent.\n                if (consumedNumber.match(/\\.|[eE]-/)) {\n                    out.push(consumedNumber);\n                } else {\n                    out.push(wrapBigIntValueObject(consumedNumber));\n                }\n                continue;\n            }\n        }\n        out.push(json[ii]);\n    }\n\n    return out.join('');\n}\n\nfunction consumeNumber(json: string, ii: number): string | null {\n    /** @see https://stackoverflow.com/a/13340826/11440277 */\n    const JSON_NUMBER_REGEX = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/;\n\n    // Stop early if the first character isn't a digit or a minus sign.\n    if (!json[ii]?.match(/[-\\d]/)) {\n        return null;\n    }\n\n    // Otherwise, check if the next characters form a valid JSON number.\n    const numberMatch = json.slice(ii).match(JSON_NUMBER_REGEX);\n    return numberMatch ? numberMatch[0] : null;\n}\n\ntype BigIntValueObject = {\n    // `$` implies 'this is a value object'.\n    // `n` implies 'interpret the value as a bigint'.\n    $n: string;\n};\n\nfunction wrapBigIntValueObject(value: string): string {\n    return `{\"$n\":\"${value}\"}`;\n}\n\nfunction unwrapBigIntValueObject({ $n }: BigIntValueObject): bigint {\n    if ($n.match(/[eE]/)) {\n        const [units, exponent] = $n.split(/[eE]/);\n        return BigInt(units) * BigInt(10) ** BigInt(exponent);\n    }\n    return BigInt($n);\n}\n\nfunction isBigIntValueObject(value: unknown): value is BigIntValueObject {\n    return !!value && typeof value === 'object' && '$n' in value && typeof value.$n === 'string';\n}\n","import { RpcRequest } from './rpc-request';\n\nlet _nextMessageId = 0n;\nfunction getNextMessageId(): string {\n    const id = _nextMessageId;\n    _nextMessageId++;\n    return id.toString();\n}\n\n/**\n * Returns a spec-compliant JSON RPC 2.0 message, given a method name and some params.\n *\n * Generates a new `id` on each call by incrementing a `bigint` and casting it to a string.\n */\nexport function createRpcMessage<TParams>(request: RpcRequest<TParams>) {\n    return {\n        id: getNextMessageId(),\n        jsonrpc: '2.0',\n        method: request.methodName,\n        params: request.params,\n    };\n}\n","/**\n * Transforms a value into a JSON string, whilst rendering bigints as large unsafe integers.\n */\nexport function stringifyJsonWithBigInts(value: unknown, space?: number | string): string {\n    return unwrapBigIntValueObject(\n        JSON.stringify(value, (_, v) => (typeof v === 'bigint' ? wrapBigIntValueObject(v) : v), space),\n    );\n}\n\ntype BigIntValueObject = {\n    // `$` implies 'this is a value object'.\n    // `n` implies 'interpret the value as a bigint'.\n    $n: string;\n};\n\nfunction wrapBigIntValueObject(value: bigint): BigIntValueObject {\n    return { $n: `${value}` };\n}\n\nfunction unwrapBigIntValueObject(value: string): string {\n    return value.replace(/\\{\\s*\"\\$n\"\\s*:\\s*\"(-?\\d+)\"\\s*\\}/g, '$1');\n}\n"],"names":["unwrapBigIntValueObject","wrapBigIntValueObject"],"mappings":"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"}},
    {"offset": {"line": 7615, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/rpc-spec/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-spec/src/rpc.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-spec/src/rpc-api.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-spec/src/rpc-transport.ts"],"sourcesContent":["import { SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD, SolanaError } from '@solana/errors';\nimport { Callable, Flatten, OverloadImplementations, UnionToIntersection } from '@solana/rpc-spec-types';\n\nimport { RpcApi, RpcPlan } from './rpc-api';\nimport { RpcTransport } from './rpc-transport';\n\nexport type RpcConfig<TRpcMethods, TRpcTransport extends RpcTransport> = Readonly<{\n    api: RpcApi<TRpcMethods>;\n    transport: TRpcTransport;\n}>;\n\n/**\n * An object that exposes all of the functions described by `TRpcMethods`.\n *\n * Calling each method returns a {@link PendingRpcRequest | PendingRpcRequest<TResponse>} where\n * `TResponse` is that method's response type.\n */\nexport type Rpc<TRpcMethods> = {\n    [TMethodName in keyof TRpcMethods]: PendingRpcRequestBuilder<OverloadImplementations<TRpcMethods, TMethodName>>;\n};\n\n/**\n * Pending requests are the result of calling a supported method on a {@link Rpc} object. They\n * encapsulate all of the information necessary to make the request without actually making it.\n *\n * Calling the {@link PendingRpcRequest.send | `send(options)`} method on a\n * {@link PendingRpcRequest | PendingRpcRequest<TResponse>} will trigger the request and return a\n * promise for `TResponse`.\n */\nexport type PendingRpcRequest<TResponse> = {\n    send(options?: RpcSendOptions): Promise<TResponse>;\n};\n\nexport type RpcSendOptions = Readonly<{\n    /**\n     * An optional signal that you can supply when triggering a {@link PendingRpcRequest} that you\n     * might later need to abort.\n     */\n    abortSignal?: AbortSignal;\n}>;\n\ntype PendingRpcRequestBuilder<TMethodImplementations> = UnionToIntersection<\n    Flatten<{\n        [P in keyof TMethodImplementations]: PendingRpcRequestReturnTypeMapper<TMethodImplementations[P]>;\n    }>\n>;\n\ntype PendingRpcRequestReturnTypeMapper<TMethodImplementation> =\n    // Check that this property of the TRpcMethods interface is, in fact, a function.\n    TMethodImplementation extends Callable\n        ? (...args: Parameters<TMethodImplementation>) => PendingRpcRequest<ReturnType<TMethodImplementation>>\n        : never;\n\n/**\n * Creates a {@link Rpc} instance given a {@link RpcApi | RpcApi<TRpcMethods>} and a\n * {@link RpcTransport} capable of fulfilling them.\n */\nexport function createRpc<TRpcMethods, TRpcTransport extends RpcTransport>(\n    rpcConfig: RpcConfig<TRpcMethods, TRpcTransport>,\n): Rpc<TRpcMethods> {\n    return makeProxy(rpcConfig);\n}\n\nfunction makeProxy<TRpcMethods, TRpcTransport extends RpcTransport>(\n    rpcConfig: RpcConfig<TRpcMethods, TRpcTransport>,\n): Rpc<TRpcMethods> {\n    return new Proxy(rpcConfig.api, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get(target, p, receiver) {\n            if (p === 'then') {\n                return undefined;\n            }\n            return function (...rawParams: unknown[]) {\n                const methodName = p.toString();\n                const getApiPlan = Reflect.get(target, methodName, receiver);\n                if (!getApiPlan) {\n                    throw new SolanaError(SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD, {\n                        method: methodName,\n                        params: rawParams,\n                    });\n                }\n                const apiPlan = getApiPlan(...rawParams);\n                return createPendingRpcRequest(rpcConfig, apiPlan);\n            };\n        },\n    }) as Rpc<TRpcMethods>;\n}\n\nfunction createPendingRpcRequest<TRpcMethods, TRpcTransport extends RpcTransport, TResponse>(\n    { transport }: RpcConfig<TRpcMethods, TRpcTransport>,\n    plan: RpcPlan<TResponse>,\n): PendingRpcRequest<TResponse> {\n    return {\n        async send(options?: RpcSendOptions): Promise<TResponse> {\n            return await plan.execute({ signal: options?.abortSignal, transport });\n        },\n    };\n}\n","import {\n    Callable,\n    createRpcMessage,\n    RpcRequestTransformer,\n    RpcResponse,\n    RpcResponseTransformer,\n} from '@solana/rpc-spec-types';\n\nimport type { RpcTransport } from './rpc-transport';\n\nexport type RpcApiConfig = Readonly<{\n    /**\n     * An optional function that transforms the {@link RpcRequest} before it is sent to the JSON RPC\n     * server.\n     *\n     * This is useful when the params supplied by the caller need to be transformed before\n     * forwarding the message to the server. Use cases for this include applying defaults,\n     * forwarding calls to renamed methods, and serializing complex values.\n     */\n    requestTransformer?: RpcRequestTransformer;\n    /**\n     * An optional function that transforms the {@link RpcResponse} before it is returned to the\n     * caller.\n     *\n     * Use cases for this include constructing complex data types from serialized data, and throwing\n     * exceptions.\n     */\n    responseTransformer?: RpcResponseTransformer;\n}>;\n\n/**\n * This type allows an {@link RpcApi} to describe how a particular request should be issued to the\n * JSON RPC server.\n *\n * Given a function that was called on a {@link Rpc}, this object exposes an `execute` function that\n * dictates which request will be sent, how the underlying transport will be used, and how the\n * responses will be transformed.\n *\n * This function accepts a {@link RpcTransport} and an `AbortSignal` and asynchronously returns a\n * {@link RpcResponse}. This gives us the opportunity to:\n *\n * - define the `payload` from the requested method name and parameters before passing it to the\n *   transport.\n * - call the underlying transport zero, one or multiple times depending on the use-case (e.g.\n *   caching or aggregating multiple responses).\n * - transform the response from the JSON RPC server, in case it does not match the `TResponse`\n *   specified by the {@link PendingRpcRequest | PendingRpcRequest<TResponse>} returned from that\n *   function.\n */\nexport type RpcPlan<TResponse> = {\n    execute: (\n        config: Readonly<{\n            signal?: AbortSignal;\n            transport: RpcTransport;\n        }>,\n    ) => Promise<RpcResponse<TResponse>>;\n};\n\n/**\n * For each of `TRpcMethods`, this object exposes a method with the same name that maps between its\n * input arguments and a {@link RpcPlan | RpcPlan<TResponse>} that implements the execution of a\n * JSON RPC request to fetch `TResponse`.\n */\nexport type RpcApi<TRpcMethods> = {\n    [MethodName in keyof TRpcMethods]: RpcReturnTypeMapper<TRpcMethods[MethodName]>;\n};\n\ntype RpcReturnTypeMapper<TRpcMethod> = TRpcMethod extends Callable\n    ? (...rawParams: unknown[]) => RpcPlan<ReturnType<TRpcMethod>>\n    : never;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RpcApiMethod = (...args: any) => any;\ninterface RpcApiMethods {\n    [methodName: string]: RpcApiMethod;\n}\n\n/**\n * Creates a JavaScript proxy that converts _any_ function call called on it to a {@link RpcPlan} by\n * creating an `execute` function that:\n *\n * - sets the transport payload to a JSON RPC v2 payload object with the requested `methodName` and\n *   `params` properties, optionally transformed by {@link RpcApiConfig.requestTransformer}.\n * - transforms the transport's response using the {@link RpcApiConfig.responseTransformer}\n *   function, if provided.\n *\n * @example\n * ```ts\n * // For example, given this `RpcApi`:\n * const rpcApi = createJsonRpcApi({\n *     requestTransformer: (...rawParams) => rawParams.reverse(),\n *     responseTransformer: response => response.result,\n * });\n *\n * // ...the following function call:\n * rpcApi.foo('bar', { baz: 'bat' });\n *\n * // ...will produce a `RpcPlan` that:\n * // -   Uses the following payload: { id: 1, jsonrpc: '2.0', method: 'foo', params: [{ baz: 'bat' }, 'bar'] }.\n * // -   Returns the \"result\" property of the RPC response.\n * ```\n */\nexport function createJsonRpcApi<TRpcMethods extends RpcApiMethods>(config?: RpcApiConfig): RpcApi<TRpcMethods> {\n    return new Proxy({} as RpcApi<TRpcMethods>, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get<TMethodName extends keyof RpcApi<TRpcMethods>>(\n            ...args: Parameters<NonNullable<ProxyHandler<RpcApi<TRpcMethods>>['get']>>\n        ) {\n            const [_, p] = args;\n            const methodName = p.toString() as keyof TRpcMethods as string;\n            return function (\n                ...rawParams: Parameters<\n                    TRpcMethods[TMethodName] extends CallableFunction ? TRpcMethods[TMethodName] : never\n                >\n            ): RpcPlan<ReturnType<TRpcMethods[TMethodName]>> {\n                const rawRequest = Object.freeze({ methodName, params: rawParams });\n                const request = config?.requestTransformer ? config?.requestTransformer(rawRequest) : rawRequest;\n                return Object.freeze(<RpcPlan<ReturnType<TRpcMethods[TMethodName]>>>{\n                    execute: async ({ signal, transport }) => {\n                        const payload = createRpcMessage(request);\n                        const response = await transport({ payload, signal });\n                        if (!config?.responseTransformer) {\n                            return response;\n                        }\n                        return config.responseTransformer(response, request);\n                    },\n                });\n            };\n        },\n    });\n}\n","import { RpcResponse } from '@solana/rpc-spec-types';\n\ntype Config = Readonly<{\n    /** A value of arbitrary type to be sent to a RPC server */\n    payload: unknown;\n    /**\n     * An optional `AbortSignal` on which the `'abort'` event will be fired if the request should be\n     * cancelled.\n     */\n    signal?: AbortSignal;\n}>;\n\n/**\n * A function that can act as a transport for a {@link Rpc}. It need only return a promise for a\n * response given the supplied config.\n */\nexport type RpcTransport = {\n    <TResponse>(config: Config): Promise<RpcResponse<TResponse>>;\n};\n\n/**\n * Returns `true` if the given payload is a JSON RPC v2 payload.\n *\n * This means, the payload is an object such that:\n *\n * - It has a `jsonrpc` property with a value of `'2.0'`.\n * - It has a `method` property that is a string.\n * - It has a `params` property of any type.\n *\n * @example\n * ```ts\n * import { isJsonRpcPayload } from '@solana/rpc-spec';\n *\n * if (isJsonRpcPayload(payload)) {\n *     const payloadMethod: string = payload.method;\n *     const payloadParams: unknown = payload.params;\n * }\n * ```\n */\nexport function isJsonRpcPayload(payload: unknown): payload is Readonly<{\n    jsonrpc: '2.0';\n    method: string;\n    params: unknown;\n}> {\n    if (payload == null || typeof payload !== 'object' || Array.isArray(payload)) {\n        return false;\n    }\n    return (\n        'jsonrpc' in payload &&\n        payload.jsonrpc === '2.0' &&\n        'method' in payload &&\n        typeof payload.method === 'string' &&\n        'params' in payload\n    );\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAyDO,SAAS,UACZ,SAAA,EACgB;IAChB,OAAO,UAAU,SAAS,CAAA;AAC9B;AAEA,SAAS,UACL,SAAA,EACgB;IAChB,OAAO,IAAI,KAAA,CAAM,SAAA,CAAU,GAAA,EAAK;QAC5B,cAAA,GAAiB;YACb,OAAO,KAAA;QACX,CAAA;QACA,cAAA,GAAiB;YACb,OAAO,KAAA;QACX,CAAA;QACA,GAAA,EAAI,MAAA,EAAQ,CAAA,EAAG,QAAA,EAAU;YACrB,IAAI,MAAM,MAAA,EAAQ;gBACd,OAAO,KAAA,CAAA;YACX;YACA,OAAO,SAAA,GAAa,SAAA,EAAsB;gBACtC,MAAM,UAAA,GAAa,EAAE,QAAA,EAAS;gBAC9B,MAAM,UAAA,GAAa,OAAA,CAAQ,GAAA,CAAI,MAAA,EAAQ,YAAY,QAAQ,CAAA;gBAC3D,IAAI,CAAC,UAAA,EAAY;oBACb,MAAM,IAAI,iLAAA,CAAY,wNAAA,EAAoD;wBACtE,MAAA,EAAQ,UAAA;wBACR,MAAA,EAAQ;oBAAA,CACX,CAAA;gBACL;gBACA,MAAM,OAAA,GAAU,UAAA,CAAW,GAAG,SAAS,CAAA;gBACvC,OAAO,uBAAA,CAAwB,WAAW,OAAO,CAAA;YACrD,CAAA;QACJ;IAAA,CACH,CAAA;AACL;AAEA,SAAS,uBAAA,CACL,EAAE,SAAA,EAAU,EACZ,IAAA,EAC4B;IAC5B,OAAO;QACH,MAAM,MAAK,OAAA,EAA8C;YACrD,OAAO,MAAM,KAAK,OAAA,CAAQ;gBAAE,QAAQ,OAAA,EAAS,WAAA;gBAAa;YAAA,CAAW,CAAA;QACzE;IAAA,CACJ;AACJ;ACAO,SAAS,iBAAoD,MAAA,EAA4C;IAC5G,OAAO,IAAI,KAAA,CAAM,CAAA,CAAC,EAA0B;QACxC,cAAA,GAAiB;YACb,OAAO,KAAA;QACX,CAAA;QACA,cAAA,GAAiB;YACb,OAAO,KAAA;QACX,CAAA;QACA,KAAA,GACO,IAAA,EACL;YACE,MAAM,CAAC,CAAA,EAAG,CAAC,CAAA,GAAI,IAAA;YACf,MAAM,UAAA,GAAa,EAAE,QAAA,EAAS;YAC9B,OAAO,SAAA,GACA,SAAA,EAG0C;gBAC7C,MAAM,aAAa,MAAA,CAAO,MAAA,CAAO;oBAAE,UAAA;oBAAY,MAAA,EAAQ;gBAAA,CAAW,CAAA;gBAClE,MAAM,UAAU,MAAA,EAAQ,kBAAA,GAAqB,MAAA,EAAQ,kBAAA,CAAmB,UAAU,CAAA,GAAI,UAAA;gBACtF,OAAO,OAAO,MAAA,CAAsD;oBAChE,OAAA,EAAS,OAAO,EAAE,MAAA,EAAQ,SAAA,EAAU,KAAM;wBACtC,MAAM,OAAA,OAAU,oMAAA,EAAiB,OAAO,CAAA;wBACxC,MAAM,WAAW,MAAM,SAAA,CAAU;4BAAE,OAAA;4BAAS;wBAAA,CAAQ,CAAA;wBACpD,IAAI,CAAC,QAAQ,mBAAA,EAAqB;4BAC9B,OAAO,QAAA;wBACX;wBACA,OAAO,MAAA,CAAO,mBAAA,CAAoB,QAAA,EAAU,OAAO,CAAA;oBACvD;gBAAA,CACH,CAAA;YACL,CAAA;QACJ;IAAA,CACH,CAAA;AACL;;AChGO,SAAS,iBAAiB,OAAA,EAI9B;IACC,IAAI,OAAA,IAAW,QAAQ,OAAO,OAAA,KAAY,YAAY,KAAA,CAAM,OAAA,CAAQ,OAAO,CAAA,EAAG;QAC1E,OAAO,KAAA;IACX;IACA,OACI,SAAA,IAAa,OAAA,IACb,OAAA,CAAQ,OAAA,KAAY,KAAA,IACpB,QAAA,IAAY,OAAA,IACZ,OAAO,OAAA,CAAQ,MAAA,KAAW,QAAA,IAC1B,QAAA,IAAY,OAAA;AAEpB"}},
    {"offset": {"line": 7716, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/rpc-transformers/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-transformers/src/request-transformer-bigint-downcast-internal.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-transformers/src/tree-traversal.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-transformers/src/request-transformer-bigint-downcast.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-transformers/src/request-transformer-default-commitment-internal.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-transformers/src/request-transformer-default-commitment.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-transformers/src/request-transformer-integer-overflow-internal.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-transformers/src/request-transformer-integer-overflow.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-transformers/src/request-transformer-options-object-position-config.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-transformers/src/request-transformer.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-transformers/src/response-transformer-bigint-upcast-internal.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-transformers/src/response-transformer-bigint-upcast.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-transformers/src/response-transformer-result.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-transformers/src/response-transformer-throw-solana-error.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-transformers/src/response-transformer.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-transformers/src/response-transformer-allowed-numeric-values.ts"],"sourcesContent":["export function downcastNodeToNumberIfBigint(value: bigint): number;\nexport function downcastNodeToNumberIfBigint<T>(value: T): T;\nexport function downcastNodeToNumberIfBigint(value: unknown): unknown {\n    return typeof value === 'bigint'\n        ? // FIXME(solana-labs/solana/issues/30341) Create a data type to represent u64 in the Solana\n          // JSON RPC implementation so that we can throw away this entire patcher instead of unsafely\n          // downcasting `bigints` to `numbers`.\n          Number(value)\n        : value;\n}\n","import { RpcRequest, RpcRequestTransformer, RpcResponseTransformer } from '@solana/rpc-spec-types';\n\nexport type KeyPathWildcard = { readonly ['__keyPathWildcard:@solana/kit']: unique symbol };\nexport type KeyPath = ReadonlyArray<KeyPath | KeyPathWildcard | number | string>;\n\nexport const KEYPATH_WILDCARD = {} as KeyPathWildcard;\n\ntype NodeVisitor = <TState extends TraversalState>(value: unknown, state: TState) => unknown;\nexport type TraversalState = Readonly<{\n    keyPath: KeyPath;\n}>;\n\nfunction getTreeWalker(visitors: NodeVisitor[]) {\n    return function traverse<TState extends TraversalState>(node: unknown, state: TState): unknown {\n        if (Array.isArray(node)) {\n            return node.map((element, ii) => {\n                const nextState = {\n                    ...state,\n                    keyPath: [...state.keyPath, ii],\n                };\n                return traverse(element, nextState);\n            });\n        } else if (typeof node === 'object' && node !== null) {\n            const out: Record<number | string | symbol, unknown> = {};\n            for (const propName in node) {\n                if (!Object.prototype.hasOwnProperty.call(node, propName)) {\n                    continue;\n                }\n                const nextState = {\n                    ...state,\n                    keyPath: [...state.keyPath, propName],\n                };\n                out[propName] = traverse(node[propName as keyof typeof node], nextState);\n            }\n            return out;\n        } else {\n            return visitors.reduce((acc, visitNode) => visitNode(acc, state), node);\n        }\n    };\n}\n\n/**\n * Creates a transformer that traverses the request parameters and executes the provided visitors at\n * each node. A custom initial state can be provided but must at least provide `{ keyPath: [] }`.\n *\n * @example\n * ```ts\n * import { getTreeWalkerRequestTransformer } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getTreeWalkerRequestTransformer(\n *     [\n *         // Replaces foo.bar with \"baz\".\n *         (node, state) => (state.keyPath === ['foo', 'bar'] ? 'baz' : node),\n *         // Increments all numbers by 1.\n *         node => (typeof node === number ? node + 1 : node),\n *     ],\n *     { keyPath: [] },\n * );\n * ```\n */\nexport function getTreeWalkerRequestTransformer<TState extends TraversalState>(\n    visitors: NodeVisitor[],\n    initialState: TState,\n): RpcRequestTransformer {\n    return <TParams>(request: RpcRequest<TParams>): RpcRequest => {\n        const traverse = getTreeWalker(visitors);\n        return Object.freeze({\n            ...request,\n            params: traverse(request.params, initialState),\n        });\n    };\n}\n\nexport function getTreeWalkerResponseTransformer<TState extends TraversalState>(\n    visitors: NodeVisitor[],\n    initialState: TState,\n): RpcResponseTransformer {\n    return json => getTreeWalker(visitors)(json, initialState);\n}\n","import { downcastNodeToNumberIfBigint } from './request-transformer-bigint-downcast-internal';\nimport { getTreeWalkerRequestTransformer } from './tree-traversal';\n\n/**\n * Creates a transformer that downcasts all `BigInt` values to `Number`.\n *\n * @example\n * ```ts\n * import { getBigIntDowncastRequestTransformer } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getBigIntDowncastRequestTransformer();\n * ```\n *\n */\nexport function getBigIntDowncastRequestTransformer() {\n    return getTreeWalkerRequestTransformer([downcastNodeToNumberIfBigint], { keyPath: [] });\n}\n","import { Commitment } from '@solana/rpc-types';\n\nexport function applyDefaultCommitment({\n    commitmentPropertyName,\n    params,\n    optionsObjectPositionInParams,\n    overrideCommitment,\n}: Readonly<{\n    commitmentPropertyName: string;\n    optionsObjectPositionInParams: number;\n    overrideCommitment?: Commitment;\n    params: unknown[];\n}>) {\n    const paramInTargetPosition = params[optionsObjectPositionInParams];\n    if (\n        // There's no config.\n        paramInTargetPosition === undefined ||\n        // There is a config object.\n        (paramInTargetPosition && typeof paramInTargetPosition === 'object' && !Array.isArray(paramInTargetPosition))\n    ) {\n        if (\n            // The config object already has a commitment set.\n            paramInTargetPosition &&\n            commitmentPropertyName in paramInTargetPosition\n        ) {\n            if (\n                !paramInTargetPosition[commitmentPropertyName as keyof typeof paramInTargetPosition] ||\n                paramInTargetPosition[commitmentPropertyName as keyof typeof paramInTargetPosition] === 'finalized'\n            ) {\n                // Delete the commitment property; `finalized` is already the server default.\n                const nextParams = [...params];\n                const {\n                    [commitmentPropertyName as keyof typeof paramInTargetPosition]: _, // eslint-disable-line @typescript-eslint/no-unused-vars\n                    ...rest\n                } = paramInTargetPosition;\n                if (Object.keys(rest).length > 0) {\n                    nextParams[optionsObjectPositionInParams] = rest;\n                } else {\n                    if (optionsObjectPositionInParams === nextParams.length - 1) {\n                        nextParams.length--;\n                    } else {\n                        nextParams[optionsObjectPositionInParams] = undefined;\n                    }\n                }\n                return nextParams;\n            }\n        } else if (overrideCommitment !== 'finalized') {\n            // Apply the default commitment.\n            const nextParams = [...params];\n            nextParams[optionsObjectPositionInParams] = {\n                ...paramInTargetPosition,\n                [commitmentPropertyName]: overrideCommitment,\n            };\n            return nextParams;\n        }\n    }\n    return params;\n}\n","import type { RpcRequest, RpcRequestTransformer } from '@solana/rpc-spec-types';\nimport type { Commitment } from '@solana/rpc-types';\n\nimport { applyDefaultCommitment } from './request-transformer-default-commitment-internal';\n\n/**\n * Creates a transformer that adds the provided default commitment to the configuration object of the request when applicable.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { getDefaultCommitmentRequestTransformer, OPTIONS_OBJECT_POSITION_BY_METHOD } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getDefaultCommitmentRequestTransformer({\n *     defaultCommitment: 'confirmed',\n *     optionsObjectPositionByMethod: OPTIONS_OBJECT_POSITION_BY_METHOD,\n * });\n */\nexport function getDefaultCommitmentRequestTransformer({\n    defaultCommitment,\n    optionsObjectPositionByMethod,\n}: Readonly<{\n    defaultCommitment?: Commitment;\n    optionsObjectPositionByMethod: Record<string, number>;\n}>): RpcRequestTransformer {\n    return <TParams>(request: RpcRequest<TParams>): RpcRequest => {\n        const { params, methodName } = request;\n\n        // We only apply default commitment to array parameters.\n        if (!Array.isArray(params)) {\n            return request;\n        }\n\n        // Find the position of the options object in the parameters and abort if not found.\n        const optionsObjectPositionInParams = optionsObjectPositionByMethod[methodName];\n        if (optionsObjectPositionInParams == null) {\n            return request;\n        }\n\n        return Object.freeze({\n            methodName,\n            params: applyDefaultCommitment({\n                commitmentPropertyName: methodName === 'sendTransaction' ? 'preflightCommitment' : 'commitment',\n                optionsObjectPositionInParams,\n                overrideCommitment: defaultCommitment,\n                params,\n            }),\n        });\n    };\n}\n","import { KeyPath, TraversalState } from './tree-traversal';\n\nexport function getIntegerOverflowNodeVisitor(onIntegerOverflow: (keyPath: KeyPath, value: bigint) => void) {\n    return <T>(value: T, { keyPath }: TraversalState): T => {\n        if (typeof value === 'bigint') {\n            if (onIntegerOverflow && (value > Number.MAX_SAFE_INTEGER || value < -Number.MAX_SAFE_INTEGER)) {\n                onIntegerOverflow(keyPath as (number | string)[], value);\n            }\n        }\n        return value;\n    };\n}\n","import { RpcRequest } from '@solana/rpc-spec-types';\n\nimport { getIntegerOverflowNodeVisitor } from './request-transformer-integer-overflow-internal';\nimport { getTreeWalkerRequestTransformer, KeyPath } from './tree-traversal';\n\nexport type IntegerOverflowHandler = (request: RpcRequest, keyPath: KeyPath, value: bigint) => void;\n\n/**\n * Creates a transformer that traverses the request parameters and executes the provided handler\n * when an integer overflow is detected.\n *\n * @example\n * ```ts\n * import { getIntegerOverflowRequestTransformer } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getIntegerOverflowRequestTransformer((request, keyPath, value) => {\n *     throw new Error(`Integer overflow at ${keyPath.join('.')}: ${value}`);\n * });\n * ```\n */\nexport function getIntegerOverflowRequestTransformer(onIntegerOverflow: IntegerOverflowHandler) {\n    return <TParams>(request: RpcRequest<TParams>): RpcRequest => {\n        const transformer = getTreeWalkerRequestTransformer(\n            [getIntegerOverflowNodeVisitor((...args) => onIntegerOverflow(request, ...args))],\n            { keyPath: [] },\n        );\n        return transformer(request);\n    };\n}\n","export const OPTIONS_OBJECT_POSITION_BY_METHOD: Record<string, number> = {\n    accountNotifications: 1,\n    blockNotifications: 1,\n    getAccountInfo: 1,\n    getBalance: 1,\n    getBlock: 1,\n    getBlockHeight: 0,\n    getBlockProduction: 0,\n    getBlocks: 2,\n    getBlocksWithLimit: 2,\n    getEpochInfo: 0,\n    getFeeForMessage: 1,\n    getInflationGovernor: 0,\n    getInflationReward: 1,\n    getLargestAccounts: 0,\n    getLatestBlockhash: 0,\n    getLeaderSchedule: 1,\n    getMinimumBalanceForRentExemption: 1,\n    getMultipleAccounts: 1,\n    getProgramAccounts: 1,\n    getSignaturesForAddress: 1,\n    getSlot: 0,\n    getSlotLeader: 0,\n    getStakeMinimumDelegation: 0,\n    getSupply: 0,\n    getTokenAccountBalance: 1,\n    getTokenAccountsByDelegate: 2,\n    getTokenAccountsByOwner: 2,\n    getTokenLargestAccounts: 1,\n    getTokenSupply: 1,\n    getTransaction: 1,\n    getTransactionCount: 0,\n    getVoteAccounts: 0,\n    isBlockhashValid: 1,\n    logsNotifications: 1,\n    programNotifications: 1,\n    requestAirdrop: 2,\n    sendTransaction: 1,\n    signatureNotifications: 1,\n    simulateTransaction: 1,\n};\n","import { pipe } from '@solana/functional';\nimport { RpcRequest, RpcRequestTransformer } from '@solana/rpc-spec-types';\nimport { Commitment } from '@solana/rpc-types';\n\nimport { getBigIntDowncastRequestTransformer } from './request-transformer-bigint-downcast';\nimport { getDefaultCommitmentRequestTransformer } from './request-transformer-default-commitment';\nimport { getIntegerOverflowRequestTransformer, IntegerOverflowHandler } from './request-transformer-integer-overflow';\nimport { OPTIONS_OBJECT_POSITION_BY_METHOD } from './request-transformer-options-object-position-config';\n\nexport type RequestTransformerConfig = Readonly<{\n    /**\n     * An optional {@link Commitment} value to use as the default when none is supplied by the\n     * caller.\n     */\n    defaultCommitment?: Commitment;\n    /**\n     * An optional function that will be called whenever a `bigint` input exceeds that which can be\n     * expressed using JavaScript numbers.\n     *\n     * This is used in the default {@link SolanaRpcSubscriptionsApi} to throw an exception rather\n     * than to allow truncated values to propagate through a program.\n     */\n    onIntegerOverflow?: IntegerOverflowHandler;\n}>;\n\n/**\n * Returns the default request transformer for the Solana RPC API.\n *\n * Under the hood, this function composes multiple\n * {@link RpcRequestTransformer | RpcRequestTransformers} together such as the\n * {@link getDefaultCommitmentTransformer}, the {@link getIntegerOverflowRequestTransformer} and the\n * {@link getBigIntDowncastRequestTransformer}.\n *\n * @example\n * ```ts\n * import { getDefaultRequestTransformerForSolanaRpc } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getDefaultRequestTransformerForSolanaRpc({\n *     defaultCommitment: 'confirmed',\n *     onIntegerOverflow: (request, keyPath, value) => {\n *         throw new Error(`Integer overflow at ${keyPath.join('.')}: ${value}`);\n *     },\n * });\n * ```\n */\nexport function getDefaultRequestTransformerForSolanaRpc(config?: RequestTransformerConfig): RpcRequestTransformer {\n    const handleIntegerOverflow = config?.onIntegerOverflow;\n    return (request: RpcRequest): RpcRequest => {\n        return pipe(\n            request,\n            handleIntegerOverflow ? getIntegerOverflowRequestTransformer(handleIntegerOverflow) : r => r,\n            getBigIntDowncastRequestTransformer(),\n            getDefaultCommitmentRequestTransformer({\n                defaultCommitment: config?.defaultCommitment,\n                optionsObjectPositionByMethod: OPTIONS_OBJECT_POSITION_BY_METHOD,\n            }),\n        );\n    };\n}\n","import { KeyPath, KEYPATH_WILDCARD, TraversalState } from './tree-traversal';\n\nexport function getBigIntUpcastVisitor(allowedNumericKeyPaths: readonly KeyPath[]) {\n    return function upcastNodeToBigIntIfNumber(value: unknown, { keyPath }: TraversalState) {\n        const isInteger = (typeof value === 'number' && Number.isInteger(value)) || typeof value === 'bigint';\n        if (!isInteger) return value;\n        if (keyPathIsAllowedToBeNumeric(keyPath, allowedNumericKeyPaths)) {\n            return Number(value);\n        } else {\n            return BigInt(value);\n        }\n    };\n}\n\nfunction keyPathIsAllowedToBeNumeric(keyPath: KeyPath, allowedNumericKeyPaths: readonly KeyPath[]) {\n    return allowedNumericKeyPaths.some(prohibitedKeyPath => {\n        if (prohibitedKeyPath.length !== keyPath.length) {\n            return false;\n        }\n        for (let ii = keyPath.length - 1; ii >= 0; ii--) {\n            const keyPathPart = keyPath[ii];\n            const prohibitedKeyPathPart = prohibitedKeyPath[ii];\n            if (\n                prohibitedKeyPathPart !== keyPathPart &&\n                (prohibitedKeyPathPart !== KEYPATH_WILDCARD || typeof keyPathPart !== 'number')\n            ) {\n                return false;\n            }\n        }\n        return true;\n    });\n}\n","import { getBigIntUpcastVisitor } from './response-transformer-bigint-upcast-internal';\nimport { getTreeWalkerResponseTransformer, KeyPath } from './tree-traversal';\n\n/**\n * Returns a transformer that upcasts all `Number` values to `BigInts` unless they match within the\n * provided {@link KeyPath | KeyPaths}. In other words, the provided {@link KeyPath | KeyPaths} will\n * remain as `Number` values, any other numeric value will be upcasted to a `BigInt`.\n *\n * Note that you can use {@link KEYPATH_WILDCARD} to match any key within a {@link KeyPath}.\n *\n * @example\n * ```ts\n * import { getBigIntUpcastResponseTransformer } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getBigIntUpcastResponseTransformer([\n *     ['index'],\n *     ['instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n *     ['instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n *     ['instructions', KEYPATH_WILDCARD, 'stackHeight'],\n * ]);\n * ```\n */\nexport function getBigIntUpcastResponseTransformer(allowedNumericKeyPaths: readonly KeyPath[]) {\n    return getTreeWalkerResponseTransformer([getBigIntUpcastVisitor(allowedNumericKeyPaths)], { keyPath: [] });\n}\n","import { RpcResponseTransformer } from '@solana/rpc-spec-types';\n\ntype JsonRpcResponse = { result: unknown };\n\n/**\n * Returns a transformer that extracts the `result` field from the body of the RPC response.\n *\n * For instance, we go from `{ jsonrpc: '2.0', result: 'foo', id: 1 }` to `'foo'`.\n *\n * @example\n * ```ts\n * import { getResultResponseTransformer } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getResultResponseTransformer();\n * ```\n */\nexport function getResultResponseTransformer(): RpcResponseTransformer {\n    return json => (json as JsonRpcResponse).result;\n}\n","import { getSolanaErrorFromJsonRpcError } from '@solana/errors';\nimport { RpcResponseTransformer } from '@solana/rpc-spec-types';\n\ntype JsonRpcResponse = { error: Parameters<typeof getSolanaErrorFromJsonRpcError>[0] } | { result: unknown };\n\n/**\n * Returns a transformer that throws a {@link SolanaError} with the appropriate RPC error code if\n * the body of the RPC response contains an error.\n *\n * @example\n * ```ts\n * import { getThrowSolanaErrorResponseTransformer } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getThrowSolanaErrorResponseTransformer();\n * ```\n */\nexport function getThrowSolanaErrorResponseTransformer(): RpcResponseTransformer {\n    return json => {\n        const jsonRpcResponse = json as JsonRpcResponse;\n        if ('error' in jsonRpcResponse) {\n            throw getSolanaErrorFromJsonRpcError(jsonRpcResponse.error);\n        }\n        return jsonRpcResponse;\n    };\n}\n","import { pipe } from '@solana/functional';\nimport { RpcRequest, RpcResponse, RpcResponseTransformer } from '@solana/rpc-spec-types';\n\nimport { AllowedNumericKeypaths } from './response-transformer-allowed-numeric-values';\nimport { getBigIntUpcastResponseTransformer } from './response-transformer-bigint-upcast';\nimport { getResultResponseTransformer } from './response-transformer-result';\nimport { getThrowSolanaErrorResponseTransformer } from './response-transformer-throw-solana-error';\n\nexport type ResponseTransformerConfig<TApi> = Readonly<{\n    /**\n     * An optional map from the name of an API method to an array of {@link KeyPath | KeyPaths}\n     * pointing to values in the response that should materialize in the application as `Number`\n     * instead of `BigInt`.\n     */\n    allowedNumericKeyPaths?: AllowedNumericKeypaths<TApi>;\n}>;\n\n/**\n * Returns the default response transformer for the Solana RPC API.\n *\n * Under the hood, this function composes multiple\n * {@link RpcResponseTransformer | RpcResponseTransformers} together such as the\n * {@link getThrowSolanaErrorResponseTransformer}, the {@link getResultResponseTransformer} and the\n * {@link getBigIntUpcastResponseTransformer}.\n *\n * @example\n * ```ts\n * import { getDefaultResponseTransformerForSolanaRpc } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getDefaultResponseTransformerForSolanaRpc({\n *     allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n * });\n * ```\n */\nexport function getDefaultResponseTransformerForSolanaRpc<TApi>(\n    config?: ResponseTransformerConfig<TApi>,\n): RpcResponseTransformer {\n    return (response: RpcResponse, request: RpcRequest): RpcResponse => {\n        const methodName = request.methodName as keyof TApi;\n        const keyPaths =\n            config?.allowedNumericKeyPaths && methodName ? config.allowedNumericKeyPaths[methodName] : undefined;\n        return pipe(\n            response,\n            r => getThrowSolanaErrorResponseTransformer()(r, request),\n            r => getResultResponseTransformer()(r, request),\n            r => getBigIntUpcastResponseTransformer(keyPaths ?? [])(r, request),\n        );\n    };\n}\n\n/**\n * Returns the default response transformer for the Solana RPC Subscriptions API.\n *\n * Under the hood, this function composes the {@link getBigIntUpcastResponseTransformer}.\n *\n * @example\n * ```ts\n * import { getDefaultResponseTransformerForSolanaRpcSubscriptions } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getDefaultResponseTransformerForSolanaRpcSubscriptions({\n *     allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n * });\n * ```\n */\nexport function getDefaultResponseTransformerForSolanaRpcSubscriptions<TApi>(\n    config?: ResponseTransformerConfig<TApi>,\n): RpcResponseTransformer {\n    return (response: RpcResponse, request: RpcRequest): RpcResponse => {\n        const methodName = request.methodName as keyof TApi;\n        const keyPaths =\n            config?.allowedNumericKeyPaths && methodName ? config.allowedNumericKeyPaths[methodName] : undefined;\n        return pipe(response, r => getBigIntUpcastResponseTransformer(keyPaths ?? [])(r, request));\n    };\n}\n","import { KeyPath, KEYPATH_WILDCARD } from './tree-traversal';\n\nexport type AllowedNumericKeypaths<TApi> = Partial<Record<keyof TApi, readonly KeyPath[]>>;\n\n// Numeric values nested in `jsonParsed` accounts\nexport const jsonParsedTokenAccountsConfigs = [\n    // parsed Token/Token22 token account\n    ['data', 'parsed', 'info', 'tokenAmount', 'decimals'],\n    ['data', 'parsed', 'info', 'tokenAmount', 'uiAmount'],\n    ['data', 'parsed', 'info', 'rentExemptReserve', 'decimals'],\n    ['data', 'parsed', 'info', 'rentExemptReserve', 'uiAmount'],\n    ['data', 'parsed', 'info', 'delegatedAmount', 'decimals'],\n    ['data', 'parsed', 'info', 'delegatedAmount', 'uiAmount'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'olderTransferFee', 'transferFeeBasisPoints'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'newerTransferFee', 'transferFeeBasisPoints'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'preUpdateAverageRate'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'currentRate'],\n];\nexport const jsonParsedAccountsConfigs = [\n    ...jsonParsedTokenAccountsConfigs,\n    // parsed AddressTableLookup account\n    ['data', 'parsed', 'info', 'lastExtendedSlotStartIndex'],\n    // parsed Config account\n    ['data', 'parsed', 'info', 'slashPenalty'],\n    ['data', 'parsed', 'info', 'warmupCooldownRate'],\n    // parsed Token/Token22 mint account\n    ['data', 'parsed', 'info', 'decimals'],\n    // parsed Token/Token22 multisig account\n    ['data', 'parsed', 'info', 'numRequiredSigners'],\n    ['data', 'parsed', 'info', 'numValidSigners'],\n    // parsed Stake account\n    ['data', 'parsed', 'info', 'stake', 'delegation', 'warmupCooldownRate'],\n    // parsed Sysvar rent account\n    ['data', 'parsed', 'info', 'exemptionThreshold'],\n    ['data', 'parsed', 'info', 'burnPercent'],\n    // parsed Vote account\n    ['data', 'parsed', 'info', 'commission'],\n    ['data', 'parsed', 'info', 'votes', KEYPATH_WILDCARD, 'confirmationCount'],\n];\nexport const innerInstructionsConfigs = [\n    ['index'],\n    ['instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n    ['instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n    ['instructions', KEYPATH_WILDCARD, 'stackHeight'],\n];\nexport const messageConfig = [\n    ['addressTableLookups', KEYPATH_WILDCARD, 'writableIndexes', KEYPATH_WILDCARD],\n    ['addressTableLookups', KEYPATH_WILDCARD, 'readonlyIndexes', KEYPATH_WILDCARD],\n    ['header', 'numReadonlySignedAccounts'],\n    ['header', 'numReadonlyUnsignedAccounts'],\n    ['header', 'numRequiredSignatures'],\n    ['instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n    ['instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n    ['instructions', KEYPATH_WILDCARD, 'stackHeight'],\n] as const;\n"],"names":["pipe"],"mappings":"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"}},
    {"offset": {"line": 8249, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/rpc-api/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-api/src/index.ts"],"sourcesContent":["/**\n * This package contains types that describe the [methods](https://solana.com/docs/rpc/http) of the\n * Solana JSON RPC API, and utilities for creating a {@link RpcApi} implementation with sensible\n * defaults. It can be used standalone, but it is also exported as part of Kit\n * [`@solana/kit`](https://github.com/anza-xyz/kit/tree/main/packages/kit).\n *\n * @example\n * Each RPC method is described in terms of a TypeScript type of the following form:\n *\n * ```ts\n * type ExampleApi = {\n *     getSomething(address: Address): Something;\n * };\n * ```\n *\n * A {@link RpcApi} that implements `ExampleApi` will ultimately expose its defined methods on any\n * {@link Rpc} that uses it.\n *\n * ```ts\n * const rpc: Rpc<ExampleApi> = createExampleRpc(/* ... *\\/);\n * const something: Something = await rpc.getSomething(address('95DpK3y3GF7U8s1k4EvZ7xqyeCkhsHeZaE97iZpHUGMN')).send();\n * ```\n *\n * @packageDocumentation\n */\nimport { createJsonRpcApi, RpcApi } from '@solana/rpc-spec';\nimport {\n    AllowedNumericKeypaths,\n    getDefaultRequestTransformerForSolanaRpc,\n    getDefaultResponseTransformerForSolanaRpc,\n    innerInstructionsConfigs,\n    jsonParsedAccountsConfigs,\n    jsonParsedTokenAccountsConfigs,\n    KEYPATH_WILDCARD,\n    messageConfig,\n    RequestTransformerConfig,\n} from '@solana/rpc-transformers';\n\nimport { GetAccountInfoApi } from './getAccountInfo';\nimport { GetBalanceApi } from './getBalance';\nimport { GetBlockApi } from './getBlock';\nimport { GetBlockCommitmentApi } from './getBlockCommitment';\nimport { GetBlockHeightApi } from './getBlockHeight';\nimport { GetBlockProductionApi } from './getBlockProduction';\nimport { GetBlocksApi } from './getBlocks';\nimport { GetBlocksWithLimitApi } from './getBlocksWithLimit';\nimport { GetBlockTimeApi } from './getBlockTime';\nimport { GetClusterNodesApi } from './getClusterNodes';\nimport { GetEpochInfoApi } from './getEpochInfo';\nimport { GetEpochScheduleApi } from './getEpochSchedule';\nimport { GetFeeForMessageApi } from './getFeeForMessage';\nimport { GetFirstAvailableBlockApi } from './getFirstAvailableBlock';\nimport { GetGenesisHashApi } from './getGenesisHash';\nimport { GetHealthApi } from './getHealth';\nimport { GetHighestSnapshotSlotApi } from './getHighestSnapshotSlot';\nimport { GetIdentityApi } from './getIdentity';\nimport { GetInflationGovernorApi } from './getInflationGovernor';\nimport { GetInflationRateApi } from './getInflationRate';\nimport { GetInflationRewardApi } from './getInflationReward';\nimport { GetLargestAccountsApi } from './getLargestAccounts';\nimport { GetLatestBlockhashApi } from './getLatestBlockhash';\nimport { GetLeaderScheduleApi } from './getLeaderSchedule';\nimport { GetMaxRetransmitSlotApi } from './getMaxRetransmitSlot';\nimport { GetMaxShredInsertSlotApi } from './getMaxShredInsertSlot';\nimport { GetMinimumBalanceForRentExemptionApi } from './getMinimumBalanceForRentExemption';\nimport { GetMultipleAccountsApi } from './getMultipleAccounts';\nimport { GetProgramAccountsApi } from './getProgramAccounts';\nimport { GetRecentPerformanceSamplesApi } from './getRecentPerformanceSamples';\nimport { GetRecentPrioritizationFeesApi } from './getRecentPrioritizationFees';\nimport { GetSignaturesForAddressApi } from './getSignaturesForAddress';\nimport { GetSignatureStatusesApi } from './getSignatureStatuses';\nimport { GetSlotApi } from './getSlot';\nimport { GetSlotLeaderApi } from './getSlotLeader';\nimport { GetSlotLeadersApi } from './getSlotLeaders';\nimport { GetStakeMinimumDelegationApi } from './getStakeMinimumDelegation';\nimport { GetSupplyApi } from './getSupply';\nimport { GetTokenAccountBalanceApi } from './getTokenAccountBalance';\nimport { GetTokenAccountsByDelegateApi } from './getTokenAccountsByDelegate';\nimport { GetTokenAccountsByOwnerApi } from './getTokenAccountsByOwner';\nimport { GetTokenLargestAccountsApi } from './getTokenLargestAccounts';\nimport { GetTokenSupplyApi } from './getTokenSupply';\nimport { GetTransactionApi } from './getTransaction';\nimport { GetTransactionCountApi } from './getTransactionCount';\nimport { GetVersionApi } from './getVersion';\nimport { GetVoteAccountsApi } from './getVoteAccounts';\nimport { IsBlockhashValidApi } from './isBlockhashValid';\nimport { MinimumLedgerSlotApi } from './minimumLedgerSlot';\nimport { RequestAirdropApi } from './requestAirdrop';\nimport { SendTransactionApi } from './sendTransaction';\nimport { SimulateTransactionApi } from './simulateTransaction';\n\ntype SolanaRpcApiForAllClusters = GetAccountInfoApi &\n    GetBalanceApi &\n    GetBlockApi &\n    GetBlockCommitmentApi &\n    GetBlockHeightApi &\n    GetBlockProductionApi &\n    GetBlocksApi &\n    GetBlocksWithLimitApi &\n    GetBlockTimeApi &\n    GetClusterNodesApi &\n    GetEpochInfoApi &\n    GetEpochScheduleApi &\n    GetFeeForMessageApi &\n    GetFirstAvailableBlockApi &\n    GetGenesisHashApi &\n    GetHealthApi &\n    GetHighestSnapshotSlotApi &\n    GetIdentityApi &\n    GetInflationGovernorApi &\n    GetInflationRateApi &\n    GetInflationRewardApi &\n    GetLargestAccountsApi &\n    GetLatestBlockhashApi &\n    GetLeaderScheduleApi &\n    GetMaxRetransmitSlotApi &\n    GetMaxShredInsertSlotApi &\n    GetMinimumBalanceForRentExemptionApi &\n    GetMultipleAccountsApi &\n    GetProgramAccountsApi &\n    GetRecentPerformanceSamplesApi &\n    GetRecentPrioritizationFeesApi &\n    GetSignaturesForAddressApi &\n    GetSignatureStatusesApi &\n    GetSlotApi &\n    GetSlotLeaderApi &\n    GetSlotLeadersApi &\n    GetStakeMinimumDelegationApi &\n    GetSupplyApi &\n    GetTokenAccountBalanceApi &\n    GetTokenAccountsByDelegateApi &\n    GetTokenAccountsByOwnerApi &\n    GetTokenLargestAccountsApi &\n    GetTokenSupplyApi &\n    GetTransactionApi &\n    GetTransactionCountApi &\n    GetVersionApi &\n    GetVoteAccountsApi &\n    IsBlockhashValidApi &\n    MinimumLedgerSlotApi &\n    SendTransactionApi &\n    SimulateTransactionApi;\ntype SolanaRpcApiForTestClusters = RequestAirdropApi & SolanaRpcApiForAllClusters;\n/**\n * Represents the RPC methods available on test clusters.\n *\n * For instance, the test clusters support the {@link RequestAirdropApi} while mainnet does not.\n */\nexport type SolanaRpcApi = SolanaRpcApiForTestClusters;\n/**\n * Represents the RPC methods available on the devnet cluster.\n *\n * For instance, the devnet cluster supports the {@link RequestAirdropApi} while mainnet does not.\n */\nexport type SolanaRpcApiDevnet = SolanaRpcApiForTestClusters;\n/**\n * Represents the RPC methods available on the testnet cluster.\n *\n * For instance, the testnet cluster supports the {@link RequestAirdropApi} while mainnet does not.\n */\nexport type SolanaRpcApiTestnet = SolanaRpcApiForTestClusters;\n/**\n * Represents the RPC methods available on the mainnet cluster.\n *\n * For instance, the mainnet cluster does not support the {@link RequestAirdropApi} whereas test\n * clusters do.\n */\nexport type SolanaRpcApiMainnet = SolanaRpcApiForAllClusters;\n\nexport type {\n    GetAccountInfoApi,\n    GetBalanceApi,\n    GetBlockApi,\n    GetBlockCommitmentApi,\n    GetBlockHeightApi,\n    GetBlockProductionApi,\n    GetBlocksApi,\n    GetBlocksWithLimitApi,\n    GetBlockTimeApi,\n    GetClusterNodesApi,\n    GetEpochInfoApi,\n    GetEpochScheduleApi,\n    GetFeeForMessageApi,\n    GetFirstAvailableBlockApi,\n    GetGenesisHashApi,\n    GetHealthApi,\n    GetHighestSnapshotSlotApi,\n    GetIdentityApi,\n    GetInflationGovernorApi,\n    GetInflationRateApi,\n    GetInflationRewardApi,\n    GetLargestAccountsApi,\n    GetLatestBlockhashApi,\n    GetLeaderScheduleApi,\n    GetMaxRetransmitSlotApi,\n    GetMaxShredInsertSlotApi,\n    GetMinimumBalanceForRentExemptionApi,\n    GetMultipleAccountsApi,\n    GetProgramAccountsApi,\n    GetRecentPerformanceSamplesApi,\n    GetRecentPrioritizationFeesApi,\n    GetSignaturesForAddressApi,\n    GetSignatureStatusesApi,\n    GetSlotApi,\n    GetSlotLeaderApi,\n    GetSlotLeadersApi,\n    GetStakeMinimumDelegationApi,\n    GetSupplyApi,\n    GetTokenAccountBalanceApi,\n    GetTokenAccountsByDelegateApi,\n    GetTokenAccountsByOwnerApi,\n    GetTokenLargestAccountsApi,\n    GetTokenSupplyApi,\n    GetTransactionApi,\n    GetTransactionCountApi,\n    GetVersionApi,\n    GetVoteAccountsApi,\n    IsBlockhashValidApi,\n    MinimumLedgerSlotApi,\n    RequestAirdropApi,\n    SendTransactionApi,\n    SimulateTransactionApi,\n};\n\ntype Config = RequestTransformerConfig;\n\n/**\n * Creates a {@link RpcApi} implementation of the Solana JSON RPC API with some default behaviours.\n *\n * The default behaviours include:\n * - A transform that converts `bigint` inputs to `number` for compatibility with version 1.0 of the\n *   Solana JSON RPC.\n * - A transform that calls the config's {@link Config.onIntegerOverflow | onIntegerOverflow}\n *   handler whenever a `bigint` input would overflow a JavaScript IEEE 754 number. See\n *   [this](https://github.com/solana-labs/solana-web3.js/issues/1116) GitHub issue for more\n *   information.\n * - A transform that applies a default commitment wherever not specified\n */\nexport function createSolanaRpcApi<\n    // eslint-disable-next-line @typescript-eslint/no-duplicate-type-constituents\n    TRpcMethods extends SolanaRpcApi | SolanaRpcApiDevnet | SolanaRpcApiMainnet | SolanaRpcApiTestnet = SolanaRpcApi,\n>(config?: Config): RpcApi<TRpcMethods> {\n    return createJsonRpcApi<TRpcMethods>({\n        requestTransformer: getDefaultRequestTransformerForSolanaRpc(config),\n        responseTransformer: getDefaultResponseTransformerForSolanaRpc({\n            allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n        }),\n    });\n}\n\nlet memoizedKeypaths: AllowedNumericKeypaths<RpcApi<SolanaRpcApi>>;\n\n/**\n * These are keypaths at the end of which you will find a numeric value that should *not* be upcast\n * to a `bigint`. These are values that are legitimately defined as `u8` or `usize` on the backend.\n */\nfunction getAllowedNumericKeypaths(): AllowedNumericKeypaths<RpcApi<SolanaRpcApi>> {\n    if (!memoizedKeypaths) {\n        memoizedKeypaths = {\n            getAccountInfo: jsonParsedAccountsConfigs.map(c => ['value', ...c]),\n            getBlock: [\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'preTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'preTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'postTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'postTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                ...innerInstructionsConfigs.map(c => [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    ...c,\n                ]),\n                ...messageConfig.map(c => ['transactions', KEYPATH_WILDCARD, 'transaction', 'message', ...c] as const),\n                ['rewards', KEYPATH_WILDCARD, 'commission'],\n            ],\n            getClusterNodes: [\n                [KEYPATH_WILDCARD, 'featureSet'],\n                [KEYPATH_WILDCARD, 'shredVersion'],\n            ],\n            getInflationGovernor: [['initial'], ['foundation'], ['foundationTerm'], ['taper'], ['terminal']],\n            getInflationRate: [['foundation'], ['total'], ['validator']],\n            getInflationReward: [[KEYPATH_WILDCARD, 'commission']],\n            getMultipleAccounts: jsonParsedAccountsConfigs.map(c => ['value', KEYPATH_WILDCARD, ...c]),\n            getProgramAccounts: jsonParsedAccountsConfigs.flatMap(c => [\n                ['value', KEYPATH_WILDCARD, 'account', ...c],\n                [KEYPATH_WILDCARD, 'account', ...c],\n            ]),\n            getRecentPerformanceSamples: [[KEYPATH_WILDCARD, 'samplePeriodSecs']],\n            getTokenAccountBalance: [\n                ['value', 'decimals'],\n                ['value', 'uiAmount'],\n            ],\n            getTokenAccountsByDelegate: jsonParsedTokenAccountsConfigs.map(c => [\n                'value',\n                KEYPATH_WILDCARD,\n                'account',\n                ...c,\n            ]),\n            getTokenAccountsByOwner: jsonParsedTokenAccountsConfigs.map(c => [\n                'value',\n                KEYPATH_WILDCARD,\n                'account',\n                ...c,\n            ]),\n            getTokenLargestAccounts: [\n                ['value', KEYPATH_WILDCARD, 'decimals'],\n                ['value', KEYPATH_WILDCARD, 'uiAmount'],\n            ],\n            getTokenSupply: [\n                ['value', 'decimals'],\n                ['value', 'uiAmount'],\n            ],\n            getTransaction: [\n                ['meta', 'preTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                ['meta', 'preTokenBalances', KEYPATH_WILDCARD, 'uiTokenAmount', 'decimals'],\n                ['meta', 'postTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                ['meta', 'postTokenBalances', KEYPATH_WILDCARD, 'uiTokenAmount', 'decimals'],\n                ['meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                ...innerInstructionsConfigs.map(c => ['meta', 'innerInstructions', KEYPATH_WILDCARD, ...c]),\n                ...messageConfig.map(c => ['transaction', 'message', ...c] as const),\n            ],\n            getVersion: [['feature-set']],\n            getVoteAccounts: [\n                ['current', KEYPATH_WILDCARD, 'commission'],\n                ['delinquent', KEYPATH_WILDCARD, 'commission'],\n            ],\n            simulateTransaction: [\n                ['value', 'loadedAccountsDataSize'],\n                ...jsonParsedAccountsConfigs.map(c => ['value', 'accounts', KEYPATH_WILDCARD, ...c]),\n                ...innerInstructionsConfigs.map(c => ['value', 'innerInstructions', KEYPATH_WILDCARD, ...c]),\n            ],\n        };\n    }\n    return memoizedKeypaths;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8541, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/rpc-transport-http/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-transport-http/src/http-transport-headers.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-transport-http/src/http-transport.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-transport-http/src/is-solana-request.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-transport-http/src/http-transport-for-solana-rpc.ts"],"sourcesContent":["import { SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, SolanaError } from '@solana/errors';\n\nexport type AllowedHttpRequestHeaders = Readonly<\n    {\n        // Someone can still sneak a forbidden header past Typescript if they do something like\n        // fOo-BaR, but at that point they deserve the runtime failure.\n        [K in DisallowedHeaders | ForbiddenHeaders as\n            | Capitalize<Lowercase<K>> // `Foo-bar`\n            | K // `Foo-Bar`\n            | Lowercase<K> // `foo-bar`\n            | Uncapitalize<K> // `foo-Bar`\n            // `FOO-BAR`\n            | Uppercase<K>]?: never;\n    } & { [headerName: string]: string }\n>;\n// These are headers that we simply don't allow the developer to override because they're\n// fundamental to the operation of the JSON-RPC transport.\ntype DisallowedHeaders = 'Accept' | 'Content-Length' | 'Content-Type' | 'Solana-Client';\ntype ForbiddenHeaders =\n    | 'Accept-Charset'\n    // Though technically forbidden in non-Node environments, we don't have a way to target\n    // TypeScript types depending on which platform you are authoring for. `Accept-Encoding` is\n    // therefore omitted from the forbidden headers type, but is still a runtime error in dev mode\n    // when supplied in a non-Node context.\n    // | 'Accept-Encoding'\n    | 'Access-Control-Request-Headers'\n    | 'Access-Control-Request-Method'\n    | 'Connection'\n    | 'Content-Length'\n    | 'Cookie'\n    | 'Date'\n    | 'DNT'\n    | 'Expect'\n    | 'Host'\n    | 'Keep-Alive'\n    // Similar to `Accept-Encoding`, we don't have a way to target TypeScript types depending on\n    // which platform you are authoring for. `Origin` is therefore omitted from the forbidden\n    // headers type, but is still a runtime error in dev mode when supplied in a browser context.\n    // | 'Origin'\n    | 'Permissions-Policy'\n    | 'Referer'\n    | 'TE'\n    | 'Trailer'\n    | 'Transfer-Encoding'\n    | 'Upgrade'\n    | 'Via'\n    | `Proxy-${string}`\n    | `Sec-${string}`;\n\n// These are headers which are fundamental to the JSON-RPC transport, and must not be modified.\nconst DISALLOWED_HEADERS: Record<string, boolean> = {\n    accept: true,\n    'content-length': true,\n    'content-type': true,\n};\n// https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\nconst FORBIDDEN_HEADERS: Record<string, boolean> = /* @__PURE__ */ Object.assign(\n    {\n        'accept-charset': true,\n        'access-control-request-headers': true,\n        'access-control-request-method': true,\n        connection: true,\n        'content-length': true,\n        cookie: true,\n        date: true,\n        dnt: true,\n        expect: true,\n        host: true,\n        'keep-alive': true,\n        'permissions-policy': true,\n        // Prefix matching is implemented in code, below.\n        // 'proxy-': true,\n        // 'sec-': true,\n        referer: true,\n        te: true,\n        trailer: true,\n        'transfer-encoding': true,\n        upgrade: true,\n        via: true,\n    },\n    __NODEJS__ ? undefined : { 'accept-encoding': true },\n    __BROWSER__ ? { origin: true } : undefined,\n);\n\nexport function assertIsAllowedHttpRequestHeaders(\n    headers: Record<string, string>,\n): asserts headers is AllowedHttpRequestHeaders {\n    const badHeaders = Object.keys(headers).filter(headerName => {\n        const lowercaseHeaderName = headerName.toLowerCase();\n        return (\n            DISALLOWED_HEADERS[headerName.toLowerCase()] === true ||\n            FORBIDDEN_HEADERS[headerName.toLowerCase()] === true ||\n            lowercaseHeaderName.startsWith('proxy-') ||\n            lowercaseHeaderName.startsWith('sec-')\n        );\n    });\n    if (badHeaders.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, {\n            headers: badHeaders,\n        });\n    }\n}\n\n// Lowercasing header names makes it easier to override user-supplied headers, such as those defined\n// in the `DisallowedHeaders` type.\nexport function normalizeHeaders<T extends Record<string, string>>(\n    headers: T,\n): { [K in string & keyof T as Lowercase<K>]: T[K] } {\n    const out: Record<string, string> = {};\n    for (const headerName in headers) {\n        out[headerName.toLowerCase()] = headers[headerName];\n    }\n    return out as { [K in string & keyof T as Lowercase<K>]: T[K] };\n}\n","import { SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, SolanaError } from '@solana/errors';\nimport type { RpcTransport } from '@solana/rpc-spec';\nimport type { RpcResponse } from '@solana/rpc-spec-types';\nimport type Dispatcher from 'undici-types/dispatcher';\n\nimport { HttpTransportConfig as Config } from './http-transport-config';\nimport { assertIsAllowedHttpRequestHeaders, normalizeHeaders } from './http-transport-headers';\n\nlet didWarnDispatcherWasSuppliedInNonNodeEnvironment = false;\nfunction warnDispatcherWasSuppliedInNonNodeEnvironment() {\n    if (didWarnDispatcherWasSuppliedInNonNodeEnvironment) {\n        return;\n    }\n    didWarnDispatcherWasSuppliedInNonNodeEnvironment = true;\n    console.warn(\n        'You have supplied a `Dispatcher` to `createHttpTransport()`. It has been ignored ' +\n            'because Undici dispatchers only work in Node environments. To eliminate this ' +\n            'warning, omit the `dispatcher_NODE_ONLY` property from your config when running in ' +\n            'a non-Node environment.',\n    );\n}\n\n/**\n * Creates a function you can use to make `POST` requests with headers suitable for sending JSON\n * data to a server.\n *\n * @example\n * ```ts\n * import { createHttpTransport } from '@solana/rpc-transport-http';\n *\n * const transport = createHttpTransport({ url: 'https://api.mainnet-beta.solana.com' });\n * const response = await transport({\n *     payload: { id: 1, jsonrpc: '2.0', method: 'getSlot' },\n * });\n * const data = await response.json();\n * ```\n */\nexport function createHttpTransport(config: Config): RpcTransport {\n    if (process.env.NODE_ENV !== \"production\" && !__NODEJS__ && 'dispatcher_NODE_ONLY' in config) {\n        warnDispatcherWasSuppliedInNonNodeEnvironment();\n    }\n    const { fromJson, headers, toJson, url } = config;\n    if (process.env.NODE_ENV !== \"production\" && headers) {\n        assertIsAllowedHttpRequestHeaders(headers);\n    }\n    let dispatcherConfig: { dispatcher: Dispatcher | undefined } | undefined;\n    if (__NODEJS__ && 'dispatcher_NODE_ONLY' in config) {\n        dispatcherConfig = { dispatcher: config.dispatcher_NODE_ONLY };\n    }\n    const customHeaders = headers && normalizeHeaders(headers);\n    return async function makeHttpRequest<TResponse>({\n        payload,\n        signal,\n    }: Parameters<RpcTransport>[0]): Promise<RpcResponse<TResponse>> {\n        const body = toJson ? toJson(payload) : JSON.stringify(payload);\n        const requestInfo = {\n            ...dispatcherConfig,\n            body,\n            headers: {\n                ...customHeaders,\n                // Keep these headers lowercase so they will override any user-supplied headers above.\n                accept: 'application/json',\n                'content-length': body.length.toString(),\n                'content-type': 'application/json; charset=utf-8',\n            },\n            method: 'POST',\n            signal,\n        };\n        const response = await fetch(url, requestInfo);\n        if (!response.ok) {\n            throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, {\n                headers: response.headers,\n                message: response.statusText,\n                statusCode: response.status,\n            });\n        }\n        if (fromJson) {\n            return fromJson(await response.text(), payload) as TResponse;\n        }\n        return await response.json();\n    };\n}\n","import { isJsonRpcPayload } from '@solana/rpc-spec';\n\nconst SOLANA_RPC_METHODS = [\n    'getAccountInfo',\n    'getBalance',\n    'getBlock',\n    'getBlockCommitment',\n    'getBlockHeight',\n    'getBlockProduction',\n    'getBlocks',\n    'getBlocksWithLimit',\n    'getBlockTime',\n    'getClusterNodes',\n    'getEpochInfo',\n    'getEpochSchedule',\n    'getFeeForMessage',\n    'getFirstAvailableBlock',\n    'getGenesisHash',\n    'getHealth',\n    'getHighestSnapshotSlot',\n    'getIdentity',\n    'getInflationGovernor',\n    'getInflationRate',\n    'getInflationReward',\n    'getLargestAccounts',\n    'getLatestBlockhash',\n    'getLeaderSchedule',\n    'getMaxRetransmitSlot',\n    'getMaxShredInsertSlot',\n    'getMinimumBalanceForRentExemption',\n    'getMultipleAccounts',\n    'getProgramAccounts',\n    'getRecentPerformanceSamples',\n    'getRecentPrioritizationFees',\n    'getSignaturesForAddress',\n    'getSignatureStatuses',\n    'getSlot',\n    'getSlotLeader',\n    'getSlotLeaders',\n    'getStakeMinimumDelegation',\n    'getSupply',\n    'getTokenAccountBalance',\n    'getTokenAccountsByDelegate',\n    'getTokenAccountsByOwner',\n    'getTokenLargestAccounts',\n    'getTokenSupply',\n    'getTransaction',\n    'getTransactionCount',\n    'getVersion',\n    'getVoteAccounts',\n    'index',\n    'isBlockhashValid',\n    'minimumLedgerSlot',\n    'requestAirdrop',\n    'sendTransaction',\n    'simulateTransaction',\n] as const;\n\n/**\n * Helper function that checks if a given `RpcRequest` comes from the Solana RPC API.\n */\nexport function isSolanaRequest(payload: unknown): payload is Readonly<{\n    jsonrpc: '2.0';\n    method: (typeof SOLANA_RPC_METHODS)[number];\n    params: unknown;\n}> {\n    return isJsonRpcPayload(payload) && (SOLANA_RPC_METHODS as readonly string[]).includes(payload.method);\n}\n","import { RpcTransport } from '@solana/rpc-spec';\nimport { parseJsonWithBigInts, stringifyJsonWithBigInts } from '@solana/rpc-spec-types';\n\nimport { createHttpTransport } from './http-transport';\nimport { HttpTransportConfig } from './http-transport-config';\nimport { isSolanaRequest } from './is-solana-request';\n\ntype Config = Pick<HttpTransportConfig, 'dispatcher_NODE_ONLY' | 'headers' | 'url'>;\n\n/**\n * Creates a {@link RpcTransport} that uses JSON HTTP requests — much like the\n * {@link createHttpTransport} function - except that it also uses custom `toJson` and `fromJson`\n * functions in order to allow `bigint` values to be serialized and deserialized correctly over the\n * wire.\n *\n * Since this is something specific to the Solana RPC API, these custom JSON functions are only\n * triggered when the request is recognized as a Solana RPC request. Normal RPC APIs should aim to\n * wrap their `bigint` values — e.g. `u64` or `i64` — in special value objects that represent the\n * number as a string to avoid numerical values going above `Number.MAX_SAFE_INTEGER`.\n *\n * It has the same configuration options as {@link createHttpTransport}, but without the `fromJson`\n * and `toJson` options.\n */\nexport function createHttpTransportForSolanaRpc(config: Config): RpcTransport {\n    return createHttpTransport({\n        ...config,\n        fromJson: (rawResponse: string, payload: unknown) =>\n            isSolanaRequest(payload) ? parseJsonWithBigInts(rawResponse) : JSON.parse(rawResponse),\n        toJson: (payload: unknown) =>\n            isSolanaRequest(payload) ? stringifyJsonWithBigInts(payload) : JSON.stringify(payload),\n    });\n}\n"],"names":["SolanaError"],"mappings":";;;;;;ACsCQ,OAAA,CAAA,GAAA,CAAA,QAAA;;;;;;;;ADYR,IAAM,kBAAA,GAA8C;IAChD,MAAA,EAAQ,IAAA;IACR,gBAAA,EAAkB,IAAA;IAClB,cAAA,EAAgB;AACpB,CAAA;AAEA,IAAM,oBAAA,aAAA,GAA6D,MAAA,CAAO,MAAA,CACtE;IACI,gBAAA,EAAkB,IAAA;IAClB,gCAAA,EAAkC,IAAA;IAClC,+BAAA,EAAiC,IAAA;IACjC,UAAA,EAAY,IAAA;IACZ,gBAAA,EAAkB,IAAA;IAClB,MAAA,EAAQ,IAAA;IACR,IAAA,EAAM,IAAA;IACN,GAAA,EAAK,IAAA;IACL,MAAA,EAAQ,IAAA;IACR,IAAA,EAAM,IAAA;IACN,YAAA,EAAc,IAAA;IACd,oBAAA,EAAsB,IAAA;IAAA,iDAAA;IAAA,kBAAA;IAAA,gBAAA;IAItB,OAAA,EAAS,IAAA;IACT,EAAA,EAAI,IAAA;IACJ,OAAA,EAAS,IAAA;IACT,mBAAA,EAAqB,IAAA;IACrB,OAAA,EAAS,IAAA;IACT,GAAA,EAAK;AAAA,CACT,EACyB;IAAE,iBAAA,EAAmB,IAAA;AAAA,CAAK,EACrC;IAAE,MAAA,EAAQ,IAAA;AAAA,CAAK;AAG1B,SAAS,kCACZ,OAAA,EAC4C;IAC5C,MAAM,aAAa,MAAA,CAAO,IAAA,CAAK,OAAO,CAAA,CAAE,MAAA,CAAO,CAAA,UAAA,KAAc;QACzD,MAAM,mBAAA,GAAsB,WAAW,WAAA,EAAY;QACnD,OACI,kBAAA,CAAmB,UAAA,CAAW,WAAA,EAAa,CAAA,KAAM,IAAA,IACjD,iBAAA,CAAkB,UAAA,CAAW,WAAA,EAAa,CAAA,KAAM,QAChD,mBAAA,CAAoB,UAAA,CAAW,QAAQ,CAAA,IACvC,mBAAA,CAAoB,UAAA,CAAW,MAAM,CAAA;IAE7C,CAAC,CAAA;IACD,IAAI,UAAA,CAAW,MAAA,GAAS,CAAA,EAAG;QACvB,MAAM,IAAI,iLAAA,CAAY,wNAAA,EAAoD;YACtE,OAAA,EAAS;QAAA,CACZ,CAAA;IACL;AACJ;AAIO,SAAS,iBACZ,OAAA,EACiD;IACjD,MAAM,MAA8B,CAAA,CAAC;IACrC,IAAA,MAAW,cAAc,OAAA,CAAS;QAC9B,GAAA,CAAI,UAAA,CAAW,WAAA,EAAa,CAAA,GAAI,OAAA,CAAQ,UAAU,CAAA;IACtD;IACA,OAAO,GAAA;AACX;;ACzGA,IAAI,gDAAA,GAAmD,KAAA;AACvD,SAAS,6CAAA,GAAgD;IACrD,IAAI,gDAAA,EAAkD;QAClD;IACJ;IACA,gDAAA,GAAmD,IAAA;IACnD,OAAA,CAAQ,IAAA,CACJ;AAKR;AAiBO,SAAS,oBAAoB,MAAA,EAA8B;IAC9D,wDAA6B,YAAA,IAAgB,IAAA,IAAe,sBAAA,IAA0B,MAAA,EAAQ;QAC1F,6CAAA,EAA8C;IAClD;IACA,MAAM,EAAE,QAAA,EAAU,OAAA,EAAS,MAAA,EAAQ,GAAA,EAAI,GAAI,MAAA;IAC3C,IAAI,OAAA,CAAA,GAAA,CAAA,QAAA,gCAAyB,gBAAgB,OAAA,EAAS;QAClD,iCAAA,CAAkC,OAAO,CAAA;IAC7C;IACA,IAAI,gBAAA;IAIJ,MAAM,aAAA,GAAgB,OAAA,IAAW,gBAAA,CAAiB,OAAO,CAAA;IACzD,OAAO,eAAe,eAAA,CAA2B,EAC7C,OAAA,EACA,MAAA,EACJ,EAAiE;QAC7D,MAAM,OAAO,MAAA,GAAS,MAAA,CAAO,OAAO,CAAA,GAAI,IAAA,CAAK,SAAA,CAAU,OAAO,CAAA;QAC9D,MAAM,WAAA,GAAc;YAChB,GAAG,gBAAA;YACH,IAAA;YACA,OAAA,EAAS;gBACL,GAAG,aAAA;gBAAA,sFAAA;gBAEH,MAAA,EAAQ,kBAAA;gBACR,gBAAA,EAAkB,IAAA,CAAK,MAAA,CAAO,QAAA,EAAS;gBACvC,cAAA,EAAgB;YAAA,CACpB;YACA,MAAA,EAAQ,MAAA;YACR;QAAA,CACJ;QACA,MAAM,QAAA,GAAW,MAAM,KAAA,CAAM,GAAA,EAAK,WAAW,CAAA;QAC7C,IAAI,CAAC,SAAS,EAAA,EAAI;YACd,MAAM,IAAIA,iLAAAA,CAAY,6MAAA,EAAyC;gBAC3D,SAAS,QAAA,CAAS,OAAA;gBAClB,SAAS,QAAA,CAAS,UAAA;gBAClB,YAAY,QAAA,CAAS,MAAA;YAAA,CACxB,CAAA;QACL;QACA,IAAI,QAAA,EAAU;YACV,OAAO,QAAA,CAAS,MAAM,QAAA,CAAS,IAAA,IAAQ,OAAO,CAAA;QAClD;QACA,OAAO,MAAM,SAAS,IAAA,EAAK;IAC/B,CAAA;AACJ;AC/EA,IAAM,kBAAA,GAAqB;IACvB,gBAAA;IACA,YAAA;IACA,UAAA;IACA,oBAAA;IACA,gBAAA;IACA,oBAAA;IACA,WAAA;IACA,oBAAA;IACA,cAAA;IACA,iBAAA;IACA,cAAA;IACA,kBAAA;IACA,kBAAA;IACA,wBAAA;IACA,gBAAA;IACA,WAAA;IACA,wBAAA;IACA,aAAA;IACA,sBAAA;IACA,kBAAA;IACA,oBAAA;IACA,oBAAA;IACA,oBAAA;IACA,mBAAA;IACA,sBAAA;IACA,uBAAA;IACA,mCAAA;IACA,qBAAA;IACA,oBAAA;IACA,6BAAA;IACA,6BAAA;IACA,yBAAA;IACA,sBAAA;IACA,SAAA;IACA,eAAA;IACA,gBAAA;IACA,2BAAA;IACA,WAAA;IACA,wBAAA;IACA,4BAAA;IACA,yBAAA;IACA,yBAAA;IACA,gBAAA;IACA,gBAAA;IACA,qBAAA;IACA,YAAA;IACA,iBAAA;IACA,OAAA;IACA,kBAAA;IACA,mBAAA;IACA,gBAAA;IACA,iBAAA;IACA;CACJ;AAKO,SAAS,gBAAgB,OAAA,EAI7B;IACC,WAAO,2LAAA,EAAiB,OAAO,CAAA,IAAM,kBAAA,CAAyC,QAAA,CAAS,QAAQ,MAAM,CAAA;AACzG;;AC5CO,SAAS,gCAAgC,MAAA,EAA8B;IAC1E,OAAO,mBAAA,CAAoB;QACvB,GAAG,MAAA;QACH,QAAA,EAAU,CAAC,WAAA,EAAqB,OAAA,GAC5B,eAAA,CAAgB,OAAO,CAAA,OAAI,wMAAA,EAAqB,WAAW,CAAA,GAAI,IAAA,CAAK,KAAA,CAAM,WAAW,CAAA;QACzF,MAAA,EAAQ,CAAC,OAAA,GACL,eAAA,CAAgB,OAAO,CAAA,OAAI,4MAAA,EAAyB,OAAO,CAAA,GAAI,IAAA,CAAK,SAAA,CAAU,OAAO;IAAA,CAC5F,CAAA;AACL"}},
    {"offset": {"line": 8726, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/fast-stable-stringify/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/fast-stable-stringify/src/index.ts"],"sourcesContent":["/**\n * This project is a fork of [nickyout/fast-stable-stringify](https://github.com/nickyout/fast-stable-stringify)\n *\n * The most popular repository providing this feature is [substack's json-stable-stringify](https://www.npmjs.com/package/json-stable-stringify). The intent of this library is to provide a faster alternative for when performance is more important than features. It assumes you provide basic javascript values without circular references, and returns a non-indented string.\n *\n * Just like substack's, it:\n *\n * - handles all variations of all basic javascript values (number, string, boolean, array, object, null, Date, BigInt)\n * - handles undefined _and_ function in the same way as `JSON.stringify`\n * - **does not support ie8 (and below) with complete certainty**.\n *\n * Unlike substack's, it:\n *\n * - does not implement the 'replacer' or 'space' arguments of the JSON.stringify method\n * - does not check for circular references\n *\n * @example\n * ```js\n * import stringify from '@solana/fast-stable-stringify';\n * stringify({ d: 0, c: 1, a: 2, b: 3, e: 4 }); // '{\"a\":2,\"b\":3,\"c\":1,\"d\":0,\"e\":4}'\n * ```\n *\n * @packageDocumentation\n */\nconst objToString = Object.prototype.toString;\nconst objKeys =\n    Object.keys ||\n    function (obj) {\n        const keys = [];\n        for (const name in obj) {\n            keys.push(name);\n        }\n        return keys;\n    };\n\nfunction stringify(val: unknown, isArrayProp: boolean) {\n    let i, max, str, keys, key, propVal, toStr;\n    if (val === true) {\n        return 'true';\n    }\n    if (val === false) {\n        return 'false';\n    }\n    switch (typeof val) {\n        case 'object':\n            if (val === null) {\n                return null;\n            } else if ('toJSON' in val && typeof val.toJSON === 'function') {\n                return stringify(val.toJSON(), isArrayProp);\n            } else {\n                toStr = objToString.call(val);\n                if (toStr === '[object Array]') {\n                    str = '[';\n                    max = (val as unknown[]).length - 1;\n                    for (i = 0; i < max; i++) {\n                        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                        str += stringify((val as unknown[])[i], true) + ',';\n                    }\n                    if (max > -1) {\n                        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                        str += stringify((val as unknown[])[i], true);\n                    }\n                    return str + ']';\n                } else if (toStr === '[object Object]') {\n                    // only object is left\n                    keys = objKeys(val).sort();\n                    max = keys.length;\n                    str = '';\n                    i = 0;\n                    while (i < max) {\n                        key = keys[i];\n                        propVal = stringify((val as Record<typeof key, unknown>)[key], false);\n                        if (propVal !== undefined) {\n                            if (str) {\n                                str += ',';\n                            }\n                            // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                            str += JSON.stringify(key) + ':' + propVal;\n                        }\n                        i++;\n                    }\n                    return '{' + str + '}';\n                } else {\n                    return JSON.stringify(val);\n                }\n            }\n        case 'function':\n        case 'undefined':\n            return isArrayProp ? null : undefined;\n        case 'bigint':\n            return `${val.toString()}n`;\n        case 'string':\n            return JSON.stringify(val);\n        default:\n            return isFinite(val as number) ? val : null;\n    }\n}\n\nexport default function (\n    val:\n        | Function // eslint-disable-line @typescript-eslint/no-unsafe-function-type\n        | undefined,\n): undefined;\nexport default function (val: unknown): string;\nexport default function (val: unknown): string | undefined {\n    const returnVal = stringify(val, false);\n    if (returnVal !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        return '' + returnVal;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8810, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/rpc/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc/src/rpc-integer-overflow-error.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc/src/rpc-default-config.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/event-target-impl/src/index.browser.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc/src/rpc-request-coalescer.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc/src/rpc-request-deduplication.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc/src/rpc-transport.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc/src/rpc.ts"],"sourcesContent":["import { safeCaptureStackTrace, SOLANA_ERROR__RPC__INTEGER_OVERFLOW, SolanaError } from '@solana/errors';\nimport type { KeyPath } from '@solana/rpc-transformers';\n\nexport function createSolanaJsonRpcIntegerOverflowError(\n    methodName: string,\n    keyPath: KeyPath,\n    value: bigint,\n): SolanaError<typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW> {\n    let argumentLabel = '';\n    if (typeof keyPath[0] === 'number') {\n        const argPosition = keyPath[0] + 1;\n        const lastDigit = argPosition % 10;\n        const lastTwoDigits = argPosition % 100;\n        if (lastDigit == 1 && lastTwoDigits != 11) {\n            argumentLabel = argPosition + 'st';\n        } else if (lastDigit == 2 && lastTwoDigits != 12) {\n            argumentLabel = argPosition + 'nd';\n        } else if (lastDigit == 3 && lastTwoDigits != 13) {\n            argumentLabel = argPosition + 'rd';\n        } else {\n            argumentLabel = argPosition + 'th';\n        }\n    } else {\n        argumentLabel = `\\`${keyPath[0].toString()}\\``;\n    }\n    const path =\n        keyPath.length > 1\n            ? keyPath\n                  .slice(1)\n                  .map(pathPart => (typeof pathPart === 'number' ? `[${pathPart}]` : pathPart))\n                  .join('.')\n            : undefined;\n    const error = new SolanaError(SOLANA_ERROR__RPC__INTEGER_OVERFLOW, {\n        argumentLabel,\n        keyPath: keyPath as readonly (number | string | symbol)[],\n        methodName,\n        optionalPathLabel: path ? ` at path \\`${path}\\`` : '',\n        value,\n        ...(path !== undefined ? { path } : undefined),\n    });\n    safeCaptureStackTrace(error, createSolanaJsonRpcIntegerOverflowError);\n    return error;\n}\n","import type { createSolanaRpcApi } from '@solana/rpc-api';\n\nimport { createSolanaJsonRpcIntegerOverflowError } from './rpc-integer-overflow-error';\n\n/**\n * When you create {@link Rpc} instances with custom transports but otherwise the default RPC API\n * behaviours, use this.\n *\n * @example\n * ```ts\n * const myCustomRpc = createRpc({\n *     api: createSolanaRpcApi(DEFAULT_RPC_CONFIG),\n *     transport: myCustomTransport,\n * });\n * ```\n */\nexport const DEFAULT_RPC_CONFIG: Partial<NonNullable<Parameters<typeof createSolanaRpcApi>[0]>> = {\n    defaultCommitment: 'confirmed',\n    onIntegerOverflow(request, keyPath, value) {\n        throw createSolanaJsonRpcIntegerOverflowError(request.methodName, keyPath, value);\n    },\n};\n","export const AbortController = globalThis.AbortController;\nexport const EventTarget = globalThis.EventTarget;\n","import { AbortController } from '@solana/event-target-impl';\nimport type { RpcTransport } from '@solana/rpc-spec';\nimport type { RpcResponse } from '@solana/rpc-spec-types';\n\ntype CoalescedRequest = {\n    readonly abortController: AbortController;\n    numConsumers: number;\n    readonly responsePromise: Promise<RpcResponse>;\n};\n\ntype GetDeduplicationKeyFn = (payload: unknown) => string | undefined;\n\n// This used to be a `Symbol()`, but there's a bug in Node <21 where the `undici` library passes\n// the `reason` property of the `AbortSignal` straight to `Error.captureStackTrace()` without first\n// typechecking it. `Error.captureStackTrace()` fatals when given a `Symbol`.\n// See https://github.com/nodejs/undici/pull/2597\nlet EXPLICIT_ABORT_TOKEN: ReturnType<typeof createExplicitAbortToken>;\nfunction createExplicitAbortToken() {\n    // This function is an annoying workaround to prevent `process.env.NODE_ENV` from appearing at\n    // the top level of this module and thwarting an optimizing compiler's attempt to tree-shake.\n    return process.env.NODE_ENV !== \"production\"\n        ? {\n              EXPLICIT_ABORT_TOKEN:\n                  'This object is thrown from the request that underlies a series of coalesced ' +\n                  'requests when the last request in that series aborts',\n          }\n        : {};\n}\n\nexport function getRpcTransportWithRequestCoalescing<TTransport extends RpcTransport>(\n    transport: TTransport,\n    getDeduplicationKey: GetDeduplicationKeyFn,\n): TTransport {\n    let coalescedRequestsByDeduplicationKey: Record<string, CoalescedRequest> | undefined;\n    return async function makeCoalescedHttpRequest<TResponse>(\n        request: Parameters<RpcTransport>[0],\n    ): Promise<RpcResponse<TResponse>> {\n        const { payload, signal } = request;\n        const deduplicationKey = getDeduplicationKey(payload);\n        if (deduplicationKey === undefined) {\n            return await transport(request);\n        }\n        if (!coalescedRequestsByDeduplicationKey) {\n            queueMicrotask(() => {\n                coalescedRequestsByDeduplicationKey = undefined;\n            });\n            coalescedRequestsByDeduplicationKey = {};\n        }\n        if (coalescedRequestsByDeduplicationKey[deduplicationKey] == null) {\n            const abortController = new AbortController();\n            const responsePromise = (async () => {\n                try {\n                    return await transport<TResponse>({\n                        ...request,\n                        signal: abortController.signal,\n                    });\n                } catch (e) {\n                    if (e === (EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken())) {\n                        // We triggered this error when the last subscriber aborted. Letting this\n                        // error bubble up from here would cause runtime fatals where there should\n                        // be none.\n                        return;\n                    }\n                    throw e;\n                }\n            })();\n            coalescedRequestsByDeduplicationKey[deduplicationKey] = {\n                abortController,\n                numConsumers: 0,\n                responsePromise,\n            };\n        }\n        const coalescedRequest = coalescedRequestsByDeduplicationKey[deduplicationKey];\n        coalescedRequest.numConsumers++;\n        if (signal) {\n            const responsePromise = coalescedRequest.responsePromise as Promise<RpcResponse<TResponse>>;\n            return await new Promise<RpcResponse<TResponse>>((resolve, reject) => {\n                const handleAbort = (e: AbortSignalEventMap['abort']) => {\n                    signal.removeEventListener('abort', handleAbort);\n                    coalescedRequest.numConsumers -= 1;\n                    queueMicrotask(() => {\n                        if (coalescedRequest.numConsumers === 0) {\n                            const abortController = coalescedRequest.abortController;\n                            abortController.abort((EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken()));\n                        }\n                    });\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                    reject((e.target as AbortSignal).reason);\n                };\n                signal.addEventListener('abort', handleAbort);\n                responsePromise\n                    .then(resolve)\n                    .catch(reject)\n                    .finally(() => {\n                        signal.removeEventListener('abort', handleAbort);\n                    });\n            });\n        } else {\n            return (await coalescedRequest.responsePromise) as RpcResponse<TResponse>;\n        }\n    } as TTransport;\n}\n","import fastStableStringify from '@solana/fast-stable-stringify';\nimport { isJsonRpcPayload } from '@solana/rpc-spec';\n\nexport function getSolanaRpcPayloadDeduplicationKey(payload: unknown): string | undefined {\n    return isJsonRpcPayload(payload) ? fastStableStringify([payload.method, payload.params]) : undefined;\n}\n","import { pipe } from '@solana/functional';\nimport { createHttpTransport, createHttpTransportForSolanaRpc } from '@solana/rpc-transport-http';\nimport type { ClusterUrl } from '@solana/rpc-types';\n\nimport { RpcTransportFromClusterUrl } from './rpc-clusters';\nimport { getRpcTransportWithRequestCoalescing } from './rpc-request-coalescer';\nimport { getSolanaRpcPayloadDeduplicationKey } from './rpc-request-deduplication';\n\ntype RpcTransportConfig = Parameters<typeof createHttpTransport>[0];\ninterface DefaultRpcTransportConfig<TClusterUrl extends ClusterUrl> extends RpcTransportConfig {\n    url: TClusterUrl;\n}\n\nfunction normalizeHeaders<T extends Record<string, string>>(\n    headers: T,\n): { [K in string & keyof T as Lowercase<K>]: T[K] } {\n    const out: Record<string, string> = {};\n    for (const headerName in headers) {\n        // Lowercasing header names makes it easier to override user-supplied headers.\n        out[headerName.toLowerCase()] = headers[headerName];\n    }\n    return out as { [K in string & keyof T as Lowercase<K>]: T[K] };\n}\n\n/**\n * Creates a {@link RpcTransport} with some default behaviours.\n *\n * The default behaviours include:\n * - An automatically-set `Solana-Client` request header, containing the version of `@solana/kit`\n * - Logic that coalesces multiple calls in the same runloop, for the same methods with the same\n *   arguments, into a single network request.\n * - [node-only] An automatically-set `Accept-Encoding` request header asking the server to compress\n *   responses\n *\n * @param config\n */\nexport function createDefaultRpcTransport<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcTransportConfig<TClusterUrl>,\n): RpcTransportFromClusterUrl<TClusterUrl> {\n    return pipe(\n        createHttpTransportForSolanaRpc({\n            ...config,\n            headers: {\n                ...(__NODEJS__ &&\n                    ({\n                        // Keep these headers lowercase so they will be overridden by any user-supplied headers below.\n                        'accept-encoding':\n                            // Natively supported by Node LTS v20.18.0 and above.\n                            'br,gzip,deflate', // Brotli, gzip, and Deflate, in that order.\n                    } as { [overrideHeader: string]: string })),\n                ...(config.headers ? normalizeHeaders(config.headers) : undefined),\n                ...({\n                    // Keep these headers lowercase so they will override any user-supplied headers above.\n                    'solana-client': __VERSION__ ? `js/${__VERSION__}` : 'UNKNOWN',\n                } as { [overrideHeader: string]: string }),\n            },\n        }) as RpcTransportFromClusterUrl<TClusterUrl>,\n        transport => getRpcTransportWithRequestCoalescing(transport, getSolanaRpcPayloadDeduplicationKey),\n    );\n}\n","import { createSolanaRpcApi } from '@solana/rpc-api';\nimport { createRpc, RpcTransport } from '@solana/rpc-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n\nimport type { RpcFromTransport, SolanaRpcApiFromTransport } from './rpc-clusters';\nimport { DEFAULT_RPC_CONFIG } from './rpc-default-config';\nimport { createDefaultRpcTransport } from './rpc-transport';\n\ntype DefaultRpcTransportConfig<TClusterUrl extends ClusterUrl> = Parameters<\n    typeof createDefaultRpcTransport<TClusterUrl>\n>[0];\n\n/**\n * Creates a {@link Rpc} instance that exposes the Solana JSON RPC API given a cluster URL and some\n * optional transport config. See {@link createDefaultRpcTransport} for the shape of the transport\n * config.\n */\nexport function createSolanaRpc<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<DefaultRpcTransportConfig<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcFromTransport(createDefaultRpcTransport({ url: clusterUrl, ...config }));\n}\n\n/**\n * Creates a {@link Rpc} instance that exposes the Solana JSON RPC API given the supplied\n * {@link RpcTransport}.\n */\nexport function createSolanaRpcFromTransport<TTransport extends RpcTransport>(transport: TTransport) {\n    return createRpc({\n        api: createSolanaRpcApi(DEFAULT_RPC_CONFIG),\n        transport,\n    }) as RpcFromTransport<SolanaRpcApiFromTransport<TTransport>, TTransport>;\n}\n"],"names":["AbortController"],"mappings":"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"}},
    {"offset": {"line": 8992, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/subscribable/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/event-target-impl/src/index.browser.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/subscribable/src/async-iterable.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/subscribable/src/data-publisher.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/subscribable/src/demultiplex.ts"],"sourcesContent":["export const AbortController = globalThis.AbortController;\nexport const EventTarget = globalThis.EventTarget;\n","import {\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { AbortController } from '@solana/event-target-impl';\n\nimport { DataPublisher } from './data-publisher';\n\ntype Config = Readonly<{\n    /**\n     * Triggering this abort signal will cause all iterators spawned from this iterator to return\n     * once they have published all queued messages.\n     */\n    abortSignal: AbortSignal;\n    /**\n     * Messages from this channel of `dataPublisher` will be the ones yielded through the iterators.\n     *\n     * Messages only begin to be queued after the first time an iterator begins to poll. Channel\n     * messages published before that time will be dropped.\n     */\n    dataChannelName: string;\n    // FIXME: It would be nice to be able to constrain the type of `dataPublisher` to one that\n    //        definitely supports the `dataChannelName` and `errorChannelName` channels, and\n    //        furthermore publishes `TData` on the `dataChannelName` channel. This is more difficult\n    //        than it should be: https://tsplay.dev/NlZelW\n    dataPublisher: DataPublisher;\n    /**\n     * Messages from this channel of `dataPublisher` will be the ones thrown through the iterators.\n     *\n     * Any new iterators created after the first error is encountered will reject with that error\n     * when polled.\n     */\n    errorChannelName: string;\n}>;\n\nconst enum PublishType {\n    DATA,\n    ERROR,\n}\n\ntype IteratorKey = symbol;\ntype IteratorState<TData> =\n    | {\n          __hasPolled: false;\n          publishQueue: (\n              | {\n                    __type: PublishType.DATA;\n                    data: TData;\n                }\n              | {\n                    __type: PublishType.ERROR;\n                    err: unknown;\n                }\n          )[];\n      }\n    | {\n          __hasPolled: true;\n          onData: (data: TData) => void;\n          onError: Parameters<ConstructorParameters<typeof Promise>[0]>[1];\n      };\n\nlet EXPLICIT_ABORT_TOKEN: symbol;\nfunction createExplicitAbortToken() {\n    // This function is an annoying workaround to prevent `process.env.NODE_ENV` from appearing at\n    // the top level of this module and thwarting an optimizing compiler's attempt to tree-shake.\n    return Symbol(\n        process.env.NODE_ENV !== \"production\"\n            ? \"This symbol is thrown from a socket's iterator when the connection is explicitly \" +\n                  'aborted by the user'\n            : undefined,\n    );\n}\n\nconst UNINITIALIZED = Symbol();\n\n/**\n * Returns an `AsyncIterable` given a data publisher.\n *\n * The iterable will produce iterators that vend messages published to `dataChannelName` and will\n * throw the first time a message is published to `errorChannelName`. Triggering the abort signal\n * will cause all iterators spawned from this iterator to return once they have published all queued\n * messages.\n *\n * Things to note:\n *\n * - If a message is published over a channel before the `AsyncIterator` attached to it has polled\n *   for the next result, the message will be queued in memory.\n * - Messages only begin to be queued after the first time an iterator begins to poll. Channel\n *   messages published before that time will be dropped.\n * - If there are messages in the queue and an error occurs, all queued messages will be vended to\n *   the iterator before the error is thrown.\n * - If there are messages in the queue and the abort signal fires, all queued messages will be\n *   vended to the iterator after which it will return.\n * - Any new iterators created after the first error is encountered will reject with that error when\n *   polled.\n *\n * @param config\n *\n * @example\n * ```ts\n * const iterable = createAsyncIterableFromDataPublisher({\n *     abortSignal: AbortSignal.timeout(10_000),\n *     dataChannelName: 'message',\n *     dataPublisher,\n *     errorChannelName: 'error',\n * });\n * try {\n *     for await (const message of iterable) {\n *         console.log('Got message', message);\n *     }\n * } catch (e) {\n *     console.error('An error was published to the error channel', e);\n * } finally {\n *     console.log(\"It's been 10 seconds; that's enough for now.\");\n * }\n * ```\n */\nexport function createAsyncIterableFromDataPublisher<TData>({\n    abortSignal,\n    dataChannelName,\n    dataPublisher,\n    errorChannelName,\n}: Config): AsyncIterable<TData> {\n    const iteratorState: Map<IteratorKey, IteratorState<TData>> = new Map();\n    function publishErrorToAllIterators(reason: unknown) {\n        for (const [iteratorKey, state] of iteratorState.entries()) {\n            if (state.__hasPolled) {\n                iteratorState.delete(iteratorKey);\n                state.onError(reason);\n            } else {\n                state.publishQueue.push({\n                    __type: PublishType.ERROR,\n                    err: reason,\n                });\n            }\n        }\n    }\n    const abortController = new AbortController();\n    abortSignal.addEventListener('abort', () => {\n        abortController.abort();\n        publishErrorToAllIterators((EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken()));\n    });\n    const options = { signal: abortController.signal } as const;\n    let firstError: unknown = UNINITIALIZED;\n    dataPublisher.on(\n        errorChannelName,\n        err => {\n            if (firstError === UNINITIALIZED) {\n                firstError = err;\n                abortController.abort();\n                publishErrorToAllIterators(err);\n            }\n        },\n        options,\n    );\n    dataPublisher.on(\n        dataChannelName,\n        data => {\n            iteratorState.forEach((state, iteratorKey) => {\n                if (state.__hasPolled) {\n                    const { onData } = state;\n                    iteratorState.set(iteratorKey, { __hasPolled: false, publishQueue: [] });\n                    onData(data as TData);\n                } else {\n                    state.publishQueue.push({\n                        __type: PublishType.DATA,\n                        data: data as TData,\n                    });\n                }\n            });\n        },\n        options,\n    );\n    return {\n        async *[Symbol.asyncIterator]() {\n            if (abortSignal.aborted) {\n                return;\n            }\n            if (firstError !== UNINITIALIZED) {\n                throw firstError;\n            }\n            const iteratorKey = Symbol();\n            iteratorState.set(iteratorKey, { __hasPolled: false, publishQueue: [] });\n            try {\n                while (true) {\n                    const state = iteratorState.get(iteratorKey);\n                    if (!state) {\n                        // There should always be state by now.\n                        throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING);\n                    }\n                    if (state.__hasPolled) {\n                        // You should never be able to poll twice in a row.\n                        throw new SolanaError(\n                            SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n                        );\n                    }\n                    const publishQueue = state.publishQueue;\n                    try {\n                        if (publishQueue.length) {\n                            state.publishQueue = [];\n                            for (const item of publishQueue) {\n                                if (item.__type === PublishType.DATA) {\n                                    yield item.data;\n                                } else {\n                                    throw item.err;\n                                }\n                            }\n                        } else {\n                            yield await new Promise<TData>((resolve, reject) => {\n                                iteratorState.set(iteratorKey, {\n                                    __hasPolled: true,\n                                    onData: resolve,\n                                    onError: reject,\n                                });\n                            });\n                        }\n                    } catch (e) {\n                        if (e === (EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken())) {\n                            return;\n                        } else {\n                            throw e;\n                        }\n                    }\n                }\n            } finally {\n                iteratorState.delete(iteratorKey);\n            }\n        },\n    };\n}\n","import { TypedEventEmitter, TypedEventTarget } from './event-emitter';\n\ntype UnsubscribeFn = () => void;\n\n/**\n * Represents an object with an `on` function that you can call to subscribe to certain data over a\n * named channel.\n *\n * @example\n * ```ts\n * let dataPublisher: DataPublisher<{ error: SolanaError }>;\n * dataPublisher.on('data', handleData); // ERROR. `data` is not a known channel name.\n * dataPublisher.on('error', e => {\n *     console.error(e);\n * }); // OK.\n * ```\n */\nexport interface DataPublisher<TDataByChannelName extends Record<string, unknown> = Record<string, unknown>> {\n    /**\n     * Call this to subscribe to data over a named channel.\n     *\n     * @param channelName The name of the channel on which to subscribe for messages\n     * @param subscriber The function to call when a message becomes available\n     * @param options.signal An abort signal you can fire to unsubscribe\n     *\n     * @returns A function that you can call to unsubscribe\n     */\n    on<const TChannelName extends keyof TDataByChannelName>(\n        channelName: TChannelName,\n        subscriber: (data: TDataByChannelName[TChannelName]) => void,\n        options?: { signal: AbortSignal },\n    ): UnsubscribeFn;\n}\n\n/**\n * Returns an object with an `on` function that you can call to subscribe to certain data over a\n * named channel.\n *\n * The `on` function returns an unsubscribe function.\n *\n * @example\n * ```ts\n * const socketDataPublisher = getDataPublisherFromEventEmitter(new WebSocket('wss://api.devnet.solana.com'));\n * const unsubscribe = socketDataPublisher.on('message', message => {\n *     if (JSON.parse(message.data).id === 42) {\n *         console.log('Got response 42');\n *         unsubscribe();\n *     }\n * });\n * ```\n */\nexport function getDataPublisherFromEventEmitter<TEventMap extends Record<string, Event>>(\n    eventEmitter: TypedEventEmitter<TEventMap> | TypedEventTarget<TEventMap>,\n): DataPublisher<{\n    [TEventType in keyof TEventMap]: TEventMap[TEventType] extends CustomEvent ? TEventMap[TEventType]['detail'] : null;\n}> {\n    return {\n        on(channelName, subscriber, options) {\n            function innerListener(ev: Event) {\n                if (ev instanceof CustomEvent) {\n                    const data = (ev as CustomEvent<TEventMap[typeof channelName]>).detail;\n                    (subscriber as unknown as (data: TEventMap[typeof channelName]) => void)(data);\n                } else {\n                    (subscriber as () => void)();\n                }\n            }\n            eventEmitter.addEventListener(channelName, innerListener, options);\n            return () => {\n                eventEmitter.removeEventListener(channelName, innerListener);\n            };\n        },\n    };\n}\n","import { EventTarget } from '@solana/event-target-impl';\n\nimport { DataPublisher, getDataPublisherFromEventEmitter } from './data-publisher';\n\n/**\n * Given a channel that carries messages for multiple subscribers on a single channel name, this\n * function returns a new {@link DataPublisher} that splits them into multiple channel names.\n *\n * @param messageTransformer A function that receives the message as the first argument, and returns\n * a tuple of the derived channel name and the message.\n *\n * @example\n * Imagine a channel that carries multiple notifications whose destination is contained within the\n * message itself.\n *\n * ```ts\n * const demuxedDataPublisher = demultiplexDataPublisher(channel, 'message', message => {\n *     const destinationChannelName = `notification-for:${message.subscriberId}`;\n *     return [destinationChannelName, message];\n * });\n * ```\n *\n * Now you can subscribe to _only_ the messages you are interested in, without having to subscribe\n * to the entire `'message'` channel and filter out the messages that are not for you.\n *\n * ```ts\n * demuxedDataPublisher.on(\n *     'notification-for:123',\n *     message => {\n *         console.log('Got a message for subscriber 123', message);\n *     },\n *     { signal: AbortSignal.timeout(5_000) },\n * );\n * ```\n */\nexport function demultiplexDataPublisher<\n    TDataPublisher extends DataPublisher,\n    const TChannelName extends Parameters<TDataPublisher['on']>[0],\n>(\n    publisher: TDataPublisher,\n    sourceChannelName: TChannelName,\n    messageTransformer: (\n        // FIXME: Deriving the type of the message from `TDataPublisher` and `TChannelName` would\n        //        help callers to constrain their transform functions.\n        message: unknown,\n    ) => [destinationChannelName: string, message: unknown] | void,\n): DataPublisher {\n    let innerPublisherState:\n        | {\n              readonly dispose: () => void;\n              numSubscribers: number;\n          }\n        | undefined;\n    const eventTarget = new EventTarget();\n    const demultiplexedDataPublisher = getDataPublisherFromEventEmitter(eventTarget);\n    return {\n        ...demultiplexedDataPublisher,\n        on(channelName, subscriber, options) {\n            if (!innerPublisherState) {\n                const innerPublisherUnsubscribe = publisher.on(sourceChannelName, sourceMessage => {\n                    const transformResult = messageTransformer(sourceMessage);\n                    if (!transformResult) {\n                        return;\n                    }\n                    const [destinationChannelName, message] = transformResult;\n                    eventTarget.dispatchEvent(\n                        new CustomEvent(destinationChannelName, {\n                            detail: message,\n                        }),\n                    );\n                });\n                innerPublisherState = {\n                    dispose: innerPublisherUnsubscribe,\n                    numSubscribers: 0,\n                };\n            }\n            innerPublisherState.numSubscribers++;\n            const unsubscribe = demultiplexedDataPublisher.on(channelName, subscriber, options);\n            let isActive = true;\n            function handleUnsubscribe() {\n                if (!isActive) {\n                    return;\n                }\n                isActive = false;\n                options?.signal.removeEventListener('abort', handleUnsubscribe);\n                innerPublisherState!.numSubscribers--;\n                if (innerPublisherState!.numSubscribers === 0) {\n                    innerPublisherState!.dispose();\n                    innerPublisherState = undefined;\n                }\n                unsubscribe();\n            }\n            options?.signal.addEventListener('abort', handleUnsubscribe);\n            return handleUnsubscribe;\n        },\n    };\n}\n"],"names":["AbortController","EventTarget"],"mappings":"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"}},
    {"offset": {"line": 9188, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/promises/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/promises/src/race.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/promises/src/abortable.ts"],"sourcesContent":["/**\n * Forked from https://github.com/digitalloggers/race-as-promised/tree/master\n *\n * Authored by Brian Kim:\n * https://github.com/nodejs/node/issues/17469#issuecomment-685216777\n *\n * Adapted to module structure.\n *\n * This is free and unencumbered software released into the public domain.\n *\n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n *\n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * For more information, please refer to <http://unlicense.org/>\n */\n\ntype Deferred = Readonly<{\n    reject: (reason?: unknown) => void;\n    resolve: (value: unknown) => void;\n}>;\n\nfunction isObject(value: unknown): value is object {\n    return value !== null && (typeof value === 'object' || typeof value === 'function');\n}\n\nfunction addRaceContender(contender: object) {\n    const deferreds = new Set<Deferred>();\n    const record = { deferreds, settled: false };\n\n    // This call to `then` happens once for the lifetime of the value.\n    Promise.resolve(contender).then(\n        value => {\n            for (const { resolve } of deferreds) {\n                resolve(value);\n            }\n\n            deferreds.clear();\n            record.settled = true;\n        },\n        err => {\n            for (const { reject } of deferreds) {\n                reject(err);\n            }\n\n            deferreds.clear();\n            record.settled = true;\n        },\n    );\n    return record;\n}\n\n// Keys are the values passed to race, values are a record of data containing a\n// set of deferreds and whether the value has settled.\nconst wm = new WeakMap<object, { deferreds: Set<Deferred>; settled: boolean }>();\n/**\n * An implementation of [`Promise.race`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race)\n * that causes all of the losing promises to settle. This allows them to be released and garbage\n * collected, preventing memory leaks.\n *\n * Read more here: https://github.com/nodejs/node/issues/17469\n */\nexport async function safeRace<T extends readonly unknown[] | []>(contenders: T): Promise<Awaited<T[number]>> {\n    let deferred: Deferred;\n    const result = new Promise((resolve, reject) => {\n        deferred = { reject, resolve };\n        for (const contender of contenders) {\n            if (!isObject(contender)) {\n                // If the contender is a primitive, attempting to use it as a key in the\n                // weakmap would throw an error. Luckily, it is safe to call\n                // `Promise.resolve(contender).then` on a primitive value multiple times\n                // because the promise fulfills immediately.\n                Promise.resolve(contender).then(resolve, reject);\n                continue;\n            }\n\n            let record = wm.get(contender);\n            if (record === undefined) {\n                record = addRaceContender(contender);\n                record.deferreds.add(deferred);\n                wm.set(contender, record);\n            } else if (record.settled) {\n                // If the value has settled, it is safe to call\n                // `Promise.resolve(contender).then` on it.\n                Promise.resolve(contender).then(resolve, reject);\n            } else {\n                record.deferreds.add(deferred);\n            }\n        }\n    });\n\n    // The finally callback executes when any value settles, preventing any of\n    // the unresolved values from retaining a reference to the resolved value.\n    return await (result.finally(() => {\n        for (const contender of contenders) {\n            if (isObject(contender)) {\n                const record = wm.get(contender)!;\n                record.deferreds.delete(deferred);\n            }\n        }\n    }) as Promise<Awaited<T[number]>>);\n}\n","import { safeRace } from './race';\n\n/**\n * Returns a new promise that will reject if the abort signal fires before the original promise\n * settles. Resolves or rejects with the value of the original promise otherwise.\n *\n * @example\n * ```ts\n * const result = await getAbortablePromise(\n *     // Resolves or rejects when `fetch` settles.\n *     fetch('https://example.com/json').then(r => r.json()),\n *     // ...unless it takes longer than 5 seconds, after which the `AbortSignal` is triggered.\n *     AbortSignal.timeout(5000),\n * );\n * ```\n */\nexport function getAbortablePromise<T>(promise: Promise<T>, abortSignal?: AbortSignal): Promise<T> {\n    if (!abortSignal) {\n        return promise;\n    } else {\n        return safeRace([\n            // This promise only ever rejects if the signal is aborted. Otherwise it idles forever.\n            // It's important that this come before the input promise; in the event of an abort, we\n            // want to throw even if the input promise's result is ready\n            new Promise<never>((_, reject) => {\n                if (abortSignal.aborted) {\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                    reject(abortSignal.reason);\n                } else {\n                    abortSignal.addEventListener('abort', function () {\n                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                        reject(this.reason);\n                    });\n                }\n            }),\n            promise,\n        ]);\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 9282, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/rpc-subscriptions-spec/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-subscriptions-spec/src/rpc-subscriptions.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-subscriptions-spec/src/rpc-subscriptions-api.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-subscriptions-spec/src/rpc-subscriptions-channel.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/event-target-impl/src/index.browser.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-subscriptions-spec/src/rpc-subscriptions-pubsub-plan.ts"],"sourcesContent":["import { SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN, SolanaError } from '@solana/errors';\nimport { Callable, Flatten, OverloadImplementations, UnionToIntersection } from '@solana/rpc-spec-types';\nimport { createAsyncIterableFromDataPublisher } from '@solana/subscribable';\n\nimport { RpcSubscriptionsApi, RpcSubscriptionsPlan } from './rpc-subscriptions-api';\nimport { PendingRpcSubscriptionsRequest, RpcSubscribeOptions } from './rpc-subscriptions-request';\nimport { RpcSubscriptionsTransport } from './rpc-subscriptions-transport';\n\nexport type RpcSubscriptionsConfig<TRpcMethods> = Readonly<{\n    api: RpcSubscriptionsApi<TRpcMethods>;\n    transport: RpcSubscriptionsTransport;\n}>;\n\n/**\n * An object that exposes all of the functions described by `TRpcSubscriptionsMethods`.\n *\n * Calling each method returns a\n * {@link PendingRpcSubscriptionsRequest | PendingRpcSubscriptionsRequest<TNotification>} where\n * `TNotification` is that method's notification type.\n */\nexport type RpcSubscriptions<TRpcSubscriptionsMethods> = {\n    [TMethodName in keyof TRpcSubscriptionsMethods]: PendingRpcSubscriptionsRequestBuilder<\n        OverloadImplementations<TRpcSubscriptionsMethods, TMethodName>\n    >;\n};\n\ntype PendingRpcSubscriptionsRequestBuilder<TSubscriptionMethodImplementations> = UnionToIntersection<\n    Flatten<{\n        [P in keyof TSubscriptionMethodImplementations]: PendingRpcSubscriptionsRequestReturnTypeMapper<\n            TSubscriptionMethodImplementations[P]\n        >;\n    }>\n>;\n\ntype PendingRpcSubscriptionsRequestReturnTypeMapper<TSubscriptionMethodImplementation> =\n    // Check that this property of the TRpcSubscriptionMethods interface is, in fact, a function.\n    TSubscriptionMethodImplementation extends Callable\n        ? (\n              ...args: Parameters<TSubscriptionMethodImplementation>\n          ) => PendingRpcSubscriptionsRequest<ReturnType<TSubscriptionMethodImplementation>>\n        : never;\n\n/**\n * Creates a {@link RpcSubscriptions} instance given a\n * {@link RpcSubscriptionsApi | RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>} and a\n * {@link RpcSubscriptionsTransport} capable of fulfilling them.\n */\nexport function createSubscriptionRpc<TRpcSubscriptionsApiMethods>(\n    rpcConfig: RpcSubscriptionsConfig<TRpcSubscriptionsApiMethods>,\n): RpcSubscriptions<TRpcSubscriptionsApiMethods> {\n    return new Proxy(rpcConfig.api, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get(target, p, receiver) {\n            if (p === 'then') {\n                return undefined;\n            }\n            return function (...rawParams: unknown[]) {\n                const notificationName = p.toString();\n                const createRpcSubscriptionPlan = Reflect.get(target, notificationName, receiver);\n                if (!createRpcSubscriptionPlan) {\n                    throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN, {\n                        notificationName,\n                    });\n                }\n                const subscriptionPlan = createRpcSubscriptionPlan(...rawParams);\n                return createPendingRpcSubscription(rpcConfig.transport, subscriptionPlan);\n            };\n        },\n    }) as RpcSubscriptions<TRpcSubscriptionsApiMethods>;\n}\n\nfunction createPendingRpcSubscription<TNotification>(\n    transport: RpcSubscriptionsTransport,\n    subscriptionsPlan: RpcSubscriptionsPlan<TNotification>,\n): PendingRpcSubscriptionsRequest<TNotification> {\n    return {\n        async subscribe({ abortSignal }: RpcSubscribeOptions): Promise<AsyncIterable<TNotification>> {\n            const notificationsDataPublisher = await transport({\n                signal: abortSignal,\n                ...subscriptionsPlan,\n            });\n            return createAsyncIterableFromDataPublisher<TNotification>({\n                abortSignal,\n                dataChannelName: 'notification',\n                dataPublisher: notificationsDataPublisher,\n                errorChannelName: 'error',\n            });\n        },\n    };\n}\n","import { Callable, RpcRequest, RpcRequestTransformer } from '@solana/rpc-spec-types';\nimport { DataPublisher } from '@solana/subscribable';\n\nimport { RpcSubscriptionsChannel } from './rpc-subscriptions-channel';\nimport { RpcSubscriptionsTransportDataEvents } from './rpc-subscriptions-transport';\n\nexport type RpcSubscriptionsApiConfig<TApiMethods extends RpcSubscriptionsApiMethods> = Readonly<{\n    planExecutor: RpcSubscriptionsPlanExecutor<ReturnType<TApiMethods[keyof TApiMethods]>>;\n    /**\n     * An optional function that transforms the {@link RpcRequest} before it is sent to the JSON RPC\n     * server.\n     *\n     * This is useful when the params supplied by the caller need to be transformed before\n     * forwarding the message to the server. Use cases for this include applying defaults,\n     * forwarding calls to renamed methods, and serializing complex values.\n     */\n    requestTransformer?: RpcRequestTransformer;\n}>;\n\n/**\n * A function that implements a protocol for subscribing and unsubscribing from notifications given\n * a {@link RpcSubscriptionsChannel}, a {@link RpcRequest}, and an `AbortSignal`.\n *\n * @returns A {@link DataPublisher} that emits {@link RpcSubscriptionsTransportDataEvents}\n */\ntype RpcSubscriptionsPlanExecutor<TNotification> = (\n    config: Readonly<{\n        channel: RpcSubscriptionsChannel<unknown, unknown>;\n        request: RpcRequest;\n        signal: AbortSignal;\n    }>,\n) => Promise<DataPublisher<RpcSubscriptionsTransportDataEvents<TNotification>>>;\n\n/**\n * This type allows an {@link RpcSubscriptionsApi} to describe how a particular subscription should\n * be issued to the JSON RPC server.\n *\n * Given a function that was called on a {@link RpcSubscriptions}, this object exposes an `execute`\n * function that dictates which subscription request will be sent, how the underlying transport will\n * be used, and how the notifications will be transformed.\n *\n * This function accepts a {@link RpcSubscriptionsChannel} and an `AbortSignal` and asynchronously\n * returns a {@link DataPublisher}. This gives us the opportunity to:\n *\n * - define the `payload` from the requested method name and parameters before passing it to the\n *   channel.\n * - call the underlying channel zero, one or multiple times depending on the use-case (e.g.\n *   caching or coalescing multiple subscriptions).\n * - transform the notification from the JSON RPC server, in case it does not match the\n *   `TNotification` specified by the\n *   {@link PendingRpcSubscriptionsRequest | PendingRpcSubscriptionsRequest<TNotification>} emitted\n *   from the publisher returned.\n */\nexport type RpcSubscriptionsPlan<TNotification> = Readonly<{\n    /**\n     * This method may be called with a newly-opened channel or a pre-established channel.\n     */\n    execute: (\n        config: Readonly<{\n            channel: RpcSubscriptionsChannel<unknown, unknown>;\n            signal: AbortSignal;\n        }>,\n    ) => Promise<DataPublisher<RpcSubscriptionsTransportDataEvents<TNotification>>>;\n    /**\n     * This request is used to uniquely identify the subscription.\n     * It typically comes from the method name and parameters of the subscription call,\n     * after potentially being transformed by the RPC Subscriptions API.\n     */\n    request: RpcRequest;\n}>;\n\n/**\n * For each of `TRpcSubscriptionsMethods`, this object exposes a method with the same name that maps\n * between its input arguments and a\n * {@link RpcSubscriptionsPlan | RpcSubscriptionsPlan<TNotification>} that implements the execution\n * of a JSON RPC subscription for `TNotifications`.\n */\nexport type RpcSubscriptionsApi<TRpcSubscriptionMethods> = {\n    [MethodName in keyof TRpcSubscriptionMethods]: RpcSubscriptionsReturnTypeMapper<\n        TRpcSubscriptionMethods[MethodName]\n    >;\n};\n\ntype RpcSubscriptionsReturnTypeMapper<TRpcMethod> = TRpcMethod extends Callable\n    ? (...rawParams: unknown[]) => RpcSubscriptionsPlan<ReturnType<TRpcMethod>>\n    : never;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RpcSubscriptionsApiMethod = (...args: any) => any;\nexport interface RpcSubscriptionsApiMethods {\n    [methodName: string]: RpcSubscriptionsApiMethod;\n}\n\n/**\n * Creates a JavaScript proxy that converts _any_ function call called on it to a\n * {@link RpcSubscriptionsPlan} by creating an `execute` function that:\n *\n * - calls the supplied {@link RpcSubscriptionsApiConfig.planExecutor} with a JSON RPC v2 payload\n *   object with the requested `methodName` and `params` properties, optionally transformed by\n *   {@link RpcSubscriptionsApiConfig.requestTransformer}.\n *\n * @example\n * ```ts\n * // For example, given this `RpcSubscriptionsApi`:\n * const rpcSubscriptionsApi = createJsonRpcSubscriptionsApi({\n *     async planExecutor({ channel, request }) {\n *         await channel.send(request);\n *         return {\n *             ...channel,\n *             on(type, listener, options) {\n *                 if (type !== 'message') {\n *                     return channel.on(type, listener, options);\n *                 }\n *                 return channel.on(\n *                     'message',\n *                     function resultGettingListener(message) {\n *                         listener(message.result);\n *                     },\n *                     options,\n *                 );\n *             }\n *         }\n *     },\n *     requestTransformer: (...rawParams) => rawParams.reverse(),\n * });\n *\n * // ...the following function call:\n * rpcSubscriptionsApi.foo('bar', { baz: 'bat' });\n *\n * // ...will produce a `RpcSubscriptionsPlan` that:\n * // -   Uses the following payload: { id: 1, jsonrpc: '2.0', method: 'foo', params: [{ baz: 'bat' }, 'bar'] }.\n * // -   Emits the \"result\" property of each RPC Subscriptions message.\n * ```\n */\nexport function createRpcSubscriptionsApi<TRpcSubscriptionsApiMethods extends RpcSubscriptionsApiMethods>(\n    config: RpcSubscriptionsApiConfig<TRpcSubscriptionsApiMethods>,\n): RpcSubscriptionsApi<TRpcSubscriptionsApiMethods> {\n    return new Proxy({} as RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get<TNotificationName extends keyof RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>>(\n            ...args: Parameters<NonNullable<ProxyHandler<RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>>['get']>>\n        ) {\n            const [_, p] = args;\n            const methodName = p.toString() as keyof TRpcSubscriptionsApiMethods as string;\n            return function (\n                ...params: Parameters<\n                    TRpcSubscriptionsApiMethods[TNotificationName] extends CallableFunction\n                        ? TRpcSubscriptionsApiMethods[TNotificationName]\n                        : never\n                >\n            ): RpcSubscriptionsPlan<ReturnType<TRpcSubscriptionsApiMethods[TNotificationName]>> {\n                const rawRequest = { methodName, params };\n                const request = config.requestTransformer ? config.requestTransformer(rawRequest) : rawRequest;\n                return {\n                    execute(planConfig) {\n                        return config.planExecutor({ ...planConfig, request });\n                    },\n                    request,\n                };\n            };\n        },\n    });\n}\n","import {\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SolanaError,\n} from '@solana/errors';\nimport { DataPublisher } from '@solana/subscribable';\n\ntype RpcSubscriptionsChannelSolanaErrorCode =\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT;\n\nexport type RpcSubscriptionChannelEvents<TInboundMessage> = {\n    /**\n     * Fires when the channel closes unexpectedly.\n     * @eventProperty\n     */\n    error: SolanaError<RpcSubscriptionsChannelSolanaErrorCode>;\n    /**\n     * Fires on every message received from the remote end.\n     * @eventProperty\n     */\n    message: TInboundMessage;\n};\n\n/**\n * A {@link DataPublisher} on which you can subscribe to events of type\n * {@link RpcSubscriptionChannelEvents | RpcSubscriptionChannelEvents<TInboundMessage>}.\n * Additionally, you can use this object to send messages of type `TOutboundMessage` back to the\n * remote end by calling its {@link RpcSubscriptionsChannel.send | `send(message)`} method.\n */\nexport interface RpcSubscriptionsChannel<TOutboundMessage, TInboundMessage>\n    extends DataPublisher<RpcSubscriptionChannelEvents<TInboundMessage>> {\n    send(message: TOutboundMessage): Promise<void>;\n}\n\n/**\n * A channel creator is a function that accepts an `AbortSignal`, returns a new\n * {@link RpcSubscriptionsChannel}, and tears down the channel when the abort signal fires.\n */\nexport type RpcSubscriptionsChannelCreator<TOutboundMessage, TInboundMessage> = (\n    config: Readonly<{\n        abortSignal: AbortSignal;\n    }>,\n) => Promise<RpcSubscriptionsChannel<TOutboundMessage, TInboundMessage>>;\n\n/**\n * Given a channel with inbound messages of type `T` and a function of type `T => U`, returns a new\n * channel with inbound messages of type `U`.\n *\n * Note that this only affects messages of type `\"message\"` and thus, does not affect incoming error\n * messages.\n *\n * @example Parsing incoming JSON messages\n * ```ts\n * const transformedChannel = transformChannelInboundMessages(channel, JSON.parse);\n * ```\n */\nexport function transformChannelInboundMessages<TOutboundMessage, TNewInboundMessage, TInboundMessage>(\n    channel: RpcSubscriptionsChannel<TOutboundMessage, TInboundMessage>,\n    transform: (message: TInboundMessage) => TNewInboundMessage,\n): RpcSubscriptionsChannel<TOutboundMessage, TNewInboundMessage> {\n    return Object.freeze<RpcSubscriptionsChannel<TOutboundMessage, TNewInboundMessage>>({\n        ...channel,\n        on(type, subscriber, options) {\n            if (type !== 'message') {\n                return channel.on(\n                    type,\n                    subscriber as (data: RpcSubscriptionChannelEvents<TInboundMessage>[typeof type]) => void,\n                    options,\n                );\n            }\n            return channel.on(\n                'message',\n                message => (subscriber as (data: TNewInboundMessage) => void)(transform(message)),\n                options,\n            );\n        },\n    });\n}\n\n/**\n * Given a channel with outbound messages of type `T` and a function of type `U => T`, returns a new\n * channel with outbound messages of type `U`.\n *\n * @example Stringifying JSON messages before sending them over the wire\n * ```ts\n * const transformedChannel = transformChannelOutboundMessages(channel, JSON.stringify);\n * ```\n */\nexport function transformChannelOutboundMessages<TNewOutboundMessage, TOutboundMessage, TInboundMessage>(\n    channel: RpcSubscriptionsChannel<TOutboundMessage, TInboundMessage>,\n    transform: (message: TNewOutboundMessage) => TOutboundMessage,\n): RpcSubscriptionsChannel<TNewOutboundMessage, TInboundMessage> {\n    return Object.freeze<RpcSubscriptionsChannel<TNewOutboundMessage, TInboundMessage>>({\n        ...channel,\n        send: message => channel.send(transform(message)),\n    });\n}\n","export const AbortController = globalThis.AbortController;\nexport const EventTarget = globalThis.EventTarget;\n","import {\n    getSolanaErrorFromJsonRpcError,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID,\n    SolanaError,\n} from '@solana/errors';\nimport { AbortController } from '@solana/event-target-impl';\nimport { safeRace } from '@solana/promises';\nimport { createRpcMessage, RpcRequest, RpcResponseData, RpcResponseTransformer } from '@solana/rpc-spec-types';\nimport { DataPublisher } from '@solana/subscribable';\nimport { demultiplexDataPublisher } from '@solana/subscribable';\n\nimport { RpcSubscriptionChannelEvents } from './rpc-subscriptions-channel';\nimport { RpcSubscriptionsChannel } from './rpc-subscriptions-channel';\n\ntype Config<TNotification> = Readonly<{\n    channel: RpcSubscriptionsChannel<unknown, RpcNotification<TNotification> | RpcResponseData<RpcSubscriptionId>>;\n    responseTransformer?: RpcResponseTransformer;\n    signal: AbortSignal;\n    subscribeRequest: RpcRequest;\n    unsubscribeMethodName: string;\n}>;\n\ntype RpcNotification<TNotification> = Readonly<{\n    method: string;\n    params: Readonly<{\n        result: TNotification;\n        subscription: number;\n    }>;\n}>;\n\ntype RpcSubscriptionId = number;\n\ntype RpcSubscriptionNotificationEvents<TNotification> = Omit<RpcSubscriptionChannelEvents<TNotification>, 'message'> & {\n    notification: TNotification;\n};\n\nconst subscriberCountBySubscriptionIdByChannel = new WeakMap<WeakKey, Record<number, number>>();\nfunction decrementSubscriberCountAndReturnNewCount(channel: WeakKey, subscriptionId?: number): number | undefined {\n    return augmentSubscriberCountAndReturnNewCount(-1, channel, subscriptionId);\n}\nfunction incrementSubscriberCount(channel: WeakKey, subscriptionId?: number): void {\n    augmentSubscriberCountAndReturnNewCount(1, channel, subscriptionId);\n}\nfunction getSubscriberCountBySubscriptionIdForChannel(channel: WeakKey): Record<number, number> {\n    let subscriberCountBySubscriptionId = subscriberCountBySubscriptionIdByChannel.get(channel);\n    if (!subscriberCountBySubscriptionId) {\n        subscriberCountBySubscriptionIdByChannel.set(channel, (subscriberCountBySubscriptionId = {}));\n    }\n    return subscriberCountBySubscriptionId;\n}\nfunction augmentSubscriberCountAndReturnNewCount(\n    amount: -1 | 1,\n    channel: WeakKey,\n    subscriptionId?: number,\n): number | undefined {\n    if (subscriptionId === undefined) {\n        return;\n    }\n    const subscriberCountBySubscriptionId = getSubscriberCountBySubscriptionIdForChannel(channel);\n    if (!subscriberCountBySubscriptionId[subscriptionId] && amount > 0) {\n        subscriberCountBySubscriptionId[subscriptionId] = 0;\n    }\n    const newCount = amount + subscriberCountBySubscriptionId[subscriptionId];\n    if (newCount <= 0) {\n        delete subscriberCountBySubscriptionId[subscriptionId];\n    } else {\n        subscriberCountBySubscriptionId[subscriptionId] = newCount;\n    }\n    return newCount;\n}\n\nconst cache = new WeakMap();\nfunction getMemoizedDemultiplexedNotificationPublisherFromChannelAndResponseTransformer<TNotification>(\n    channel: RpcSubscriptionsChannel<unknown, RpcNotification<TNotification>>,\n    subscribeRequest: RpcRequest,\n    responseTransformer?: RpcResponseTransformer,\n): DataPublisher<{\n    [channelName: `notification:${number}`]: TNotification;\n}> {\n    let publisherByResponseTransformer = cache.get(channel);\n    if (!publisherByResponseTransformer) {\n        cache.set(channel, (publisherByResponseTransformer = new WeakMap()));\n    }\n    const responseTransformerKey = responseTransformer ?? channel;\n    let publisher = publisherByResponseTransformer.get(responseTransformerKey);\n    if (!publisher) {\n        publisherByResponseTransformer.set(\n            responseTransformerKey,\n            (publisher = demultiplexDataPublisher(channel, 'message', rawMessage => {\n                const message = rawMessage as RpcNotification<unknown> | RpcResponseData<unknown>;\n                if (!('method' in message)) {\n                    return;\n                }\n                const transformedNotification = responseTransformer\n                    ? responseTransformer(message.params.result, subscribeRequest)\n                    : message.params.result;\n                return [`notification:${message.params.subscription}`, transformedNotification];\n            })),\n        );\n    }\n    return publisher;\n}\n\n/**\n * Given a channel, this function executes the particular subscription plan required by the Solana\n * JSON RPC Subscriptions API.\n *\n * @param config\n *\n * 1. Calls the `subscribeRequest` on the remote RPC\n * 2. Waits for a response containing the subscription id\n * 3. Returns a {@link DataPublisher} that publishes notifications related to that subscriptions id,\n *    filtering out all others\n * 4. Calls the `unsubscribeMethodName` on the remote RPC when the abort signal is fired.\n */\nexport async function executeRpcPubSubSubscriptionPlan<TNotification>({\n    channel,\n    responseTransformer,\n    signal,\n    subscribeRequest,\n    unsubscribeMethodName,\n}: Config<TNotification>): Promise<DataPublisher<RpcSubscriptionNotificationEvents<TNotification>>> {\n    let subscriptionId: number | undefined;\n    channel.on(\n        'error',\n        () => {\n            // An error on the channel indicates that the subscriptions are dead.\n            // There is no longer any sense hanging on to subscription ids.\n            // Erasing it here will prevent the unsubscribe code from running.\n            subscriptionId = undefined;\n            subscriberCountBySubscriptionIdByChannel.delete(channel);\n        },\n        { signal },\n    );\n    /**\n     * STEP 1\n     * Create a promise that rejects if this subscription is aborted and sends\n     * the unsubscribe message if the subscription is active at that time.\n     */\n    const abortPromise = new Promise<never>((_, reject) => {\n        function handleAbort(this: AbortSignal) {\n            /**\n             * Because of https://github.com/solana-labs/solana/pull/18943, two subscriptions for\n             * materially the same notification will be coalesced on the server. This means they\n             * will be assigned the same subscription id, and will occupy one subscription slot. We\n             * must be careful not to send the unsubscribe message until the last subscriber aborts.\n             */\n            if (decrementSubscriberCountAndReturnNewCount(channel, subscriptionId) === 0) {\n                const unsubscribePayload = createRpcMessage({\n                    methodName: unsubscribeMethodName,\n                    params: [subscriptionId],\n                });\n                subscriptionId = undefined;\n                channel.send(unsubscribePayload).catch(() => {});\n            }\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            reject(this.reason);\n        }\n        if (signal.aborted) {\n            handleAbort.call(signal);\n        } else {\n            signal.addEventListener('abort', handleAbort);\n        }\n    });\n    /**\n     * STEP 2\n     * Send the subscription request.\n     */\n    const subscribePayload = createRpcMessage(subscribeRequest);\n    await channel.send(subscribePayload);\n    /**\n     * STEP 3\n     * Wait for the acknowledgement from the server with the subscription id.\n     */\n    const subscriptionIdPromise = new Promise<RpcSubscriptionId>((resolve, reject) => {\n        const abortController = new AbortController();\n        signal.addEventListener('abort', abortController.abort.bind(abortController));\n        const options = { signal: abortController.signal } as const;\n        channel.on(\n            'error',\n            err => {\n                abortController.abort();\n                reject(err);\n            },\n            options,\n        );\n        channel.on(\n            'message',\n            message => {\n                if (message && typeof message === 'object' && 'id' in message && message.id === subscribePayload.id) {\n                    abortController.abort();\n                    if ('error' in message) {\n                        reject(getSolanaErrorFromJsonRpcError(message.error));\n                    } else {\n                        resolve(message.result);\n                    }\n                }\n            },\n            options,\n        );\n    });\n    subscriptionId = await safeRace([abortPromise, subscriptionIdPromise]);\n    if (subscriptionId == null) {\n        throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID);\n    }\n    incrementSubscriberCount(channel, subscriptionId);\n    /**\n     * STEP 4\n     * Filter out notifications unrelated to this subscription.\n     */\n    const notificationPublisher = getMemoizedDemultiplexedNotificationPublisherFromChannelAndResponseTransformer(\n        channel,\n        subscribeRequest,\n        responseTransformer,\n    );\n    const notificationKey = `notification:${subscriptionId}` as const;\n    return {\n        on(type, listener, options) {\n            switch (type) {\n                case 'notification':\n                    return notificationPublisher.on(\n                        notificationKey,\n                        listener as (data: RpcSubscriptionNotificationEvents<TNotification>['notification']) => void,\n                        options,\n                    );\n                case 'error':\n                    return channel.on(\n                        'error',\n                        listener as (data: RpcSubscriptionNotificationEvents<TNotification>['error']) => void,\n                        options,\n                    );\n                default:\n                    throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED, {\n                        channelName: type,\n                        supportedChannelNames: ['notification', 'error'],\n                    });\n            }\n        },\n    };\n}\n"],"names":["AbortController","SolanaError"],"mappings":"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"}},
    {"offset": {"line": 9536, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/rpc-subscriptions-api/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-subscriptions-api/src/index.ts"],"sourcesContent":["import {\n    createRpcSubscriptionsApi,\n    executeRpcPubSubSubscriptionPlan,\n    RpcSubscriptionsApi,\n    RpcSubscriptionsApiMethods,\n} from '@solana/rpc-subscriptions-spec';\nimport {\n    AllowedNumericKeypaths,\n    getDefaultRequestTransformerForSolanaRpc,\n    getDefaultResponseTransformerForSolanaRpcSubscriptions,\n    jsonParsedAccountsConfigs,\n    KEYPATH_WILDCARD,\n    RequestTransformerConfig,\n} from '@solana/rpc-transformers';\n\nimport { AccountNotificationsApi } from './account-notifications';\nimport { BlockNotificationsApi } from './block-notifications';\nimport { LogsNotificationsApi } from './logs-notifications';\nimport { ProgramNotificationsApi } from './program-notifications';\nimport { RootNotificationsApi } from './root-notifications';\nimport { SignatureNotificationsApi } from './signature-notifications';\nimport { SlotNotificationsApi } from './slot-notifications';\nimport { SlotsUpdatesNotificationsApi } from './slots-updates-notifications';\nimport { VoteNotificationsApi } from './vote-notifications';\n\nexport type SolanaRpcSubscriptionsApi = AccountNotificationsApi &\n    LogsNotificationsApi &\n    ProgramNotificationsApi &\n    RootNotificationsApi &\n    SignatureNotificationsApi &\n    SlotNotificationsApi;\nexport type SolanaRpcSubscriptionsApiUnstable = BlockNotificationsApi &\n    SlotsUpdatesNotificationsApi &\n    VoteNotificationsApi;\n\nexport type {\n    AccountNotificationsApi,\n    BlockNotificationsApi,\n    LogsNotificationsApi,\n    ProgramNotificationsApi,\n    RootNotificationsApi,\n    SignatureNotificationsApi,\n    SlotNotificationsApi,\n    SlotsUpdatesNotificationsApi,\n    VoteNotificationsApi,\n};\n\ntype Config = RequestTransformerConfig;\n\nfunction createSolanaRpcSubscriptionsApi_INTERNAL<TApi extends RpcSubscriptionsApiMethods>(\n    config?: Config,\n): RpcSubscriptionsApi<TApi> {\n    const requestTransformer = getDefaultRequestTransformerForSolanaRpc(config);\n    const responseTransformer = getDefaultResponseTransformerForSolanaRpcSubscriptions({\n        allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n    });\n    return createRpcSubscriptionsApi<TApi>({\n        planExecutor({ request, ...rest }) {\n            return executeRpcPubSubSubscriptionPlan({\n                ...rest,\n                responseTransformer,\n                subscribeRequest: { ...request, methodName: request.methodName.replace(/Notifications$/, 'Subscribe') },\n                unsubscribeMethodName: request.methodName.replace(/Notifications$/, 'Unsubscribe'),\n            });\n        },\n        requestTransformer,\n    });\n}\n\nexport function createSolanaRpcSubscriptionsApi<TApi extends RpcSubscriptionsApiMethods = SolanaRpcSubscriptionsApi>(\n    config?: Config,\n): RpcSubscriptionsApi<TApi> {\n    return createSolanaRpcSubscriptionsApi_INTERNAL<TApi>(config);\n}\n\nexport function createSolanaRpcSubscriptionsApi_UNSTABLE(config?: Config) {\n    return createSolanaRpcSubscriptionsApi_INTERNAL<SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>(\n        config,\n    );\n}\n\nlet memoizedKeypaths: AllowedNumericKeypaths<\n    RpcSubscriptionsApi<SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>\n>;\n\n/**\n * These are keypaths at the end of which you will find a numeric value that should *not* be upcast\n * to a `bigint`. These are values that are legitimately defined as `u8` or `usize` on the backend.\n */\nfunction getAllowedNumericKeypaths(): AllowedNumericKeypaths<\n    RpcSubscriptionsApi<SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>\n> {\n    if (!memoizedKeypaths) {\n        memoizedKeypaths = {\n            accountNotifications: jsonParsedAccountsConfigs.map(c => ['value', ...c]),\n            blockNotifications: [\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'preTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'accountIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'preTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'postTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'accountIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'postTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['value', 'block', 'transactions', KEYPATH_WILDCARD, 'meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    'index',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'programIdIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'accounts',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'addressTableLookups',\n                    KEYPATH_WILDCARD,\n                    'writableIndexes',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'addressTableLookups',\n                    KEYPATH_WILDCARD,\n                    'readonlyIndexes',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'programIdIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'accounts',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'header',\n                    'numReadonlySignedAccounts',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'header',\n                    'numReadonlyUnsignedAccounts',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'header',\n                    'numRequiredSignatures',\n                ],\n                ['value', 'block', 'rewards', KEYPATH_WILDCARD, 'commission'],\n            ],\n            programNotifications: jsonParsedAccountsConfigs.flatMap(c => [\n                ['value', KEYPATH_WILDCARD, 'account', ...c],\n                [KEYPATH_WILDCARD, 'account', ...c],\n            ]),\n        };\n    }\n    return memoizedKeypaths;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 9778, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/rpc-subscriptions-channel-websocket/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/event-target-impl/src/index.browser.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/ws-impl/src/index.browser.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-subscriptions-channel-websocket/src/websocket-channel.ts"],"sourcesContent":["export const AbortController = globalThis.AbortController;\nexport const EventTarget = globalThis.EventTarget;\n","export default globalThis.WebSocket;\n","import {\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SolanaError,\n} from '@solana/errors';\nimport { EventTarget } from '@solana/event-target-impl';\nimport { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\nimport { getDataPublisherFromEventEmitter } from '@solana/subscribable';\nimport WebSocket from '@solana/ws-impl';\n\nexport type Config = Readonly<{\n    /**\n     * The number of bytes to admit into the WebSocket's send buffer before queueing messages on the\n     * client.\n     *\n     * When you call {@link RpcSubscriptionsChannel.send | `send()`} on a `WebSocket` the runtime\n     * might add the message to a buffer rather than send it right away. In the event that\n     * `socket.bufferedAmount` exceeds the value configured here, messages will be added to a queue\n     * in your application code instead of being sent to the WebSocket, until such time as the\n     * `bufferedAmount` falls back below the high watermark.\n     */\n    sendBufferHighWatermark: number;\n    /**\n     * An `AbortSignal` to fire when you want to explicitly close the `WebSocket`.\n     *\n     * If the channel is open it will be closed with a normal closure code\n     * (https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1) If the channel has not been\n     * established yet, firing this signal will result in the `AbortError` being thrown to the\n     * caller who was trying to open the channel.\n     */\n    signal: AbortSignal;\n    /**\n     * A string representing the target endpoint.\n     *\n     * In Node, it must be an absolute URL using the `ws` or `wss` protocol.\n     */\n    url: string;\n}>;\n\ntype WebSocketMessage = ArrayBufferLike | ArrayBufferView | Blob | string;\n\nconst NORMAL_CLOSURE_CODE = 1000; // https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1\n\n/**\n * Creates an object that represents an open channel to a `WebSocket` server.\n *\n * You can use it to send messages by calling its\n * {@link RpcSubscriptionsChannel.send | `send()`} function and you can receive them by subscribing\n * to the {@link RpcSubscriptionChannelEvents} it emits.\n */\nexport function createWebSocketChannel({\n    sendBufferHighWatermark,\n    signal,\n    url,\n}: Config): Promise<RpcSubscriptionsChannel<WebSocketMessage, string>> {\n    if (signal.aborted) {\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        return Promise.reject(signal.reason);\n    }\n    let bufferDrainWatcher: Readonly<{ onCancel(): void; promise: Promise<void> }> | undefined;\n    let hasConnected = false;\n    const listenerRemovers = new Set<() => void>();\n    function cleanupListeners() {\n        listenerRemovers.forEach(r => {\n            r();\n        });\n        listenerRemovers.clear();\n    }\n    function handleAbort() {\n        cleanupListeners();\n        if (!hasConnected) {\n            rejectOpen(signal.reason);\n        }\n        if (webSocket.readyState !== WebSocket.CLOSED && webSocket.readyState !== WebSocket.CLOSING) {\n            webSocket.close(NORMAL_CLOSURE_CODE);\n        }\n    }\n    function handleClose(ev: CloseEvent) {\n        cleanupListeners();\n        bufferDrainWatcher?.onCancel();\n        signal.removeEventListener('abort', handleAbort);\n        webSocket.removeEventListener('close', handleClose);\n        webSocket.removeEventListener('error', handleError);\n        webSocket.removeEventListener('message', handleMessage);\n        webSocket.removeEventListener('open', handleOpen);\n        if (!signal.aborted && !(ev.wasClean && ev.code === NORMAL_CLOSURE_CODE)) {\n            eventTarget.dispatchEvent(\n                new CustomEvent('error', {\n                    detail: new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED, {\n                        cause: ev,\n                    }),\n                }),\n            );\n        }\n    }\n    function handleError(ev: Event) {\n        if (signal.aborted) {\n            return;\n        }\n        if (!hasConnected) {\n            const failedToConnectError = new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT, {\n                errorEvent: ev,\n            });\n            rejectOpen(failedToConnectError);\n            eventTarget.dispatchEvent(\n                new CustomEvent('error', {\n                    detail: failedToConnectError,\n                }),\n            );\n        }\n    }\n    function handleMessage(ev: MessageEvent) {\n        if (signal.aborted) {\n            return;\n        }\n        eventTarget.dispatchEvent(new CustomEvent('message', { detail: ev.data }));\n    }\n    const eventTarget = new EventTarget();\n    const dataPublisher = getDataPublisherFromEventEmitter(eventTarget);\n    function handleOpen() {\n        hasConnected = true;\n        resolveOpen({\n            ...dataPublisher,\n            async send(message) {\n                if (webSocket.readyState !== WebSocket.OPEN) {\n                    throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED);\n                }\n                if (!bufferDrainWatcher && webSocket.bufferedAmount > sendBufferHighWatermark) {\n                    let onCancel!: () => void;\n                    const promise = new Promise<void>((resolve, reject) => {\n                        const intervalId = setInterval(() => {\n                            if (\n                                webSocket.readyState !== WebSocket.OPEN ||\n                                !(webSocket.bufferedAmount > sendBufferHighWatermark)\n                            ) {\n                                clearInterval(intervalId);\n                                bufferDrainWatcher = undefined;\n                                resolve();\n                            }\n                        }, 16);\n                        onCancel = () => {\n                            bufferDrainWatcher = undefined;\n                            clearInterval(intervalId);\n                            reject(\n                                new SolanaError(\n                                    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n                                ),\n                            );\n                        };\n                    });\n                    bufferDrainWatcher = {\n                        onCancel,\n                        promise,\n                    };\n                }\n                if (bufferDrainWatcher) {\n                    if (ArrayBuffer.isView(message) && !(message instanceof DataView)) {\n                        const TypedArrayConstructor = message.constructor as {\n                            new (...args: [typeof message]): typeof message;\n                        };\n                        // Clone the message to prevent mutation while queued.\n                        message = new TypedArrayConstructor(message);\n                    }\n                    await bufferDrainWatcher.promise;\n                }\n                webSocket.send(message);\n            },\n        });\n    }\n    const webSocket = new WebSocket(url);\n    signal.addEventListener('abort', handleAbort);\n    webSocket.addEventListener('close', handleClose);\n    webSocket.addEventListener('error', handleError);\n    webSocket.addEventListener('message', handleMessage);\n    webSocket.addEventListener('open', handleOpen);\n    let rejectOpen!: (e: SolanaError) => void;\n    let resolveOpen!: (value: RpcSubscriptionsChannel<WebSocketMessage, string>) => void;\n    return new Promise<RpcSubscriptionsChannel<WebSocketMessage, string>>((resolve, reject) => {\n        rejectOpen = reject;\n        resolveOpen = resolve;\n    });\n}\n"],"names":["EventTarget","index_browser_default"],"mappings":"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"}},
    {"offset": {"line": 9914, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/rpc-subscriptions/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-subscriptions/src/rpc-integer-overflow-error.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-subscriptions/src/rpc-default-config.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/event-target-impl/src/index.browser.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-subscriptions/src/rpc-subscriptions-autopinger.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-subscriptions/src/rpc-subscriptions-channel-pool-internal.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-subscriptions/src/rpc-subscriptions-channel-pool.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-subscriptions/src/rpc-subscriptions-json.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-subscriptions/src/rpc-subscriptions-json-bigint.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-subscriptions/src/rpc-subscriptions-channel.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-subscriptions/src/rpc-subscriptions-coalescer.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-subscriptions/src/rpc-subscriptions-transport.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/rpc-subscriptions/src/rpc-subscriptions.ts"],"sourcesContent":["import { safeCaptureStackTrace, SOLANA_ERROR__RPC__INTEGER_OVERFLOW, SolanaError } from '@solana/errors';\nimport type { KeyPath } from '@solana/rpc-transformers';\n\nexport function createSolanaJsonRpcIntegerOverflowError(\n    methodName: string,\n    keyPath: KeyPath,\n    value: bigint,\n): SolanaError<typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW> {\n    let argumentLabel = '';\n    if (typeof keyPath[0] === 'number') {\n        const argPosition = keyPath[0] + 1;\n        const lastDigit = argPosition % 10;\n        const lastTwoDigits = argPosition % 100;\n        if (lastDigit == 1 && lastTwoDigits != 11) {\n            argumentLabel = argPosition + 'st';\n        } else if (lastDigit == 2 && lastTwoDigits != 12) {\n            argumentLabel = argPosition + 'nd';\n        } else if (lastDigit == 3 && lastTwoDigits != 13) {\n            argumentLabel = argPosition + 'rd';\n        } else {\n            argumentLabel = argPosition + 'th';\n        }\n    } else {\n        argumentLabel = `\\`${keyPath[0].toString()}\\``;\n    }\n    const path =\n        keyPath.length > 1\n            ? keyPath\n                  .slice(1)\n                  .map(pathPart => (typeof pathPart === 'number' ? `[${pathPart}]` : pathPart))\n                  .join('.')\n            : undefined;\n    const error = new SolanaError(SOLANA_ERROR__RPC__INTEGER_OVERFLOW, {\n        argumentLabel,\n        keyPath: keyPath as readonly (number | string | symbol)[],\n        methodName,\n        optionalPathLabel: path ? ` at path \\`${path}\\`` : '',\n        value,\n        ...(path !== undefined ? { path } : undefined),\n    });\n    safeCaptureStackTrace(error, createSolanaJsonRpcIntegerOverflowError);\n    return error;\n}\n","import type { createSolanaRpcSubscriptionsApi } from '@solana/rpc-subscriptions-api';\n\nimport { createSolanaJsonRpcIntegerOverflowError } from './rpc-integer-overflow-error';\n\nexport const DEFAULT_RPC_SUBSCRIPTIONS_CONFIG: Partial<\n    NonNullable<Parameters<typeof createSolanaRpcSubscriptionsApi>[0]>\n> = {\n    defaultCommitment: 'confirmed',\n    onIntegerOverflow(request, keyPath, value) {\n        throw createSolanaJsonRpcIntegerOverflowError(request.methodName, keyPath, value);\n    },\n};\n","export const AbortController = globalThis.AbortController;\nexport const EventTarget = globalThis.EventTarget;\n","import { isSolanaError, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED } from '@solana/errors';\nimport { AbortController } from '@solana/event-target-impl';\nimport type { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\n\ntype Config<TChannel extends RpcSubscriptionsChannel<unknown, unknown>> = Readonly<{\n    abortSignal: AbortSignal;\n    channel: TChannel;\n    intervalMs: number;\n}>;\n\nconst PING_PAYLOAD = {\n    jsonrpc: '2.0',\n    method: 'ping',\n} as const;\n\n/**\n * Given a {@link RpcSubscriptionsChannel}, will return a new channel that sends a ping message to\n * the inner channel if a message has not been sent or received in the last `intervalMs`. In web\n * browsers, this implementation sends no ping when the network is down, and sends a ping\n * immediately upon the network coming back up.\n */\nexport function getRpcSubscriptionsChannelWithAutoping<TChannel extends RpcSubscriptionsChannel<object, unknown>>({\n    abortSignal: callerAbortSignal,\n    channel,\n    intervalMs,\n}: Config<TChannel>): TChannel {\n    let intervalId: ReturnType<typeof setInterval> | undefined;\n    function sendPing() {\n        channel.send(PING_PAYLOAD).catch((e: unknown) => {\n            if (isSolanaError(e, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED)) {\n                pingerAbortController.abort();\n            }\n        });\n    }\n    function restartPingTimer() {\n        clearInterval(intervalId);\n        intervalId = setInterval(sendPing, intervalMs);\n    }\n    const pingerAbortController = new AbortController();\n    pingerAbortController.signal.addEventListener('abort', () => {\n        clearInterval(intervalId);\n    });\n    callerAbortSignal.addEventListener('abort', () => {\n        pingerAbortController.abort();\n    });\n    channel.on(\n        'error',\n        () => {\n            pingerAbortController.abort();\n        },\n        { signal: pingerAbortController.signal },\n    );\n    channel.on('message', restartPingTimer, { signal: pingerAbortController.signal });\n    if (!__BROWSER__ || globalThis.navigator.onLine) {\n        restartPingTimer();\n    }\n    if (__BROWSER__) {\n        globalThis.addEventListener(\n            'offline',\n            function handleOffline() {\n                clearInterval(intervalId);\n            },\n            { signal: pingerAbortController.signal },\n        );\n        globalThis.addEventListener(\n            'online',\n            function handleOnline() {\n                sendPing();\n                restartPingTimer();\n            },\n            { signal: pingerAbortController.signal },\n        );\n    }\n    return {\n        ...channel,\n        send(...args) {\n            if (!pingerAbortController.signal.aborted) {\n                restartPingTimer();\n            }\n            return channel.send(...args);\n        },\n    };\n}\n","import { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\n\nexport type ChannelPoolEntry = {\n    channel: PromiseLike<RpcSubscriptionsChannel<unknown, unknown>> | RpcSubscriptionsChannel<unknown, unknown>;\n    readonly dispose: () => void;\n    subscriptionCount: number;\n};\n\ntype ChannelPool = { readonly entries: ChannelPoolEntry[]; freeChannelIndex: number };\n\nexport function createChannelPool(): ChannelPool {\n    return {\n        entries: [],\n        freeChannelIndex: -1,\n    };\n}\n","import { AbortController } from '@solana/event-target-impl';\nimport { RpcSubscriptionsChannelCreator } from '@solana/rpc-subscriptions-spec';\n\nimport { ChannelPoolEntry, createChannelPool } from './rpc-subscriptions-channel-pool-internal';\n\ntype Config = Readonly<{\n    maxSubscriptionsPerChannel: number;\n    minChannels: number;\n}>;\n\n/**\n * Given a channel creator, will return a new channel creator with the following behavior.\n *\n * 1. When called, returns a {@link RpcSubscriptionsChannel}. Adds that channel to a pool.\n * 2. When called again, creates and returns new\n *    {@link RpcSubscriptionChannel | RpcSubscriptionChannels} up to the number specified by\n *    `minChannels`.\n * 3. When `minChannels` channels have been created, subsequent calls vend whichever existing\n *    channel from the pool has the fewest subscribers, or the next one in rotation in the event of\n *    a tie.\n * 4. Once all channels carry the number of subscribers specified by the number\n *    `maxSubscriptionsPerChannel`, new channels in excess of `minChannel` will be created,\n *    returned, and added to the pool.\n * 5. A channel will be destroyed once all of its subscribers' abort signals fire.\n */\nexport function getChannelPoolingChannelCreator<\n    TChannelCreator extends RpcSubscriptionsChannelCreator<unknown, unknown>,\n>(createChannel: TChannelCreator, { maxSubscriptionsPerChannel, minChannels }: Config): TChannelCreator {\n    const pool = createChannelPool();\n    /**\n     * This function advances the free channel index to the pool entry with the most capacity. It\n     * sets the index to `-1` if all channels are full.\n     */\n    function recomputeFreeChannelIndex() {\n        if (pool.entries.length < minChannels) {\n            // Don't set the free channel index until the pool fills up; we want to keep creating\n            // channels before we start rotating among them.\n            pool.freeChannelIndex = -1;\n            return;\n        }\n        let mostFreeChannel: Readonly<{ poolIndex: number; subscriptionCount: number }> | undefined;\n        for (let ii = 0; ii < pool.entries.length; ii++) {\n            const nextPoolIndex = (pool.freeChannelIndex + ii + 2) % pool.entries.length;\n            const nextPoolEntry =\n                // Start from the item two positions after the current item. This way, the\n                // search will finish on the item after the current one. This ensures that, if\n                // any channels tie for having the most capacity, the one that will be chosen is\n                // the one immediately to the current one's right (wrapping around).\n                pool.entries[nextPoolIndex];\n            if (\n                nextPoolEntry.subscriptionCount < maxSubscriptionsPerChannel &&\n                (!mostFreeChannel || mostFreeChannel.subscriptionCount >= nextPoolEntry.subscriptionCount)\n            ) {\n                mostFreeChannel = {\n                    poolIndex: nextPoolIndex,\n                    subscriptionCount: nextPoolEntry.subscriptionCount,\n                };\n            }\n        }\n        pool.freeChannelIndex = mostFreeChannel?.poolIndex ?? -1;\n    }\n    return function getExistingChannelWithMostCapacityOrCreateChannel({ abortSignal }) {\n        let poolEntry: ChannelPoolEntry;\n        function destroyPoolEntry() {\n            const index = pool.entries.findIndex(entry => entry === poolEntry);\n            pool.entries.splice(index, 1);\n            poolEntry.dispose();\n            recomputeFreeChannelIndex();\n        }\n        if (pool.freeChannelIndex === -1) {\n            const abortController = new AbortController();\n            const newChannelPromise = createChannel({ abortSignal: abortController.signal });\n            newChannelPromise\n                .then(newChannel => {\n                    newChannel.on('error', destroyPoolEntry, { signal: abortController.signal });\n                })\n                .catch(destroyPoolEntry);\n            poolEntry = {\n                channel: newChannelPromise,\n                dispose() {\n                    abortController.abort();\n                },\n                subscriptionCount: 0,\n            };\n            pool.entries.push(poolEntry);\n        } else {\n            poolEntry = pool.entries[pool.freeChannelIndex];\n        }\n        /**\n         * A note about subscription counts.\n         * Because of https://github.com/solana-labs/solana/pull/18943, two subscriptions for\n         * materially the same notification will be coalesced on the server. This means they will be\n         * assigned the same subscription id, and will occupy one subscription slot. We can't tell,\n         * from here, whether a subscription will be treated in this way or not, so we\n         * unconditionally increment the subscription count every time a subscription request is\n         * made. This may result in subscription channels being treated as out-of-capacity when in\n         * fact they are not.\n         */\n        poolEntry.subscriptionCount++;\n        abortSignal.addEventListener('abort', function destroyConsumer() {\n            poolEntry.subscriptionCount--;\n            if (poolEntry.subscriptionCount === 0) {\n                destroyPoolEntry();\n            } else if (pool.freeChannelIndex !== -1) {\n                // Back the free channel index up one position, and recompute it.\n                pool.freeChannelIndex--;\n                recomputeFreeChannelIndex();\n            }\n        });\n        recomputeFreeChannelIndex();\n        return poolEntry.channel;\n    } as TChannelCreator;\n}\n","import { pipe } from '@solana/functional';\nimport {\n    RpcSubscriptionsChannel,\n    transformChannelInboundMessages,\n    transformChannelOutboundMessages,\n} from '@solana/rpc-subscriptions-spec';\n\n/**\n * Given a {@link RpcSubscriptionsChannel}, will return a new channel that parses data published to\n * the `'message'` channel as JSON, and JSON-stringifies messages sent via the\n * {@link RpcSubscriptionsChannel.send | send(message)} method.\n */\nexport function getRpcSubscriptionsChannelWithJSONSerialization(\n    channel: RpcSubscriptionsChannel<string, string>,\n): RpcSubscriptionsChannel<unknown, unknown> {\n    return pipe(\n        channel,\n        c => transformChannelInboundMessages(c, JSON.parse),\n        c => transformChannelOutboundMessages(c, JSON.stringify),\n    );\n}\n","import { pipe } from '@solana/functional';\nimport { parseJsonWithBigInts, stringifyJsonWithBigInts } from '@solana/rpc-spec-types';\nimport {\n    RpcSubscriptionsChannel,\n    transformChannelInboundMessages,\n    transformChannelOutboundMessages,\n} from '@solana/rpc-subscriptions-spec';\n\n/**\n * Similarly, to {@link getRpcSubscriptionsChannelWithJSONSerialization}, this function will\n * stringify and parse JSON message to and from the given `string` channel. However, this function\n * parses any integer value as a `BigInt` in order to safely handle numbers that exceed the\n * JavaScript [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\n * value.\n */\nexport function getRpcSubscriptionsChannelWithBigIntJSONSerialization(\n    channel: RpcSubscriptionsChannel<string, string>,\n): RpcSubscriptionsChannel<unknown, unknown> {\n    return pipe(\n        channel,\n        c => transformChannelInboundMessages(c, parseJsonWithBigInts),\n        c => transformChannelOutboundMessages(c, stringifyJsonWithBigInts),\n    );\n}\n","import { createWebSocketChannel } from '@solana/rpc-subscriptions-channel-websocket';\nimport type { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\nimport type { ClusterUrl } from '@solana/rpc-types';\n\nimport { getRpcSubscriptionsChannelWithAutoping } from './rpc-subscriptions-autopinger';\nimport { getChannelPoolingChannelCreator } from './rpc-subscriptions-channel-pool';\nimport { RpcSubscriptionsChannelCreatorFromClusterUrl } from './rpc-subscriptions-clusters';\nimport { getRpcSubscriptionsChannelWithJSONSerialization } from './rpc-subscriptions-json';\nimport { getRpcSubscriptionsChannelWithBigIntJSONSerialization } from './rpc-subscriptions-json-bigint';\n\nexport type DefaultRpcSubscriptionsChannelConfig<TClusterUrl extends ClusterUrl> = Readonly<{\n    /**\n     * The number of milliseconds to wait since the last message sent or received over the channel\n     * before sending a ping message to keep the channel open.\n     */\n    intervalMs?: number;\n    /**\n     * The number of subscribers that may share a channel before a new channel must be created.\n     *\n     * It is important that you set this to the maximum number of subscriptions that your RPC\n     * provider recommends making over a single connection; the default is set deliberately low, so\n     * as to comply with the restrictive limits of the public mainnet RPC node.\n     *\n     * @defaultValue 100\n     */\n    maxSubscriptionsPerChannel?: number;\n    /** The number of channels to create before reusing a channel for a new subscription. */\n    minChannels?: number;\n    /**\n     * The number of bytes of data to admit into the\n     * [`WebSocket`](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket) buffer before\n     * buffering data on the client.\n     */\n    sendBufferHighWatermark?: number;\n    /** The URL of the web socket server. Must use the `ws` or `wss` protocols. */\n    url: TClusterUrl;\n}>;\n\n/**\n * Similar to {@link createDefaultRpcSubscriptionsChannelCreator} with some Solana-specific\n * defaults.\n *\n * For instance, it safely handles `BigInt` values in JSON messages since Solana RPC servers accept\n * and return integers larger than [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER).\n */\nexport function createDefaultSolanaRpcSubscriptionsChannelCreator<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsChannelConfig<TClusterUrl>,\n): RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown> {\n    return createDefaultRpcSubscriptionsChannelCreatorImpl({\n        ...config,\n        jsonSerializer: getRpcSubscriptionsChannelWithBigIntJSONSerialization,\n    });\n}\n\n/**\n * Creates a function that returns new subscription channels when called.\n */\nexport function createDefaultRpcSubscriptionsChannelCreator<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsChannelConfig<TClusterUrl>,\n): RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown> {\n    return createDefaultRpcSubscriptionsChannelCreatorImpl({\n        ...config,\n        jsonSerializer: getRpcSubscriptionsChannelWithJSONSerialization,\n    });\n}\n\nfunction createDefaultRpcSubscriptionsChannelCreatorImpl<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsChannelConfig<TClusterUrl> & {\n        jsonSerializer: (channel: RpcSubscriptionsChannel<string, string>) => RpcSubscriptionsChannel<unknown, unknown>;\n    },\n): RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown> {\n    if (/^wss?:/i.test(config.url) === false) {\n        const protocolMatch = config.url.match(/^([^:]+):/);\n        throw new DOMException(\n            protocolMatch\n                ? \"Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or \" +\n                  `'wss'. '${protocolMatch[1]}:' is not allowed.`\n                : `Failed to construct 'WebSocket': The URL '${config.url}' is invalid.`,\n        );\n    }\n    const { intervalMs, ...rest } = config;\n    const createDefaultRpcSubscriptionsChannel = (({ abortSignal }) => {\n        return createWebSocketChannel({\n            ...rest,\n            sendBufferHighWatermark:\n                config.sendBufferHighWatermark ??\n                // Let 128KB of data into the WebSocket buffer before buffering it in the app.\n                131_072,\n            signal: abortSignal,\n        })\n            .then(config.jsonSerializer)\n            .then(channel =>\n                getRpcSubscriptionsChannelWithAutoping({\n                    abortSignal,\n                    channel,\n                    intervalMs: intervalMs ?? 5_000,\n                }),\n            );\n    }) as RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown>;\n    return getChannelPoolingChannelCreator(createDefaultRpcSubscriptionsChannel, {\n        maxSubscriptionsPerChannel:\n            config.maxSubscriptionsPerChannel ??\n            /**\n             * A note about this default. The idea here is that, because some RPC providers impose\n             * an upper limit on the number of subscriptions you can make per channel, we must\n             * choose a number low enough to avoid hitting that limit. Without knowing what provider\n             * a given person is using, or what their limit is, we have to choose the lowest of all\n             * known limits. As of this writing (October 2024) that is the public mainnet RPC node\n             * (api.mainnet-beta.solana.com) at 100 subscriptions.\n             */\n            100,\n        minChannels: config.minChannels ?? 1,\n    });\n}\n","import { AbortController } from '@solana/event-target-impl';\nimport fastStableStringify from '@solana/fast-stable-stringify';\nimport { RpcSubscriptionsTransport } from '@solana/rpc-subscriptions-spec';\nimport { DataPublisher } from '@solana/subscribable';\n\ntype CacheEntry = {\n    readonly abortController: AbortController;\n    readonly dataPublisherPromise: Promise<DataPublisher>;\n    numSubscribers: number;\n};\n\n/**\n * Given a {@link RpcSubscriptionsTransport}, will return a new transport that coalesces identical\n * subscriptions into a single subscription request to the server. The determination of whether a\n * subscription is the same as another is based on the `rpcRequest` returned by its\n * {@link RpcSubscriptionsPlan}. The subscription will only be aborted once all subscribers abort,\n * or there is an error.\n */\nexport function getRpcSubscriptionsTransportWithSubscriptionCoalescing<TTransport extends RpcSubscriptionsTransport>(\n    transport: TTransport,\n): TTransport {\n    const cache = new Map<string, CacheEntry>();\n    return function rpcSubscriptionsTransportWithSubscriptionCoalescing(config) {\n        const { request, signal } = config;\n        const subscriptionConfigurationHash = fastStableStringify([request.methodName, request.params]);\n\n        let cachedDataPublisherPromise = cache.get(subscriptionConfigurationHash);\n        if (!cachedDataPublisherPromise) {\n            const abortController = new AbortController();\n            const dataPublisherPromise = transport({\n                ...config,\n                signal: abortController.signal,\n            });\n            dataPublisherPromise\n                .then(dataPublisher => {\n                    dataPublisher.on(\n                        'error',\n                        () => {\n                            cache.delete(subscriptionConfigurationHash);\n                            abortController.abort();\n                        },\n                        { signal: abortController.signal },\n                    );\n                })\n                .catch(() => {});\n            cache.set(\n                subscriptionConfigurationHash,\n                (cachedDataPublisherPromise = {\n                    abortController,\n                    dataPublisherPromise,\n                    numSubscribers: 0,\n                }),\n            );\n        }\n        cachedDataPublisherPromise.numSubscribers++;\n        signal.addEventListener(\n            'abort',\n            () => {\n                cachedDataPublisherPromise.numSubscribers--;\n                if (cachedDataPublisherPromise.numSubscribers === 0) {\n                    queueMicrotask(() => {\n                        if (cachedDataPublisherPromise.numSubscribers === 0) {\n                            cache.delete(subscriptionConfigurationHash);\n                            cachedDataPublisherPromise.abortController.abort();\n                        }\n                    });\n                }\n            },\n            { signal: cachedDataPublisherPromise.abortController.signal },\n        );\n        return cachedDataPublisherPromise.dataPublisherPromise;\n    } as TTransport;\n}\n","import { pipe } from '@solana/functional';\nimport { RpcSubscriptionsChannelCreator, RpcSubscriptionsTransport } from '@solana/rpc-subscriptions-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n\nimport {\n    RpcSubscriptionsChannelCreatorDevnet,\n    RpcSubscriptionsChannelCreatorFromClusterUrl,\n    RpcSubscriptionsChannelCreatorMainnet,\n    RpcSubscriptionsChannelCreatorTestnet,\n    RpcSubscriptionsTransportDevnet,\n    RpcSubscriptionsTransportFromClusterUrl,\n    RpcSubscriptionsTransportMainnet,\n    RpcSubscriptionsTransportTestnet,\n} from './rpc-subscriptions-clusters';\nimport { getRpcSubscriptionsTransportWithSubscriptionCoalescing } from './rpc-subscriptions-coalescer';\n\nexport type DefaultRpcSubscriptionsTransportConfig<TClusterUrl extends ClusterUrl> = Readonly<{\n    createChannel: RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown>;\n}>;\n\n/**\n * Creates a {@link RpcSubscriptionsTransport} with some default behaviours.\n *\n * The default behaviours include:\n * - Logic that coalesces multiple subscriptions for the same notifications with the same arguments\n *   into a single subscription.\n *\n * @param config\n */\nexport function createDefaultRpcSubscriptionsTransport<TClusterUrl extends ClusterUrl>({\n    createChannel,\n}: DefaultRpcSubscriptionsTransportConfig<TClusterUrl>) {\n    return pipe(\n        createRpcSubscriptionsTransportFromChannelCreator(\n            createChannel,\n        ) as RpcSubscriptionsTransport as RpcSubscriptionsTransportFromClusterUrl<TClusterUrl>,\n        transport => getRpcSubscriptionsTransportWithSubscriptionCoalescing(transport),\n    );\n}\n\nexport function createRpcSubscriptionsTransportFromChannelCreator<\n    TChannelCreator extends RpcSubscriptionsChannelCreator<TOutboundMessage, TInboundMessage>,\n    TInboundMessage,\n    TOutboundMessage,\n>(createChannel: TChannelCreator) {\n    return (async ({ execute, signal }) => {\n        const channel = await createChannel({ abortSignal: signal });\n        return await execute({ channel, signal });\n    }) as TChannelCreator extends RpcSubscriptionsChannelCreatorDevnet<TOutboundMessage, TInboundMessage>\n        ? RpcSubscriptionsTransportDevnet\n        : TChannelCreator extends RpcSubscriptionsChannelCreatorTestnet<TOutboundMessage, TInboundMessage>\n          ? RpcSubscriptionsTransportTestnet\n          : TChannelCreator extends RpcSubscriptionsChannelCreatorMainnet<TOutboundMessage, TInboundMessage>\n            ? RpcSubscriptionsTransportMainnet\n            : RpcSubscriptionsTransport;\n}\n","import type { SolanaRpcSubscriptionsApi, SolanaRpcSubscriptionsApiUnstable } from '@solana/rpc-subscriptions-api';\nimport { createSolanaRpcSubscriptionsApi } from '@solana/rpc-subscriptions-api';\nimport {\n    createSubscriptionRpc,\n    RpcSubscriptionsApiMethods,\n    type RpcSubscriptionsTransport,\n} from '@solana/rpc-subscriptions-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n\nimport { DEFAULT_RPC_SUBSCRIPTIONS_CONFIG } from './rpc-default-config';\nimport {\n    createDefaultSolanaRpcSubscriptionsChannelCreator,\n    DefaultRpcSubscriptionsChannelConfig,\n} from './rpc-subscriptions-channel';\nimport type { RpcSubscriptionsFromTransport } from './rpc-subscriptions-clusters';\nimport { createDefaultRpcSubscriptionsTransport } from './rpc-subscriptions-transport';\n\ntype Config<TClusterUrl extends ClusterUrl> = DefaultRpcSubscriptionsChannelConfig<TClusterUrl>;\n\nfunction createSolanaRpcSubscriptionsImpl<TClusterUrl extends ClusterUrl, TApi extends RpcSubscriptionsApiMethods>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<Config<TClusterUrl>, 'url'>,\n) {\n    const transport = createDefaultRpcSubscriptionsTransport({\n        createChannel: createDefaultSolanaRpcSubscriptionsChannelCreator({ ...config, url: clusterUrl }),\n    });\n    return createSolanaRpcSubscriptionsFromTransport<typeof transport, TApi>(transport);\n}\n\n/**\n * Creates a {@link RpcSubscriptions} instance that exposes the Solana JSON RPC WebSocket API given\n * a cluster URL and some optional channel config. See\n * {@link createDefaultRpcSubscriptionsChannelCreator} for the shape of the channel config.\n */\nexport function createSolanaRpcSubscriptions<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<Config<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcSubscriptionsImpl<TClusterUrl, SolanaRpcSubscriptionsApi>(clusterUrl, config);\n}\n\n/**\n * Creates a {@link RpcSubscriptions} instance that exposes the Solana JSON RPC WebSocket API,\n * including its unstable methods, given a cluster URL and some optional channel config. See\n * {@link createDefaultRpcSubscriptionsChannelCreator} for the shape of the channel config.\n */\nexport function createSolanaRpcSubscriptions_UNSTABLE<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<Config<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcSubscriptionsImpl<TClusterUrl, SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>(\n        clusterUrl,\n        config,\n    );\n}\n\n/**\n * Creates a {@link RpcSubscriptions} instance that exposes the Solana JSON RPC WebSocket API given\n * the supplied {@link RpcSubscriptionsTransport}.\n */\nexport function createSolanaRpcSubscriptionsFromTransport<\n    TTransport extends RpcSubscriptionsTransport,\n    TApi extends RpcSubscriptionsApiMethods = SolanaRpcSubscriptionsApi,\n>(transport: TTransport) {\n    return createSubscriptionRpc({\n        api: createSolanaRpcSubscriptionsApi<TApi>(DEFAULT_RPC_SUBSCRIPTIONS_CONFIG),\n        transport,\n    }) as RpcSubscriptionsFromTransport<TApi, TTransport>;\n}\n"],"names":["AbortController","pipe","transformChannelInboundMessages","transformChannelOutboundMessages"],"mappings":"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"}},
    {"offset": {"line": 10271, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/options/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/options/src/option.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/options/src/unwrap-option.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/options/src/option-codec.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/options/src/unwrap-option-recursively.ts"],"sourcesContent":["/**\n * An implementation of the Rust `Option<T>` type in JavaScript.\n *\n * In Rust, optional values are represented using `Option<T>`, which can be either:\n * - `Some(T)`, indicating a present value.\n * - `None`, indicating the absence of a value.\n *\n * In JavaScript, this is typically represented as `T | null`. However, this approach fails with nested options.\n * For example, `Option<Option<T>>` in Rust would translate to `T | null | null` in JavaScript, which is equivalent to `T | null`.\n * This means there is no way to differentiate between `Some(None)` and `None`, making nested options impossible.\n *\n * This `Option` type helps solve this by mirroring Rust’s `Option<T>` type.\n *\n * ```ts\n * type Option<T> = Some<T> | None;\n * type Some<T> = { __option: 'Some'; value: T };\n * type None = { __option: 'None' };\n * ```\n *\n * @typeParam T - The type of the contained value.\n *\n * @example\n * Here's how you can create `Option` values.\n *\n * To improve developer experience, helper functions are available.\n * TypeScript can infer the type of `T` or it can be explicitly provided.\n *\n * ```ts\n * // Create an option with a value.\n * some('Hello World');\n * some<number | string>(123);\n *\n * // Create an empty option.\n * none();\n * none<number | string>();\n * ```\n *\n * @see {@link Some}\n * @see {@link None}\n * @see {@link some}\n * @see {@link none}\n */\nexport type Option<T> = None | Some<T>;\n\n/**\n * A flexible type that allows working with {@link Option} values or nullable values.\n *\n * It defines a looser type that can be used when encoding {@link Option | Options}.\n * This allows us to pass `null` or the nested value directly whilst still\n * supporting the Option type for use-cases that need more type safety.\n *\n * @typeParam T - The type of the contained value.\n *\n * @example\n * Accepting both `Option<T>` and `T | null` as input.\n * ```ts\n * function double(value: OptionOrNullable<number>) {\n *   const option = isOption(value) ? value : wrapNullable(value);\n *   return isSome(option) ? option.value * 2 : 'No value';\n * }\n *\n * double(42);       // 84\n * double(some(21)); // 42\n * double(none());   // \"No value\"\n * double(null);     // \"No value\"\n * ```\n *\n * @see {@link Option}\n * @see {@link isOption}\n * @see {@link wrapNullable}\n */\nexport type OptionOrNullable<T> = Option<T> | T | null;\n\n/**\n * Represents an {@link Option} that contains a value.\n *\n * This type mirrors Rust’s `Some(T)`, indicating that a value is present.\n *\n * For more details, see {@link Option}.\n *\n * @typeParam T - The type of the contained value.\n *\n * @example\n * Creating a `Some` value.\n * ```ts\n * const value = some(42);\n * isSome(value); // true\n * isNone(value); // false\n * ```\n *\n * @see {@link Option}\n * @see {@link some}\n * @see {@link isSome}\n */\nexport type Some<T> = Readonly<{ __option: 'Some'; value: T }>;\n\n/**\n * Represents an {@link Option} that contains no value.\n *\n * This type mirrors Rust’s `None`, indicating the absence of a value.\n *\n * For more details, see {@link Option}.\n *\n * @example\n * Creating a `None` value.\n * ```ts\n * const empty = none();\n * isNone(empty); // true\n * isSome(empty); // false\n * ```\n *\n * @see {@link Option}\n * @see {@link none}\n * @see {@link isNone}\n */\nexport type None = Readonly<{ __option: 'None' }>;\n\n/**\n * Creates a new {@link Option} that contains a value.\n *\n * This function explicitly wraps a value in an {@link Option} type.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param value - The value to wrap in an {@link Option}.\n * @returns An {@link Option} containing the provided value.\n *\n * @example\n * Wrapping a value in an `Option`.\n * ```ts\n * const option = some('Hello');\n * option.value;     // \"Hello\"\n * isOption(option); // true\n * isSome(option);   // true\n * isNone(option);   // false\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n */\nexport const some = <T>(value: T): Option<T> => ({ __option: 'Some', value });\n\n/**\n * Creates a new {@link Option} that contains no value.\n *\n * This function explicitly represents an absent value.\n *\n * @typeParam T - The type of the expected absent value.\n *\n * @returns An {@link Option} containing no value.\n *\n * @example\n * Creating an empty `Option`.\n * ```ts\n * const empty = none<number>();\n * isOption(empty); // true\n * isSome(empty);   // false\n * isNone(empty);   // true\n * ```\n *\n * @see {@link Option}\n * @see {@link None}\n */\nexport const none = <T>(): Option<T> => ({ __option: 'None' });\n\n/**\n * Checks whether the given value is an {@link Option}.\n *\n * This function determines whether an input follows the `Option<T>` structure.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param input - The value to check.\n * @returns `true` if the value is an {@link Option}, `false` otherwise.\n *\n * @example\n * Checking for `Option` values.\n * ```ts\n * isOption(some(42));        // true\n * isOption(none());          // true\n * isOption(42);              // false\n * isOption(null);            // false\n * isOption(\"anything else\"); // false\n * ```\n *\n * @see {@link Option}\n */\nexport const isOption = <T = unknown>(input: unknown): input is Option<T> =>\n    !!(\n        input &&\n        typeof input === 'object' &&\n        '__option' in input &&\n        ((input.__option === 'Some' && 'value' in input) || input.__option === 'None')\n    );\n\n/**\n * Checks whether the given {@link Option} contains a value.\n *\n * This function acts as a type guard, ensuring the value is a {@link Some}.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param option - The {@link Option} to check.\n * @returns `true` if the option is a {@link Some}, `false` otherwise.\n *\n * @example\n * Checking for `Some` values.\n * ```ts\n * isSome(some(42)); // true\n * isSome(none());   // false\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n */\nexport const isSome = <T>(option: Option<T>): option is Some<T> => option.__option === 'Some';\n\n/**\n * Checks whether the given {@link Option} contains no value.\n *\n * This function acts as a type guard, ensuring the value is a {@link None}.\n *\n * @typeParam T - The type of the expected value.\n *\n * @param option - The {@link Option} to check.\n * @returns `true` if the option is a {@link None}, `false` otherwise.\n *\n * @example\n * Checking for `None` values.\n * ```ts\n * isNone(some(42)); // false\n * isNone(none());   // true\n * ```\n *\n * @see {@link Option}\n * @see {@link None}\n */\nexport const isNone = <T>(option: Option<T>): option is None => option.__option === 'None';\n","import { isSome, none, Option, some } from './option';\n\n/**\n * Unwraps the value of an {@link Option}, returning its contained value or a fallback.\n *\n * This function extracts the value `T` from an `Option<T>` type.\n * - If the option is {@link Some}, it returns the contained value `T`.\n * - If the option is {@link None}, it returns the fallback value `U`, which defaults to `null`.\n *\n * @typeParam T - The type of the contained value.\n * @typeParam U - The type of the fallback value (defaults to `null`).\n *\n * @param option - The {@link Option} to unwrap.\n * @param fallback - A function that provides a fallback value if the option is {@link None}.\n * @returns The contained value if {@link Some}, otherwise the fallback value.\n *\n * @example\n * Unwrapping an `Option` with no fallback.\n * ```ts\n * unwrapOption(some('Hello World')); // \"Hello World\"\n * unwrapOption(none());              // null\n * ```\n *\n * @example\n * Providing a custom fallback value.\n * ```ts\n * unwrapOption(some('Hello World'), () => 'Default'); // \"Hello World\"\n * unwrapOption(none(), () => 'Default');              // \"Default\"\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n * @see {@link None}\n */\nexport function unwrapOption<T>(option: Option<T>): T | null;\nexport function unwrapOption<T, U>(option: Option<T>, fallback: () => U): T | U;\nexport function unwrapOption<T, U = null>(option: Option<T>, fallback?: () => U): T | U {\n    if (isSome(option)) return option.value;\n    return fallback ? fallback() : (null as U);\n}\n\n/**\n * Wraps a nullable value into an {@link Option}.\n *\n * - If the input value is `null`, this function returns {@link None}.\n * - Otherwise, it wraps the value in {@link Some}.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param nullable - The nullable value to wrap.\n * @returns An {@link Option} wrapping the value.\n *\n * @example\n * Wrapping nullable values.\n * ```ts\n * wrapNullable('Hello World'); // Option<string> (Some)\n * wrapNullable<string>(null);  // Option<string> (None)\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n * @see {@link None}\n */\nexport const wrapNullable = <T>(nullable: T | null): Option<T> => (nullable !== null ? some(nullable) : none<T>());\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getBooleanDecoder,\n    getBooleanEncoder,\n    getConstantDecoder,\n    getConstantEncoder,\n    getTupleDecoder,\n    getTupleEncoder,\n    getUnionDecoder,\n    getUnionEncoder,\n    getUnitDecoder,\n    getUnitEncoder,\n} from '@solana/codecs-data-structures';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { isOption, isSome, None, none, Option, OptionOrNullable, Some, some } from './option';\nimport { wrapNullable } from './unwrap-option';\n\n/**\n * Defines the configuration options for {@link Option} codecs.\n *\n * The `getOptionCodec` function behaves similarly to {@link getNullableCodec}\n * but encodes `Option<T>` types instead of `T | null` types.\n *\n * This configuration controls how {@link None} values are encoded and how presence\n * is determined when decoding.\n *\n * @typeParam TPrefix - A number codec, encoder, or decoder used as the presence prefix.\n *\n * @see {@link getOptionEncoder}\n * @see {@link getOptionDecoder}\n * @see {@link getOptionCodec}\n */\nexport type OptionCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Specifies how {@link None} values are represented in the encoded data.\n     *\n     * - By default, {@link None} values are omitted from encoding.\n     * - `'zeroes'`: The bytes allocated for the value are filled with zeroes. This requires a fixed-size codec for the item.\n     * - Custom byte array: {@link None} values are replaced with a predefined byte sequence. This results in a variable-size codec.\n     *\n     * @defaultValue No explicit `noneValue` is used; {@link None} values are omitted.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The presence prefix used to distinguish between {@link None} and present values.\n     *\n     * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`).\n     * - Custom number codec: Allows defining a different number size for the prefix.\n     * - `null`: No prefix is used; `noneValue` (if provided) determines {@link None}.\n     *   If no `noneValue` is set, {@link None} is identified by the absence of bytes.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Returns an encoder for optional values using the {@link Option} type.\n *\n * This encoder serializes an {@link OptionOrNullable} value using a configurable approach:\n * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, {@link None} values are encoded as zeroes.\n * - If `noneValue` is a byte array, {@link None} values are replaced with the provided constant.\n *\n * Unlike {@link getNullableEncoder}, this encoder accepts both {@link Option} and {@link Nullable} values.\n *\n * For more details, see {@link getOptionCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param item - The encoder for the value that may be present.\n * @param config - Configuration options for encoding optional values.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding option values.\n *\n * @example\n * Encoding an optional string.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const encoder = getOptionEncoder(stringCodec);\n *\n * encoder.encode(some('Hi'));\n * encoder.encode('Hi');\n * // 0x01020000004869\n * //   | |       └-- utf8 string content (\"Hi\").\n * //   | └-- u32 string prefix (2 characters).\n * //   └-- 1-byte prefix (Some).\n *\n * encoder.encode(none());\n * encoder.encode(null);\n * // 0x00\n * //   └-- 1-byte prefix (None).\n * ```\n *\n * @see {@link getOptionCodec}\n */\nexport function getOptionEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: OptionCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<OptionOrNullable<TFrom>, TSize>;\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: OptionCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: OptionCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: OptionCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: OptionCodecConfig<NumberEncoder> = {},\n): Encoder<OptionOrNullable<TFrom>> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: None | null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: Some<TFrom> | TFrom): [boolean, TFrom] => [\n                true,\n                isOption(value) && isSome(value) ? value.value : value,\n            ]),\n        ],\n        variant => {\n            const option = isOption<TFrom>(variant) ? variant : wrapNullable(variant);\n            return Number(isSome(option));\n        },\n    );\n}\n\n/**\n * Returns a decoder for optional values using the {@link Option} type.\n *\n * This decoder deserializes an `Option<T>` value using a configurable approach:\n * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, `None` values are identified by zeroes.\n * - If `noneValue` is a byte array, `None` values match the provided constant.\n *\n * Unlike {@link getNullableDecoder}, this decoder always outputs an {@link Option} type.\n *\n * For more details, see {@link getOptionCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The decoder for the value that may be present.\n * @param config - Configuration options for decoding optional values.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding option values.\n *\n * @example\n * Decoding an optional string with a size prefix.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const decoder = getOptionDecoder(stringCodec);\n *\n * decoder.decode(new Uint8Array([0x01, 0x02, 0x00, 0x00, 0x00, 0x48, 0x69]));\n * // some('Hi')\n *\n * decoder.decode(new Uint8Array([0x00]));\n * // none()\n * ```\n *\n * @see {@link getOptionCodec}\n */\nexport function getOptionDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: OptionCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<Option<TTo>, TSize>;\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: OptionCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: OptionCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: OptionCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: OptionCodecConfig<NumberDecoder> = {},\n): Decoder<Option<TTo>> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => none<TTo>()),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => some(value)),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding optional values using the {@link Option} type.\n *\n * This codec serializes and deserializes `Option<T>` values using a configurable approach:\n * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`).\n * - If `noneValue: 'zeroes'` is set, `None` values are encoded/decoded as zeroes.\n * - If `noneValue` is a byte array, `None` values are represented by the provided constant.\n * - If `prefix: null` is set, the codec determines `None` values solely from `noneValue` or the presence of bytes.\n *\n * For more details on the configuration options, see {@link OptionCodecConfig}.\n *\n * Note that this behaves similarly to {@link getNullableCodec}, except it\n * encodes {@link OptionOrNullable} values and decodes {@link Option} values.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The codec for the value that may be present.\n * @param config - Configuration options for encoding and decoding option values.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding option values.\n *\n * @example\n * Encoding and decoding an optional string with a size prefix.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const codec = getOptionCodec(stringCodec);\n *\n * const someBytes = codec.encode(some('Hi'));\n * // 0x01020000004869\n * //   | |       └-- utf8 string content (\"Hi\").\n * //   | └-- u32 string prefix (2 characters).\n * //   └-- 1-byte prefix (Some).\n *\n * const noneBytes = codec.encode(none());\n * // 0x00\n * //   └-- 1-byte prefix (None).\n *\n * codec.decode(someBytes); // some('Hi')\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Encoding nullable values.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const codec = getOptionCodec(stringCodec);\n *\n * const someBytes = codec.encode('Hi'); // 0x01020000004869\n * const noneBytes = codec.encode(null); // 0x00\n *\n * codec.decode(someBytes); // some('Hi')\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Encoding and decoding an optional number with a fixed size.\n * ```ts\n * const codec = getOptionCodec(getU16Codec(), { noneValue: 'zeroes' });\n *\n * const someBytes = codec.encode(some(42)); // 0x012a00\n * const noneBytes = codec.encode(none());   // 0x000000\n *\n * codec.decode(someBytes); // some(42)\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Encoding and decoding {@link None} values with a custom byte sequence and no prefix.\n * ```ts\n * const codec = getOptionCodec(getU16Codec(), {\n *   noneValue: new Uint8Array([0xff, 0xff]),\n *   prefix: null,\n * });\n *\n * const someBytes = codec.encode(some(42)); // 0x2a00\n * const noneBytes = codec.encode(none());   // 0xffff\n *\n * codec.decode(someBytes); // some(42)\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Identifying {@link None} values by the absence of bytes.\n * ```ts\n * const codec = getOptionCodec(getU16Codec(), { prefix: null });\n *\n * const someBytes = codec.encode(some(42)); // 0x2a00\n * const noneBytes = codec.encode(none());   // new Uint8Array(0)\n *\n * codec.decode(someBytes); // some(42)\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @remarks\n * Separate {@link getOptionEncoder} and {@link getOptionDecoder} functions are available.\n *\n * ```ts\n * const bytes = getOptionEncoder(getU32Encoder()).encode(some(42));\n * const value = getOptionDecoder(getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getOptionEncoder}\n * @see {@link getOptionDecoder}\n */\nexport function getOptionCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: OptionCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>, TSize>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: OptionCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: OptionCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: OptionCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: OptionCodecConfig<NumberCodec> = {},\n): Codec<OptionOrNullable<TFrom>, Option<TTo>> {\n    type ConfigCast = OptionCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getOptionEncoder<TFrom>(item, config as ConfigCast),\n        getOptionDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n","import { isOption, isSome, None, Some } from './option';\n\n/**\n * Defines types that should not be recursively unwrapped.\n *\n * These types are preserved as-is when using {@link unwrapOptionRecursively}.\n *\n * @see {@link unwrapOptionRecursively}\n */\ntype UnUnwrappables =\n    | Date\n    | Int8Array\n    | Int16Array\n    | Int32Array\n    | Uint8Array\n    | Uint16Array\n    | Uint32Array\n    | bigint\n    | boolean\n    | number\n    | string\n    | symbol\n    | null\n    | undefined;\n\n/**\n * A type that recursively unwraps nested {@link Option} types.\n *\n * This type resolves all nested {@link Option} values, ensuring\n * that deeply wrapped values are properly extracted.\n *\n * - If `T` is an {@link Option}, it resolves to the contained value.\n * - If `T` is a known primitive or immutable type, it remains unchanged.\n * - If `T` is an object or array, it recursively unwraps any options found.\n *\n * The fallback type `U` (default: `null`) is used in place of `None` values.\n *\n * @typeParam T - The type to be unwrapped.\n * @typeParam U - The fallback type for `None` values (defaults to `null`).\n *\n * @example\n * Resolving nested `Option` types.\n * ```ts\n * UnwrappedOption<Some<Some<string>>>; // string\n * UnwrappedOption<None>;               // null\n * ```\n *\n * @example\n * Resolving options inside objects and arrays.\n * ```ts\n * UnwrappedOption<{ a: Some<number>; b: None }>; // { a: number; b: null }\n * UnwrappedOption<[Some<number>, None]>;         // [number, null]\n * ```\n *\n * @see {@link unwrapOptionRecursively}\n */\nexport type UnwrappedOption<T, U = null> =\n    T extends Some<infer TValue>\n        ? UnwrappedOption<TValue, U>\n        : T extends None\n          ? U\n          : T extends UnUnwrappables\n            ? T\n            : T extends object\n              ? { [key in keyof T]: UnwrappedOption<T[key], U> }\n              : T extends Array<infer TItem>\n                ? Array<UnwrappedOption<TItem, U>>\n                : T;\n\n/**\n * Recursively unwraps all nested {@link Option} types within a value.\n *\n * This function traverses a given value and removes all instances\n * of {@link Option}, replacing them with their contained values.\n *\n * - If an {@link Option} is encountered, its value is extracted.\n * - If an array or object is encountered, its elements are traversed recursively.\n * - If `None` is encountered, it is replaced with the fallback value (default: `null`).\n *\n * @typeParam T - The type of the input value.\n * @typeParam U - The fallback type for `None` values (defaults to `null`).\n *\n * @param input - The value to unwrap.\n * @param fallback - A function that provides a fallback value for `None` options.\n * @returns The recursively unwrapped value.\n *\n * @example\n * Recursively unwrapping nested options.\n * ```ts\n * unwrapOptionRecursively(some(some('Hello World'))); // \"Hello World\"\n * unwrapOptionRecursively(some(none<string>()));      // null\n * ```\n *\n * @example\n * Recursively unwrapping options inside objects and arrays.\n * ```ts\n * unwrapOptionRecursively({\n *   a: 'hello',\n *   b: none(),\n *   c: [{ c1: some(42) }, { c2: none() }],\n * });\n * // { a: \"hello\", b: null, c: [{ c1: 42 }, { c2: null }] }\n * ```\n *\n * @example\n * Using a fallback value for `None` options.\n * ```ts\n * unwrapOptionRecursively(\n *   {\n *     a: 'hello',\n *     b: none(),\n *     c: [{ c1: some(42) }, { c2: none() }],\n *   },\n *   () => 'Default',\n * );\n * // { a: \"hello\", b: \"Default\", c: [{ c1: 42 }, { c2: \"Default\" }] }\n * ```\n *\n * @remarks\n * This function does not mutate objects or arrays.\n *\n * @see {@link Option}\n * @see {@link UnwrappedOption}\n */\nexport function unwrapOptionRecursively<T>(input: T): UnwrappedOption<T>;\nexport function unwrapOptionRecursively<T, U>(input: T, fallback: () => U): UnwrappedOption<T, U>;\nexport function unwrapOptionRecursively<T, U = null>(input: T, fallback?: () => U): UnwrappedOption<T, U> {\n    // Types to bypass.\n    if (!input || ArrayBuffer.isView(input)) {\n        return input as UnwrappedOption<T, U>;\n    }\n\n    const next = <X>(x: X) =>\n        (fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x)) as UnwrappedOption<X, U>;\n\n    // Handle Option.\n    if (isOption(input)) {\n        if (isSome(input)) return next(input.value) as UnwrappedOption<T, U>;\n        return (fallback ? fallback() : null) as UnwrappedOption<T, U>;\n    }\n\n    // Walk.\n    if (Array.isArray(input)) {\n        return input.map(next) as UnwrappedOption<T, U>;\n    }\n    if (typeof input === 'object') {\n        return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)])) as UnwrappedOption<T, U>;\n    }\n    return input as UnwrappedOption<T, U>;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 10428, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/accounts/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/accounts/src/account.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/accounts/src/decode-account.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/accounts/src/parse-account.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/accounts/src/fetch-account.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/accounts/src/maybe-account.ts"],"sourcesContent":["import type { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport type { Lamports } from '@solana/rpc-types';\n\n/**\n * The number of bytes required to store the {@link BaseAccount} information without its data.\n *\n * @example\n * ```ts\n * const myTotalAccountSize = myAccountDataSize + BASE_ACCOUNT_SIZE;\n * ```\n */\nexport const BASE_ACCOUNT_SIZE = 128;\n\n/**\n * Defines the attributes common to all Solana accounts. Namely, it contains everything stored\n * on-chain except the account data itself.\n *\n * @interface\n *\n * @example\n * ```ts\n * const BaseAccount: BaseAccount = {\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * };\n * ```\n */\nexport type BaseAccount = {\n    readonly executable: boolean;\n    readonly lamports: Lamports;\n    readonly programAddress: Address;\n    readonly space: bigint;\n};\n\n/**\n * Contains all the information relevant to a Solana account. It includes the account's address and\n * data, as well as the properties of {@link BaseAccount}.\n *\n * @interface\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * // Encoded\n * const myEncodedAccount: Account<Uint8Array, '1234..5678'> = {\n *     address: address('1234..5678'),\n *     data: new Uint8Array([1, 2, 3]),\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * };\n *\n * // Decoded\n * type MyAccountData = { name: string; age: number };\n * const myDecodedAccount: Account<MyAccountData, '1234..5678'> = {\n *     address: address('1234..5678'),\n *     data: { name: 'Alice', age: 30 },\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * };\n * ```\n */\nexport type Account<TData extends Uint8Array | object, TAddress extends string = string> = BaseAccount & {\n    readonly address: Address<TAddress>;\n    readonly data: TData;\n};\n\n/**\n * Represents an encoded account and is equivalent to an {@link Account} with `Uint8Array` account\n * data.\n *\n * @interface\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * {\n *     address: address('1234..5678'),\n *     data: new Uint8Array([1, 2, 3]),\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * } satisfies EncodedAccount<'1234..5678'>;\n * ```\n */\nexport type EncodedAccount<TAddress extends string = string> = Account<ReadonlyUint8Array, TAddress>;\n","import type { Decoder, ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SolanaError,\n} from '@solana/errors';\n\nimport type { Account, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\n\n/**\n * Transforms an {@link EncodedAccount} into an {@link Account} (or a {@link MaybeEncodedAccount}\n * into a {@link MaybeAccount}) by decoding the account data using the provided {@link Decoder}\n * instance.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The type of this account's data.\n *\n * @example\n * ```ts\n * type MyAccountData = { name: string; age: number };\n *\n * const myAccount: EncodedAccount<'1234..5678'>;\n * const myDecoder: Decoder<MyAccountData> = getStructDecoder([\n *     ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *     ['age', getU32Decoder()],\n * ]);\n *\n * const myDecodedAccount = decodeAccount(myAccount, myDecoder);\n * myDecodedAccount satisfies Account<MyAccountData, '1234..5678'>;\n * ```\n */\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): MaybeAccount<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    try {\n        if ('exists' in encodedAccount && !encodedAccount.exists) {\n            return encodedAccount;\n        }\n        return Object.freeze({ ...encodedAccount, data: decoder.decode(encodedAccount.data) });\n    } catch {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT, {\n            address: encodedAccount.address,\n        });\n    }\n}\n\nfunction accountExists<TData extends object>(account: Account<TData> | MaybeAccount<TData>): account is Account<TData> {\n    return !('exists' in account) || ('exists' in account && account.exists);\n}\n\n/**\n * Asserts that an account stores decoded data, ie. not a `Uint8Array`.\n *\n * Note that it does not check the shape of the data matches the decoded type, only that it is not a\n * `Uint8Array`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The type of this account's data.\n *\n * @example\n * ```ts\n * type MyAccountData = { name: string; age: number };\n *\n * const myAccount: Account<MyAccountData | Uint8Array, '1234..5678'>;\n * assertAccountDecoded(myAccount);\n *\n * // now the account data can be used as MyAccountData\n * account.data satisfies MyAccountData;\n * ```\n *\n * This is particularly useful for narrowing the result of fetching a JSON parsed account.\n *\n * ```ts\n * const account: MaybeAccount<MockData | Uint8Array> = await fetchJsonParsedAccount<MockData>(\n *     rpc,\n *     '1234..5678' as Address,\n * );\n *\n * assertAccountDecoded(account);\n * // now we have a MaybeAccount<MockData>\n * account satisfies MaybeAccount<MockData>;\n * ```\n */\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is MaybeAccount<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress> | MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (accountExists(account) && account.data instanceof Uint8Array) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT, {\n            address: account.address,\n        });\n    }\n}\n\n/**\n * Asserts that all input accounts store decoded data, ie. not a `Uint8Array`.\n *\n * As with {@link assertAccountDecoded} it does not check the shape of the data matches the decoded\n * type, only that it is not a `Uint8Array`.\n *\n * @example\n * ```ts\n * type MyAccountData = { name: string; age: number };\n *\n * const myAccounts: Account<MyAccountData | Uint8Array, Address>[];\n * assertAccountsDecoded(myAccounts);\n *\n * // now the account data can be used as MyAccountData\n * for (const a of account) {\n *     account.data satisfies MyAccountData;\n * }\n * ```\n */\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: Account<ReadonlyUint8Array | TData, TAddress>[],\n): asserts accounts is Account<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: MaybeAccount<ReadonlyUint8Array | TData, TAddress>[],\n): asserts accounts is MaybeAccount<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: (Account<ReadonlyUint8Array | TData, TAddress> | MaybeAccount<ReadonlyUint8Array | TData, TAddress>)[],\n): asserts accounts is (Account<TData, TAddress> | MaybeAccount<TData, TAddress>)[] {\n    const encoded = accounts.filter(a => accountExists(a) && a.data instanceof Uint8Array);\n    if (encoded.length > 0) {\n        const encodedAddresses = encoded.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED, {\n            addresses: encodedAddresses,\n        });\n    }\n}\n","import type { Address } from '@solana/addresses';\nimport { getBase58Encoder, getBase64Encoder } from '@solana/codecs-strings';\nimport type {\n    AccountInfoBase,\n    AccountInfoWithBase58Bytes,\n    AccountInfoWithBase58EncodedData,\n    AccountInfoWithBase64EncodedData,\n} from '@solana/rpc-types';\n\nimport type { Account, BaseAccount, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport type { JsonParsedDataResponse } from './rpc-api';\n\ntype Base64EncodedRpcAccount = AccountInfoBase & AccountInfoWithBase64EncodedData;\n\n/**\n * Parses a base64-encoded account provided by the RPC client into an {@link EncodedAccount} type or\n * a {@link MaybeEncodedAccount} type if the raw data can be set to `null`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * const myAddress = address('1234..5678');\n * const myRpcAccount = await rpc.getAccountInfo(myAddress, { encoding: 'base64' }).send();\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = parseBase64RpcAccount(myRpcAccount);\n * ```\n */\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase64Encoder().encode(rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype Base58EncodedRpcAccount = AccountInfoBase & (AccountInfoWithBase58Bytes | AccountInfoWithBase58EncodedData);\n\n/**\n * Parses a base58-encoded account provided by the RPC client into an {@link EncodedAccount} type or\n * a {@link MaybeEncodedAccount} type if the raw data can be set to `null`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * const myAddress = address('1234..5678');\n * const myRpcAccount = await rpc.getAccountInfo(myAddress, { encoding: 'base58' }).send();\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = parseBase58RpcAccount(myRpcAccount);\n * ```\n */\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase58Encoder().encode(typeof rpcAccount.data === 'string' ? rpcAccount.data : rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype JsonParsedRpcAccount = AccountInfoBase & { readonly data: JsonParsedDataResponse<unknown> };\n\n/**\n * Parses an arbitrary `jsonParsed` account provided by the RPC client into an {@link Account} type\n * or a {@link MaybeAccount} type if the raw data can be set to `null`.\n *\n * The expected data type should be explicitly provided as the first type parameter.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The expected type of this account's data.\n *\n * @example\n * ```ts\n * const myAccount: Account<MyData> = parseJsonRpcAccount<MyData>(myJsonRpcAccount);\n * ```\n */\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount,\n): Account<TData, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): MaybeAccount<TData, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = rpcAccount.data.parsed.info as TData;\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\nfunction parseBaseAccount(rpcAccount: AccountInfoBase): BaseAccount {\n    return Object.freeze({\n        executable: rpcAccount.executable,\n        lamports: rpcAccount.lamports,\n        programAddress: rpcAccount.owner,\n        space: rpcAccount.space,\n    });\n}\n","import type { Address } from '@solana/addresses';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Commitment, Slot } from '@solana/rpc-types';\n\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport { parseBase64RpcAccount, parseJsonRpcAccount } from './parse-account';\nimport type { GetAccountInfoApi, GetMultipleAccountsApi } from './rpc-api';\n\n/**\n * Optional configuration for fetching a singular account.\n *\n * @interface\n */\nexport type FetchAccountConfig = {\n    abortSignal?: AbortSignal;\n    /**\n     * Fetch the details of the account as of the highest slot that has reached this level of\n     * commitment.\n     *\n     * @defaultValue Whichever default is applied by the underlying {@link RpcApi} in use. For\n     * example, when using an API created by a `createSolanaRpc*()` helper, the default commitment\n     * is `\"confirmed\"` unless configured otherwise. Unmitigated by an API layer on the client, the\n     * default commitment applied by the server is `\"finalized\"`.\n     */\n    commitment?: Commitment;\n    /**\n     * Prevents accessing stale data by enforcing that the RPC node has processed transactions up to\n     * this slot\n     */\n    minContextSlot?: Slot;\n};\n\n/**\n * Fetches a {@link MaybeEncodedAccount} from the provided RPC client and address.\n *\n * It uses the {@link GetAccountInfoApi.getAccountInfo | getAccountInfo} RPC method under the hood\n * with base64 encoding and an additional configuration object can be provided to customize the\n * behavior of the RPC call.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * const myAddress = address('1234..5678');\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = await fetchEncodedAccount(rpc, myAddress);\n *\n * // With custom configuration.\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = await fetchEncodedAccount(rpc, myAddress, {\n *     abortSignal: myAbortController.signal,\n *     commitment: 'confirmed',\n * });\n * ```\n */\nexport async function fetchEncodedAccount<TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc.getAccountInfo(address, { ...rpcConfig, encoding: 'base64' }).send({ abortSignal });\n    return parseBase64RpcAccount(address, response.value);\n}\n\n/**\n * Fetches a {@link MaybeAccount} from the provided RPC client and address by using\n * {@link GetAccountInfoApi.getAccountInfo | getAccountInfo} under the hood with the `jsonParsed`\n * encoding.\n *\n * It may also return a {@link MaybeEncodedAccount} if the RPC client does not know how to parse the\n * account at the requested address. In any case, the expected data type should be explicitly\n * provided as the first type parameter.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The expected type of this account's data.\n *\n * @example\n * ```ts\n * type TokenData = { mint: Address; owner: Address };\n * const myAccount = await fetchJsonParsedAccount<TokenData>(rpc, myAddress);\n * myAccount satisfies MaybeAccount<TokenData> | MaybeEncodedAccount;\n *\n * // With custom configuration.\n * const myAccount = await fetchJsonParsedAccount<TokenData>(rpc, myAddress, {\n *     abortSignal: myAbortController.signal,\n *     commitment: 'confirmed',\n * });\n * ```\n */\nexport async function fetchJsonParsedAccount<TData extends object, TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeAccount<TData, TAddress> | MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const { value: account } = await rpc\n        .getAccountInfo(address, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return !!account && typeof account === 'object' && 'parsed' in account.data\n        ? parseJsonRpcAccount<TData, TAddress>(address, account as Parameters<typeof parseJsonRpcAccount>[1])\n        : parseBase64RpcAccount<TAddress>(address, account as Parameters<typeof parseBase64RpcAccount>[1]);\n}\n\n/**\n * Optional configuration for fetching multiple accounts.\n *\n * @interface\n */\nexport type FetchAccountsConfig = {\n    abortSignal?: AbortSignal;\n    /**\n     * Fetch the details of the accounts as of the highest slot that has reached this level of\n     * commitment.\n     *\n     * @defaultValue Whichever default is applied by the underlying {@link RpcApi} in use. For\n     * example, when using an API created by a `createSolanaRpc*()` helper, the default commitment\n     * is `\"confirmed\"` unless configured otherwise. Unmitigated by an API layer on the client, the\n     * default commitment applied by the server is `\"finalized\"`.\n     */\n    commitment?: Commitment;\n    /**\n     * Prevents accessing stale data by enforcing that the RPC node has processed transactions up to\n     * this slot\n     */\n    minContextSlot?: Slot;\n};\n\n/**\n * Fetches an array of {@link MaybeEncodedAccount | MaybeEncodedAccounts} from the provided RPC\n * client and an array of addresses.\n *\n * It uses the {@link GetMultipleAccountsApi#getMultipleAccounts | getMultipleAccounts} RPC method\n * under the hood with base64 encodings and an additional configuration object can be provided to\n * customize the behavior of the RPC call.\n *\n * @typeParam TAddresses - Supply an array of string literals to define accounts having particular\n * addresses.\n *\n * @example\n * ```ts\n * const myAddressA = address('1234..5678');\n * const myAddressB = address('8765..4321');\n * const [myAccountA, myAccountB] = await fetchEncodedAccounts(rpc, [myAddressA, myAddressB]);\n * myAccountA satisfies MaybeEncodedAccount<'1234..5678'>;\n * myAccountB satisfies MaybeEncodedAccount<'8765..4321'>;\n *\n * // With custom configuration.\n * const [myAccountA, myAccountB] = await fetchEncodedAccounts(rpc, [myAddressA, myAddressB], {\n *     abortSignal: myAbortController.signal,\n *     commitment: 'confirmed',\n * });\n * ```\n */\nexport async function fetchEncodedAccounts<\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'base64' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => parseBase64RpcAccount(addresses[index], account)) as {\n        [P in keyof TAddresses]: MaybeEncodedAccount<TAddresses[P]>;\n    };\n}\n\n/**\n * Fetches an array of {@link MaybeAccount | MaybeAccounts} from a provided RPC client and an array\n * of addresses.\n *\n * It uses the {@link GetMultipleAccountsApi#getMultipleAccounts | getMultipleAccounts} RPC method\n * under the hood with the `jsonParsed` encoding. It may also return a\n * {@link MaybeEncodedAccount} instead of the expected {@link MaybeAccount} if the RPC client does\n * not know how to parse some of the requested accounts. In any case, the array of expected data\n * types should be explicitly provided as the first type parameter.\n *\n * @typeParam TAddresses - Supply an array of string literals to define accounts having particular\n * addresses.\n * @typeParam TData - The expected types of these accounts' data.\n \n * @example\n * ```ts\n * type TokenData = { mint: Address; owner: Address };\n * type MintData = { supply: bigint };\n * const [myAccountA, myAccountB] = await fetchJsonParsedAccounts<[TokenData, MintData]>(rpc, [myAddressA, myAddressB]);\n * myAccountA satisfies MaybeAccount<TokenData> | MaybeEncodedAccount;\n * myAccountB satisfies MaybeAccount<MintData> | MaybeEncodedAccount;\n * ```\n */\nexport async function fetchJsonParsedAccounts<\n    TData extends object[],\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => {\n        return !!account && typeof account === 'object' && 'parsed' in account.data\n            ? parseJsonRpcAccount(addresses[index], account as Parameters<typeof parseJsonRpcAccount>[1])\n            : parseBase64RpcAccount(addresses[index], account as Parameters<typeof parseBase64RpcAccount>[1]);\n    }) as {\n        [P in keyof TAddresses]:\n            | MaybeAccount<TData[P & keyof TData], TAddresses[P]>\n            | MaybeEncodedAccount<TAddresses[P]>;\n    } & {\n        [P in keyof TData]:\n            | MaybeAccount<TData[P], TAddresses[P & keyof TAddresses]>\n            | MaybeEncodedAccount<TAddresses[P & keyof TAddresses]>;\n    };\n}\n","import { Address } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\n\nimport { Account } from './account';\n\n/**\n * Represents an account that may or may not exist on-chain.\n *\n * When the account exists, it is represented as an {@link Account} type with an additional `exists`\n * attribute set to `true`. When it does not exist, it is represented by an object containing only\n * the address of the account and an `exists` attribute set to `false`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * // Account exists\n * const myExistingAccount: MaybeAccount<MyAccountData, '1234..5678'> = {\n *     exists: true,\n *     address: address('1234..5678'),\n *     data: { name: 'Alice', age: 30 },\n *     // ...\n * };\n *\n * // Account does not exist\n * const myMissingAccount: MaybeAccount<MyAccountData, '8765..4321'> = {\n *     exists: false,\n *     address: address('8765..4321'),\n * };\n * ```\n */\nexport type MaybeAccount<TData extends Uint8Array | object, TAddress extends string = string> =\n    | { readonly address: Address<TAddress>; readonly exists: false }\n    | (Account<TData, TAddress> & { readonly exists: true });\n\n/**\n * Represents an encoded account that may or may not exist on-chain.\n *\n * When the account exists, it is represented as an {@link Account} type having its `TData` type\n * parameter set to `Uint8Array` with an additional `exists` attribute set to `true`. When it does\n * not exist, it is represented by an object containing only the address of the account and an\n * `exists` attribute set to `false`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * // Encoded account exists\n * const myExistingAccount: MaybeEncodedAccount<'1234..5678'> = {\n *     exists: true,\n *     address: address('1234..5678'),\n *     data: new Uint8Array([1, 2, 3]),\n *     // ...\n * };\n *\n * // Encoded account does not exist\n * const myMissingAccount: MaybeEncodedAccount<'8765..4321'> = {\n *     exists: false,\n *     address: address('8765..4321'),\n * };\n * ```\n */\nexport type MaybeEncodedAccount<TAddress extends string = string> = MaybeAccount<Uint8Array, TAddress>;\n\n/**\n * Given a {@link MaybeAccount}, asserts that the account exists and allows it to be used as an\n * {@link Account} type going forward.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * const myAccount: MaybeEncodedAccount<'1234..5678'>;\n * assertAccountExists(myAccount);\n *\n * // Now we can use myAccount as an `EncodedAccount`\n * myAccount satisfies EncodedAccount<'1234..5678'>;\n * ```\n */\nexport function assertAccountExists<TData extends Uint8Array | object, TAddress extends string = string>(\n    account: MaybeAccount<TData, TAddress>,\n): asserts account is Account<TData, TAddress> & { exists: true } {\n    if (!account.exists) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND, { address: account.address });\n    }\n}\n\n/**\n * Given an array of {@link MaybeAccount | MaybeAccounts}, asserts that all the accounts exist and\n * allows them to be used as an array of {@link Account | Accounts} going forward.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * const myAccounts: MaybeEncodedAccount<Address>[];\n * assertAccountsExist(myAccounts);\n *\n * // Now we can use them as an array of `EncodedAccounts`\n * for (const a of myAccounts) {\n *     a satisfies EncodedAccount<Address>;\n * }\n * ```\n */\nexport function assertAccountsExist<TData extends Uint8Array | object, TAddress extends string = string>(\n    accounts: MaybeAccount<TData, TAddress>[],\n): asserts accounts is (Account<TData, TAddress> & { exists: true })[] {\n    const missingAccounts = accounts.filter(a => !a.exists);\n    if (missingAccounts.length > 0) {\n        const missingAddresses = missingAccounts.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND, { addresses: missingAddresses });\n    }\n}\n"],"names":["SolanaError"],"mappings":"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"}},
    {"offset": {"line": 10609, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/programs/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/programs/src/program-error.ts"],"sourcesContent":["import type { Address } from '@solana/addresses';\nimport { isSolanaError, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM, SolanaError } from '@solana/errors';\n\n/**\n * Identifies whether an error -- typically caused by a transaction failure -- is a custom program\n * error from the provided program address.\n *\n * @param transactionMessage The transaction message that failed to execute. Since the RPC response\n * only provides the index of the failed instruction, the transaction message is required to\n * determine its program address\n * @param programAddress The address of the program from which the error is expected to have\n * originated\n * @param code The expected error code of the custom program error. When provided, the function will\n * check that the custom program error code matches the given value.\n *\n * @example\n * ```ts\n * try {\n *     // Send and confirm your transaction.\n * } catch (error) {\n *     if (isProgramError(error, transactionMessage, myProgramAddress, 42)) {\n *         // Handle custom program error 42 from this program.\n *     } else if (isProgramError(error, transactionMessage, myProgramAddress)) {\n *         // Handle all other custom program errors from this program.\n *     } else {\n *         throw error;\n *     }\n * }\n * ```\n */\nexport function isProgramError<TProgramErrorCode extends number>(\n    error: unknown,\n    transactionMessage: { instructions: Record<number, { programAddress: Address }> },\n    programAddress: Address,\n    code?: TProgramErrorCode,\n): error is Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> &\n    SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> {\n    if (!isSolanaError(error, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM)) {\n        return false;\n    }\n    const instructionProgramAddress = transactionMessage.instructions[error.context.index]?.programAddress;\n    if (!instructionProgramAddress || instructionProgramAddress !== programAddress) {\n        return false;\n    }\n    return typeof code === 'undefined' || error.context.code === code;\n}\n"],"names":[],"mappings":";;;;;;;AA8BO,SAAS,cAAA,CACZ,KAAA,EACA,kBAAA,EACA,cAAA,EACA,IAAA,EAE4D;IAC5D,IAAI,KAAC,mLAAA,EAAc,KAAA,EAAO,6MAAuC,CAAA,EAAG;QAChE,OAAO,KAAA;IACX;IACA,MAAM,4BAA4B,kBAAA,CAAmB,YAAA,CAAa,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,EAAG,cAAA;IACxF,IAAI,CAAC,yBAAA,IAA6B,yBAAA,KAA8B,cAAA,EAAgB;QAC5E,OAAO,KAAA;IACX;IACA,OAAO,OAAO,IAAA,KAAS,WAAA,IAAe,KAAA,CAAM,OAAA,CAAQ,IAAA,KAAS,IAAA;AACjE"}},
    {"offset": {"line": 10633, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/instruction-plans/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/instruction-plans/src/instruction-plan.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/instruction-plans/src/transaction-plan-result.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/instruction-plans/src/transaction-plan-executor.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/instruction-plans/src/transaction-plan.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/instruction-plans/src/transaction-planner.ts"],"sourcesContent":["import {\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE,\n    SolanaError,\n} from '@solana/errors';\nimport { Instruction } from '@solana/instructions';\nimport {\n    appendTransactionMessageInstruction,\n    BaseTransactionMessage,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\nimport { getTransactionMessageSize, TRANSACTION_SIZE_LIMIT } from '@solana/transactions';\n\n/**\n * A set of instructions with constraints on how they can be executed.\n *\n * This is structured as a recursive tree of plans in order to allow for\n * parallel execution, sequential execution and combinations of both.\n *\n * Namely the following plans are supported:\n * - {@link SingleInstructionPlan} - A plan that contains a single instruction.\n *   This is a simple instruction wrapper and the simplest leaf in this tree.\n * - {@link ParallelInstructionPlan} - A plan that contains other plans that\n *   can be executed in parallel.\n * - {@link SequentialInstructionPlan} - A plan that contains other plans that\n *   must be executed sequentially. It also defines whether the plan is divisible\n *   meaning that instructions inside it can be split into separate transactions.\n * - {@link MessagePackerInstructionPlan} - A plan that can dynamically pack\n *  instructions into transaction messages.\n *\n * Helpers are provided for each of these plans to make it easier to create them.\n *\n * @example\n * ```ts\n * const myInstructionPlan: InstructionPlan = parallelInstructionPlan([\n *    sequentialInstructionPlan([instructionA, instructionB]),\n *    instructionC,\n *    instructionD,\n * ]);\n * ```\n *\n * @see {@link SingleInstructionPlan}\n * @see {@link ParallelInstructionPlan}\n * @see {@link SequentialInstructionPlan}\n * @see {@link MessagePackerInstructionPlan}\n */\nexport type InstructionPlan =\n    | MessagePackerInstructionPlan\n    | ParallelInstructionPlan\n    | SequentialInstructionPlan\n    | SingleInstructionPlan;\n\n/**\n * A plan wrapping other plans that must be executed sequentially.\n *\n * It also defines whether nested plans are divisible — meaning that\n * the instructions inside them can be split into separate transactions.\n * When `divisible` is `false`, the instructions inside the plan should\n * all be executed atomically — either in a single transaction or in a\n * transaction bundle.\n *\n * You may use the {@link sequentialInstructionPlan} and {@link nonDivisibleSequentialInstructionPlan}\n * helpers to create objects of this type.\n *\n * @example Simple sequential plan with two instructions.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, instructionB]);\n * plan satisfies SequentialInstructionPlan;\n * ```\n *\n * @example Non-divisible sequential plan with two instructions.\n * ```ts\n * const plan = nonDivisibleSequentialInstructionPlan([instructionA, instructionB]);\n * plan satisfies SequentialInstructionPlan & { divisible: false };\n * ```\n *\n * @example Sequential plan with nested parallel plans.\n * Here, instructions A and B can be executed in parallel, but they must both be finalized\n * before instructions C and D can be sent — which can also be executed in parallel.\n * ```ts\n * const plan = sequentialInstructionPlan([\n *   parallelInstructionPlan([instructionA, instructionB]),\n *   parallelInstructionPlan([instructionC, instructionD]),\n * ]);\n * plan satisfies SequentialInstructionPlan & { divisible: false };\n * ```\n *\n * @see {@link sequentialInstructionPlan}\n * @see {@link nonDivisibleSequentialInstructionPlan}\n */\nexport type SequentialInstructionPlan = Readonly<{\n    divisible: boolean;\n    kind: 'sequential';\n    plans: InstructionPlan[];\n}>;\n\n/**\n * A plan wrapping other plans that can be executed in parallel.\n *\n * This means direct children of this plan can be executed in separate\n * parallel transactions without consequence.\n * However, the children themselves can define additional constraints\n * for that specific branch of the tree — such as the {@link SequentialInstructionPlan}.\n *\n * You may use the {@link parallelInstructionPlan} helper to create objects of this type.\n *\n * @example Simple parallel plan with two instructions.\n * ```ts\n * const plan = parallelInstructionPlan([instructionA, instructionB]);\n * plan satisfies ParallelInstructionPlan;\n * ```\n *\n * @example Parallel plan with nested sequential plans.\n * Here, instructions A and B must be executed sequentially and so must instructions C and D,\n * but both pairs can be executed in parallel.\n * ```ts\n * const plan = parallelInstructionPlan([\n *   sequentialInstructionPlan([instructionA, instructionB]),\n *   sequentialInstructionPlan([instructionC, instructionD]),\n * ]);\n * plan satisfies ParallelInstructionPlan;\n * ```\n *\n * @see {@link parallelInstructionPlan}\n */\nexport type ParallelInstructionPlan = Readonly<{\n    kind: 'parallel';\n    plans: InstructionPlan[];\n}>;\n\n/**\n * A plan that contains a single instruction.\n *\n * This is a simple instruction wrapper that transforms an instruction into a plan.\n *\n * You may use the {@link singleInstructionPlan} helper to create objects of this type.\n *\n * @example\n * ```ts\n * const plan = singleInstructionPlan(instructionA);\n * plan satisfies SingleInstructionPlan;\n * ```\n *\n * @see {@link singleInstructionPlan}\n */\nexport type SingleInstructionPlan<TInstruction extends Instruction = Instruction> = Readonly<{\n    instruction: TInstruction;\n    kind: 'single';\n}>;\n\n/**\n * A plan that can dynamically pack instructions into transaction messages.\n *\n * This plan provides a {@link MessagePacker} via the `getMessagePacker`\n * method, which enables instructions to be dynamically packed into the\n * provided transaction message until there are no more instructions to pack.\n * The returned {@link MessagePacker} offers a `packMessageToCapacity(message)`\n * method that packs the provided message — when possible — and a `done()` method\n * that checks whether there are more instructions to pack.\n *\n * Several helper functions are provided to create objects of this type such as\n * {@link getLinearMessagePackerInstructionPlan} or {@link getMessagePackerInstructionPlanFromInstructions}.\n *\n * @example An message packer plan for a write instruction that uses as many bytes as possible.\n * ```ts\n * const plan = getLinearMessagePackerInstructionPlan({\n *   totalLength: dataToWrite.length,\n *   getInstruction: (offset, length) =>\n *     getWriteInstruction({\n *       offset,\n *       data: dataToWrite.slice(offset, offset + length),\n *     }),\n * });\n * plan satisfies MessagePackerInstructionPlan;\n * ```\n *\n * @example A message packer plan for multiple realloc instructions.\n * ```ts\n * const plan = getReallocMessagePackerInstructionPlan({\n *   totalSize: additionalDataSize,\n *   getInstruction: (size) => getExtendInstruction({ length: size }),\n * });\n * plan satisfies MessagePackerInstructionPlan;\n * ```\n *\n * @example Using a message packer plan.\n * ```ts\n * let plan: MessagePackerInstructionPlan;\n * const messagePacker = plan.getMessagePacker();\n *\n * while (!messagePacker.done()) {\n *   try {\n *     transactionMessage = messagePacker.packMessageToCapacity(transactionMessage);\n *   } catch (error) {\n *     // The current transaction message cannot be used to pack this plan.\n *     // We should create a new one and try again.\n *   }\n * }\n * ```\n *\n * @see {@link getLinearMessagePackerInstructionPlan}\n * @see {@link getMessagePackerInstructionPlanFromInstructions}\n * @see {@link getReallocMessagePackerInstructionPlan}\n */\nexport type MessagePackerInstructionPlan = Readonly<{\n    getMessagePacker: () => MessagePacker;\n    kind: 'messagePacker';\n}>;\n\n/**\n * The message packer returned by the {@link MessagePackerInstructionPlan}.\n *\n * It offers a `packMessageToCapacity(transactionMessage)` method that packs as many instructions\n * as possible into the provided transaction message, while still being able to fit into the\n * transaction size limit. It returns the updated transaction message with the packed instructions\n * or throws an error if the current transaction message cannot accommodate this plan.\n *\n * The `done()` method checks whether there are more instructions to pack into\n * transaction messages.\n *\n * @example\n * ```ts\n * let plan: MessagePackerInstructionPlan;\n * const messagePacker = plan.getMessagePacker();\n *\n * while (!messagePacker.done()) {\n *   try {\n *     transactionMessage = messagePacker.packMessageToCapacity(transactionMessage);\n *   } catch (error) {\n *     // The current transaction message cannot be used to pack this plan.\n *     // We should create a new one and try again.\n *   }\n * }\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n */\nexport type MessagePacker = Readonly<{\n    /** Checks whether the message packer has more instructions to pack into transaction messages. */\n    done: () => boolean;\n    /**\n     * Packs the provided transaction message with instructions or throws if not possible.\n     *\n     * @throws {@link SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN}\n     *   if the provided transaction message cannot be used to fill the next instructions.\n     * @throws {@link SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE}\n     *   if the message packer is already done and no more instructions can be packed.\n     */\n    packMessageToCapacity: (\n        transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer,\n    ) => BaseTransactionMessage & TransactionMessageWithFeePayer;\n}>;\n\n/**\n * Creates a {@link ParallelInstructionPlan} from an array of nested plans.\n *\n * It can accept {@link Instruction} objects directly, which will be wrapped\n * in {@link SingleInstructionPlan | SingleInstructionPlans} automatically.\n *\n * @example Using explicit {@link SingleInstructionPlan | SingleInstructionPlans}.\n * ```ts\n * const plan = parallelInstructionPlan([\n *   singleInstructionPlan(instructionA),\n *   singleInstructionPlan(instructionB),\n * ]);\n * ```\n *\n * @example Using {@link Instruction | Instructions} directly.\n * ```ts\n * const plan = parallelInstructionPlan([instructionA, instructionB]);\n * ```\n *\n * @see {@link ParallelInstructionPlan}\n */\nexport function parallelInstructionPlan(plans: (Instruction | InstructionPlan)[]): ParallelInstructionPlan {\n    return Object.freeze({\n        kind: 'parallel',\n        plans: parseSingleInstructionPlans(plans),\n    });\n}\n\n/**\n * Creates a divisible {@link SequentialInstructionPlan} from an array of nested plans.\n *\n * It can accept {@link Instruction} objects directly, which will be wrapped\n * in {@link SingleInstructionPlan | SingleInstructionPlans} automatically.\n *\n * @example Using explicit {@link SingleInstructionPlan | SingleInstructionPlans}.\n * ```ts\n * const plan = sequentialInstructionPlan([\n *   singleInstructionPlan(instructionA),\n *   singleInstructionPlan(instructionB),\n * ]);\n * ```\n *\n * @example Using {@link Instruction | Instructions} directly.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, instructionB]);\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n */\nexport function sequentialInstructionPlan(\n    plans: (Instruction | InstructionPlan)[],\n): SequentialInstructionPlan & { divisible: true } {\n    return Object.freeze({\n        divisible: true,\n        kind: 'sequential',\n        plans: parseSingleInstructionPlans(plans),\n    });\n}\n\n/**\n * Creates a non-divisible {@link SequentialInstructionPlan} from an array of nested plans.\n *\n * It can accept {@link Instruction} objects directly, which will be wrapped\n * in {@link SingleInstructionPlan | SingleInstructionPlans} automatically.\n *\n * @example Using explicit {@link SingleInstructionPlan | SingleInstructionPlans}.\n * ```ts\n * const plan = nonDivisibleSequentialInstructionPlan([\n *   singleInstructionPlan(instructionA),\n *   singleInstructionPlan(instructionB),\n * ]);\n * ```\n *\n * @example Using {@link Instruction | Instructions} directly.\n * ```ts\n * const plan = nonDivisibleSequentialInstructionPlan([instructionA, instructionB]);\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n */\nexport function nonDivisibleSequentialInstructionPlan(\n    plans: (Instruction | InstructionPlan)[],\n): SequentialInstructionPlan & { divisible: false } {\n    return Object.freeze({\n        divisible: false,\n        kind: 'sequential',\n        plans: parseSingleInstructionPlans(plans),\n    });\n}\n\n/**\n * Creates a {@link SingleInstructionPlan} from an {@link Instruction} object.\n *\n * @example\n * ```ts\n * const plan = singleInstructionPlan(instructionA);\n * ```\n *\n * @see {@link SingleInstructionPlan}\n */\nexport function singleInstructionPlan(instruction: Instruction): SingleInstructionPlan {\n    return Object.freeze({ instruction, kind: 'single' });\n}\n\nfunction parseSingleInstructionPlans(plans: (Instruction | InstructionPlan)[]): InstructionPlan[] {\n    return plans.map(plan => ('kind' in plan ? plan : singleInstructionPlan(plan)));\n}\n\n/**\n * Creates a {@link MessagePackerInstructionPlan} that packs instructions\n * such that each instruction consumes as many bytes as possible from the given\n * `totalLength` while still being able to fit into the given transaction messages.\n *\n * This is particularly useful for instructions that write data to accounts and must\n * span multiple transactions due to their size limit.\n *\n * This message packer will first call `getInstruction` with a length of zero to\n * determine the base size of the instruction before figuring out how many\n * additional bytes can be packed into the transaction message. That remaining space\n * will then be used to call `getInstruction` again with the appropriate length.\n *\n * @param getInstruction - A function that returns an instruction for a given offset and length.\n * @param totalLength - The total length of the data to write, in bytes.\n *\n * @example\n * ```ts\n * const plan = getLinearMessagePackerInstructionPlan({\n *   totalLength: dataToWrite.length,\n *   getInstruction: (offset, length) =>\n *     getWriteInstruction({\n *       offset,\n *       data: dataToWrite.slice(offset, offset + length),\n *     }),\n * });\n * plan satisfies MessagePackerInstructionPlan;\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n */\nexport function getLinearMessagePackerInstructionPlan({\n    getInstruction,\n    totalLength: totalBytes,\n}: {\n    getInstruction: (offset: number, length: number) => Instruction;\n    totalLength: number;\n}): MessagePackerInstructionPlan {\n    return Object.freeze({\n        getMessagePacker: () => {\n            let offset = 0;\n            return Object.freeze({\n                done: () => offset >= totalBytes,\n                packMessageToCapacity: (message: BaseTransactionMessage & TransactionMessageWithFeePayer) => {\n                    if (offset >= totalBytes) {\n                        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE);\n                    }\n\n                    const messageSizeWithBaseInstruction = getTransactionMessageSize(\n                        appendTransactionMessageInstruction(getInstruction(offset, 0), message),\n                    );\n                    const freeSpace =\n                        TRANSACTION_SIZE_LIMIT -\n                        messageSizeWithBaseInstruction /* Includes the base instruction (length: 0). */ -\n                        1; /* Leeway for shortU16 numbers in transaction headers. */\n\n                    if (freeSpace <= 0) {\n                        const messageSize = getTransactionMessageSize(message);\n                        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n                            // (+1) We need to pack at least one byte of data otherwise\n                            // there is no point packing the base instruction alone.\n                            numBytesRequired: messageSizeWithBaseInstruction - messageSize + 1,\n                            // (-1) Leeway for shortU16 numbers in transaction headers.\n                            numFreeBytes: TRANSACTION_SIZE_LIMIT - messageSize - 1,\n                        });\n                    }\n\n                    const length = Math.min(totalBytes - offset, freeSpace);\n                    const instruction = getInstruction(offset, length);\n                    offset += length;\n                    return appendTransactionMessageInstruction(instruction, message);\n                },\n            });\n        },\n        kind: 'messagePacker',\n    });\n}\n\n/**\n * Creates a {@link MessagePackerInstructionPlan} from a list of instructions.\n *\n * This can be useful to prepare a set of instructions that can be iterated over\n * — e.g. to pack a list of instructions that gradually reallocate the size of an account\n * one `REALLOC_LIMIT` (10'240 bytes) at a time.\n *\n * @example\n * ```ts\n * const plan = getMessagePackerInstructionPlanFromInstructions([\n *   instructionA,\n *   instructionB,\n *   instructionC,\n * ]);\n *\n * const messagePacker = plan.getMessagePacker();\n * firstTransactionMessage = messagePacker.packMessageToCapacity(firstTransactionMessage);\n * // Contains instruction A and instruction B.\n * secondTransactionMessage = messagePacker.packMessageToCapacity(secondTransactionMessage);\n * // Contains instruction C.\n * messagePacker.done(); // true\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n * @see {@link getReallocMessagePackerInstructionPlan}\n */\nexport function getMessagePackerInstructionPlanFromInstructions<TInstruction extends Instruction = Instruction>(\n    instructions: TInstruction[],\n): MessagePackerInstructionPlan {\n    return Object.freeze({\n        getMessagePacker: () => {\n            let instructionIndex = 0;\n            return Object.freeze({\n                done: () => instructionIndex >= instructions.length,\n                packMessageToCapacity: (message: BaseTransactionMessage & TransactionMessageWithFeePayer) => {\n                    if (instructionIndex >= instructions.length) {\n                        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE);\n                    }\n\n                    const originalMessageSize = getTransactionMessageSize(message);\n\n                    for (let index = instructionIndex; index < instructions.length; index++) {\n                        message = appendTransactionMessageInstruction(instructions[index], message);\n                        const messageSize = getTransactionMessageSize(message);\n\n                        if (messageSize > TRANSACTION_SIZE_LIMIT) {\n                            if (index === instructionIndex) {\n                                throw new SolanaError(\n                                    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n                                    {\n                                        numBytesRequired: messageSize - originalMessageSize,\n                                        numFreeBytes: TRANSACTION_SIZE_LIMIT - originalMessageSize,\n                                    },\n                                );\n                            }\n                            instructionIndex = index;\n                            return message;\n                        }\n                    }\n\n                    instructionIndex = instructions.length;\n                    return message;\n                },\n            });\n        },\n        kind: 'messagePacker',\n    });\n}\n\nconst REALLOC_LIMIT = 10_240;\n\n/**\n * Creates a {@link MessagePackerInstructionPlan} that packs a list of realloc instructions.\n *\n * That is, it splits instruction by chunks of `REALLOC_LIMIT` (10'240) bytes until\n * the given total size is reached.\n *\n * @example\n * ```ts\n * const plan = getReallocMessagePackerInstructionPlan({\n *   totalSize: additionalDataSize,\n *   getInstruction: (size) => getExtendInstruction({ length: size }),\n * });\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n */\nexport function getReallocMessagePackerInstructionPlan({\n    getInstruction,\n    totalSize,\n}: {\n    getInstruction: (size: number) => Instruction;\n    totalSize: number;\n}): MessagePackerInstructionPlan {\n    const numberOfInstructions = Math.ceil(totalSize / REALLOC_LIMIT);\n    const lastInstructionSize = totalSize % REALLOC_LIMIT;\n    const instructions = new Array(numberOfInstructions)\n        .fill(0)\n        .map((_, i) => getInstruction(i === numberOfInstructions - 1 ? lastInstructionSize : REALLOC_LIMIT));\n\n    return getMessagePackerInstructionPlanFromInstructions(instructions);\n}\n","import { Signature } from '@solana/keys';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\nimport { getSignatureFromTransaction, Transaction } from '@solana/transactions';\n\n/**\n * The result of executing a transaction plan.\n *\n * This is structured as a recursive tree of results that mirrors the structure\n * of the original transaction plan, capturing the execution status at each level.\n *\n * Namely, the following result types are supported:\n * - {@link SingleTransactionPlanResult} - A result for a single transaction message\n *   containing its execution status.\n * - {@link ParallelTransactionPlanResult} - A result containing other results that\n *   were executed in parallel.\n * - {@link SequentialTransactionPlanResult} - A result containing other results that\n *   were executed sequentially. It also retains the divisibility property from the\n *   original plan.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n *\n * @see {@link SingleTransactionPlanResult}\n * @see {@link ParallelTransactionPlanResult}\n * @see {@link SequentialTransactionPlanResult}\n * @see {@link TransactionPlanResultStatus}\n */\nexport type TransactionPlanResult<TContext extends TransactionPlanResultContext = TransactionPlanResultContext> =\n    | ParallelTransactionPlanResult<TContext>\n    | SequentialTransactionPlanResult<TContext>\n    | SingleTransactionPlanResult<TContext>;\n\n/** A context object that may be passed along with successful results. */\nexport type TransactionPlanResultContext = Record<number | string | symbol, unknown>;\n\n/**\n * A result for a sequential transaction plan.\n *\n * This represents the execution result of a {@link SequentialTransactionPlan} and\n * contains child results that were executed sequentially. It also retains the\n * divisibility property from the original plan.\n *\n * You may use the {@link sequentialTransactionPlanResult} and\n * {@link nonDivisibleSequentialTransactionPlanResult} helpers to create objects of this type.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n *\n * @example\n * ```ts\n * const result = sequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult;\n * ```\n *\n * @example\n * Non-divisible sequential result.\n * ```ts\n * const result = nonDivisibleSequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult & { divisible: false };\n * ```\n *\n * @see {@link sequentialTransactionPlanResult}\n * @see {@link nonDivisibleSequentialTransactionPlanResult}\n */\nexport type SequentialTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n> = Readonly<{\n    divisible: boolean;\n    kind: 'sequential';\n    plans: TransactionPlanResult<TContext>[];\n}>;\n\n/**\n * A result for a parallel transaction plan.\n *\n * This represents the execution result of a {@link ParallelTransactionPlan} and\n * contains child results that were executed in parallel.\n *\n * You may use the {@link parallelTransactionPlanResult} helper to create objects of this type.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n *\n * @example\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies ParallelTransactionPlanResult;\n * ```\n *\n * @see {@link parallelTransactionPlanResult}\n */\nexport type ParallelTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n> = Readonly<{\n    kind: 'parallel';\n    plans: TransactionPlanResult<TContext>[];\n}>;\n\n/**\n * A result for a single transaction plan.\n *\n * This represents the execution result of a {@link SingleTransactionPlan} and\n * contains the original transaction message along with its execution status.\n *\n * You may use the {@link successfulSingleTransactionPlanResult},\n * {@link failedSingleTransactionPlanResult}, or {@link canceledSingleTransactionPlanResult}\n * helpers to create objects of this type.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @template TTransactionMessage - The type of the transaction message\n *\n * @example\n * Successful result with a transaction and context.\n * ```ts\n * const result = successfulSingleTransactionPlanResult(\n *   transactionMessage,\n *   transaction\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @example\n * Failed result with an error.\n * ```ts\n * const result = failedSingleTransactionPlanResult(\n *   transactionMessage,\n *   new SolanaError(SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE),\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @example\n * Canceled result.\n * ```ts\n * const result = canceledSingleTransactionPlanResult(transactionMessage);\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link successfulSingleTransactionPlanResult}\n * @see {@link failedSingleTransactionPlanResult}\n * @see {@link canceledSingleTransactionPlanResult}\n */\nexport type SingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer = BaseTransactionMessage &\n        TransactionMessageWithFeePayer,\n> = Readonly<{\n    kind: 'single';\n    message: TTransactionMessage;\n    status: TransactionPlanResultStatus<TContext>;\n}>;\n\n/**\n * The status of a single transaction plan execution.\n *\n * This represents the outcome of executing a single transaction message and can be one of:\n * - `successful` - The transaction was successfully executed. Contains the transaction\n *   and an optional context object.\n * - `failed` - The transaction execution failed. Contains the error that caused the failure.\n * - `canceled` - The transaction execution was canceled.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n */\nexport type TransactionPlanResultStatus<TContext extends TransactionPlanResultContext = TransactionPlanResultContext> =\n    | Readonly<{ context: TContext; kind: 'successful'; signature: Signature; transaction?: Transaction }>\n    | Readonly<{ error: Error; kind: 'failed' }>\n    | Readonly<{ kind: 'canceled' }>;\n\n/**\n * Creates a divisible {@link SequentialTransactionPlanResult} from an array of nested results.\n *\n * This function creates a sequential result with the `divisible` property set to `true`,\n * indicating that the nested plans were executed sequentially but could have been\n * split into separate transactions or batches.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @param plans - The child results that were executed sequentially\n *\n * @example\n * ```ts\n * const result = sequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult & { divisible: true };\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n */\nexport function sequentialTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n>(plans: TransactionPlanResult<TContext>[]): SequentialTransactionPlanResult<TContext> & { divisible: true } {\n    return Object.freeze({ divisible: true, kind: 'sequential', plans });\n}\n\n/**\n * Creates a non-divisible {@link SequentialTransactionPlanResult} from an array of nested results.\n *\n * This function creates a sequential result with the `divisible` property set to `false`,\n * indicating that the nested plans were executed sequentially and could not have been\n * split into separate transactions or batches (e.g., they were executed as a transaction bundle).\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @param plans - The child results that were executed sequentially\n *\n * @example\n * ```ts\n * const result = nonDivisibleSequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult & { divisible: false };\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n */\nexport function nonDivisibleSequentialTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n>(plans: TransactionPlanResult<TContext>[]): SequentialTransactionPlanResult<TContext> & { divisible: false } {\n    return Object.freeze({ divisible: false, kind: 'sequential', plans });\n}\n\n/**\n * Creates a {@link ParallelTransactionPlanResult} from an array of nested results.\n *\n * This function creates a parallel result indicating that the nested plans\n * were executed in parallel.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @param plans - The child results that were executed in parallel\n *\n * @example\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies ParallelTransactionPlanResult;\n * ```\n *\n * @see {@link ParallelTransactionPlanResult}\n */\nexport function parallelTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n>(plans: TransactionPlanResult<TContext>[]): ParallelTransactionPlanResult<TContext> {\n    return Object.freeze({ kind: 'parallel', plans });\n}\n\n/**\n * Creates a successful {@link SingleTransactionPlanResult} from a transaction message and transaction.\n *\n * This function creates a single result with a 'successful' status, indicating that\n * the transaction was successfully executed. It also includes the original transaction\n * message, the executed transaction, and an optional context object.\n *\n * @template TContext - The type of the context object\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n * @param transaction - The successfully executed transaction\n * @param context - Optional context object to be included with the result\n *\n * @example\n * ```ts\n * const result = successfulSingleTransactionPlanResult(\n *   transactionMessage,\n *   transaction\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function successfulSingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer = BaseTransactionMessage &\n        TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n    transaction: Transaction,\n    context?: TContext,\n): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({\n            context: context ?? ({} as TContext),\n            kind: 'successful',\n            signature: getSignatureFromTransaction(transaction),\n            transaction,\n        }),\n    });\n}\n\n/**\n * Creates a successful {@link SingleTransactionPlanResult} from a transaction message and signature.\n *\n * This function creates a single result with a 'successful' status, indicating that\n * the transaction was successfully executed. It also includes the original transaction\n * message, the signature of the executed transaction, and an optional context object.\n *\n * @template TContext - The type of the context object\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n * @param signature - The signature of the successfully executed transaction\n * @param context - Optional context object to be included with the result\n *\n * @example\n * ```ts\n * const result = successfulSingleTransactionPlanResult(\n *   transactionMessage,\n *   signature\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function successfulSingleTransactionPlanResultFromSignature<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer = BaseTransactionMessage &\n        TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n    signature: Signature,\n    context?: TContext,\n): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({ context: context ?? ({} as TContext), kind: 'successful', signature }),\n    });\n}\n\n/**\n * Creates a failed {@link SingleTransactionPlanResult} from a transaction message and error.\n *\n * This function creates a single result with a 'failed' status, indicating that\n * the transaction execution failed. It includes the original transaction message\n * and the error that caused the failure.\n *\n * @template TContext - The type of the context object (not used in failed results)\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n * @param error - The error that caused the transaction to fail\n *\n * @example\n * ```ts\n * const result = failedSingleTransactionPlanResult(\n *   transactionMessage,\n *   new SolanaError({\n *     code: 123,\n *     message: 'Transaction simulation failed',\n *   }),\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function failedSingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer = BaseTransactionMessage &\n        TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage, error: Error): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({ error, kind: 'failed' }),\n    });\n}\n\n/**\n * Creates a canceled {@link SingleTransactionPlanResult} from a transaction message.\n *\n * This function creates a single result with a 'canceled' status, indicating that\n * the transaction execution was canceled. It includes the original transaction message.\n *\n * @template TContext - The type of the context object (not used in canceled results)\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n *\n * @example\n * ```ts\n * const result = canceledSingleTransactionPlanResult(transactionMessage);\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function canceledSingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer = BaseTransactionMessage &\n        TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({ kind: 'canceled' }),\n    });\n}\n\n/**\n * Flattens a {@link TransactionPlanResult} into an array of {@link SingleTransactionPlanResult}.\n * @param result The transaction plan result to flatten\n * @returns An array of single transaction plan results\n */\nexport function flattenTransactionPlanResult(result: TransactionPlanResult): SingleTransactionPlanResult[] {\n    const transactionPlanResults: SingleTransactionPlanResult[] = [];\n\n    function traverse(result: TransactionPlanResult) {\n        if (result.kind === 'single') {\n            transactionPlanResults.push(result);\n        } else {\n            for (const subResult of result.plans) {\n                traverse(subResult);\n            }\n        }\n    }\n\n    traverse(result);\n    return transactionPlanResults;\n}\n\n/**\n * A {@link SingleTransactionPlanResult} with 'successful' status.\n */\nexport type SuccessfulSingleTransactionPlanResult = SingleTransactionPlanResult & { status: { kind: 'successful' } };\n\n/**\n * A {@link SingleTransactionPlanResult} with 'failed' status.\n */\nexport type FailedSingleTransactionPlanResult = SingleTransactionPlanResult & { status: { kind: 'failed' } };\n\n/**\n * A {@link SingleTransactionPlanResult} with 'canceled' status.\n */\nexport type CanceledSingleTransactionPlanResult = SingleTransactionPlanResult & { status: { kind: 'canceled' } };\n\n/**\n * A summary of a {@link TransactionPlanResult}, categorizing transactions by their execution status.\n * - `successful`: Indicates whether all transactions were successful (i.e., no failed or canceled transactions).\n * - `successfulTransactions`: An array of successful transactions, each including its signature.\n * - `failedTransactions`: An array of failed transactions, each including the error that caused the failure.\n * - `canceledTransactions`: An array of canceled transactions.\n */\nexport type TransactionPlanResultSummary = Readonly<{\n    canceledTransactions: CanceledSingleTransactionPlanResult[];\n    failedTransactions: FailedSingleTransactionPlanResult[];\n    successful: boolean;\n    successfulTransactions: SuccessfulSingleTransactionPlanResult[];\n}>;\n\n/**\n * Summarize a {@link TransactionPlanResult} into a {@link TransactionPlanResultSummary}.\n * @param result The transaction plan result to summarize\n * @returns A summary of the transaction plan result\n */\nexport function summarizeTransactionPlanResult(result: TransactionPlanResult): TransactionPlanResultSummary {\n    const successfulTransactions: TransactionPlanResultSummary['successfulTransactions'] = [];\n    const failedTransactions: TransactionPlanResultSummary['failedTransactions'] = [];\n    const canceledTransactions: TransactionPlanResultSummary['canceledTransactions'] = [];\n\n    const flattenedResults = flattenTransactionPlanResult(result);\n\n    for (const singleResult of flattenedResults) {\n        switch (singleResult.status.kind) {\n            case 'successful': {\n                successfulTransactions.push(singleResult as SuccessfulSingleTransactionPlanResult);\n                break;\n            }\n            case 'failed': {\n                failedTransactions.push(singleResult as FailedSingleTransactionPlanResult);\n                break;\n            }\n            case 'canceled': {\n                canceledTransactions.push(singleResult as CanceledSingleTransactionPlanResult);\n                break;\n            }\n        }\n    }\n\n    return Object.freeze({\n        canceledTransactions,\n        failedTransactions,\n        successful: failedTransactions.length === 0 && canceledTransactions.length === 0,\n        successfulTransactions,\n    });\n}\n","import {\n    SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,\n    SolanaError,\n} from '@solana/errors';\nimport { Signature } from '@solana/keys';\nimport { getAbortablePromise } from '@solana/promises';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\nimport { Transaction } from '@solana/transactions';\n\nimport type {\n    ParallelTransactionPlan,\n    SequentialTransactionPlan,\n    SingleTransactionPlan,\n    TransactionPlan,\n} from './transaction-plan';\nimport {\n    canceledSingleTransactionPlanResult,\n    failedSingleTransactionPlanResult,\n    nonDivisibleSequentialTransactionPlanResult,\n    parallelTransactionPlanResult,\n    sequentialTransactionPlanResult,\n    successfulSingleTransactionPlanResult,\n    successfulSingleTransactionPlanResultFromSignature,\n    type TransactionPlanResult,\n    type TransactionPlanResultContext,\n} from './transaction-plan-result';\n\nexport type TransactionPlanExecutor<TContext extends TransactionPlanResultContext = TransactionPlanResultContext> = (\n    transactionPlan: TransactionPlan,\n    config?: { abortSignal?: AbortSignal },\n) => Promise<TransactionPlanResult<TContext>>;\n\ntype ExecuteResult<TContext extends TransactionPlanResultContext> = {\n    context?: TContext;\n} & ({ signature: Signature } | { transaction: Transaction });\n\ntype ExecuteTransactionMessage = <TContext extends TransactionPlanResultContext = TransactionPlanResultContext>(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer,\n    config?: { abortSignal?: AbortSignal },\n) => Promise<ExecuteResult<TContext>>;\n\n/**\n * Configuration object for creating a new transaction plan executor.\n *\n * @see {@link createTransactionPlanExecutor}\n */\nexport type TransactionPlanExecutorConfig = {\n    /** Called whenever a transaction message must be sent to the blockchain. */\n    executeTransactionMessage: ExecuteTransactionMessage;\n};\n\n/**\n * Creates a new transaction plan executor based on the provided configuration.\n *\n * The executor will traverse the provided `TransactionPlan` sequentially or in parallel,\n * executing each transaction message using the `executeTransactionMessage` function.\n *\n * - If that function is successful, the executor will return a successful `TransactionPlanResult`\n * for that message including the transaction and any custom context.\n * - If that function throws an error, the executor will stop processing and cancel all\n * remaining transaction messages in the plan.\n * - If the `abortSignal` is triggered, the executor will immediately stop processing the plan and\n * return a `TransactionPlanResult` with the status set to `canceled`.\n *\n * @example\n * ```ts\n * const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });\n *\n * const transactionPlanExecutor = createTransactionPlanExecutor({\n *   executeTransactionMessage: (message) => {\n *     const transaction = await signTransactionMessageWithSigners(message);\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n *     return { transaction };\n *   }\n * });\n * ```\n *\n * @see {@link TransactionPlannerConfig}\n */\nexport function createTransactionPlanExecutor(config: TransactionPlanExecutorConfig): TransactionPlanExecutor {\n    return async (plan, { abortSignal } = {}): Promise<TransactionPlanResult> => {\n        const context: TraverseContext = {\n            ...config,\n            abortSignal: abortSignal,\n            canceled: abortSignal?.aborted ?? false,\n        };\n\n        const cancelHandler = () => {\n            context.canceled = true;\n        };\n        abortSignal?.addEventListener('abort', cancelHandler);\n        const transactionPlanResult = await traverse(plan, context);\n        abortSignal?.removeEventListener('abort', cancelHandler);\n\n        if (context.canceled) {\n            const abortReason = abortSignal?.aborted ? abortSignal.reason : undefined;\n            const context = { cause: findErrorFromTransactionPlanResult(transactionPlanResult) ?? abortReason };\n            // Here we want the `transactionPlanResult` to be available in the error context\n            // so applications can create recovery plans but we don't want this object to be\n            // serialized with the error. This is why we set it as a non-enumerable property.\n            Object.defineProperty(context, 'transactionPlanResult', {\n                configurable: false,\n                enumerable: false,\n                value: transactionPlanResult,\n                writable: false,\n            });\n            throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN, context);\n        }\n\n        return transactionPlanResult;\n    };\n}\n\ntype TraverseContext = TransactionPlanExecutorConfig & {\n    abortSignal?: AbortSignal;\n    canceled: boolean;\n};\n\nasync function traverse(transactionPlan: TransactionPlan, context: TraverseContext): Promise<TransactionPlanResult> {\n    const kind = transactionPlan.kind;\n    switch (kind) {\n        case 'sequential':\n            return await traverseSequential(transactionPlan, context);\n        case 'parallel':\n            return await traverseParallel(transactionPlan, context);\n        case 'single':\n            return await traverseSingle(transactionPlan, context);\n        default:\n            transactionPlan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND, { kind });\n    }\n}\n\nasync function traverseSequential(\n    transactionPlan: SequentialTransactionPlan,\n    context: TraverseContext,\n): Promise<TransactionPlanResult> {\n    const results: TransactionPlanResult[] = [];\n\n    for (const subPlan of transactionPlan.plans) {\n        const result = await traverse(subPlan, context);\n        results.push(result);\n    }\n\n    return transactionPlan.divisible\n        ? sequentialTransactionPlanResult(results)\n        : nonDivisibleSequentialTransactionPlanResult(results);\n}\n\nasync function traverseParallel(\n    transactionPlan: ParallelTransactionPlan,\n    context: TraverseContext,\n): Promise<TransactionPlanResult> {\n    const results = await Promise.all(transactionPlan.plans.map(plan => traverse(plan, context)));\n    return parallelTransactionPlanResult(results);\n}\n\nasync function traverseSingle(\n    transactionPlan: SingleTransactionPlan,\n    context: TraverseContext,\n): Promise<TransactionPlanResult> {\n    if (context.canceled) {\n        return canceledSingleTransactionPlanResult(transactionPlan.message);\n    }\n\n    try {\n        const result = await getAbortablePromise(\n            context.executeTransactionMessage(transactionPlan.message, { abortSignal: context.abortSignal }),\n            context.abortSignal,\n        );\n        if ('transaction' in result) {\n            return successfulSingleTransactionPlanResult(transactionPlan.message, result.transaction, result.context);\n        } else {\n            return successfulSingleTransactionPlanResultFromSignature(\n                transactionPlan.message,\n                result.signature,\n                result.context,\n            );\n        }\n    } catch (error) {\n        context.canceled = true;\n        return failedSingleTransactionPlanResult(transactionPlan.message, error as Error);\n    }\n}\n\nfunction findErrorFromTransactionPlanResult(result: TransactionPlanResult): Error | undefined {\n    if (result.kind === 'single') {\n        return result.status.kind === 'failed' ? result.status.error : undefined;\n    }\n    for (const plan of result.plans) {\n        const error = findErrorFromTransactionPlanResult(plan);\n        if (error) {\n            return error;\n        }\n    }\n}\n","import { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\n/**\n * A set of transaction messages with constraints on how they can be executed.\n *\n * This is structured as a recursive tree of plans to allow for\n * parallel execution, sequential execution and combinations of both.\n *\n * Namely, the following plans are supported:\n * - {@link SingleTransactionPlan} - A plan that contains a single transaction message.\n *   This is the simplest leaf in this tree.\n * - {@link ParallelTransactionPlan} - A plan that contains other plans that\n *   can be executed in parallel.\n * - {@link SequentialTransactionPlan} - A plan that contains other plans that\n *   must be executed sequentially. It also defines whether the plan is divisible\n *   meaning that transaction messages inside it can be split into separate batches.\n *\n * Helpers are provided for each of these plans to make it easier to create them.\n *\n * @example\n * ```ts\n * const myTransactionPlan: TransactionPlan = parallelTransactionPlan([\n *   sequentialTransactionPlan([messageA, messageB]),\n *   messageC,\n * ]);\n * ```\n *\n * @see {@link SingleTransactionPlan}\n * @see {@link ParallelTransactionPlan}\n * @see {@link SequentialTransactionPlan}\n */\nexport type TransactionPlan = ParallelTransactionPlan | SequentialTransactionPlan | SingleTransactionPlan;\n\n/**\n * A plan wrapping other plans that must be executed sequentially.\n *\n * It also defines whether nested plans are divisible — meaning that\n * the transaction messages inside them can be split into separate batches.\n * When `divisible` is `false`, the transaction messages inside the plan should\n * all be executed atomically — usually in a transaction bundle.\n *\n * You may use the {@link sequentialTransactionPlan} and {@link nonDivisibleSequentialTransactionPlan}\n * helpers to create objects of this type.\n *\n * @example\n * Simple sequential plan with two transaction messages.\n * ```ts\n * const plan = sequentialTransactionPlan([messageA, messageB]);\n * plan satisfies SequentialTransactionPlan;\n * ```\n *\n * @example\n * Non-divisible sequential plan with two transaction messages.\n * ```ts\n * const plan = nonDivisibleSequentialTransactionPlan([messageA, messageB]);\n * plan satisfies SequentialTransactionPlan & { divisible: false };\n * ```\n *\n * @example\n * Sequential plan with nested parallel plans.\n * Here, messages A and B can be executed in parallel, but they must both be finalized\n * before messages C and D can be sent — which can also be executed in parallel.\n * ```ts\n * const plan = sequentialTransactionPlan([\n *   parallelTransactionPlan([messageA, messageB]),\n *   parallelTransactionPlan([messageC, messageD]),\n * ]);\n * ```\n *\n * @see {@link sequentialTransactionPlan}\n * @see {@link nonDivisibleSequentialTransactionPlan}\n */\nexport type SequentialTransactionPlan = Readonly<{\n    divisible: boolean;\n    kind: 'sequential';\n    plans: TransactionPlan[];\n}>;\n\n/**\n * A plan wrapping other plans that can be executed in parallel.\n *\n * This means direct children of this plan can be executed in separate\n * parallel transactions without causing any side effects.\n * However, the children themselves can define additional constraints\n * for that specific branch of the tree — such as the {@link SequentialTransactionPlan}.\n *\n * You may use the {@link parallelTransactionPlan} helper to create objects of this type.\n *\n * @example\n * Simple parallel plan with two transaction messages.\n * ```ts\n * const plan = parallelTransactionPlan([messageA, messageB]);\n * plan satisfies ParallelTransactionPlan;\n * ```\n *\n * @example\n * Parallel plan with nested sequential plans.\n * Here, messages A and B must be executed sequentially and so must messages C and D,\n * but both pairs can be executed in parallel.\n * ```ts\n * const plan = parallelTransactionPlan([\n *   sequentialTransactionPlan([messageA, messageB]),\n *   sequentialTransactionPlan([messageC, messageD]),\n * ]);\n * plan satisfies ParallelTransactionPlan;\n * ```\n *\n * @see {@link parallelTransactionPlan}\n */\nexport type ParallelTransactionPlan = Readonly<{\n    kind: 'parallel';\n    plans: TransactionPlan[];\n}>;\n\n/**\n * A plan that contains a single transaction message.\n *\n * This is a simple transaction message wrapper that transforms a message into a plan.\n *\n * You may use the {@link singleTransactionPlan} helper to create objects of this type.\n *\n * @example\n * ```ts\n * const plan = singleTransactionPlan(transactionMessage);\n * plan satisfies SingleTransactionPlan;\n * ```\n *\n * @see {@link singleTransactionPlan}\n */\nexport type SingleTransactionPlan<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer = BaseTransactionMessage &\n        TransactionMessageWithFeePayer,\n> = Readonly<{\n    kind: 'single';\n    message: TTransactionMessage;\n}>;\n\n/**\n * Creates a {@link ParallelTransactionPlan} from an array of nested plans.\n *\n * It can accept {@link TransactionMessage} objects directly, which will be wrapped\n * in {@link SingleTransactionPlan | SingleTransactionPlans} automatically.\n *\n * @example\n * Using explicit {@link SingleTransactionPlan | SingleTransactionPlans}.\n * ```ts\n * const plan = parallelTransactionPlan([\n *   singleTransactionPlan(messageA),\n *   singleTransactionPlan(messageB),\n * ]);\n * ```\n *\n * @example\n * Using {@link TransactionMessage | TransactionMessages} directly.\n * ```ts\n * const plan = parallelTransactionPlan([messageA, messageB]);\n * ```\n *\n * @see {@link ParallelTransactionPlan}\n */\nexport function parallelTransactionPlan(\n    plans: (TransactionPlan | (BaseTransactionMessage & TransactionMessageWithFeePayer))[],\n): ParallelTransactionPlan {\n    return Object.freeze({ kind: 'parallel', plans: parseSingleTransactionPlans(plans) });\n}\n\n/**\n * Creates a divisible {@link SequentialTransactionPlan} from an array of nested plans.\n *\n * It can accept {@link TransactionMessage} objects directly, which will be wrapped\n * in {@link SingleTransactionPlan | SingleTransactionPlans} automatically.\n *\n * @example\n * Using explicit {@link SingleTransactionPlan | SingleTransactionPlans}.\n * ```ts\n * const plan = sequentialTransactionPlan([\n *   singleTransactionPlan(messageA),\n *   singleTransactionPlan(messageB),\n * ]);\n * ```\n *\n * @example\n * Using {@link TransactionMessage | TransactionMessages} directly.\n * ```ts\n * const plan = sequentialTransactionPlan([messageA, messageB]);\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n */\nexport function sequentialTransactionPlan(\n    plans: (TransactionPlan | (BaseTransactionMessage & TransactionMessageWithFeePayer))[],\n): SequentialTransactionPlan & { divisible: true } {\n    return Object.freeze({ divisible: true, kind: 'sequential', plans: parseSingleTransactionPlans(plans) });\n}\n\n/**\n * Creates a non-divisible {@link SequentialTransactionPlan} from an array of nested plans.\n *\n * It can accept {@link TransactionMessage} objects directly, which will be wrapped\n * in {@link SingleTransactionPlan | SingleTransactionPlans} automatically.\n *\n * @example\n * Using explicit {@link SingleTransactionPlan | SingleTransactionPlans}.\n * ```ts\n * const plan = nonDivisibleSequentialTransactionPlan([\n *   singleTransactionPlan(messageA),\n *   singleTransactionPlan(messageB),\n * ]);\n * ```\n *\n * @example\n * Using {@link TransactionMessage | TransactionMessages} directly.\n * ```ts\n * const plan = nonDivisibleSequentialTransactionPlan([messageA, messageB]);\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n */\nexport function nonDivisibleSequentialTransactionPlan(\n    plans: (TransactionPlan | (BaseTransactionMessage & TransactionMessageWithFeePayer))[],\n): SequentialTransactionPlan & { divisible: false } {\n    return Object.freeze({ divisible: false, kind: 'sequential', plans: parseSingleTransactionPlans(plans) });\n}\n\n/**\n * Creates a {@link SingleTransactionPlan} from a {@link TransactionMessage} object.\n *\n * @example\n * ```ts\n * const plan = singleTransactionPlan(transactionMessage);\n * plan satisfies SingleTransactionPlan;\n * ```\n *\n * @see {@link SingleTransactionPlan}\n */\nexport function singleTransactionPlan<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer = BaseTransactionMessage &\n        TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage): SingleTransactionPlan<TTransactionMessage> {\n    return Object.freeze({ kind: 'single', message: transactionMessage });\n}\n\nfunction parseSingleTransactionPlans(\n    plans: (TransactionPlan | (BaseTransactionMessage & TransactionMessageWithFeePayer))[],\n): TransactionPlan[] {\n    return plans.map(plan => ('kind' in plan ? plan : singleTransactionPlan(plan)));\n}\n\n/**\n * Retrieves all individual {@link SingleTransactionPlan} instances from a transaction plan tree.\n *\n * This function recursively traverses any nested structure of transaction plans and extracts\n * all the single transaction plans they contain. It's useful when you need to access all\n * the actual transaction messages that will be executed, regardless of their organization\n * in the plan tree (parallel or sequential).\n *\n * @param transactionPlan - The transaction plan to extract single plans from\n * @returns An array of all single transaction plans contained in the tree\n *\n * @example\n * ```ts\n * const plan = parallelTransactionPlan([\n *   sequentialTransactionPlan([messageA, messageB]),\n *   nonDivisibleSequentialTransactionPlan([messageC, messageD]),\n *   messageE,\n * ]);\n *\n * const singlePlans = getAllSingleTransactionPlans(plan);\n * // Array of `SingleTransactionPlan` containing:\n * // messageA, messageB, messageC and messageD.\n * ```\n */\nexport function getAllSingleTransactionPlans(transactionPlan: TransactionPlan): SingleTransactionPlan[] {\n    if (transactionPlan.kind === 'single') {\n        return [transactionPlan];\n    }\n    return transactionPlan.plans.flatMap(getAllSingleTransactionPlans);\n}\n","import {\n    isSolanaError,\n    SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,\n    SolanaError,\n} from '@solana/errors';\nimport { getAbortablePromise } from '@solana/promises';\nimport {\n    appendTransactionMessageInstructions,\n    BaseTransactionMessage,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\nimport { getTransactionMessageSize, TRANSACTION_SIZE_LIMIT } from '@solana/transactions';\n\nimport {\n    InstructionPlan,\n    MessagePackerInstructionPlan,\n    ParallelInstructionPlan,\n    SequentialInstructionPlan,\n    SingleInstructionPlan,\n} from './instruction-plan';\nimport {\n    getAllSingleTransactionPlans,\n    nonDivisibleSequentialTransactionPlan,\n    parallelTransactionPlan,\n    sequentialTransactionPlan,\n    SingleTransactionPlan,\n    singleTransactionPlan,\n    TransactionPlan,\n} from './transaction-plan';\n\n/**\n * Plans one or more transactions according to the provided instruction plan.\n *\n * @param instructionPlan - The instruction plan to be planned and executed.\n * @param config - Optional configuration object that can include an `AbortSignal` to cancel the planning process.\n *\n * @see {@link InstructionPlan}\n * @see {@link TransactionPlan}\n */\nexport type TransactionPlanner = (\n    instructionPlan: InstructionPlan,\n    config?: { abortSignal?: AbortSignal },\n) => Promise<TransactionPlan>;\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] };\n\ntype CreateTransactionMessage = (config?: {\n    abortSignal?: AbortSignal;\n}) =>\n    | Promise<BaseTransactionMessage & TransactionMessageWithFeePayer>\n    | (BaseTransactionMessage & TransactionMessageWithFeePayer);\n\ntype OnTransactionMessageUpdated = (\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer,\n    config?: { abortSignal?: AbortSignal },\n) =>\n    | Promise<BaseTransactionMessage & TransactionMessageWithFeePayer>\n    | (BaseTransactionMessage & TransactionMessageWithFeePayer);\n\n/**\n * Configuration object for creating a new transaction planner.\n *\n * @see {@link createTransactionPlanner}\n */\nexport type TransactionPlannerConfig = {\n    /** Called whenever a new transaction message is needed. */\n    createTransactionMessage: CreateTransactionMessage;\n    /**\n     * Called whenever a transaction message is updated — e.g. new instructions were added.\n     * This function must return the updated transaction message back — even if no changes were made.\n     */\n    onTransactionMessageUpdated?: OnTransactionMessageUpdated;\n};\n\n/**\n * Creates a new transaction planner based on the provided configuration.\n *\n * At the very least, the `createTransactionMessage` function must be provided.\n * This function is used to create new transaction messages whenever needed.\n *\n * Additionally, the `onTransactionMessageUpdated` function can be provided\n * to update transaction messages during the planning process. This function will\n * be called whenever a transaction message is updated, e.g. when new instructions\n * are added to a transaction message. It accepts the updated transaction message\n * and must return a transaction message back, even if no changes were made.\n *\n * @example\n * ```ts\n * const transactionPlanner = createTransactionPlanner({\n *   createTransactionMessage: () => pipe(\n *     createTransactionMessage({ version: 0 }),\n *     message => setTransactionMessageFeePayerSigner(mySigner, message),\n *   )\n * });\n * ```\n *\n * @see {@link TransactionPlannerConfig}\n */\nexport function createTransactionPlanner(config: TransactionPlannerConfig): TransactionPlanner {\n    return async (instructionPlan, { abortSignal } = {}): Promise<TransactionPlan> => {\n        const plan = await traverse(instructionPlan, {\n            abortSignal,\n            createTransactionMessage: config.createTransactionMessage,\n            onTransactionMessageUpdated: config.onTransactionMessageUpdated ?? (msg => msg),\n            parent: null,\n            parentCandidates: [],\n        });\n\n        if (!plan) {\n            throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN);\n        }\n\n        return freezeTransactionPlan(plan);\n    };\n}\n\ntype MutableTransactionPlan = Mutable<TransactionPlan>;\ntype MutableSingleTransactionPlan = Mutable<SingleTransactionPlan>;\n\ntype TraverseContext = {\n    abortSignal?: AbortSignal;\n    createTransactionMessage: CreateTransactionMessage;\n    onTransactionMessageUpdated: OnTransactionMessageUpdated;\n    parent: InstructionPlan | null;\n    parentCandidates: MutableSingleTransactionPlan[];\n};\n\nasync function traverse(\n    instructionPlan: InstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    context.abortSignal?.throwIfAborted();\n    const kind = instructionPlan.kind;\n    switch (kind) {\n        case 'sequential':\n            return await traverseSequential(instructionPlan, context);\n        case 'parallel':\n            return await traverseParallel(instructionPlan, context);\n        case 'single':\n            return await traverseSingle(instructionPlan, context);\n        case 'messagePacker':\n            return await traverseMessagePacker(instructionPlan, context);\n        default:\n            instructionPlan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, { kind });\n    }\n}\n\nasync function traverseSequential(\n    instructionPlan: SequentialInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    let candidate: MutableSingleTransactionPlan | null = null;\n\n    // Check if the sequential plan must fit entirely in its parent candidates\n    // due to constraints like being inside a parallel plan or not being divisible.\n    const mustEntirelyFitInParentCandidate =\n        context.parent && (context.parent.kind === 'parallel' || !instructionPlan.divisible);\n\n    // If so, try to fit the entire plan inside one of the parent candidates.\n    if (mustEntirelyFitInParentCandidate) {\n        const candidate = await selectAndMutateCandidate(context, context.parentCandidates, message =>\n            fitEntirePlanInsideMessage(instructionPlan, message),\n        );\n        // If that's possible, we the candidate is mutated and we can return null.\n        // Otherwise, we proceed with the normal traversal and no parent candidate.\n        if (candidate) {\n            return null;\n        }\n    } else {\n        // Otherwise, we can use the first parent candidate, if any,\n        // since we know it must be a divisible sequential plan.\n        candidate = context.parentCandidates.length > 0 ? context.parentCandidates[0] : null;\n    }\n\n    const transactionPlans: TransactionPlan[] = [];\n    for (const plan of instructionPlan.plans) {\n        const transactionPlan = await traverse(plan, {\n            ...context,\n            parent: instructionPlan,\n            parentCandidates: candidate ? [candidate] : [],\n        });\n        if (transactionPlan) {\n            candidate = getSequentialCandidate(transactionPlan);\n            const newPlans =\n                transactionPlan.kind === 'sequential' && (transactionPlan.divisible || !instructionPlan.divisible)\n                    ? transactionPlan.plans\n                    : [transactionPlan];\n            transactionPlans.push(...newPlans);\n        }\n    }\n\n    // Wrap in a sequential plan or simplify.\n    if (transactionPlans.length === 1) {\n        return transactionPlans[0];\n    }\n    if (transactionPlans.length === 0) {\n        return null;\n    }\n    return {\n        divisible: instructionPlan.divisible,\n        kind: 'sequential',\n        plans: transactionPlans,\n    };\n}\n\nasync function traverseParallel(\n    instructionPlan: ParallelInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    const candidates: MutableSingleTransactionPlan[] = [...context.parentCandidates];\n    const transactionPlans: TransactionPlan[] = [];\n\n    // Reorder children so message packer plans are last.\n    const sortedChildren = Array.from(instructionPlan.plans).sort(\n        (a, b) => Number(a.kind === 'messagePacker') - Number(b.kind === 'messagePacker'),\n    );\n\n    for (const plan of sortedChildren) {\n        const transactionPlan = await traverse(plan, {\n            ...context,\n            parent: instructionPlan,\n            parentCandidates: candidates,\n        });\n        if (transactionPlan) {\n            candidates.push(...getParallelCandidates(transactionPlan));\n            const newPlans = transactionPlan.kind === 'parallel' ? transactionPlan.plans : [transactionPlan];\n            transactionPlans.push(...newPlans);\n        }\n    }\n\n    // Wrap in a parallel plan or simplify.\n    if (transactionPlans.length === 1) {\n        return transactionPlans[0];\n    }\n    if (transactionPlans.length === 0) {\n        return null;\n    }\n    return { kind: 'parallel', plans: transactionPlans };\n}\n\nasync function traverseSingle(\n    instructionPlan: SingleInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    const predicate = (message: BaseTransactionMessage & TransactionMessageWithFeePayer) =>\n        appendTransactionMessageInstructions([instructionPlan.instruction], message);\n    const candidate = await selectAndMutateCandidate(context, context.parentCandidates, predicate);\n    if (candidate) {\n        return null;\n    }\n    const message = await createNewMessage(context, predicate);\n    return { kind: 'single', message };\n}\n\nasync function traverseMessagePacker(\n    instructionPlan: MessagePackerInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    const messagePacker = instructionPlan.getMessagePacker();\n    const transactionPlans: SingleTransactionPlan[] = [];\n    const candidates = [...context.parentCandidates];\n\n    while (!messagePacker.done()) {\n        const candidate = await selectAndMutateCandidate(context, candidates, messagePacker.packMessageToCapacity);\n        if (!candidate) {\n            const message = await createNewMessage(context, messagePacker.packMessageToCapacity);\n            const newPlan: MutableSingleTransactionPlan = { kind: 'single', message };\n            transactionPlans.push(newPlan);\n        }\n    }\n\n    if (transactionPlans.length === 1) {\n        return transactionPlans[0];\n    }\n    if (transactionPlans.length === 0) {\n        return null;\n    }\n    if (context.parent?.kind === 'parallel') {\n        return { kind: 'parallel', plans: transactionPlans };\n    }\n    return {\n        divisible: context.parent?.kind === 'sequential' ? context.parent.divisible : true,\n        kind: 'sequential',\n        plans: transactionPlans,\n    };\n}\n\nfunction getSequentialCandidate(latestPlan: MutableTransactionPlan): MutableSingleTransactionPlan | null {\n    if (latestPlan.kind === 'single') {\n        return latestPlan;\n    }\n    if (latestPlan.kind === 'sequential' && latestPlan.plans.length > 0) {\n        return getSequentialCandidate(latestPlan.plans[latestPlan.plans.length - 1]);\n    }\n    return null;\n}\n\nfunction getParallelCandidates(latestPlan: TransactionPlan): MutableSingleTransactionPlan[] {\n    return getAllSingleTransactionPlans(latestPlan);\n}\n\nasync function selectAndMutateCandidate(\n    context: Pick<TraverseContext, 'abortSignal' | 'onTransactionMessageUpdated'>,\n    candidates: MutableSingleTransactionPlan[],\n    predicate: (\n        message: BaseTransactionMessage & TransactionMessageWithFeePayer,\n    ) => BaseTransactionMessage & TransactionMessageWithFeePayer,\n): Promise<MutableSingleTransactionPlan | null> {\n    for (const candidate of candidates) {\n        try {\n            const message = await getAbortablePromise(\n                Promise.resolve(\n                    context.onTransactionMessageUpdated(predicate(candidate.message), {\n                        abortSignal: context.abortSignal,\n                    }),\n                ),\n                context.abortSignal,\n            );\n            if (getTransactionMessageSize(message) <= TRANSACTION_SIZE_LIMIT) {\n                candidate.message = message;\n                return candidate;\n            }\n        } catch (error) {\n            if (isSolanaError(error, SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN)) {\n                // Try the next candidate.\n            } else {\n                throw error;\n            }\n        }\n    }\n    return null;\n}\n\nasync function createNewMessage(\n    context: Pick<TraverseContext, 'abortSignal' | 'createTransactionMessage' | 'onTransactionMessageUpdated'>,\n    predicate: (\n        message: BaseTransactionMessage & TransactionMessageWithFeePayer,\n    ) => BaseTransactionMessage & TransactionMessageWithFeePayer,\n): Promise<BaseTransactionMessage & TransactionMessageWithFeePayer> {\n    const newMessage = await getAbortablePromise(\n        Promise.resolve(context.createTransactionMessage({ abortSignal: context.abortSignal })),\n        context.abortSignal,\n    );\n    const updatedMessage = await getAbortablePromise(\n        Promise.resolve(\n            context.onTransactionMessageUpdated(predicate(newMessage), { abortSignal: context.abortSignal }),\n        ),\n        context.abortSignal,\n    );\n    const updatedMessageSize = getTransactionMessageSize(updatedMessage);\n    if (updatedMessageSize > TRANSACTION_SIZE_LIMIT) {\n        const newMessageSize = getTransactionMessageSize(newMessage);\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n            numBytesRequired: updatedMessageSize - newMessageSize,\n            numFreeBytes: TRANSACTION_SIZE_LIMIT - newMessageSize,\n        });\n    }\n    return updatedMessage;\n}\n\nfunction freezeTransactionPlan(plan: MutableTransactionPlan): TransactionPlan {\n    const kind = plan.kind;\n    switch (kind) {\n        case 'single':\n            return singleTransactionPlan(plan.message);\n        case 'sequential':\n            return plan.divisible\n                ? sequentialTransactionPlan(plan.plans.map(freezeTransactionPlan))\n                : nonDivisibleSequentialTransactionPlan(plan.plans.map(freezeTransactionPlan));\n        case 'parallel':\n            return parallelTransactionPlan(plan.plans.map(freezeTransactionPlan));\n        default:\n            plan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND, { kind });\n    }\n}\n\nfunction fitEntirePlanInsideMessage(\n    instructionPlan: InstructionPlan,\n    message: BaseTransactionMessage & TransactionMessageWithFeePayer,\n): BaseTransactionMessage & TransactionMessageWithFeePayer {\n    let newMessage: BaseTransactionMessage & TransactionMessageWithFeePayer = message;\n\n    const kind = instructionPlan.kind;\n    switch (kind) {\n        case 'sequential':\n        case 'parallel':\n            for (const plan of instructionPlan.plans) {\n                newMessage = fitEntirePlanInsideMessage(plan, newMessage);\n            }\n            return newMessage;\n        case 'single':\n            newMessage = appendTransactionMessageInstructions([instructionPlan.instruction], message);\n            // eslint-disable-next-line no-case-declarations\n            const newMessageSize = getTransactionMessageSize(newMessage);\n            if (newMessageSize > TRANSACTION_SIZE_LIMIT) {\n                const baseMessageSize = getTransactionMessageSize(message);\n                throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n                    numBytesRequired: newMessageSize - baseMessageSize,\n                    numFreeBytes: TRANSACTION_SIZE_LIMIT - baseMessageSize,\n                });\n            }\n            return newMessage;\n        case 'messagePacker':\n            // eslint-disable-next-line no-case-declarations\n            const messagePacker = instructionPlan.getMessagePacker();\n            while (!messagePacker.done()) {\n                newMessage = messagePacker.packMessageToCapacity(message);\n            }\n            return newMessage;\n        default:\n            instructionPlan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, { kind });\n    }\n}\n"],"names":["traverse","result","context","SolanaError","traverseSequential","traverseParallel","traverseSingle","candidate","message","getAbortablePromise","getTransactionMessageSize","TRANSACTION_SIZE_LIMIT","SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN","SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND"],"mappings":"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"}},
    {"offset": {"line": 11280, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/sysvars/dist/index.browser.mjs","sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/sysvars/src/sysvar.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/sysvars/src/clock.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/sysvars/src/epoch-rewards.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/sysvars/src/epoch-schedule.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/sysvars/src/last-restart-slot.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/sysvars/src/recent-blockhashes.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/sysvars/src/rent.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/sysvars/src/slot-hashes.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/sysvars/src/slot-history.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40solana/sysvars/src/stake-history.ts"],"sourcesContent":["import {\n    type FetchAccountConfig,\n    fetchEncodedAccount,\n    fetchJsonParsedAccount,\n    type MaybeAccount,\n    type MaybeEncodedAccount,\n} from '@solana/accounts';\nimport type { Address } from '@solana/addresses';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { JsonParsedSysvarAccount } from '@solana/rpc-parsed-types';\nimport type { Rpc } from '@solana/rpc-spec';\n\nexport const SYSVAR_CLOCK_ADDRESS =\n    'SysvarC1ock11111111111111111111111111111111' as Address<'SysvarC1ock11111111111111111111111111111111'>;\nexport const SYSVAR_EPOCH_REWARDS_ADDRESS =\n    'SysvarEpochRewards1111111111111111111111111' as Address<'SysvarEpochRewards1111111111111111111111111'>;\nexport const SYSVAR_EPOCH_SCHEDULE_ADDRESS =\n    'SysvarEpochSchedu1e111111111111111111111111' as Address<'SysvarEpochSchedu1e111111111111111111111111'>;\nexport const SYSVAR_INSTRUCTIONS_ADDRESS =\n    'Sysvar1nstructions1111111111111111111111111' as Address<'Sysvar1nstructions1111111111111111111111111'>;\nexport const SYSVAR_LAST_RESTART_SLOT_ADDRESS =\n    'SysvarLastRestartS1ot1111111111111111111111' as Address<'SysvarLastRestartS1ot1111111111111111111111'>;\nexport const SYSVAR_RECENT_BLOCKHASHES_ADDRESS =\n    'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\nexport const SYSVAR_RENT_ADDRESS =\n    'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\nexport const SYSVAR_SLOT_HASHES_ADDRESS =\n    'SysvarS1otHashes111111111111111111111111111' as Address<'SysvarS1otHashes111111111111111111111111111'>;\nexport const SYSVAR_SLOT_HISTORY_ADDRESS =\n    'SysvarS1otHistory11111111111111111111111111' as Address<'SysvarS1otHistory11111111111111111111111111'>;\nexport const SYSVAR_STAKE_HISTORY_ADDRESS =\n    'SysvarStakeHistory1111111111111111111111111' as Address<'SysvarStakeHistory1111111111111111111111111'>;\n\ntype SysvarAddress =\n    | typeof SYSVAR_CLOCK_ADDRESS\n    | typeof SYSVAR_EPOCH_REWARDS_ADDRESS\n    | typeof SYSVAR_EPOCH_SCHEDULE_ADDRESS\n    | typeof SYSVAR_INSTRUCTIONS_ADDRESS\n    | typeof SYSVAR_LAST_RESTART_SLOT_ADDRESS\n    | typeof SYSVAR_RECENT_BLOCKHASHES_ADDRESS\n    | typeof SYSVAR_RENT_ADDRESS\n    | typeof SYSVAR_SLOT_HASHES_ADDRESS\n    | typeof SYSVAR_SLOT_HISTORY_ADDRESS\n    | typeof SYSVAR_STAKE_HISTORY_ADDRESS;\n\n/**\n * Fetch an encoded sysvar account.\n *\n * Sysvars are special accounts that contain dynamically-updated data about the network cluster, the\n * blockchain history, and the executing transaction.\n */\nexport async function fetchEncodedSysvarAccount<TAddress extends SysvarAddress>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: TAddress,\n    config?: FetchAccountConfig,\n): Promise<MaybeEncodedAccount<TAddress>> {\n    return await fetchEncodedAccount<TAddress>(rpc, address, config);\n}\n\n/**\n * Fetch a JSON-parsed sysvar account.\n *\n * Sysvars are special accounts that contain dynamically-updated data about the network cluster, the\n * blockchain history, and the executing transaction.\n */\nexport async function fetchJsonParsedSysvarAccount<TAddress extends SysvarAddress>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: TAddress,\n    config?: FetchAccountConfig,\n): Promise<MaybeAccount<JsonParsedSysvarAccount, TAddress> | MaybeEncodedAccount<TAddress>> {\n    return await fetchJsonParsedAccount<JsonParsedSysvarAccount, TAddress>(rpc, address, config);\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getI64Decoder,\n    getI64Encoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Epoch, Slot, UnixTimestamp } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_CLOCK_ADDRESS } from './sysvar';\n\ntype SysvarClockSize = 40;\n\n/**\n * Contains data on cluster time, including the current slot, epoch, and estimated wall-clock Unix\n * timestamp. It is updated every slot.\n */\nexport type SysvarClock = Readonly<{\n    /** The current epoch */\n    epoch: Epoch;\n    /**\n     * The Unix timestamp of the first slot in this epoch.\n     *\n     * In the first slot of an epoch, this timestamp is identical to the `unixTimestamp`.\n     */\n    epochStartTimestamp: UnixTimestamp;\n    /** The most recent epoch for which the leader schedule has already been generated */\n    leaderScheduleEpoch: Epoch;\n    /** The current slot */\n    slot: Slot;\n    /** The Unix timestamp of this slot */\n    unixTimestamp: UnixTimestamp;\n}>;\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarClock} to a byte array representing\n * the `Clock` sysvar's account data.\n */\nexport function getSysvarClockEncoder(): FixedSizeEncoder<SysvarClock, SysvarClockSize> {\n    return getStructEncoder([\n        ['slot', getU64Encoder()],\n        ['epochStartTimestamp', getI64Encoder()],\n        ['epoch', getU64Encoder()],\n        ['leaderScheduleEpoch', getU64Encoder()],\n        ['unixTimestamp', getI64Encoder()],\n    ]) as FixedSizeEncoder<SysvarClock, SysvarClockSize>;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `Clock` sysvar's\n * account data to a {@link SysvarClock}.\n */\nexport function getSysvarClockDecoder(): FixedSizeDecoder<SysvarClock, SysvarClockSize> {\n    return getStructDecoder([\n        ['slot', getU64Decoder()],\n        ['epochStartTimestamp', getI64Decoder()],\n        ['epoch', getU64Decoder()],\n        ['leaderScheduleEpoch', getU64Decoder()],\n        ['unixTimestamp', getI64Decoder()],\n    ]) as FixedSizeDecoder<SysvarClock, SysvarClockSize>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarClock}\n *\n * @see {@link getSysvarClockDecoder}\n * @see {@link getSysvarClockEncoder}\n */\nexport function getSysvarClockCodec(): FixedSizeCodec<SysvarClock, SysvarClock, SysvarClockSize> {\n    return combineCodec(getSysvarClockEncoder(), getSysvarClockDecoder());\n}\n\n/**\n * Fetches the `Clock` sysvar account using any RPC that supports the {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarClock(rpc: Rpc<GetAccountInfoApi>, config?: FetchAccountConfig): Promise<SysvarClock> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_CLOCK_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarClockDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getBooleanDecoder,\n    getBooleanEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n    getU128Decoder,\n    getU128Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport {\n    Blockhash,\n    getBlockhashDecoder,\n    getBlockhashEncoder,\n    getDefaultLamportsDecoder,\n    getDefaultLamportsEncoder,\n    Lamports,\n} from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_EPOCH_REWARDS_ADDRESS } from './sysvar';\n\ntype SysvarEpochRewardsSize = 81;\n\n/**\n * Tracks whether the rewards period (including calculation and distribution) is in progress, as\n * well as the details needed to resume distribution when starting from a snapshot during the\n * rewards period.\n *\n * The sysvar is repopulated at the start of the first block of each epoch. Therefore, the sysvar\n * contains data about the current epoch until a new epoch begins.\n */\nexport type SysvarEpochRewards = Readonly<{\n    /** Whether the rewards period (including calculation and distribution) is active */\n    active: boolean;\n    /** The rewards currently distributed for the current epoch, in {@link Lamports} */\n    distributedRewards: Lamports;\n    /** The starting block height of the rewards distribution in the current epoch */\n    distributionStartingBlockHeight: bigint;\n    /**\n     * Number of partitions in the rewards distribution in the current epoch, used to generate an\n     * `EpochRewardsHasher`\n     */\n    numPartitions: bigint;\n    /**\n     * The {@link Blockhash} of the parent block of the first block in the epoch, used to seed an\n     * `EpochRewardsHasher`\n     */\n    parentBlockhash: Blockhash;\n    /**\n     * The total rewards points calculated for the current epoch, where points equals the sum of\n     * (delegated stake * credits observed) for all  delegations\n     */\n    totalPoints: bigint;\n    /** The total rewards for the current epoch, in {@link Lamports} */\n    totalRewards: Lamports;\n}>;\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarEpochRewards} to a byte array\n * representing the `EpochRewards` sysvar's account data.\n */\nexport function getSysvarEpochRewardsEncoder(): FixedSizeEncoder<SysvarEpochRewards, SysvarEpochRewardsSize> {\n    return getStructEncoder([\n        ['distributionStartingBlockHeight', getU64Encoder()],\n        ['numPartitions', getU64Encoder()],\n        ['parentBlockhash', getBlockhashEncoder()],\n        ['totalPoints', getU128Encoder()],\n        ['totalRewards', getDefaultLamportsEncoder()],\n        ['distributedRewards', getDefaultLamportsEncoder()],\n        ['active', getBooleanEncoder()],\n    ]) as FixedSizeEncoder<SysvarEpochRewards, SysvarEpochRewardsSize>;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `EpochRewards`\n * sysvar's account data to a {@link SysvarEpochRewards}.\n */\nexport function getSysvarEpochRewardsDecoder(): FixedSizeDecoder<SysvarEpochRewards, SysvarEpochRewardsSize> {\n    return getStructDecoder([\n        ['distributionStartingBlockHeight', getU64Decoder()],\n        ['numPartitions', getU64Decoder()],\n        ['parentBlockhash', getBlockhashDecoder()],\n        ['totalPoints', getU128Decoder()],\n        ['totalRewards', getDefaultLamportsDecoder()],\n        ['distributedRewards', getDefaultLamportsDecoder()],\n        ['active', getBooleanDecoder()],\n    ]) as FixedSizeDecoder<SysvarEpochRewards, SysvarEpochRewardsSize>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarEpochRewards}\n *\n * @see {@link getSysvarEpochRewardsDecoder}\n * @see {@link getSysvarEpochRewardsEncoder}\n */\nexport function getSysvarEpochRewardsCodec(): FixedSizeCodec<\n    SysvarEpochRewards,\n    SysvarEpochRewards,\n    SysvarEpochRewardsSize\n> {\n    return combineCodec(getSysvarEpochRewardsEncoder(), getSysvarEpochRewardsDecoder());\n}\n\n/**\n * Fetch the `EpochRewards` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarEpochRewards(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarEpochRewards> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_EPOCH_REWARDS_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarEpochRewardsDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getBooleanDecoder,\n    getBooleanEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Epoch, Slot } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_EPOCH_SCHEDULE_ADDRESS } from './sysvar';\n\ntype SysvarEpochScheduleSize = 33;\n\n/**\n * Includes the number of slots per epoch, timing of leader schedule selection, and information\n * about epoch warm-up time.\n */\nexport type SysvarEpochSchedule = Readonly<{\n    /**\n     * First normal-length epoch after the warmup period,\n     * log2(slotsPerEpoch) - log2(MINIMUM_SLOTS_PER_EPOCH)\n     */\n    firstNormalEpoch: Epoch;\n    /**\n     * The first slot after the warmup period, MINIMUM_SLOTS_PER_EPOCH * (2^(firstNormalEpoch) - 1)\n     */\n    firstNormalSlot: Slot;\n    /**\n     * A number of slots before beginning of an epoch to calculate a leader schedule for that\n     * epoch.\n     */\n    leaderScheduleSlotOffset: bigint;\n    /** The maximum number of slots in each epoch */\n    slotsPerEpoch: bigint;\n    /** Whether epochs start short and grow */\n    warmup: boolean;\n}>;\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarEpochSchedule} to a byte array\n * representing the `EpochSchedule` sysvar's account data.\n */\nexport function getSysvarEpochScheduleEncoder(): FixedSizeEncoder<SysvarEpochSchedule, SysvarEpochScheduleSize> {\n    return getStructEncoder([\n        ['slotsPerEpoch', getU64Encoder()],\n        ['leaderScheduleSlotOffset', getU64Encoder()],\n        ['warmup', getBooleanEncoder()],\n        ['firstNormalEpoch', getU64Encoder()],\n        ['firstNormalSlot', getU64Encoder()],\n    ]) as FixedSizeEncoder<SysvarEpochSchedule, SysvarEpochScheduleSize>;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `EpochSchedule`\n * sysvar's account data to a {@link SysvarEpochSchedule}.\n */\nexport function getSysvarEpochScheduleDecoder(): FixedSizeDecoder<SysvarEpochSchedule, SysvarEpochScheduleSize> {\n    return getStructDecoder([\n        ['slotsPerEpoch', getU64Decoder()],\n        ['leaderScheduleSlotOffset', getU64Decoder()],\n        ['warmup', getBooleanDecoder()],\n        ['firstNormalEpoch', getU64Decoder()],\n        ['firstNormalSlot', getU64Decoder()],\n    ]) as FixedSizeDecoder<SysvarEpochSchedule, SysvarEpochScheduleSize>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarEpochSchedule}\n *\n * @see {@link getSysvarEpochScheduleDecoder}\n * @see {@link getSysvarEpochScheduleEncoder}\n */\nexport function getSysvarEpochScheduleCodec(): FixedSizeCodec<\n    SysvarEpochSchedule,\n    SysvarEpochSchedule,\n    SysvarEpochScheduleSize\n> {\n    return combineCodec(getSysvarEpochScheduleEncoder(), getSysvarEpochScheduleDecoder());\n}\n\n/**\n * Fetches the `EpochSchedule` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarEpochSchedule(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarEpochSchedule> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_EPOCH_SCHEDULE_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarEpochScheduleDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Slot } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_LAST_RESTART_SLOT_ADDRESS } from './sysvar';\n\ntype SysvarLastRestartSlotSize = 8;\n\n/**\n * Information about the last restart slot (hard fork).\n *\n * The `LastRestartSlot` sysvar provides access to the last restart slot kept in the bank fork for\n * the slot on the fork that executes the current transaction. In case there was no fork it returns\n * `0`.\n */\nexport type SysvarLastRestartSlot = Readonly<{\n    /** The last restart {@link Slot} */\n    lastRestartSlot: Slot;\n}>;\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarLastRestartSlot} to a byte array\n * representing the `LastRestartSlot` sysvar's account data.\n */\nexport function getSysvarLastRestartSlotEncoder(): FixedSizeEncoder<SysvarLastRestartSlot, SysvarLastRestartSlotSize> {\n    return getStructEncoder([['lastRestartSlot', getU64Encoder()]]) as FixedSizeEncoder<\n        SysvarLastRestartSlot,\n        SysvarLastRestartSlotSize\n    >;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `LastRestartSlot`\n * sysvar's account data to a {@link SysvarLastRestartSlot}.\n */\nexport function getSysvarLastRestartSlotDecoder(): FixedSizeDecoder<SysvarLastRestartSlot, SysvarLastRestartSlotSize> {\n    return getStructDecoder([['lastRestartSlot', getU64Decoder()]]) as FixedSizeDecoder<\n        SysvarLastRestartSlot,\n        SysvarLastRestartSlotSize\n    >;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarLastRestartSlot}\n *\n * @see {@link getSysvarLastRestartSlotDecoder}\n * @see {@link getSysvarLastRestartSlotEncoder}\n */\nexport function getSysvarLastRestartSlotCodec(): FixedSizeCodec<\n    SysvarLastRestartSlot,\n    SysvarLastRestartSlot,\n    SysvarLastRestartSlotSize\n> {\n    return combineCodec(getSysvarLastRestartSlotEncoder(), getSysvarLastRestartSlotDecoder());\n}\n\n/**\n * Fetches the `LastRestartSlot` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarLastRestartSlot(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarLastRestartSlot> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_LAST_RESTART_SLOT_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarLastRestartSlotDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    getArrayDecoder,\n    getArrayEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport {\n    type Blockhash,\n    getBlockhashDecoder,\n    getBlockhashEncoder,\n    getDefaultLamportsDecoder,\n    getDefaultLamportsEncoder,\n    type Lamports,\n} from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_RECENT_BLOCKHASHES_ADDRESS } from './sysvar';\n\ntype FeeCalculator = Readonly<{\n    /**\n     * The current cost of a signature.\n     *\n     * This amount may increase/decrease over time based on cluster processing load\n     */\n    lamportsPerSignature: Lamports;\n}>;\ntype Entry = Readonly<{\n    blockhash: Blockhash;\n    feeCalculator: FeeCalculator;\n}>;\n\n/**\n * Information about recent blocks and their fee calculators.\n *\n * @deprecated Transaction fees should be determined with the\n * {@link GetFeeForMessageApi.getFeeForMessage} RPC method. For additional context see the\n * [Comprehensive Compute Fees proposal](https://docs.anza.xyz/proposals/comprehensive-compute-fees/).\n */\nexport type SysvarRecentBlockhashes = Entry[];\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarRecentBlockhashes} to a byte array\n * representing the `RecentBlockhashes` sysvar's account data.\n *\n * @deprecated Transaction fees should be determined with the\n * {@link GetFeeForMessageApi.getFeeForMessage} RPC method. For additional context see the\n * [Comprehensive Compute Fees proposal](https://docs.anza.xyz/proposals/comprehensive-compute-fees/).\n */\nexport function getSysvarRecentBlockhashesEncoder(): VariableSizeEncoder<SysvarRecentBlockhashes> {\n    return getArrayEncoder(\n        getStructEncoder([\n            ['blockhash', getBlockhashEncoder()],\n            ['feeCalculator', getStructEncoder([['lamportsPerSignature', getDefaultLamportsEncoder()]])],\n        ]),\n    );\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `RecentBlockhashes`\n * sysvar's account data to a {@link SysvarRecentBlockhashes}.\n *\n * @deprecated Transaction fees should be determined with the\n * {@link GetFeeForMessageApi.getFeeForMessage} RPC method. For additional context see the\n * [Comprehensive Compute Fees proposal](https://docs.anza.xyz/proposals/comprehensive-compute-fees/).\n */\nexport function getSysvarRecentBlockhashesDecoder(): VariableSizeDecoder<SysvarRecentBlockhashes> {\n    return getArrayDecoder(\n        getStructDecoder([\n            ['blockhash', getBlockhashDecoder()],\n            ['feeCalculator', getStructDecoder([['lamportsPerSignature', getDefaultLamportsDecoder()]])],\n        ]),\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarRecentBlockhashes}\n *\n * @deprecated Transaction fees should be determined with the\n * {@link GetFeeForMessageApi.getFeeForMessage} RPC method. For additional context see the\n * [Comprehensive Compute Fees proposal](https://docs.anza.xyz/proposals/comprehensive-compute-fees/).\n *\n * @see {@link getSysvarRecentBlockhashesDecoder}\n * @see {@link getSysvarRecentBlockhashesEncoder}\n */\nexport function getSysvarRecentBlockhashesCodec(): VariableSizeCodec<SysvarRecentBlockhashes> {\n    return combineCodec(getSysvarRecentBlockhashesEncoder(), getSysvarRecentBlockhashesDecoder());\n}\n\n/**\n * Fetches the `RecentBlockhashes` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n *\n * @deprecated Transaction fees should be determined with the\n * {@link GetFeeForMessageApi.getFeeForMessage} RPC method. For additional context see the\n * [Comprehensive Compute Fees proposal](https://docs.anza.xyz/proposals/comprehensive-compute-fees/).\n */\nexport async function fetchSysvarRecentBlockhashes(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarRecentBlockhashes> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_RECENT_BLOCKHASHES_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarRecentBlockhashesDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getF64Decoder,\n    getF64Encoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU8Decoder,\n    getU8Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport {\n    F64UnsafeSeeDocumentation,\n    getDefaultLamportsDecoder,\n    getDefaultLamportsEncoder,\n    type Lamports,\n} from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_RENT_ADDRESS } from './sysvar';\n\ntype SysvarRentSize = 17;\n\n/**\n * Configuration for network rent.\n */\nexport type SysvarRent = Readonly<{\n    /**\n     * The percentage of collected rent that is burned.\n     *\n     * Valid values are in the range [0, 100]. The remaining percentage is distributed to\n     * validators.\n     */\n    burnPercent: number;\n    /** Amount of time (in years) a balance must include rent for the account to be rent exempt */\n    exemptionThreshold: F64UnsafeSeeDocumentation;\n    /** Rental rate in {@link Lamports}/byte-year. */\n    lamportsPerByteYear: Lamports;\n}>;\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarRent} to a byte array representing\n * the `Rent` sysvar's account data.\n */\nexport function getSysvarRentEncoder(): FixedSizeEncoder<SysvarRent, SysvarRentSize> {\n    return getStructEncoder([\n        ['lamportsPerByteYear', getDefaultLamportsEncoder()],\n        ['exemptionThreshold', getF64Encoder()],\n        ['burnPercent', getU8Encoder()],\n    ]) as FixedSizeEncoder<SysvarRent, SysvarRentSize>;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `Rent` sysvar's\n * account data to a {@link SysvarRent}.\n */\nexport function getSysvarRentDecoder(): FixedSizeDecoder<SysvarRent, SysvarRentSize> {\n    return getStructDecoder([\n        ['lamportsPerByteYear', getDefaultLamportsDecoder()],\n        ['exemptionThreshold', getF64Decoder()],\n        ['burnPercent', getU8Decoder()],\n    ]) as FixedSizeDecoder<SysvarRent, SysvarRentSize>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarRent}\n *\n * @see {@link getSysvarRentDecoder}\n * @see {@link getSysvarRentEncoder}\n */\nexport function getSysvarRentCodec(): FixedSizeCodec<SysvarRent, SysvarRent, SysvarRentSize> {\n    return combineCodec(getSysvarRentEncoder(), getSysvarRentDecoder());\n}\n\n/**\n * Fetches the `Rent` sysvar account using any RPC that supports the {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarRent(rpc: Rpc<GetAccountInfoApi>, config?: FetchAccountConfig): Promise<SysvarRent> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_RENT_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarRentDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    getArrayDecoder,\n    getArrayEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport { type Blockhash, getBlockhashDecoder, getBlockhashEncoder, type Slot } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_SLOT_HASHES_ADDRESS } from './sysvar';\n\ntype Entry = Readonly<{\n    hash: Blockhash;\n    slot: Slot;\n}>;\n\n/** The most recent hashes of a slot's parent banks. */\nexport type SysvarSlotHashes = Entry[];\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarSlotHashes} to a byte array\n * representing the `SlotHashes` sysvar's account data.\n */\nexport function getSysvarSlotHashesEncoder(): VariableSizeEncoder<SysvarSlotHashes> {\n    return getArrayEncoder(\n        getStructEncoder([\n            ['slot', getU64Encoder()],\n            ['hash', getBlockhashEncoder()],\n        ]),\n    );\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `SlotHashes` sysvar's\n * account data to a {@link SysvarSlotHashes}.\n */\nexport function getSysvarSlotHashesDecoder(): VariableSizeDecoder<SysvarSlotHashes> {\n    return getArrayDecoder(\n        getStructDecoder([\n            ['slot', getU64Decoder()],\n            ['hash', getBlockhashDecoder()],\n        ]),\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarSlotHashes}\n *\n * @see {@link getSysvarSlotHashesDecoder}\n * @see {@link getSysvarSlotHashesEncoder}\n */\nexport function getSysvarSlotHashesCodec(): VariableSizeCodec<SysvarSlotHashes> {\n    return combineCodec(getSysvarSlotHashesEncoder(), getSysvarSlotHashesDecoder());\n}\n\n/**\n * Fetches the `SlotHashes` sysvar account using any RPC that supports the {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarSlotHashes(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarSlotHashes> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_SLOT_HASHES_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarSlotHashesDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getArrayCodec,\n    getU64Codec,\n    getU64Decoder,\n    getU64Encoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs';\nimport {\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SolanaError,\n} from '@solana/errors';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Slot } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_SLOT_HISTORY_ADDRESS } from './sysvar';\n\nconst BITVEC_DISCRIMINATOR = 1;\n// Max number of bits in the bitvector.\n// The Solana SDK defines a constant `MAX_ENTRIES` representing the maximum\n// number of bits that can be represented by the bitvector in the `SlotHistory`\n// sysvar. This value is 1024 * 1024 = 1_048_576.\n// See https://github.com/anza-xyz/agave/blob/e0203f22dc83cb792fa97f91dbe6e924cbd08af1/sdk/program/src/slot_history.rs#L43\nconst BITVEC_NUM_BITS = 1024 * 1024;\n// The length of the bitvector in blocks.\n// At 64 bits per block, this is 1024 * 1024 / 64 = 16_384.\nconst BITVEC_LENGTH = BITVEC_NUM_BITS / 64;\n\nconst SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE =\n    1 + // Discriminator\n    8 + // bitvector length (u64)\n    BITVEC_LENGTH * 8 +\n    8 + // Number of bits (u64)\n    8; // Next slot (u64)\n\nlet memoizedU64Encoder: FixedSizeEncoder<bigint, 8> | undefined;\nlet memoizedU64Decoder: FixedSizeDecoder<bigint, 8> | undefined;\nlet memoizedU64ArrayEncoder: FixedSizeEncoder<bigint[]> | undefined;\nlet memoizedU64ArrayDecoder: FixedSizeDecoder<bigint[]> | undefined;\n\nfunction getMemoizedU64Encoder(): FixedSizeEncoder<bigint, 8> {\n    if (!memoizedU64Encoder) memoizedU64Encoder = getU64Encoder();\n    return memoizedU64Encoder;\n}\nfunction getMemoizedU64Decoder(): FixedSizeDecoder<bigint, 8> {\n    if (!memoizedU64Decoder) memoizedU64Decoder = getU64Decoder();\n    return memoizedU64Decoder;\n}\nfunction getMemoizedU64ArrayEncoder(): FixedSizeEncoder<bigint[], typeof BITVEC_LENGTH> {\n    if (!memoizedU64ArrayEncoder) memoizedU64ArrayEncoder = getArrayCodec(getU64Codec(), { size: BITVEC_LENGTH });\n    return memoizedU64ArrayEncoder;\n}\nfunction getMemoizedU64ArrayDecoder(): FixedSizeDecoder<bigint[], typeof BITVEC_LENGTH> {\n    if (!memoizedU64ArrayDecoder) memoizedU64ArrayDecoder = getArrayCodec(getU64Codec(), { size: BITVEC_LENGTH });\n    return memoizedU64ArrayDecoder;\n}\n\ntype SysvarSlotHistorySize = typeof SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE;\n\n/** A bitvector of slots present over the last epoch. */\nexport type SysvarSlotHistory = {\n    /**\n     * A vector of 64-bit numbers which, when their bits are strung together, represent a record of\n     * non-skipped slots.\n     *\n     * The bit in position (slot % MAX_ENTRIES) is 0 if the slot was skipped and 1 otherwise, valid\n     * only when the candidate slot is less than `nextSlot` and greater than or equal to\n     * `MAX_ENTRIES - nextSlot`.\n     */\n    bits: bigint[];\n    /** The number of the slot one newer than tracked by the bitvector */\n    nextSlot: Slot;\n};\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarSlotHistory} to a byte array\n * representing the `SlotHistory` sysvar's account data.\n */\nexport function getSysvarSlotHistoryEncoder(): FixedSizeEncoder<SysvarSlotHistory, SysvarSlotHistorySize> {\n    return createEncoder({\n        fixedSize: SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE,\n        write: (value: SysvarSlotHistory, bytes, offset) => {\n            // First byte is the bitvector discriminator.\n            bytes.set([BITVEC_DISCRIMINATOR], offset);\n            offset += 1;\n            // Next 8 bytes are the bitvector length.\n            getMemoizedU64Encoder().write(BigInt(BITVEC_LENGTH), bytes, offset);\n            offset += 8;\n            // Next `BITVEC_LENGTH` bytes are the bitvector.\n            // Any missing bits are assumed to be 0.\n            getMemoizedU64ArrayEncoder().write(value.bits, bytes, offset);\n            offset += BITVEC_LENGTH * 8;\n            // Next 8 bytes are the number of bits.\n            getMemoizedU64Encoder().write(BigInt(BITVEC_NUM_BITS), bytes, offset);\n            offset += 8;\n            // Next 8 bytes are the next slot.\n            getMemoizedU64Encoder().write(value.nextSlot, bytes, offset);\n            offset += 8;\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `SlotHistory` sysvar's\n * account data to a {@link SysvarSlotHistory}.\n */\nexport function getSysvarSlotHistoryDecoder(): FixedSizeDecoder<SysvarSlotHistory, SysvarSlotHistorySize> {\n    return createDecoder({\n        fixedSize: SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            // Byte length should be exact.\n            if (bytes.length != SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n                    actual: bytes.length,\n                    expected: SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE,\n                });\n            }\n            // First byte is the bitvector discriminator.\n            const discriminator = bytes[offset];\n            offset += 1;\n            if (discriminator !== BITVEC_DISCRIMINATOR) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                    actual: discriminator,\n                    expected: BITVEC_DISCRIMINATOR,\n                });\n            }\n            // Next 8 bytes are the bitvector length.\n            const bitVecLength = getMemoizedU64Decoder().read(bytes, offset)[0];\n            offset += 8;\n            if (bitVecLength !== BigInt(BITVEC_LENGTH)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n                    actual: bitVecLength,\n                    codecDescription: 'SysvarSlotHistoryCodec',\n                    expected: BITVEC_LENGTH,\n                });\n            }\n            // Next `BITVEC_LENGTH` bytes are the bitvector.\n            const bits = getMemoizedU64ArrayDecoder().read(bytes, offset)[0];\n            offset += BITVEC_LENGTH * 8;\n            // Next 8 bytes are the number of bits.\n            const numBits = getMemoizedU64Decoder().read(bytes, offset)[0];\n            offset += 8;\n            if (numBits !== BigInt(BITVEC_NUM_BITS)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n                    actual: numBits,\n                    codecDescription: 'SysvarSlotHistoryCodec',\n                    expected: BITVEC_NUM_BITS,\n                });\n            }\n            // Next 8 bytes are the next slot.\n            const nextSlot = getMemoizedU64Decoder().read(bytes, offset)[0];\n            offset += 8;\n            return [\n                {\n                    bits,\n                    nextSlot,\n                },\n                offset,\n            ];\n        },\n    });\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarSlotHistory}\n *\n * @see {@link getSysvarSlotHistoryDecoder}\n * @see {@link getSysvarSlotHistoryEncoder}\n */\nexport function getSysvarSlotHistoryCodec(): FixedSizeCodec<\n    SysvarSlotHistory,\n    SysvarSlotHistory,\n    SysvarSlotHistorySize\n> {\n    return combineCodec(getSysvarSlotHistoryEncoder(), getSysvarSlotHistoryDecoder());\n}\n\n/**\n * Fetches the `SlotHistory` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarSlotHistory(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarSlotHistory> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_SLOT_HISTORY_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarSlotHistoryDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    getArrayDecoder,\n    getArrayEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport { Epoch, getDefaultLamportsDecoder, getDefaultLamportsEncoder, type Lamports } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_STAKE_HISTORY_ADDRESS } from './sysvar';\n\ntype Entry = Readonly<{\n    /** The epoch to which this stake history entry pertains */\n    epoch: Epoch;\n    stakeHistory: Readonly<{\n        /**\n         * Sum of portion of stakes requested to be warmed up, but not fully activated yet, in\n         * {@link Lamports}\n         */\n        activating: Lamports;\n        /**\n         * Sum of portion of stakes requested to be cooled down, but not fully deactivated yet, in\n         * {@link Lamports}\n         */\n        deactivating: Lamports;\n        /** Effective stake at this epoch, in {@link Lamports} */\n        effective: Lamports;\n    }>;\n}>;\n\n/** History of stake activations and de-activations. */\nexport type SysvarStakeHistory = Entry[];\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarStakeHistory} to a byte array\n * representing the `StakeHistory` sysvar's account data.\n */\nexport function getSysvarStakeHistoryEncoder(): VariableSizeEncoder<SysvarStakeHistory> {\n    return getArrayEncoder(\n        getStructEncoder([\n            ['epoch', getU64Encoder()],\n            [\n                'stakeHistory',\n                getStructEncoder([\n                    ['effective', getDefaultLamportsEncoder()],\n                    ['activating', getDefaultLamportsEncoder()],\n                    ['deactivating', getDefaultLamportsEncoder()],\n                ]),\n            ],\n        ]),\n        { size: getU64Encoder() },\n    );\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `StakeHistory`\n * sysvar's account data to a {@link SysvarStakeHistory}.\n */\nexport function getSysvarStakeHistoryDecoder(): VariableSizeDecoder<SysvarStakeHistory> {\n    return getArrayDecoder(\n        getStructDecoder([\n            ['epoch', getU64Decoder()],\n            [\n                'stakeHistory',\n                getStructDecoder([\n                    ['effective', getDefaultLamportsDecoder()],\n                    ['activating', getDefaultLamportsDecoder()],\n                    ['deactivating', getDefaultLamportsDecoder()],\n                ]),\n            ],\n        ]),\n        { size: getU64Decoder() },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarStakeHistory}\n *\n * @see {@link getSysvarStakeHistoryDecoder}\n * @see {@link getSysvarStakeHistoryEncoder}\n */\nexport function getSysvarStakeHistoryCodec(): VariableSizeCodec<SysvarStakeHistory> {\n    return combineCodec(getSysvarStakeHistoryEncoder(), getSysvarStakeHistoryDecoder());\n}\n\n/**\n * Fetches the `StakeHistory` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarStakeHistory(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarStakeHistory> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_STAKE_HISTORY_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarStakeHistoryDecoder());\n    return decoded.data;\n}\n"],"names":["getStructEncoder","getU64Encoder","getStructDecoder","getU64Decoder","combineCodec","assertAccountExists","decodeAccount","getBooleanEncoder","getBooleanDecoder","getBlockhashEncoder","getDefaultLamportsEncoder","getBlockhashDecoder","getDefaultLamportsDecoder","getArrayEncoder","getArrayDecoder"],"mappings":"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"}}]
}
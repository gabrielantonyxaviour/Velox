module.exports = [
"[project]/node_modules/got/dist/source/core/errors.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AbortError",
    ()=>AbortError,
    "CacheError",
    ()=>CacheError,
    "HTTPError",
    ()=>HTTPError,
    "MaxRedirectsError",
    ()=>MaxRedirectsError,
    "ReadError",
    ()=>ReadError,
    "RequestError",
    ()=>RequestError,
    "RetryError",
    ()=>RetryError,
    "TimeoutError",
    ()=>TimeoutError,
    "UploadError",
    ()=>UploadError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sindresorhus/is/distribution/index.js [app-ssr] (ecmascript)");
;
// A hacky check to prevent circular references.
function isRequest(x) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object(x) && '_onResponse' in x;
}
class RequestError extends Error {
    name = 'RequestError';
    code = 'ERR_GOT_REQUEST_ERROR';
    input;
    stack;
    response;
    request;
    timings;
    constructor(message, error, self){
        super(message, {
            cause: error
        });
        Error.captureStackTrace(this, this.constructor);
        if (error.code) {
            this.code = error.code;
        }
        this.input = error.input;
        if (isRequest(self)) {
            Object.defineProperty(this, 'request', {
                enumerable: false,
                value: self
            });
            Object.defineProperty(this, 'response', {
                enumerable: false,
                value: self.response
            });
            this.options = self.options;
        } else {
            this.options = self;
        }
        this.timings = this.request?.timings;
        // Recover the original stacktrace
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string(error.stack) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string(this.stack)) {
            const indexOfMessage = this.stack.indexOf(this.message) + this.message.length;
            const thisStackTrace = this.stack.slice(indexOfMessage).split('\n').reverse();
            const errorStackTrace = error.stack.slice(error.stack.indexOf(error.message) + error.message.length).split('\n').reverse();
            // Remove duplicated traces
            while(errorStackTrace.length > 0 && errorStackTrace[0] === thisStackTrace[0]){
                thisStackTrace.shift();
            }
            this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join('\n')}${errorStackTrace.reverse().join('\n')}`;
        }
    }
}
class MaxRedirectsError extends RequestError {
    name = 'MaxRedirectsError';
    code = 'ERR_TOO_MANY_REDIRECTS';
    constructor(request){
        super(`Redirected ${request.options.maxRedirects} times. Aborting.`, {}, request);
    }
}
class HTTPError extends RequestError {
    name = 'HTTPError';
    code = 'ERR_NON_2XX_3XX_RESPONSE';
    constructor(response){
        super(`Request failed with status code ${response.statusCode} (${response.statusMessage}): ${response.request.options.method} ${response.request.options.url.toString()}`, {}, response.request);
    }
}
class CacheError extends RequestError {
    name = 'CacheError';
    constructor(error, request){
        super(error.message, error, request);
        if (this.code === 'ERR_GOT_REQUEST_ERROR') {
            this.code = 'ERR_CACHE_ACCESS';
        }
    }
}
class UploadError extends RequestError {
    name = 'UploadError';
    constructor(error, request){
        super(error.message, error, request);
        if (this.code === 'ERR_GOT_REQUEST_ERROR') {
            this.code = 'ERR_UPLOAD';
        }
    }
}
class TimeoutError extends RequestError {
    name = 'TimeoutError';
    timings;
    event;
    constructor(error, timings, request){
        super(error.message, error, request);
        this.event = error.event;
        this.timings = timings;
    }
}
class ReadError extends RequestError {
    name = 'ReadError';
    constructor(error, request){
        super(error.message, error, request);
        if (this.code === 'ERR_GOT_REQUEST_ERROR') {
            this.code = 'ERR_READING_RESPONSE_STREAM';
        }
    }
}
class RetryError extends RequestError {
    name = 'RetryError';
    code = 'ERR_RETRYING';
    constructor(request){
        super('Retrying', {}, request);
    }
}
class AbortError extends RequestError {
    name = 'AbortError';
    code = 'ERR_ABORTED';
    constructor(request){
        super('This operation was aborted.', {}, request);
    }
}
}),
"[project]/node_modules/got/dist/source/core/utils/defer-to-connect.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
function isTlsSocket(socket) {
    return 'encrypted' in socket;
}
const deferToConnect = (socket, fn)=>{
    let listeners;
    if (typeof fn === 'function') {
        const connect = fn;
        listeners = {
            connect
        };
    } else {
        listeners = fn;
    }
    const hasConnectListener = typeof listeners.connect === 'function';
    const hasSecureConnectListener = typeof listeners.secureConnect === 'function';
    const hasCloseListener = typeof listeners.close === 'function';
    const onConnect = ()=>{
        if (hasConnectListener) {
            listeners.connect();
        }
        if (isTlsSocket(socket) && hasSecureConnectListener) {
            if (socket.authorized) {
                listeners.secureConnect();
            } else {
                // Wait for secureConnect event (even if authorization fails, we need the timing)
                socket.once('secureConnect', listeners.secureConnect);
            }
        }
        if (hasCloseListener) {
            socket.once('close', listeners.close);
        }
    };
    if (socket.writable && !socket.connecting) {
        onConnect();
    } else if (socket.connecting) {
        socket.once('connect', onConnect);
    } else if (socket.destroyed && hasCloseListener) {
        const hadError = '_hadError' in socket ? Boolean(socket._hadError) : false;
        listeners.close(hadError);
    }
};
const __TURBOPACK__default__export__ = deferToConnect;
}),
"[project]/node_modules/got/dist/source/core/utils/timer.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:events [external] (node:events, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:util [external] (node:util, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$defer$2d$to$2d$connect$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/utils/defer-to-connect.js [app-ssr] (ecmascript)");
;
;
;
const timer = (request)=>{
    if (request.timings) {
        return request.timings;
    }
    const timings = {
        start: Date.now(),
        socket: undefined,
        lookup: undefined,
        connect: undefined,
        secureConnect: undefined,
        upload: undefined,
        response: undefined,
        end: undefined,
        error: undefined,
        abort: undefined,
        phases: {
            wait: undefined,
            dns: undefined,
            tcp: undefined,
            tls: undefined,
            request: undefined,
            firstByte: undefined,
            download: undefined,
            total: undefined
        }
    };
    request.timings = timings;
    const handleError = (origin)=>{
        origin.once(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["errorMonitor"], ()=>{
            timings.error = Date.now();
            timings.phases.total = timings.error - timings.start;
        });
    };
    handleError(request);
    const onAbort = ()=>{
        timings.abort = Date.now();
        timings.phases.total = timings.abort - timings.start;
    };
    request.prependOnceListener('abort', onAbort);
    const onSocket = (socket)=>{
        timings.socket = Date.now();
        timings.phases.wait = timings.socket - timings.start;
        if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["types"].isProxy(socket)) {
            // HTTP/2: The socket is a proxy, so connection events won't fire.
            // We can't measure connection timings, so leave them undefined.
            // This prevents NaN in phases.request calculation.
            return;
        }
        // Check if socket is already connected (reused from connection pool)
        const socketAlreadyConnected = socket.writable && !socket.connecting;
        if (socketAlreadyConnected) {
            // Socket reuse detected: the socket was already connected from a previous request.
            // For reused sockets, set all connection timestamps to socket time since no new
            // connection was made for THIS request. But preserve phase durations from the
            // original connection so they're not lost.
            timings.lookup = timings.socket;
            timings.connect = timings.socket;
            if (socket.__initial_connection_timings__) {
                // Restore the phase timings from the initial connection
                timings.phases.dns = socket.__initial_connection_timings__.dnsPhase;
                timings.phases.tcp = socket.__initial_connection_timings__.tcpPhase;
                timings.phases.tls = socket.__initial_connection_timings__.tlsPhase;
                // Set secureConnect timestamp if there was TLS
                if (timings.phases.tls !== undefined) {
                    timings.secureConnect = timings.socket;
                }
            } else {
                // Socket reused but no initial timings stored (e.g., from external code)
                // Set phases to 0
                timings.phases.dns = 0;
                timings.phases.tcp = 0;
            }
            return;
        }
        const lookupListener = ()=>{
            timings.lookup = Date.now();
            timings.phases.dns = timings.lookup - timings.socket;
        };
        socket.prependOnceListener('lookup', lookupListener);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$defer$2d$to$2d$connect$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(socket, {
            connect () {
                timings.connect = Date.now();
                if (timings.lookup === undefined) {
                    // No DNS lookup occurred (e.g., connecting to an IP address directly)
                    // Set lookup to socket time (no time elapsed for DNS)
                    socket.removeListener('lookup', lookupListener);
                    timings.lookup = timings.socket;
                    timings.phases.dns = 0;
                }
                timings.phases.tcp = timings.connect - timings.lookup;
                // If lookup and connect happen at the EXACT same time (tcp = 0),
                // DNS was served from cache and the dns value is just event loop overhead.
                // Set dns to 0 to indicate no actual DNS resolution occurred.
                // Fixes https://github.com/szmarczak/http-timer/issues/35
                if (timings.phases.tcp === 0 && timings.phases.dns && timings.phases.dns > 0) {
                    timings.phases.dns = 0;
                }
                // Store connection phase timings on socket for potential reuse
                if (!socket.__initial_connection_timings__) {
                    socket.__initial_connection_timings__ = {
                        dnsPhase: timings.phases.dns,
                        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion -- TypeScript can't prove this is defined due to callback structure
                        tcpPhase: timings.phases.tcp
                    };
                }
            },
            secureConnect () {
                timings.secureConnect = Date.now();
                timings.phases.tls = timings.secureConnect - timings.connect;
                // Update stored timings with TLS phase timing
                if (socket.__initial_connection_timings__) {
                    socket.__initial_connection_timings__.tlsPhase = timings.phases.tls;
                }
            }
        });
    };
    if (request.socket) {
        onSocket(request.socket);
    } else {
        request.prependOnceListener('socket', onSocket);
    }
    const onUpload = ()=>{
        timings.upload = Date.now();
        // Calculate request phase if we have connection timings
        const secureOrConnect = timings.secureConnect ?? timings.connect;
        if (secureOrConnect !== undefined) {
            timings.phases.request = timings.upload - secureOrConnect;
        }
    // If both are undefined (HTTP/2), phases.request stays undefined (not NaN)
    };
    if (request.writableFinished) {
        onUpload();
    } else {
        request.prependOnceListener('finish', onUpload);
    }
    request.prependOnceListener('response', (response)=>{
        timings.response = Date.now();
        timings.phases.firstByte = timings.response - timings.upload;
        response.timings = timings;
        handleError(response);
        response.prependOnceListener('end', ()=>{
            request.off('abort', onAbort);
            response.off('aborted', onAbort);
            if (timings.phases.total !== undefined) {
                // Aborted or errored
                return;
            }
            timings.end = Date.now();
            timings.phases.download = timings.end - timings.response;
            timings.phases.total = timings.end - timings.start;
        });
        response.prependOnceListener('aborted', onAbort);
    });
    return timings;
};
const __TURBOPACK__default__export__ = timer;
}),
"[project]/node_modules/got/dist/source/core/utils/is-form-data.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>isFormData
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sindresorhus/is/distribution/index.js [app-ssr] (ecmascript)");
;
function isFormData(body) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].nodeStream(body) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].function(body.getBoundary);
}
}),
"[project]/node_modules/got/dist/source/core/utils/get-body-size.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>getBodySize
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:util [external] (node:util, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sindresorhus/is/distribution/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$is$2d$form$2d$data$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/utils/is-form-data.js [app-ssr] (ecmascript)");
;
;
;
async function getBodySize(body, headers) {
    if (headers && 'content-length' in headers) {
        return Number(headers['content-length']);
    }
    if (!body) {
        return 0;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string(body)) {
        return new TextEncoder().encode(body).byteLength;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].buffer(body)) {
        return body.length;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].typedArray(body)) {
        return body.byteLength;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$is$2d$form$2d$data$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(body)) {
        try {
            return await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["promisify"])(body.getLength.bind(body))();
        } catch (error) {
            const typedError = error;
            throw new Error('Cannot determine content-length for form-data with stream(s) of unknown length. ' + 'This is a limitation of the `form-data` package. ' + 'To fix this, either:\n' + '1. Use the `knownLength` option when appending streams:\n' + '   form.append(\'file\', stream, {knownLength: 12345});\n' + '2. Switch to spec-compliant FormData (formdata-node package)\n' + 'See: https://github.com/form-data/form-data#alternative-submission-methods\n' + `Original error: ${typedError.message}`);
        }
    }
    return undefined;
}
}),
"[project]/node_modules/got/dist/source/core/utils/proxy-events.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>proxyEvents
]);
function proxyEvents(from, to, events) {
    const eventFunctions = {};
    for (const event of events){
        const eventFunction = (...arguments_)=>{
            to.emit(event, ...arguments_);
        };
        eventFunctions[event] = eventFunction;
        from.on(event, eventFunction);
    }
    return ()=>{
        for (const [event, eventFunction] of Object.entries(eventFunctions)){
            from.off(event, eventFunction);
        }
    };
}
}),
"[project]/node_modules/got/dist/source/core/utils/unhandle.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// When attaching listeners, it's very easy to forget about them.
// Especially if you do error handling and set timeouts.
// So instead of checking if it's proper to throw an error on every timeout ever,
// use this simple tool which will remove all listeners you have attached.
__turbopack_context__.s([
    "default",
    ()=>unhandle
]);
function unhandle() {
    const handlers = [];
    return {
        once (origin, event, function_) {
            origin.once(event, function_);
            handlers.push({
                origin,
                event,
                fn: function_
            });
        },
        unhandleAll () {
            for (const handler of handlers){
                const { origin, event, fn } = handler;
                origin.removeListener(event, fn);
            }
            handlers.length = 0;
        }
    };
}
}),
"[project]/node_modules/got/dist/source/core/timed-out.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TimeoutError",
    ()=>TimeoutError,
    "default",
    ()=>timedOut
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$net__$5b$external$5d$__$28$node$3a$net$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:net [external] (node:net, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$unhandle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/utils/unhandle.js [app-ssr] (ecmascript)");
;
;
const reentry = Symbol('reentry');
const noop = ()=>{};
class TimeoutError extends Error {
    event;
    name = 'TimeoutError';
    code = 'ETIMEDOUT';
    constructor(threshold, event){
        super(`Timeout awaiting '${event}' for ${threshold}ms`);
        this.event = event;
    }
}
function timedOut(request, delays, options) {
    if (reentry in request) {
        return noop;
    }
    request[reentry] = true;
    const cancelers = [];
    const { once, unhandleAll } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$unhandle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])();
    const handled = new Map();
    const addTimeout = (delay, callback, event)=>{
        const timeout = setTimeout(callback, delay, delay, event);
        timeout.unref?.();
        const cancel = ()=>{
            handled.set(event, true);
            clearTimeout(timeout);
        };
        cancelers.push(cancel);
        return cancel;
    };
    const { host, hostname } = options;
    const timeoutHandler = (delay, event)=>{
        // Use setTimeout to allow for any cancelled events to be handled first,
        // to prevent firing any TimeoutError unneeded when the event loop is busy or blocked
        setTimeout(()=>{
            if (!handled.has(event)) {
                request.destroy(new TimeoutError(delay, event));
            }
        }, 0);
    };
    const cancelTimeouts = ()=>{
        for (const cancel of cancelers){
            cancel();
        }
        unhandleAll();
    };
    request.once('error', (error)=>{
        cancelTimeouts();
        // Save original behavior
        /* istanbul ignore next */ if (request.listenerCount('error') === 0) {
            throw error;
        }
    });
    if (delays.request !== undefined) {
        const cancelTimeout = addTimeout(delays.request, timeoutHandler, 'request');
        once(request, 'response', (response)=>{
            once(response, 'end', cancelTimeout);
        });
    }
    if (delays.socket !== undefined) {
        const { socket } = delays;
        const socketTimeoutHandler = ()=>{
            timeoutHandler(socket, 'socket');
        };
        request.setTimeout(socket, socketTimeoutHandler);
        // `request.setTimeout(0)` causes a memory leak.
        // We can just remove the listener and forget about the timer - it's unreffed.
        // See https://github.com/sindresorhus/got/issues/690
        cancelers.push(()=>{
            request.removeListener('timeout', socketTimeoutHandler);
        });
    }
    const hasLookup = delays.lookup !== undefined;
    const hasConnect = delays.connect !== undefined;
    const hasSecureConnect = delays.secureConnect !== undefined;
    const hasSend = delays.send !== undefined;
    if (hasLookup || hasConnect || hasSecureConnect || hasSend) {
        once(request, 'socket', (socket)=>{
            const { socketPath } = request;
            /* istanbul ignore next: hard to test */ if (socket.connecting) {
                const hasPath = Boolean(socketPath ?? __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$net__$5b$external$5d$__$28$node$3a$net$2c$__cjs$29$__["default"].isIP(hostname ?? host ?? '') !== 0);
                if (hasLookup && !hasPath && socket.address().address === undefined) {
                    const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');
                    once(socket, 'lookup', cancelTimeout);
                }
                if (hasConnect) {
                    const timeConnect = ()=>addTimeout(delays.connect, timeoutHandler, 'connect');
                    if (hasPath) {
                        once(socket, 'connect', timeConnect());
                    } else {
                        once(socket, 'lookup', (error)=>{
                            if (error === null) {
                                once(socket, 'connect', timeConnect());
                            }
                        });
                    }
                }
                if (hasSecureConnect && options.protocol === 'https:') {
                    once(socket, 'connect', ()=>{
                        const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');
                        once(socket, 'secureConnect', cancelTimeout);
                    });
                }
            }
            if (hasSend) {
                const timeRequest = ()=>addTimeout(delays.send, timeoutHandler, 'send');
                /* istanbul ignore next: hard to test */ if (socket.connecting) {
                    once(socket, 'connect', ()=>{
                        once(request, 'upload-complete', timeRequest());
                    });
                } else {
                    once(request, 'upload-complete', timeRequest());
                }
            }
        });
    }
    if (delays.response !== undefined) {
        once(request, 'upload-complete', ()=>{
            const cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');
            once(request, 'response', cancelTimeout);
        });
    }
    if (delays.read !== undefined) {
        once(request, 'response', (response)=>{
            const cancelTimeout = addTimeout(delays.read, timeoutHandler, 'read');
            once(response, 'end', cancelTimeout);
        });
    }
    return cancelTimeouts;
}
}),
"[project]/node_modules/got/dist/source/core/utils/url-to-options.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>urlToOptions
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sindresorhus/is/distribution/index.js [app-ssr] (ecmascript)");
;
function urlToOptions(url) {
    // Cast to URL
    url = url;
    const options = {
        protocol: url.protocol,
        hostname: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string(url.hostname) && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,
        host: url.host,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        href: url.href,
        path: `${url.pathname || ''}${url.search || ''}`
    };
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string(url.port) && url.port.length > 0) {
        options.port = Number(url.port);
    }
    if (url.username || url.password) {
        options.auth = `${url.username || ''}:${url.password || ''}`;
    }
    return options;
}
}),
"[project]/node_modules/got/dist/source/core/utils/weakable-map.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>WeakableMap
]);
class WeakableMap {
    weakMap = new WeakMap();
    map = new Map();
    set(key, value) {
        if (typeof key === 'object') {
            this.weakMap.set(key, value);
        } else {
            this.map.set(key, value);
        }
    }
    get(key) {
        if (typeof key === 'object') {
            return this.weakMap.get(key);
        }
        return this.map.get(key);
    }
    has(key) {
        if (typeof key === 'object') {
            return this.weakMap.has(key);
        }
        return this.map.has(key);
    }
}
}),
"[project]/node_modules/got/dist/source/core/calculate-retry-delay.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const calculateRetryDelay = ({ attemptCount, retryOptions, error, retryAfter, computedValue })=>{
    if (error.name === 'RetryError') {
        return 1;
    }
    if (attemptCount > retryOptions.limit) {
        return 0;
    }
    const hasMethod = retryOptions.methods.includes(error.options.method);
    const hasErrorCode = retryOptions.errorCodes.includes(error.code);
    const hasStatusCode = error.response && retryOptions.statusCodes.includes(error.response.statusCode);
    if (!hasMethod || !hasErrorCode && !hasStatusCode) {
        return 0;
    }
    if (error.response) {
        if (retryAfter) {
            // In this case `computedValue` is `options.request.timeout`
            if (retryAfter > computedValue) {
                return 0;
            }
            return retryAfter;
        }
        if (error.response.statusCode === 413) {
            return 0;
        }
    }
    const noise = Math.random() * retryOptions.noise;
    return Math.min(2 ** (attemptCount - 1) * 1000, retryOptions.backoffLimit) + noise;
};
const __TURBOPACK__default__export__ = calculateRetryDelay;
}),
"[project]/node_modules/got/dist/source/core/parse-link-header.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>parseLinkHeader
]);
function parseLinkHeader(link) {
    const parsed = [];
    const items = link.split(',');
    for (const item of items){
        // https://tools.ietf.org/html/rfc5988#section-5
        const [rawUriReference, ...rawLinkParameters] = item.split(';');
        const trimmedUriReference = rawUriReference.trim();
        // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
        if (trimmedUriReference[0] !== '<' || trimmedUriReference.at(-1) !== '>') {
            throw new Error(`Invalid format of the Link header reference: ${trimmedUriReference}`);
        }
        const reference = trimmedUriReference.slice(1, -1);
        const parameters = {};
        if (rawLinkParameters.length === 0) {
            throw new Error(`Unexpected end of Link header parameters: ${rawLinkParameters.join(';')}`);
        }
        for (const rawParameter of rawLinkParameters){
            const trimmedRawParameter = rawParameter.trim();
            const center = trimmedRawParameter.indexOf('=');
            if (center === -1) {
                throw new Error(`Failed to parse Link header: ${link}`);
            }
            const name = trimmedRawParameter.slice(0, center).trim();
            const value = trimmedRawParameter.slice(center + 1).trim();
            parameters[name] = value;
        }
        parsed.push({
            reference,
            parameters
        });
    }
    return parsed;
}
}),
"[project]/node_modules/got/dist/source/core/options.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>Options
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:util [external] (node:util, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$tls__$5b$external$5d$__$28$node$3a$tls$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:tls [external] (node:tls, cjs)");
// DO NOT use destructuring for `https.request` and `http.request` as it's not compatible with `nock`.
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$https__$5b$external$5d$__$28$node$3a$https$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:https [external] (node:https, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$http__$5b$external$5d$__$28$node$3a$http$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:http [external] (node:http, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sindresorhus/is/distribution/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lowercase$2d$keys$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lowercase-keys/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cacheable$2d$lookup$2f$source$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cacheable-lookup/source/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$http2$2d$wrapper$2f$source$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/http2-wrapper/source/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$form$2d$data$2d$encoder$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/form-data-encoder/lib/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$parse$2d$link$2d$header$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/parse-link-header.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
const [major, minor] = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].versions.node.split('.').map(Number);
/**
Generic helper that wraps any assertion function to add context to error messages.
*/ function wrapAssertionWithContext(optionName, assertionFn) {
    try {
        assertionFn();
    } catch (error) {
        if (error instanceof Error) {
            error.message = `Option '${optionName}': ${error.message}`;
        }
        throw error;
    }
}
/**
Helper function that wraps assert.any() to provide better error messages.
When assertion fails, it includes the option name in the error message.
*/ function assertAny(optionName, validators, value) {
    wrapAssertionWithContext(optionName, ()=>{
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].any(validators, value);
    });
}
/**
Helper function that wraps assert.plainObject() to provide better error messages.
When assertion fails, it includes the option name in the error message.
*/ function assertPlainObject(optionName, value) {
    wrapAssertionWithContext(optionName, ()=>{
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].plainObject(value);
    });
}
function validateSearchParameters(searchParameters) {
    // eslint-disable-next-line guard-for-in
    for(const key in searchParameters){
        const value = searchParameters[key];
        assertAny(`searchParams.${key}`, [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].number,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].boolean,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].null,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value);
    }
}
const globalCache = new Map();
let globalDnsCache;
const getGlobalDnsCache = ()=>{
    if (globalDnsCache) {
        return globalDnsCache;
    }
    globalDnsCache = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cacheable$2d$lookup$2f$source$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
    return globalDnsCache;
};
// Detects and wraps QuickLRU v7+ instances to make them compatible with the StorageAdapter interface
const wrapQuickLruIfNeeded = (value)=>{
    // Check if this is QuickLRU v7+ using Symbol.toStringTag and the evict method (added in v7)
    if (value?.[Symbol.toStringTag] === 'QuickLRU' && typeof value.evict === 'function') {
        // QuickLRU v7+ uses set(key, value, {maxAge: number}) but StorageAdapter expects set(key, value, ttl)
        // Wrap it to translate the interface
        return {
            get (key) {
                return value.get(key);
            },
            set (key, cacheValue, ttl) {
                if (ttl === undefined) {
                    value.set(key, cacheValue);
                } else {
                    value.set(key, cacheValue, {
                        maxAge: ttl
                    });
                }
                return true;
            },
            delete (key) {
                return value.delete(key);
            },
            clear () {
                return value.clear();
            },
            has (key) {
                return value.has(key);
            }
        };
    }
    // QuickLRU v5 and other caches work as-is
    return value;
};
const defaultInternals = {
    request: undefined,
    agent: {
        http: undefined,
        https: undefined,
        http2: undefined
    },
    h2session: undefined,
    decompress: true,
    timeout: {
        connect: undefined,
        lookup: undefined,
        read: undefined,
        request: undefined,
        response: undefined,
        secureConnect: undefined,
        send: undefined,
        socket: undefined
    },
    prefixUrl: '',
    body: undefined,
    form: undefined,
    json: undefined,
    cookieJar: undefined,
    ignoreInvalidCookies: false,
    searchParams: undefined,
    dnsLookup: undefined,
    dnsCache: undefined,
    context: {},
    hooks: {
        init: [],
        beforeRequest: [],
        beforeError: [],
        beforeRedirect: [],
        beforeRetry: [],
        beforeCache: [],
        afterResponse: []
    },
    followRedirect: true,
    maxRedirects: 10,
    cache: undefined,
    throwHttpErrors: true,
    username: '',
    password: '',
    http2: false,
    allowGetBody: false,
    copyPipedHeaders: true,
    headers: {
        'user-agent': 'got (https://github.com/sindresorhus/got)'
    },
    methodRewriting: false,
    dnsLookupIpVersion: undefined,
    parseJson: JSON.parse,
    stringifyJson: JSON.stringify,
    retry: {
        limit: 2,
        methods: [
            'GET',
            'PUT',
            'HEAD',
            'DELETE',
            'OPTIONS',
            'TRACE'
        ],
        statusCodes: [
            408,
            413,
            429,
            500,
            502,
            503,
            504,
            521,
            522,
            524
        ],
        errorCodes: [
            'ETIMEDOUT',
            'ECONNRESET',
            'EADDRINUSE',
            'ECONNREFUSED',
            'EPIPE',
            'ENOTFOUND',
            'ENETUNREACH',
            'EAI_AGAIN'
        ],
        maxRetryAfter: undefined,
        calculateDelay: ({ computedValue })=>computedValue,
        backoffLimit: Number.POSITIVE_INFINITY,
        noise: 100,
        // TODO: Change default to `true` in the next major version to fix https://github.com/sindresorhus/got/issues/2243
        enforceRetryRules: false
    },
    localAddress: undefined,
    method: 'GET',
    createConnection: undefined,
    cacheOptions: {
        shared: undefined,
        cacheHeuristic: undefined,
        immutableMinTimeToLive: undefined,
        ignoreCargoCult: undefined
    },
    https: {
        alpnProtocols: undefined,
        rejectUnauthorized: undefined,
        checkServerIdentity: undefined,
        serverName: undefined,
        certificateAuthority: undefined,
        key: undefined,
        certificate: undefined,
        passphrase: undefined,
        pfx: undefined,
        ciphers: undefined,
        honorCipherOrder: undefined,
        minVersion: undefined,
        maxVersion: undefined,
        signatureAlgorithms: undefined,
        tlsSessionLifetime: undefined,
        dhparam: undefined,
        ecdhCurve: undefined,
        certificateRevocationLists: undefined,
        secureOptions: undefined
    },
    encoding: undefined,
    resolveBodyOnly: false,
    isStream: false,
    responseType: 'text',
    url: undefined,
    pagination: {
        transform (response) {
            if (response.request.options.responseType === 'json') {
                return response.body;
            }
            return JSON.parse(response.body);
        },
        paginate ({ response }) {
            const rawLinkHeader = response.headers.link;
            if (typeof rawLinkHeader !== 'string' || rawLinkHeader.trim() === '') {
                return false;
            }
            const parsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$parse$2d$link$2d$header$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(rawLinkHeader);
            const next = parsed.find((entry)=>entry.parameters.rel === 'next' || entry.parameters.rel === '"next"');
            if (next) {
                return {
                    url: new URL(next.reference, response.url)
                };
            }
            return false;
        },
        filter: ()=>true,
        shouldContinue: ()=>true,
        countLimit: Number.POSITIVE_INFINITY,
        backoff: 0,
        requestLimit: 10_000,
        stackAllItems: false
    },
    setHost: true,
    maxHeaderSize: undefined,
    signal: undefined,
    enableUnixSockets: false,
    strictContentLength: false
};
const cloneInternals = (internals)=>{
    const { hooks, retry } = internals;
    const result = {
        ...internals,
        context: {
            ...internals.context
        },
        cacheOptions: {
            ...internals.cacheOptions
        },
        https: {
            ...internals.https
        },
        agent: {
            ...internals.agent
        },
        headers: {
            ...internals.headers
        },
        retry: {
            ...retry,
            errorCodes: [
                ...retry.errorCodes
            ],
            methods: [
                ...retry.methods
            ],
            statusCodes: [
                ...retry.statusCodes
            ]
        },
        timeout: {
            ...internals.timeout
        },
        hooks: {
            init: [
                ...hooks.init
            ],
            beforeRequest: [
                ...hooks.beforeRequest
            ],
            beforeError: [
                ...hooks.beforeError
            ],
            beforeRedirect: [
                ...hooks.beforeRedirect
            ],
            beforeRetry: [
                ...hooks.beforeRetry
            ],
            beforeCache: [
                ...hooks.beforeCache
            ],
            afterResponse: [
                ...hooks.afterResponse
            ]
        },
        searchParams: internals.searchParams ? new URLSearchParams(internals.searchParams) : undefined,
        pagination: {
            ...internals.pagination
        }
    };
    return result;
};
const cloneRaw = (raw)=>{
    const { hooks, retry } = raw;
    const result = {
        ...raw
    };
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object(raw.context)) {
        result.context = {
            ...raw.context
        };
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object(raw.cacheOptions)) {
        result.cacheOptions = {
            ...raw.cacheOptions
        };
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object(raw.https)) {
        result.https = {
            ...raw.https
        };
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object(raw.cacheOptions)) {
        result.cacheOptions = {
            ...result.cacheOptions
        };
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object(raw.agent)) {
        result.agent = {
            ...raw.agent
        };
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object(raw.headers)) {
        result.headers = {
            ...raw.headers
        };
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object(retry)) {
        result.retry = {
            ...retry
        };
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].array(retry.errorCodes)) {
            result.retry.errorCodes = [
                ...retry.errorCodes
            ];
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].array(retry.methods)) {
            result.retry.methods = [
                ...retry.methods
            ];
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].array(retry.statusCodes)) {
            result.retry.statusCodes = [
                ...retry.statusCodes
            ];
        }
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object(raw.timeout)) {
        result.timeout = {
            ...raw.timeout
        };
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object(hooks)) {
        result.hooks = {
            ...hooks
        };
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].array(hooks.init)) {
            result.hooks.init = [
                ...hooks.init
            ];
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].array(hooks.beforeRequest)) {
            result.hooks.beforeRequest = [
                ...hooks.beforeRequest
            ];
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].array(hooks.beforeError)) {
            result.hooks.beforeError = [
                ...hooks.beforeError
            ];
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].array(hooks.beforeRedirect)) {
            result.hooks.beforeRedirect = [
                ...hooks.beforeRedirect
            ];
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].array(hooks.beforeRetry)) {
            result.hooks.beforeRetry = [
                ...hooks.beforeRetry
            ];
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].array(hooks.beforeCache)) {
            result.hooks.beforeCache = [
                ...hooks.beforeCache
            ];
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].array(hooks.afterResponse)) {
            result.hooks.afterResponse = [
                ...hooks.afterResponse
            ];
        }
    }
    if (raw.searchParams) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string(raw.searchParams)) {
            result.searchParams = raw.searchParams;
        } else if (raw.searchParams instanceof URLSearchParams) {
            result.searchParams = new URLSearchParams(raw.searchParams);
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object(raw.searchParams)) {
            result.searchParams = {
                ...raw.searchParams
            };
        }
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object(raw.pagination)) {
        result.pagination = {
            ...raw.pagination
        };
    }
    return result;
};
const getHttp2TimeoutOption = (internals)=>{
    const delays = [
        internals.timeout.socket,
        internals.timeout.connect,
        internals.timeout.lookup,
        internals.timeout.request,
        internals.timeout.secureConnect
    ].filter((delay)=>typeof delay === 'number');
    if (delays.length > 0) {
        return Math.min(...delays);
    }
    return undefined;
};
const init = (options, withOptions, self)=>{
    const initHooks = options.hooks?.init;
    if (initHooks) {
        for (const hook of initHooks){
            hook(withOptions, self);
        }
    }
};
class Options {
    _unixOptions;
    _internals;
    _merging = false;
    _init;
    constructor(input, options, defaults){
        assertAny('input', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].urlInstance,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], input);
        assertAny('options', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], options);
        assertAny('defaults', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], defaults);
        if (input instanceof Options || options instanceof Options) {
            throw new TypeError('The defaults must be passed as the third argument');
        }
        this._internals = cloneInternals(defaults?._internals ?? defaults ?? defaultInternals);
        this._init = [
            ...defaults?._init ?? []
        ];
        // This rule allows `finally` to be considered more important.
        // Meaning no matter the error thrown in the `try` block,
        // if `finally` throws then the `finally` error will be thrown.
        //
        // Yes, we want this. If we set `url` first, then the `url.searchParams`
        // would get merged. Instead we set the `searchParams` first, then
        // `url.searchParams` is overwritten as expected.
        //
        /* eslint-disable no-unsafe-finally */ try {
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].plainObject(input)) {
                try {
                    this.merge(input);
                    this.merge(options);
                } finally{
                    this.url = input.url;
                }
            } else {
                try {
                    this.merge(options);
                } finally{
                    if (options?.url !== undefined) {
                        if (input === undefined) {
                            this.url = options.url;
                        } else {
                            throw new TypeError('The `url` option is mutually exclusive with the `input` argument');
                        }
                    } else if (input !== undefined) {
                        this.url = input;
                    }
                }
            }
        } catch (error) {
            error.options = this;
            throw error;
        }
    /* eslint-enable no-unsafe-finally */ }
    merge(options) {
        if (!options) {
            return;
        }
        if (options instanceof Options) {
            // Create a copy of the _init array to avoid infinite loop
            // when merging an Options instance with itself
            const initArray = [
                ...options._init
            ];
            for (const init of initArray){
                this.merge(init);
            }
            return;
        }
        options = cloneRaw(options);
        init(this, options, this);
        init(options, options, this);
        this._merging = true;
        // Always merge `isStream` first
        if ('isStream' in options) {
            this.isStream = options.isStream;
        }
        try {
            let push = false;
            for(const key in options){
                // `got.extend()` options
                if (key === 'mutableDefaults' || key === 'handlers') {
                    continue;
                }
                // Never merge `url`
                if (key === 'url') {
                    continue;
                }
                // Never merge `preserveHooks` - it's a control flag, not a persistent option
                if (key === 'preserveHooks') {
                    continue;
                }
                if (!(key in this)) {
                    throw new Error(`Unexpected option: ${key}`);
                }
                // @ts-expect-error Type 'unknown' is not assignable to type 'never'.
                const value = options[key];
                if (value === undefined) {
                    continue;
                }
                // @ts-expect-error Type 'unknown' is not assignable to type 'never'.
                this[key] = value;
                push = true;
            }
            if (push) {
                this._init.push(options);
            }
        } finally{
            this._merging = false;
        }
    }
    /**
    Custom request function.
    The main purpose of this is to [support HTTP2 using a wrapper](https://github.com/szmarczak/http2-wrapper).

    @default http.request | https.request
    */ get request() {
        return this._internals.request;
    }
    set request(value) {
        assertAny('request', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].function,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value);
        this._internals.request = value;
    }
    /**
    An object representing `http`, `https` and `http2` keys for [`http.Agent`](https://nodejs.org/api/http.html#http_class_http_agent), [`https.Agent`](https://nodejs.org/api/https.html#https_class_https_agent) and [`http2wrapper.Agent`](https://github.com/szmarczak/http2-wrapper#new-http2agentoptions) instance.
    This is necessary because a request to one protocol might redirect to another.
    In such a scenario, Got will switch over to the right protocol agent for you.

    If a key is not present, it will default to a global agent.

    @example
    ```
    import got from 'got';
    import HttpAgent from 'agentkeepalive';

    const {HttpsAgent} = HttpAgent;

    await got('https://sindresorhus.com', {
        agent: {
            http: new HttpAgent(),
            https: new HttpsAgent()
        }
    });
    ```
    */ get agent() {
        return this._internals.agent;
    }
    set agent(value) {
        assertPlainObject('agent', value);
        // eslint-disable-next-line guard-for-in
        for(const key in value){
            if (!(key in this._internals.agent)) {
                throw new TypeError(`Unexpected agent option: ${key}`);
            }
            // @ts-expect-error - No idea why `value[key]` doesn't work here.
            assertAny(`agent.${key}`, [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined,
                (v)=>v === false
            ], value[key]);
        }
        if (this._merging) {
            Object.assign(this._internals.agent, value);
        } else {
            this._internals.agent = {
                ...value
            };
        }
    }
    get h2session() {
        return this._internals.h2session;
    }
    set h2session(value) {
        this._internals.h2session = value;
    }
    /**
    Decompress the response automatically.

    This will set the `accept-encoding` header to `gzip, deflate, br` unless you set it yourself.

    If this is disabled, a compressed response is returned as a `Buffer`.
    This may be useful if you want to handle decompression yourself or stream the raw compressed data.

    @default true
    */ get decompress() {
        return this._internals.decompress;
    }
    set decompress(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].boolean(value);
        this._internals.decompress = value;
    }
    /**
    Milliseconds to wait for the server to end the response before aborting the request with `got.TimeoutError` error (a.k.a. `request` property).
    By default, there's no timeout.

    This also accepts an `object` with the following fields to constrain the duration of each phase of the request lifecycle:

    - `lookup` starts when a socket is assigned and ends when the hostname has been resolved.
        Does not apply when using a Unix domain socket.
    - `connect` starts when `lookup` completes (or when the socket is assigned if lookup does not apply to the request) and ends when the socket is connected.
    - `secureConnect` starts when `connect` completes and ends when the handshaking process completes (HTTPS only).
    - `socket` starts when the socket is connected. See [request.setTimeout](https://nodejs.org/api/http.html#http_request_settimeout_timeout_callback).
    - `response` starts when the request has been written to the socket and ends when the response headers are received.
    - `send` starts when the socket is connected and ends with the request has been written to the socket.
    - `request` starts when the request is initiated and ends when the response's end event fires.
    */ get timeout() {
        // We always return `Delays` here.
        // It has to be `Delays | number`, otherwise TypeScript will error because the getter and the setter have incompatible types.
        return this._internals.timeout;
    }
    set timeout(value) {
        assertPlainObject('timeout', value);
        // eslint-disable-next-line guard-for-in
        for(const key in value){
            if (!(key in this._internals.timeout)) {
                throw new Error(`Unexpected timeout option: ${key}`);
            }
            // @ts-expect-error - No idea why `value[key]` doesn't work here.
            assertAny(`timeout.${key}`, [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].number,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
            ], value[key]);
        }
        if (this._merging) {
            Object.assign(this._internals.timeout, value);
        } else {
            this._internals.timeout = {
                ...value
            };
        }
    }
    /**
    When specified, `prefixUrl` will be prepended to `url`.
    The prefix can be any valid URL, either relative or absolute.
    A trailing slash `/` is optional - one will be added automatically.

    __Note__: `prefixUrl` will be ignored if the `url` argument is a URL instance.

    __Note__: Leading slashes in `input` are disallowed when using this option to enforce consistency and avoid confusion.
    For example, when the prefix URL is `https://example.com/foo` and the input is `/bar`, there's ambiguity whether the resulting URL would become `https://example.com/foo/bar` or `https://example.com/bar`.
    The latter is used by browsers.

    __Tip__: Useful when used with `got.extend()` to create niche-specific Got instances.

    __Tip__: You can change `prefixUrl` using hooks as long as the URL still includes the `prefixUrl`.
    If the URL doesn't include it anymore, it will throw.

    @example
    ```
    import got from 'got';

    await got('unicorn', {prefixUrl: 'https://cats.com'});
    //=> 'https://cats.com/unicorn'

    const instance = got.extend({
        prefixUrl: 'https://google.com'
    });

    await instance('unicorn', {
        hooks: {
            beforeRequest: [
                options => {
                    options.prefixUrl = 'https://cats.com';
                }
            ]
        }
    });
    //=> 'https://cats.com/unicorn'
    ```
    */ get prefixUrl() {
        // We always return `string` here.
        // It has to be `string | URL`, otherwise TypeScript will error because the getter and the setter have incompatible types.
        return this._internals.prefixUrl;
    }
    set prefixUrl(value) {
        assertAny('prefixUrl', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].urlInstance
        ], value);
        if (value === '') {
            this._internals.prefixUrl = '';
            return;
        }
        value = value.toString();
        if (!value.endsWith('/')) {
            value += '/';
        }
        if (this._internals.prefixUrl && this._internals.url) {
            const { href } = this._internals.url;
            this._internals.url.href = value + href.slice(this._internals.prefixUrl.length);
        }
        this._internals.prefixUrl = value;
    }
    /**
    __Note #1__: The `body` option cannot be used with the `json` or `form` option.

    __Note #2__: If you provide this option, `got.stream()` will be read-only.

    __Note #3__: If you provide a payload with the `GET` or `HEAD` method, it will throw a `TypeError` unless the method is `GET` and the `allowGetBody` option is set to `true`.

    __Note #4__: This option is not enumerable and will not be merged with the instance defaults.

    The `content-length` header will be automatically set if `body` is a `string` / `Buffer` / typed array ([`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array), etc.) / [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) / [`form-data` instance](https://github.com/form-data/form-data), and `content-length` and `transfer-encoding` are not manually set in `options.headers`.

    Since Got 12, the `content-length` is not automatically set when `body` is a `fs.createReadStream`.

    You can use `Iterable` and `AsyncIterable` objects as request body, including Web [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream):

    @example
    ```
    import got from 'got';

    // Using an async generator
    async function* generateData() {
        yield 'Hello, ';
        yield 'world!';
    }

    await got.post('https://httpbin.org/anything', {
        body: generateData()
    });
    ```
    */ get body() {
        return this._internals.body;
    }
    set body(value) {
        assertAny('body', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].buffer,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].nodeStream,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].generator,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].asyncGenerator,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].iterable,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].asyncIterable,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$form$2d$data$2d$encoder$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFormData"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].typedArray,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value);
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].nodeStream(value)) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].truthy(value.readable);
        }
        if (value !== undefined) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].undefined(this._internals.form);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].undefined(this._internals.json);
        }
        this._internals.body = value;
    }
    /**
    The form body is converted to a query string using [`(new URLSearchParams(object)).toString()`](https://nodejs.org/api/url.html#url_constructor_new_urlsearchparams_obj).

    If the `Content-Type` header is not present, it will be set to `application/x-www-form-urlencoded`.

    __Note #1__: If you provide this option, `got.stream()` will be read-only.

    __Note #2__: This option is not enumerable and will not be merged with the instance defaults.
    */ get form() {
        return this._internals.form;
    }
    set form(value) {
        assertAny('form', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].plainObject,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value);
        if (value !== undefined) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].undefined(this._internals.body);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].undefined(this._internals.json);
        }
        this._internals.form = value;
    }
    /**
    JSON request body. If the `content-type` header is not set, it will be set to `application/json`.

    __Important__: This option only affects the request body you send to the server. To parse the response as JSON, you must either call `.json()` on the promise or set `responseType: 'json'` in the options.

    __Note #1__: If you provide this option, `got.stream()` will be read-only.

    __Note #2__: This option is not enumerable and will not be merged with the instance defaults.
    */ get json() {
        return this._internals.json;
    }
    set json(value) {
        if (value !== undefined) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].undefined(this._internals.body);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].undefined(this._internals.form);
        }
        this._internals.json = value;
    }
    /**
    The URL to request, as a string, a [`https.request` options object](https://nodejs.org/api/https.html#https_https_request_options_callback), or a [WHATWG `URL`](https://nodejs.org/api/url.html#url_class_url).

    Properties from `options` will override properties in the parsed `url`.

    If no protocol is specified, it will throw a `TypeError`.

    __Note__: The query string is **not** parsed as search params.

    @example
    ```
    await got('https://example.com/?query=a b'); //=> https://example.com/?query=a%20b
    await got('https://example.com/', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b

    // The query string is overridden by `searchParams`
    await got('https://example.com/?query=a b', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b
    ```
    */ get url() {
        return this._internals.url;
    }
    set url(value) {
        assertAny('url', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].urlInstance,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value);
        if (value === undefined) {
            this._internals.url = undefined;
            return;
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string(value) && value.startsWith('/')) {
            throw new Error('`url` must not start with a slash');
        }
        // Detect if URL is already absolute (has a protocol/scheme)
        const valueString = value.toString();
        const isAbsolute = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].urlInstance(value) || /^[a-z][a-z\d+.-]*:\/\//i.test(valueString);
        // Only concatenate prefixUrl if the URL is relative
        const urlString = isAbsolute ? valueString : `${this.prefixUrl}${valueString}`;
        const url = new URL(urlString);
        this._internals.url = url;
        if (url.protocol === 'unix:') {
            url.href = `http://unix${url.pathname}${url.search}`;
        }
        if (url.protocol !== 'http:' && url.protocol !== 'https:') {
            const error = new Error(`Unsupported protocol: ${url.protocol}`);
            error.code = 'ERR_UNSUPPORTED_PROTOCOL';
            throw error;
        }
        if (this._internals.username) {
            url.username = this._internals.username;
            this._internals.username = '';
        }
        if (this._internals.password) {
            url.password = this._internals.password;
            this._internals.password = '';
        }
        if (this._internals.searchParams) {
            url.search = this._internals.searchParams.toString();
            this._internals.searchParams = undefined;
        }
        if (url.hostname === 'unix') {
            if (!this._internals.enableUnixSockets) {
                throw new Error('Using UNIX domain sockets but option `enableUnixSockets` is not enabled');
            }
            const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url.pathname}${url.search}`);
            if (matches?.groups) {
                const { socketPath, path } = matches.groups;
                this._unixOptions = {
                    socketPath,
                    path,
                    host: ''
                };
            } else {
                this._unixOptions = undefined;
            }
            return;
        }
        this._unixOptions = undefined;
    }
    /**
    Cookie support. You don't have to care about parsing or how to store them.

    __Note__: If you provide this option, `options.headers.cookie` will be overridden.
    */ get cookieJar() {
        return this._internals.cookieJar;
    }
    set cookieJar(value) {
        assertAny('cookieJar', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value);
        if (value === undefined) {
            this._internals.cookieJar = undefined;
            return;
        }
        let { setCookie, getCookieString } = value;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].function(setCookie);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].function(getCookieString);
        /* istanbul ignore next: Horrible `tough-cookie` v3 check */ if (setCookie.length === 4 && getCookieString.length === 0) {
            setCookie = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["promisify"])(setCookie.bind(value));
            getCookieString = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["promisify"])(getCookieString.bind(value));
            this._internals.cookieJar = {
                setCookie,
                getCookieString: getCookieString
            };
        } else {
            this._internals.cookieJar = value;
        }
    }
    /**
    You can abort the `request` using [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController).

    @example
    ```
    import got from 'got';

    const abortController = new AbortController();

    const request = got('https://httpbin.org/anything', {
        signal: abortController.signal
    });

    setTimeout(() => {
        abortController.abort();
    }, 100);
    ```
    */ get signal() {
        return this._internals.signal;
    }
    set signal(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].object(value);
        this._internals.signal = value;
    }
    /**
    Ignore invalid cookies instead of throwing an error.
    Only useful when the `cookieJar` option has been set. Not recommended.

    @default false
    */ get ignoreInvalidCookies() {
        return this._internals.ignoreInvalidCookies;
    }
    set ignoreInvalidCookies(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].boolean(value);
        this._internals.ignoreInvalidCookies = value;
    }
    /**
    Query string that will be added to the request URL.
    This will override the query string in `url`.

    If you need to pass in an array, you can do it using a `URLSearchParams` instance.

    @example
    ```
    import got from 'got';

    const searchParams = new URLSearchParams([['key', 'a'], ['key', 'b']]);

    await got('https://example.com', {searchParams});

    console.log(searchParams.toString());
    //=> 'key=a&key=b'
    ```
    */ get searchParams() {
        if (this._internals.url) {
            return this._internals.url.searchParams;
        }
        if (this._internals.searchParams === undefined) {
            this._internals.searchParams = new URLSearchParams();
        }
        return this._internals.searchParams;
    }
    set searchParams(value) {
        assertAny('searchParams', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value);
        const url = this._internals.url;
        if (value === undefined) {
            this._internals.searchParams = undefined;
            if (url) {
                url.search = '';
            }
            return;
        }
        const searchParameters = this.searchParams;
        let updated;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string(value)) {
            updated = new URLSearchParams(value);
        } else if (value instanceof URLSearchParams) {
            updated = value;
        } else {
            validateSearchParameters(value);
            updated = new URLSearchParams();
            // eslint-disable-next-line guard-for-in
            for(const key in value){
                const entry = value[key];
                if (entry === null) {
                    updated.append(key, '');
                } else if (entry === undefined) {
                    searchParameters.delete(key);
                } else {
                    updated.append(key, entry);
                }
            }
        }
        if (this._merging) {
            // These keys will be replaced
            for (const key of updated.keys()){
                searchParameters.delete(key);
            }
            for (const [key, value] of updated){
                searchParameters.append(key, value);
            }
        } else if (url) {
            url.search = searchParameters.toString();
        } else {
            this._internals.searchParams = searchParameters;
        }
    }
    get searchParameters() {
        throw new Error('The `searchParameters` option does not exist. Use `searchParams` instead.');
    }
    set searchParameters(_value) {
        throw new Error('The `searchParameters` option does not exist. Use `searchParams` instead.');
    }
    get dnsLookup() {
        return this._internals.dnsLookup;
    }
    set dnsLookup(value) {
        assertAny('dnsLookup', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].function,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value);
        this._internals.dnsLookup = value;
    }
    /**
    An instance of [`CacheableLookup`](https://github.com/szmarczak/cacheable-lookup) used for making DNS lookups.
    Useful when making lots of requests to different *public* hostnames.

    `CacheableLookup` uses `dns.resolver4(..)` and `dns.resolver6(...)` under the hood and fall backs to `dns.lookup(...)` when the first two fail, which may lead to additional delay.

    __Note__: This should stay disabled when making requests to internal hostnames such as `localhost`, `database.local` etc.

    @default false
    */ get dnsCache() {
        return this._internals.dnsCache;
    }
    set dnsCache(value) {
        assertAny('dnsCache', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].boolean,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value);
        if (value === true) {
            this._internals.dnsCache = getGlobalDnsCache();
        } else if (value === false) {
            this._internals.dnsCache = undefined;
        } else {
            this._internals.dnsCache = value;
        }
    }
    /**
    User data. `context` is shallow merged and enumerable. If it contains non-enumerable properties they will NOT be merged.

    @example
    ```
    import got from 'got';

    const instance = got.extend({
        hooks: {
            beforeRequest: [
                options => {
                    if (!options.context || !options.context.token) {
                        throw new Error('Token required');
                    }

                    options.headers.token = options.context.token;
                }
            ]
        }
    });

    const context = {
        token: 'secret'
    };

    const response = await instance('https://httpbin.org/headers', {context});

    // Let's see the headers
    console.log(response.body);
    ```
    */ get context() {
        return this._internals.context;
    }
    set context(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].object(value);
        if (this._merging) {
            Object.assign(this._internals.context, value);
        } else {
            this._internals.context = {
                ...value
            };
        }
    }
    /**
    Hooks allow modifications during the request lifecycle.
    Hook functions may be async and are run serially.
    */ get hooks() {
        return this._internals.hooks;
    }
    set hooks(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].object(value);
        // eslint-disable-next-line guard-for-in
        for(const knownHookEvent in value){
            if (!(knownHookEvent in this._internals.hooks)) {
                throw new Error(`Unexpected hook event: ${knownHookEvent}`);
            }
            const typedKnownHookEvent = knownHookEvent;
            const hooks = value[typedKnownHookEvent];
            assertAny(`hooks.${knownHookEvent}`, [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].array,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
            ], hooks);
            if (hooks) {
                for (const hook of hooks){
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].function(hook);
                }
            }
            if (this._merging) {
                if (hooks) {
                    // @ts-expect-error FIXME
                    this._internals.hooks[typedKnownHookEvent].push(...hooks);
                }
            } else {
                if (!hooks) {
                    throw new Error(`Missing hook event: ${knownHookEvent}`);
                }
                // @ts-expect-error FIXME
                this._internals.hooks[knownHookEvent] = [
                    ...hooks
                ];
            }
        }
    }
    /**
    Whether redirect responses should be followed automatically.

    Optionally, pass a function to dynamically decide based on the response object.

    Note that if a `303` is sent by the server in response to any request type (`POST`, `DELETE`, etc.), Got will automatically request the resource pointed to in the location header via `GET`.
    This is in accordance with [the spec](https://tools.ietf.org/html/rfc7231#section-6.4.4). You can optionally turn on this behavior also for other redirect codes - see `methodRewriting`.

    @default true
    */ get followRedirect() {
        return this._internals.followRedirect;
    }
    set followRedirect(value) {
        assertAny('followRedirect', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].boolean,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].function
        ], value);
        this._internals.followRedirect = value;
    }
    get followRedirects() {
        throw new TypeError('The `followRedirects` option does not exist. Use `followRedirect` instead.');
    }
    set followRedirects(_value) {
        throw new TypeError('The `followRedirects` option does not exist. Use `followRedirect` instead.');
    }
    /**
    If exceeded, the request will be aborted and a `MaxRedirectsError` will be thrown.

    @default 10
    */ get maxRedirects() {
        return this._internals.maxRedirects;
    }
    set maxRedirects(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].number(value);
        this._internals.maxRedirects = value;
    }
    /**
    A cache adapter instance for storing cached response data.

    @default false
    */ get cache() {
        return this._internals.cache;
    }
    set cache(value) {
        assertAny('cache', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].boolean,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value);
        if (value === true) {
            this._internals.cache = globalCache;
        } else if (value === false) {
            this._internals.cache = undefined;
        } else {
            this._internals.cache = wrapQuickLruIfNeeded(value);
        }
    }
    /**
    Determines if a `got.HTTPError` is thrown for unsuccessful responses.

    If this is disabled, requests that encounter an error status code will be resolved with the `response` instead of throwing.
    This may be useful if you are checking for resource availability and are expecting error responses.

    @default true
    */ get throwHttpErrors() {
        return this._internals.throwHttpErrors;
    }
    set throwHttpErrors(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].boolean(value);
        this._internals.throwHttpErrors = value;
    }
    get username() {
        const url = this._internals.url;
        const value = url ? url.username : this._internals.username;
        return decodeURIComponent(value);
    }
    set username(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].string(value);
        const url = this._internals.url;
        const fixedValue = encodeURIComponent(value);
        if (url) {
            url.username = fixedValue;
        } else {
            this._internals.username = fixedValue;
        }
    }
    get password() {
        const url = this._internals.url;
        const value = url ? url.password : this._internals.password;
        return decodeURIComponent(value);
    }
    set password(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].string(value);
        const url = this._internals.url;
        const fixedValue = encodeURIComponent(value);
        if (url) {
            url.password = fixedValue;
        } else {
            this._internals.password = fixedValue;
        }
    }
    /**
    If set to `true`, Got will additionally accept HTTP2 requests.

    It will choose either HTTP/1.1 or HTTP/2 depending on the ALPN protocol.

    __Note__: This option requires Node.js 15.10.0 or newer as HTTP/2 support on older Node.js versions is very buggy.

    __Note__: Overriding `options.request` will disable HTTP2 support.

    @default false

    @example
    ```
    import got from 'got';

    const {headers} = await got('https://nghttp2.org/httpbin/anything', {http2: true});

    console.log(headers.via);
    //=> '2 nghttpx'
    ```
    */ get http2() {
        return this._internals.http2;
    }
    set http2(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].boolean(value);
        this._internals.http2 = value;
    }
    /**
    Set this to `true` to allow sending body for the `GET` method.
    However, the [HTTP/2 specification](https://tools.ietf.org/html/rfc7540#section-8.1.3) says that `An HTTP GET request includes request header fields and no payload body`, therefore when using the HTTP/2 protocol this option will have no effect.
    This option is only meant to interact with non-compliant servers when you have no other choice.

    __Note__: The [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.1) doesn't specify any particular behavior for the GET method having a payload, therefore __it's considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern)__.

    @default false
    */ get allowGetBody() {
        return this._internals.allowGetBody;
    }
    set allowGetBody(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].boolean(value);
        this._internals.allowGetBody = value;
    }
    /**
    Automatically copy headers from piped streams.

    When piping a request into a Got stream (e.g., `request.pipe(got.stream(url))`), this controls whether headers from the source stream are automatically merged into the Got request headers.

    Note: Piped headers overwrite any explicitly set headers with the same name. To override this, either set `copyPipedHeaders` to `false` and manually copy safe headers, or use a `beforeRequest` hook to force specific header values after piping.

    Useful for proxy scenarios, but you may want to disable this to filter out headers like `Host`, `Connection`, `Authorization`, etc.

    @default true

    @example
    ```
    import got from 'got';
    import {pipeline} from 'node:stream/promises';

    // Disable automatic header copying and manually copy only safe headers
    server.get('/proxy', async (request, response) => {
        const gotStream = got.stream('https://example.com', {
            copyPipedHeaders: false,
            headers: {
                'user-agent': request.headers['user-agent'],
                'accept': request.headers['accept'],
                // Explicitly NOT copying host, connection, authorization, etc.
            }
        });

        await pipeline(request, gotStream, response);
    });
    ```

    @example
    ```
    import got from 'got';

    // Override piped headers using beforeRequest hook
    const gotStream = got.stream('https://example.com', {
        hooks: {
            beforeRequest: [
                options => {
                    // Force specific header values after piping
                    options.headers.host = 'example.com';
                    delete options.headers.authorization;
                }
            ]
        }
    });
    ```
    */ get copyPipedHeaders() {
        return this._internals.copyPipedHeaders;
    }
    set copyPipedHeaders(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].boolean(value);
        this._internals.copyPipedHeaders = value;
    }
    /**
    Request headers.

    Existing headers will be overwritten. Headers set to `undefined` will be omitted.

    @default {}
    */ get headers() {
        return this._internals.headers;
    }
    set headers(value) {
        assertPlainObject('headers', value);
        if (this._merging) {
            Object.assign(this._internals.headers, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lowercase$2d$keys$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(value));
        } else {
            this._internals.headers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lowercase$2d$keys$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(value);
        }
    }
    /**
    Specifies if the HTTP request method should be [rewritten as `GET`](https://tools.ietf.org/html/rfc7231#section-6.4) on redirects.

    As the [specification](https://tools.ietf.org/html/rfc7231#section-6.4) prefers to rewrite the HTTP method only on `303` responses, this is Got's default behavior.
    Setting `methodRewriting` to `true` will also rewrite `301` and `302` responses, as allowed by the spec. This is the behavior followed by `curl` and browsers.

    __Note__: Got never performs method rewriting on `307` and `308` responses, as this is [explicitly prohibited by the specification](https://www.rfc-editor.org/rfc/rfc7231#section-6.4.7).

    @default false
    */ get methodRewriting() {
        return this._internals.methodRewriting;
    }
    set methodRewriting(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].boolean(value);
        this._internals.methodRewriting = value;
    }
    /**
    Indicates which DNS record family to use.

    Values:
    - `undefined`: IPv4 (if present) or IPv6
    - `4`: Only IPv4
    - `6`: Only IPv6

    @default undefined
    */ get dnsLookupIpVersion() {
        return this._internals.dnsLookupIpVersion;
    }
    set dnsLookupIpVersion(value) {
        if (value !== undefined && value !== 4 && value !== 6) {
            throw new TypeError(`Invalid DNS lookup IP version: ${value}`);
        }
        this._internals.dnsLookupIpVersion = value;
    }
    /**
    A function used to parse JSON responses.

    @example
    ```
    import got from 'got';
    import Bourne from '@hapi/bourne';

    const parsed = await got('https://example.com', {
        parseJson: text => Bourne.parse(text)
    }).json();

    console.log(parsed);
    ```
    */ get parseJson() {
        return this._internals.parseJson;
    }
    set parseJson(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].function(value);
        this._internals.parseJson = value;
    }
    /**
    A function used to stringify the body of JSON requests.

    @example
    ```
    import got from 'got';

    await got.post('https://example.com', {
        stringifyJson: object => JSON.stringify(object, (key, value) => {
            if (key.startsWith('_')) {
                return;
            }

            return value;
        }),
        json: {
            some: 'payload',
            _ignoreMe: 1234
        }
    });
    ```

    @example
    ```
    import got from 'got';

    await got.post('https://example.com', {
        stringifyJson: object => JSON.stringify(object, (key, value) => {
            if (typeof value === 'number') {
                return value.toString();
            }

            return value;
        }),
        json: {
            some: 'payload',
            number: 1
        }
    });
    ```
    */ get stringifyJson() {
        return this._internals.stringifyJson;
    }
    set stringifyJson(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].function(value);
        this._internals.stringifyJson = value;
    }
    /**
    An object representing `limit`, `calculateDelay`, `methods`, `statusCodes`, `maxRetryAfter` and `errorCodes` fields for maximum retry count, retry handler, allowed methods, allowed status codes, maximum [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) time and allowed error codes.

    Delays between retries counts with function `1000 * Math.pow(2, retry) + Math.random() * 100`, where `retry` is attempt number (starts from 1).

    The `calculateDelay` property is a `function` that receives an object with `attemptCount`, `retryOptions`, `error` and `computedValue` properties for current retry count, the retry options, error and default computed value.
    The function must return a delay in milliseconds (or a Promise resolving with it) (`0` return value cancels retry).

    The `enforceRetryRules` property is a `boolean` that, when set to `true`, enforces the `limit`, `methods`, `statusCodes`, and `errorCodes` options before calling `calculateDelay`. Your `calculateDelay` function is only invoked when a retry is allowed based on these criteria. When `false` (default), `calculateDelay` receives the computed value but can override all retry logic.

    __Note:__ When `enforceRetryRules` is `false`, you must check `computedValue` in your `calculateDelay` function to respect the default retry logic. When `true`, the retry rules are enforced automatically.

    By default, it retries *only* on the specified methods, status codes, and on these network errors:

    - `ETIMEDOUT`: One of the [timeout](#timeout) limits were reached.
    - `ECONNRESET`: Connection was forcibly closed by a peer.
    - `EADDRINUSE`: Could not bind to any free port.
    - `ECONNREFUSED`: Connection was refused by the server.
    - `EPIPE`: The remote side of the stream being written has been closed.
    - `ENOTFOUND`: Couldn't resolve the hostname to an IP address.
    - `ENETUNREACH`: No internet connection.
    - `EAI_AGAIN`: DNS lookup timed out.

    __Note__: If `maxRetryAfter` is set to `undefined`, it will use `options.timeout`.
    __Note__: If [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) header is greater than `maxRetryAfter`, it will cancel the request.
    */ get retry() {
        return this._internals.retry;
    }
    set retry(value) {
        assertPlainObject('retry', value);
        assertAny('retry.calculateDelay', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].function,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.calculateDelay);
        assertAny('retry.maxRetryAfter', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].number,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.maxRetryAfter);
        assertAny('retry.limit', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].number,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.limit);
        assertAny('retry.methods', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].array,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.methods);
        assertAny('retry.statusCodes', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].array,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.statusCodes);
        assertAny('retry.errorCodes', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].array,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.errorCodes);
        assertAny('retry.noise', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].number,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.noise);
        assertAny('retry.enforceRetryRules', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].boolean,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.enforceRetryRules);
        if (value.noise && Math.abs(value.noise) > 100) {
            throw new Error(`The maximum acceptable retry noise is +/- 100ms, got ${value.noise}`);
        }
        for(const key in value){
            if (!(key in this._internals.retry)) {
                throw new Error(`Unexpected retry option: ${key}`);
            }
        }
        if (this._merging) {
            Object.assign(this._internals.retry, value);
        } else {
            this._internals.retry = {
                ...value
            };
        }
        const { retry } = this._internals;
        retry.methods = [
            ...new Set(retry.methods.map((method)=>method.toUpperCase()))
        ];
        retry.statusCodes = [
            ...new Set(retry.statusCodes)
        ];
        retry.errorCodes = [
            ...new Set(retry.errorCodes)
        ];
    }
    /**
    From `http.RequestOptions`.

    The IP address used to send the request from.
    */ get localAddress() {
        return this._internals.localAddress;
    }
    set localAddress(value) {
        assertAny('localAddress', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value);
        this._internals.localAddress = value;
    }
    /**
    The HTTP method used to make the request.

    @default 'GET'
    */ get method() {
        return this._internals.method;
    }
    set method(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].string(value);
        this._internals.method = value.toUpperCase();
    }
    get createConnection() {
        return this._internals.createConnection;
    }
    set createConnection(value) {
        assertAny('createConnection', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].function,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value);
        this._internals.createConnection = value;
    }
    /**
    From `http-cache-semantics`

    @default {}
    */ get cacheOptions() {
        return this._internals.cacheOptions;
    }
    set cacheOptions(value) {
        assertPlainObject('cacheOptions', value);
        assertAny('cacheOptions.shared', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].boolean,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.shared);
        assertAny('cacheOptions.cacheHeuristic', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].number,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.cacheHeuristic);
        assertAny('cacheOptions.immutableMinTimeToLive', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].number,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.immutableMinTimeToLive);
        assertAny('cacheOptions.ignoreCargoCult', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].boolean,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.ignoreCargoCult);
        for(const key in value){
            if (!(key in this._internals.cacheOptions)) {
                throw new Error(`Cache option \`${key}\` does not exist`);
            }
        }
        if (this._merging) {
            Object.assign(this._internals.cacheOptions, value);
        } else {
            this._internals.cacheOptions = {
                ...value
            };
        }
    }
    /**
    Options for the advanced HTTPS API.
    */ get https() {
        return this._internals.https;
    }
    set https(value) {
        assertPlainObject('https', value);
        assertAny('https.rejectUnauthorized', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].boolean,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.rejectUnauthorized);
        assertAny('https.checkServerIdentity', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].function,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.checkServerIdentity);
        assertAny('https.serverName', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.serverName);
        assertAny('https.certificateAuthority', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].array,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.certificateAuthority);
        assertAny('https.key', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].array,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.key);
        assertAny('https.certificate', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].array,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.certificate);
        assertAny('https.passphrase', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.passphrase);
        assertAny('https.pfx', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].buffer,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].array,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.pfx);
        assertAny('https.alpnProtocols', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].array,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.alpnProtocols);
        assertAny('https.ciphers', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.ciphers);
        assertAny('https.dhparam', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].buffer,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.dhparam);
        assertAny('https.signatureAlgorithms', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.signatureAlgorithms);
        assertAny('https.minVersion', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.minVersion);
        assertAny('https.maxVersion', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.maxVersion);
        assertAny('https.honorCipherOrder', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].boolean,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.honorCipherOrder);
        assertAny('https.tlsSessionLifetime', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].number,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.tlsSessionLifetime);
        assertAny('https.ecdhCurve', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.ecdhCurve);
        assertAny('https.certificateRevocationLists', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].buffer,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].array,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.certificateRevocationLists);
        assertAny('https.secureOptions', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].number,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value.secureOptions);
        for(const key in value){
            if (!(key in this._internals.https)) {
                throw new Error(`HTTPS option \`${key}\` does not exist`);
            }
        }
        if (this._merging) {
            Object.assign(this._internals.https, value);
        } else {
            this._internals.https = {
                ...value
            };
        }
    }
    /**
    [Encoding](https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings) to be used on `setEncoding` of the response data.

    To get a [`Buffer`](https://nodejs.org/api/buffer.html), you need to set `responseType` to `buffer` instead.
    Don't set this option to `null`.

    __Note__: This doesn't affect streams! Instead, you need to do `got.stream(...).setEncoding(encoding)`.

    @default 'utf-8'
    */ get encoding() {
        return this._internals.encoding;
    }
    set encoding(value) {
        if (value === null) {
            throw new TypeError('To get a Buffer, set `options.responseType` to `buffer` instead');
        }
        assertAny('encoding', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value);
        this._internals.encoding = value;
    }
    /**
    When set to `true` the promise will return the Response body instead of the Response object.

    @default false
    */ get resolveBodyOnly() {
        return this._internals.resolveBodyOnly;
    }
    set resolveBodyOnly(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].boolean(value);
        this._internals.resolveBodyOnly = value;
    }
    /**
    Returns a `Stream` instead of a `Promise`.
    This is equivalent to calling `got.stream(url, options?)`.

    @default false
    */ get isStream() {
        return this._internals.isStream;
    }
    set isStream(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].boolean(value);
        this._internals.isStream = value;
    }
    /**
    The parsing method.

    The promise also has `.text()`, `.json()` and `.buffer()` methods which return another Got promise for the parsed body.

    It's like setting the options to `{responseType: 'json', resolveBodyOnly: true}` but without affecting the main Got promise.

    __Note__: When using streams, this option is ignored.

    @example
    ```
    const responsePromise = got(url);
    const bufferPromise = responsePromise.buffer();
    const jsonPromise = responsePromise.json();

    const [response, buffer, json] = Promise.all([responsePromise, bufferPromise, jsonPromise]);
    // `response` is an instance of Got Response
    // `buffer` is an instance of Buffer
    // `json` is an object
    ```

    @example
    ```
    // This
    const body = await got(url).json();

    // is semantically the same as this
    const body = await got(url, {responseType: 'json', resolveBodyOnly: true});
    ```
    */ get responseType() {
        return this._internals.responseType;
    }
    set responseType(value) {
        if (value === undefined) {
            this._internals.responseType = 'text';
            return;
        }
        if (value !== 'text' && value !== 'buffer' && value !== 'json') {
            throw new Error(`Invalid \`responseType\` option: ${value}`);
        }
        this._internals.responseType = value;
    }
    get pagination() {
        return this._internals.pagination;
    }
    set pagination(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].object(value);
        if (this._merging) {
            Object.assign(this._internals.pagination, value);
        } else {
            this._internals.pagination = value;
        }
    }
    get auth() {
        throw new Error('Parameter `auth` is deprecated. Use `username` / `password` instead.');
    }
    set auth(_value) {
        throw new Error('Parameter `auth` is deprecated. Use `username` / `password` instead.');
    }
    get setHost() {
        return this._internals.setHost;
    }
    set setHost(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].boolean(value);
        this._internals.setHost = value;
    }
    get maxHeaderSize() {
        return this._internals.maxHeaderSize;
    }
    set maxHeaderSize(value) {
        assertAny('maxHeaderSize', [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].number,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
        ], value);
        this._internals.maxHeaderSize = value;
    }
    get enableUnixSockets() {
        return this._internals.enableUnixSockets;
    }
    set enableUnixSockets(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].boolean(value);
        this._internals.enableUnixSockets = value;
    }
    /**
    Throw an error if the server response's `content-length` header value doesn't match the number of bytes received.

    This is useful for detecting truncated responses and follows RFC 9112 requirements for message completeness.

    __Note__: Responses without a `content-length` header are not validated.
    __Note__: When enabled and validation fails, a `ReadError` with code `ERR_HTTP_CONTENT_LENGTH_MISMATCH` will be thrown.

    @default false
    */ get strictContentLength() {
        return this._internals.strictContentLength;
    }
    set strictContentLength(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].boolean(value);
        this._internals.strictContentLength = value;
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    toJSON() {
        return {
            ...this._internals
        };
    }
    [Symbol.for('nodejs.util.inspect.custom')](_depth, options) {
        return (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["inspect"])(this._internals, options);
    }
    createNativeRequestOptions() {
        const internals = this._internals;
        const url = internals.url;
        let agent;
        if (url.protocol === 'https:') {
            if (internals.http2) {
                // Ensure HTTP/2 agent is configured for connection reuse
                // If no custom agent.http2 is provided, use the global agent for connection pooling
                agent = {
                    ...internals.agent,
                    http2: internals.agent.http2 ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$http2$2d$wrapper$2f$source$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].globalAgent
                };
            } else {
                agent = internals.agent.https;
            }
        } else {
            agent = internals.agent.http;
        }
        const { https } = internals;
        let { pfx } = https;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].array(pfx) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].plainObject(pfx[0])) {
            pfx = pfx.map((object)=>({
                    buf: object.buffer,
                    passphrase: object.passphrase
                }));
        }
        return {
            ...internals.cacheOptions,
            ...this._unixOptions,
            // HTTPS options
            // eslint-disable-next-line @typescript-eslint/naming-convention
            ALPNProtocols: https.alpnProtocols,
            ca: https.certificateAuthority,
            cert: https.certificate,
            key: https.key,
            passphrase: https.passphrase,
            pfx: https.pfx,
            rejectUnauthorized: https.rejectUnauthorized,
            checkServerIdentity: https.checkServerIdentity ?? __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$tls__$5b$external$5d$__$28$node$3a$tls$2c$__cjs$29$__["checkServerIdentity"],
            servername: https.serverName,
            ciphers: https.ciphers,
            honorCipherOrder: https.honorCipherOrder,
            minVersion: https.minVersion,
            maxVersion: https.maxVersion,
            sigalgs: https.signatureAlgorithms,
            sessionTimeout: https.tlsSessionLifetime,
            dhparam: https.dhparam,
            ecdhCurve: https.ecdhCurve,
            crl: https.certificateRevocationLists,
            secureOptions: https.secureOptions,
            // HTTP options
            lookup: internals.dnsLookup ?? internals.dnsCache?.lookup,
            family: internals.dnsLookupIpVersion,
            agent,
            setHost: internals.setHost,
            method: internals.method,
            maxHeaderSize: internals.maxHeaderSize,
            localAddress: internals.localAddress,
            headers: internals.headers,
            createConnection: internals.createConnection,
            timeout: internals.http2 ? getHttp2TimeoutOption(internals) : undefined,
            // HTTP/2 options
            h2session: internals.h2session
        };
    }
    getRequestFunction() {
        const url = this._internals.url;
        const { request } = this._internals;
        if (!request && url) {
            return this.getFallbackRequestFunction();
        }
        return request;
    }
    getFallbackRequestFunction() {
        const url = this._internals.url;
        if (!url) {
            return;
        }
        if (url.protocol === 'https:') {
            if (this._internals.http2) {
                if (major < 15 || major === 15 && minor < 10) {
                    const error = new Error('To use the `http2` option, install Node.js 15.10.0 or above');
                    error.code = 'EUNSUPPORTED';
                    throw error;
                }
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$http2$2d$wrapper$2f$source$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].auto;
            }
            return __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$https__$5b$external$5d$__$28$node$3a$https$2c$__cjs$29$__["default"].request;
        }
        return __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$http__$5b$external$5d$__$28$node$3a$http$2c$__cjs$29$__["default"].request;
    }
    freeze() {
        const options = this._internals;
        Object.freeze(options);
        Object.freeze(options.hooks);
        Object.freeze(options.hooks.afterResponse);
        Object.freeze(options.hooks.beforeError);
        Object.freeze(options.hooks.beforeRedirect);
        Object.freeze(options.hooks.beforeRequest);
        Object.freeze(options.hooks.beforeRetry);
        Object.freeze(options.hooks.init);
        Object.freeze(options.https);
        Object.freeze(options.cacheOptions);
        Object.freeze(options.agent);
        Object.freeze(options.headers);
        Object.freeze(options.timeout);
        Object.freeze(options.retry);
        Object.freeze(options.retry.errorCodes);
        Object.freeze(options.retry.methods);
        Object.freeze(options.retry.statusCodes);
    }
}
}),
"[project]/node_modules/got/dist/source/core/response.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ParseError",
    ()=>ParseError,
    "isResponseOk",
    ()=>isResponseOk,
    "parseBody",
    ()=>parseBody
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/errors.js [app-ssr] (ecmascript)");
;
const isResponseOk = (response)=>{
    const { statusCode } = response;
    const { followRedirect } = response.request.options;
    const shouldFollow = typeof followRedirect === 'function' ? followRedirect(response) : followRedirect;
    const limitStatusCode = shouldFollow ? 299 : 399;
    return statusCode >= 200 && statusCode <= limitStatusCode || statusCode === 304;
};
class ParseError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RequestError"] {
    name = 'ParseError';
    code = 'ERR_BODY_PARSE_FAILURE';
    constructor(error, response){
        const { options } = response.request;
        super(`${error.message} in "${options.url.toString()}"`, error, response.request);
    }
}
const parseBody = (response, responseType, parseJson, encoding)=>{
    const { rawBody } = response;
    try {
        if (responseType === 'text') {
            return rawBody.toString(encoding);
        }
        if (responseType === 'json') {
            return rawBody.length === 0 ? '' : parseJson(rawBody.toString(encoding));
        }
        if (responseType === 'buffer') {
            return rawBody;
        }
    } catch (error) {
        throw new ParseError(error, response);
    }
    throw new ParseError({
        message: `Unknown body type '${responseType}'`,
        name: 'Error'
    }, response);
};
}),
"[project]/node_modules/got/dist/source/core/utils/is-client-request.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
function isClientRequest(clientRequest) {
    return clientRequest.writable && !clientRequest.writableEnded;
}
const __TURBOPACK__default__export__ = isClientRequest;
}),
"[project]/node_modules/got/dist/source/core/utils/is-unix-socket-url.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// eslint-disable-next-line @typescript-eslint/naming-convention
__turbopack_context__.s([
    "default",
    ()=>isUnixSocketURL,
    "getUnixSocketPath",
    ()=>getUnixSocketPath
]);
function isUnixSocketURL(url) {
    return url.protocol === 'unix:' || url.hostname === 'unix';
}
function getUnixSocketPath(url) {
    if (!isUnixSocketURL(url)) {
        return undefined;
    }
    return /(?<socketPath>.+?):(?<path>.+)/.exec(`${url.pathname}${url.search}`)?.groups?.socketPath;
}
}),
"[project]/node_modules/got/dist/source/core/diagnostics-channel.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "generateRequestId",
    ()=>generateRequestId,
    "publishError",
    ()=>publishError,
    "publishRedirect",
    ()=>publishRedirect,
    "publishRequestCreate",
    ()=>publishRequestCreate,
    "publishRequestStart",
    ()=>publishRequestStart,
    "publishResponseEnd",
    ()=>publishResponseEnd,
    "publishResponseStart",
    ()=>publishResponseStart,
    "publishRetry",
    ()=>publishRetry
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$diagnostics_channel__$5b$external$5d$__$28$node$3a$diagnostics_channel$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:diagnostics_channel [external] (node:diagnostics_channel, cjs)");
;
;
const channels = {
    requestCreate: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$diagnostics_channel__$5b$external$5d$__$28$node$3a$diagnostics_channel$2c$__cjs$29$__["default"].channel('got:request:create'),
    requestStart: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$diagnostics_channel__$5b$external$5d$__$28$node$3a$diagnostics_channel$2c$__cjs$29$__["default"].channel('got:request:start'),
    responseStart: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$diagnostics_channel__$5b$external$5d$__$28$node$3a$diagnostics_channel$2c$__cjs$29$__["default"].channel('got:response:start'),
    responseEnd: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$diagnostics_channel__$5b$external$5d$__$28$node$3a$diagnostics_channel$2c$__cjs$29$__["default"].channel('got:response:end'),
    retry: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$diagnostics_channel__$5b$external$5d$__$28$node$3a$diagnostics_channel$2c$__cjs$29$__["default"].channel('got:request:retry'),
    error: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$diagnostics_channel__$5b$external$5d$__$28$node$3a$diagnostics_channel$2c$__cjs$29$__["default"].channel('got:request:error'),
    redirect: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$diagnostics_channel__$5b$external$5d$__$28$node$3a$diagnostics_channel$2c$__cjs$29$__["default"].channel('got:response:redirect')
};
function generateRequestId() {
    return (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["randomUUID"])();
}
function publishRequestCreate(message) {
    if (channels.requestCreate.hasSubscribers) {
        channels.requestCreate.publish(message);
    }
}
function publishRequestStart(message) {
    if (channels.requestStart.hasSubscribers) {
        channels.requestStart.publish(message);
    }
}
function publishResponseStart(message) {
    if (channels.responseStart.hasSubscribers) {
        channels.responseStart.publish(message);
    }
}
function publishResponseEnd(message) {
    if (channels.responseEnd.hasSubscribers) {
        channels.responseEnd.publish(message);
    }
}
function publishRetry(message) {
    if (channels.retry.hasSubscribers) {
        channels.retry.publish(message);
    }
}
function publishError(message) {
    if (channels.error.hasSubscribers) {
        channels.error.publish(message);
    }
}
function publishRedirect(message) {
    if (channels.redirect.hasSubscribers) {
        channels.redirect.publish(message);
    }
}
}),
"[project]/node_modules/got/dist/source/core/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

__turbopack_context__.s([
    "default",
    ()=>Request
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:buffer [external] (node:buffer, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream [external] (node:stream, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$http__$5b$external$5d$__$28$node$3a$http$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:http [external] (node:http, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$byte$2d$counter$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/byte-counter/utilities.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cacheable$2d$request$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/cacheable-request/dist/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cacheable$2d$request$2f$dist$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cacheable-request/dist/types.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$decompress$2d$response$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/decompress-response/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sindresorhus/is/distribution/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$form$2d$data$2d$encoder$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/form-data-encoder/lib/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$timer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/utils/timer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$get$2d$body$2d$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/utils/get-body-size.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$is$2d$form$2d$data$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/utils/is-form-data.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$proxy$2d$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/utils/proxy-events.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$timed$2d$out$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/timed-out.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$url$2d$to$2d$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/utils/url-to-options.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$weakable$2d$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/utils/weakable-map.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$calculate$2d$retry$2d$delay$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/calculate-retry-delay.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/options.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$response$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/response.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$is$2d$client$2d$request$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/utils/is-client-request.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$is$2d$unix$2d$socket$2d$url$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/utils/is-unix-socket-url.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/errors.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$diagnostics$2d$channel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/diagnostics-channel.js [app-ssr] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cacheable$2d$request$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__
]);
[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cacheable$2d$request$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const supportsBrotli = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].versions.brotli);
const supportsZstd = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].versions.zstd);
const methodsWithoutBody = new Set([
    'GET',
    'HEAD'
]);
// Methods that should auto-end streams when no body is provided
const methodsWithoutBodyStream = new Set([
    'OPTIONS',
    'DELETE',
    'PATCH'
]);
const cacheableStore = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$weakable$2d$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
const redirectCodes = new Set([
    300,
    301,
    302,
    303,
    304,
    307,
    308
]);
// Track errors that have been processed by beforeError hooks to preserve custom error types
const errorsProcessedByHooks = new WeakSet();
const proxiedRequestEvents = [
    'socket',
    'connect',
    'continue',
    'information',
    'upgrade'
];
const noop = ()=>{};
class Request extends __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Duplex"] {
    // @ts-expect-error - Ignoring for now.
    ['constructor'];
    _noPipe;
    // @ts-expect-error https://github.com/microsoft/TypeScript/issues/9568
    options;
    response;
    requestUrl;
    redirectUrls = [];
    retryCount = 0;
    _stopReading = false;
    _stopRetry = noop;
    _downloadedSize = 0;
    _uploadedSize = 0;
    _pipedServerResponses = new Set();
    _request;
    _responseSize;
    _bodySize;
    _unproxyEvents = noop;
    _isFromCache;
    _triggerRead = false;
    _jobs = [];
    _cancelTimeouts = noop;
    _removeListeners = noop;
    _nativeResponse;
    _flushed = false;
    _aborted = false;
    _expectedContentLength;
    _compressedBytesCount;
    _requestId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$diagnostics$2d$channel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["generateRequestId"])();
    // We need this because `this._request` if `undefined` when using cache
    _requestInitialized = false;
    constructor(url, options, defaults){
        super({
            // Don't destroy immediately, as the error may be emitted on unsuccessful retry
            autoDestroy: false,
            // It needs to be zero because we're just proxying the data to another stream
            highWaterMark: 0
        });
        this.on('pipe', (source)=>{
            if (this.options.copyPipedHeaders && source?.headers) {
                Object.assign(this.options.headers, source.headers);
            }
        });
        this.on('newListener', (event)=>{
            if (event === 'retry' && this.listenerCount('retry') > 0) {
                throw new Error('A retry listener has been attached already.');
            }
        });
        try {
            this.options = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](url, options, defaults);
            if (!this.options.url) {
                if (this.options.prefixUrl === '') {
                    throw new TypeError('Missing `url` property');
                }
                this.options.url = '';
            }
            this.requestUrl = this.options.url;
            // Publish request creation event
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$diagnostics$2d$channel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["publishRequestCreate"])({
                requestId: this._requestId,
                url: this.options.url?.toString() ?? '',
                method: this.options.method
            });
        } catch (error) {
            const { options } = error;
            if (options) {
                this.options = options;
            }
            this.flush = async ()=>{
                this.flush = async ()=>{};
                // Defer error emission to next tick to allow user to attach error handlers
                __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].nextTick(()=>{
                    // _beforeError requires options to access retry logic and hooks
                    if (this.options) {
                        this._beforeError(error);
                    } else {
                        // Options is undefined, skip _beforeError and destroy directly
                        const requestError = error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RequestError"] ? error : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RequestError"](error.message, error, this);
                        this.destroy(requestError);
                    }
                });
            };
            return;
        }
        // Important! If you replace `body` in a handler with another stream, make sure it's readable first.
        // The below is run only once.
        const { body } = this.options;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].nodeStream(body)) {
            body.once('error', (error)=>{
                if (this._flushed) {
                    this._beforeError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UploadError"](error, this));
                } else {
                    this.flush = async ()=>{
                        this.flush = async ()=>{};
                        this._beforeError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UploadError"](error, this));
                    };
                }
            });
        }
        if (this.options.signal) {
            const abort = ()=>{
                // See https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/timeout_static#return_value
                if (this.options.signal?.reason?.name === 'TimeoutError') {
                    this.destroy(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TimeoutError"](this.options.signal.reason, this.timings, this));
                } else {
                    this.destroy(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AbortError"](this));
                }
            };
            if (this.options.signal.aborted) {
                abort();
            } else {
                this.options.signal.addEventListener('abort', abort);
                this._removeListeners = ()=>{
                    this.options.signal?.removeEventListener('abort', abort);
                };
            }
        }
    }
    async flush() {
        if (this._flushed) {
            return;
        }
        this._flushed = true;
        try {
            await this._finalizeBody();
            if (this.destroyed) {
                return;
            }
            await this._makeRequest();
            if (this.destroyed) {
                this._request?.destroy();
                return;
            }
            // Queued writes etc.
            for (const job of this._jobs){
                job();
            }
            // Prevent memory leak
            this._jobs.length = 0;
            this._requestInitialized = true;
        } catch (error) {
            this._beforeError(error);
        }
    }
    _beforeError(error) {
        if (this._stopReading) {
            return;
        }
        const { response, options } = this;
        const attemptCount = this.retryCount + (error.name === 'RetryError' ? 0 : 1);
        this._stopReading = true;
        if (!(error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RequestError"])) {
            error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RequestError"](error.message, error, this);
        }
        const typedError = error;
        void (async ()=>{
            // Node.js parser is really weird.
            // It emits post-request Parse Errors on the same instance as previous request. WTF.
            // Therefore, we need to check if it has been destroyed as well.
            //
            // Furthermore, Node.js 16 `response.destroy()` doesn't immediately destroy the socket,
            // but makes the response unreadable. So we additionally need to check `response.readable`.
            if (response?.readable && !response.rawBody && !this._request?.socket?.destroyed) {
                // @types/node has incorrect typings. `setEncoding` accepts `null` as well.
                response.setEncoding(this.readableEncoding);
                const success = await this._setRawBody(response);
                if (success) {
                    response.body = response.rawBody.toString();
                }
            }
            if (this.listenerCount('retry') !== 0) {
                let backoff;
                try {
                    let retryAfter;
                    if (response && 'retry-after' in response.headers) {
                        retryAfter = Number(response.headers['retry-after']);
                        if (Number.isNaN(retryAfter)) {
                            retryAfter = Date.parse(response.headers['retry-after']) - Date.now();
                            if (retryAfter <= 0) {
                                retryAfter = 1;
                            }
                        } else {
                            retryAfter *= 1000;
                        }
                    }
                    const retryOptions = options.retry;
                    const computedValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$calculate$2d$retry$2d$delay$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({
                        attemptCount,
                        retryOptions,
                        error: typedError,
                        retryAfter,
                        computedValue: retryOptions.maxRetryAfter ?? options.timeout.request ?? Number.POSITIVE_INFINITY
                    });
                    // When enforceRetryRules is true, respect the retry rules (limit, methods, statusCodes, errorCodes)
                    // before calling the user's calculateDelay function. If computedValue is 0 (meaning retry is not allowed
                    // based on these rules), skip calling calculateDelay entirely.
                    // When false (default), always call calculateDelay, allowing it to override retry decisions.
                    if (retryOptions.enforceRetryRules && computedValue === 0) {
                        backoff = 0;
                    } else {
                        backoff = await retryOptions.calculateDelay({
                            attemptCount,
                            retryOptions,
                            error: typedError,
                            retryAfter,
                            computedValue
                        });
                    }
                } catch (error_) {
                    void this._error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RequestError"](error_.message, error_, this));
                    return;
                }
                if (backoff) {
                    await new Promise((resolve)=>{
                        const timeout = setTimeout(resolve, backoff);
                        this._stopRetry = ()=>{
                            clearTimeout(timeout);
                            resolve();
                        };
                    });
                    // Something forced us to abort the retry
                    if (this.destroyed) {
                        return;
                    }
                    // Capture body BEFORE hooks run to detect reassignment
                    const bodyBeforeHooks = this.options.body;
                    try {
                        for (const hook of this.options.hooks.beforeRetry){
                            // eslint-disable-next-line no-await-in-loop
                            await hook(typedError, this.retryCount + 1);
                        }
                    } catch (error_) {
                        void this._error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RequestError"](error_.message, error_, this));
                        return;
                    }
                    // Something forced us to abort the retry
                    if (this.destroyed) {
                        return;
                    }
                    // Preserve stream body reassigned in beforeRetry hooks.
                    const bodyAfterHooks = this.options.body;
                    const bodyWasReassigned = bodyBeforeHooks !== bodyAfterHooks;
                    // Resource cleanup and preservation logic for retry with body reassignment.
                    // The Promise wrapper (as-promise/index.ts) compares body identity to detect consumed streams,
                    // so we must preserve the body reference across destroy(). However, destroy() calls _destroy()
                    // which destroys this.options.body, creating a complex dance of clear/restore operations.
                    //
                    // Key constraints:
                    // 1. If body was reassigned, we must NOT destroy the NEW stream (it will be used for retry)
                    // 2. If body was reassigned, we MUST destroy the OLD stream to prevent memory leaks
                    // 3. We must restore the body reference after destroy() for identity checks in promise wrapper
                    // 4. We cannot use the normal setter after destroy() because it validates stream readability
                    if (bodyWasReassigned) {
                        const oldBody = bodyBeforeHooks;
                        // Temporarily clear body to prevent destroy() from destroying the new stream
                        this.options.body = undefined;
                        this.destroy();
                        // Clean up the old stream resource if it's a stream and different from new body
                        // (edge case: if old and new are same stream object, don't destroy it)
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].nodeStream(oldBody) && oldBody !== bodyAfterHooks) {
                            oldBody.destroy();
                        }
                        // Restore new body for promise wrapper's identity check
                        // We bypass the setter because it validates stream.readable (which fails for destroyed request)
                        // Type assertion is necessary here to access private _internals without exposing internal API
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].nodeStream(bodyAfterHooks) && (bodyAfterHooks.readableEnded || bodyAfterHooks.destroyed)) {
                            throw new TypeError('The reassigned stream body must be readable. Ensure you provide a fresh, readable stream in the beforeRetry hook.');
                        }
                        this.options._internals.body = bodyAfterHooks;
                    } else {
                        // Body wasn't reassigned - use normal destroy flow which handles body cleanup
                        this.destroy();
                    // Note: We do NOT restore the body reference here. The stream was destroyed by _destroy()
                    // and should not be accessed. The promise wrapper will see that body identity hasn't changed
                    // and will detect it's a consumed stream, which is the correct behavior.
                    }
                    // Publish retry event
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$diagnostics$2d$channel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["publishRetry"])({
                        requestId: this._requestId,
                        retryCount: this.retryCount + 1,
                        error: typedError,
                        delay: backoff
                    });
                    this.emit('retry', this.retryCount + 1, error, (updatedOptions)=>{
                        const request = new Request(options.url, updatedOptions, options);
                        request.retryCount = this.retryCount + 1;
                        __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].nextTick(()=>{
                            void request.flush();
                        });
                        return request;
                    });
                    return;
                }
            }
            void this._error(typedError);
        })();
    }
    _read() {
        this._triggerRead = true;
        const { response } = this;
        if (response && !this._stopReading) {
            // We cannot put this in the `if` above
            // because `.read()` also triggers the `end` event
            if (response.readableLength) {
                this._triggerRead = false;
            }
            let data;
            while((data = response.read()) !== null){
                this._downloadedSize += data.length; // eslint-disable-line @typescript-eslint/restrict-plus-operands
                const progress = this.downloadProgress;
                if (progress.percent < 1) {
                    this.emit('downloadProgress', progress);
                }
                this.push(data);
            }
        }
    }
    _write(chunk, encoding, callback) {
        const write = ()=>{
            this._writeRequest(chunk, encoding, callback);
        };
        if (this._requestInitialized) {
            write();
        } else {
            this._jobs.push(write);
        }
    }
    _final(callback) {
        const endRequest = ()=>{
            // We need to check if `this._request` is present,
            // because it isn't when we use cache.
            if (!this._request || this._request.destroyed) {
                callback();
                return;
            }
            this._request.end((error)=>{
                // The request has been destroyed before `_final` finished.
                // See https://github.com/nodejs/node/issues/39356
                if (this._request?._writableState?.errored) {
                    return;
                }
                if (!error) {
                    this._bodySize = this._uploadedSize;
                    this.emit('uploadProgress', this.uploadProgress);
                    this._request?.emit('upload-complete');
                }
                callback(error);
            });
        };
        if (this._requestInitialized) {
            endRequest();
        } else {
            this._jobs.push(endRequest);
        }
    }
    _destroy(error, callback) {
        this._stopReading = true;
        this.flush = async ()=>{};
        // Prevent further retries
        this._stopRetry();
        this._cancelTimeouts();
        this._removeListeners();
        if (this.options) {
            const { body } = this.options;
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].nodeStream(body)) {
                body.destroy();
            }
        }
        if (this._request) {
            this._request.destroy();
        }
        // Workaround: http-timer only sets timings.end when the response emits 'end'.
        // When a stream is destroyed before completion, the 'end' event may not fire,
        // leaving timings.end undefined. This should ideally be fixed in http-timer
        // by listening to the 'close' event, but we handle it here for now.
        // Only set timings.end if there was no error or abort (to maintain semantic correctness).
        const timings = this._request?.timings;
        if (timings && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined(timings.end) && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined(timings.response) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined(timings.error) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined(timings.abort)) {
            timings.end = Date.now();
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined(timings.phases.total)) {
                timings.phases.download = timings.end - timings.response;
                timings.phases.total = timings.end - timings.start;
            }
        }
        // Preserve custom errors returned by beforeError hooks.
        // For other errors, wrap non-RequestError instances for consistency.
        if (error !== null && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined(error)) {
            const processedByHooks = error instanceof Error && errorsProcessedByHooks.has(error);
            if (!processedByHooks && !(error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RequestError"])) {
                error = error instanceof Error ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RequestError"](error.message, error, this) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RequestError"](String(error), {}, this);
            }
        }
        callback(error);
    }
    pipe(destination, options) {
        if (destination instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$http__$5b$external$5d$__$28$node$3a$http$2c$__cjs$29$__["ServerResponse"]) {
            this._pipedServerResponses.add(destination);
        }
        return super.pipe(destination, options);
    }
    unpipe(destination) {
        if (destination instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$http__$5b$external$5d$__$28$node$3a$http$2c$__cjs$29$__["ServerResponse"]) {
            this._pipedServerResponses.delete(destination);
        }
        super.unpipe(destination);
        return this;
    }
    _checkContentLengthMismatch() {
        if (this.options.strictContentLength && this._expectedContentLength !== undefined) {
            // Use compressed bytes count when available (for compressed responses),
            // otherwise use _downloadedSize (for uncompressed responses)
            const actualSize = this._compressedBytesCount ?? this._downloadedSize;
            if (actualSize !== this._expectedContentLength) {
                this._beforeError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ReadError"]({
                    message: `Content-Length mismatch: expected ${this._expectedContentLength} bytes, received ${actualSize} bytes`,
                    name: 'Error',
                    code: 'ERR_HTTP_CONTENT_LENGTH_MISMATCH'
                }, this));
                return true;
            }
        }
        return false;
    }
    async _finalizeBody() {
        const { options } = this;
        const { headers } = options;
        const isForm = !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined(options.form);
        // eslint-disable-next-line @typescript-eslint/naming-convention
        const isJSON = !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined(options.json);
        const isBody = !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined(options.body);
        const cannotHaveBody = methodsWithoutBody.has(options.method) && !(options.method === 'GET' && options.allowGetBody);
        if (isForm || isJSON || isBody) {
            if (cannotHaveBody) {
                throw new TypeError(`The \`${options.method}\` method cannot be used with a body`);
            }
            // Serialize body
            const noContentType = !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string(headers['content-type']);
            if (isBody) {
                // Body is spec-compliant FormData
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$form$2d$data$2d$encoder$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFormData"])(options.body)) {
                    const encoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$form$2d$data$2d$encoder$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FormDataEncoder"](options.body);
                    if (noContentType) {
                        headers['content-type'] = encoder.headers['Content-Type'];
                    }
                    if ('Content-Length' in encoder.headers) {
                        headers['content-length'] = encoder.headers['Content-Length'];
                    }
                    options.body = encoder.encode();
                }
                // Special case for https://github.com/form-data/form-data
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$is$2d$form$2d$data$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(options.body) && noContentType) {
                    headers['content-type'] = `multipart/form-data; boundary=${options.body.getBoundary()}`;
                }
            } else if (isForm) {
                if (noContentType) {
                    headers['content-type'] = 'application/x-www-form-urlencoded';
                }
                const { form } = options;
                options.form = undefined;
                options.body = new URLSearchParams(form).toString();
            } else {
                if (noContentType) {
                    headers['content-type'] = 'application/json';
                }
                const { json } = options;
                options.json = undefined;
                options.body = options.stringifyJson(json);
            }
            const uploadBodySize = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$get$2d$body$2d$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(options.body, options.headers);
            // See https://tools.ietf.org/html/rfc7230#section-3.3.2
            // A user agent SHOULD send a Content-Length in a request message when
            // no Transfer-Encoding is sent and the request method defines a meaning
            // for an enclosed payload body.  For example, a Content-Length header
            // field is normally sent in a POST request even when the value is 0
            // (indicating an empty payload body).  A user agent SHOULD NOT send a
            // Content-Length header field when the request message does not contain
            // a payload body and the method semantics do not anticipate such a
            // body.
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined(headers['content-length']) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined(headers['transfer-encoding']) && !cannotHaveBody && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined(uploadBodySize)) {
                headers['content-length'] = String(uploadBodySize);
            }
        }
        if (options.responseType === 'json' && !('accept' in options.headers)) {
            options.headers.accept = 'application/json';
        }
        this._bodySize = Number(headers['content-length']) || undefined;
    }
    async _onResponseBase(response) {
        // This will be called e.g. when using cache so we need to check if this request has been aborted.
        if (this.isAborted) {
            return;
        }
        const { options } = this;
        const { url } = options;
        this._nativeResponse = response;
        const statusCode = response.statusCode;
        const { method } = options;
        // Skip decompression for responses that must not have bodies per RFC 9110:
        // - HEAD responses (any status code)
        // - 1xx (Informational): 100, 101, 102, 103, etc.
        // - 204 (No Content)
        // - 205 (Reset Content)
        // - 304 (Not Modified)
        const hasNoBody = method === 'HEAD' || statusCode >= 100 && statusCode < 200 || statusCode === 204 || statusCode === 205 || statusCode === 304;
        if (options.decompress && !hasNoBody) {
            // When strictContentLength is enabled, track compressed bytes by listening to
            // the native response's data events before decompression
            if (options.strictContentLength) {
                this._compressedBytesCount = 0;
                this._nativeResponse.on('data', (chunk)=>{
                    this._compressedBytesCount += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$byte$2d$counter$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["byteLength"])(chunk);
                });
            }
            response = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$decompress$2d$response$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(response);
        }
        const typedResponse = response;
        typedResponse.statusMessage = typedResponse.statusMessage || __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$http__$5b$external$5d$__$28$node$3a$http$2c$__cjs$29$__["default"].STATUS_CODES[statusCode]; // eslint-disable-line @typescript-eslint/prefer-nullish-coalescing -- The status message can be empty.
        typedResponse.url = options.url.toString();
        typedResponse.requestUrl = this.requestUrl;
        typedResponse.redirectUrls = this.redirectUrls;
        typedResponse.request = this;
        typedResponse.isFromCache = this._nativeResponse.fromCache ?? false;
        typedResponse.ip = this.ip;
        typedResponse.retryCount = this.retryCount;
        typedResponse.ok = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$response$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isResponseOk"])(typedResponse);
        this._isFromCache = typedResponse.isFromCache;
        this._responseSize = Number(response.headers['content-length']) || undefined;
        this.response = typedResponse;
        // Publish response start event
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$diagnostics$2d$channel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["publishResponseStart"])({
            requestId: this._requestId,
            url: typedResponse.url,
            statusCode,
            headers: response.headers,
            isFromCache: typedResponse.isFromCache
        });
        response.once('error', (error)=>{
            this._aborted = true;
            // Force clean-up, because some packages don't do this.
            // TODO: Fix decompress-response
            response.destroy();
            this._beforeError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ReadError"](error, this));
        });
        response.once('aborted', ()=>{
            this._aborted = true;
            // Check if there's a content-length mismatch to provide a more specific error
            if (!this._checkContentLengthMismatch()) {
                this._beforeError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ReadError"]({
                    name: 'Error',
                    message: 'The server aborted pending request',
                    code: 'ECONNRESET'
                }, this));
            }
        });
        const rawCookies = response.headers['set-cookie'];
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object(options.cookieJar) && rawCookies) {
            let promises = rawCookies.map(async (rawCookie)=>options.cookieJar.setCookie(rawCookie, url.toString()));
            if (options.ignoreInvalidCookies) {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                promises = promises.map(async (promise)=>{
                    try {
                        await promise;
                    } catch  {}
                });
            }
            try {
                await Promise.all(promises);
            } catch (error) {
                this._beforeError(error);
                return;
            }
        }
        // The above is running a promise, therefore we need to check if this request has been aborted yet again.
        if (this.isAborted) {
            return;
        }
        if (response.headers.location && redirectCodes.has(statusCode)) {
            // We're being redirected, we don't care about the response.
            // It'd be best to abort the request, but we can't because
            // we would have to sacrifice the TCP connection. We don't want that.
            const shouldFollow = typeof options.followRedirect === 'function' ? options.followRedirect(typedResponse) : options.followRedirect;
            if (shouldFollow) {
                response.resume();
                this._cancelTimeouts();
                this._unproxyEvents();
                if (this.redirectUrls.length >= options.maxRedirects) {
                    this._beforeError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MaxRedirectsError"](this));
                    return;
                }
                this._request = undefined;
                // Reset download progress for the new request
                this._downloadedSize = 0;
                const updatedOptions = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](undefined, undefined, this.options);
                const serverRequestedGet = statusCode === 303 && updatedOptions.method !== 'GET' && updatedOptions.method !== 'HEAD';
                const canRewrite = statusCode !== 307 && statusCode !== 308;
                const userRequestedGet = updatedOptions.methodRewriting && canRewrite;
                if (serverRequestedGet || userRequestedGet) {
                    updatedOptions.method = 'GET';
                    updatedOptions.body = undefined;
                    updatedOptions.json = undefined;
                    updatedOptions.form = undefined;
                    delete updatedOptions.headers['content-length'];
                }
                try {
                    // We need this in order to support UTF-8
                    const redirectBuffer = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__["Buffer"].from(response.headers.location, 'binary').toString();
                    const redirectUrl = new URL(redirectBuffer, url);
                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$is$2d$unix$2d$socket$2d$url$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(url) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$is$2d$unix$2d$socket$2d$url$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(redirectUrl)) {
                        this._beforeError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RequestError"]('Cannot redirect to UNIX socket', {}, this));
                        return;
                    }
                    // Redirecting to a different site, clear sensitive data.
                    // For UNIX sockets, different socket paths are also different origins.
                    const isDifferentOrigin = redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$is$2d$unix$2d$socket$2d$url$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getUnixSocketPath"])(url) !== (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$is$2d$unix$2d$socket$2d$url$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getUnixSocketPath"])(redirectUrl);
                    if (isDifferentOrigin) {
                        if ('host' in updatedOptions.headers) {
                            delete updatedOptions.headers.host;
                        }
                        if ('cookie' in updatedOptions.headers) {
                            delete updatedOptions.headers.cookie;
                        }
                        if ('authorization' in updatedOptions.headers) {
                            delete updatedOptions.headers.authorization;
                        }
                        if (updatedOptions.username || updatedOptions.password) {
                            updatedOptions.username = '';
                            updatedOptions.password = '';
                        }
                    } else {
                        redirectUrl.username = updatedOptions.username;
                        redirectUrl.password = updatedOptions.password;
                    }
                    this.redirectUrls.push(redirectUrl);
                    updatedOptions.url = redirectUrl;
                    for (const hook of updatedOptions.hooks.beforeRedirect){
                        // eslint-disable-next-line no-await-in-loop
                        await hook(updatedOptions, typedResponse);
                    }
                    // Publish redirect event
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$diagnostics$2d$channel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["publishRedirect"])({
                        requestId: this._requestId,
                        fromUrl: url.toString(),
                        toUrl: redirectUrl.toString(),
                        statusCode
                    });
                    this.emit('redirect', updatedOptions, typedResponse);
                    this.options = updatedOptions;
                    await this._makeRequest();
                } catch (error) {
                    this._beforeError(error);
                    return;
                }
                return;
            }
        }
        // `HTTPError`s always have `error.response.body` defined.
        // Therefore, we cannot retry if `options.throwHttpErrors` is false.
        // On the last retry, if `options.throwHttpErrors` is false, we would need to return the body,
        // but that wouldn't be possible since the body would be already read in `error.response.body`.
        if (options.isStream && options.throwHttpErrors && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$response$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isResponseOk"])(typedResponse)) {
            this._beforeError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HTTPError"](typedResponse));
            return;
        }
        // Store the expected content-length from the native response for validation.
        // This is the content-length before decompression, which is what actually gets transferred.
        // Skip storing for responses that shouldn't have bodies per RFC 9110.
        // When decompression occurs, only store if strictContentLength is enabled.
        const wasDecompressed = response !== this._nativeResponse;
        if (!hasNoBody && (!wasDecompressed || options.strictContentLength)) {
            const contentLengthHeader = this._nativeResponse.headers['content-length'];
            if (contentLengthHeader !== undefined) {
                const expectedLength = Number(contentLengthHeader);
                if (!Number.isNaN(expectedLength) && expectedLength >= 0) {
                    this._expectedContentLength = expectedLength;
                }
            }
        }
        // Set up end listener AFTER redirect check to avoid emitting progress for redirect responses
        response.once('end', ()=>{
            // Validate content-length if it was provided
            // Per RFC 9112: "If the sender closes the connection before the indicated number
            // of octets are received, the recipient MUST consider the message to be incomplete"
            if (this._checkContentLengthMismatch()) {
                return;
            }
            this._responseSize = this._downloadedSize;
            this.emit('downloadProgress', this.downloadProgress);
            // Publish response end event
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$diagnostics$2d$channel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["publishResponseEnd"])({
                requestId: this._requestId,
                url: typedResponse.url,
                statusCode,
                bodySize: this._downloadedSize,
                timings: this.timings
            });
            this.push(null);
        });
        this.emit('downloadProgress', this.downloadProgress);
        response.on('readable', ()=>{
            if (this._triggerRead) {
                this._read();
            }
        });
        this.on('resume', ()=>{
            response.resume();
        });
        this.on('pause', ()=>{
            response.pause();
        });
        if (this._noPipe) {
            const success = await this._setRawBody();
            if (success) {
                this.emit('response', response);
            }
            return;
        }
        this.emit('response', response);
        for (const destination of this._pipedServerResponses){
            if (destination.headersSent) {
                continue;
            }
            // Check if decompression actually occurred by comparing stream objects.
            // decompressResponse wraps the response stream when it decompresses,
            // so response !== this._nativeResponse indicates decompression happened.
            const wasDecompressed = response !== this._nativeResponse;
            for(const key in response.headers){
                if (Object.hasOwn(response.headers, key)) {
                    const value = response.headers[key];
                    // When decompression occurred, skip content-encoding and content-length
                    // as they refer to the compressed data, not the decompressed stream.
                    if (wasDecompressed && (key === 'content-encoding' || key === 'content-length')) {
                        continue;
                    }
                    // Skip if value is undefined
                    if (value !== undefined) {
                        destination.setHeader(key, value);
                    }
                }
            }
            destination.statusCode = statusCode;
        }
    }
    async _setRawBody(from = this) {
        if (from.readableEnded) {
            return false;
        }
        try {
            // Errors are emitted via the `error` event
            const fromArray = await from.toArray();
            const rawBody = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBuffer"])(fromArray.at(0)) ? __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__["Buffer"].concat(fromArray) : __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__["Buffer"].from(fromArray.join(''));
            // On retry Request is destroyed with no error, therefore the above will successfully resolve.
            // So in order to check if this was really successfull, we need to check if it has been properly ended.
            if (!this.isAborted) {
                this.response.rawBody = rawBody;
                return true;
            }
        } catch  {}
        return false;
    }
    async _onResponse(response) {
        try {
            await this._onResponseBase(response);
        } catch (error) {
            /* istanbul ignore next: better safe than sorry */ this._beforeError(error);
        }
    }
    _onRequest(request) {
        const { options } = this;
        const { timeout, url } = options;
        // Publish request start event
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$diagnostics$2d$channel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["publishRequestStart"])({
            requestId: this._requestId,
            url: url?.toString() ?? '',
            method: options.method,
            headers: options.headers
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$timer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(request);
        this._cancelTimeouts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$timed$2d$out$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(request, timeout, url);
        if (this.options.http2) {
            // Unset stream timeout, as the `timeout` option was used only for connection timeout.
            // We remove all 'timeout' listeners instead of calling setTimeout(0) because:
            // 1. setTimeout(0) causes a memory leak (see https://github.com/sindresorhus/got/issues/690)
            // 2. With HTTP/2 connection reuse, setTimeout(0) accumulates listeners on the socket
            // 3. removeAllListeners('timeout') properly cleans up without the memory leak
            request.removeAllListeners('timeout');
            // For HTTP/2, wait for socket and remove timeout listeners from it
            request.once('socket', (socket)=>{
                socket.removeAllListeners('timeout');
            });
        }
        const responseEventName = options.cache ? 'cacheableResponse' : 'response';
        request.once(responseEventName, (response)=>{
            void this._onResponse(response);
        });
        request.once('error', (error)=>{
            this._aborted = true;
            // Force clean-up, because some packages (e.g. nock) don't do this.
            request.destroy();
            error = error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$timed$2d$out$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TimeoutError"] ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TimeoutError"](error, this.timings, this) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RequestError"](error.message, error, this);
            this._beforeError(error);
        });
        this._unproxyEvents = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$proxy$2d$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(request, this, proxiedRequestEvents);
        this._request = request;
        this.emit('uploadProgress', this.uploadProgress);
        this._sendBody();
        this.emit('request', request);
    }
    async _asyncWrite(chunk) {
        return new Promise((resolve, reject)=>{
            super.write(chunk, (error)=>{
                if (error) {
                    reject(error);
                    return;
                }
                resolve();
            });
        });
    }
    _sendBody() {
        // Send body
        const { body } = this.options;
        const currentRequest = this.redirectUrls.length === 0 ? this : this._request ?? this;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].nodeStream(body)) {
            body.pipe(currentRequest);
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].buffer(body)) {
            // Buffer should be sent directly without conversion
            this._writeRequest(body, undefined, ()=>{});
            currentRequest.end();
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].typedArray(body)) {
            // Typed arrays should be treated like buffers, not iterated over
            // Create a Uint8Array view over the data (Node.js streams accept Uint8Array)
            const typedArray = body;
            const uint8View = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
            this._writeRequest(uint8View, undefined, ()=>{});
            currentRequest.end();
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].asyncIterable(body) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].iterable(body) && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string(body) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBuffer"])(body)) {
            (async ()=>{
                try {
                    for await (const chunk of body){
                        await this._asyncWrite(chunk);
                    }
                    super.end();
                } catch (error) {
                    this._beforeError(error);
                }
            })();
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined(body)) {
            // No body to send, end the request
            const cannotHaveBody = methodsWithoutBody.has(this.options.method) && !(this.options.method === 'GET' && this.options.allowGetBody);
            const shouldAutoEndStream = methodsWithoutBodyStream.has(this.options.method);
            if ((this._noPipe ?? false) || cannotHaveBody || currentRequest !== this || shouldAutoEndStream) {
                currentRequest.end();
            }
        } else {
            this._writeRequest(body, undefined, ()=>{});
            currentRequest.end();
        }
    }
    _prepareCache(cache) {
        if (cacheableStore.has(cache)) {
            return;
        }
        const cacheableRequest = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cacheable$2d$request$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"]((requestOptions, handler)=>{
            /**
            Wraps the cacheable-request handler to run beforeCache hooks.
            These hooks control caching behavior by:
            - Directly mutating the response object (changes apply to what gets cached)
            - Returning `false` to prevent caching
            - Returning `void`/`undefined` to use default caching behavior

            Hooks use direct mutation - they can modify response.headers, response.statusCode, etc.
            Mutations take effect immediately and determine what gets cached.
            */ const wrappedHandler = handler ? (response)=>{
                const { beforeCacheHooks, gotRequest } = requestOptions;
                // Early return if no hooks - cache the original response
                if (!beforeCacheHooks || beforeCacheHooks.length === 0) {
                    handler(response);
                    return;
                }
                try {
                    // Call each beforeCache hook with the response
                    // Hooks can directly mutate the response - mutations take effect immediately
                    for (const hook of beforeCacheHooks){
                        const result = hook(response);
                        if (result === false) {
                            // Prevent caching by adding no-cache headers
                            // Mutate the response directly to add headers
                            response.headers['cache-control'] = 'no-cache, no-store, must-revalidate';
                            response.headers.pragma = 'no-cache';
                            response.headers.expires = '0';
                            handler(response);
                            // Don't call remaining hooks - we've decided not to cache
                            return;
                        }
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].promise(result)) {
                            // BeforeCache hooks must be synchronous because cacheable-request's handler is synchronous
                            throw new TypeError('beforeCache hooks must be synchronous. The hook returned a Promise, but this hook must return synchronously. If you need async logic, use beforeRequest hook instead.');
                        }
                        if (result !== undefined) {
                            // Hooks should return false or undefined only
                            // Mutations work directly - no need to return the response
                            throw new TypeError('beforeCache hook must return false or undefined. To modify the response, mutate it directly.');
                        }
                    // Else: void/undefined = continue
                    }
                } catch (error) {
                    // Convert hook errors to RequestError and propagate
                    // This is consistent with how other hooks handle errors
                    if (gotRequest) {
                        gotRequest._beforeError(error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RequestError"] ? error : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RequestError"](error.message, error, gotRequest));
                        // Don't call handler when error was propagated successfully
                        return;
                    }
                    // If gotRequest is missing, log the error to aid debugging
                    // We still call the handler to prevent the request from hanging
                    console.error('Got: beforeCache hook error (request context unavailable):', error);
                    // Call handler with response (potentially partially modified)
                    handler(response);
                    return;
                }
                // All hooks ran successfully
                // Cache the response with any mutations applied
                handler(response);
            } : handler;
            const result = requestOptions._request(requestOptions, wrappedHandler);
            // TODO: remove this when `cacheable-request` supports async request functions.
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].promise(result)) {
                // We only need to implement the error handler in order to support HTTP2 caching.
                // The result will be a promise anyway.
                // @ts-expect-error ignore
                result.once = (event, handler)=>{
                    if (event === 'error') {
                        (async ()=>{
                            try {
                                await result;
                            } catch (error) {
                                handler(error);
                            }
                        })();
                    } else if (event === 'abort' || event === 'destroy') {
                        // The empty catch is needed here in case when
                        // it rejects before it's `await`ed in `_makeRequest`.
                        (async ()=>{
                            try {
                                const request = await result;
                                request.once(event, handler);
                            } catch  {}
                        })();
                    } else {
                        /* istanbul ignore next: safety check */ throw new Error(`Unknown HTTP2 promise event: ${event}`);
                    }
                    return result;
                };
            }
            return result;
        }, cache);
        cacheableStore.set(cache, cacheableRequest.request());
    }
    async _createCacheableRequest(url, options) {
        return new Promise((resolve, reject)=>{
            // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed
            Object.assign(options, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$url$2d$to$2d$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(url));
            let request;
            // TODO: Fix `cacheable-response`. This is ugly.
            const cacheRequest = cacheableStore.get(options.cache)(options, async (response)=>{
                response._readableState.autoDestroy = false;
                if (request) {
                    const fix = ()=>{
                        // For ResponseLike objects from cache, set complete to true if not already set.
                        // For real HTTP responses, copy from the underlying response.
                        if (response.req) {
                            response.complete = response.req.res.complete;
                        } else if (response.complete === undefined) {
                            // ResponseLike from cache should have complete = true
                            response.complete = true;
                        }
                    };
                    response.prependOnceListener('end', fix);
                    fix();
                    (await request).emit('cacheableResponse', response);
                }
                resolve(response);
            });
            cacheRequest.once('error', reject);
            cacheRequest.once('request', async (requestOrPromise)=>{
                request = requestOrPromise;
                resolve(request);
            });
        });
    }
    async _makeRequest() {
        const { options } = this;
        const { headers, username, password } = options;
        const cookieJar = options.cookieJar;
        for(const key in headers){
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined(headers[key])) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete headers[key];
            } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].null(headers[key])) {
                throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${key}\` header`);
            }
        }
        if (options.decompress && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined(headers['accept-encoding'])) {
            const encodings = [
                'gzip',
                'deflate'
            ];
            if (supportsBrotli) {
                encodings.push('br');
            }
            if (supportsZstd) {
                encodings.push('zstd');
            }
            headers['accept-encoding'] = encodings.join(', ');
        }
        if (username || password) {
            const credentials = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__["Buffer"].from(`${username}:${password}`).toString('base64');
            headers.authorization = `Basic ${credentials}`;
        }
        // Set cookies
        if (cookieJar) {
            const cookieString = await cookieJar.getCookieString(options.url.toString());
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].nonEmptyString(cookieString)) {
                headers.cookie = cookieString;
            }
        }
        let request;
        for (const hook of options.hooks.beforeRequest){
            // eslint-disable-next-line no-await-in-loop
            const result = await hook(options, {
                retryCount: this.retryCount
            });
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined(result)) {
                // @ts-expect-error Skip the type mismatch to support abstract responses
                request = ()=>result;
                break;
            }
        }
        request ||= options.getRequestFunction();
        const url = options.url;
        this._requestOptions = options.createNativeRequestOptions();
        if (options.cache) {
            this._requestOptions._request = request;
            this._requestOptions.cache = options.cache;
            this._requestOptions.body = options.body;
            this._requestOptions.beforeCacheHooks = options.hooks.beforeCache;
            this._requestOptions.gotRequest = this;
            try {
                this._prepareCache(options.cache);
            } catch (error) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CacheError"](error, this);
            }
        }
        // Cache support
        const function_ = options.cache ? this._createCacheableRequest : request;
        try {
            // We can't do `await fn(...)`,
            // because stream `error` event can be emitted before `Promise.resolve()`.
            let requestOrResponse = function_(url, this._requestOptions);
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].promise(requestOrResponse)) {
                requestOrResponse = await requestOrResponse;
            }
            // Fallback
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined(requestOrResponse)) {
                requestOrResponse = options.getFallbackRequestFunction()(url, this._requestOptions);
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].promise(requestOrResponse)) {
                    requestOrResponse = await requestOrResponse;
                }
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$is$2d$client$2d$request$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(requestOrResponse)) {
                this._onRequest(requestOrResponse);
            } else if (this.writableEnded) {
                void this._onResponse(requestOrResponse);
            } else {
                this.once('finish', ()=>{
                    void this._onResponse(requestOrResponse);
                });
                this._sendBody();
            }
        } catch (error) {
            if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cacheable$2d$request$2f$dist$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CacheError"]) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CacheError"](error, this);
            }
            throw error;
        }
    }
    async _error(error) {
        try {
            if (this.options && error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HTTPError"] && !this.options.throwHttpErrors) {
            // This branch can be reached only when using the Promise API
            // Skip calling the hooks on purpose.
            // See https://github.com/sindresorhus/got/issues/2103
            } else if (this.options) {
                const hooks = this.options.hooks.beforeError;
                if (hooks.length > 0) {
                    for (const hook of hooks){
                        // eslint-disable-next-line no-await-in-loop
                        error = await hook(error);
                        // Validate hook return value
                        if (!(error instanceof Error)) {
                            throw new TypeError(`The \`beforeError\` hook must return an Error instance. Received ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].string(error) ? 'string' : String(typeof error)}.`);
                        }
                    }
                    // Mark this error as processed by hooks so _destroy preserves custom error types.
                    // Only mark non-RequestError errors, since RequestErrors are already preserved
                    // by the instanceof check in _destroy (line 642).
                    if (!(error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RequestError"])) {
                        errorsProcessedByHooks.add(error);
                    }
                }
            }
        } catch (error_) {
            error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RequestError"](error_.message, error_, this);
        }
        // Publish error event
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$diagnostics$2d$channel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["publishError"])({
            requestId: this._requestId,
            url: this.options?.url?.toString() ?? '',
            error,
            timings: this.timings
        });
        this.destroy(error);
        // Manually emit error for Promise API to ensure it receives it.
        // Node.js streams may not re-emit if an error was already emitted during retry attempts.
        // Only emit for Promise API (_noPipe = true) to avoid double emissions in stream mode.
        // Use process.nextTick to defer emission and allow destroy() to complete first.
        // See https://github.com/sindresorhus/got/issues/1995
        if (this._noPipe) {
            __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].nextTick(()=>{
                this.emit('error', error);
            });
        }
    }
    _writeRequest(chunk, encoding, callback) {
        if (!this._request || this._request.destroyed) {
            // When there's no request (e.g., using cached response from beforeRequest hook),
            // we still need to call the callback to allow the stream to finish properly.
            callback();
            return;
        }
        this._request.write(chunk, encoding, (error)=>{
            // The `!destroyed` check is required to prevent `uploadProgress` being emitted after the stream was destroyed
            if (!error && !this._request.destroyed) {
                // For strings, encode them first to measure the actual bytes that will be sent
                const bytes = typeof chunk === 'string' ? __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__["Buffer"].from(chunk, encoding) : chunk;
                this._uploadedSize += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$byte$2d$counter$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["byteLength"])(bytes);
                const progress = this.uploadProgress;
                if (progress.percent < 1) {
                    this.emit('uploadProgress', progress);
                }
            }
            callback(error);
        });
    }
    /**
    The remote IP address.
    */ get ip() {
        return this.socket?.remoteAddress;
    }
    /**
    Indicates whether the request has been aborted or not.
    */ get isAborted() {
        return this._aborted;
    }
    get socket() {
        return this._request?.socket ?? undefined;
    }
    /**
    Progress event for downloading (receiving a response).
    */ get downloadProgress() {
        let percent;
        if (this._responseSize) {
            percent = this._downloadedSize / this._responseSize;
        } else if (this._responseSize === this._downloadedSize) {
            percent = 1;
        } else {
            percent = 0;
        }
        return {
            percent,
            transferred: this._downloadedSize,
            total: this._responseSize
        };
    }
    /**
    Progress event for uploading (sending a request).
    */ get uploadProgress() {
        let percent;
        if (this._bodySize) {
            percent = this._uploadedSize / this._bodySize;
        } else if (this._bodySize === this._uploadedSize) {
            percent = 1;
        } else {
            percent = 0;
        }
        return {
            percent,
            transferred: this._uploadedSize,
            total: this._bodySize
        };
    }
    /**
    The object contains the following properties:

    - `start` - Time when the request started.
    - `socket` - Time when a socket was assigned to the request.
    - `lookup` - Time when the DNS lookup finished.
    - `connect` - Time when the socket successfully connected.
    - `secureConnect` - Time when the socket securely connected.
    - `upload` - Time when the request finished uploading.
    - `response` - Time when the request fired `response` event.
    - `end` - Time when the response fired `end` event.
    - `error` - Time when the request fired `error` event.
    - `abort` - Time when the request fired `abort` event.
    - `phases`
        - `wait` - `timings.socket - timings.start`
        - `dns` - `timings.lookup - timings.socket`
        - `tcp` - `timings.connect - timings.lookup`
        - `tls` - `timings.secureConnect - timings.connect`
        - `request` - `timings.upload - (timings.secureConnect || timings.connect)`
        - `firstByte` - `timings.response - timings.upload`
        - `download` - `timings.end - timings.response`
        - `total` - `(timings.end || timings.error || timings.abort) - timings.start`

    If something has not been measured yet, it will be `undefined`.

    __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.
    */ get timings() {
        return this._request?.timings;
    }
    /**
    Whether the response was retrieved from the cache.
    */ get isFromCache() {
        return this._isFromCache;
    }
    get reusedSocket() {
        return this._request?.reusedSocket;
    }
    /**
    Whether the stream is read-only. Returns `true` when `body`, `json`, or `form` options are provided.
    */ get isReadonly() {
        return !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined(this.options?.body) || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined(this.options?.json) || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined(this.options?.form);
    }
}
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/node_modules/got/dist/source/as-promise/types.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CancelError",
    ()=>CancelError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/errors.js [app-ssr] (ecmascript)");
;
class CancelError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RequestError"] {
    constructor(request){
        super('Promise was canceled', {}, request);
        this.name = 'CancelError';
        this.code = 'ERR_CANCELED';
    }
    /**
    Whether the promise is canceled.
    */ get isCanceled() {
        return true;
    }
}
}),
"[project]/node_modules/got/dist/source/as-promise/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

__turbopack_context__.s([
    "default",
    ()=>asPromise
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:events [external] (node:events, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sindresorhus/is/distribution/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p$2d$cancelable$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p-cancelable/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/errors.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$response$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/response.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$proxy$2d$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/utils/proxy-events.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$as$2d$promise$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/as-promise/types.js [app-ssr] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__
]);
[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__;
;
;
;
;
;
;
;
;
const proxiedRequestEvents = [
    'request',
    'response',
    'redirect',
    'uploadProgress',
    'downloadProgress'
];
function asPromise(firstRequest) {
    let globalRequest;
    let globalResponse;
    let normalizedOptions;
    const emitter = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["EventEmitter"]();
    let promiseSettled = false;
    const promise = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p$2d$cancelable$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]((resolve, reject, onCancel)=>{
        onCancel(()=>{
            globalRequest.destroy();
        });
        onCancel.shouldReject = false;
        onCancel(()=>{
            promiseSettled = true;
            reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$as$2d$promise$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CancelError"](globalRequest));
        });
        const makeRequest = (retryCount)=>{
            // Errors when a new request is made after the promise settles.
            // Used to detect a race condition.
            // See https://github.com/sindresorhus/got/issues/1489
            onCancel(()=>{});
            const request = firstRequest ?? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](undefined, undefined, normalizedOptions);
            request.retryCount = retryCount;
            request._noPipe = true;
            globalRequest = request;
            request.once('response', async (response)=>{
                // Parse body
                const contentEncoding = (response.headers['content-encoding'] ?? '').toLowerCase();
                const isCompressed = contentEncoding === 'gzip' || contentEncoding === 'deflate' || contentEncoding === 'br' || contentEncoding === 'zstd';
                const { options } = request;
                if (isCompressed && !options.decompress) {
                    response.body = response.rawBody;
                } else {
                    try {
                        response.body = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$response$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseBody"])(response, options.responseType, options.parseJson, options.encoding);
                    } catch (error) {
                        // Fall back to `utf8`
                        try {
                            response.body = response.rawBody.toString();
                        } catch (error) {
                            request._beforeError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$response$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ParseError"](error, response));
                            return;
                        }
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$response$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isResponseOk"])(response)) {
                            request._beforeError(error);
                            return;
                        }
                    }
                }
                try {
                    const hooks = options.hooks.afterResponse;
                    for (const [index, hook] of hooks.entries()){
                        // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise
                        // eslint-disable-next-line no-await-in-loop
                        response = await hook(response, async (updatedOptions)=>{
                            const preserveHooks = updatedOptions.preserveHooks ?? false;
                            options.merge(updatedOptions);
                            options.prefixUrl = '';
                            if (updatedOptions.url) {
                                options.url = updatedOptions.url;
                            }
                            // Remove any further hooks for that request, because we'll call them anyway.
                            // The loop continues. We don't want duplicates (asPromise recursion).
                            // Unless preserveHooks is true, in which case we keep the remaining hooks.
                            if (!preserveHooks) {
                                options.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);
                            }
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RetryError"](request);
                        });
                        if (!(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].object(response) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].number(response.statusCode) && 'body' in response)) {
                            throw new TypeError('The `afterResponse` hook returned an invalid value');
                        }
                    }
                } catch (error) {
                    request._beforeError(error);
                    return;
                }
                globalResponse = response;
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$response$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isResponseOk"])(response)) {
                    request._beforeError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HTTPError"](response));
                    return;
                }
                request.destroy();
                promiseSettled = true;
                resolve(request.options.resolveBodyOnly ? response.body : response);
            });
            let handledFinalError = false;
            const onError = (error)=>{
                if (promise.isCanceled) {
                    return;
                }
                // Route errors emitted directly on the stream (e.g., EPIPE from Node.js)
                // through retry logic first, then handle them here after retries are exhausted.
                // See https://github.com/sindresorhus/got/issues/1995
                if (!request._stopReading) {
                    request._beforeError(error);
                    return;
                }
                // Allow the manual re-emission from Request to land only once.
                if (handledFinalError) {
                    return;
                }
                handledFinalError = true;
                promiseSettled = true;
                const { options } = request;
                if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HTTPError"] && !options.throwHttpErrors) {
                    const { response } = error;
                    request.destroy();
                    resolve(request.options.resolveBodyOnly ? response.body : response);
                    return;
                }
                reject(error);
            };
            // Use .on() instead of .once() to keep the listener active across retries.
            // When _stopReading is false, we return early and the error gets re-emitted
            // after retry logic completes, so we need this listener to remain active.
            // See https://github.com/sindresorhus/got/issues/1995
            request.on('error', onError);
            const previousBody = request.options?.body;
            request.once('retry', (newRetryCount, error)=>{
                firstRequest = undefined;
                // If promise already settled, don't retry
                // This prevents the race condition in #1489 where a late error
                // (e.g., ECONNRESET after successful response) triggers retry
                // after the promise has already resolved/rejected
                if (promiseSettled) {
                    return;
                }
                const newBody = request.options.body;
                if (previousBody === newBody && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].nodeStream(newBody)) {
                    error.message = 'Cannot retry with consumed body stream';
                    onError(error);
                    return;
                }
                // This is needed! We need to reuse `request.options` because they can get modified!
                // For example, by calling `promise.json()`.
                normalizedOptions = request.options;
                makeRequest(newRetryCount);
            });
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$utils$2f$proxy$2d$events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(request, emitter, proxiedRequestEvents);
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined(firstRequest)) {
                void request.flush();
            }
        };
        makeRequest(0);
    });
    promise.on = (event, function_)=>{
        emitter.on(event, function_);
        return promise;
    };
    promise.off = (event, function_)=>{
        emitter.off(event, function_);
        return promise;
    };
    const shortcut = (promiseToAwait, responseType)=>{
        const newPromise = (async ()=>{
            // Wait until downloading has ended
            await promiseToAwait;
            const { options } = globalResponse.request;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$response$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseBody"])(globalResponse, responseType, options.parseJson, options.encoding);
        })();
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promiseToAwait));
        return newPromise;
    };
    // Note: These use `function` syntax (not arrows) to access `this` context.
    // When custom handlers wrap the promise to transform errors, these methods
    // are copied to the handler's promise. Using `this` ensures we await the
    // handler's wrapped promise, not the original, so errors propagate correctly.
    promise.json = function() {
        if (globalRequest.options) {
            const { headers } = globalRequest.options;
            if (!globalRequest.writableFinished && !('accept' in headers)) {
                headers.accept = 'application/json';
            }
        }
        return shortcut(this, 'json');
    };
    promise.buffer = function() {
        return shortcut(this, 'buffer');
    };
    promise.text = function() {
        return shortcut(this, 'text');
    };
    return promise;
}
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/node_modules/got/dist/source/create.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$timers$2f$promises__$5b$external$5d$__$28$node$3a$timers$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:timers/promises [external] (node:timers/promises, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sindresorhus/is/distribution/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$as$2d$promise$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/as-promise/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/options.js [app-ssr] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$as$2d$promise$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__
]);
[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$as$2d$promise$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__;
;
;
;
;
;
const isGotInstance = (value)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].function(value);
const aliases = [
    'get',
    'post',
    'put',
    'patch',
    'head',
    'delete'
];
const create = (defaults)=>{
    defaults = {
        options: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](undefined, undefined, defaults.options),
        handlers: [
            ...defaults.handlers
        ],
        mutableDefaults: defaults.mutableDefaults
    };
    Object.defineProperty(defaults, 'mutableDefaults', {
        enumerable: true,
        configurable: false,
        writable: false
    });
    // Got interface
    const got = (url, options, defaultOptions = defaults.options)=>{
        const request = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](url, options, defaultOptions);
        let promise;
        const lastHandler = (normalized)=>{
            // Note: `options` is `undefined` when `new Options(...)` fails
            request.options = normalized;
            request._noPipe = !normalized?.isStream;
            void request.flush();
            if (normalized?.isStream) {
                return request;
            }
            promise ||= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$as$2d$promise$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(request);
            return promise;
        };
        let iteration = 0;
        const iterateHandlers = (newOptions)=>{
            const handler = defaults.handlers[iteration++] ?? lastHandler;
            const result = handler(newOptions, iterateHandlers);
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].promise(result) && !request.options?.isStream) {
                promise ||= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$as$2d$promise$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(request);
                if (result !== promise) {
                    const descriptors = Object.getOwnPropertyDescriptors(promise);
                    for(const key in descriptors){
                        if (key in result) {
                            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                            delete descriptors[key];
                        }
                    }
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    Object.defineProperties(result, descriptors);
                    result.cancel = promise.cancel;
                }
            }
            return result;
        };
        return iterateHandlers(request.options);
    };
    got.extend = (...instancesOrOptions)=>{
        const options = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](undefined, undefined, defaults.options);
        const handlers = [
            ...defaults.handlers
        ];
        let mutableDefaults;
        for (const value of instancesOrOptions){
            if (isGotInstance(value)) {
                options.merge(value.defaults.options);
                handlers.push(...value.defaults.handlers);
                mutableDefaults = value.defaults.mutableDefaults;
            } else {
                options.merge(value);
                if (value.handlers) {
                    handlers.push(...value.handlers);
                }
                mutableDefaults = value.mutableDefaults;
            }
        }
        return create({
            options,
            handlers,
            mutableDefaults: Boolean(mutableDefaults)
        });
    };
    // Pagination
    const paginateEach = async function*(url, options) {
        let normalizedOptions = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](url, options, defaults.options);
        normalizedOptions.resolveBodyOnly = false;
        const { pagination } = normalizedOptions;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].function(pagination.transform);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].function(pagination.shouldContinue);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].function(pagination.filter);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].function(pagination.paginate);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].number(pagination.countLimit);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].number(pagination.requestLimit);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].number(pagination.backoff);
        const allItems = [];
        let { countLimit } = pagination;
        let numberOfRequests = 0;
        while(numberOfRequests < pagination.requestLimit){
            if (numberOfRequests !== 0) {
                // eslint-disable-next-line no-await-in-loop
                await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$timers$2f$promises__$5b$external$5d$__$28$node$3a$timers$2f$promises$2c$__cjs$29$__["setTimeout"])(pagination.backoff);
            }
            // eslint-disable-next-line no-await-in-loop
            const response = await got(undefined, undefined, normalizedOptions);
            // eslint-disable-next-line no-await-in-loop
            const parsed = await pagination.transform(response);
            const currentItems = [];
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].array(parsed);
            for (const item of parsed){
                if (pagination.filter({
                    item,
                    currentItems,
                    allItems
                })) {
                    if (!pagination.shouldContinue({
                        item,
                        currentItems,
                        allItems
                    })) {
                        return;
                    }
                    yield item;
                    if (pagination.stackAllItems) {
                        allItems.push(item);
                    }
                    currentItems.push(item);
                    if (--countLimit <= 0) {
                        return;
                    }
                }
            }
            const optionsToMerge = pagination.paginate({
                response,
                currentItems,
                allItems
            });
            if (optionsToMerge === false) {
                return;
            }
            if (optionsToMerge === response.request.options) {
                normalizedOptions = response.request.options;
            } else {
                normalizedOptions.merge(optionsToMerge);
                try {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"].any([
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].urlInstance,
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$is$2f$distribution$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].undefined
                    ], optionsToMerge.url);
                } catch (error) {
                    if (error instanceof Error) {
                        error.message = `Option 'pagination.paginate.url': ${error.message}`;
                    }
                    throw error;
                }
                if (optionsToMerge.url !== undefined) {
                    normalizedOptions.prefixUrl = '';
                    normalizedOptions.url = optionsToMerge.url;
                }
            }
            numberOfRequests++;
        }
    };
    got.paginate = paginateEach;
    got.paginate.all = async (url, options)=>{
        const results = [];
        for await (const item of paginateEach(url, options)){
            results.push(item);
        }
        return results;
    };
    // For those who like very descriptive names
    got.paginate.each = paginateEach;
    // Stream API
    got.stream = (url, options)=>got(url, {
            ...options,
            isStream: true
        });
    // Shortcuts
    for (const method of aliases){
        got[method] = (url, options)=>got(url, {
                ...options,
                method
            });
        got.stream[method] = (url, options)=>got(url, {
                ...options,
                method,
                isStream: true
            });
    }
    if (!defaults.mutableDefaults) {
        Object.freeze(defaults.handlers);
        defaults.options.freeze();
    }
    Object.defineProperty(got, 'defaults', {
        value: defaults,
        writable: false,
        configurable: false,
        enumerable: true
    });
    return got;
};
const __TURBOPACK__default__export__ = create;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/node_modules/got/dist/source/index.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "got",
    ()=>got
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$create$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/create.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/got/dist/source/core/options.js [app-ssr] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$create$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__
]);
[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$create$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__;
;
;
const defaults = {
    options: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$core$2f$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](),
    handlers: [],
    mutableDefaults: false
};
const got = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$got$2f$dist$2f$source$2f$create$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(defaults);
const __TURBOPACK__default__export__ = got;
;
;
;
;
;
;
;
;
;
;
;
;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
];

//# sourceMappingURL=node_modules_got_dist_source_47b886ef._.js.map
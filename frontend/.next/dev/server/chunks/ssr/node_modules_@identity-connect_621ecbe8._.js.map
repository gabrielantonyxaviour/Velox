{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/crypto/src/encrDecr.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/crypto/src/errors.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/crypto/src/utils.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/crypto/src/securedEnvelope.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/crypto/src/serialization.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/crypto/src/walletAccounts.ts"],"sourcesContent":["// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Ed25519Signature, PublicKey, Signature } from '@aptos-labs/ts-sdk';\nimport { sha3_256 } from '@noble/hashes/sha3';\nimport ed2curve from 'ed2curve';\nimport nacl from 'tweetnacl';\nimport { DecryptionError } from './errors';\nimport {\n  concatUint8array,\n  decodeBase64,\n  Ed25519PublicKey,\n  Ed25519SecretKey,\n  encodeBase64,\n  KeyTypes,\n  toKey,\n  X25519PublicKey,\n  X25519SecretKey,\n} from './utils';\n\n// This callback takes in a message bytes, and signs it.\n// THIS DOES NOT PERFORM DOMAIN SEPARATION: IT IS ASSUMED OUR LIBRARY ALREADY DID IT.\n// This is to support hardware wallets.\nexport type SignCallback = (message: Uint8Array) => Promise<Signature>;\n\nexport type SignaturePurpose =\n  | 'TRANSPORT_KEYPAIR'\n  | 'ACCOUNT_INFO'\n  | 'SECURED_ENVELOPE';\n\nexport const SIGNATURE_PREFIX = 'APTOS::IDENTITY_CONNECT';\n\nexport type EncryptionResult = {\n  nonce: Uint8Array;\n  secured: Uint8Array;\n};\n\nexport type SerializedEncryptionResult = {\n  nonceB64: string;\n  securedB64: string;\n};\n\n/**\n * Converts an Ed25519 public key to an X25519 public key\n * HERE THERE BE DRAGONS. ONLY USE THIS IF YOU KNOW WHAT YOU ARE DOING.\n * @param ed25519PublicKey The Ed25519 public key to convert\n * @param errorKeyName The name of the key to use in error messages\n */\nexport function convertEd25519PublicKeyToX25519PublicKey(\n  ed25519PublicKey: Ed25519PublicKey,\n  errorKeyName: string,\n): X25519PublicKey {\n  const x25519PublicKey = ed2curve.convertPublicKey(\n    ed25519PublicKey.key.slice(0, 32),\n  );\n  if (!x25519PublicKey) {\n    throw new Error(`${errorKeyName} is not a valid Ed25519 public key`);\n  }\n  return toKey(x25519PublicKey, KeyTypes.X25519PublicKey);\n}\n\n/**\n * Converts an Ed25519 secret key to an X25519 secret key\n * HERE THERE BE DRAGONS. ONLY USE THIS IF YOU KNOW WHAT YOU ARE DOING.\n * @param ed25519SecretKey The Ed25519 secret key to convert\n */\nexport function convertEd25519SecretKeyToX25519SecretKey(\n  ed25519SecretKey: Ed25519SecretKey,\n): X25519SecretKey {\n  const x25519SecretKey = ed2curve.convertSecretKey(\n    ed25519SecretKey.key.slice(0, 32),\n  );\n  return toKey(x25519SecretKey, KeyTypes.X25519SecretKey);\n}\nexport function serializeEncryptionResult(\n  enc: EncryptionResult,\n): SerializedEncryptionResult {\n  return {\n    nonceB64: encodeBase64(enc.nonce),\n    securedB64: encodeBase64(enc.secured),\n  };\n}\n\nexport function deserializeEncryptionResult(\n  enc: SerializedEncryptionResult,\n): EncryptionResult {\n  return {\n    nonce: decodeBase64(enc.nonceB64),\n    secured: decodeBase64(enc.securedB64),\n  };\n}\n\n/**\n * Decrypts a `SerializedEncryptionResult` to an object\n * Uses the sender's X25519 public key and receiver's Ed25519 secret key\n * The receivers Ed25519 secret key is converted to an X25519 secret key for the Diffie-Hellman key exchange\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverEd25519SecretKey The receiver's Ed25519 secret key\n * @param enc The serialized encryption result\n */\nexport function decryptSerializedEncryptionResult<T>(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverEd25519SecretKey: Ed25519SecretKey,\n  enc: SerializedEncryptionResult,\n): T {\n  const des = deserializeEncryptionResult(enc);\n  return decryptObject<T>(\n    senderX25519PublicKey,\n    receiverEd25519SecretKey,\n    des.secured,\n    des.nonce,\n  );\n}\n\n/**\n * Decrypts a `SerializedEncryptionResult` to an object\n * Uses the sender's X25519 public key and receiver's X25519 secret key\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverX25519SecretKey The receiver's X25519 secret key\n * @param enc The serialized encryption result\n */\nexport function decryptSerializedEncryptionResultDirect<T>(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverX25519SecretKey: X25519SecretKey,\n  enc: SerializedEncryptionResult,\n): T {\n  const des = deserializeEncryptionResult(enc);\n  return decryptObjectDirect<T>(\n    senderX25519PublicKey,\n    receiverX25519SecretKey,\n    des.secured,\n    des.nonce,\n  );\n}\n\n/**\n * Encrypts a string, by using the sender's X25519 secret key and receiver's Ed25519 public key\n * The receiver's Ed25519 public key is converted to an X25519 public key for the Diffie-Hellman key exchange\n * @param senderX25519SecretKey The sender's X25519 secret key\n * @param receiverEd25519PublicKey The receiver's Ed25519 public key\n * @param message The message to encrypt\n */\nexport function encryptMessage(\n  senderX25519SecretKey: X25519SecretKey,\n  receiverEd25519PublicKey: Ed25519PublicKey,\n  message: string,\n): EncryptionResult {\n  // Encrypt the message with the receiver's public key and sender's secret key\n  const receiverX25519PublicKey = convertEd25519PublicKeyToX25519PublicKey(\n    receiverEd25519PublicKey,\n    'receiver public key',\n  );\n  return encryptMessageDirect(\n    senderX25519SecretKey,\n    receiverX25519PublicKey,\n    message,\n  );\n}\n\n/**\n * Encrypts a string, by using the sender's X25519 secret key and receiver's X25519 public key\n * @param senderX25519SecretKey The sender's X25519 secret key\n * @param receiverX25519PublicKey The receiver's X25519 public key\n * @param message The message to encrypt\n */\nexport function encryptMessageDirect(\n  senderX25519SecretKey: X25519SecretKey,\n  receiverX25519PublicKey: X25519PublicKey,\n  message: string,\n): EncryptionResult {\n  // Generate a random nonce\n  const nonce = nacl.randomBytes(nacl.box.nonceLength);\n\n  // Convert the message to a Uint8Array\n  const messageUint8 = new TextEncoder().encode(message);\n\n  const secured = nacl.box(\n    messageUint8,\n    nonce,\n    receiverX25519PublicKey.key,\n    senderX25519SecretKey.key.slice(0, 32),\n  );\n\n  return { nonce, secured };\n}\n\n/**\n * Encrypts an object to a string, by using the sender's X25519 secret key and receiver's Ed25519 public key\n * The receiver's Ed25519 public key is converted to an X25519 public key for the Diffie-Hellman key exchange\n * @param senderX25519SecretKey The sender's X25519 secret key\n * @param receiverEd25519PublicKey The receiver's Ed25519 public key\n * @param message The message to encrypt\n */\nexport function encryptObject<T>(\n  senderX25519SecretKey: X25519SecretKey,\n  receiverEd25519PublicKey: Ed25519PublicKey,\n  message: T,\n): EncryptionResult {\n  const receiverX25519PublicKey = convertEd25519PublicKeyToX25519PublicKey(\n    receiverEd25519PublicKey,\n    'receiver public key',\n  );\n  return encryptObjectDirect(\n    senderX25519SecretKey,\n    receiverX25519PublicKey,\n    message,\n  );\n}\n\n/**\n * Encrypts an object to a string, by using the sender's X25519 secret key and receiver's X25519 public key\n * @param senderX25519SecretKey The sender's X25519 secret key\n * @param receiverX25519PublicKey The receiver's X25519 public key\n * @param message The message to encrypt\n */\nexport function encryptObjectDirect<T>(\n  senderX25519SecretKey: X25519SecretKey,\n  receiverX25519PublicKey: X25519PublicKey,\n  message: T,\n): EncryptionResult {\n  return encryptMessageDirect(\n    senderX25519SecretKey,\n    receiverX25519PublicKey,\n    JSON.stringify(message),\n  );\n}\n\n/**\n * Decrypts a string, by using the sender's X25519 public key and receiver's Ed25519 secret key\n * The receivers Ed25519 secret key is converted to an X25519 secret key for the Diffie-Hellman key exchange\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverEd25519SecretKey The receiver's Ed25519 secret key\n * @param securedMessage The message to decrypt\n * @param nonce The nonce used to encrypt the message\n */\nexport function decryptMessage(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverEd25519SecretKey: Ed25519SecretKey,\n  securedMessage: Uint8Array,\n  nonce: Uint8Array,\n): string {\n  // Decrypt the message with the receiver's secret key and sender's public key\n  const receiverX25519SecretKey = convertEd25519SecretKeyToX25519SecretKey(\n    receiverEd25519SecretKey,\n  );\n  return decryptMessageDirect(\n    senderX25519PublicKey,\n    receiverX25519SecretKey,\n    securedMessage,\n    nonce,\n  );\n}\n\n/**\n * Decrypts a string, by using the sender's X25519 public key and receiver's X25519 secret key\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverX25519SecretKey The receiver's X25519 secret key\n * @param securedMessage The message to decrypt\n * @param nonce The nonce used to encrypt the message\n */\nexport function decryptMessageDirect(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverX25519SecretKey: X25519SecretKey,\n  securedMessage: Uint8Array,\n  nonce: Uint8Array,\n): string {\n  let decryptedUint8;\n  try {\n    decryptedUint8 = nacl.box.open(\n      securedMessage,\n      nonce,\n      senderX25519PublicKey.key.slice(0, 32),\n      receiverX25519SecretKey.key.slice(0, 32),\n    );\n  } catch (e: any) {\n    throw new DecryptionError(`Could not decrypt message: ${e.message}`);\n  }\n  if (!decryptedUint8) {\n    throw new DecryptionError('Could not decrypt message');\n  }\n\n  // Convert the decrypted Uint8Array back to a string\n  return new TextDecoder().decode(decryptedUint8);\n}\n\n/**\n * Decrypts an object, by using the sender's X25519 public key and receiver's Ed25519 secret key\n * The receivers Ed25519 secret key is converted to an X25519 secret key for the Diffie-Hellman key exchange\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverEd25519SecretKey The receiver's Ed25519 secret key\n * @param securedMessage The message to decrypt\n * @param nonce The nonce used to encrypt the message\n */\nexport function decryptObject<T>(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverEd25519SecretKey: Ed25519SecretKey,\n  securedMessage: Uint8Array,\n  nonce: Uint8Array,\n): T {\n  const receiverX25519SecretKey = convertEd25519SecretKeyToX25519SecretKey(\n    receiverEd25519SecretKey,\n  );\n  return decryptObjectDirect<T>(\n    senderX25519PublicKey,\n    receiverX25519SecretKey,\n    securedMessage,\n    nonce,\n  );\n}\n\n/**\n * Decrypts an object, by using the sender's X25519 public key and receiver's X25519 secret key\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverX25519SecretKey The receiver's X25519 secret key\n * @param securedMessage The message to decrypt\n * @param nonce The nonce used to encrypt the message\n */\nexport function decryptObjectDirect<T>(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverX25519SecretKey: X25519SecretKey,\n  securedMessage: Uint8Array,\n  nonce: Uint8Array,\n): T {\n  const decryptedStr = decryptMessageDirect(\n    senderX25519PublicKey,\n    receiverX25519SecretKey,\n    securedMessage,\n    nonce,\n  );\n  return JSON.parse(decryptedStr) as T;\n}\n\n/**\n * Hashes a message with a purpose-specific prefix using SHA-3 256-bit algorithm.\n * The purpose prefix is constructed as `'APTOS::IDENTITY_CONNECT' + '::' + purpose + '::'`\n * This is to prevent hash collisions with other services, uses, and purposes\n * @param message The message to hash as a Uint8Array.\n * @param purpose The purpose of the signature.\n * @returns Uint8Array The hashed message as a Uint8Array\n */\nexport function messageHash(message: Uint8Array, purpose: SignaturePurpose) {\n  const signaturePrefixHash = new Uint8Array(\n    sha3_256(`${SIGNATURE_PREFIX}::${purpose}::`),\n  );\n  return new Uint8Array(\n    sha3_256(concatUint8array(signaturePrefixHash, message)),\n  );\n}\n\nexport function signWithEd25519SecretKey(\n  message: Uint8Array,\n  signingEd25519SecretKey: Ed25519SecretKey,\n  purpose: SignaturePurpose,\n) {\n  return nacl.sign.detached(\n    messageHash(message, purpose),\n    signingEd25519SecretKey.key,\n  );\n}\n\n// This assumes that domain separation has already happened: this emulates the behavior of a hardware device\nexport function makeEd25519SecretKeySignCallbackNoDomainSeparation(\n  signingEd25519SecretKey: Ed25519SecretKey,\n): SignCallback {\n  return async (message: Uint8Array) =>\n    new Ed25519Signature(\n      nacl.sign.detached(message, signingEd25519SecretKey.key),\n    );\n}\n\nexport function verifySignature(\n  message: Uint8Array,\n  signature: Signature,\n  signingPublicKey: PublicKey,\n  purpose: SignaturePurpose,\n): boolean {\n  return signingPublicKey.verifySignature({\n    message: messageHash(message, purpose),\n    signature,\n  });\n}\n\nexport function hashAndVerifySignature(\n  message: string | Uint8Array,\n  signature: Signature,\n  signingPublicKey: PublicKey,\n  purpose: SignaturePurpose,\n): boolean {\n  const messageUint8 =\n    message instanceof Uint8Array ? message : new TextEncoder().encode(message);\n  const messageUint8Hash = sha3_256(messageUint8);\n  return verifySignature(\n    messageUint8Hash,\n    signature,\n    signingPublicKey,\n    purpose,\n  );\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport class EncryptionEnvelopeError extends Error {}\n\nexport class EnvelopeMessageMismatchError extends EncryptionEnvelopeError {\n  constructor(\n    message: string,\n    public field: string,\n  ) {\n    super(message);\n    this.name = 'EnvelopeMessageMismatchError';\n    Object.setPrototypeOf(this, EnvelopeMessageMismatchError.prototype);\n  }\n}\n\nexport class DecryptionError extends EncryptionEnvelopeError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'DecryptionError';\n    Object.setPrototypeOf(this, DecryptionError.prototype);\n  }\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport nacl from 'tweetnacl';\n\nexport enum KeyTypes {\n  Ed25519PublicKey = 'Ed25519PublicKey',\n  Ed25519SecretKey = 'Ed25519SecretKey',\n  X25519PublicKey = 'X25519PublicKey',\n  X25519SecretKey = 'X25519SecretKey',\n}\n\nexport interface IKey<Type extends KeyTypes> {\n  key: Uint8Array;\n  type: Type;\n}\n\nexport type X25519PublicKey = IKey<KeyTypes.X25519PublicKey>;\nexport type X25519SecretKey = IKey<KeyTypes.X25519SecretKey>;\nexport type X25519KeyPair = {\n  publicKey: X25519PublicKey;\n  secretKey: X25519SecretKey;\n};\n\nexport type Ed25519PublicKey = IKey<KeyTypes.Ed25519PublicKey>;\nexport type Ed25519SecretKey = IKey<KeyTypes.Ed25519SecretKey>;\nexport type Ed25519KeyPair = {\n  publicKey: Ed25519PublicKey;\n  secretKey: Ed25519SecretKey;\n};\n\nexport type RawKeyPair = {\n  publicKey: Uint8Array;\n  secretKey: Uint8Array;\n};\n\nexport function createX25519KeyPair(): X25519KeyPair {\n  return keypairToX25519(nacl.box.keyPair());\n}\n\nexport function createEd25519KeyPair(): Ed25519KeyPair {\n  return keypairToEd25519(nacl.sign.keyPair());\n}\n\nexport function toKey<Type extends KeyTypes = KeyTypes>(\n  rawKey: Uint8Array,\n  type: Type,\n): Type extends KeyTypes.Ed25519PublicKey\n  ? Ed25519PublicKey\n  : Type extends KeyTypes.Ed25519SecretKey\n    ? Ed25519SecretKey\n    : Type extends KeyTypes.X25519PublicKey\n      ? X25519PublicKey\n      : Type extends KeyTypes.X25519SecretKey\n        ? X25519SecretKey\n        : never {\n  return {\n    key: rawKey,\n    type,\n  } as any;\n}\n\nexport function keypairToEd25519(keyPair: RawKeyPair): Ed25519KeyPair {\n  return {\n    publicKey: toKey(keyPair.publicKey, KeyTypes.Ed25519PublicKey),\n    secretKey: toKey(keyPair.secretKey, KeyTypes.Ed25519SecretKey),\n  };\n}\n\nexport function keypairToX25519(keyPair: RawKeyPair): X25519KeyPair {\n  return {\n    publicKey: toKey(keyPair.publicKey, KeyTypes.X25519PublicKey),\n    secretKey: toKey(keyPair.secretKey, KeyTypes.X25519SecretKey),\n  };\n}\n\nexport function aptosAccountToEd25519Keypair(account: {\n  signingKey: nacl.SignKeyPair;\n}) {\n  return ed25519KeypairFromSecret(account.signingKey.secretKey);\n}\n\nexport function ed25519KeypairFromSecret(\n  ed25519SecretKeyBytes: Uint8Array,\n): Ed25519KeyPair {\n  return keypairToEd25519(\n    nacl.sign.keyPair.fromSeed(ed25519SecretKeyBytes.slice(0, 32)),\n  );\n}\n\nexport function decodeBase64(base64Str: string): Uint8Array {\n  if (globalThis.Buffer) {\n    return new Uint8Array(Buffer.from(base64Str, 'base64'));\n  }\n  return Uint8Array.from(atob(base64Str), (m) => m.codePointAt(0)!);\n}\n\nexport function encodeBase64(bytes: Uint8Array): string {\n  if (globalThis.Buffer) {\n    return Buffer.from(bytes).toString('base64');\n  }\n  return btoa(Array.from(bytes, (x) => String.fromCodePoint(x)).join(''));\n}\n\nexport function concatUint8array(\n  arrayOne: Uint8Array,\n  arrayTwo: Uint8Array,\n): Uint8Array {\n  const mergedArray = new Uint8Array(arrayOne.length + arrayTwo.length);\n  mergedArray.set(arrayOne);\n  mergedArray.set(arrayTwo, arrayOne.length);\n  return mergedArray;\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  Ed25519PublicKey as AptosEd25519PublicKey,\n  Ed25519Signature,\n  Hex,\n} from '@aptos-labs/ts-sdk';\nimport { sha3_256 } from '@noble/hashes/sha3';\nimport {\n  decryptObject,\n  deserializeEncryptionResult,\n  encryptObject,\n  SerializedEncryptionResult,\n  SignCallback,\n  serializeEncryptionResult,\n  signWithEd25519SecretKey,\n  verifySignature,\n} from './encrDecr';\nimport { EnvelopeMessageMismatchError } from './errors';\nimport {\n  createX25519KeyPair,\n  decodeBase64,\n  Ed25519PublicKey,\n  Ed25519SecretKey,\n  encodeBase64,\n  KeyTypes,\n  toKey,\n  X25519KeyPair,\n  X25519PublicKey,\n} from './utils';\n\n/**\n * When sending messages back and forth, there are some things that Identity Connect must know to function and provide\n * security for users, and dApps and wallets need to know that any messages sent to one another were sent (and\n * received) by the expected parties.\n *\n * To allow for secure communication between parties, we are introducing the\n * *SecuredEnvelope*. This envelope provides a secure channel for parties to encrypt private messages, *and*\n * authenticate one another, while allowing IC to route requests and block invalid messages.\n *\n * The envelope can be thought of as a wrapper around the JSON payload of a POST/PUT request T, and has two parts:\n * `messagePrivate`: This contains some of the parameters of `T`, which will be signed by the sender and encrypted\n *                   with the recipient's public key.\n * `publicMessage`: This field is sent unencrypted, but signed so that the IC endpoint can do basic validation before\n *                  processing. The parameters in `publicMessage` are DISJOINT from `messagePrivate`, and are invalid\n *                  otherwise: there are no keys in `messagePrivate` that also appear in `publicMessage`. It must\n *                  contain a ``_metadata`` field with security features like the timestamp, public keys, sequence\n *                  number, etc.\n *\n * Both IC and dApps can verify, on chain, that the senders’ keys match their address and that they are speaking\n * with who they expect. Encryption is done with an X25519 key derived from the ED25519 PublicKey of the wallet\n * account that is connecting (this allows for seamless cross-device account access), and an ephemeral X25519 KeyPair,\n * of which the SecretKey is thrown away after encryption. Decryption uses the X25519 key derived from the receiver\n * ED25519 SecretKey.\n *\n * Account private keys Ska (and their counterpart X25519 keys) are only used to decrypt and sign:\n * THEY ARE NEVER USED TO ENCRYPT!\n *\n * Operations follow the Cryptographic Doom Principle:\n *   Always verify the signature of the message before any other cryptographic operations\n * https://moxie.org/2011/12/13/the-cryptographic-doom-principle.html\n *\n *\n * To send a `SecuredEnvelope` over the wire, it must first be turned into a `SecuredEnvelopeTransport` - this\n * involves:\n * 1. Encrypting and serializing the `privateMessage` field to an `encryptedPrivateMessage`field.\n *     a. Generate ephemeral X25519 sender keypair `xPkse/xSkse`. The `xPkse` becomes the `senderX25519PublicKeyB64` in\n *      the `EnvelopeMetadata`.\n *     b. Convert the `receiverEd25519PublicKey` to a `receiverX25519PublicKey` - `xPkr`\n *     c. Generate a random `nonce` for the `[nacl.box](http://nacl.box)` encryption\n *     d. Encrypt the `privateMessage` using `[nacl.box](http://nacl.box)` with the `xSkse` and `xPkr`\n *     e. Package this encrypted data, and the `nonce`, into a `SerializedEncryptionResult`\n * 2. JSON serializing the `publicMessage` field into a `serializedPublicMessage`. We don’t care about canonical\n *    serialization/ordering as the sender signs over this serialized string.\n * 3.  Now that we have the private `encryptedPrivateMessage` and public `serializedPublicMessage` we can generate the\n *    `messageSignature`:\n *     a. Hash the `SHA3-256(encryptedPublicMessage)` to get `publicMessageHash`\n *     b. Hash the `SHA3-256(encryptedPrivateMessage)` to get `privateMessageHash`\n *     c. Hash `SHA3-256(publicMessageHash | privateMessageHash)` to get `combinedMessageHash`\n *     d. Get the `domainSeparatedMessageHash` by hashing the `combinedMessageHash` with a domain separator:\n *        `SHA3-256(SHA3-256('APTOS::IDENTITY_CONNECT::') | combinedMessageHash)`\n *     e. To obtain the final `messageSignature`, we sign the `domainSeparatedMessageHash` with the Ed25519 private\n *        key of the sender, and hex encode it.\n * 4. This creates the final `SecuredEnvelopeTransport` object, ready to be JSON serialized and sent in an HTTP\n *    request\n */\n\nexport const REQUIRED_FIELDS: (keyof EnvelopeMetadata)[] = [\n  'receiverEd25519PublicKeyB64',\n  'senderEd25519PublicKeyB64',\n  'senderX25519PublicKeyB64',\n  'sequence',\n  'timestampMillis',\n].sort() as (keyof EnvelopeMetadata)[];\n\n// The publicMessage._metadata field looks like this:\nexport type EnvelopeMetadata = {\n  // The receiver's public key, base64\n  receiverEd25519PublicKeyB64: string;\n  // The sender public key, base64\n  senderEd25519PublicKeyB64: string;\n  // The senders X25519 public key, base64\n  senderX25519PublicKeyB64: string;\n  // The sequence of the sender.\n  // This number only goes up, to prevent relay attacks\n  // This exists per pairing\n  // dApps, wallets, accounts, etc are expected to keep track of them\n  // IC will reject out-of-order sequence numbers\n  sequence: number;\n  // The timestamp this message was sent at\n  // IC will reject if it's in the future or older than 5 minutes\n  timestampMillis: number;\n};\n\nexport interface IEnvelopeMetadata extends Message {\n  _metadata: EnvelopeMetadata;\n}\n\n// A message- whether the `Public` or `Private` component- is a JSON object.\n// As such, we know that the keys are strings, and the values are any JSON-serializable type ('unknown')\nexport type Message = Record<string, unknown>;\n\nexport type SecuredEnvelope<Public extends Message> = {\n  encryptedPrivateMessage: SerializedEncryptionResult;\n  messageSignature: string;\n  publicMessage: Public & IEnvelopeMetadata;\n};\n\nexport type SecuredEnvelopeTransport = {\n  encryptedPrivateMessage: SerializedEncryptionResult;\n  messageSignature: string;\n  serializedPublicMessage: string;\n};\n\nexport type DecryptedEnvelope<\n  Public extends Message & { [K in keyof Private]?: never },\n  Private extends Message & { [K in keyof Public]?: never },\n> = {\n  messageSignature: string;\n  privateMessage: Private;\n  publicMessage: Public & IEnvelopeMetadata;\n};\n\nexport type DeserializedTransportEnvelope<Public extends Message> =\n  SecuredEnvelopeTransport & SecuredEnvelope<Public>;\n\nexport type SignCallbackOrEd25519SecretKey = SignCallback | Ed25519SecretKey;\n\nexport function ensurePrivatePublicFieldsDisjoint<\n  Public extends Message & { [K in keyof Private]?: never },\n  Private extends Message & { [K in keyof Public]?: never },\n>(privateMessage: Private, publicMessage: Public) {\n  // gets all fields in privateMessage that are also in publicMessage\n  const intersection = Object.keys(privateMessage).filter((x) =>\n    Object.keys(publicMessage).includes(x),\n  );\n  if (intersection.length > 0) {\n    const field = intersection[0];\n    throw new EnvelopeMessageMismatchError(\n      `Field ${field} appears in both private and public message fields`,\n      field,\n    );\n  }\n}\n\nexport function ensureMetadataFields(message: EnvelopeMetadata) {\n  // ensure ONLY the fields in REQUIRED_FIELDS are present in message. Sort asc.\n  const messageKeys = Object.keys(message).sort();\n  const extraFields = messageKeys.filter(\n    (key) => !REQUIRED_FIELDS.includes(key as any),\n  );\n  const missingFields = REQUIRED_FIELDS.filter(\n    (key) => !messageKeys.includes(key as any),\n  );\n  if (extraFields.length > 0 || missingFields.length > 0) {\n    let extraFieldsStr =\n      extraFields.length > 0 ? `extra(${extraFields.join(', ')})` : '';\n    const missingFieldsStr =\n      missingFields.length > 0 ? `missing(${missingFields.join(', ')})` : '';\n    extraFieldsStr =\n      extraFieldsStr.length > 0 && missingFieldsStr.length > 0\n        ? `${extraFieldsStr}, `\n        : extraFieldsStr;\n    throw new EnvelopeMessageMismatchError(\n      `PublicMessage metadata fields do not conform to spec: ${extraFieldsStr}${missingFieldsStr}`,\n      '_metadata',\n    );\n  }\n}\n\nexport function deserializeTransportEnvelope<Public extends Message>(\n  transportEnvelope: SecuredEnvelopeTransport,\n): DeserializedTransportEnvelope<Public> {\n  const publicMessage = JSON.parse(\n    transportEnvelope.serializedPublicMessage,\n  ) as Public & IEnvelopeMetadata;\n  return {\n    ...transportEnvelope,\n    publicMessage,\n  };\n}\n\n// This signs with the senders ed25519 private key,\n// but encrypts with an ephemeral X25519 keyPair + the receivers x25519 public key (converted from their ed25519 key)\n// This is so that the private key IS ONLY EVER USED FOR DECRYPTION, NEVER FOR ENCRYPTION\nexport function encryptAndSignEnvelope<\n  Public extends Message & { [K in keyof Private]?: never },\n  Private extends Message & { [K in keyof Public]?: never },\n>(\n  senderEd25519SecretKey: Ed25519SecretKey,\n  senderEd25519PublicKey: Ed25519PublicKey,\n  receiverEd25519PublicKey: Ed25519PublicKey,\n  sequence: number,\n  publicMessage: Public,\n  privateMessage: Private,\n): SecuredEnvelopeTransport {\n  const senderEphemeralX25519KeyPair = createX25519KeyPair();\n  const metadata = constructMetadata(\n    senderEd25519PublicKey,\n    receiverEd25519PublicKey,\n    sequence,\n    senderEphemeralX25519KeyPair.publicKey,\n  );\n\n  ensureMetadataFields(metadata);\n  ensurePrivatePublicFieldsDisjoint<Public, Private>(\n    privateMessage,\n    publicMessage,\n  );\n\n  return dangerouslyEncryptAndSignEnvelopeUnvalidated(\n    senderEd25519SecretKey,\n    receiverEd25519PublicKey,\n    metadata,\n    privateMessage,\n    publicMessage,\n    senderEphemeralX25519KeyPair,\n  );\n}\n\nexport function constructMetadata(\n  senderEd25519PublicKey: Ed25519PublicKey,\n  receiverEd25519PublicKey: Ed25519PublicKey,\n  sequence: number,\n  senderEphemeralX25519PublicKey: X25519PublicKey,\n): EnvelopeMetadata {\n  // This is used for SIGNING ONLY!\n  return {\n    receiverEd25519PublicKeyB64: encodeBase64(receiverEd25519PublicKey.key),\n    senderEd25519PublicKeyB64: encodeBase64(senderEd25519PublicKey.key),\n    senderX25519PublicKeyB64: encodeBase64(senderEphemeralX25519PublicKey.key),\n    sequence,\n    timestampMillis: Date.now(),\n  };\n}\n\nexport function dangerouslyEncryptAndSignEnvelopeUnvalidated<\n  Public extends Message & { [K in keyof Private]?: never },\n  Private extends Message & { [K in keyof Public]?: never },\n>(\n  senderEd25519SecretKey: Ed25519SecretKey,\n  receiverEd25519PublicKey: Ed25519PublicKey,\n  metadata: EnvelopeMetadata,\n  privateMessage: Private,\n  publicMessage: Public,\n  senderEphemeralX25519KeyPair: X25519KeyPair,\n): SecuredEnvelopeTransport {\n  const encryptionResult = encryptObject(\n    senderEphemeralX25519KeyPair.secretKey,\n    receiverEd25519PublicKey,\n    privateMessage,\n  );\n  const encryptedPrivateMessage = serializeEncryptionResult(encryptionResult);\n  const encryptedPrivateMessageBytes = decodeBase64(\n    encryptedPrivateMessage.securedB64,\n  );\n  const serializedPublicMessage = JSON.stringify({\n    ...publicMessage,\n    _metadata: metadata,\n  });\n  const publicMessageBytes = new TextEncoder().encode(serializedPublicMessage);\n  const messageSignature = signEnvelope(\n    publicMessageBytes,\n    encryptedPrivateMessageBytes,\n    senderEd25519SecretKey,\n  );\n  return {\n    encryptedPrivateMessage,\n    messageSignature,\n    serializedPublicMessage,\n  };\n}\n\nfunction combineHashedEnvelopeMessageBytes(\n  publicMessageBytes: Uint8Array,\n  privateMessageBytes: Uint8Array,\n): Uint8Array {\n  const publicMessageBytesHash = sha3_256(publicMessageBytes);\n  const privateMessageBytesHash = sha3_256(privateMessageBytes);\n  // Concatenate the two hashes\n  const combinedHash = new Uint8Array(\n    publicMessageBytesHash.length + privateMessageBytesHash.length,\n  );\n  combinedHash.set(publicMessageBytesHash);\n  combinedHash.set(privateMessageBytesHash, publicMessageBytesHash.length);\n  // Hash and return\n  return sha3_256(combinedHash);\n}\n\nfunction signEnvelope(\n  publicMessageBytes: Uint8Array,\n  privateMessageBytes: Uint8Array,\n  senderEd25519SecretKey: Ed25519SecretKey,\n) {\n  const messageHashBytes = combineHashedEnvelopeMessageBytes(\n    publicMessageBytes,\n    privateMessageBytes,\n  );\n  const signatureBytes = signWithEd25519SecretKey(\n    messageHashBytes,\n    senderEd25519SecretKey,\n    'SECURED_ENVELOPE',\n  );\n  return Hex.fromHexInput(signatureBytes).toString();\n}\n\nexport function verifyEnvelopeSignature(\n  publicMessageBytes: Uint8Array,\n  privateMessageBytes: Uint8Array,\n  messageSignatureInput: string,\n  senderEd25519PublicKey: Ed25519PublicKey,\n) {\n  const messageSignature = new Ed25519Signature(\n    Hex.fromHexInput(messageSignatureInput).toUint8Array(),\n  );\n  const senderPublicKey = new AptosEd25519PublicKey(senderEd25519PublicKey.key);\n  const messageHashBytes = combineHashedEnvelopeMessageBytes(\n    publicMessageBytes,\n    privateMessageBytes,\n  );\n  const messageVerified = verifySignature(\n    messageHashBytes,\n    messageSignature,\n    senderPublicKey,\n    'SECURED_ENVELOPE',\n  );\n  if (!messageVerified) {\n    throw new EnvelopeMessageMismatchError(\n      'Could not verify SecuredEnvelope signature',\n      'messageSignature',\n    );\n  }\n}\n\nexport function decryptEnvelope<\n  Public extends Message & { [K in keyof Private]?: never },\n  Private extends Message & { [K in keyof Public]?: never },\n>(\n  senderEd25519PublicKey: Ed25519PublicKey,\n  receiverEd25519SecretKey: Ed25519SecretKey,\n  message: SecuredEnvelopeTransport,\n): DecryptedEnvelope<Public, Private> {\n  const { encryptedPrivateMessage, messageSignature, serializedPublicMessage } =\n    message;\n  const publicMessage = JSON.parse(serializedPublicMessage) as Public &\n    IEnvelopeMetadata;\n\n  // Ensure the private/public message signature matches the expected signature\n  const rawPrivateMessage = decodeBase64(encryptedPrivateMessage.securedB64);\n  const rawPublicMessage = new TextEncoder().encode(serializedPublicMessage);\n  verifyEnvelopeSignature(\n    rawPublicMessage,\n    rawPrivateMessage,\n    messageSignature,\n    senderEd25519PublicKey,\n  );\n\n  // Ensure the public key matches the expected public key\n  const senderEd25519PublicKeyB64 = encodeBase64(senderEd25519PublicKey.key);\n  const expectedPublicKeyB64 =\n    publicMessage._metadata.senderEd25519PublicKeyB64;\n  if (senderEd25519PublicKeyB64 !== expectedPublicKeyB64) {\n    throw new EnvelopeMessageMismatchError(\n      'senderEd25519PublicKey in envelope does not match provided receiverEd25519SecretKey',\n      'senderPublicKey',\n    );\n  }\n\n  const senderX25519PublicKeyBytes = decodeBase64(\n    publicMessage._metadata.senderX25519PublicKeyB64,\n  );\n  const senderX25519PublicKey = toKey(\n    senderX25519PublicKeyBytes,\n    KeyTypes.X25519PublicKey,\n  );\n  const encryptionResult = deserializeEncryptionResult(encryptedPrivateMessage);\n  const privateMessage = decryptObject<Private>(\n    senderX25519PublicKey,\n    receiverEd25519SecretKey,\n    encryptionResult.secured,\n    encryptionResult.nonce,\n  );\n\n  ensureMetadataFields(publicMessage._metadata);\n  ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage);\n\n  return {\n    messageSignature,\n    privateMessage,\n    publicMessage,\n  };\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  base64ToBytes,\n  bytesToBase64,\n  deserializePublicKey,\n  deserializeSignature,\n  serializePublicKey,\n  serializeSignature,\n} from '@aptos-connect/wallet-api';\nimport {\n  AccountPublicKey,\n  Ed25519PublicKey as AptosEd25519PublicKey,\n  Deserializer,\n  Ed25519Signature,\n  Hex,\n  PublicKey,\n  Serializer,\n  Signature,\n} from '@aptos-labs/ts-sdk';\nimport { decodeBase64 } from './utils';\n\nexport function serializePublicKeyB64(publicKey: PublicKey) {\n  const serializer = new Serializer();\n  serializePublicKey(serializer, publicKey);\n  return bytesToBase64(serializer.toUint8Array());\n}\n\nexport function deserializePublicKeyB64(publicKeyB64: string) {\n  const serializedPublicKey = base64ToBytes(publicKeyB64);\n  const deserializer = new Deserializer(serializedPublicKey);\n  return deserializePublicKey(deserializer) as AccountPublicKey;\n}\n\nexport function deserializeEd25519PublicKeyB64(ed25519PublicKeyB64: string) {\n  return new AptosEd25519PublicKey(decodeBase64(ed25519PublicKeyB64));\n}\n\nexport function serializeSignatureB64(signature: Signature) {\n  const serializer = new Serializer();\n  serializeSignature(serializer, signature);\n  return bytesToBase64(serializer.toUint8Array());\n}\n\nexport function deserializeSignatureB64(signatureB64: string) {\n  const serializedSignature = base64ToBytes(signatureB64);\n  const deserializer = new Deserializer(serializedSignature);\n  return deserializeSignature(deserializer);\n}\n\nexport function deserializeEd25519SignatureB64(ed25519SignatureB64: string) {\n  const signatureBytes = Hex.fromHexInput(ed25519SignatureB64).toUint8Array();\n  return new Ed25519Signature(signatureBytes);\n}\n\nexport function publicKeyB64FromEd25519PublicKeyB64(\n  ed25519PublicKeyB64: string,\n) {\n  const publicKey = deserializeEd25519PublicKeyB64(ed25519PublicKeyB64);\n  return serializePublicKeyB64(publicKey);\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\n// Adding or removing an account? This will be idempotent, but racy\nimport {\n  Account,\n  AccountPublicKey,\n  PublicKey as AptosPublicKey,\n  Signature,\n} from '@aptos-labs/ts-sdk';\nimport { sha3_256 } from '@noble/hashes/sha3';\nimport { messageHash, signWithEd25519SecretKey } from './encrDecr';\nimport { serializePublicKeyB64, serializeSignatureB64 } from './serialization';\nimport {\n  Ed25519KeyPair,\n  Ed25519PublicKey,\n  Ed25519SecretKey,\n  ed25519KeypairFromSecret,\n  encodeBase64,\n} from './utils';\n\n// ADD/REMOVE is used for account connections\nexport enum AccountConnectionAction {\n  ADD = 'add',\n  REMOVE = 'remove',\n}\n\n/**\n * When a wallet wants to create a pairing, or add/remove an account from a wallet connection, it must prove that it\n * has the secret key for a given account. To do so it uses an `AccountConnectInfo` object.\n *  1. Once the `AccountConnectInfo` is assembled, it’s JSON serialized to get a `accountInfoSerialized` string.\n *  2. We then domain separate and hash the `accountInfoSerialized` to get the `accountInfoHash`:\n *    `SHA3-256(SHA3-256('APTOS::IDENTITY_CONNECT::') | SHA3-256(accountInfoSerialized))`\n *  3. To obtain the `signature`, we sign the `accountInfoHash` with the Ed25519 private key of the sender, and hex\n *     encode it.\n *  4. These are assembled into an `AccountConnectInfoSerialized`, ready to be sent in an HTTP request.\n */\n\nexport type BaseAccountConnectInfo = {\n  // The account address\n  accountAddress: string;\n  // either 'add' or 'remove'\n  action: AccountConnectionAction;\n  // A unique identifier for this connection: it is either the walletId or the pairingId\n  // Prevents replay attacks across wallets\n  intentId: string;\n  // Prevents replay attacks across time- these are only valid for 5 minutes\n  timestampMillis: number;\n  // The public key for the encrypted e2e channel, base64\n  transportEd25519PublicKeyB64: string;\n};\n\nexport type Ed25519AccountConnectInfo = BaseAccountConnectInfo & {\n  // The account ed25519 public key, base64\n  ed25519PublicKeyB64: string;\n  publicKeyB64?: undefined;\n};\n\nexport type AnyAccountConnectInfo = BaseAccountConnectInfo & {\n  ed25519PublicKeyB64?: undefined;\n  // The account public key, bcs-serialized and base64-encoded\n  publicKeyB64: string;\n};\n\n// Ensuring compatibility with previous wallet-sdk versions\nexport type AccountConnectInfo =\n  | Ed25519AccountConnectInfo\n  | AnyAccountConnectInfo;\n\nexport type Ed25519AccountConnectInfoSerialized = {\n  accountInfoSerialized: string;\n  signature: string;\n  signatureB64?: undefined;\n};\n\nexport type AnyAccountConnectInfoSerialized = {\n  accountInfoSerialized: string;\n  signature?: undefined;\n  signatureB64: string;\n};\n\nexport type AccountConnectInfoSerialized =\n  | Ed25519AccountConnectInfoSerialized\n  | AnyAccountConnectInfoSerialized;\n\nexport type SyncSignCallback = (message: Uint8Array) => Signature;\nexport type AsyncSignCallback = (message: Uint8Array) => Promise<Signature>;\nexport type AnySignCallback = SyncSignCallback | AsyncSignCallback;\n\nexport function deriveAccountTransportEd25519Keypair(\n  ed25519SecretKey: Ed25519SecretKey,\n  publicKey: Ed25519PublicKey | AptosPublicKey,\n): Ed25519KeyPair;\n\nexport function deriveAccountTransportEd25519Keypair(\n  signCallback: SyncSignCallback,\n  publicKey: Ed25519PublicKey | AptosPublicKey,\n): Ed25519KeyPair;\n\nexport async function deriveAccountTransportEd25519Keypair(\n  signCallback: AsyncSignCallback,\n  publicKey: Ed25519PublicKey | AptosPublicKey,\n): Promise<Ed25519KeyPair>;\n\nexport function deriveAccountTransportEd25519Keypair(\n  signCallback: AnySignCallback,\n  publicKey: Ed25519PublicKey | AptosPublicKey,\n): Ed25519KeyPair | Promise<Ed25519KeyPair>;\n\nexport function deriveAccountTransportEd25519Keypair(\n  ed25519SecretKeyOrSignCallback: Ed25519SecretKey | AnySignCallback,\n  publicKey: Ed25519PublicKey | AptosPublicKey,\n) {\n  const publicKeyBytes =\n    publicKey instanceof AptosPublicKey\n      ? publicKey.toUint8Array()\n      : publicKey.key;\n  if (ed25519SecretKeyOrSignCallback instanceof Function) {\n    const seedGeneratorBytes = messageHash(publicKeyBytes, 'TRANSPORT_KEYPAIR');\n    const signature = ed25519SecretKeyOrSignCallback(seedGeneratorBytes);\n    if (signature instanceof Promise) {\n      return signature.then((value) =>\n        ed25519KeypairFromSecret(value.toUint8Array()),\n      );\n    }\n    return ed25519KeypairFromSecret(signature.toUint8Array());\n  }\n\n  const seedBytes = signWithEd25519SecretKey(\n    publicKeyBytes,\n    ed25519SecretKeyOrSignCallback,\n    'TRANSPORT_KEYPAIR',\n  );\n  return ed25519KeypairFromSecret(seedBytes);\n}\n\nexport type CreateSerializedAccountInfoArgs<\n  TSignCallback extends AnySignCallback,\n> = [\n  signCallback: TSignCallback,\n  publicKey: AccountPublicKey,\n  transportEd25519PublicKey: Ed25519PublicKey,\n  action: AccountConnectionAction,\n  intentId: string,\n  accountAddress?: string,\n];\n\nexport function createSerializedAccountInfo(\n  ...args: CreateSerializedAccountInfoArgs<SyncSignCallback>\n): AccountConnectInfoSerialized;\nexport function createSerializedAccountInfo(\n  ...args: CreateSerializedAccountInfoArgs<AsyncSignCallback>\n): Promise<AccountConnectInfoSerialized>;\nexport function createSerializedAccountInfo(\n  ...args: CreateSerializedAccountInfoArgs<AnySignCallback>\n): AccountConnectInfoSerialized | Promise<AccountConnectInfoSerialized>;\n\nexport function createSerializedAccountInfo(\n  ...[\n    signCallback,\n    publicKey,\n    transportEd25519PublicKey,\n    action,\n    intentId,\n    accountAddress,\n  ]: CreateSerializedAccountInfoArgs<AnySignCallback>\n): AccountConnectInfoSerialized | Promise<AccountConnectInfoSerialized> {\n  // TODO: WRITE TESTS FOR THIS!\n\n  // Either the passed in Pk, or the Pk derived from the Sk\n  const authKey = publicKey.authKey();\n\n  // Either the passed in account address, or the one derived from the authKey: (either Pk, or derived from Sk)\n  const finalAccountAddress =\n    accountAddress || authKey.derivedAddress().toString();\n  const publicKeyB64 = serializePublicKeyB64(publicKey);\n\n  const accountInfo: AccountConnectInfo = {\n    accountAddress: finalAccountAddress,\n    action,\n    intentId,\n    publicKeyB64,\n    timestampMillis: Date.now(),\n    transportEd25519PublicKeyB64: encodeBase64(transportEd25519PublicKey.key),\n  };\n  const accountInfoSerialized = JSON.stringify(accountInfo);\n  const accountInfoBytes = new TextEncoder().encode(accountInfoSerialized);\n  const accountInfoHash = sha3_256(accountInfoBytes);\n\n  const signature = signCallback(messageHash(accountInfoHash, 'ACCOUNT_INFO'));\n  if (signature instanceof Promise) {\n    return signature.then((value) => ({\n      accountInfoSerialized,\n      signatureB64: serializeSignatureB64(value),\n    }));\n  }\n  return {\n    accountInfoSerialized,\n    signatureB64: serializeSignatureB64(signature),\n  };\n}\n\nexport async function aptosAccountToSerializedInfo(\n  account: Account,\n  intentId: string,\n): Promise<AccountConnectInfoSerialized> {\n  const signCallback = async (data: Uint8Array) => account.sign(data);\n  const transportKey = await deriveAccountTransportEd25519Keypair(\n    signCallback,\n    account.publicKey,\n  );\n  return createSerializedAccountInfo(\n    signCallback,\n    account.publicKey,\n    transportKey.publicKey,\n    AccountConnectionAction.ADD,\n    intentId,\n  );\n}\n"],"names":["nacl","KeyTypes","nacl","Ed25519Signature","sha3_256","sha3_256","Ed25519Signature","AptosEd25519PublicKey","Ed25519Signature","Hex","AptosEd25519PublicKey","Hex","Ed25519Signature","sha3_256","AccountConnectionAction","sha3_256"],"mappings":"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"}},
    {"offset": {"line": 517, "column": 0}, "map": {"version":3,"sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/api/src/constants.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/api/src/errors.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/api/src/network.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/api/src/types/pairing.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/api/src/types/signingRequest.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/api/src/types/wallet.ts"],"sourcesContent":["// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport const DEFAULT_BACKEND_URL = 'https://identityconnect.com';\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport const AuthError = {\n  missing_client: 'missing_client',\n  redirect_mismatch: 'redirect_mismatch',\n  state_mismatch: 'state_mismatch',\n} as const;\n\nexport const AuthErrorMessages: Record<\n  keyof typeof AuthError,\n  { code: number; description: string; shortMessage: string }\n> = {\n  [AuthError.state_mismatch]: {\n    code: 0,\n    description: 'State mismatch',\n    shortMessage: 'An error occurred while logging in, please try again.',\n  },\n  [AuthError.redirect_mismatch]: {\n    code: 1,\n    description: 'Redirect mismatch',\n    shortMessage: 'An error occurred while logging in, please try again.',\n  },\n  [AuthError.missing_client]: {\n    code: 2,\n    description: 'Missing client',\n    shortMessage: 'An error occurred while logging in, please try again.',\n  },\n} as const;\n\nexport const isAuthError = (code: string): code is keyof typeof AuthError =>\n  Object.values(AuthError).includes(code as any);\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport enum NetworkName {\n  DEVNET = 'devnet',\n  MAINNET = 'mainnet',\n  TESTNET = 'testnet',\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountData } from './account';\nimport { RegisteredDappDataBase } from './dapp';\nimport { DappSpecificWallet } from './dappSpecificWallet';\nimport { ConnectedWalletData } from './wallet';\n\nexport enum PairingStatus {\n  Finalized = 'FINALIZED',\n  Pending = 'PENDING',\n}\n\nexport interface BasePairingData {\n  createdAt: Date;\n  dappEd25519PublicKeyB64: string;\n  dappSpecificWallet?: DappSpecificWallet;\n  dappSpecificWalletId?: string;\n  expiresAt: Date;\n  id: string;\n  maxDappSequenceNumber: number;\n  maxWalletSequenceNumber: number;\n  registeredDapp: RegisteredDappDataBase;\n  registeredDappId: string;\n  status: PairingStatus;\n  updatedAt: Date;\n}\n\nexport interface NewPairingData extends BasePairingData {\n  maxDappSequenceNumber: -1;\n  maxWalletSequenceNumber: -1;\n  status: PairingStatus.Pending;\n}\n\nexport interface BaseFinalizedPairingData extends BasePairingData {\n  account: AccountData;\n  accountId: string;\n  status: PairingStatus.Finalized;\n  walletName: string;\n}\n\nexport interface AnonymousPairingData extends BaseFinalizedPairingData {\n  anonymousWallet: ConnectedWalletData;\n  anonymousWalletId: string;\n}\n\nexport type FinalizedPairingData =\n  | BaseFinalizedPairingData\n  | AnonymousPairingData;\nexport type PairingData = NewPairingData | FinalizedPairingData;\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { RegisteredDappDataBase } from './dapp';\n\n// region Duplicated from crypto to prevent dependency cycle\n\nexport type SerializedEncryptionResult = {\n  nonceB64: string;\n  securedB64: string;\n};\n\nexport type SecuredEnvelopeTransport = {\n  encryptedPrivateMessage: SerializedEncryptionResult;\n  messageSignature: string;\n  serializedPublicMessage: string;\n};\n\n// endregion\n\nexport enum SigningRequestTypes {\n  SIGN_AND_SUBMIT_TRANSACTION = 'SIGN_AND_SUBMIT_TRANSACTION',\n  SIGN_MESSAGE = 'SIGN_MESSAGE',\n  SIGN_TRANSACTION = 'SIGN_TRANSACTION',\n}\n\nexport enum SigningRequestStatus {\n  APPROVED = 'APPROVED',\n  CANCELLED = 'CANCELLED',\n  INVALID = 'INVALID',\n  PENDING = 'PENDING',\n  REJECTED = 'REJECTED',\n}\n\nexport interface SigningRequestData {\n  apiVersion: string;\n  createdAt: Date;\n  id: string;\n  networkName: string | null;\n  pairing: {\n    registeredDapp: RegisteredDappDataBase;\n  };\n  pairingId: string;\n  requestEnvelope: SecuredEnvelopeTransport;\n  requestType: SigningRequestTypes;\n  responseEnvelope?: SecuredEnvelopeTransport;\n  status: SigningRequestStatus;\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { AccountData } from './account';\nimport { DappSpecificWallet } from './dappSpecificWallet';\nimport type { AnonymousPairingData } from './pairing';\n\nexport enum WalletOSEnum {\n  Android = 'android',\n  IdentityConnect = 'ic',\n  Linux = 'linux',\n  Macos = 'osx',\n  Windows = 'win',\n  iOS = 'ios',\n}\n\nexport enum WalletPlatformEnum {\n  BraveExtension = 'brave-extension',\n  ChromeExtension = 'chrome-extension',\n  FirefoxExtension = 'firefox-extension',\n  /// Reserved for IC full custody\n  IcDappWallet = 'ic-dapp-wallet',\n  KiwiExtension = 'kiwi-extension',\n  NativeApp = 'native-app',\n  OperaExtension = 'opera-extension',\n  SafariExtension = 'safari-extension',\n}\n\nexport type WalletOS = `${WalletOSEnum}`;\nexport type WalletPlatform = `${WalletPlatformEnum}`;\n\nexport interface BaseWalletData {\n  createdAt: Date;\n  dappSpecificWallet?: DappSpecificWallet;\n  dappSpecificWalletId?: string;\n  icEd25519PublicKeyB64: string;\n  id: string;\n  updatedAt: Date;\n}\n\nexport interface NewWalletData extends BaseWalletData {\n  walletEd25519PublicKeyB64: null;\n}\n\nexport interface BaseConnectedWalletData extends BaseWalletData {\n  accounts: AccountData[];\n  deviceIdentifier: string;\n  platform: WalletPlatform;\n  platformOS: WalletOS;\n  userSubmittedAlias?: string;\n  walletEd25519PublicKeyB64: string;\n  walletName: string;\n}\n\nexport interface AuthenticatedWalletData extends BaseConnectedWalletData {\n  anonymousPairing: null;\n  user: { id: string; username: string };\n  userId: string;\n}\n\nexport interface AnonymousWalletData extends BaseConnectedWalletData {\n  anonymousPairing: AnonymousPairingData;\n  userId: null;\n}\n\nexport type ConnectedWalletData = AuthenticatedWalletData | AnonymousWalletData;\n\nexport type WalletData = NewWalletData | ConnectedWalletData;\n"],"names":["NetworkName","PairingStatus","SigningRequestTypes","SigningRequestStatus","WalletOSEnum","WalletPlatformEnum"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAGO,IAAM,sBAAsB;;ACA5B,IAAM,YAAY;IACvB,gBAAgB;IAChB,mBAAmB;IACnB,gBAAgB;AAClB;AAEO,IAAM,oBAGT;IACF,CAAC,UAAU,cAAc,CAAA,EAAG;QAC1B,MAAM;QACN,aAAa;QACb,cAAc;IAChB;IACA,CAAC,UAAU,iBAAiB,CAAA,EAAG;QAC7B,MAAM;QACN,aAAa;QACb,cAAc;IAChB;IACA,CAAC,UAAU,cAAc,CAAA,EAAG;QAC1B,MAAM;QACN,aAAa;QACb,cAAc;IAChB;AACF;AAEO,IAAM,cAAc,CAAC,OAC1B,OAAO,MAAA,CAAO,SAAS,EAAE,QAAA,CAAS,IAAW;;AC5BxC,IAAK,cAAL,aAAA,GAAA,CAAA,CAAKA,iBAAL;IACLA,YAAAA,CAAA,SAAA,GAAS;IACTA,YAAAA,CAAA,UAAA,GAAU;IACVA,YAAAA,CAAA,UAAA,GAAU;IAHA,OAAAA;AAAA,CAAA,EAAA,eAAA,CAAA;;ACKL,IAAK,gBAAL,aAAA,GAAA,CAAA,CAAKC,mBAAL;IACLA,cAAAA,CAAA,YAAA,GAAY;IACZA,cAAAA,CAAA,UAAA,GAAU;IAFA,OAAAA;AAAA,CAAA,EAAA,iBAAA,CAAA;;ACYL,IAAK,sBAAL,aAAA,GAAA,CAAA,CAAKC,yBAAL;IACLA,oBAAAA,CAAA,8BAAA,GAA8B;IAC9BA,oBAAAA,CAAA,eAAA,GAAe;IACfA,oBAAAA,CAAA,mBAAA,GAAmB;IAHT,OAAAA;AAAA,CAAA,EAAA,uBAAA,CAAA;AAML,IAAK,uBAAL,aAAA,GAAA,CAAA,CAAKC,0BAAL;IACLA,qBAAAA,CAAA,WAAA,GAAW;IACXA,qBAAAA,CAAA,YAAA,GAAY;IACZA,qBAAAA,CAAA,UAAA,GAAU;IACVA,qBAAAA,CAAA,UAAA,GAAU;IACVA,qBAAAA,CAAA,WAAA,GAAW;IALD,OAAAA;AAAA,CAAA,EAAA,wBAAA,CAAA;;ACnBL,IAAK,eAAL,aAAA,GAAA,CAAA,CAAKC,kBAAL;IACLA,aAAAA,CAAA,UAAA,GAAU;IACVA,aAAAA,CAAA,kBAAA,GAAkB;IAClBA,aAAAA,CAAA,QAAA,GAAQ;IACRA,aAAAA,CAAA,QAAA,GAAQ;IACRA,aAAAA,CAAA,UAAA,GAAU;IACVA,aAAAA,CAAA,MAAA,GAAM;IANI,OAAAA;AAAA,CAAA,EAAA,gBAAA,CAAA;AASL,IAAK,qBAAL,aAAA,GAAA,CAAA,CAAKC,wBAAL;IACLA,mBAAAA,CAAA,iBAAA,GAAiB;IACjBA,mBAAAA,CAAA,kBAAA,GAAkB;IAClBA,mBAAAA,CAAA,mBAAA,GAAmB;IAEnBA,mBAAAA,CAAA,eAAA,GAAe;IACfA,mBAAAA,CAAA,gBAAA,GAAgB;IAChBA,mBAAAA,CAAA,YAAA,GAAY;IACZA,mBAAAA,CAAA,iBAAA,GAAiB;IACjBA,mBAAAA,CAAA,kBAAA,GAAkB;IATR,OAAAA;AAAA,CAAA,EAAA,sBAAA,CAAA"}},
    {"offset": {"line": 622, "column": 0}, "map": {"version":3,"sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/wallet-api/src/serialization/bcsSerialization.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/wallet-api/src/serialization/jsonPayload.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/wallet-api/src/serialization/error.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/wallet-api/src/serialization/rawTxn.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/wallet-api/src/serialization/signAndSubmitTransactionRequestArgs.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/wallet-api/src/serialization/signTransactionRequestArgs.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/wallet-api/src/serialization/signTransactionResponseArgs.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/wallet-api/src/utils/makeFullMessage.ts"],"sourcesContent":["// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Deserializer, Hex, Serializable } from '@aptos-labs/ts-sdk';\n\nexport type BcsDeserializableV2Class<T extends Serializable> = {\n  deserialize(deserializer: Deserializer): T;\n};\n\n/**\n * Check if a value is BCS serializable\n */\nexport function isBcsSerializable(value: any): value is Serializable {\n  return (\n    (value as Serializable)?.serialize !== undefined &&\n    (value as Serializable)?.bcsToBytes !== undefined &&\n    (value as Serializable)?.bcsToHex !== undefined\n  );\n}\n\nexport function bcsSerialize(serializable: Serializable) {\n  return serializable.bcsToHex().toString();\n}\n\nexport function bcsDeserialize<T extends Serializable>(\n  deserializableClass: BcsDeserializableV2Class<T>,\n  serializedValue: string,\n) {\n  const serializedValueBytes =\n    Hex.fromHexString(serializedValue).toUint8Array();\n  const deserializer = new Deserializer(serializedValueBytes);\n  return deserializableClass.deserialize(deserializer);\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { EntryFunctionPayloadResponse } from '@aptos-labs/ts-sdk';\nimport { Hex } from '@aptos-labs/ts-sdk';\nimport type {\n  EntryFunctionJsonTransactionPayload,\n  JsonTransactionPayload,\n} from '../types';\nimport { UnexpectedValueError } from './error';\n\ninterface SerializedUint8ArrayArg {\n  type: 'Uint8Array';\n  value: string;\n}\n\nfunction isSerializedUint8Array(arg: any): arg is SerializedUint8ArrayArg {\n  return arg?.type === 'Uint8Array' && typeof arg?.value === 'string';\n}\n\nfunction serializeEntryFunctionArg(arg: any): any {\n  if (arg instanceof Uint8Array) {\n    return {\n      type: 'Uint8Array',\n      value: Hex.fromHexInput(arg).toString(),\n    };\n  }\n  if (Array.isArray(arg)) {\n    return arg.map(serializeEntryFunctionArg);\n  }\n  return arg;\n}\n\nfunction deserializeEntryFunctionArg(arg: any): any {\n  if (isSerializedUint8Array(arg)) {\n    return Hex.fromHexInput(arg.value).toUint8Array();\n  }\n  if (Array.isArray(arg)) {\n    return arg.map(deserializeEntryFunctionArg);\n  }\n  return arg;\n}\n\nfunction serializeEntryFunctionPayload(\n  payload: EntryFunctionPayloadResponse,\n): EntryFunctionJsonTransactionPayload {\n  const normalizedArgs = payload.arguments.map(serializeEntryFunctionArg);\n  return {\n    ...payload,\n    arguments: normalizedArgs,\n    type: 'entry_function_payload',\n  };\n}\n\nfunction deserializeEntryFunctionPayload(\n  payload: EntryFunctionPayloadResponse,\n): EntryFunctionJsonTransactionPayload {\n  const deserializedArgs = payload.arguments.map(deserializeEntryFunctionArg);\n  return {\n    ...payload,\n    arguments: deserializedArgs,\n    type: 'entry_function_payload',\n  };\n}\n\nexport function serializeJsonTransactionPayload(\n  payload: JsonTransactionPayload,\n): JsonTransactionPayload {\n  if (payload.type === 'entry_function_payload' || payload.type === undefined) {\n    return serializeEntryFunctionPayload(payload);\n  }\n  if (payload.type === 'multisig_payload') {\n    const innerPayload =\n      payload.transaction_payload !== undefined\n        ? serializeEntryFunctionPayload(payload.transaction_payload)\n        : undefined;\n    return { ...payload, transaction_payload: innerPayload };\n  }\n  throw new UnexpectedValueError();\n}\n\nexport function deserializeJsonTransactionPayload(\n  payload: JsonTransactionPayload,\n): JsonTransactionPayload {\n  if (payload.type === 'entry_function_payload' || payload.type === undefined) {\n    return deserializeEntryFunctionPayload(payload);\n  }\n  if (payload.type === 'multisig_payload') {\n    const innerPayload =\n      payload.transaction_payload !== undefined\n        ? deserializeEntryFunctionPayload(payload.transaction_payload)\n        : undefined;\n    return { ...payload, transaction_payload: innerPayload };\n  }\n  throw new UnexpectedValueError();\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport class UnexpectedValueError extends Error {\n  constructor(message?: string) {\n    super(message);\n    this.name = 'UnexpectedValueError';\n    Object.setPrototypeOf(this, UnexpectedValueError.prototype);\n  }\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  FeePayerRawTransaction,\n  MultiAgentRawTransaction,\n  RawTransaction,\n  RawTransactionWithData,\n} from '@aptos-labs/ts-sdk';\nimport { bcsDeserialize, bcsSerialize } from './bcsSerialization';\nimport { UnexpectedValueError } from './error';\n\nexport type SerializableRawTransaction =\n  | RawTransaction\n  | FeePayerRawTransaction\n  | MultiAgentRawTransaction;\n\nexport interface SerializedSimpleRawTransaction {\n  type: 'raw_txn';\n  value: string;\n}\n\nexport interface SerializedFeePayerRawTransaction {\n  type: 'fee_payer_raw_txn';\n  value: string;\n}\n\nexport interface SerializedMultiAgentRawTransaction {\n  type: 'multi_agent_raw_txn';\n  value: string;\n}\n\nexport type SerializedRawTransaction =\n  | SerializedSimpleRawTransaction\n  | SerializedFeePayerRawTransaction\n  | SerializedMultiAgentRawTransaction;\n\nexport function serializeRawTransaction(\n  rawTxn: RawTransaction,\n): SerializedSimpleRawTransaction;\nexport function serializeRawTransaction(\n  rawTxn: FeePayerRawTransaction,\n): SerializedFeePayerRawTransaction;\nexport function serializeRawTransaction(\n  rawTxn: MultiAgentRawTransaction,\n): SerializedMultiAgentRawTransaction;\nexport function serializeRawTransaction(\n  rawTxn: SerializableRawTransaction,\n): SerializedRawTransaction;\n\nexport function serializeRawTransaction(\n  rawTxn: SerializableRawTransaction,\n): SerializedRawTransaction {\n  const value = bcsSerialize(rawTxn);\n  if ('fee_payer_address' in rawTxn) {\n    return { type: 'fee_payer_raw_txn', value };\n  }\n  if ('secondary_signer_addresses' in rawTxn) {\n    return { type: 'multi_agent_raw_txn', value };\n  }\n  if ('chain_id' in rawTxn) {\n    return { type: 'raw_txn', value };\n  }\n  throw new UnexpectedValueError('Invalid raw transaction type');\n}\n\nexport function deserializeRawTransaction(\n  serialized: SerializedSimpleRawTransaction,\n): RawTransaction;\nexport function deserializeRawTransaction(\n  serialized: SerializedFeePayerRawTransaction,\n): FeePayerRawTransaction;\nexport function deserializeRawTransaction(\n  serialized: SerializedMultiAgentRawTransaction,\n): MultiAgentRawTransaction;\nexport function deserializeRawTransaction(\n  serialized: SerializedRawTransaction,\n): SerializableRawTransaction;\n\nexport function deserializeRawTransaction(\n  serialized: SerializedRawTransaction,\n): SerializableRawTransaction {\n  switch (serialized.type) {\n    case 'raw_txn':\n      return bcsDeserialize(RawTransaction, serialized.value);\n    case 'fee_payer_raw_txn':\n      return bcsDeserialize(\n        RawTransactionWithData,\n        serialized.value,\n      ) as FeePayerRawTransaction;\n    case 'multi_agent_raw_txn':\n      return bcsDeserialize(\n        RawTransactionWithData,\n        serialized.value,\n      ) as MultiAgentRawTransaction;\n    default:\n      throw new UnexpectedValueError('Invalid raw transaction type');\n  }\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountAuthenticator, TransactionPayload } from '@aptos-labs/ts-sdk';\nimport type {\n  SignAndSubmitTransactionRequestArgs,\n  SignAndSubmitTransactionWithFeePayerRawTxnRequestArgs,\n  SignAndSubmitTransactionWithPayloadRequestArgs,\n  SignAndSubmitTransactionWithRawTxnRequestArgs,\n} from '../types';\nimport { JsonTransactionPayload, TransactionOptions } from '../types';\nimport {\n  bcsDeserialize,\n  bcsSerialize,\n  isBcsSerializable,\n} from './bcsSerialization';\n\nimport { UnexpectedValueError } from './error';\nimport {\n  deserializeJsonTransactionPayload,\n  serializeJsonTransactionPayload,\n} from './jsonPayload';\nimport {\n  deserializeRawTransaction,\n  type SerializedFeePayerRawTransaction,\n  type SerializedSimpleRawTransaction,\n  serializeRawTransaction,\n} from './rawTxn';\n\nexport interface SerializedSignAndSubmitTransactionWithPayloadRequestArgs {\n  options?: TransactionOptions;\n  payload: JsonTransactionPayload | string;\n}\n\nexport interface SerializedSignAndSubmitTransactionWithRawTxnRequestArgs {\n  rawTxn: SerializedSimpleRawTransaction;\n}\n\nexport interface SerializedSignAndSubmitTransactionWithFeePayerRawTxnRequestArgs {\n  feePayerAuthenticator: string;\n  rawTxn: SerializedFeePayerRawTransaction;\n}\n\nexport type SerializedSignAndSubmitTransactionRequestArgs =\n  | SerializedSignAndSubmitTransactionWithPayloadRequestArgs\n  | SerializedSignAndSubmitTransactionWithRawTxnRequestArgs\n  | SerializedSignAndSubmitTransactionWithFeePayerRawTxnRequestArgs;\n\nexport function serializeSignAndSubmitTransactionRequestArgs(\n  args: SignAndSubmitTransactionRequestArgs,\n): SerializedSignAndSubmitTransactionRequestArgs {\n  if ('payload' in args) {\n    const serializedPayload = isBcsSerializable(args.payload)\n      ? bcsSerialize(args.payload)\n      : serializeJsonTransactionPayload(args.payload);\n    return { options: args.options, payload: serializedPayload };\n  }\n  if ('feePayerAuthenticator' in args) {\n    return {\n      feePayerAuthenticator: bcsSerialize(args.feePayerAuthenticator),\n      rawTxn: serializeRawTransaction(args.rawTxn),\n    };\n  }\n  if ('rawTxn' in args) {\n    return { rawTxn: serializeRawTransaction(args.rawTxn) };\n  }\n  throw new UnexpectedValueError();\n}\n\nexport function deserializeSignAndSubmitTransactionRequestArgs(\n  args: SerializedSignAndSubmitTransactionWithPayloadRequestArgs,\n): SignAndSubmitTransactionWithPayloadRequestArgs;\nexport function deserializeSignAndSubmitTransactionRequestArgs(\n  args: SerializedSignAndSubmitTransactionWithRawTxnRequestArgs,\n): SignAndSubmitTransactionWithRawTxnRequestArgs;\nexport function deserializeSignAndSubmitTransactionRequestArgs(\n  args: SerializedSignAndSubmitTransactionWithFeePayerRawTxnRequestArgs,\n): SignAndSubmitTransactionWithFeePayerRawTxnRequestArgs;\nexport function deserializeSignAndSubmitTransactionRequestArgs(\n  args: SerializedSignAndSubmitTransactionRequestArgs,\n): SignAndSubmitTransactionRequestArgs;\n\nexport function deserializeSignAndSubmitTransactionRequestArgs(\n  args: SerializedSignAndSubmitTransactionRequestArgs,\n): SignAndSubmitTransactionRequestArgs {\n  if ('payload' in args) {\n    const payload =\n      typeof args.payload === 'string'\n        ? bcsDeserialize(TransactionPayload, args.payload)\n        : deserializeJsonTransactionPayload(args.payload);\n    return { options: args.options, payload };\n  }\n  if ('feePayerAuthenticator' in args) {\n    const deserializedRawTxn = deserializeRawTransaction(args.rawTxn);\n    const feePayerAuthenticator = bcsDeserialize(\n      AccountAuthenticator,\n      args.feePayerAuthenticator,\n    );\n    return { feePayerAuthenticator, rawTxn: deserializedRawTxn };\n  }\n  if ('rawTxn' in args) {\n    const deserializedRawTxn = deserializeRawTransaction(args.rawTxn);\n    return { rawTxn: deserializedRawTxn };\n  }\n  throw new UnexpectedValueError();\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { TransactionPayload } from '@aptos-labs/ts-sdk';\nimport type {\n  JsonTransactionPayload,\n  SignTransactionRequestArgs,\n  SignTransactionWithPayloadRequestArgs,\n  SignTransactionWithRawTxnRequestArgs,\n  TransactionOptions,\n} from '../types';\nimport {\n  bcsDeserialize,\n  bcsSerialize,\n  isBcsSerializable,\n} from './bcsSerialization';\nimport { UnexpectedValueError } from './error';\nimport {\n  deserializeJsonTransactionPayload,\n  serializeJsonTransactionPayload,\n} from './jsonPayload';\nimport type { SerializedRawTransaction } from './rawTxn';\nimport { deserializeRawTransaction, serializeRawTransaction } from './rawTxn';\n\nexport interface SerializedSignTransactionWithPayloadRequestArgs {\n  options?: TransactionOptions;\n  payload: JsonTransactionPayload | string;\n}\n\nexport interface SerializedSignTransactionWithRawTxnRequestArgs {\n  rawTxn: SerializedRawTransaction;\n}\n\nexport type SerializedSignTransactionRequestArgs =\n  | SerializedSignTransactionWithPayloadRequestArgs\n  | SerializedSignTransactionWithRawTxnRequestArgs;\n\nexport function serializeSignTransactionRequestArgs(\n  args: SignTransactionRequestArgs,\n): SerializedSignTransactionRequestArgs {\n  if ('payload' in args) {\n    const serializedPayload = isBcsSerializable(args.payload)\n      ? bcsSerialize(args.payload)\n      : serializeJsonTransactionPayload(args.payload);\n    return { options: args.options, payload: serializedPayload };\n  }\n  if ('rawTxn' in args) {\n    const serializedRawTxn = serializeRawTransaction(args.rawTxn);\n    return { rawTxn: serializedRawTxn };\n  }\n  throw new UnexpectedValueError();\n}\n\nexport function deserializeSignTransactionRequestArgs(\n  args: SerializedSignTransactionWithPayloadRequestArgs,\n): SignTransactionWithPayloadRequestArgs;\nexport function deserializeSignTransactionRequestArgs(\n  args: SerializedSignTransactionWithRawTxnRequestArgs,\n): SignTransactionWithRawTxnRequestArgs;\nexport function deserializeSignTransactionRequestArgs(\n  args: SerializedSignTransactionRequestArgs,\n): SignTransactionRequestArgs;\n\nexport function deserializeSignTransactionRequestArgs(\n  args: SerializedSignTransactionRequestArgs,\n): SignTransactionRequestArgs {\n  if ('payload' in args) {\n    const payload =\n      typeof args.payload === 'string'\n        ? bcsDeserialize(TransactionPayload, args.payload)\n        : deserializeJsonTransactionPayload(args.payload);\n    return { options: args.options, payload };\n  }\n  if ('rawTxn' in args) {\n    const deserializedRawTxn = deserializeRawTransaction(args.rawTxn);\n    return { rawTxn: deserializedRawTxn };\n  }\n  throw new UnexpectedValueError();\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountAuthenticator, RawTransaction } from '@aptos-labs/ts-sdk';\nimport type { SignTransactionResponseArgs } from '../types';\nimport { bcsDeserialize, bcsSerialize } from './bcsSerialization';\n\nexport interface SerializedSignTransactionWithPayloadResponseArgs {\n  accountAuthenticator: string;\n  rawTxn: string;\n}\n\nexport interface SerializedSignTransactionWithRawTxnResponseArgs {\n  accountAuthenticator: string;\n}\n\nexport type SerializedSignTransactionResponseArgs =\n  | SerializedSignTransactionWithPayloadResponseArgs\n  | SerializedSignTransactionWithRawTxnResponseArgs;\n\nexport function serializeSignTransactionResponseArgs(\n  args: SignTransactionResponseArgs,\n): SerializedSignTransactionResponseArgs {\n  const accountAuthenticator = bcsSerialize(args.accountAuthenticator);\n  if ('rawTxn' in args) {\n    const rawTxn = bcsSerialize(args.rawTxn);\n    return { accountAuthenticator, rawTxn };\n  }\n  return { accountAuthenticator };\n}\n\nexport function deserializeSignTransactionResponseArgs(\n  args: SerializedSignTransactionResponseArgs,\n): SignTransactionResponseArgs {\n  const accountAuthenticator = bcsDeserialize(\n    AccountAuthenticator,\n    args.accountAuthenticator,\n  );\n  if ('rawTxn' in args) {\n    const rawTxn = bcsDeserialize(RawTransaction, args.rawTxn);\n    return { accountAuthenticator, rawTxn };\n  }\n  return { accountAuthenticator };\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport type {\n  FullMessageFlags,\n  FullMessageParams,\n  FullMessageResult,\n} from '../types';\n\nconst prefix = 'APTOS';\n\nexport function makeFullMessage(\n  params: FullMessageParams,\n  flags: FullMessageFlags,\n): FullMessageResult {\n  let fullMessage = prefix;\n  if (flags.address) {\n    fullMessage += `\\naddress: ${params.address}`;\n  }\n  if (flags.application) {\n    fullMessage += `\\napplication: ${params.application}`;\n  }\n  if (flags.chainId) {\n    fullMessage += `\\nchainId: ${params.chainId}`;\n  }\n\n  fullMessage += `\\nmessage: ${params.message}`;\n  fullMessage += `\\nnonce: ${params.nonce}`;\n\n  return {\n    fullMessage,\n    prefix,\n  };\n}\n"],"names":["Hex","Hex","TransactionPayload","TransactionPayload","AccountAuthenticator","RawTransaction","AccountAuthenticator","RawTransaction"],"mappings":"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"}},
    {"offset": {"line": 933, "column": 0}, "map": {"version":3,"sources":["file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/dapp-sdk/src/ACDappClient.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/dapp-sdk/src/constants.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/dapp-sdk/src/conversion.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/dapp-sdk/src/PairingClient.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/dapp-sdk/src/errors.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/dapp-sdk/src/state.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/dapp-sdk/src/utils.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/dapp-sdk/src/ICDappClient.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/dapp-sdk/src/prompt.ts","file:///Users/gabrielantonyxaviour/Documents/starters/movement/Velox/frontend/node_modules/%40identity-connect/dapp-sdk/src/KeylessClient.ts"],"sourcesContent":["// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  ConnectRequest,\n  ConnectResponse,\n  chainIdToNetwork,\n  type DappInfo,\n  DisconnectRequest,\n  GetConnectedAccountsRequest,\n  GetConnectedAccountsResponse,\n  makeUserApproval,\n  SignAndSubmitTransactionRequest,\n  SignAndSubmitTransactionResponse,\n  SignInRequest,\n  SignInResponse,\n  SignMessageRequest,\n  SignMessageResponse,\n  SignTransactionRequest,\n  SignTransactionResponse,\n  shelbynet,\n  UserApproval,\n  UserDismissal,\n} from '@aptos-connect/wallet-api';\nimport { WebWalletTransport } from '@aptos-connect/web-transport';\nimport {\n  AccountAddress,\n  AccountAddressInput,\n  AnySignature,\n  AptosConfig,\n  Deserializer,\n  Ed25519Signature,\n  FeePayerRawTransaction,\n  generateRawTransaction,\n  Hex,\n} from '@aptos-labs/ts-sdk';\nimport { NetworkName } from '@identity-connect/api';\nimport { createEd25519KeyPair, encodeBase64 } from '@identity-connect/crypto';\nimport { SignAndSubmitTransactionRequestArgs } from '@identity-connect/wallet-api';\nimport { DEFAULT_FRONTEND_URL } from './constants';\nimport { normalizePayloadForIC } from './conversion';\nimport { ACPairingClient } from './PairingClient';\n\nexport interface WithSignerAddress {\n  signerAddress: AccountAddress;\n}\n\nexport interface ACDappClientConfig {\n  backendBaseURL?: string;\n  dappId?: string;\n  dappImageURI?: string;\n  dappName?: string;\n  // Only used for remote wallet pairings (to be deprecated)\n  defaultNetworkName?: NetworkName;\n  frontendBaseURL?: string;\n  provider?: 'google' | 'apple';\n  tgWebAppURL?: string;\n}\n\nexport class ACDappClient {\n  readonly dappInfo: DappInfo;\n\n  private readonly transport: WebWalletTransport;\n\n  private readonly dappId?: string;\n  private readonly pairingClient: ACPairingClient;\n\n  constructor({\n    backendBaseURL,\n    dappId,\n    dappImageURI,\n    dappName,\n    defaultNetworkName = NetworkName.MAINNET,\n    frontendBaseURL = DEFAULT_FRONTEND_URL,\n    provider = 'google',\n    tgWebAppURL,\n  }: ACDappClientConfig = {}) {\n    this.dappInfo = {\n      domain: window.location.origin,\n      imageURI: dappImageURI,\n      name: dappName ?? document.title,\n    };\n\n    this.transport = new WebWalletTransport(\n      frontendBaseURL,\n      provider,\n      tgWebAppURL,\n    );\n\n    this.dappId = dappId;\n    this.pairingClient = new ACPairingClient({\n      axiosConfig: {\n        baseURL: backendBaseURL ?? frontendBaseURL,\n      },\n      defaultNetworkName,\n    });\n  }\n\n  // region Public API\n\n  private async getKeylessAccounts() {\n    const serializedRequest = GetConnectedAccountsRequest.serialize(\n      this.dappInfo,\n    );\n    const serializedResponse =\n      await this.transport.sendRequest(serializedRequest);\n    const response =\n      GetConnectedAccountsResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  private async getIcAccounts() {\n    return (await this.pairingClient.getConnectedAccounts()) ?? [];\n  }\n\n  private async isIcAccount(address: AccountAddressInput) {\n    const icAccounts = await this.getIcAccounts();\n    return (\n      icAccounts.find((account) =>\n        account.address.equals(AccountAddress.from(address)),\n      ) !== undefined\n    );\n  }\n\n  async getConnectedAccounts() {\n    const keylessAccounts = await this.getKeylessAccounts();\n    const icAccounts = await this.getIcAccounts();\n    return [...keylessAccounts, ...icAccounts];\n  }\n\n  async disconnect(address: AccountAddressInput) {\n    if (await this.isIcAccount(address)) {\n      const stringAddress = AccountAddress.from(address).toString();\n      await this.pairingClient.disconnect(stringAddress);\n    } else {\n      const serializedRequest = DisconnectRequest.serialize(this.dappInfo);\n      await this.transport.sendRequest(serializedRequest);\n    }\n  }\n\n  async connect({\n    claimOptions,\n    preferredWalletName,\n  }: Omit<ConnectRequest.Args, 'dappId' | 'dappEd25519PublicKeyB64'> = {}) {\n    const dappKeypair = createEd25519KeyPair();\n    const injectedPreferredWalletName =\n      typeof window !== 'undefined'\n        ? (window as any).AC_PREFERRED_WALLET_NAME\n        : undefined;\n\n    const requestArgs = {\n      claimOptions,\n      dappEd25519PublicKeyB64: encodeBase64(dappKeypair.publicKey.key),\n      dappId: this.dappId,\n      preferredWalletName: preferredWalletName ?? injectedPreferredWalletName,\n    } satisfies ConnectRequest.Args;\n\n    const serializedRequest = ConnectRequest.serialize(\n      this.dappInfo,\n      requestArgs,\n    );\n    const serializedResponse =\n      await this.transport.sendRequest(serializedRequest);\n    const response = ConnectResponse.deserialize(serializedResponse);\n\n    if (response.args.status === 'approved') {\n      const { account, pairing } = response.args.args;\n      if (pairing) {\n        await this.pairingClient.addPairing(dappKeypair, pairing);\n      }\n      return makeUserApproval({ account });\n    }\n    return response.args;\n  }\n\n  async signIn(\n    args: SignInRequest.Args,\n  ): Promise<UserDismissal | UserApproval<SignInResponse.ApprovalArgs>> {\n    const serializedRequest = SignInRequest.serialize(this.dappInfo, args);\n    const serializedResponse =\n      await this.transport.sendRequest(serializedRequest);\n\n    const response = SignInResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signMessage(args: SignMessageRequest.Args & WithSignerAddress) {\n    const { signerAddress } = args;\n\n    if (await this.isIcAccount(signerAddress)) {\n      const { chainId } = args;\n      const network = chainIdToNetwork(chainId) as string;\n\n      let message: string;\n      let nonce: string;\n      try {\n        message = new TextDecoder().decode(args.message);\n        nonce = new TextDecoder().decode(args.nonce);\n      } catch (_err) {\n        throw new Error('Only UTF-8 encoded text is supported when using IC');\n      }\n\n      const { fullMessage, signature: hexSignature } =\n        await this.pairingClient.signMessage(\n          signerAddress.toString(),\n          {\n            address: true,\n            application: true,\n            chainId: true,\n            message,\n            nonce,\n          },\n          { networkName: network as NetworkName },\n        );\n\n      const signatureBytes = Hex.fromHexInput(hexSignature).toUint8Array();\n      const signature =\n        signatureBytes.length === Ed25519Signature.LENGTH\n          ? new Ed25519Signature(signatureBytes)\n          : AnySignature.deserialize(new Deserializer(signatureBytes));\n      return makeUserApproval<SignMessageResponse.ApprovalArgs>({\n        fullMessage,\n        signature,\n      });\n    }\n    const serializedRequest = SignMessageRequest.serialize(this.dappInfo, args);\n    const serializedResponse =\n      await this.transport.sendRequest(serializedRequest);\n    const response = SignMessageResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signTransaction(\n    args: (\n      | SignTransactionRequest.Args\n      | SignTransactionRequest.ArgsWithTransaction\n    ) &\n      WithSignerAddress,\n  ): Promise<SignTransactionResponse.Args> {\n    const normalizedArgs =\n      'transaction' in args ? SignTransactionRequest.normalizeArgs(args) : args;\n    const { signerAddress } = args;\n\n    if (await this.isIcAccount(signerAddress)) {\n      const {\n        expirationSecondsFromNow,\n        expirationTimestamp,\n        feePayer,\n        gasUnitPrice,\n        maxGasAmount,\n        network,\n        payload,\n        secondarySigners,\n        sender,\n        sequenceNumber,\n      } = normalizedArgs;\n\n      if (feePayer !== undefined) {\n        throw new Error('Sponsored transaction not currently supported');\n      }\n\n      if (secondarySigners && secondarySigners.length > 0) {\n        throw new Error('Multi-agent transactions not currently supported');\n      }\n\n      if (!('bcsToBytes' in payload)) {\n        throw new Error(\n          'Payload input format is only supported with Keyless accounts.',\n        );\n      }\n\n      const responseArgs = await this.pairingClient.signTransaction(\n        signerAddress.toString(),\n        {\n          options: {\n            expirationSecondsFromNow,\n            expirationTimestamp,\n            gasUnitPrice,\n            maxGasAmount,\n            sender: sender?.address.toString(),\n            sequenceNumber:\n              sequenceNumber !== undefined ? Number(sequenceNumber) : undefined,\n          },\n          payload,\n        },\n        {\n          networkName: network as NetworkName | undefined,\n        },\n      );\n      return makeUserApproval({\n        authenticator: responseArgs.accountAuthenticator,\n        rawTransaction: responseArgs.rawTxn,\n      });\n    }\n\n    const serializedRequest = SignTransactionRequest.serialize(\n      this.dappInfo,\n      normalizedArgs,\n    );\n    const serializedResponse =\n      await this.transport.sendRequest(serializedRequest);\n    const response = SignTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signAndSubmitTransaction(\n    args: SignAndSubmitTransactionRequest.Args & WithSignerAddress,\n  ) {\n    const { signerAddress } = args;\n    if (await this.isIcAccount(signerAddress)) {\n      const {\n        expirationTimestamp,\n        feePayer,\n        gasUnitPrice,\n        maxGasAmount,\n        network,\n      } = args;\n      if (network === shelbynet.name) {\n        throw new Error('Shelbynet not supported');\n      }\n      const aptosConfig = new AptosConfig({ network });\n\n      let convertedArgs: SignAndSubmitTransactionRequestArgs;\n      if (feePayer !== undefined) {\n        const payload = await normalizePayloadForIC(args.payload, aptosConfig);\n        const rawTxn = await generateRawTransaction({\n          aptosConfig,\n          feePayerAddress: feePayer.address,\n          options: {\n            gasUnitPrice,\n            maxGasAmount,\n          },\n          payload,\n          sender: signerAddress,\n        });\n        convertedArgs = {\n          feePayerAuthenticator: feePayer.authenticator,\n          rawTxn: new FeePayerRawTransaction(rawTxn, [], feePayer.address),\n        };\n      } else {\n        const payload = normalizePayloadForIC(args.payload);\n        convertedArgs = {\n          options: {\n            expirationTimestamp,\n            gasUnitPrice,\n            maxGasAmount,\n          },\n          payload,\n        };\n      }\n\n      const { hash } = await this.pairingClient.signAndSubmitTransaction(\n        signerAddress.toString(),\n        convertedArgs,\n        {\n          networkName: network as NetworkName | undefined,\n        },\n      );\n      return makeUserApproval<SignAndSubmitTransactionResponse.ApprovalArgs>({\n        txnHash: hash,\n      });\n    }\n\n    const serializedRequest = SignAndSubmitTransactionRequest.serialize(\n      this.dappInfo,\n      args,\n    );\n    const serializedResponse =\n      await this.transport.sendRequest(serializedRequest);\n    const response =\n      SignAndSubmitTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  // endregion\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport const DEFAULT_FRONTEND_URL = 'https://web.petra.app';\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  AccountAddress,\n  AnyTransactionPayloadInstance,\n  AptosConfig,\n  EntryFunctionArgumentTypes,\n  generateTransactionPayload,\n  generateTransactionPayloadWithABI,\n  InputGenerateTransactionPayloadData,\n  SimpleEntryFunctionArgumentTypes,\n  TransactionPayload,\n} from '@aptos-labs/ts-sdk';\nimport { JsonTransactionPayload } from '@identity-connect/wallet-api';\n\ntype EntryFunctionArgument =\n  | SimpleEntryFunctionArgumentTypes\n  | EntryFunctionArgumentTypes;\ntype SerializableArgument =\n  | undefined\n  | null\n  | number\n  | string\n  | boolean\n  | Uint8Array\n  | SerializableArgument[];\n\n/**\n * Return an equivalent argument value that can be safely serialized.\n */\nfunction convertToSerializableArgument(\n  argument: EntryFunctionArgument,\n): SerializableArgument {\n  if (argument === undefined || argument === null) {\n    return argument;\n  }\n\n  if (Array.isArray(argument)) {\n    return argument.map((subArgument) =>\n      convertToSerializableArgument(subArgument),\n    );\n  }\n\n  if (\n    typeof argument === 'string' ||\n    typeof argument === 'number' ||\n    typeof argument === 'boolean' ||\n    argument instanceof Uint8Array\n  ) {\n    return argument;\n  }\n\n  if (typeof argument === 'bigint') {\n    return argument.toString();\n  }\n\n  // ArrayBuffer\n  if (argument instanceof ArrayBuffer) {\n    return new Uint8Array(argument);\n  }\n\n  // MoveVector\n  if ('values' in argument) {\n    return argument.values.map((subArgument) =>\n      convertToSerializableArgument(subArgument),\n    );\n  }\n\n  // AccountAddress\n  if ('data' in argument) {\n    return AccountAddress.from(argument.data).toString();\n  }\n\n  // MoveOption\n  if (argument.value === undefined) {\n    return undefined;\n  }\n\n  if (\n    typeof argument.value === 'string' ||\n    typeof argument.value === 'number' ||\n    typeof argument.value === 'boolean' ||\n    argument.value instanceof Uint8Array\n  ) {\n    return argument.value;\n  }\n\n  if (typeof argument.value === 'bigint') {\n    return argument.value.toString();\n  }\n\n  throw new Error('Unexpected argument');\n}\n\n/**\n * Normalize payload input so that it's compatible with IC requests.\n * This variant is sync and will convert a payload generation input into a\n * `JsonTransactionPayload` when the ABI is not available\n */\nexport function normalizePayloadForIC(\n  payload: TransactionPayload | InputGenerateTransactionPayloadData,\n): AnyTransactionPayloadInstance | JsonTransactionPayload;\n/**\n * Normalize payload input so that it's compatible with IC requests.\n * This variant is async and will generate a payload instance when an input is provided\n */\nexport async function normalizePayloadForIC(\n  payload: TransactionPayload | InputGenerateTransactionPayloadData,\n  aptosConfig: AptosConfig,\n): Promise<AnyTransactionPayloadInstance>;\n\nexport function normalizePayloadForIC(\n  payload: TransactionPayload | InputGenerateTransactionPayloadData,\n  aptosConfig?: AptosConfig,\n):\n  | AnyTransactionPayloadInstance\n  | JsonTransactionPayload\n  | Promise<AnyTransactionPayloadInstance> {\n  if ('bcsToBytes' in payload) {\n    return payload as AnyTransactionPayloadInstance;\n  }\n  if ('bytecode' in payload) {\n    // The signature of this function returns a promise, but it's actually sync code\n    return generateTransactionPayload(payload);\n  }\n  if (aptosConfig) {\n    return payload.abi !== undefined\n      ? generateTransactionPayloadWithABI({ ...payload, abi: payload.abi })\n      : generateTransactionPayload({ aptosConfig, ...payload });\n  }\n\n  const entryFunctionPayload = {\n    arguments: payload.functionArguments.map(convertToSerializableArgument),\n    function: payload.function,\n    type: 'entry_function_payload' as const,\n    type_arguments: (payload.typeArguments ?? []).map((ta) => ta.toString()),\n  };\n\n  return 'multisigAddress' in payload\n    ? {\n        multisig_address: AccountAddress.from(\n          payload.multisigAddress,\n        ).toString(),\n        transaction_payload: entryFunctionPayload,\n        type: 'multisig_payload' as const,\n      }\n    : entryFunctionPayload;\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-await-in-loop */\n\nimport { AccountInfo } from '@aptos-connect/wallet-api';\nimport { AccountAddress } from '@aptos-labs/ts-sdk';\nimport {\n  CancelSigningRequestSerializedResponse,\n  CreateSigningRequestSerializedResponse,\n  FinalizedPairingData,\n  GetPairingSerializedResponse,\n  GetSigningRequestSerializedResponse,\n  NetworkName,\n  SerializedDate,\n  SigningRequestData,\n  SigningRequestStatus,\n  SigningRequestTypes,\n} from '@identity-connect/api';\nimport {\n  decodeBase64,\n  decryptEnvelope,\n  deserializeEd25519PublicKeyB64,\n  deserializePublicKeyB64,\n  Ed25519KeyPair,\n  Ed25519PublicKey,\n  Ed25519SecretKey,\n  encodeBase64,\n  encryptAndSignEnvelope,\n  KeyTypes,\n  toKey,\n} from '@identity-connect/crypto';\nimport {\n  deserializeSignTransactionResponseArgs,\n  type SerializedSignAndSubmitTransactionRequestArgs,\n  type SerializedSignTransactionRequestArgs,\n  type SerializedSignTransactionResponseArgs,\n  type SignAndSubmitTransactionRequestArgs,\n  type SignAndSubmitTransactionResponseArgs,\n  SignMessageRequestArgs,\n  SignMessageResponseArgs,\n  type SignTransactionRequestArgs,\n  type SignTransactionResponseArgs,\n  type SignTransactionWithPayloadRequestArgs,\n  type SignTransactionWithPayloadResponseArgs,\n  type SignTransactionWithRawTxnRequestArgs,\n  type SignTransactionWithRawTxnResponseArgs,\n  serializeSignAndSubmitTransactionRequestArgs,\n  serializeSignTransactionRequestArgs,\n} from '@identity-connect/wallet-api';\nimport axios, {\n  AxiosError,\n  AxiosInstance,\n  CreateAxiosDefaults,\n  isAxiosError,\n} from 'axios';\nimport { DEFAULT_FRONTEND_URL } from './constants';\nimport { PairingExpiredError, SignatureRequestError } from './errors';\nimport {\n  DappPairingData,\n  DappStateAccessors,\n  windowStateAccessors,\n} from './state';\nimport { CancelToken } from './types';\nimport {\n  validateSignAndSubmitTransactionResponse,\n  validateSignMessageResponse,\n} from './utils';\n\nconst API_VERSION = '0.2.0' as const;\nconst SIGNING_REQUEST_POLLING_INTERVAL = 2500;\nconst SEQUENCE_NUMBER_MISMATCH_PATTERN =\n  /^Sequence number mismatch, expected (?:\\S+ to be )?(\\d+)/;\n\nasync function waitFor(milliseconds: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, milliseconds);\n  });\n}\n\nasync function withRetries<Response>(\n  requestFn: () => Promise<Response>,\n  onError: (err: any) => void,\n  retries: number = 1,\n) {\n  for (let i = 0; i < retries; i += 1) {\n    try {\n      return await requestFn();\n    } catch (err) {\n      onError(err);\n    }\n  }\n  return requestFn();\n}\n\nexport interface SignRequestOptions {\n  cancelToken?: CancelToken;\n  networkName?: NetworkName;\n}\n\nexport type OnDisconnectListener = (address: string) => void;\nexport type OnDisconnectListenerCleanup = () => void;\n\nexport interface ACPairingClientConfig {\n  accessors?: DappStateAccessors;\n  axiosConfig?: CreateAxiosDefaults;\n  defaultNetworkName?: NetworkName;\n}\n\nexport class ACPairingClient {\n  protected readonly accessors: DappStateAccessors;\n  private readonly defaultNetworkName: NetworkName;\n  protected readonly axiosInstance: AxiosInstance;\n  private readonly initPromise?: Promise<void>;\n\n  constructor({\n    accessors = windowStateAccessors,\n    axiosConfig,\n    defaultNetworkName = NetworkName.MAINNET,\n  }: ACPairingClientConfig = {}) {\n    this.accessors = accessors;\n    this.defaultNetworkName = defaultNetworkName;\n    this.axiosInstance = axios.create({\n      baseURL: DEFAULT_FRONTEND_URL,\n      ...axiosConfig,\n    });\n\n    const isClientSideRendering = typeof window !== 'undefined';\n    this.initPromise = isClientSideRendering\n      ? this.syncFirstPairing()\n      : undefined;\n  }\n\n  private async getPairing(id: string) {\n    const response = await this.axiosInstance.get<GetPairingSerializedResponse>(\n      `v1/pairing/${id}/`,\n    );\n    return response.data.data.pairing;\n  }\n\n  private async syncFirstPairing() {\n    const pairings = await this.accessors.getAll();\n    const firstPairing = Object.values(pairings)[0];\n    if (firstPairing === undefined) {\n      return;\n    }\n\n    try {\n      const { dappSpecificWallet, maxDappSequenceNumber } =\n        await this.getPairing(firstPairing.pairingId);\n      await this.accessors.update(firstPairing.accountAddress, {\n        ...firstPairing,\n        currSequenceNumber: maxDappSequenceNumber,\n        dappWalletId: dappSpecificWallet?.id,\n      });\n    } catch (_err) {\n      await this.accessors.update(firstPairing.accountAddress, undefined);\n    }\n  }\n\n  private async createSigningRequest<TRequestBody>(\n    pairing: DappPairingData,\n    type: string,\n    networkName: NetworkName,\n    requestBody: TRequestBody,\n  ) {\n    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);\n    const accountTransportEd25519PublicKey = decodeBase64(\n      pairing.accountTransportEd25519PublicKeyB64,\n    );\n\n    let sequenceNumber = pairing.currSequenceNumber + 1;\n    return withRetries(\n      async () => {\n        const requestEnvelope = await encryptAndSignEnvelope<any, any>(\n          toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),\n          toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n          toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n          sequenceNumber,\n          { apiVersion: API_VERSION, networkName, requestType: type },\n          requestBody,\n        );\n\n        const response =\n          await this.axiosInstance.post<CreateSigningRequestSerializedResponse>(\n            `v1/pairing/${pairing.pairingId}/signing-request/`,\n            requestEnvelope,\n          );\n\n        await this.accessors.update(pairing.accountAddress, {\n          ...pairing,\n          currSequenceNumber: sequenceNumber,\n        });\n\n        return response.data.data.signingRequest;\n      },\n      (err) => {\n        if (isAxiosError(err)) {\n          const errorMessage: string = err.response?.data?.message;\n          const expectedSequenceNumber = errorMessage?.match(\n            SEQUENCE_NUMBER_MISMATCH_PATTERN,\n          )?.[1];\n          if (expectedSequenceNumber !== undefined) {\n            sequenceNumber = Number(expectedSequenceNumber);\n            return;\n          }\n        }\n        throw err;\n      },\n    );\n  }\n\n  private async getSigningRequest(id: string) {\n    const response = await this.axiosInstance.get<\n      GetSigningRequestSerializedResponse | undefined\n    >(`v1/signing-request/${id}/`, {\n      validateStatus: (status) => status === 200 || status === 404,\n    });\n    return response.data?.data?.signingRequest;\n  }\n\n  protected async deletePairing(\n    pairingId: string,\n    secretKey: Ed25519SecretKey,\n    publicKey: Ed25519PublicKey,\n  ) {\n    const requestEnvelope = await encryptAndSignEnvelope<any, any>(\n      secretKey,\n      publicKey,\n      publicKey,\n      0, // ignored\n      {},\n      {},\n    );\n\n    await this.axiosInstance.post<CreateSigningRequestSerializedResponse>(\n      `v1/pairing/${pairingId}/delete/`,\n      requestEnvelope,\n      { validateStatus: (status) => status === 204 || status === 404 },\n    );\n  }\n\n  async cancelSigningRequest(pairing: DappPairingData, id: string) {\n    const sequenceNumber = pairing.currSequenceNumber;\n    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);\n    const accountTransportEd25519PublicKey = decodeBase64(\n      pairing.accountTransportEd25519PublicKeyB64,\n    );\n\n    const requestEnvelope = await encryptAndSignEnvelope<any, any>(\n      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),\n      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n      toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n      sequenceNumber + 1,\n      {},\n      {},\n    );\n\n    const response =\n      await this.axiosInstance.patch<CancelSigningRequestSerializedResponse>(\n        `v1/signing-request/${id}/cancel/`,\n        requestEnvelope,\n      );\n\n    // TODO: auto-sync sequence number on error\n    await this.accessors.update(pairing.accountAddress, {\n      ...pairing,\n      currSequenceNumber: sequenceNumber + 1,\n    });\n\n    return response.data.data.signingRequest;\n  }\n\n  private async signRequest<TRequestBody, TResponseBody>(\n    address: string,\n    type: SigningRequestTypes,\n    requestBody: TRequestBody,\n    { cancelToken, networkName }: SignRequestOptions = {},\n  ) {\n    await this.initPromise;\n    const pairing = await this.accessors.get(address);\n    if (pairing === undefined) {\n      throw new Error('The requested account is not paired');\n    }\n\n    let signingRequest: SerializedDate<SigningRequestData>;\n\n    try {\n      signingRequest = await this.createSigningRequest<TRequestBody>(\n        pairing,\n        type,\n        networkName || this.defaultNetworkName,\n        requestBody,\n      );\n\n      while (signingRequest.status === 'PENDING') {\n        await waitFor(SIGNING_REQUEST_POLLING_INTERVAL);\n        if (cancelToken?.cancelled) {\n          // TODO: send cancel request\n          signingRequest.status = SigningRequestStatus.CANCELLED;\n          break;\n        }\n        signingRequest =\n          (await this.getSigningRequest(signingRequest.id)) ?? signingRequest;\n      }\n    } catch (err) {\n      if (isAxiosError(err) && err.code === '404') {\n        await this.accessors.update(address, undefined);\n        for (const listener of this.onDisconnectListeners) {\n          listener(address);\n        }\n        throw new PairingExpiredError();\n      }\n      throw err;\n    }\n\n    if (signingRequest.status !== 'APPROVED') {\n      throw new SignatureRequestError(signingRequest.status);\n    }\n\n    const decrypted = decryptEnvelope<{}, TResponseBody & {}>(\n      toKey(\n        decodeBase64(pairing.accountTransportEd25519PublicKeyB64),\n        KeyTypes.Ed25519PublicKey,\n      ),\n      toKey(\n        decodeBase64(pairing.dappEd25519SecretKeyB64),\n        KeyTypes.Ed25519SecretKey,\n      ),\n      signingRequest.responseEnvelope!,\n    );\n    return decrypted.privateMessage;\n  }\n\n  // region Public API\n\n  /**\n   * Requests a connection to an account (internally known as pairing).\n   * @returns either the address of the connected account, or undefined if the\n   * connection was cancelled.\n   */\n  async addPairing(\n    { publicKey, secretKey }: Ed25519KeyPair,\n    finalizedPairing: SerializedDate<FinalizedPairingData>,\n  ) {\n    await this.accessors.update(finalizedPairing.account.accountAddress, {\n      accountAddress: finalizedPairing.account.accountAddress,\n      accountAlias: finalizedPairing.account.userSubmittedAlias ?? undefined,\n      accountPublicKeyB64: finalizedPairing.account.publicKeyB64,\n      accountTransportEd25519PublicKeyB64:\n        finalizedPairing.account.transportEd25519PublicKeyB64,\n      currSequenceNumber: finalizedPairing.maxDappSequenceNumber,\n      dappEd25519PublicKeyB64: encodeBase64(publicKey.key),\n      dappEd25519SecretKeyB64: encodeBase64(secretKey.key),\n      dappWalletId: finalizedPairing.dappSpecificWalletId,\n      pairingId: finalizedPairing.id,\n    });\n  }\n\n  async disconnect(address: string) {\n    const pairing = await this.accessors.get(address);\n    if (pairing === undefined) {\n      throw new Error('The specified account is not paired');\n    }\n\n    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);\n    await this.deletePairing(\n      pairing.pairingId,\n      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),\n      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n    );\n    await this.accessors.update(address, undefined);\n    for (const listener of this.onDisconnectListeners) {\n      listener(address);\n    }\n  }\n\n  async signMessage(\n    address: string,\n    args: SignMessageRequestArgs,\n    options?: SignRequestOptions,\n  ) {\n    const response = await this.signRequest<\n      SignMessageRequestArgs,\n      SignMessageResponseArgs\n    >(address, SigningRequestTypes.SIGN_MESSAGE, args, options);\n    validateSignMessageResponse(response);\n    return response;\n  }\n\n  // region signTransaction\n\n  async signTransaction(\n    address: string,\n    args: SignTransactionWithPayloadRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignTransactionWithPayloadResponseArgs>;\n\n  async signTransaction(\n    address: string,\n    args: SignTransactionWithRawTxnRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignTransactionWithRawTxnResponseArgs>;\n\n  async signTransaction(\n    address: string,\n    args: SignTransactionRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignTransactionResponseArgs>;\n\n  async signTransaction(\n    address: string,\n    args: SignTransactionRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignTransactionResponseArgs> {\n    const serializedRequestArgs = serializeSignTransactionRequestArgs(args);\n    const serializedResponseArgs = await this.signRequest<\n      SerializedSignTransactionRequestArgs,\n      SerializedSignTransactionResponseArgs\n    >(\n      address,\n      SigningRequestTypes.SIGN_TRANSACTION,\n      serializedRequestArgs,\n      options,\n    );\n    return deserializeSignTransactionResponseArgs(serializedResponseArgs);\n  }\n\n  // endregion\n\n  async signAndSubmitTransaction(\n    address: string,\n    args: SignAndSubmitTransactionRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignAndSubmitTransactionResponseArgs> {\n    const serializedRequestArgs =\n      serializeSignAndSubmitTransactionRequestArgs(args);\n    try {\n      const responseArgs = await this.signRequest<\n        SerializedSignAndSubmitTransactionRequestArgs,\n        SignAndSubmitTransactionResponseArgs\n      >(\n        address,\n        SigningRequestTypes.SIGN_AND_SUBMIT_TRANSACTION,\n        serializedRequestArgs,\n        options,\n      );\n      validateSignAndSubmitTransactionResponse(responseArgs);\n      return responseArgs;\n    } catch (e) {\n      if (e instanceof AxiosError && e.response?.data?.message) {\n        throw new Error(e.response?.data?.message);\n      }\n      throw e;\n    }\n  }\n\n  async getConnectedAccounts() {\n    await this.initPromise;\n    const pairings = await this.accessors.getAll();\n    return Object.values(pairings).map<AccountInfo>(\n      ({\n        accountAddress,\n        accountEd25519PublicKeyB64,\n        accountPublicKeyB64,\n      }) => ({\n        address: AccountAddress.from(accountAddress),\n        publicKey:\n          accountPublicKeyB64 !== undefined\n            ? deserializePublicKeyB64(accountPublicKeyB64)\n            : deserializeEd25519PublicKeyB64(accountEd25519PublicKeyB64),\n      }),\n    );\n  }\n\n  // endregion\n\n  private readonly onDisconnectListeners = new Set<OnDisconnectListener>();\n\n  onDisconnect(listener: OnDisconnectListener): OnDisconnectListenerCleanup {\n    this.onDisconnectListeners.add(listener);\n    return () => this.onDisconnectListeners.delete(listener);\n  }\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { SigningRequestStatus } from '@identity-connect/api';\n\nexport class SignatureRequestError extends Error {\n  constructor(status: SigningRequestStatus) {\n    super(status);\n    this.name = 'SignatureRequestError';\n    Object.setPrototypeOf(this, SignatureRequestError.prototype);\n  }\n}\n\nexport class UnexpectedSignatureResponseError extends Error {\n  constructor(missingFields: string[]) {\n    const message = `Missing the following fields: ${missingFields.join(', ')}`;\n    super(message);\n    this.name = 'UnexpectedSignatureResponseError';\n    Object.setPrototypeOf(this, UnexpectedSignatureResponseError.prototype);\n  }\n}\n\nexport class PairingExpiredError extends Error {\n  constructor() {\n    super();\n    this.name = 'PairingExpiredError';\n    Object.setPrototypeOf(this, PairingExpiredError.prototype);\n  }\n}\n\nexport class UnregisteredDappError extends Error {\n  constructor() {\n    super('Dapp ID is invalid or not associated with a registered Dapp.');\n    this.name = 'UnregisteredDappError';\n    Object.setPrototypeOf(this, UnregisteredDappError.prototype);\n  }\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport interface BaseDappPairingData {\n  accountAddress: string;\n  accountAlias?: string;\n  accountTransportEd25519PublicKeyB64: string;\n  currSequenceNumber: number;\n  dappEd25519PublicKeyB64: string;\n  dappEd25519SecretKeyB64: string;\n  dappWalletId?: string;\n  pairingId: string;\n}\n\n// Keeping this temporarily for backward compatibility\nexport interface PrevDappPairingData extends BaseDappPairingData {\n  accountEd25519PublicKeyB64: string;\n  accountPublicKeyB64?: undefined;\n}\n\nexport interface CurrDappPairingData extends BaseDappPairingData {\n  accountEd25519PublicKeyB64?: undefined;\n  accountPublicKeyB64: string;\n}\n\nexport type DappPairingData = PrevDappPairingData | CurrDappPairingData;\n\nexport type DappPairingDataMap = { [address: string]: DappPairingData };\n\nexport interface DappStateAccessors {\n  get: (address: string) => Promise<DappPairingData | undefined>;\n  getAll: () => Promise<DappPairingDataMap>;\n  update: (address: string, pairing?: DappPairingData) => Promise<void>;\n}\n\nexport const DAPP_PAIRINGS_WINDOW_STORAGE_KEY = 'icDappPairings';\n\n/**\n * Default implementation of DappStateAccessors that uses the Window localStorage API.\n * This should work for most dapps.\n */\nexport const windowStateAccessors: DappStateAccessors = {\n  async get(address: string) {\n    const pairings = await this.getAll();\n    return pairings[address];\n  },\n  async getAll() {\n    const serialized = window.localStorage.getItem(\n      DAPP_PAIRINGS_WINDOW_STORAGE_KEY,\n    );\n    return serialized ? (JSON.parse(serialized) as DappPairingDataMap) : {};\n  },\n  async update(address: string, pairing?: DappPairingData) {\n    const pairings = await this.getAll();\n    if (pairing === undefined) {\n      delete pairings[address];\n    } else {\n      pairings[address] = pairing;\n    }\n    const newSerialized = JSON.stringify(pairings);\n    window.localStorage.setItem(\n      DAPP_PAIRINGS_WINDOW_STORAGE_KEY,\n      newSerialized,\n    );\n  },\n};\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  SignAndSubmitTransactionResponseArgs,\n  SignMessageResponseArgs,\n} from '@identity-connect/wallet-api';\nimport { UnexpectedSignatureResponseError } from './errors';\n\nconst SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS: (keyof SignMessageResponseArgs)[] =\n  [\n    'address',\n    'application',\n    'chainId',\n    'fullMessage',\n    'message',\n    'nonce',\n    'prefix',\n    'signature',\n  ];\n\nexport function validateSignMessageResponse(response: SignMessageResponseArgs) {\n  const providedFields = new Set(Object.keys(response));\n  const missingFields = SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS.filter(\n    (field) => !providedFields.has(field),\n  );\n  if (missingFields.length > 0) {\n    throw new UnexpectedSignatureResponseError(missingFields);\n  }\n}\n\nconst SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS: (keyof SignAndSubmitTransactionResponseArgs)[] =\n  ['hash'];\n\nexport function validateSignAndSubmitTransactionResponse(\n  response: SignAndSubmitTransactionResponseArgs,\n) {\n  const providedFields = new Set(Object.keys(response));\n  const missingFields =\n    SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS.filter(\n      (field) => !providedFields.has(field),\n    );\n  if (missingFields.length > 0) {\n    throw new UnexpectedSignatureResponseError(missingFields);\n  }\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  CreatePairingSerializedResponse,\n  FinalizedPairingData,\n  SerializedDate,\n} from '@identity-connect/api';\nimport { createEd25519KeyPair, encodeBase64 } from '@identity-connect/crypto';\nimport { isAxiosError } from 'axios';\nimport { DEFAULT_FRONTEND_URL } from './constants';\nimport { UnregisteredDappError } from './errors';\nimport { ACPairingClient, ACPairingClientConfig } from './PairingClient';\nimport { openPrompt, waitForPromptResponse } from './prompt';\n\nexport interface ICDappClientConfig extends ACPairingClientConfig {\n  frontendBaseURL?: string;\n}\n\nexport class ICDappClient extends ACPairingClient {\n  private readonly frontendBaseURL: string;\n\n  constructor(\n    private readonly dappId: string,\n    {\n      frontendBaseURL = DEFAULT_FRONTEND_URL,\n      ...pairingClientConfig\n    }: ICDappClientConfig = {},\n  ) {\n    super(pairingClientConfig);\n    this.frontendBaseURL = frontendBaseURL;\n  }\n\n  private async createPairingRequest(dappEd25519PublicKeyB64: string) {\n    try {\n      const response =\n        await this.axiosInstance.post<CreatePairingSerializedResponse>(\n          'v1/pairing/',\n          {\n            dappEd25519PublicKeyB64,\n            dappId: this.dappId,\n          },\n        );\n      return response.data.data.pairing;\n    } catch (err) {\n      // TODO: export typed errors from API\n      if (\n        isAxiosError(err) &&\n        err.response?.data?.message === 'Dapp not found'\n      ) {\n        throw new UnregisteredDappError();\n      }\n      throw err;\n    }\n  }\n\n  // region Public API\n\n  /**\n   * Requests a connection to an account (internally known as pairing).\n   * @returns either the address of the connected account, or undefined if the\n   * connection was cancelled.\n   */\n  async connect() {\n    const { publicKey, secretKey } = createEd25519KeyPair();\n    const dappEd25519PublicKeyB64 = encodeBase64(publicKey.key);\n\n    // Open the prompt without pairingId (for a snappier ux)\n    const url = new URL(`${this.frontendBaseURL}/pairing`);\n    const promptWindow = await openPrompt(url.href);\n\n    let pairingId: string;\n    try {\n      const pendingPairing = await this.createPairingRequest(\n        dappEd25519PublicKeyB64,\n      );\n      pairingId = pendingPairing.id;\n    } catch (err) {\n      // Close the prompt and have the dapp handle the error\n      promptWindow.close();\n      throw err;\n    }\n\n    // Update the prompt's URL as soon as a pairingId is available\n    url.searchParams.set('pairingId', pairingId);\n    promptWindow.location.href = url.href;\n    const promptResponse =\n      await waitForPromptResponse<SerializedDate<FinalizedPairingData>>(\n        promptWindow,\n      );\n\n    if (promptResponse.status === 'dismissed') {\n      // Ignore the result. This is just a courtesy call, so if anything goes wrong\n      // the pairing will be removed during scheduled cleanup)\n      void this.deletePairing(pairingId, secretKey, publicKey);\n      return undefined;\n    }\n\n    const finalizedPairing = promptResponse.args;\n    await this.addPairing({ publicKey, secretKey }, finalizedPairing);\n\n    return finalizedPairing.account.accountAddress;\n  }\n\n  async offboard(address: string) {\n    const pairing = await this.accessors.get(address);\n    if (pairing === undefined) {\n      throw new Error('This account is not paired');\n    }\n\n    const walletId = pairing.dappWalletId;\n    if (walletId === undefined) {\n      throw new Error('This account cannot be offboarded');\n    }\n\n    const url = new URL(\n      `${this.frontendBaseURL}/offboarding?walletId=${walletId}`,\n    );\n    const promptWindow = openPrompt(url);\n    const response = await waitForPromptResponse<{ offboarded: boolean }>(\n      promptWindow,\n    );\n    if (response.status === 'approved' && response.args.offboarded) {\n      // If exported, disconnect the pairing to clean up\n      this.disconnect(address);\n      return true;\n    }\n    return false;\n  }\n\n  // endregion\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nconst DEFAULT_PROMPT_SIZE = { height: 695, width: 465 };\nconst PROMPT_POLLER_INTERVAL = 500;\n\nexport function openPrompt(url: string | URL, size = DEFAULT_PROMPT_SIZE) {\n  const { height, width } = size;\n  const options = {\n    height,\n    left: window.screenLeft + Math.round((window.outerWidth - width) / 2),\n    popup: true,\n    top: window.screenTop + Math.round((window.outerHeight - height) / 2),\n    width,\n  };\n\n  const strOptions = Object.entries(options)\n    .map(([key, value]) => `${key}=${JSON.stringify(value)}`)\n    .reduce((acc, entry) => `${acc}, ${entry}`);\n\n  const href = url instanceof URL ? url.href : url;\n  const promptWindow = window.open(href, undefined, strOptions);\n  if (promptWindow === null) {\n    throw new Error(\"Couldn't open prompt\");\n  }\n\n  return promptWindow;\n}\n\nexport interface PromptApproval<TResponseArgs> {\n  args: TResponseArgs;\n  status: 'approved';\n}\n\nexport interface PromptDismissal {\n  status: 'dismissed';\n}\n\nexport type PromptResponse<TResponseArgs> =\n  | PromptApproval<TResponseArgs>\n  | PromptDismissal;\n\nexport async function waitForPromptResponse<TResponseArgs>(\n  promptWindow: Window,\n) {\n  return new Promise<PromptResponse<TResponseArgs>>((resolve) => {\n    const listeners = {\n      onMessage: (message: MessageEvent) => {\n        if (message.source !== promptWindow) {\n          return;\n        }\n        window.removeEventListener('message', listeners.onMessage);\n        clearTimeout(listeners.promptPollerId);\n        resolve({\n          args: message.data,\n          status: 'approved',\n        });\n      },\n      promptPollerId: setInterval(() => {\n        if (promptWindow.closed) {\n          window.removeEventListener('message', listeners.onMessage);\n          clearTimeout(listeners.promptPollerId);\n          resolve({\n            status: 'dismissed',\n          });\n        }\n      }, PROMPT_POLLER_INTERVAL),\n    };\n\n    window.addEventListener('message', listeners.onMessage);\n  });\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  ConnectRequest,\n  ConnectResponse,\n  type DappInfo,\n  DisconnectRequest,\n  GetConnectedAccountsRequest,\n  GetConnectedAccountsResponse,\n  IsConnectedRequest,\n  IsConnectedResponse,\n  SignAndSubmitTransactionRequest,\n  SignAndSubmitTransactionResponse,\n  SignMessageRequest,\n  SignMessageResponse,\n  SignTransactionRequest,\n  SignTransactionResponse,\n} from '@aptos-connect/wallet-api';\nimport { WebWalletTransport } from '@aptos-connect/web-transport';\nimport { NetworkName } from '@identity-connect/api';\nimport { DEFAULT_FRONTEND_URL } from './constants';\n\nexport interface ACKeylessClientConfig {\n  dappImageURI?: string;\n  dappName?: string;\n  defaultNetworkName?: NetworkName;\n  frontendBaseURL?: string;\n  provider?: 'google' | 'apple';\n}\n\nexport class ACKeylessClient {\n  private readonly defaultNetworkName: NetworkName;\n\n  readonly dappInfo: DappInfo;\n\n  private readonly transport: WebWalletTransport;\n\n  constructor({\n    dappImageURI,\n    dappName,\n    defaultNetworkName = NetworkName.MAINNET,\n    frontendBaseURL = DEFAULT_FRONTEND_URL,\n    provider = 'google',\n  }: ACKeylessClientConfig = {}) {\n    this.defaultNetworkName = defaultNetworkName;\n\n    this.dappInfo = {\n      domain: window.location.origin,\n      imageURI: dappImageURI,\n      name: dappName ?? document.title,\n    };\n\n    this.transport = new WebWalletTransport(frontendBaseURL, provider);\n  }\n\n  // region Public API\n\n  async isConnected() {\n    const serializedRequest = IsConnectedRequest.serialize(this.dappInfo);\n    const serializedResponse =\n      await this.transport.sendRequest(serializedRequest);\n    const response = IsConnectedResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async getConnectedAccounts() {\n    const serializedRequest = GetConnectedAccountsRequest.serialize(\n      this.dappInfo,\n    );\n    const serializedResponse =\n      await this.transport.sendRequest(serializedRequest);\n    const response =\n      GetConnectedAccountsResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async disconnect() {\n    const serializedRequest = DisconnectRequest.serialize(this.dappInfo);\n    await this.transport.sendRequest(serializedRequest);\n  }\n\n  async connect() {\n    const serializedRequest = ConnectRequest.serialize(this.dappInfo);\n    const serializedResponse =\n      await this.transport.sendRequest(serializedRequest);\n    const response = ConnectResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signMessage(args: SignMessageRequest.Args) {\n    const serializedRequest = SignMessageRequest.serialize(this.dappInfo, args);\n    const serializedResponse =\n      await this.transport.sendRequest(serializedRequest);\n    const response = SignMessageResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signTransaction(\n    args:\n      | SignTransactionRequest.Args\n      | SignTransactionRequest.ArgsWithTransaction,\n  ): Promise<SignTransactionResponse.Args> {\n    const normalizedArgs =\n      'transaction' in args ? SignTransactionRequest.normalizeArgs(args) : args;\n    const serializedRequest = SignTransactionRequest.serialize(\n      this.dappInfo,\n      normalizedArgs,\n    );\n    const serializedResponse =\n      await this.transport.sendRequest(serializedRequest);\n    const response = SignTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signAndSubmitTransaction(args: SignAndSubmitTransactionRequest.Args) {\n    const serializedRequest = SignAndSubmitTransactionRequest.serialize(\n      this.dappInfo,\n      args,\n    );\n    const serializedResponse =\n      await this.transport.sendRequest(serializedRequest);\n    const response =\n      SignAndSubmitTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  // endregion\n}\n"],"names":["AccountAddress","AptosConfig","NetworkName","encodeBase64","AccountAddress","AccountAddress","NetworkName","AccountAddress","encodeBase64","AptosConfig","createEd25519KeyPair","encodeBase64","isAxiosError","isAxiosError","createEd25519KeyPair","encodeBase64","ConnectRequest","ConnectResponse","DisconnectRequest","GetConnectedAccountsRequest","GetConnectedAccountsResponse","SignAndSubmitTransactionRequest","SignAndSubmitTransactionResponse","SignMessageRequest","SignMessageResponse","SignTransactionRequest","SignTransactionResponse","WebWalletTransport","NetworkName","NetworkName","WebWalletTransport","GetConnectedAccountsRequest","GetConnectedAccountsResponse","DisconnectRequest","ConnectRequest","ConnectResponse","SignMessageRequest","SignMessageResponse","SignTransactionRequest","SignTransactionResponse","SignAndSubmitTransactionRequest","SignAndSubmitTransactionResponse"],"mappings":"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"}}]
}
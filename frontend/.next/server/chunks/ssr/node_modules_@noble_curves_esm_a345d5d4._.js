module.exports=[835962,a=>{"use strict";var b=a.i(677832);let c=BigInt(0),d=BigInt(1);function e(a,b){if("boolean"!=typeof b)throw Error(a+" boolean expected, got "+b)}function f(a,b=""){if("boolean"!=typeof a)throw Error((b&&`"${b}"`)+"expected boolean, got type="+typeof a);return a}function g(a,c,d=""){let e=(0,b.isBytes)(a),f=a?.length,h=void 0!==c;if(!e||h&&f!==c)throw Error((d&&`"${d}" `)+"expected Uint8Array"+(h?` of length ${c}`:"")+", got "+(e?`length=${f}`:`type=${typeof a}`));return a}function h(a){let b=a.toString(16);return 1&b.length?"0"+b:b}function i(a){if("string"!=typeof a)throw Error("hex string expected, got "+typeof a);return""===a?c:BigInt("0x"+a)}function j(a){return i((0,b.bytesToHex)(a))}function k(a){return(0,b.abytes)(a),i((0,b.bytesToHex)(Uint8Array.from(a).reverse()))}function l(a,c){return(0,b.hexToBytes)(a.toString(16).padStart(2*c,"0"))}function m(a,b){return l(a,b).reverse()}function n(a){return(0,b.hexToBytes)(h(a))}function o(a,c,d){let e;if("string"==typeof c)try{e=(0,b.hexToBytes)(c)}catch(b){throw Error(a+" must be hex string or Uint8Array, cause: "+b)}else if((0,b.isBytes)(c))e=Uint8Array.from(c);else throw Error(a+" must be hex string or Uint8Array");let f=e.length;if("number"==typeof d&&f!==d)throw Error(a+" of length "+d+" expected, got "+f);return e}function p(a,b){if(a.length!==b.length)return!1;let c=0;for(let d=0;d<a.length;d++)c|=a[d]^b[d];return 0===c}function q(a){return Uint8Array.from(a)}function r(a){return Uint8Array.from(a,(b,c)=>{let d=b.charCodeAt(0);if(1!==b.length||d>127)throw Error(`string contains non-ASCII character "${a[c]}" with code ${d} at position ${c}`);return d})}let s=a=>"bigint"==typeof a&&c<=a;function t(a,b,c){return s(a)&&s(b)&&s(c)&&b<=a&&a<c}function u(a,b,c,d){if(!t(b,c,d))throw Error("expected valid "+a+": "+c+" <= n < "+d+", got "+b)}function v(a){let b;for(b=0;a>c;a>>=d,b+=1);return b}function w(a,b){return a>>BigInt(b)&d}function x(a,b,e){return a|(e?d:c)<<BigInt(b)}function y(a,c,d){if("number"!=typeof a||a<2)throw Error("hashLen must be a number");if("number"!=typeof c||c<2)throw Error("qByteLen must be a number");if("function"!=typeof d)throw Error("hmacFn must be a function");let e=a=>new Uint8Array(a),f=e(a),g=e(a),h=0,i=()=>{f.fill(1),g.fill(0),h=0},j=(...a)=>d(g,f,...a),k=(a=e(0))=>{(g=j(Uint8Array.of(0),a),f=j(),0!==a.length)&&(g=j(Uint8Array.of(1),a),f=j())},l=()=>{if(h++>=1e3)throw Error("drbg: tried 1000 values");let a=0,d=[];for(;a<c;){let b=(f=j()).slice();d.push(b),a+=f.length}return(0,b.concatBytes)(...d)};return(a,b)=>{let c;for(i(),k(a);!(c=b(l()));)k();return i(),c}}let z={bigint:a=>"bigint"==typeof a,function:a=>"function"==typeof a,boolean:a=>"boolean"==typeof a,string:a=>"string"==typeof a,stringOrUint8Array:a=>"string"==typeof a||(0,b.isBytes)(a),isSafeInteger:a=>Number.isSafeInteger(a),array:a=>Array.isArray(a),field:(a,b)=>b.Fp.isValid(a),hash:a=>"function"==typeof a&&Number.isSafeInteger(a.outputLen)};function A(a,b,c={}){let d=(b,c,d)=>{let e=z[c];if("function"!=typeof e)throw Error("invalid validator function");let f=a[b];if((!d||void 0!==f)&&!e(f,a))throw Error("param "+String(b)+" is invalid. Expected "+c+", got "+f)};for(let[a,c]of Object.entries(b))d(a,c,!1);for(let[a,b]of Object.entries(c))d(a,b,!0);return a}function B(a){return"function"==typeof a&&Number.isSafeInteger(a.outputLen)}function C(a,b,c={}){if(!a||"object"!=typeof a)throw Error("expected valid options object");function d(b,c,d){let e=a[b];if(d&&void 0===e)return;let f=typeof e;if(f!==c||null===e)throw Error(`param "${b}" is invalid: expected ${c}, got ${f}`)}Object.entries(b).forEach(([a,b])=>d(a,b,!1)),Object.entries(c).forEach(([a,b])=>d(a,b,!0))}function D(a){let b=new WeakMap;return(c,...d)=>{let e=b.get(c);if(void 0!==e)return e;let f=a(c,...d);return b.set(c,f),f}}a.s(["_abool2",()=>f,"_abytes2",()=>g,"_validateObject",()=>C,"aInRange",()=>u,"abool",()=>e,"asciiToBytes",()=>r,"bitGet",()=>w,"bitLen",()=>v,"bitMask",0,a=>(d<<BigInt(a))-d,"bitSet",()=>x,"bytesToNumberBE",()=>j,"bytesToNumberLE",()=>k,"copyBytes",()=>q,"createHmacDrbg",()=>y,"ensureBytes",()=>o,"equalBytes",()=>p,"hexToNumber",()=>i,"inRange",()=>t,"isHash",()=>B,"memoized",()=>D,"notImplemented",0,()=>{throw Error("not implemented")},"numberToBytesBE",()=>l,"numberToBytesLE",()=>m,"numberToHexUnpadded",()=>h,"numberToVarBytesBE",()=>n,"validateObject",()=>A])},242587,a=>{"use strict";var b=a.i(957162),c=a.i(677832),d=a.i(835962),e=a.i(293259),f=a.i(359029);let g=(a,b)=>(a+(a>=0?b:-b)/m)/b;function h(a){if(!["compact","recovered","der"].includes(a))throw Error('Signature format must be "compact", "recovered", or "der"');return a}function i(a,b){let c={};for(let d of Object.keys(b))c[d]=void 0===a[d]?b[d]:a[d];return(0,d._abool2)(c.lowS,"lowS"),(0,d._abool2)(c.prehash,"prehash"),void 0!==c.format&&h(c.format),c}let j={Err:class extends Error{constructor(a=""){super(a)}},_tlv:{encode:(a,b)=>{let{Err:c}=j;if(a<0||a>256)throw new c("tlv.encode: wrong tag");if(1&b.length)throw new c("tlv.encode: unpadded data");let e=b.length/2,f=(0,d.numberToHexUnpadded)(e);if(f.length/2&128)throw new c("tlv.encode: long form length too big");let g=e>127?(0,d.numberToHexUnpadded)(f.length/2|128):"";return(0,d.numberToHexUnpadded)(a)+g+f+b},decode(a,b){let{Err:c}=j,d=0;if(a<0||a>256)throw new c("tlv.encode: wrong tag");if(b.length<2||b[d++]!==a)throw new c("tlv.decode: wrong tlv");let e=b[d++],f=0;if(128&e){let a=127&e;if(!a)throw new c("tlv.decode(long): indefinite length not supported");if(a>4)throw new c("tlv.decode(long): byte length is too big");let g=b.subarray(d,d+a);if(g.length!==a)throw new c("tlv.decode: length bytes not complete");if(0===g[0])throw new c("tlv.decode(long): zero leftmost byte");for(let a of g)f=f<<8|a;if(d+=a,f<128)throw new c("tlv.decode(long): not minimal encoding")}else f=e;let g=b.subarray(d,d+f);if(g.length!==f)throw new c("tlv.decode: wrong value length");return{v:g,l:b.subarray(d+f)}}},_int:{encode(a){let{Err:b}=j;if(a<k)throw new b("integer: negative integers are not allowed");let c=(0,d.numberToHexUnpadded)(a);if(8&Number.parseInt(c[0],16)&&(c="00"+c),1&c.length)throw new b("unexpected DER parsing assertion: unpadded hex");return c},decode(a){let{Err:b}=j;if(128&a[0])throw new b("invalid signature integer: negative");if(0===a[0]&&!(128&a[1]))throw new b("invalid signature integer: unnecessary leading zero");return(0,d.bytesToNumberBE)(a)}},toSig(a){let{Err:b,_int:c,_tlv:e}=j,f=(0,d.ensureBytes)("signature",a),{v:g,l:h}=e.decode(48,f);if(h.length)throw new b("invalid signature: left bytes after parsing");let{v:i,l:k}=e.decode(2,g),{v:l,l:m}=e.decode(2,k);if(m.length)throw new b("invalid signature: left bytes after parsing");return{r:c.decode(i),s:c.decode(l)}},hexFromSig(a){let{_tlv:b,_int:c}=j,d=b.encode(2,c.encode(a.r)),e=b.encode(2,c.encode(a.s));return b.encode(48,d+e)}},k=BigInt(0),l=BigInt(1),m=BigInt(2),n=BigInt(3),o=BigInt(4);function p(a,b){let c,{BYTES:e}=a;if("bigint"==typeof b)c=b;else{let f=(0,d.ensureBytes)("private key",b);try{c=a.fromBytes(f)}catch(a){throw Error(`invalid private key: expected ui8a of size ${e}, got ${typeof b}`)}}if(!a.isValidNot0(c))throw Error("invalid private key: out of range [1..N-1]");return c}function q(a,b={}){let f=(0,e._createCurveFields)("weierstrass",a,b),{Fp:h,Fn:i}=f,j=f.CURVE,{h:m,n:s}=j;(0,d._validateObject)(b,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});let{endo:u}=b;if(u&&(!h.is0(j.a)||"bigint"!=typeof u.beta||!Array.isArray(u.basises)))throw Error('invalid endo: expected "beta": bigint and "basises": array');let v=t(h,i);function w(){if(!h.isOdd)throw Error("compression is not supported: Field does not have .isOdd()")}let x=b.toBytes||function(a,b,e){let{x:f,y:g}=b.toAffine(),i=h.toBytes(f);if((0,d._abool2)(e,"isCompressed"),!e)return(0,c.concatBytes)(Uint8Array.of(4),i,h.toBytes(g));{w();let a=!h.isOdd(g);return(0,c.concatBytes)(r(a),i)}},y=b.fromBytes||function(a){(0,d._abytes2)(a,void 0,"Point");let{publicKey:b,publicKeyUncompressed:c}=v,e=a.length,f=a[0],g=a.subarray(1);if(e===b&&(2===f||3===f)){let a,b=h.fromBytes(g);if(!h.isValid(b))throw Error("bad point: is not on curve, wrong x");let c=z(b);try{a=h.sqrt(c)}catch(a){throw Error("bad point: is not on curve, sqrt error"+(a instanceof Error?": "+a.message:""))}return w(),(1&f)==1!==h.isOdd(a)&&(a=h.neg(a)),{x:b,y:a}}if(e===c&&4===f){let a=h.BYTES,b=h.fromBytes(g.subarray(0,a)),c=h.fromBytes(g.subarray(a,2*a));if(!A(b,c))throw Error("bad point: is not on curve");return{x:b,y:c}}throw Error(`bad point: got length ${e}, expected compressed=${b} or uncompressed=${c}`)};function z(a){let b=h.sqr(a),c=h.mul(b,a);return h.add(h.add(c,h.mul(a,j.a)),j.b)}function A(a,b){let c=h.sqr(b),d=z(a);return h.eql(c,d)}if(!A(j.Gx,j.Gy))throw Error("bad curve params: generator point");let B=h.mul(h.pow(j.a,n),o),C=h.mul(h.sqr(j.b),BigInt(27));if(h.is0(h.add(B,C)))throw Error("bad curve params: a or b");function D(a,b,c=!1){if(!h.isValid(b)||c&&h.is0(b))throw Error(`bad point coordinate ${a}`);return b}function E(a){if(!(a instanceof J))throw Error("ProjectivePoint expected")}function F(a){if(!u||!u.basises)throw Error("no endo");return function(a,b,c){let[[e,f],[h,i]]=b,j=g(i*a,c),m=g(-f*a,c),n=a-j*e-m*h,o=-j*f-m*i,p=n<k,q=o<k;p&&(n=-n),q&&(o=-o);let r=(0,d.bitMask)(Math.ceil((0,d.bitLen)(c)/2))+l;if(n<k||n>=r||o<k||o>=r)throw Error("splitScalar (endomorphism): failed, k="+a);return{k1neg:p,k1:n,k2neg:q,k2:o}}(a,u.basises,i.ORDER)}let G=(0,d.memoized)((a,b)=>{let{X:c,Y:d,Z:e}=a;if(h.eql(e,h.ONE))return{x:c,y:d};let f=a.is0();null==b&&(b=f?h.ONE:h.inv(e));let g=h.mul(c,b),i=h.mul(d,b),j=h.mul(e,b);if(f)return{x:h.ZERO,y:h.ZERO};if(!h.eql(j,h.ONE))throw Error("invZ was invalid");return{x:g,y:i}}),H=(0,d.memoized)(a=>{if(a.is0()){if(b.allowInfinityPoint&&!h.is0(a.Y))return;throw Error("bad point: ZERO")}let{x:c,y:d}=a.toAffine();if(!h.isValid(c)||!h.isValid(d))throw Error("bad point: x or y not field elements");if(!A(c,d))throw Error("bad point: equation left != right");if(!a.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0});function I(a,b,c,d,f){return c=new J(h.mul(c.X,a),c.Y,c.Z),b=(0,e.negateCt)(d,b),c=(0,e.negateCt)(f,c),b.add(c)}class J{constructor(a,b,c){this.X=D("x",a),this.Y=D("y",b,!0),this.Z=D("z",c),Object.freeze(this)}static CURVE(){return j}static fromAffine(a){let{x:b,y:c}=a||{};if(!a||!h.isValid(b)||!h.isValid(c))throw Error("invalid affine point");if(a instanceof J)throw Error("projective point not allowed");return h.is0(b)&&h.is0(c)?J.ZERO:new J(b,c,h.ONE)}static fromBytes(a){let b=J.fromAffine(y((0,d._abytes2)(a,void 0,"point")));return b.assertValidity(),b}static fromHex(a){return J.fromBytes((0,d.ensureBytes)("pointHex",a))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(a=8,b=!0){return L.createCache(this,a),b||this.multiply(n),this}assertValidity(){H(this)}hasEvenY(){let{y:a}=this.toAffine();if(!h.isOdd)throw Error("Field doesn't support isOdd");return!h.isOdd(a)}equals(a){E(a);let{X:b,Y:c,Z:d}=this,{X:e,Y:f,Z:g}=a,i=h.eql(h.mul(b,g),h.mul(e,d)),j=h.eql(h.mul(c,g),h.mul(f,d));return i&&j}negate(){return new J(this.X,h.neg(this.Y),this.Z)}double(){let{a,b}=j,c=h.mul(b,n),{X:d,Y:e,Z:f}=this,g=h.ZERO,i=h.ZERO,k=h.ZERO,l=h.mul(d,d),m=h.mul(e,e),o=h.mul(f,f),p=h.mul(d,e);return p=h.add(p,p),k=h.mul(d,f),k=h.add(k,k),g=h.mul(a,k),i=h.mul(c,o),i=h.add(g,i),g=h.sub(m,i),i=h.add(m,i),i=h.mul(g,i),g=h.mul(p,g),k=h.mul(c,k),o=h.mul(a,o),p=h.sub(l,o),p=h.mul(a,p),p=h.add(p,k),k=h.add(l,l),l=h.add(k,l),l=h.add(l,o),l=h.mul(l,p),i=h.add(i,l),o=h.mul(e,f),o=h.add(o,o),l=h.mul(o,p),g=h.sub(g,l),k=h.mul(o,m),k=h.add(k,k),new J(g,i,k=h.add(k,k))}add(a){E(a);let{X:b,Y:c,Z:d}=this,{X:e,Y:f,Z:g}=a,i=h.ZERO,k=h.ZERO,l=h.ZERO,m=j.a,o=h.mul(j.b,n),p=h.mul(b,e),q=h.mul(c,f),r=h.mul(d,g),s=h.add(b,c),t=h.add(e,f);s=h.mul(s,t),t=h.add(p,q),s=h.sub(s,t),t=h.add(b,d);let u=h.add(e,g);return t=h.mul(t,u),u=h.add(p,r),t=h.sub(t,u),u=h.add(c,d),i=h.add(f,g),u=h.mul(u,i),i=h.add(q,r),u=h.sub(u,i),l=h.mul(m,t),i=h.mul(o,r),l=h.add(i,l),i=h.sub(q,l),l=h.add(q,l),k=h.mul(i,l),q=h.add(p,p),q=h.add(q,p),r=h.mul(m,r),t=h.mul(o,t),q=h.add(q,r),r=h.sub(p,r),r=h.mul(m,r),t=h.add(t,r),p=h.mul(q,t),k=h.add(k,p),p=h.mul(u,t),i=h.mul(s,i),i=h.sub(i,p),p=h.mul(s,q),l=h.mul(u,l),new J(i,k,l=h.add(l,p))}subtract(a){return this.add(a.negate())}is0(){return this.equals(J.ZERO)}multiply(a){let c,d,{endo:f}=b;if(!i.isValidNot0(a))throw Error("invalid scalar: out of range");let g=a=>L.cached(this,a,a=>(0,e.normalizeZ)(J,a));if(f){let{k1neg:b,k1:e,k2neg:h,k2:i}=F(a),{p:j,f:k}=g(e),{p:l,f:m}=g(i);d=k.add(m),c=I(f.beta,j,l,b,h)}else{let{p:b,f:e}=g(a);c=b,d=e}return(0,e.normalizeZ)(J,[c,d])[0]}multiplyUnsafe(a){let{endo:c}=b;if(!i.isValid(a))throw Error("invalid scalar: out of range");if(a===k||this.is0())return J.ZERO;if(a===l)return this;if(L.hasCache(this))return this.multiply(a);if(!c)return L.unsafe(this,a);{let{k1neg:b,k1:d,k2neg:f,k2:g}=F(a),{p1:h,p2:i}=(0,e.mulEndoUnsafe)(J,this,d,g);return I(c.beta,h,i,b,f)}}multiplyAndAddUnsafe(a,b,c){let d=this.multiplyUnsafe(b).add(a.multiplyUnsafe(c));return d.is0()?void 0:d}toAffine(a){return G(this,a)}isTorsionFree(){let{isTorsionFree:a}=b;return m===l||(a?a(J,this):L.unsafe(this,s).is0())}clearCofactor(){let{clearCofactor:a}=b;return m===l?this:a?a(J,this):this.multiplyUnsafe(m)}isSmallOrder(){return this.multiplyUnsafe(m).is0()}toBytes(a=!0){return(0,d._abool2)(a,"isCompressed"),this.assertValidity(),x(J,this,a)}toHex(a=!0){return(0,c.bytesToHex)(this.toBytes(a))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(a=!0){return this.toBytes(a)}_setWindowSize(a){this.precompute(a)}static normalizeZ(a){return(0,e.normalizeZ)(J,a)}static msm(a,b){return(0,e.pippenger)(J,i,a,b)}static fromPrivateKey(a){return J.BASE.multiply(p(i,a))}}J.BASE=new J(j.Gx,j.Gy,h.ONE),J.ZERO=new J(h.ZERO,h.ONE,h.ZERO),J.Fp=h,J.Fn=i;let K=i.BITS,L=new e.wNAF(J,b.endo?Math.ceil(K/2):K);return J.BASE.precompute(8),J}function r(a){return Uint8Array.of(a?2:3)}function s(a,b){(0,f.validateField)(a);let{A:c,B:d,Z:e}=b;if(!a.isValid(c)||!a.isValid(d)||!a.isValid(e))throw Error("mapToCurveSimpleSWU: invalid opts");let g=function(a,b){let c=a.ORDER,d=k;for(let a=c-l;a%m===k;a/=m)d+=l;let e=d,f=m<<e-l-l,g=f*m,h=(c-l)/g,i=(h-l)/m,j=g-l,p=a.pow(b,h),q=a.pow(b,(h+l)/m),r=(b,c)=>{let d=p,g=a.pow(c,j),h=a.sqr(g);h=a.mul(h,c);let k=a.mul(b,h);k=a.pow(k,i),k=a.mul(k,g),g=a.mul(k,c),h=a.mul(k,b);let n=a.mul(h,g);k=a.pow(n,f);let o=a.eql(k,a.ONE);g=a.mul(h,q),k=a.mul(n,d),h=a.cmov(g,h,o),n=a.cmov(k,n,o);for(let b=e;b>l;b--){let c=b-m;c=m<<c-l;let e=a.pow(n,c),f=a.eql(e,a.ONE);g=a.mul(h,d),d=a.mul(d,d),e=a.mul(n,d),h=a.cmov(g,h,f),n=a.cmov(e,n,f)}return{isValid:o,value:h}};if(a.ORDER%o===n){let c=(a.ORDER-n)/o,d=a.sqrt(a.neg(b));r=(b,e)=>{let f=a.sqr(e),g=a.mul(b,e);f=a.mul(f,g);let h=a.pow(f,c);h=a.mul(h,g);let i=a.mul(h,d),j=a.mul(a.sqr(h),e),k=a.eql(j,b),l=a.cmov(i,h,k);return{isValid:k,value:l}}}return r}(a,e);if(!a.isOdd)throw Error("Field does not have .isOdd()");return b=>{let h,i,j,k,l,m,n,o;h=a.sqr(b),h=a.mul(h,e),i=a.sqr(h),i=a.add(i,h),j=a.add(i,a.ONE),j=a.mul(j,d),k=a.cmov(e,a.neg(i),!a.eql(i,a.ZERO)),k=a.mul(k,c),i=a.sqr(j),m=a.sqr(k),l=a.mul(m,c),i=a.add(i,l),i=a.mul(i,j),m=a.mul(m,k),l=a.mul(m,d),i=a.add(i,l),n=a.mul(h,j);let{isValid:p,value:q}=g(i,m);o=a.mul(h,b),o=a.mul(o,q),n=a.cmov(n,j,p),o=a.cmov(o,q,p);let r=a.isOdd(b)===a.isOdd(o);o=a.cmov(a.neg(o),o,r);let s=(0,f.FpInvertBatch)(a,[k],!0)[0];return{x:n=a.mul(n,s),y:o}}}function t(a,b){return{secretKey:b.BYTES,publicKey:1+a.BYTES,publicKeyUncompressed:1+2*a.BYTES,publicKeyHasPrefix:!0,signature:2*b.BYTES}}function u(a){let{CURVE:b,curveOpts:c}=v(a);return function(a,b){var c,e;let{Fp:f,Fn:g}=b,h=(c=a.a,e=a.b,function(a){let b=f.sqr(a),d=f.mul(b,a);return f.add(f.add(d,f.mul(a,c)),e)});return Object.assign({},{CURVE:a,Point:b,ProjectivePoint:b,normPrivateKeyToScalar:a=>p(g,a),weierstrassEquation:h,isWithinCurveOrder:function(a){return(0,d.inRange)(a,l,g.ORDER)}})}(a,q(b,c))}function v(a){let b={a:a.a,b:a.b,p:a.Fp.ORDER,n:a.n,h:a.h,Gx:a.Gx,Gy:a.Gy},c=a.Fp,d=a.allowedPrivateKeyLengths?Array.from(new Set(a.allowedPrivateKeyLengths.map(a=>Math.ceil(a/2)))):void 0,e={Fp:c,Fn:(0,f.Field)(b.n,{BITS:a.nBitLength,allowedLengths:d,modFromBytes:a.wrapPrivateKey}),allowInfinityPoint:a.allowInfinityPoint,endo:a.endo,isTorsionFree:a.isTorsionFree,clearCofactor:a.clearCofactor,fromBytes:a.fromBytes,toBytes:a.toBytes};return{CURVE:b,curveOpts:e}}function w(a){let e,{CURVE:g,curveOpts:n,hash:o,ecdsaOpts:s}=function(a){let{CURVE:b,curveOpts:c}=v(a),d={hmac:a.hmac,randomBytes:a.randomBytes,lowS:a.lowS,bits2int:a.bits2int,bits2int_modN:a.bits2int_modN};return{CURVE:b,curveOpts:c,hash:a.hash,ecdsaOpts:d}}(a),u=function(a,e,g={}){(0,c.ahash)(e),(0,d._validateObject)(g,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});let n=g.randomBytes||c.randomBytes,o=g.hmac||((a,...d)=>(0,b.hmac)(e,a,(0,c.concatBytes)(...d))),{Fp:q,Fn:s}=a,{ORDER:u,BITS:v}=s,{keygen:w,getPublicKey:x,getSharedSecret:y,utils:z,lengths:A}=function(a,b={}){let{Fn:e}=a,g=b.randomBytes||c.randomBytes,h=Object.assign(t(a.Fp,e),{seed:(0,f.getMinHashLength)(e.ORDER)});function i(a){try{return!!p(e,a)}catch(a){return!1}}function j(a=g(h.seed)){return(0,f.mapHashToField)((0,d._abytes2)(a,h.seed,"seed"),e.ORDER)}function k(b,c=!0){return a.BASE.multiply(p(e,b)).toBytes(c)}function l(b){if("bigint"==typeof b)return!1;if(b instanceof a)return!0;let{secretKey:c,publicKey:f,publicKeyUncompressed:g}=h;if(e.allowedLengths||c===f)return;let i=(0,d.ensureBytes)("key",b).length;return i===f||i===g}return Object.freeze({getPublicKey:k,getSharedSecret:function(b,c,d=!0){if(!0===l(b))throw Error("first arg must be private key");if(!1===l(c))throw Error("second arg must be public key");let f=p(e,b);return a.fromHex(c).multiply(f).toBytes(d)},keygen:function(a){let b=j(a);return{secretKey:b,publicKey:k(b)}},Point:a,utils:{isValidSecretKey:i,isValidPublicKey:function(b,c){let{publicKey:d,publicKeyUncompressed:e}=h;try{let f=b.length;if(!0===c&&f!==d||!1===c&&f!==e)return!1;return!!a.fromBytes(b)}catch(a){return!1}},randomSecretKey:j,isValidPrivateKey:i,randomPrivateKey:j,normPrivateKeyToScalar:a=>p(e,a),precompute:(b=8,c=a.BASE)=>c.precompute(b,!1)},lengths:h})}(a,g),B={prehash:!1,lowS:"boolean"==typeof g.lowS&&g.lowS,format:void 0,extraEntropy:!1},C="compact";function D(a,b){if(!s.isValidNot0(b))throw Error(`invalid signature ${a}: out of range 1..Point.Fn.ORDER`);return b}class E{constructor(a,b,c){this.r=D("r",a),this.s=D("s",b),null!=c&&(this.recovery=c),Object.freeze(this)}static fromBytes(a,b=C){var c,e;let f,g;if(c=a,h(e=b),g=A.signature,(0,d._abytes2)(c,"compact"===e?g:"recovered"===e?g+1:void 0,`${e} signature`),"der"===b){let{r:b,s:c}=j.toSig((0,d._abytes2)(a));return new E(b,c)}"recovered"===b&&(f=a[0],b="compact",a=a.subarray(1));let i=s.BYTES,k=a.subarray(0,i),l=a.subarray(i,2*i);return new E(s.fromBytes(k),s.fromBytes(l),f)}static fromHex(a,b){return this.fromBytes((0,c.hexToBytes)(a),b)}addRecoveryBit(a){return new E(this.r,this.s,a)}recoverPublicKey(b){let e=q.ORDER,{r:f,s:g,recovery:h}=this;if(null==h||![0,1,2,3].includes(h))throw Error("recovery id invalid");if(u*m<e&&h>1)throw Error("recovery id is ambiguous for h>1 curve");let i=2===h||3===h?f+u:f;if(!q.isValid(i))throw Error("recovery id 2 or 3 invalid");let j=q.toBytes(i),k=a.fromBytes((0,c.concatBytes)(r((1&h)==0),j)),l=s.inv(i),n=G((0,d.ensureBytes)("msgHash",b)),o=s.create(-n*l),p=s.create(g*l),t=a.BASE.multiplyUnsafe(o).add(k.multiplyUnsafe(p));if(t.is0())throw Error("point at infinify");return t.assertValidity(),t}hasHighS(){return this.s>u>>l}toBytes(a=C){if(h(a),"der"===a)return(0,c.hexToBytes)(j.hexFromSig(this));let b=s.toBytes(this.r),d=s.toBytes(this.s);if("recovered"===a){if(null==this.recovery)throw Error("recovery bit must be present");return(0,c.concatBytes)(Uint8Array.of(this.recovery),b,d)}return(0,c.concatBytes)(b,d)}toHex(a){return(0,c.bytesToHex)(this.toBytes(a))}assertValidity(){}static fromCompact(a){return E.fromBytes((0,d.ensureBytes)("sig",a),"compact")}static fromDER(a){return E.fromBytes((0,d.ensureBytes)("sig",a),"der")}normalizeS(){return this.hasHighS()?new E(this.r,s.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return(0,c.bytesToHex)(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return(0,c.bytesToHex)(this.toBytes("compact"))}}let F=g.bits2int||function(a){if(a.length>8192)throw Error("input is too large");let b=(0,d.bytesToNumberBE)(a),c=8*a.length-v;return c>0?b>>BigInt(c):b},G=g.bits2int_modN||function(a){return s.create(F(a))},H=(0,d.bitMask)(v);function I(a){return(0,d.aInRange)("num < 2^"+v,a,k,H),s.toBytes(a)}function J(a,b){return(0,d._abytes2)(a,void 0,"message"),b?(0,d._abytes2)(e(a),void 0,"prehashed message"):a}return Object.freeze({keygen:w,getPublicKey:x,getSharedSecret:y,utils:z,lengths:A,Point:a,sign:function(b,f,g={}){let{seed:h,k2sig:j}=function(b,e,f){if(["recovered","canonical"].some(a=>a in f))throw Error("sign() legacy options not supported");let{lowS:g,prehash:h,extraEntropy:j}=i(f,B),m=G(b=J(b,h)),o=p(s,e),q=[I(o),I(m)];if(null!=j&&!1!==j){let a=!0===j?n(A.secretKey):j;q.push((0,d.ensureBytes)("extraEntropy",a))}return{seed:(0,c.concatBytes)(...q),k2sig:function(b){let c=F(b);if(!s.isValidNot0(c))return;let d=s.inv(c),e=a.BASE.multiply(c).toAffine(),f=s.create(e.x);if(f===k)return;let h=s.create(d*s.create(m+f*o));if(h===k)return;let i=2*(e.x!==f)|Number(e.y&l),j=h;return g&&h>u>>l&&(j=s.neg(h),i^=1),new E(f,j,i)}}}(b=(0,d.ensureBytes)("message",b),f,g);return(0,d.createHmacDrbg)(e.outputLen,s.BYTES,o)(h,j)},verify:function(b,e,f,g={}){let{lowS:h,prehash:k,format:l}=i(g,B);if(f=(0,d.ensureBytes)("publicKey",f),e=J((0,d.ensureBytes)("message",e),k),"strict"in g)throw Error("options.strict was renamed to lowS");let m=void 0===l?function(a){let b,e="string"==typeof a||(0,c.isBytes)(a),f=!e&&null!==a&&"object"==typeof a&&"bigint"==typeof a.r&&"bigint"==typeof a.s;if(!e&&!f)throw Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(f)b=new E(a.r,a.s);else if(e){try{b=E.fromBytes((0,d.ensureBytes)("sig",a),"der")}catch(a){if(!(a instanceof j.Err))throw a}if(!b)try{b=E.fromBytes((0,d.ensureBytes)("sig",a),"compact")}catch(a){return!1}}return!!b&&b}(b):E.fromBytes((0,d.ensureBytes)("sig",b),l);if(!1===m)return!1;try{let b=a.fromBytes(f);if(h&&m.hasHighS())return!1;let{r:c,s:d}=m,g=G(e),i=s.inv(d),j=s.create(g*i),k=s.create(c*i),l=a.BASE.multiplyUnsafe(j).add(b.multiplyUnsafe(k));if(l.is0())return!1;return s.create(l.x)===c}catch(a){return!1}},recoverPublicKey:function(a,b,c={}){let{prehash:d}=i(c,B);return b=J(b,d),E.fromBytes(a,"recovered").recoverPublicKey(b).toBytes()},Signature:E,hash:e})}(q(g,n),o,s);return e=u.Point,Object.assign({},u,{ProjectivePoint:e,CURVE:Object.assign({},a,(0,f.nLength)(e.Fn.ORDER,e.Fn.BITS))})}a.s(["_normFnElement",()=>p,"mapToCurveSimpleSWU",()=>s,"weierstrass",()=>w,"weierstrassPoints",()=>u])},433830,a=>{"use strict";var b=a.i(242587);function c(a,c){let d=c=>(0,b.weierstrass)({...a,hash:c});return{...d(c),create:d}}a.s(["createCurve",()=>c])},293259,359029,57871,a=>{"use strict";var b=a.i(835962),c=a.i(677832);let d=BigInt(0),e=BigInt(1),f=BigInt(2),g=BigInt(3),h=BigInt(4),i=BigInt(5),j=BigInt(7),k=BigInt(8),l=BigInt(9),m=BigInt(16);function n(a,b){let c=a%b;return c>=d?c:b+c}function o(a,b,c){let e=a;for(;b-- >d;)e*=e,e%=c;return e}function p(a,b){if(a===d)throw Error("invert: expected non-zero number");if(b<=d)throw Error("invert: expected positive modulus, got "+b);let c=n(a,b),f=b,g=d,h=e,i=e,j=d;for(;c!==d;){let a=f/c,b=f%c,d=g-i*a,e=h-j*a;f=c,c=b,g=i,h=j,i=d,j=e}if(f!==e)throw Error("invert: does not exist");return n(g,b)}function q(a,b,c){if(!a.eql(a.sqr(b),c))throw Error("Cannot find square root")}function r(a,b){let c=(a.ORDER+e)/h,d=a.pow(b,c);return q(a,d,b),d}function s(a,b){let c=(a.ORDER-i)/k,d=a.mul(b,f),e=a.pow(d,c),g=a.mul(b,e),h=a.mul(a.mul(g,f),e),j=a.mul(g,a.sub(h,a.ONE));return q(a,j,b),j}function t(a){if(a<g)throw Error("sqrt is not defined for small field");let b=a-e,c=0;for(;b%f===d;)b/=f,c++;let h=f,i=A(a);for(;1===y(i,h);)if(h++>1e3)throw Error("Cannot find square root: probably non-prime P");if(1===c)return r;let j=i.pow(h,b),k=(b+e)/f;return function(a,d){if(a.is0(d))return d;if(1!==y(a,d))throw Error("Cannot find square root");let f=c,g=a.mul(a.ONE,j),h=a.pow(d,b),i=a.pow(d,k);for(;!a.eql(h,a.ONE);){if(a.is0(h))return a.ZERO;let b=1,c=a.sqr(h);for(;!a.eql(c,a.ONE);)if(b++,c=a.sqr(c),b===f)throw Error("Cannot find square root");let d=e<<BigInt(f-b-1),j=a.pow(g,d);f=b,g=a.sqr(j),h=a.mul(h,g),i=a.mul(i,j)}return i}}let u=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function v(a){let c=u.reduce((a,b)=>(a[b]="function",a),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"});return(0,b._validateObject)(a,c),a}function w(a,b,c){if(c<d)throw Error("invalid exponent, negatives unsupported");if(c===d)return a.ONE;if(c===e)return b;let f=a.ONE,g=b;for(;c>d;)c&e&&(f=a.mul(f,g)),g=a.sqr(g),c>>=e;return f}function x(a,b,c=!1){let d=Array(b.length).fill(c?a.ZERO:void 0),e=b.reduce((b,c,e)=>a.is0(c)?b:(d[e]=b,a.mul(b,c)),a.ONE),f=a.inv(e);return b.reduceRight((b,c,e)=>a.is0(c)?b:(d[e]=a.mul(b,d[e]),a.mul(b,c)),f),d}function y(a,b){let c=(a.ORDER-e)/f,d=a.pow(b,c),g=a.eql(d,a.ONE),h=a.eql(d,a.ZERO),i=a.eql(d,a.neg(a.ONE));if(!g&&!h&&!i)throw Error("invalid Legendre symbol result");return g?1:h?0:-1}function z(a,b){void 0!==b&&(0,c.anumber)(b);let d=void 0!==b?b:a.toString(2).length,e=Math.ceil(d/8);return{nBitLength:d,nByteLength:e}}function A(a,c,f=!1,o={}){let u,v,y,B;if(a<=d)throw Error("invalid field: expected ORDER > 0, got "+a);let C=!1;if("object"==typeof c&&null!=c){if(o.sqrt||f)throw Error("cannot specify opts in two arguments");c.BITS&&(v=c.BITS),c.sqrt&&(y=c.sqrt),"boolean"==typeof c.isLE&&(f=c.isLE),"boolean"==typeof c.modFromBytes&&(C=c.modFromBytes),B=c.allowedLengths}else"number"==typeof c&&(v=c),o.sqrt&&(y=o.sqrt);let{nBitLength:D,nByteLength:E}=z(a,v);if(E>2048)throw Error("invalid field: expected ORDER of <= 2048 bytes");let F=Object.freeze({ORDER:a,isLE:f,BITS:D,BYTES:E,MASK:(0,b.bitMask)(D),ZERO:d,ONE:e,allowedLengths:B,create:b=>n(b,a),isValid:b=>{if("bigint"!=typeof b)throw Error("invalid field element: expected bigint, got "+typeof b);return d<=b&&b<a},is0:a=>a===d,isValidNot0:a=>!F.is0(a)&&F.isValid(a),isOdd:a=>(a&e)===e,neg:b=>n(-b,a),eql:(a,b)=>a===b,sqr:b=>n(b*b,a),add:(b,c)=>n(b+c,a),sub:(b,c)=>n(b-c,a),mul:(b,c)=>n(b*c,a),pow:(a,b)=>w(F,a,b),div:(b,c)=>n(b*p(c,a),a),sqrN:a=>a*a,addN:(a,b)=>a+b,subN:(a,b)=>a-b,mulN:(a,b)=>a*b,inv:b=>p(b,a),sqrt:y||(b=>(u||(u=function(a){if(a%h===g)return r;if(a%k===i)return s;if(a%m===l){let b,c,d,e,f,g;return b=A(a),d=(c=t(a))(b,b.neg(b.ONE)),e=c(b,d),f=c(b,b.neg(d)),g=(a+j)/m,(a,b)=>{let c=a.pow(b,g),h=a.mul(c,d),i=a.mul(c,e),j=a.mul(c,f),k=a.eql(a.sqr(h),b),l=a.eql(a.sqr(i),b);c=a.cmov(c,h,k),h=a.cmov(j,i,l);let m=a.eql(a.sqr(h),b),n=a.cmov(c,h,m);return q(a,n,b),n}}return t(a)}(a)),u(F,b))),toBytes:a=>f?(0,b.numberToBytesLE)(a,E):(0,b.numberToBytesBE)(a,E),fromBytes:(c,d=!0)=>{if(B){if(!B.includes(c.length)||c.length>E)throw Error("Field.fromBytes: expected "+B+" bytes, got "+c.length);let a=new Uint8Array(E);a.set(c,f?0:a.length-c.length),c=a}if(c.length!==E)throw Error("Field.fromBytes: expected "+E+" bytes, got "+c.length);let e=f?(0,b.bytesToNumberLE)(c):(0,b.bytesToNumberBE)(c);if(C&&(e=n(e,a)),!d&&!F.isValid(e))throw Error("invalid field element: outside of range 0..ORDER");return e},invertBatch:a=>x(F,a),cmov:(a,b,c)=>c?b:a});return Object.freeze(F)}function B(a,b){if(!a.isOdd)throw Error("Field doesn't have isOdd");let c=a.sqrt(b);return a.isOdd(c)?a.neg(c):c}function C(a){if("bigint"!=typeof a)throw Error("field order must be bigint");return Math.ceil(a.toString(2).length/8)}function D(a){let b=C(a);return b+Math.ceil(b/2)}function E(a,c,d=!1){let f=a.length,g=C(c),h=D(c);if(f<16||f<h||f>1024)throw Error("expected "+h+"-1024 bytes of input, got "+f);let i=n(d?(0,b.bytesToNumberLE)(a):(0,b.bytesToNumberBE)(a),c-e)+e;return d?(0,b.numberToBytesLE)(i,g):(0,b.numberToBytesBE)(i,g)}a.s(["Field",()=>A,"FpInvertBatch",()=>x,"FpLegendre",()=>y,"FpPow",()=>w,"FpSqrtEven",()=>B,"getMinHashLength",()=>D,"isNegativeLE",0,(a,b)=>(n(a,b)&e)===e,"mapHashToField",()=>E,"mod",()=>n,"nLength",()=>z,"pow2",()=>o,"validateField",()=>v],359029);let F=BigInt(0),G=BigInt(1);function H(a,b){let c=b.negate();return a?c:b}function I(a,b){let c=x(a.Fp,b.map(a=>a.Z));return b.map((b,d)=>a.fromAffine(b.toAffine(c[d])))}function J(a,b){if(!Number.isSafeInteger(a)||a<=0||a>b)throw Error("invalid window size, expected [1.."+b+"], got W="+a)}function K(a,c){J(a,c);let d=Math.ceil(c/a)+1,e=2**(a-1),f=2**a;return{windows:d,windowSize:e,mask:(0,b.bitMask)(a),maxNumber:f,shiftBy:BigInt(a)}}function L(a,b,c){let{windowSize:d,mask:e,maxNumber:f,shiftBy:g}=c,h=Number(a&e),i=a>>g;h>d&&(h-=f,i+=G);let j=b*d,k=j+Math.abs(h)-1,l=0===h;return{nextN:i,offset:k,isZero:l,isNeg:h<0,isNegF:b%2!=0,offsetF:j}}let M=new WeakMap,N=new WeakMap;function O(a){return N.get(a)||1}function P(a){if(a!==F)throw Error("invalid wNAF")}class Q{constructor(a,b){this.BASE=a.BASE,this.ZERO=a.ZERO,this.Fn=a.Fn,this.bits=b}_unsafeLadder(a,b,c=this.ZERO){let d=a;for(;b>F;)b&G&&(c=c.add(d)),d=d.double(),b>>=G;return c}precomputeWindow(a,b){let{windows:c,windowSize:d}=K(b,this.bits),e=[],f=a,g=f;for(let a=0;a<c;a++){g=f,e.push(g);for(let a=1;a<d;a++)g=g.add(f),e.push(g);f=g.double()}return e}wNAF(a,b,c){if(!this.Fn.isValid(c))throw Error("invalid scalar");let d=this.ZERO,e=this.BASE,f=K(a,this.bits);for(let a=0;a<f.windows;a++){let{nextN:g,offset:h,isZero:i,isNeg:j,isNegF:k,offsetF:l}=L(c,a,f);c=g,i?e=e.add(H(k,b[l])):d=d.add(H(j,b[h]))}return P(c),{p:d,f:e}}wNAFUnsafe(a,b,c,d=this.ZERO){let e=K(a,this.bits);for(let a=0;a<e.windows&&c!==F;a++){let{nextN:f,offset:g,isZero:h,isNeg:i}=L(c,a,e);if(c=f,!h){let a=b[g];d=d.add(i?a.negate():a)}}return P(c),d}getPrecomputes(a,b,c){let d=M.get(b);return d||(d=this.precomputeWindow(b,a),1!==a&&("function"==typeof c&&(d=c(d)),M.set(b,d))),d}cached(a,b,c){let d=O(a);return this.wNAF(d,this.getPrecomputes(d,a,c),b)}unsafe(a,b,c,d){let e=O(a);return 1===e?this._unsafeLadder(a,b,d):this.wNAFUnsafe(e,this.getPrecomputes(e,a,c),b,d)}createCache(a,b){J(b,this.bits),N.set(a,b),M.delete(a)}hasCache(a){return 1!==O(a)}}function R(a,b,c,d){let e=b,f=a.ZERO,g=a.ZERO;for(;c>F||d>F;)c&G&&(f=f.add(e)),d&G&&(g=g.add(e)),e=e.double(),c>>=G,d>>=G;return{p1:f,p2:g}}function S(a,c,d,e){if(!Array.isArray(d))throw Error("array expected");d.forEach((b,c)=>{if(!(b instanceof a))throw Error("invalid point at index "+c)});if(!Array.isArray(e))throw Error("array of scalars expected");e.forEach((a,b)=>{if(!c.isValid(a))throw Error("invalid scalar at index "+b)});let f=d.length,g=e.length;if(f!==g)throw Error("arrays of points and scalars must have equal length");let h=a.ZERO,i=(0,b.bitLen)(BigInt(f)),j=1;i>12?j=i-3:i>4?j=i-2:i>0&&(j=2);let k=(0,b.bitMask)(j),l=Array(Number(k)+1).fill(h),m=Math.floor((c.BITS-1)/j)*j,n=h;for(let a=m;a>=0;a-=j){l.fill(h);for(let b=0;b<g;b++){let c=Number(e[b]>>BigInt(a)&k);l[c]=l[c].add(d[b])}let b=h;for(let a=l.length-1,c=h;a>0;a--)c=c.add(l[a]),b=b.add(c);if(n=n.add(b),0!==a)for(let a=0;a<j;a++)n=n.double()}return n}function T(a,b,c){if(!b)return A(a,{isLE:c});if(b.ORDER!==a)throw Error("Field.ORDER must match order: Fp == p, Fn == n");return v(b),b}function U(a,b,c={},d){if(void 0===d&&(d="edwards"===a),!b||"object"!=typeof b)throw Error(`expected valid ${a} CURVE object`);for(let a of["p","n","h"]){let c=b[a];if(!("bigint"==typeof c&&c>F))throw Error(`CURVE.${a} must be positive bigint`)}let e=T(b.p,c.Fp,d),f=T(b.n,c.Fn,d);for(let c of["Gx","Gy","a","weierstrass"===a?"b":"d"])if(!e.isValid(b[c]))throw Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return{CURVE:b=Object.freeze(Object.assign({},b)),Fp:e,Fn:f}}a.s(["_createCurveFields",()=>U,"mulEndoUnsafe",()=>R,"negateCt",()=>H,"normalizeZ",()=>I,"pippenger",()=>S,"wNAF",()=>Q],293259);let V=b.bytesToNumberBE;function W(a,b){if(X(a),X(b),a<0||a>=1<<8*b)throw Error("invalid I2OSP input: "+a);let c=Array.from({length:b}).fill(0);for(let d=b-1;d>=0;d--)c[d]=255&a,a>>>=8;return new Uint8Array(c)}function X(a){if(!Number.isSafeInteger(a))throw Error("number expected")}function Y(a){if(!(0,c.isBytes)(a)&&"string"!=typeof a)throw Error("DST must be Uint8Array or string");return"string"==typeof a?(0,c.utf8ToBytes)(a):a}function Z(a,b,d,e){(0,c.abytes)(a),X(d),(b=Y(b)).length>255&&(b=e((0,c.concatBytes)((0,c.utf8ToBytes)("H2C-OVERSIZE-DST-"),b)));let{outputLen:f,blockLen:g}=e,h=Math.ceil(d/f);if(d>65535||h>255)throw Error("expand_message_xmd: invalid lenInBytes");let i=(0,c.concatBytes)(b,W(b.length,1)),j=W(0,g),k=W(d,2),l=Array(h),m=e((0,c.concatBytes)(j,a,k,W(0,1),i));l[0]=e((0,c.concatBytes)(m,W(1,1),i));for(let a=1;a<=h;a++){let b=[function(a,b){let c=new Uint8Array(a.length);for(let d=0;d<a.length;d++)c[d]=a[d]^b[d];return c}(m,l[a-1]),W(a+1,1),i];l[a]=e((0,c.concatBytes)(...b))}return(0,c.concatBytes)(...l).slice(0,d)}function $(a,d,e){let f;(0,b._validateObject)(e,{p:"bigint",m:"number",k:"number",hash:"function"});let{p:g,k:h,m:i,hash:j,expand:k,DST:l}=e;if(!(0,b.isHash)(e.hash))throw Error("expected valid hash");(0,c.abytes)(a),X(d);let m=Math.ceil((g.toString(2).length+h)/8),o=d*i*m;if("xmd"===k)f=Z(a,l,o,j);else if("xof"===k)f=function(a,b,d,e,f){if((0,c.abytes)(a),X(d),(b=Y(b)).length>255){let a=Math.ceil(2*e/8);b=f.create({dkLen:a}).update((0,c.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(b).digest()}if(d>65535||b.length>255)throw Error("expand_message_xof: invalid lenInBytes");return f.create({dkLen:d}).update(a).update(W(d,2)).update(b).update(W(b.length,1)).digest()}(a,l,o,h,j);else if("_internal_pass"===k)f=a;else throw Error('expand must be "xmd" or "xof"');let p=Array(d);for(let a=0;a<d;a++){let b=Array(i);for(let c=0;c<i;c++){let d=m*(c+a*i),e=f.subarray(d,d+m);b[c]=n(V(e),g)}p[a]=b}return p}function _(a,b){let c=b.map(a=>Array.from(a).reverse());return(b,d)=>{let[e,f,g,h]=c.map(c=>c.reduce((c,d)=>a.add(a.mul(c,b),d))),[i,j]=x(a,[f,h],!0);return b=a.mul(e,i),d=a.mul(d,a.mul(g,j)),{x:b,y:d}}}let aa=(0,c.utf8ToBytes)("HashToScalar-");function ab(a,b,c){if("function"!=typeof b)throw Error("mapToCurve() must be defined");function d(c){return a.fromAffine(b(c))}function e(b){let c=b.clearCofactor();return c.equals(a.ZERO)?a.ZERO:(c.assertValidity(),c)}return{defaults:c,hashToCurve(a,b){let f=$(a,2,Object.assign({},c,b)),g=d(f[0]),h=d(f[1]);return e(g.add(h))},encodeToCurve(a,b){let f=c.encodeDST?{DST:c.encodeDST}:{};return e(d($(a,1,Object.assign({},c,f,b))[0]))},mapToCurve(a){if(!Array.isArray(a))throw Error("expected array of bigints");for(let b of a)if("bigint"!=typeof b)throw Error("expected array of bigints");return e(d(a))},hashToScalar:(b,d)=>$(b,1,Object.assign({},c,{p:a.Fn.ORDER,m:1,DST:aa},d))[0][0]}}a.s(["_DST_scalar",0,aa,"createHasher",()=>ab,"expand_message_xmd",()=>Z,"isogenyMap",()=>_],57871)},862497,a=>{"use strict";let b;var c,d,e=a.i(516148),f=a.i(433830),g=a.i(57871),h=a.i(359029),i=a.i(242587);let j={p:BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"),n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),h:BigInt(1),a:BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"),b:BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5")},k={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),h:BigInt(1),a:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"),b:BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f")},l={p:BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),n:BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),h:BigInt(1),a:BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"),b:BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),Gx:BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),Gy:BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")},m=(0,h.Field)(j.p),n=(0,h.Field)(k.p),o=(0,h.Field)(l.p),p=(0,f.createCurve)({...j,Fp:m,lowS:!1},e.sha256),q=(0,g.createHasher)(p.Point,(c=p.Point,d={A:j.a,B:j.b,Z:p.Point.Fp.create(BigInt("-10"))},b=(0,i.mapToCurveSimpleSWU)(c.Fp,d),a=>b(a[0])),{DST:"P256_XMD:SHA-256_SSWU_RO_",encodeDST:"P256_XMD:SHA-256_SSWU_NU_",p:j.p,m:1,k:128,expand:"xmd",hash:e.sha256});(0,f.createCurve)({...k,Fp:n,lowS:!1},e.sha384),(0,f.createCurve)({...l,Fp:o,lowS:!1,allowedPrivateKeyLengths:[130,131,132]},e.sha512),a.s(["p256",0,p,"p256_hasher",0,q])},707140,a=>{"use strict";var b=a.i(677832),c=a.i(835962);b.abytes,b.anumber,b.bytesToHex,b.bytesToUtf8,b.concatBytes,b.hexToBytes,b.isBytes,b.randomBytes,b.utf8ToBytes,c.abool,c.numberToHexUnpadded,c.hexToNumber;let d=c.bytesToNumberBE;c.bytesToNumberLE,c.numberToBytesBE,c.numberToBytesLE,c.numberToVarBytesBE,c.ensureBytes;let e=c.equalBytes;c.copyBytes,c.asciiToBytes,c.inRange,c.aInRange,c.bitLen,c.bitGet,c.bitSet,c.bitMask,c.createHmacDrbg,c.notImplemented,c.memoized,c.validateObject,c.isHash,a.s(["bytesToNumberBE",0,d,"equalBytes",0,e])},654476,a=>{"use strict";var b=a.i(516148),c=a.i(677832),d=a.i(433830),e=a.i(57871),f=a.i(359029),g=a.i(242587),h=a.i(835962);let i={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},j={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},k=BigInt(0),l=BigInt(2),m=(0,f.Field)(i.p,{sqrt:function(a){let b=i.p,c=BigInt(3),d=BigInt(6),e=BigInt(11),g=BigInt(22),h=BigInt(23),j=BigInt(44),k=BigInt(88),n=a*a*a%b,o=n*n*a%b,p=(0,f.pow2)(o,c,b)*o%b,q=(0,f.pow2)(p,c,b)*o%b,r=(0,f.pow2)(q,l,b)*n%b,s=(0,f.pow2)(r,e,b)*r%b,t=(0,f.pow2)(s,g,b)*s%b,u=(0,f.pow2)(t,j,b)*t%b,v=(0,f.pow2)(u,k,b)*u%b,w=(0,f.pow2)(v,j,b)*t%b,x=(0,f.pow2)(w,c,b)*o%b,y=(0,f.pow2)(x,h,b)*s%b,z=(0,f.pow2)(y,d,b)*n%b,A=(0,f.pow2)(z,l,b);if(!m.eql(m.sqr(A),a))throw Error("Cannot find square root");return A}}),n=(0,d.createCurve)({...i,Fp:m,lowS:!0,endo:j},b.sha256);n.Point;h.bytesToNumberBE;let o=(0,e.isogenyMap)(m,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(a=>a.map(a=>BigInt(a)))),p=(0,g.mapToCurveSimpleSWU)(m,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:m.create(BigInt("-11"))});(0,e.createHasher)(n.Point,a=>{let{x:b,y:c}=p(m.create(a[0]));return o(b,c)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:m.ORDER,m:1,k:128,expand:"xmd",hash:b.sha256}),a.s(["secp256k1",0,n])}];

//# sourceMappingURL=node_modules_%40noble_curves_esm_a345d5d4._.js.map
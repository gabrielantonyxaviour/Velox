module.exports=[760912,a=>{"use strict";var b=a.i(602383),c=a.i(346280),d=a.i(109450),e=a.i(135323),f=a.i(94702),g=a.i(39647),h=a.i(883148),i=a.i(447649),j=a.i(922848),k=a.i(37252),l=a.i(321590),m=a.i(898965),n=a.i(473439),o=a.i(353292),p=a.i(977601),q=a.i(583335),r=a.i(316266);let s={convertEVMChainIdToCoinType(a){if(a>=0x80000000)throw Error("Invalid chainId");return(0x80000000|a)>>>0}};var t=a.i(82228),u=a.i(929581),v=a.i(667625);let w=(0,q.proxy)({suggestions:[],loading:!1}),x=(0,u.withErrorBoundary)({state:w,subscribe:a=>(0,q.subscribe)(w,()=>a(w)),subscribeKey:(a,b)=>(0,r.subscribeKey)(w,a,b),async resolveName(a){try{return await n.BlockchainApiController.lookupEnsName(a)}catch(a){throw Error(a?.reasons?.[0]?.description||"Error resolving name")}},async isNameRegistered(a){try{return await n.BlockchainApiController.lookupEnsName(a),!0}catch{return!1}},async getSuggestions(a){try{return w.loading=!0,w.suggestions=[],w.suggestions=(await n.BlockchainApiController.getEnsNameSuggestions(a)).suggestions||[],w.suggestions}catch(a){throw Error(x.parseEnsApiError(a,"Error fetching name suggestions"))}finally{w.loading=!1}},async getNamesForAddress(a){try{if(!b.ChainController.state.activeCaipNetwork)return[];let c=t.StorageUtil.getEnsFromCacheForAddress(a);if(c)return c;let d=await n.BlockchainApiController.reverseLookupEnsName({address:a});return t.StorageUtil.updateEnsCache({address:a,ens:d,timestamp:Date.now()}),d}catch(a){throw Error(x.parseEnsApiError(a,"Error fetching names for address"))}},async registerName(a){let e=b.ChainController.state.activeCaipNetwork,f=b.ChainController.getAccountData(e?.chainNamespace)?.address,g=d.ConnectorController.getAuthConnector();if(!e)throw Error("Network not found");if(!f||!g)throw Error("Address or auth connector not found");w.loading=!0;try{let d=JSON.stringify({name:a,attributes:{},timestamp:Math.floor(Date.now()/1e3)});v.RouterController.pushTransactionStack({onCancel(){v.RouterController.replace("RegisterAccountName")}});let g=await c.ConnectionController.signMessage(d);w.loading=!1;let h=e.id;if(!h)throw Error("Network not found");let i=s.convertEVMChainIdToCoinType(Number(h));await n.BlockchainApiController.registerEnsName({coinType:i,address:f,signature:g,message:d}),b.ChainController.setAccountProp("profileName",a,e.chainNamespace),t.StorageUtil.updateEnsCache({address:f,ens:[{name:a,registered_at:new Date().toISOString(),updated_at:void 0,addresses:{},attributes:[]}],timestamp:Date.now()}),v.RouterController.replace("RegisterAccountNameSuccess")}catch(c){let b=x.parseEnsApiError(c,`Error registering name ${a}`);throw v.RouterController.replace("RegisterAccountName"),Error(b)}finally{w.loading=!1}},validateName:a=>/^[a-zA-Z0-9-]{4,}$/u.test(a),parseEnsApiError:(a,b)=>a?.reasons?.[0]?.description||b});var y=a.i(242528),z=a.i(786183);let A={id:"2b92315d-eab7-5bef-84fa-089a131333f5",name:"USD Coin",symbol:"USDC",networks:[{name:"ethereum-mainnet",display_name:"Ethereum",chain_id:"1",contract_address:"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"},{name:"polygon-mainnet",display_name:"Polygon",chain_id:"137",contract_address:"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"}]},B={id:"USD",payment_method_limits:[{id:"card",min:"10.00",max:"7500.00"},{id:"ach_bank_account",min:"10.00",max:"25000.00"}]},C={providers:p.ONRAMP_PROVIDERS,selectedProvider:null,error:null,purchaseCurrency:A,paymentCurrency:B,purchaseCurrencies:[A],paymentCurrencies:[],quotesLoading:!1},D=(0,q.proxy)(C),E=(0,u.withErrorBoundary)({state:D,subscribe:a=>(0,q.subscribe)(D,()=>a(D)),subscribeKey:(a,b)=>(0,r.subscribeKey)(D,a,b),setSelectedProvider(a){if(a&&"meld"===a.name){let c=b.ChainController.state.activeChain,d=c===h.ConstantsUtil.CHAIN.SOLANA?"SOL":"USDC",e=c?b.ChainController.state.chains.get(c)?.accountState?.address??"":"",g=new URL(a.url);g.searchParams.append("publicKey",p.MELD_PUBLIC_KEY),g.searchParams.append("destinationCurrencyCode",d),g.searchParams.append("walletAddress",e),g.searchParams.append("externalCustomerId",f.OptionsController.state.projectId),D.selectedProvider={...a,url:g.toString()}}else D.selectedProvider=a},setOnrampProviders(a){Array.isArray(a)&&a.every(a=>"string"==typeof a)?D.providers=p.ONRAMP_PROVIDERS.filter(b=>a.includes(b.name)):D.providers=[]},setPurchaseCurrency(a){D.purchaseCurrency=a},setPaymentCurrency(a){D.paymentCurrency=a},setPurchaseAmount(a){E.state.purchaseAmount=a},setPaymentAmount(a){E.state.paymentAmount=a},async getAvailableCurrencies(){let a=await n.BlockchainApiController.getOnrampOptions();D.purchaseCurrencies=a.purchaseCurrencies,D.paymentCurrencies=a.paymentCurrencies,D.paymentCurrency=a.paymentCurrencies[0]||B,D.purchaseCurrency=a.purchaseCurrencies[0]||A,await l.ApiController.fetchCurrencyImages(a.paymentCurrencies.map(a=>a.id)),await l.ApiController.fetchTokenImages(a.purchaseCurrencies.map(a=>a.symbol))},async getQuote(){D.quotesLoading=!0;try{let a=await n.BlockchainApiController.getOnrampQuote({purchaseCurrency:D.purchaseCurrency,paymentCurrency:D.paymentCurrency,amount:D.paymentAmount?.toString()||"0",network:D.purchaseCurrency?.symbol});return D.quotesLoading=!1,D.purchaseAmount=Number(a?.purchaseAmount.amount),a}catch(a){return D.error=a.message,D.quotesLoading=!1,null}finally{D.quotesLoading=!1}},resetState(){D.selectedProvider=null,D.error=null,D.purchaseCurrency=A,D.paymentCurrency=B,D.purchaseCurrencies=[A],D.paymentCurrencies=[],D.paymentAmount=void 0,D.purchaseAmount=void 0,D.quotesLoading=!1}}),F={eip155:void 0,solana:void 0,polkadot:void 0,bip122:void 0,cosmos:void 0,sui:void 0,stacks:void 0},G=(0,q.proxy)({providers:{...F},providerIds:{...F}}),H={state:G,subscribeKey:(a,b)=>(0,r.subscribeKey)(G,a,b),subscribe:a=>(0,q.subscribe)(G,()=>{a(G)}),subscribeProviders:a=>(0,q.subscribe)(G.providers,()=>a(G.providers)),setProvider(a,b){a&&b&&(G.providers[a]=(0,q.ref)(b))},getProvider(a){if(a)return G.providers[a]},setProviderId(a,b){b&&(G.providerIds[a]=b)},getProviderId(a){if(a)return G.providerIds[a]},reset(){G.providers={...F},G.providerIds={...F}},resetChain(a){G.providers[a]=void 0,G.providerIds[a]=void 0}};var I=a.i(284799),J=a.i(720214),K=a.i(411210),L=a.i(531657),M=a.i(371188),N=a.i(435044),O=a.i(287862);a.i(974991);var P=a.i(951028);a.i(639170);var Q=a.i(638183),R=a.i(121392),S=a.i(392911);let T={METMASK_CONNECTOR_NAME:"MetaMask",TRUST_CONNECTOR_NAME:"Trust Wallet",SOLFLARE_CONNECTOR_NAME:"Solflare",PHANTOM_CONNECTOR_NAME:"Phantom",COIN98_CONNECTOR_NAME:"Coin98",MAGIC_EDEN_CONNECTOR_NAME:"Magic Eden",BACKPACK_CONNECTOR_NAME:"Backpack",BITGET_CONNECTOR_NAME:"Bitget Wallet",FRONTIER_CONNECTOR_NAME:"Frontier",XVERSE_CONNECTOR_NAME:"Xverse Wallet",LEATHER_CONNECTOR_NAME:"Leather",OKX_CONNECTOR_NAME:"OKX Wallet",EIP155:h.ConstantsUtil.CHAIN.EVM,ADD_CHAIN_METHOD:"wallet_addEthereumChain",EIP6963_ANNOUNCE_EVENT:"eip6963:announceProvider",EIP6963_REQUEST_EVENT:"eip6963:requestProvider",CONNECTOR_RDNS_MAP:{coinbaseWallet:"com.coinbase.wallet",coinbaseWalletSDK:"com.coinbase.wallet"},CONNECTOR_TYPE_EXTERNAL:"EXTERNAL",CONNECTOR_TYPE_WALLET_CONNECT:"WALLET_CONNECT",CONNECTOR_TYPE_INJECTED:"INJECTED",CONNECTOR_TYPE_ANNOUNCED:"ANNOUNCED",CONNECTOR_TYPE_AUTH:"AUTH",CONNECTOR_TYPE_MULTI_CHAIN:"MULTI_CHAIN",CONNECTOR_TYPE_W3M_AUTH:"ID_AUTH",getSDKVersionWarningMessage:(a,b)=>`
     @@@@@@@           @@@@@@@@@@@@@@@@@@      
   @@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@   
  @@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@  
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@  
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@@@   @@@@@@@@@@@ 
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@@   @@@@@@@@@@@@ 
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@@  @@@@@@@@@@@@@
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@   @@@@@@@@@@@@@    
 @@@@@@   @@@@@@  @@@@@@@@@@@   @@@@@@@@@@@@@@    
 @@@@@@   @@@@@@  @@@@@@@@@@@  @@@@@@@@@@@@@@@ 
 @@@@@@@@@@@@@@@  @@@@@@@@@@   @@@@@@@@@@@@@@@ 
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@  
  @@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@  
   @@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@   
      @@@@@            @@@@@@@@@@@@@@@@@@  
      
AppKit SDK version ${a} is outdated. Latest version is ${b}. Please update to the latest version for bug fixes and new features.
            
Changelog: https://github.com/reown-com/appkit/releases
NPM Registry: https://www.npmjs.com/package/@reown/appkit`},U=(h.ConstantsUtil.CONNECTOR_ID.COINBASE,h.ConstantsUtil.CONNECTOR_ID.COINBASE_SDK,h.ConstantsUtil.CONNECTOR_ID.SAFE,h.ConstantsUtil.CONNECTOR_ID.LEDGER,h.ConstantsUtil.CONNECTOR_ID.OKX,T.METMASK_CONNECTOR_NAME,T.TRUST_CONNECTOR_NAME,T.SOLFLARE_CONNECTOR_NAME,T.PHANTOM_CONNECTOR_NAME,T.COIN98_CONNECTOR_NAME,T.MAGIC_EDEN_CONNECTOR_NAME,T.BACKPACK_CONNECTOR_NAME,T.BITGET_CONNECTOR_NAME,T.FRONTIER_CONNECTOR_NAME,T.XVERSE_CONNECTOR_NAME,T.LEATHER_CONNECTOR_NAME,T.OKX_CONNECTOR_NAME,{1:"ba0ba0cd-17c6-4806-ad93-f9d174f17900",42161:"3bff954d-5cb0-47a0-9a23-d20192e74600",43114:"30c46e53-e989-45fb-4549-be3bd4eb3b00",56:"93564157-2e8e-4ce7-81df-b264dbee9b00",250:"06b26297-fe0c-4733-5d6b-ffa5498aac00",10:"ab9c186a-c52f-464b-2906-ca59d760a400",137:"41d04d42-da3b-4453-8506-668cc0727900",5e3:"e86fae9b-b770-4eea-e520-150e12c81100",295:"6a97d510-cac8-4e58-c7ce-e8681b044c00",0xaa36a7:"e909ea0a-f92a-4512-c8fc-748044ea6800",84532:"a18a7ecd-e307-4360-4746-283182228e00",1301:"4eeea7ef-0014-4649-5d1d-07271a80f600",130:"2257980a-3463-48c6-cbac-a42d2a956e00",10143:"0a728e83-bacb-46db-7844-948f05434900",100:"02b53f6a-e3d4-479e-1cb4-21178987d100",9001:"f926ff41-260d-4028-635e-91913fc28e00",324:"b310f07f-4ef7-49f3-7073-2a0a39685800",314:"5a73b3dd-af74-424e-cae0-0de859ee9400",4689:"34e68754-e536-40da-c153-6ef2e7188a00",1088:"3897a66d-40b9-4833-162f-a2c90531c900",1284:"161038da-44ae-4ec7-1208-0ea569454b00",1285:"f1d73bb6-5450-4e18-38f7-fb6484264a00",7777777:"845c60df-d429-4991-e687-91ae45791600",42220:"ab781bbc-ccc6-418d-d32d-789b15da1f00",8453:"7289c336-3981-4081-c5f4-efc26ac64a00",0x4e454152:"3ff73439-a619-4894-9262-4470c773a100",2020:"b8101fc0-9c19-4b6f-ec65-f6dfff106e00",2021:"b8101fc0-9c19-4b6f-ec65-f6dfff106e00",80094:"e329c2c9-59b0-4a02-83e4-212ff3779900",2741:"fc2427d1-5af9-4a9c-8da5-6f94627cd900","5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp":"a1b58899-f671-4276-6a5e-56ca5bd59700","4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z":"a1b58899-f671-4276-6a5e-56ca5bd59700",EtWTRABZaYq6iMfeYKouRu166VU2xqa1:"a1b58899-f671-4276-6a5e-56ca5bd59700","000000000019d6689c085ae165831e93":"0b4838db-0161-4ffe-022d-532bf03dba00","000000000933ea01ad0ee984209779ba":"39354064-d79b-420b-065d-f980c4b78200","00000008819873e925422c1ff0f99f7c":"b3406e4a-bbfc-44fb-e3a6-89673c78b700"}),V={[h.ConstantsUtil.CONNECTOR_ID.COINBASE]:"0c2840c3-5b04-4c44-9661-fbd4b49e1800",[h.ConstantsUtil.CONNECTOR_ID.COINBASE_SDK]:"0c2840c3-5b04-4c44-9661-fbd4b49e1800",[h.ConstantsUtil.CONNECTOR_ID.SAFE]:"461db637-8616-43ce-035a-d89b8a1d5800",[h.ConstantsUtil.CONNECTOR_ID.LEDGER]:"54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",[h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT]:"ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",[h.ConstantsUtil.CONNECTOR_ID.INJECTED]:"07ba87ed-43aa-4adf-4540-9e6a2b9cae00"},W={[h.ConstantsUtil.CONNECTOR_ID.INJECTED]:"Browser Wallet",[h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT]:"WalletConnect",[h.ConstantsUtil.CONNECTOR_ID.COINBASE]:"Coinbase",[h.ConstantsUtil.CONNECTOR_ID.COINBASE_SDK]:"Coinbase",[h.ConstantsUtil.CONNECTOR_ID.LEDGER]:"Ledger",[h.ConstantsUtil.CONNECTOR_ID.SAFE]:"Safe"};function X(a,b){let c=new URL("https://rpc.walletconnect.org/v1/");return c.searchParams.set("chainId",a),c.searchParams.set("projectId",b),c.toString()}h.ConstantsUtil.CONNECTOR_ID.INJECTED,h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT,h.ConstantsUtil.CONNECTOR_ID.EIP6963,h.ConstantsUtil.CONNECTOR_ID.AUTH,T.CONNECTOR_TYPE_AUTH;let Y=["near:mainnet","solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp","eip155:1101","eip155:56","eip155:42161","eip155:7777777","eip155:59144","eip155:324","solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1","eip155:5000","solana:4sgjmw1sunhzsxgspuhpqldx6wiyjntz","eip155:80084","eip155:5003","eip155:100","eip155:8453","eip155:42220","eip155:1313161555","eip155:17000","eip155:1","eip155:300","eip155:1313161554","eip155:1329","eip155:84532","eip155:421614","eip155:11155111","eip155:8217","eip155:43114","solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z","eip155:999999999","eip155:11155420","eip155:80002","eip155:97","eip155:43113","eip155:137","eip155:10","eip155:1301","eip155:80094","eip155:80069","eip155:560048","eip155:31","eip155:2818","eip155:57054","eip155:911867","eip155:534351","eip155:1112","eip155:534352","eip155:1111","eip155:146","eip155:130","eip155:1284","eip155:30","eip155:2810","bip122:000000000019d6689c085ae165831e93","bip122:000000000933ea01ad0ee984209779ba"],Z={extendRpcUrlWithProjectId(a,b){let c=!1;try{c="rpc.walletconnect.org"===new URL(a).host}catch(a){c=!1}if(c){let c=new URL(a);return c.searchParams.has("projectId")||c.searchParams.set("projectId",b),c.toString()}return a},isCaipNetwork:a=>"chainNamespace"in a&&"caipNetworkId"in a,getChainNamespace(a){return this.isCaipNetwork(a)?a.chainNamespace:h.ConstantsUtil.CHAIN.EVM},getCaipNetworkId(a){return this.isCaipNetwork(a)?a.caipNetworkId:`${h.ConstantsUtil.CHAIN.EVM}:${a.id}`},getDefaultRpcUrl(a,b,c){let d=a.rpcUrls?.default?.http?.[0];return Y.includes(b)?X(b,c):d||""},extendCaipNetwork(a,{customNetworkImageUrls:b,projectId:c,customRpcUrls:d}){let e=this.getChainNamespace(a),f=this.getCaipNetworkId(a),g=a.rpcUrls?.default?.http?.[0],h=this.getDefaultRpcUrl(a,f,c),i=a?.rpcUrls?.chainDefault?.http?.[0]||g,j=d?.[f]?.map(a=>a.url)||[],k=[...j,...h?[h]:[]],l=[...j];return i&&!l.includes(i)&&l.push(i),{...a,chainNamespace:e,caipNetworkId:f,assets:{imageId:U[a.id],imageUrl:b?.[a.id]},rpcUrls:{...a.rpcUrls,default:{http:k},chainDefault:{http:l}}}},extendCaipNetworks:(a,{customNetworkImageUrls:b,projectId:c,customRpcUrls:d})=>a.map(a=>Z.extendCaipNetwork(a,{customNetworkImageUrls:b,customRpcUrls:d,projectId:c})),getViemTransport(a,b,c){let d=[];return c?.forEach(a=>{d.push((0,S.http)(a.url,a.config))}),Y.includes(a.caipNetworkId)&&d.push((0,S.http)(X(a.caipNetworkId,b),{fetchOptions:{headers:{"Content-Type":"text/plain"}}})),a?.rpcUrls?.default?.http?.forEach(a=>{d.push((0,S.http)(a))}),(0,R.fallback)(d)},extendWagmiTransports(a,b,c){if(Y.includes(a.caipNetworkId)){let d=this.getDefaultRpcUrl(a,a.caipNetworkId,b);return(0,R.fallback)([c,(0,S.http)(d)])}return c},getUnsupportedNetwork:a=>({id:a.split(":")[1],caipNetworkId:a,name:h.ConstantsUtil.UNSUPPORTED_NETWORK_NAME,chainNamespace:a.split(":")[0],nativeCurrency:{name:"",decimals:0,symbol:""},rpcUrls:{default:{http:[]}}}),getCaipNetworkFromStorage(a){let c=t.StorageUtil.getActiveCaipNetworkId(),d=b.ChainController.getAllRequestedCaipNetworks(),e=Array.from(b.ChainController.state.chains?.keys()||[]),f=c?.split(":")[0],g=!!f&&e.includes(f),h=d?.find(a=>a.caipNetworkId===c);return g&&!h&&c?this.getUnsupportedNetwork(c):h||a||d?.[0]}};var $=a.i(680704);new AbortController;let _={UNAUTHORIZED_DOMAIN_NOT_ALLOWED:{message:"Unauthorized: origin not allowed",alertErrorKey:"ORIGIN_NOT_ALLOWED"},JWT_VALIDATION_ERROR:{message:"JWT validation error: JWT Token is not yet valid",alertErrorKey:"JWT_TOKEN_NOT_VALID"},INVALID_KEY:{message:"Unauthorized: invalid key",alertErrorKey:"INVALID_PROJECT_ID"}},aa={SWITCH_NETWORK_NOT_FOUND:{code:"APKT001",displayMessage:"Network Not Found",debugMessage:"The specified network is not recognized. Please ensure it is included in the `networks` array of your `createAppKit` configuration."},ORIGIN_NOT_ALLOWED:{code:"APKT002",displayMessage:"Invalid App Configuration",debugMessage:()=>`The origin ${(0,$.isSafe)()?window.origin:"unknown"} is not in your allow list. Please update your allowed domains at https://dashboard.reown.com.`},IFRAME_LOAD_FAILED:{code:"APKT003",displayMessage:"Network Error: Wallet Load Failed",debugMessage:()=>"Failed to load the embedded wallet. This may be due to network issues or server downtime. Please check your network connection and try again shortly. Contact support if the issue persists."},IFRAME_REQUEST_TIMEOUT:{code:"APKT004",displayMessage:"Wallet Request Timeout",debugMessage:()=>"The request to the embedded wallet timed out. Please check your network connection and try again shortly. Contact support if the issue persists."},UNVERIFIED_DOMAIN:{code:"APKT005",displayMessage:"Unverified Domain",debugMessage:()=>"Embedded wallet load failed. Ensure your domain is verified in https://dashboard.reown.com."},JWT_TOKEN_NOT_VALID:{code:"APKT006",displayMessage:"Session Expired",debugMessage:"Your session is invalid or expired. Please check your systemâ€™s date and time settings, then reconnect."},INVALID_PROJECT_ID:{code:"APKT007",displayMessage:"Invalid Project ID",debugMessage:"The specified project ID is invalid. Please visit https://dashboard.reown.com to obtain a valid project ID."},PROJECT_ID_NOT_CONFIGURED:{code:"APKT008",displayMessage:"Project ID Missing",debugMessage:"No project ID is configured. You can create and configure a project ID at https://dashboard.reown.com."},SERVER_ERROR_APP_CONFIGURATION:{code:"APKT009",displayMessage:"Server Error",debugMessage:a=>`Unable to fetch App Configuration. ${a}. Please check your network connection and try again shortly. Contact support if the issue persists.`},RATE_LIMITED_APP_CONFIGURATION:{code:"APKT010",displayMessage:"Rate Limited",debugMessage:"You have been rate limited while retrieving App Configuration. Please wait a few minutes and try again. Contact support if the issue persists."}},ab={debugMessage:a=>`[Reown Config Notice] ${a}`},ac={code:"APKTW001",displayMessage:"Inactive Namespace Not Connected",debugMessage:(a,b)=>`An error occurred while connecting an inactive namespace ${a}: "${b}"`},ad={getCaipTokens(a){if(!a)return;let b={};return Object.entries(a).forEach(([a,c])=>{b[`${T.EIP155}:${a}`]=c}),b},isLowerCaseMatch:(a,b)=>a?.toLowerCase()===b?.toLowerCase(),getActiveNamespaceConnectedToAuth(){let a=b.ChainController.state.activeChain;return h.ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.find(b=>d.ConnectorController.getConnectorId(b)===h.ConstantsUtil.CONNECTOR_ID.AUTH&&b===a)},withRetry({conditionFn:a,intervalMs:b,maxRetries:c}){let d=0;return new Promise(e=>{async function f(){return(d+=1,await a())?e(!0):d>=c?e(!1):(setTimeout(f,b),null)}f()})},userChainIdToChainNamespace(a){if("number"==typeof a)return h.ConstantsUtil.CHAIN.EVM;let[b]=a.split(":");return b},getOtherAuthNamespaces:a=>a?h.ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.filter(b=>b!==a):[],getConnectorStorageInfo(a,b){let c=t.StorageUtil.getConnections()[b]??[];return{hasDisconnected:t.StorageUtil.isConnectorDisconnected(a,b),hasConnected:c.some(b=>ad.isLowerCaseMatch(b.connectorId,a))}}};var ae=a.i(31620);let af={createLogger(a,b="error"){let c=(0,ae.getDefaultLoggerOptions)({level:b}),{logger:d}=(0,ae.generatePlatformLogger)({opts:c});return d.error=(...b)=>{for(let c of b)if(c instanceof Error)return void a(c,...b);a(void 0,...b)},d}},ag={extractVersion(a){if(!a||"string"!=typeof a)return null;let b=a.match(/(?:[~^>=<]+\s*)?(?<version>\d+(?:\.\d+){0,2})(?:-[a-zA-Z]+\.\d+)?/u);return b?.groups?.version||null},checkSDKVersion(a){let b=this.extractVersion(a),c=h.ConstantsUtil.IS_DEVELOPMENT;if(!b||!c)return;let d=t.StorageUtil.getLatestAppKitVersion();if(this.isValidVersion(d)&&this.isOlder(b,d))return void console.warn(T.getSDKVersionWarningMessage(b,d));try{fetch("https://registry.npmjs.org/@reown/appkit/latest").then(a=>a.json()).then(a=>{let c=a.version;this.isOlder(b,c)&&(t.StorageUtil.updateLatestAppKitVersion({timestamp:Date.now(),version:c}),console.warn(T.getSDKVersionWarningMessage(b,c)))})}catch(a){}},isValidVersion:a=>"string"==typeof a&&/^\d+\.\d+\.\d+$/u.test(a),isOlder(a,b){let c=this.extractVersion(a),d=this.extractVersion(b);if(!c||!d)return!1;function e(a){let b=a.split(".").map(Number);for(;b.length<3;)b.push(0);return b}let f=e(c),g=e(d);for(let a=0;a<Math.max(f.length,g.length);a+=1){let b=f[a]||0,c=g[a]||0;if(b<c)return!0;if(b>c)break}return!1}},ah={TOKEN_ADDRESSES_BY_SYMBOL:{USDC:{8453:"0x833589fcd6edb6e08f4c7c32d4f71b54bda02913",84532:"0x036CbD53842c5426634e7929541eC2318f3dCF7e"}},getTokenSymbolByAddress(a){if(!a)return;let[b]=Object.entries(ah.TOKEN_ADDRESSES_BY_SYMBOL).find(([b,c])=>Object.values(c).includes(a))??[];return b}};var ai=a.i(130934),aj=a.i(221570),ak=a.i(916451);let al={hexStringToNumber:a=>parseInt(a.startsWith("0x")?a.slice(2):a,16),numberToHexString:a=>`0x${a.toString(16)}`,async getUserInfo(a){let[b,c]=await Promise.all([al.getAddresses(a),al.getChainId(a)]);return{chainId:c,addresses:b}},getChainId:async a=>Number(await a.request({method:"eth_chainId"})),async getAddress(a){let[b]=await a.request({method:"eth_accounts"});return b},getAddresses:async a=>await a.request({method:"eth_accounts"}),async addEthereumChain(a,b){let c=b.rpcUrls.chainDefault?.http||[];await a.request({method:"wallet_addEthereumChain",params:[{chainId:al.numberToHexString(b.id),rpcUrls:[...c],chainName:b.name,nativeCurrency:{name:b.nativeCurrency.name,decimals:b.nativeCurrency.decimals,symbol:b.nativeCurrency.symbol},blockExplorerUrls:[b.blockExplorers?.default.url],iconUrls:[U[b.id]]}]})}},am=0,an=1;function ao(a){return{formatters:void 0,fees:void 0,serializers:void 0,...a}}let ap=ao({id:"5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",name:"Solana",network:"solana-mainnet",nativeCurrency:{name:"Solana",symbol:"SOL",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},testnet:!1,chainNamespace:"solana",caipNetworkId:"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",deprecatedCaipNetworkId:"solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ"}),aq=ao({id:"EtWTRABZaYq6iMfeYKouRu166VU2xqa1",name:"Solana Devnet",network:"solana-devnet",nativeCurrency:{name:"Solana",symbol:"SOL",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},testnet:!0,chainNamespace:"solana",caipNetworkId:"solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",deprecatedCaipNetworkId:"solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K"});ao({id:"4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",name:"Solana Testnet",network:"solana-testnet",nativeCurrency:{name:"Solana",symbol:"SOL",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},testnet:!0,chainNamespace:"solana",caipNetworkId:"solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z"}),ao({id:"000000000019d6689c085ae165831e93",caipNetworkId:"bip122:000000000019d6689c085ae165831e93",chainNamespace:"bip122",name:"Bitcoin",nativeCurrency:{name:"Bitcoin",symbol:"BTC",decimals:8},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}}}),ao({id:"000000000933ea01ad0ee984209779ba",caipNetworkId:"bip122:000000000933ea01ad0ee984209779ba",chainNamespace:"bip122",name:"Bitcoin Testnet",nativeCurrency:{name:"Bitcoin",symbol:"BTC",decimals:8},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},testnet:!0}),ao({id:"00000008819873e925422c1ff0f99f7c",caipNetworkId:"bip122:00000008819873e925422c1ff0f99f7c",chainNamespace:"bip122",name:"Bitcoin Signet",nativeCurrency:{name:"Bitcoin",symbol:"BTC",decimals:8},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},testnet:!0});let ar={solana:["solana_signMessage","solana_signTransaction","solana_requestAccounts","solana_getAccounts","solana_signAllTransactions","solana_signAndSendTransaction"],eip155:["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode","wallet_getCallsStatus","wallet_showCallsStatus","wallet_sendCalls","wallet_getCapabilities","wallet_grantPermissions","wallet_revokePermissions","wallet_getAssets"],bip122:["sendTransfer","signMessage","signPsbt","getAccountAddresses"]},as={RPC_ERROR_CODE:{USER_REJECTED:5e3,USER_REJECTED_METHODS:5002},getMethodsByChainNamespace:a=>ar[a]||[],createDefaultNamespace(a){return{methods:this.getMethodsByChainNamespace(a),events:["accountsChanged","chainChanged"],chains:[],rpcMap:{}}},applyNamespaceOverrides(a,b){if(!b)return{...a};let c={...a},d=new Set;if(b.methods&&Object.keys(b.methods).forEach(a=>d.add(a)),b.chains&&Object.keys(b.chains).forEach(a=>d.add(a)),b.events&&Object.keys(b.events).forEach(a=>d.add(a)),b.rpcMap&&Object.keys(b.rpcMap).forEach(a=>{let[b]=a.split(":");b&&d.add(b)}),d.forEach(a=>{c[a]||(c[a]=this.createDefaultNamespace(a))}),b.methods&&Object.entries(b.methods).forEach(([a,b])=>{c[a]&&(c[a].methods=b)}),b.chains&&Object.entries(b.chains).forEach(([a,b])=>{c[a]&&(c[a].chains=b)}),b.events&&Object.entries(b.events).forEach(([a,b])=>{c[a]&&(c[a].events=b)}),b.rpcMap){let a=new Set;Object.entries(b.rpcMap).forEach(([b,d])=>{let[e,f]=b.split(":");e&&f&&c[e]&&(c[e].rpcMap||(c[e].rpcMap={}),a.has(e)||(c[e].rpcMap={},a.add(e)),c[e].rpcMap[f]=d)})}return c},createNamespaces(a,b){let c=a.reduce((a,b)=>{let{id:c,chainNamespace:d,rpcUrls:e}=b,f=e.default.http[0];a[d]||(a[d]=this.createDefaultNamespace(d));let g=`${d}:${c}`,h=a[d];switch(h.chains.push(g),g){case ap.caipNetworkId:h.chains.push(ap.deprecatedCaipNetworkId);break;case aq.caipNetworkId:h.chains.push(aq.deprecatedCaipNetworkId)}return h?.rpcMap&&f&&(h.rpcMap[c]=f),a},{});return this.applyNamespaceOverrides(c,b)},resolveReownName:async a=>{let b=await x.resolveName(a),c=Object.values(b?.addresses)||[];return c[0]?.address||!1},getChainsFromNamespaces:(a={})=>Object.values(a).flatMap(a=>Array.from(new Set([...a.chains||[],...a.accounts.map(a=>{let[b,c]=a.split(":");return`${b}:${c}`})]))),isSessionEventData:a=>"object"==typeof a&&null!==a&&"id"in a&&"topic"in a&&"params"in a&&"object"==typeof a.params&&null!==a.params&&"chainId"in a.params&&"event"in a.params&&"object"==typeof a.params.event&&null!==a.params.event,isUserRejectedRequestError(a){try{if("object"==typeof a&&null!==a){let b="number"==typeof a.code,c=b&&a.code===as.RPC_ERROR_CODE.USER_REJECTED_METHODS,d=b&&a.code===as.RPC_ERROR_CODE.USER_REJECTED;return c||d}return!1}catch{return!1}},isOriginAllowed(a,b,c){for(let d of[...b,...c])if(d.includes("*")){let b=d.replace(/[.*+?^${}()|[\]\\]/gu,"\\$&");if(RegExp(`^${b.replace(/\\\*/gu,".*")}$`,"u").test(a))return!0}else try{if(new URL(d).origin===a)return!0}catch(b){if(d===a)return!0}return!1},listenWcProvider({universalProvider:a,namespace:b,onConnect:c,onDisconnect:d,onAccountsChanged:e,onChainChanged:f,onDisplayUri:g}){c&&a.on("connect",()=>{c(as.getWalletConnectAccounts(a,b))}),d&&a.on("disconnect",()=>{d()}),e&&a.on("accountsChanged",c=>{try{let d=a.session?.namespaces?.[b]?.accounts||[],f=a.rpcProviders?.[b]?.getDefaultChain(),g=c.map(a=>{let c=d.find(c=>c.includes(`${b}:${f}:${a}`));if(!c)return;let{chainId:e,chainNamespace:g}=j.ParseUtil.parseCaipAddress(c);return{address:a,chainId:e,chainNamespace:g}}).filter(a=>void 0!==a);g.length>0&&e(g)}catch(a){console.warn("Failed to parse accounts for namespace on accountsChanged event",b,c,a)}}),f&&a.on("chainChanged",a=>{f(a)}),g&&a.on("display_uri",a=>{g(a)})},getWalletConnectAccounts(a,b){let c=new Set,d=a?.session?.namespaces?.[b]?.accounts?.map(a=>j.ParseUtil.parseCaipAddress(a)).filter(({address:a})=>!c.has(a.toLowerCase())&&(c.add(a.toLowerCase()),!0));return d&&d.length>0?d:[]}};class at{constructor(a){this.namespace=a.namespace}async syncConnections(a){switch(this.namespace){case h.ConstantsUtil.CHAIN.EVM:await this.syncEVMConnections(a);break;case h.ConstantsUtil.CHAIN.SOLANA:await this.syncSolanaConnections(a);break;case h.ConstantsUtil.CHAIN.BITCOIN:await this.syncBitcoinConnections(a);break;default:throw Error(`Unsupported chain namespace: ${this.namespace}`)}}async syncEVMConnections({connectors:a,caipNetworks:b,universalProvider:c,onConnection:d,onListenProvider:e}){await Promise.all(a.filter(a=>{let{hasDisconnected:b,hasConnected:c}=ad.getConnectorStorageInfo(a.id,this.namespace);return!b&&c}).map(async a=>{if(a.id===h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT){let e=as.getWalletConnectAccounts(c,this.namespace),f=b.find(a=>a.chainNamespace===this.namespace&&a.id.toString()===e[0]?.chainId?.toString());e.length>0&&d({connectorId:a.id,accounts:e.map(a=>({address:a.address})),caipNetwork:f})}else{let{accounts:c,chainId:f}=await O.ConnectorUtil.fetchProviderData(a);if(c.length>0&&f){let g=b.find(a=>a.chainNamespace===this.namespace&&a.id.toString()===f.toString());d({connectorId:a.id,accounts:c.map(a=>({address:a})),caipNetwork:g}),a.provider&&a.id!==h.ConstantsUtil.CONNECTOR_ID.AUTH&&a.id!==h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT&&e(a.id,a.provider)}}}))}async syncSolanaConnections({connectors:a,caipNetwork:b,universalProvider:c,onConnection:d,onListenProvider:e}){await Promise.all(a.filter(a=>{let{hasDisconnected:b,hasConnected:c}=ad.getConnectorStorageInfo(a.id,this.namespace);return!b&&c}).map(async a=>{if(a.id===h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT){let e=as.getWalletConnectAccounts(c,this.namespace);e.length>0&&d({connectorId:a.id,accounts:e.map(a=>({address:a.address})),caipNetwork:b})}else{let c=await a.connect({chainId:b?.id});c&&(d({connectorId:a.id,accounts:[{address:c}],caipNetwork:b}),e(a.id,a.provider))}}))}async syncBitcoinConnections({connectors:a,caipNetwork:b,universalProvider:c,onConnection:d,onListenProvider:f}){await Promise.all(a.filter(a=>{let{hasDisconnected:b,hasConnected:c}=ad.getConnectorStorageInfo(a.id,this.namespace);return!b&&c}).map(async a=>{if(a.id===h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT){let e=as.getWalletConnectAccounts(c,this.namespace);e.length>0&&d({connectorId:a.id,accounts:e.map(a=>({address:a.address})),caipNetwork:b});return}let g=await a.connect(),i=await a.getAccountAddresses(),j=i?.map(a=>e.CoreHelperUtil.createAccount(h.ConstantsUtil.CHAIN.BITCOIN,a.address,a.purpose||"payment",a.publicKey,a.path));if(j&&j.length>1&&(j=[{namespace:h.ConstantsUtil.CHAIN.BITCOIN,publicKey:j[am]?.publicKey??"",path:j[am]?.path??"",address:j[am]?.address??"",type:"payment"},{namespace:h.ConstantsUtil.CHAIN.BITCOIN,publicKey:j[an]?.publicKey??"",path:j[an]?.path??"",address:j[an]?.address??"",type:"ordinal"}]),!(a.chains.find(a=>a.id===b?.id)||a.chains[0]))throw Error("The connector does not support any of the requested chains");g&&(f(a.id,a.provider),d({connectorId:a.id,accounts:j.map(a=>({address:a.address,type:a.type,publicKey:a.publicKey,path:a.path})),caipNetwork:b}))}))}getConnection({address:a,connectorId:b,connections:c,connectors:d}){if(b){let e=c.find(a=>ad.isLowerCaseMatch(a.connectorId,b));if(!e)return null;let f=d.find(a=>ad.isLowerCaseMatch(a.id,e.connectorId)),g=a?e.accounts.find(b=>ad.isLowerCaseMatch(b.address,a)):e.accounts[0];return{...e,account:g,connector:f}}let e=c.find(a=>a.accounts.length>0&&d.some(b=>ad.isLowerCaseMatch(b.id,a.connectorId)));if(e){let[a]=e.accounts,b=d.find(a=>ad.isLowerCaseMatch(a.id,e.connectorId));return{...e,account:a,connector:b}}return null}}let au=["http://localhost:*","https://localhost:*","http://127.0.0.1:*","https://127.0.0.1:*","https://*.pages.dev","https://*.vercel.app","https://*.ngrok-free.app","https://secure-mobile.walletconnect.com","https://secure-mobile.walletconnect.org"];class av{constructor({provider:a,namespace:c}){this.id=h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT,this.name=W[h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT],this.type="WALLET_CONNECT",this.imageId=V[h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT],this.getCaipNetworks=b.ChainController.getCaipNetworks.bind(b.ChainController),this.caipNetworks=this.getCaipNetworks(),this.provider=a,this.chain=c}get chains(){return this.getCaipNetworks()}async connectWalletConnect(){if(!await this.authenticate()){let a=this.getCaipNetworks(),b=f.OptionsController.state.universalProviderConfigOverride,c=as.createNamespaces(a,b);await this.provider.connect({optionalNamespaces:c})}return{clientId:await this.provider.client.core.crypto.getClientId(),session:this.provider.session}}async disconnect(){await this.provider.disconnect()}async authenticate(){let a=this.chains.map(a=>a.caipNetworkId);return J.SIWXUtil.universalProviderAuthenticate({universalProvider:this.provider,chains:a,methods:aw})}}let aw=["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode","wallet_getCallsStatus","wallet_sendCalls","wallet_getCapabilities","wallet_grantPermissions","wallet_revokePermissions","wallet_getAssets"],ax=[h.ConstantsUtil.CONNECTOR_ID.AUTH,h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT];class ay{constructor(a){this.availableConnectors=[],this.availableConnections=[],this.providerHandlers={},this.eventListeners=new Map,this.getCaipNetworks=a=>b.ChainController.getCaipNetworks(a),this.getConnectorId=a=>d.ConnectorController.getConnectorId(a),a&&this.construct(a),a?.namespace&&(this.connectionManager=new at({namespace:a.namespace}))}construct(a){this.projectId=a.projectId,this.namespace=a.namespace,this.adapterType=a.adapterType}get connectors(){return this.availableConnectors}get connections(){return this.availableConnections}get networks(){return this.getCaipNetworks(this.namespace)}onAuthConnected({accounts:a,chainId:b}){let c=this.getCaipNetworks().filter(a=>a.chainNamespace===this.namespace).find(a=>a.id.toString()===b?.toString());a&&c&&this.addConnection({connectorId:h.ConstantsUtil.CONNECTOR_ID.AUTH,accounts:a,caipNetwork:c})}setAuthProvider(a){a.onConnect(this.onAuthConnected.bind(this)),a.onSocialConnected(this.onAuthConnected.bind(this)),this.addConnector({id:h.ConstantsUtil.CONNECTOR_ID.AUTH,type:"AUTH",name:h.ConstantsUtil.CONNECTOR_NAMES.AUTH,provider:a,imageId:V[h.ConstantsUtil.CONNECTOR_ID.AUTH],chain:this.namespace,chains:[]})}addConnector(...a){let b=new Set;this.availableConnectors=[...a,...this.availableConnectors].filter(a=>!b.has(a.id)&&(b.add(a.id),!0)),this.emit("connectors",this.availableConnectors)}addConnection(...a){let b=new Set;this.availableConnections=[...a,...this.availableConnections].filter(a=>!b.has(a.connectorId.toLowerCase())&&(b.add(a.connectorId.toLowerCase()),!0)),this.emit("connections",this.availableConnections)}deleteConnection(a){this.availableConnections=this.availableConnections.filter(b=>!ad.isLowerCaseMatch(b.connectorId,a)),this.emit("connections",this.availableConnections)}clearConnections(a=!1){this.availableConnections=[],a&&this.emit("connections",this.availableConnections)}setStatus(a,c){b.ChainController.setAccountProp("status",a,c)}on(a,b){this.eventListeners.has(a)||this.eventListeners.set(a,new Set),this.eventListeners.get(a)?.add(b)}off(a,b){let c=this.eventListeners.get(a);c&&c.delete(b)}removeAllEventListeners(){this.eventListeners.forEach(a=>{a.clear()})}emit(a,b){let c=this.eventListeners.get(a);c&&c.forEach(a=>a(b))}async connectWalletConnect(a){try{let a=this.getWalletConnectConnector();return{clientId:(await a.connectWalletConnect()).clientId}}catch(a){if(as.isUserRejectedRequestError(a))throw new ak.UserRejectedRequestError(a);throw a}}async switchNetwork(a){let{caipNetwork:b,providerType:c}=a;if(!a.provider)return;let d="provider"in a.provider?a.provider.provider:a.provider;if("WALLET_CONNECT"===c)return void d.setDefaultChain(b.caipNetworkId);if(d&&"AUTH"===c){let a=(0,N.getPreferredAccountType)(b.chainNamespace);await d.switchNetwork({chainId:b.caipNetworkId});let c=await d.getUser({chainId:b.caipNetworkId,preferredAccountType:a});this.emit("switchNetwork",c)}}getWalletConnectConnector(){let a=this.connectors.find(a=>a instanceof av);if(!a)throw Error("WalletConnectConnector not found");return a}onConnect(a,b){if(a.length>0){let{address:c,chainId:d}=e.CoreHelperUtil.getAccount(a[0]),f=this.getCaipNetworks().filter(a=>a.chainNamespace===this.namespace).find(a=>a.id.toString()===d?.toString()),g=this.connectors.find(a=>a.id===b);c&&(this.emit("accountChanged",{address:c,chainId:d,connector:g}),this.addConnection({connectorId:b,accounts:a.map(a=>{let{address:b}=e.CoreHelperUtil.getAccount(a);return{address:b}}),caipNetwork:f}))}}onAccountsChanged(a,b,c=!0){if(a.length>0){let{address:c}=e.CoreHelperUtil.getAccount(a[0]),d=this.connectionManager?.getConnection({connectorId:b,connections:this.connections,connectors:this.connectors});c&&ad.isLowerCaseMatch(this.getConnectorId(h.ConstantsUtil.CHAIN.EVM),b)&&this.emit("accountChanged",{address:c,chainId:d?.caipNetwork?.id,connector:d?.connector}),this.addConnection({connectorId:b,accounts:a.map(a=>{let{address:b}=e.CoreHelperUtil.getAccount(a);return{address:b}}),caipNetwork:d?.caipNetwork})}else c&&this.onDisconnect(b)}onDisconnect(a){this.removeProviderListeners(a),this.deleteConnection(a),ad.isLowerCaseMatch(this.getConnectorId(h.ConstantsUtil.CHAIN.EVM),a)&&this.emitFirstAvailableConnection(),0===this.connections.length&&this.emit("disconnect")}onChainChanged(a,b){let c="string"==typeof a&&a.startsWith("0x")?al.hexStringToNumber(a).toString():a.toString(),d=this.connectionManager?.getConnection({connectorId:b,connections:this.connections,connectors:this.connectors}),e=this.getCaipNetworks().filter(a=>a.chainNamespace===this.namespace).find(a=>a.id.toString()===c);d&&this.addConnection({connectorId:b,accounts:d.accounts,caipNetwork:e}),ad.isLowerCaseMatch(this.getConnectorId(h.ConstantsUtil.CHAIN.EVM),b)&&this.emit("switchNetwork",{chainId:c})}listenProviderEvents(a,b){if(ax.includes(a))return;let c=b=>this.onAccountsChanged(b,a),d=b=>this.onChainChanged(b,a),e=()=>this.onDisconnect(a);this.providerHandlers[a]||(b.on("disconnect",e),b.on("accountsChanged",c),b.on("chainChanged",d),this.providerHandlers[a]={provider:b,disconnect:e,accountsChanged:c,chainChanged:d})}removeProviderListeners(a){if(this.providerHandlers[a]){let{provider:b,disconnect:c,accountsChanged:d,chainChanged:e}=this.providerHandlers[a];b.removeListener("disconnect",c),b.removeListener("accountsChanged",d),b.removeListener("chainChanged",e),this.providerHandlers[a]=null}}emitFirstAvailableConnection(){let a=this.connectionManager?.getConnection({connections:this.connections,connectors:this.connectors});if(a){let[b]=a.accounts;this.emit("accountChanged",{address:b?.address,chainId:a.caipNetwork?.id,connector:a.connector})}}}class az extends ay{async setUniversalProvider(a){if(!this.namespace)throw Error("UniversalAdapter:setUniversalProvider - namespace is required");return this.addConnector(new av({provider:a,caipNetworks:this.getCaipNetworks(),namespace:this.namespace})),Promise.resolve()}async connect(a){return Promise.resolve({id:"WALLET_CONNECT",type:"WALLET_CONNECT",chainId:Number(a.chainId),provider:this.provider,address:""})}async disconnect(){try{let a=this.getWalletConnectConnector();await a.disconnect(),this.emit("disconnect")}catch(a){console.warn("UniversalAdapter:disconnect - error",a)}return{connections:[]}}syncConnections(){return Promise.resolve()}async getAccounts({namespace:a}){let b=this.provider;return Promise.resolve({accounts:(b?.session?.namespaces?.[a]?.accounts?.map(a=>{let[,,b]=a.split(":");return b}).filter((a,b,c)=>c.indexOf(a)===b)||[]).map(b=>e.CoreHelperUtil.createAccount(a,b,"bip122"===a?"payment":"eoa"))})}async syncConnectors(){return Promise.resolve()}async getBalance(a){if(!(a.caipNetwork&&p.ConstantsUtil.BALANCE_SUPPORTED_CHAINS.includes(a.caipNetwork?.chainNamespace))||a.caipNetwork?.testnet)return{balance:"0.00",symbol:a.caipNetwork?.nativeCurrency.symbol||""};let c=b.ChainController.getAccountData();if(c?.balanceLoading&&a.chainId===b.ChainController.state.activeCaipNetwork?.id)return{balance:c?.balance||"0.00",symbol:c?.balanceSymbol||""};let d=(await b.ChainController.fetchTokenBalance()).find(b=>b.chainId===`${a.caipNetwork?.chainNamespace}:${a.chainId}`&&b.symbol===a.caipNetwork?.nativeCurrency.symbol);return{balance:d?.quantity.numeric||"0.00",symbol:d?.symbol||a.caipNetwork?.nativeCurrency.symbol||""}}async signMessage(a){let{provider:c,message:d,address:e}=a;if(!c)throw Error("UniversalAdapter:signMessage - provider is undefined");return{signature:b.ChainController.state.activeCaipNetwork?.chainNamespace===h.ConstantsUtil.CHAIN.SOLANA?(await c.request({method:"solana_signMessage",params:{message:ai.default.encode(new TextEncoder().encode(d)),pubkey:e}},b.ChainController.state.activeCaipNetwork?.caipNetworkId)).signature:await c.request({method:"personal_sign",params:[d,e]},b.ChainController.state.activeCaipNetwork?.caipNetworkId)}}async estimateGas(){return Promise.resolve({gas:BigInt(0)})}async sendTransaction(){return Promise.resolve({hash:""})}walletGetAssets(a){return Promise.resolve({})}async writeContract(){return Promise.resolve({hash:""})}emitFirstAvailableConnection(){}parseUnits(){return 0n}formatUnits(){return"0"}async getCapabilities(){return Promise.resolve({})}async grantPermissions(){return Promise.resolve({})}async revokePermissions(){return Promise.resolve("0x")}async syncConnection(){return Promise.resolve({id:"WALLET_CONNECT",type:"WALLET_CONNECT",chainId:1,provider:this.provider,address:""})}async switchNetwork(a){let{caipNetwork:b}=a,c=this.getWalletConnectConnector();if(b.chainNamespace===h.ConstantsUtil.CHAIN.EVM)try{await c.provider?.request({method:"wallet_switchEthereumChain",params:[{chainId:(0,aj.toHex)(b.id)}]})}catch(a){if(4902===a.code||32603===a.code||5e3===a.code||a?.data?.originalError?.code===4902)try{await c.provider?.request({method:"wallet_addEthereumChain",params:[{chainId:(0,aj.toHex)(b.id),rpcUrls:[b?.rpcUrls.chainDefault?.http],chainName:b.name,nativeCurrency:b.nativeCurrency,blockExplorerUrls:[b.blockExplorers?.default.url]}]})}catch(a){throw Error("Chain is not supported")}}c.provider.setDefaultChain(b.caipNetworkId)}getWalletConnectProvider(){let a=this.connectors.find(a=>"WALLET_CONNECT"===a.type);return a?.provider}}let aA=["email","socials","swaps","onramp","activity","reownBranding","multiWallet","emailCapture","payWithExchange","payments","reownAuthentication"],aB={email:{apiFeatureName:"social_login",localFeatureName:"email",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:a=>{if(!a?.config)return!1;let b=a.config;return!!a.isEnabled&&b.includes("email")},processFallback:a=>void 0===a?p.ConstantsUtil.DEFAULT_REMOTE_FEATURES.email:!!a},socials:{apiFeatureName:"social_login",localFeatureName:"socials",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:a=>{if(!a?.config)return!1;let b=a.config;return!!a.isEnabled&&b.length>0&&b.filter(a=>"email"!==a)},processFallback:a=>void 0===a?p.ConstantsUtil.DEFAULT_REMOTE_FEATURES.socials:"boolean"==typeof a?!!a&&p.ConstantsUtil.DEFAULT_REMOTE_FEATURES.socials:a},swaps:{apiFeatureName:"swap",localFeatureName:"swaps",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:a=>{if(!a?.config)return!1;let b=a.config;return!!a.isEnabled&&b.length>0&&b},processFallback:a=>void 0===a?p.ConstantsUtil.DEFAULT_REMOTE_FEATURES.swaps:"boolean"==typeof a?!!a&&p.ConstantsUtil.DEFAULT_REMOTE_FEATURES.swaps:a},onramp:{apiFeatureName:"onramp",localFeatureName:"onramp",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:a=>{if(!a?.config)return!1;let b=a.config;return!!a.isEnabled&&b.length>0&&b},processFallback:a=>void 0===a?p.ConstantsUtil.DEFAULT_REMOTE_FEATURES.onramp:"boolean"==typeof a?!!a&&p.ConstantsUtil.DEFAULT_REMOTE_FEATURES.onramp:a},activity:{apiFeatureName:"activity",localFeatureName:"history",returnType:!1,isLegacy:!0,isAvailableOnBasic:!1,processApi:a=>!!a.isEnabled,processFallback:a=>void 0===a?p.ConstantsUtil.DEFAULT_REMOTE_FEATURES.activity:!!a},reownBranding:{apiFeatureName:"reown_branding",localFeatureName:"reownBranding",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:a=>!!a.isEnabled,processFallback:a=>void 0===a?p.ConstantsUtil.DEFAULT_REMOTE_FEATURES.reownBranding:!!a},emailCapture:{apiFeatureName:"email_capture",localFeatureName:"emailCapture",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:a=>a.isEnabled&&(a.config??[]),processFallback:a=>!1},multiWallet:{apiFeatureName:"multi_wallet",localFeatureName:"multiWallet",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:a=>!!a.isEnabled,processFallback:()=>p.ConstantsUtil.DEFAULT_REMOTE_FEATURES.multiWallet},payWithExchange:{apiFeatureName:"fund_from_exchange",localFeatureName:"payWithExchange",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:a=>!!a.isEnabled,processFallback:()=>p.ConstantsUtil.DEFAULT_REMOTE_FEATURES.payWithExchange},payments:{apiFeatureName:"payments",localFeatureName:"payments",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:a=>!!a.isEnabled,processFallback:()=>p.ConstantsUtil.DEFAULT_REMOTE_FEATURES.payments},reownAuthentication:{apiFeatureName:"reown_authentication",localFeatureName:"reownAuthentication",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:a=>!!a.isEnabled,processFallback:a=>void 0===a?p.ConstantsUtil.DEFAULT_REMOTE_FEATURES.reownAuthentication:!!a}},aC={localSettingsOverridden:new Set,getApiConfig:(a,b)=>b?.find(b=>b.id===a),addWarning(a,b){if(void 0!==a){let a=aB[b],c=a.isLegacy?`"features.${a.localFeatureName}" (now "${b}")`:`"features.${b}"`;this.localSettingsOverridden.add(c)}},processFeature(a,b,c,d,e){let f=aB[a],g=b[f.localFeatureName];if(e&&!f.isAvailableOnBasic)return!1;if(d){let b=this.getApiConfig(f.apiFeatureName,c);return b?.config===null?this.processFallbackFeature(a,g):!!b?.config&&(void 0!==g&&this.addWarning(g,a),this.processApiFeature(a,b))}return this.processFallbackFeature(a,g)},processApiFeature:(a,b)=>aB[a].processApi(b),processFallbackFeature:(a,b)=>aB[a].processFallback(b),async fetchRemoteFeatures(a){let b=a.basic??!1,c=a.features||{};this.localSettingsOverridden.clear();let d=null,e=!1;try{e=null!=(d=await l.ApiController.fetchProjectConfig())}catch(a){console.warn("[Reown Config] Failed to fetch remote project configuration. Using local/default values.",a)}let f=e&&!b?p.ConstantsUtil.DEFAULT_REMOTE_FEATURES:p.ConstantsUtil.DEFAULT_REMOTE_FEATURES_DISABLED;try{for(let a of aA){let g=this.processFeature(a,c,d,e,b);Object.assign(f,{[a]:g})}}catch(a){return console.warn("[Reown Config] Failed to process the configuration from Cloud. Using default values.",a),p.ConstantsUtil.DEFAULT_REMOTE_FEATURES}if(e&&this.localSettingsOverridden.size>0){let a=`Your local configuration for ${Array.from(this.localSettingsOverridden).join(", ")} was ignored because a remote configuration was successfully fetched. Please manage these features via your project dashboard on dashboard.reown.com.`;k.AlertController.open({debugMessage:ab.debugMessage(a)},"warning")}return f}};class aD{constructor(a){this.chainNamespaces=[],this.features={},this.remoteFeatures={},this.reportedAlertErrors={},this.getCaipNetwork=(a,c)=>{if(a){let d=b.ChainController.getCaipNetworks(a)?.find(a=>a.id===c);if(d)return d;let e=b.ChainController.getNetworkData(a)?.caipNetwork;if(e)return e;let f=b.ChainController.getRequestedCaipNetworks(a);return f.filter(b=>b.chainNamespace===a)?.[0]}return b.ChainController.state.activeCaipNetwork||this.defaultCaipNetwork},this.getCaipNetworkId=()=>{let a=this.getCaipNetwork();if(a)return a.id},this.getCaipNetworks=a=>b.ChainController.getCaipNetworks(a),this.getActiveChainNamespace=()=>b.ChainController.state.activeChain,this.setRequestedCaipNetworks=(a,c)=>{b.ChainController.setRequestedCaipNetworks(a,c)},this.getApprovedCaipNetworkIds=()=>b.ChainController.getAllApprovedCaipNetworkIds(),this.getCaipAddress=a=>b.ChainController.state.activeChain!==a&&a?b.ChainController.state.chains.get(a)?.accountState?.caipAddress:b.ChainController.state.activeCaipAddress,this.setClientId=a=>{n.BlockchainApiController.setClientId(a)},this.getProvider=a=>H.getProvider(a),this.getProviderType=a=>H.getProviderId(a),this.getPreferredAccountType=a=>(0,N.getPreferredAccountType)(a),this.setCaipAddress=(a,c,d=!1)=>{b.ChainController.setAccountProp("caipAddress",a,c,d),b.ChainController.setAccountProp("address",e.CoreHelperUtil.getPlainAddress(a),c,d)},this.setBalance=(a,c,d)=>{b.ChainController.setAccountProp("balance",a,d),b.ChainController.setAccountProp("balanceSymbol",c,d)},this.setProfileName=(a,c)=>{b.ChainController.setAccountProp("profileName",a,c)},this.setProfileImage=(a,c)=>{b.ChainController.setAccountProp("profileImage",a,c)},this.setUser=(a,c)=>{b.ChainController.setAccountProp("user",a,c)},this.resetAccount=a=>{b.ChainController.resetAccount(a)},this.setCaipNetwork=a=>{b.ChainController.setActiveCaipNetwork(a)},this.setCaipNetworkOfNamespace=(a,c)=>{b.ChainController.setChainNetworkData(c,{caipNetwork:a})},this.setStatus=(a,c)=>{b.ChainController.setAccountProp("status",a,c),d.ConnectorController.isConnected()?t.StorageUtil.setConnectionStatus("connected"):t.StorageUtil.setConnectionStatus("disconnected")},this.getAddressByChainNamespace=a=>b.ChainController.getAccountData(a)?.address,this.setConnectors=a=>{let b=[...d.ConnectorController.state.allConnectors,...a];d.ConnectorController.setConnectors(b)},this.setConnections=(a,b)=>{t.StorageUtil.setConnections(a,b),c.ConnectionController.setConnections(a,b)},this.fetchIdentity=a=>n.BlockchainApiController.fetchIdentity(a),this.getReownName=a=>x.getNamesForAddress(a),this.getConnectors=()=>d.ConnectorController.getConnectors(),this.getConnectorImage=a=>m.AssetUtil.getConnectorImage(a),this.getConnections=a=>this.remoteFeatures.multiWallet?o.ConnectionControllerUtil.getConnectionsData(a).connections:(k.AlertController.open(h.ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,"info"),[]),this.getRecentConnections=a=>this.remoteFeatures.multiWallet?o.ConnectionControllerUtil.getConnectionsData(a).recentConnections:(k.AlertController.open(h.ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,"info"),[]),this.switchConnection=async a=>{this.remoteFeatures.multiWallet?await c.ConnectionController.switchConnection(a):k.AlertController.open(h.ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,"info")},this.deleteConnection=a=>{this.remoteFeatures.multiWallet?(t.StorageUtil.deleteAddressFromConnection(a),c.ConnectionController.syncStorageConnections()):k.AlertController.open(h.ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,"info")},this.setConnectedWalletInfo=(a,c)=>{let d=H.getProviderId(c),e=a?{...a,type:d}:void 0;b.ChainController.setAccountProp("connectedWalletInfo",e,c)},this.getIsConnectedState=()=>!!b.ChainController.state.activeCaipAddress,this.addAddressLabel=(a,c,d)=>{let e=b.ChainController.getAccountData(d)?.addressLabels||{};b.ChainController.setAccountProp("addressLabels",{...e,[a]:c},d)},this.removeAddressLabel=(a,c)=>{let d=b.ChainController.getAccountData(c)?.addressLabels||{};b.ChainController.setAccountProp("addressLabels",{...d,[a]:void 0},c)},this.getAddress=a=>{let c=a||b.ChainController.state.activeChain;return b.ChainController.getAccountData(c)?.address},this.setApprovedCaipNetworksData=a=>b.ChainController.setApprovedCaipNetworksData(a),this.resetNetwork=a=>{b.ChainController.resetNetwork(a)},this.addConnector=a=>{d.ConnectorController.addConnector(a)},this.resetWcConnection=()=>{c.ConnectionController.resetWcConnection()},this.setAddressExplorerUrl=(a,c)=>{b.ChainController.setAccountProp("addressExplorerUrl",a,c)},this.setSmartAccountDeployed=(a,c)=>{b.ChainController.setAccountProp("smartAccountDeployed",a,c)},this.setPreferredAccountType=(a,c)=>{b.ChainController.setAccountProp("preferredAccountType",a,c)},this.setEIP6963Enabled=a=>{f.OptionsController.setEIP6963Enabled(a)},this.handleUnsafeRPCRequest=()=>{this.isOpen()?this.isTransactionStackEmpty()||this.redirect("ApproveTransaction"):this.open({view:"ApproveTransaction"})},this.options=a,this.version=a.sdkVersion,this.caipNetworks=this.extendCaipNetworks(a),this.chainNamespaces=this.getChainNamespacesSet(a.adapters,this.caipNetworks),this.defaultCaipNetwork=this.extendDefaultCaipNetwork(a),this.chainAdapters=this.createAdapters(a.adapters),this.readyPromise=this.initialize(a),ag.checkSDKVersion(a.sdkVersion)}getChainNamespacesSet(a,b){let c=a?.map(a=>a.namespace).filter(a=>!!a);return c?.length?[...new Set(c)]:[...new Set(b?.map(a=>a.chainNamespace))]}async initialize(b){if(this.initializeProjectSettings(b),this.initControllers(b),await this.initChainAdapters(),this.sendInitializeEvent(b),f.OptionsController.state.enableReconnect?(await this.syncExistingConnection(),await this.syncAdapterConnections()):await this.unSyncExistingConnection(),this.remoteFeatures=await aC.fetchRemoteFeatures(b),f.OptionsController.setRemoteFeatures(this.remoteFeatures),this.remoteFeatures.onramp&&E.setOnrampProviders(this.remoteFeatures.onramp),(f.OptionsController.state.remoteFeatures?.email||Array.isArray(f.OptionsController.state.remoteFeatures?.socials)&&f.OptionsController.state.remoteFeatures?.socials.length>0)&&await this.checkAllowedOrigins(),f.OptionsController.state.features?.reownAuthentication||f.OptionsController.state.remoteFeatures?.reownAuthentication){let{ReownAuthentication:b}=await a.A(202490),c=f.OptionsController.state.siwx;c instanceof b||(c&&console.warn("ReownAuthentication option is enabled, SIWX configuration will be overridden."),f.OptionsController.setSIWX(new b))}}async openSend(a){let c=a.namespace||b.ChainController.state.activeChain,d=this.getCaipAddress(c),e=this.getCaipNetwork(c)?.id;if(!d)throw Error("openSend: caipAddress not found");if(e?.toString()!==a.chainId.toString()){let d=b.ChainController.getCaipNetworkById(a.chainId,c);if(!d)throw Error(`openSend: caipNetwork with chainId ${a.chainId} not found`);await this.switchNetwork(d,{throwOnFailure:!0})}try{let b=ah.getTokenSymbolByAddress(a.assetAddress);b&&await l.ApiController.fetchTokenImages([b])}catch{}return await z.ModalController.open({view:"WalletSend",data:{send:a}}),new Promise((a,b)=>{let c=K.SendController.subscribeKey("hash",b=>{b&&(e(),a({hash:b}))}),d=z.ModalController.subscribe(a=>{a.open||(e(),b(Error("Modal closed")))}),e=this.createCleanupHandler([c,d])})}toModalOptions(){return{isSwap:function(a){return a?.view==="Swap"},isSend:function(a){return a?.view==="WalletSend"}}}async checkAllowedOrigins(){try{let a=await l.ApiController.fetchAllowedOrigins();if(!e.CoreHelperUtil.isClient())return;let b=window.location.origin;as.isOriginAllowed(b,a,au)||k.AlertController.open(aa.ORIGIN_NOT_ALLOWED,"error")}catch(a){if(!(a instanceof Error))return;switch(a.message){case"RATE_LIMITED":k.AlertController.open(aa.RATE_LIMITED_APP_CONFIGURATION,"error");break;case"SERVER_ERROR":{let b=a.cause instanceof Error?a.cause:a;k.AlertController.open({displayMessage:aa.SERVER_ERROR_APP_CONFIGURATION.displayMessage,debugMessage:aa.SERVER_ERROR_APP_CONFIGURATION.debugMessage(b.message)},"error")}}}}createCleanupHandler(a){return()=>{a.forEach(a=>{try{a()}catch{}})}}sendInitializeEvent(a){let{...b}=a;delete b.adapters,delete b.universalProvider,y.EventsController.sendEvent({type:"track",event:"INITIALIZE",properties:{...b,networks:a.networks.map(a=>a.id),siweConfig:{options:a.siweConfig?.options||{}}}})}initControllers(a){this.initializeOptionsController(a),this.initializeChainController(a),this.initializeThemeController(a),this.initializeConnectionController(a),this.initializeConnectorController()}initializeThemeController(a){a.themeMode&&M.ThemeController.setThemeMode(a.themeMode),a.themeVariables&&M.ThemeController.setThemeVariables(a.themeVariables)}initializeChainController(a){if(!this.connectionControllerClient||!this.networkControllerClient)throw Error("ConnectionControllerClient and NetworkControllerClient must be set");b.ChainController.initialize(a.adapters??[],this.caipNetworks,{connectionControllerClient:this.connectionControllerClient,networkControllerClient:this.networkControllerClient});let c=this.getDefaultNetwork();c&&b.ChainController.setActiveCaipNetwork(c)}initializeConnectionController(a){c.ConnectionController.initialize(a.adapters??[]),c.ConnectionController.setWcBasic(a.basic??!1)}initializeConnectorController(){d.ConnectorController.initialize(this.chainNamespaces)}initializeProjectSettings(a){f.OptionsController.setProjectId(a.projectId),f.OptionsController.setSdkVersion(a.sdkVersion)}initializeOptionsController(a){f.OptionsController.setDebug(!1!==a.debug),f.OptionsController.setEnableWalletGuide(!1!==a.enableWalletGuide),f.OptionsController.setEnableWallets(!1!==a.enableWallets),f.OptionsController.setEIP6963Enabled(!1!==a.enableEIP6963),f.OptionsController.setEnableNetworkSwitch(!1!==a.enableNetworkSwitch),f.OptionsController.setEnableReconnect(!1!==a.enableReconnect),f.OptionsController.setEnableMobileFullScreen(!0===a.enableMobileFullScreen),f.OptionsController.setEnableAuthLogger(!1!==a.enableAuthLogger),f.OptionsController.setCustomRpcUrls(a.customRpcUrls),f.OptionsController.setEnableEmbedded(a.enableEmbedded),f.OptionsController.setAllWallets(a.allWallets),f.OptionsController.setIncludeWalletIds(a.includeWalletIds),f.OptionsController.setExcludeWalletIds(a.excludeWalletIds),f.OptionsController.setFeaturedWalletIds(a.featuredWalletIds),f.OptionsController.setTokens(a.tokens),f.OptionsController.setTermsConditionsUrl(a.termsConditionsUrl),f.OptionsController.setPrivacyPolicyUrl(a.privacyPolicyUrl),f.OptionsController.setCustomWallets(a.customWallets),f.OptionsController.setFeatures(a.features),f.OptionsController.setAllowUnsupportedChain(a.allowUnsupportedChain),f.OptionsController.setUniversalProviderConfigOverride(a.universalProviderConfigOverride),f.OptionsController.setPreferUniversalLinks(a.experimental_preferUniversalLinks),f.OptionsController.setDefaultAccountTypes(a.defaultAccountTypes);let b=this.getDefaultMetaData();if(!a.metadata&&b&&(a.metadata=b),f.OptionsController.setMetadata(a.metadata),f.OptionsController.setDisableAppend(a.disableAppend),f.OptionsController.setEnableEmbedded(a.enableEmbedded),f.OptionsController.setSIWX(a.siwx),this.features=f.OptionsController.state.features??{},!a.projectId)return void k.AlertController.open(aa.PROJECT_ID_NOT_CONFIGURED,"error");if(a.adapters?.find(a=>a.namespace===h.ConstantsUtil.CHAIN.EVM)&&a.siweConfig){if(a.siwx)throw Error("Cannot set both `siweConfig` and `siwx` options");f.OptionsController.setSIWX(a.siweConfig.mapToSIWX())}}getDefaultMetaData(){return e.CoreHelperUtil.isClient()?{name:document.getElementsByTagName("title")?.[0]?.textContent||"",description:document.querySelector('meta[property="og:description"]')?.content||"",url:window.location.origin,icons:[document.querySelector('link[rel~="icon"]')?.href||""]}:null}setUnsupportedNetwork(a){let c=this.getActiveChainNamespace();if(c){let d=Z.getUnsupportedNetwork(`${c}:${a}`);b.ChainController.setActiveCaipNetwork(d)}}getDefaultNetwork(){return Z.getCaipNetworkFromStorage(this.defaultCaipNetwork)}extendCaipNetwork(a,b){return Z.extendCaipNetwork(a,{customNetworkImageUrls:b.chainImages,projectId:b.projectId})}extendCaipNetworks(a){return Z.extendCaipNetworks(a.networks,{customNetworkImageUrls:a.chainImages,customRpcUrls:a.customRpcUrls,projectId:a.projectId})}extendDefaultCaipNetwork(a){let b=a.networks.find(b=>b.id===a.defaultNetwork?.id);return b?Z.extendCaipNetwork(b,{customNetworkImageUrls:a.chainImages,customRpcUrls:a.customRpcUrls,projectId:a.projectId}):void 0}async disconnectConnector(a,c){try{this.setLoading(!0,a);let d={connections:[]},e=this.getAdapter(a);return(b.ChainController.state.chains.get(a)?.accountState?.caipAddress||!f.OptionsController.state.enableReconnect)&&e?.disconnect&&(d=await e.disconnect({id:c})),this.setLoading(!1,a),d}catch(b){throw this.setLoading(!1,a),Error(`Failed to disconnect chains: ${b.message}`)}}createClients(){this.connectionControllerClient={connectWalletConnect:async()=>{let a=b.ChainController.state.activeChain,d=this.getAdapter(a),e=this.getCaipNetwork(a)?.id,f=c.ConnectionController.getConnections(a),g=this.remoteFeatures.multiWallet,h=f.length>0;if(!d)throw Error("Adapter not found");let i=await d.connectWalletConnect(e);h&&g||this.close(),this.setClientId(i?.clientId||null),t.StorageUtil.setConnectedNamespaces([...b.ChainController.state.chains.keys()]),await this.syncWalletConnectAccount(),await J.SIWXUtil.initializeIfEnabled()},connectExternal:async a=>{let b=await this.onConnectExternal(a);return await this.connectInactiveNamespaces(a,b),b?{address:b.address}:void 0},reconnectExternal:async({id:a,info:c,type:d,provider:e})=>{let f=b.ChainController.state.activeChain,g=this.getAdapter(f);if(!f)throw Error("reconnectExternal: namespace not found");if(!g)throw Error("reconnectExternal: adapter not found");g?.reconnect&&(await g?.reconnect({id:a,info:c,type:d,provider:e,chainId:this.getCaipNetwork()?.id}),t.StorageUtil.addConnectedNamespace(f),this.syncConnectedWalletInfo(f))},disconnectConnector:async a=>{await this.disconnectConnector(a.namespace,a.id)},disconnect:async a=>{let{id:e,chainNamespace:f,initialDisconnect:g}=a||{},i=f||b.ChainController.state.activeChain,j=d.ConnectorController.getConnectorId(i),k=e===h.ConstantsUtil.CONNECTOR_ID.AUTH||j===h.ConstantsUtil.CONNECTOR_ID.AUTH,l=e===h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT||j===h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;try{let a=Array.from(b.ChainController.state.chains.keys()),h=f?[f]:a;(l||k)&&(h=a);let i=h.map(async a=>{let b=d.ConnectorController.getConnectorId(a),c=await this.disconnectConnector(a,e||b);c&&(k&&t.StorageUtil.deleteConnectedSocialProvider(),c.connections.forEach(b=>{t.StorageUtil.addDisconnectedConnectorId(b.connectorId,a)})),g&&this.onDisconnectNamespace({chainNamespace:a,closeModal:!1})}),j=await Promise.allSettled(i);K.SendController.resetSend(),c.ConnectionController.resetWcConnection(),J.SIWXUtil.getSIWX()?.signOutOnDisconnect&&await J.SIWXUtil.clearSessions(),d.ConnectorController.setFilterByNamespace(void 0),c.ConnectionController.syncStorageConnections();let m=j.filter(a=>"rejected"===a.status);if(m.length>0)throw Error(m.map(a=>a.reason.message).join(", "));y.EventsController.sendEvent({type:"track",event:"DISCONNECT_SUCCESS",properties:{namespace:f||"all"}})}catch(a){throw Error(`Failed to disconnect chains: ${a.message}`)}},checkInstalled:a=>a?a.some(a=>!!window.ethereum?.[String(a)]):!!window.ethereum,signMessage:async a=>{let c=b.ChainController.state.activeChain,d=this.getAdapter(b.ChainController.state.activeChain);if(!c)throw Error("signMessage: namespace not found");if(!d)throw Error("signMessage: adapter not found");let e=this.getAddress(c);if(!e)throw Error("signMessage: address not found");let f=await d?.signMessage({message:a,address:e,provider:H.getProvider(c)});return f?.signature||""},sendTransaction:async a=>{let b=a.chainNamespace;if(!b)throw Error("sendTransaction: namespace not found");if(p.ConstantsUtil.SEND_SUPPORTED_NAMESPACES.includes(b)){let c=this.getAdapter(b);if(!c)throw Error("sendTransaction: adapter not found");let d=H.getProvider(b),e=await c?.sendTransaction({...a,caipNetwork:this.getCaipNetwork(),provider:d});return e?.hash||""}return""},estimateGas:async a=>{let b=a.chainNamespace;if(b===h.ConstantsUtil.CHAIN.EVM){let c=this.getAdapter(b);if(!c)throw Error("estimateGas: adapter is required but got undefined");let d=H.getProvider(b),e=this.getCaipNetwork();if(!e)throw Error("estimateGas: caipNetwork is required but got undefined");let f=await c?.estimateGas({...a,provider:d,caipNetwork:e});return f?.gas||0n}return 0n},getEnsAvatar:async()=>{let a=b.ChainController.state.activeChain;if(!a)throw Error("getEnsAvatar: namespace is required but got undefined");let c=this.getAddress(a);if(!c)throw Error("getEnsAvatar: address not found");await this.syncIdentity({address:c,chainId:Number(this.getCaipNetwork()?.id),chainNamespace:a});let d=b.ChainController.getAccountData();return d?.profileImage||!1},getEnsAddress:async a=>await as.resolveReownName(a),writeContract:async a=>{let c=b.ChainController.state.activeChain,d=this.getAdapter(c);if(!c)throw Error("writeContract: namespace is required but got undefined");if(!d)throw Error("writeContract: adapter is required but got undefined");let e=this.getCaipNetwork(),f=this.getCaipAddress(),g=H.getProvider(c);if(!e||!f)throw Error("writeContract: caipNetwork or caipAddress is required but got undefined");let h=await d?.writeContract({...a,caipNetwork:e,provider:g,caipAddress:f});return h?.hash},parseUnits:(a,c)=>{let d=this.getAdapter(b.ChainController.state.activeChain);if(!d)throw Error("parseUnits: adapter is required but got undefined");return d?.parseUnits({value:a,decimals:c})??0n},formatUnits:(a,c)=>{let d=this.getAdapter(b.ChainController.state.activeChain);if(!d)throw Error("formatUnits: adapter is required but got undefined");return d?.formatUnits({value:a,decimals:c})??"0"},getCapabilities:async a=>{let c=this.getAdapter(b.ChainController.state.activeChain);if(!c)throw Error("getCapabilities: adapter is required but got undefined");return await c?.getCapabilities(a)},grantPermissions:async a=>{let c=this.getAdapter(b.ChainController.state.activeChain);if(!c)throw Error("grantPermissions: adapter is required but got undefined");return await c?.grantPermissions(a)},revokePermissions:async a=>{let c=this.getAdapter(b.ChainController.state.activeChain);if(!c)throw Error("revokePermissions: adapter is required but got undefined");return c?.revokePermissions?await c.revokePermissions(a):"0x"},walletGetAssets:async a=>{let c=this.getAdapter(b.ChainController.state.activeChain);if(!c)throw Error("walletGetAssets: adapter is required but got undefined");return await c?.walletGetAssets(a)??{}},updateBalance:a=>{let b=this.getAddress(a),c=this.getCaipNetwork(a);c&&b&&this.updateNativeBalance(b,c?.id,a)}},this.networkControllerClient={switchCaipNetwork:async a=>await this.switchCaipNetwork(a),getApprovedCaipNetworksData:async()=>this.getApprovedCaipNetworksData()},c.ConnectionController.setClient(this.connectionControllerClient)}async onConnectExternal(a){let c=b.ChainController.state.activeChain,e=a.chain||c,f=this.getAdapter(e),g=!0;if(a.type===T.CONNECTOR_TYPE_AUTH&&h.ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.some(a=>d.ConnectorController.getConnectorId(a)===h.ConstantsUtil.CONNECTOR_ID.AUTH)&&a.chain!==c&&(g=!1),a.chain&&a.chain!==c&&!a.caipNetwork){let b=this.getCaipNetworks().find(b=>b.chainNamespace===a.chain);b&&g&&this.setCaipNetwork(b)}if(!e)throw Error("connectExternal: namespace not found");if(!f)throw Error("connectExternal: adapter not found");let i=this.getCaipNetwork(e),j=a.caipNetwork||i,k=await f.connect({id:a.id,address:a.address,info:a.info,type:a.type,provider:a.provider,socialUri:a.socialUri,chainId:a.caipNetwork?.id||i?.id,rpcUrl:a.caipNetwork?.rpcUrls?.default?.http?.[0]||i?.rpcUrls?.default?.http?.[0]});if(k)return t.StorageUtil.addConnectedNamespace(e),this.syncProvider({...k,chainNamespace:e}),this.setStatus("connected",e),this.syncConnectedWalletInfo(e),t.StorageUtil.removeDisconnectedConnectorId(a.id,e),{address:k.address,connectedCaipNetwork:j}}async connectInactiveNamespaces(a,c){let d=a.type===T.CONNECTOR_TYPE_AUTH,e=ad.getOtherAuthNamespaces(c?.connectedCaipNetwork?.chainNamespace),f=b.ChainController.state.activeCaipNetwork,g=this.getAdapter(f?.chainNamespace),h=H.getProvider(f?.chainNamespace);d&&(await Promise.all(e.map(async b=>{try{let c=H.getProvider(b),d=this.getCaipNetwork(b),e=this.getAdapter(b);await e?.connect({...a,provider:c,socialUri:void 0,chainId:d?.id,rpcUrl:d?.rpcUrls?.default?.http?.[0]})&&(t.StorageUtil.addConnectedNamespace(b),t.StorageUtil.removeDisconnectedConnectorId(a.id,b),this.setStatus("connected",b),this.syncConnectedWalletInfo(b))}catch(a){k.AlertController.warn(ac.displayMessage,ac.debugMessage(b,a instanceof Error?a.message:void 0),ac.code)}})),f&&await g?.switchNetwork({caipNetwork:f,provider:h,providerType:a.type}))}getApprovedCaipNetworksData(){if(H.getProviderId(b.ChainController.state.activeChain)===T.CONNECTOR_TYPE_WALLET_CONNECT){let a=this.universalProvider?.session?.namespaces;return{supportsAllNetworks:this.universalProvider?.session?.peer?.metadata.name==="MetaMask Wallet",approvedCaipNetworkIds:this.getChainsFromNamespaces(a)}}return{supportsAllNetworks:!0,approvedCaipNetworkIds:[]}}async switchCaipNetwork(a){let c=a.chainNamespace;if(this.getAddressByChainNamespace(a.chainNamespace)){let d=H.getProvider(c),e=H.getProviderId(c);if(a.chainNamespace===b.ChainController.state.activeChain){let b=this.getAdapter(c);await b?.switchNetwork({caipNetwork:a,provider:d,providerType:e})}else if(this.setCaipNetwork(a),e===T.CONNECTOR_TYPE_WALLET_CONNECT)this.syncWalletConnectAccount();else{let b=this.getAddressByChainNamespace(c);b&&this.syncAccount({address:b,chainId:a.id,chainNamespace:c})}}else this.setCaipNetwork(a)}getChainsFromNamespaces(a={}){return Object.values(a).flatMap(a=>Array.from(new Set([...a.chains||[],...a.accounts.map(a=>{let{chainId:b,chainNamespace:c}=j.ParseUtil.parseCaipAddress(a);return`${c}:${b}`})])))}createAdapters(a){return this.createClients(),this.chainNamespaces.reduce((b,c)=>{let d=a?.find(a=>a.namespace===c);return d?(d.construct({namespace:c,projectId:this.options?.projectId,networks:this.caipNetworks?.filter(({chainNamespace:a})=>a===c)}),b[c]=d):b[c]=new az({namespace:c,networks:this.getCaipNetworks()}),b},{})}async initChainAdapter(a){this.onConnectors(a),this.listenAdapter(a),await this.chainAdapters?.[a].syncConnectors(this.options,this),await this.createUniversalProviderForAdapter(a)}async initChainAdapters(){await Promise.all(this.chainNamespaces.map(async a=>{await this.initChainAdapter(a)}))}onConnectors(a){let b=this.getAdapter(a);b?.on("connectors",this.setConnectors.bind(this))}listenAdapter(a){let d=this.getAdapter(a);if(!d)return;let e=t.StorageUtil.getConnectionStatus();!1===f.OptionsController.state.enableReconnect?this.setStatus("disconnected",a):"connected"===e?this.setStatus("connecting",a):("disconnected"===e&&t.StorageUtil.clearAddressCache(),this.setStatus(e,a)),d.on("switchNetwork",({address:c,chainId:d})=>{let e=this.getCaipNetworks().find(a=>a.id.toString()===d.toString()||a.caipNetworkId.toString()===d.toString()),f=b.ChainController.state.activeChain===a,g=b.ChainController.state.chains.get(a)?.accountState?.address;if(e){let b=f&&c?c:g;b&&this.syncAccount({address:b,chainId:e.id,chainNamespace:a})}else this.setUnsupportedNetwork(d)}),d.on("disconnect",()=>{let b=this.remoteFeatures.multiWallet,d=Array.from(c.ConnectionController.state.connections.values()).flat();this.onDisconnectNamespace({chainNamespace:a,closeModal:!b||0===d.length})}),d.on("connections",b=>{this.setConnections(b,a)}),d.on("pendingTransactions",()=>{let c=this.getAddress(a),d=b.ChainController.state.activeCaipNetwork;c&&d?.id&&this.updateNativeBalance(c,d.id,d.chainNamespace)}),d.on("accountChanged",({address:c,chainId:d,connector:e})=>{this.handlePreviousConnectorConnection(e);let f=b.ChainController.state.activeChain===a;e?.provider&&(this.syncProvider({id:e.id,type:e.type,provider:e?.provider,chainNamespace:a}),this.syncConnectedWalletInfo(a));let g=b.ChainController.getNetworkData(a)?.caipNetwork?.id,h=d||g;f&&h?this.syncAccount({address:c,chainId:h,chainNamespace:a}):!f&&h?(this.syncAccountInfo(c,h,a),this.syncBalance({address:c,chainId:h,chainNamespace:a})):this.syncAccountInfo(c,d,a),t.StorageUtil.addConnectedNamespace(a)})}async handlePreviousConnectorConnection(a){let b=a?.chain,e=a?.id,g=d.ConnectorController.getConnectorId(b),h=f.OptionsController.state.remoteFeatures?.multiWallet,i=g!==e,j=b&&e&&g&&i&&!h;try{j&&await c.ConnectionController.disconnect({id:g,namespace:b})}catch(a){console.warn("Error disconnecting previous connector",a)}}async createUniversalProviderForAdapter(a){await this.getUniversalProvider(),this.universalProvider&&await this.chainAdapters?.[a]?.setUniversalProvider?.(this.universalProvider)}async syncExistingConnection(){await Promise.allSettled(this.chainNamespaces.map(a=>this.syncNamespaceConnection(a)))}async unSyncExistingConnection(){try{await Promise.allSettled(this.chainNamespaces.map(a=>c.ConnectionController.disconnect({namespace:a,initialDisconnect:!0})))}catch(a){console.error("Error disconnecting existing connections:",a)}}async reconnectWalletConnect(){await this.syncWalletConnectAccount();let a=this.getAddress();this.getCaipAddress()||t.StorageUtil.deleteRecentWallet();let b=t.StorageUtil.getRecentWallet();y.EventsController.sendEvent({type:"track",event:"CONNECT_SUCCESS",address:a,properties:{method:e.CoreHelperUtil.isMobile()?"mobile":"qrcode",name:b?.name||"Unknown",reconnect:!0,view:v.RouterController.state.view,walletRank:b?.order}})}async syncNamespaceConnection(a){try{a===h.ConstantsUtil.CHAIN.EVM&&e.CoreHelperUtil.isSafeApp()&&d.ConnectorController.setConnectorId(h.ConstantsUtil.CONNECTOR_ID.SAFE,a);let b=d.ConnectorController.getConnectorId(a);switch(this.setStatus("connecting",a),b){case h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT:await this.reconnectWalletConnect();break;case h.ConstantsUtil.CONNECTOR_ID.AUTH:break;default:await this.syncAdapterConnection(a)}}catch(b){console.warn("AppKit couldn't sync existing connection",b),this.setStatus("disconnected",a)}}onDisconnectNamespace(a){let{chainNamespace:c,closeModal:e}=a||{};b.ChainController.resetAccount(c),b.ChainController.resetNetwork(c),t.StorageUtil.removeConnectedNamespace(c);let f=Array.from(b.ChainController.state.chains.keys());(c?[c]:f).forEach(a=>t.StorageUtil.addDisconnectedConnectorId(d.ConnectorController.getConnectorId(a)||"",a)),d.ConnectorController.removeConnectorId(c),H.resetChain(c),this.setUser(null,c),this.setStatus("disconnected",c),this.setConnectedWalletInfo(null,c),!1!==e&&z.ModalController.close()}async syncAdapterConnections(){await Promise.allSettled(this.chainNamespaces.map(a=>{let b=this.getAdapter(a),c=this.getCaipAddress(a),d=this.getCaipNetwork(a);return b?.syncConnections({connectToFirstConnector:!c,caipNetwork:d})}))}async syncAdapterConnection(a){let b=this.getAdapter(a),c=this.getCaipNetwork(a),e=d.ConnectorController.getConnectorId(a),f=d.ConnectorController.getConnectors(a).find(a=>a.id===e);try{if(!b||!f)throw Error(`Adapter or connector not found for namespace ${a}`);if(!c?.id)throw Error("CaipNetwork not found");let d=await b?.syncConnection({namespace:a,id:f.id,chainId:c.id,rpcUrl:c?.rpcUrls?.default?.http?.[0]});d?(this.syncProvider({...d,chainNamespace:a}),await this.syncAccount({...d,chainNamespace:a}),this.setStatus("connected",a),y.EventsController.sendEvent({type:"track",event:"CONNECT_SUCCESS",address:d.address,properties:{method:"browser",name:f.info?.name||f.name||"Unknown",reconnect:!0,view:v.RouterController.state.view,walletRank:void 0}})):this.setStatus("disconnected",a)}catch(b){this.onDisconnectNamespace({chainNamespace:a,closeModal:!1})}}async syncWalletConnectAccount(){let a=Object.keys(this.universalProvider?.session?.namespaces||{}),c=this.chainNamespaces.map(async c=>{let e=this.getAdapter(c);if(!e)return;let f=this.universalProvider?.session?.namespaces?.[c]?.accounts||[],g=b.ChainController.state.activeCaipNetwork?.id,i=f.find(a=>{let{chainId:b}=j.ParseUtil.parseCaipAddress(a);return b===g?.toString()})||f[0];if(i){let a=j.ParseUtil.validateCaipAddress(i),{chainId:f,address:g}=j.ParseUtil.parseCaipAddress(a);if(H.setProviderId(c,T.CONNECTOR_TYPE_WALLET_CONNECT),this.caipNetworks&&b.ChainController.state.activeCaipNetwork&&e.namespace!==h.ConstantsUtil.CHAIN.EVM){let a=e.getWalletConnectProvider({caipNetworks:this.getCaipNetworks(),provider:this.universalProvider,activeCaipNetwork:b.ChainController.state.activeCaipNetwork});H.setProvider(c,a)}else H.setProvider(c,this.universalProvider);d.ConnectorController.setConnectorId(h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT,c),t.StorageUtil.addConnectedNamespace(c),await this.syncAccount({address:g,chainId:f,chainNamespace:c})}else a.includes(c)&&this.setStatus("disconnected",c);this.syncConnectedWalletInfo(c),await b.ChainController.setApprovedCaipNetworksData(c)});await Promise.all(c)}syncProvider({type:a,provider:b,id:c,chainNamespace:e}){H.setProviderId(e,a),H.setProvider(e,b),d.ConnectorController.setConnectorId(c,e)}async syncAccount(a){let c=a.chainNamespace===b.ChainController.state.activeChain,d=b.ChainController.getCaipNetworkByNamespace(a.chainNamespace,a.chainId),{address:e,chainId:g,chainNamespace:i}=a,{chainId:k}=t.StorageUtil.getActiveNetworkProps(),l=g||k,m=b.ChainController.state.activeCaipNetwork?.name===h.ConstantsUtil.UNSUPPORTED_NETWORK_NAME,n=b.ChainController.getNetworkProp("supportsAllNetworks",i);if(this.setStatus("connected",i),(!m||n)&&l){let a=this.getCaipNetworks().find(a=>a.id.toString()===l.toString()),k=this.getCaipNetworks().find(a=>a.chainNamespace===i);if(!n&&!a&&!k){let b=this.getApprovedCaipNetworkIds()||[],c=b.find(a=>j.ParseUtil.parseCaipNetworkId(a)?.chainId===l.toString()),d=b.find(a=>j.ParseUtil.parseCaipNetworkId(a)?.chainNamespace===i);a=this.getCaipNetworks().find(a=>a.caipNetworkId===c),k=this.getCaipNetworks().find(a=>a.caipNetworkId===d||"deprecatedCaipNetworkId"in a&&a.deprecatedCaipNetworkId===d)}let m=a||k;m?.chainNamespace===b.ChainController.state.activeChain?f.OptionsController.state.enableNetworkSwitch&&!f.OptionsController.state.allowUnsupportedChain&&b.ChainController.state.activeCaipNetwork?.name===h.ConstantsUtil.UNSUPPORTED_NETWORK_NAME?b.ChainController.showUnsupportedChainUI():this.setCaipNetwork(m):!c&&d&&this.setCaipNetworkOfNamespace(d,i),this.syncConnectedWalletInfo(i);let o=this.getAddress(i);ad.isLowerCaseMatch(e,o)||this.syncAccountInfo(e,m?.id,i),c?await this.syncBalance({address:e,chainId:m?.id,chainNamespace:i}):await this.syncBalance({address:e,chainId:d?.id,chainNamespace:i}),this.syncIdentity({address:e,chainId:g,chainNamespace:i})}}async syncAccountInfo(a,b,c){let d=this.getCaipAddress(c),e=b||d?.split(":")[1];if(!e)return;let f=`${c}:${e}:${a}`;this.setCaipAddress(f,c,!0),await this.syncIdentity({address:a,chainId:e,chainNamespace:c})}async syncReownName(a,b){try{let c=await this.getReownName(a);if(c[0]){let a=c[0];this.setProfileName(a.name,b)}else this.setProfileName(null,b)}catch{this.setProfileName(null,b)}}syncConnectedWalletInfo(a){let b=d.ConnectorController.getConnectorId(a),c=H.getProviderId(a);if(c===T.CONNECTOR_TYPE_ANNOUNCED||c===T.CONNECTOR_TYPE_INJECTED){if(b){let c=this.getConnectors().find(a=>{let c=a.id===b,d=a.info?.rdns===b,e=a.connectors?.some(a=>a.id===b||a.info?.rdns===b);return c||d||!!e});if(c){let{info:b,name:d,imageUrl:e}=c,f=e||this.getConnectorImage(c);this.setConnectedWalletInfo({name:d,icon:f,...b},a)}}}else if(c===T.CONNECTOR_TYPE_WALLET_CONNECT){let b=H.getProvider(a);b?.session&&this.setConnectedWalletInfo({...b.session.peer.metadata,name:b.session.peer.metadata.name,icon:b.session.peer.metadata.icons?.[0]},a)}else if(b&&(b===h.ConstantsUtil.CONNECTOR_ID.COINBASE_SDK||b===h.ConstantsUtil.CONNECTOR_ID.COINBASE)){let c=this.getConnectors().find(a=>a.id===b),d=c?.name||"Coinbase Wallet",e=c?.imageUrl||this.getConnectorImage(c),f=c?.info;this.setConnectedWalletInfo({...f,name:d,icon:e},a)}}async syncBalance(a){i.NetworkUtil.getNetworksByNamespace(this.getCaipNetworks(),a.chainNamespace).find(b=>b.id.toString()===a.chainId?.toString())&&a.chainId&&await this.updateNativeBalance(a.address,a.chainId,a.chainNamespace)}async ready(){await this.readyPromise}async updateNativeBalance(a,c,d){let e=this.getAdapter(d),f=b.ChainController.getCaipNetworkByNamespace(d,c);if(e){let b=await e.getBalance({address:a,chainId:c,caipNetwork:f,tokens:this.options.tokens});return this.setBalance(b.balance,b.symbol,d),b}}async initializeUniversalAdapter(){let a=af.createLogger((a,...b)=>{a&&this.handleAlertError(a),console.error(...b)}),b={projectId:this.options?.projectId,metadata:{name:this.options?.metadata?this.options?.metadata.name:"",description:this.options?.metadata?this.options?.metadata.description:"",url:this.options?.metadata?this.options?.metadata.url:"",icons:this.options?.metadata?this.options?.metadata.icons:[""]},logger:a};f.OptionsController.setManualWCControl(!!this.options?.manualWCControl),this.universalProvider=this.options.universalProvider??await g.default.init(b),!1===f.OptionsController.state.enableReconnect&&this.universalProvider.session&&await this.universalProvider.disconnect(),this.listenWalletConnect()}listenWalletConnect(){this.universalProvider&&this.chainNamespaces.forEach(a=>{as.listenWcProvider({universalProvider:this.universalProvider,namespace:a,onDisplayUri:a=>{c.ConnectionController.setUri(a)},onConnect:a=>{let{address:b}=e.CoreHelperUtil.getAccount(a[0]);c.ConnectionController.finalizeWcConnection(b)},onDisconnect:()=>{b.ChainController.state.noAdapters&&this.resetAccount(a),c.ConnectionController.resetWcConnection()},onChainChanged:c=>{let e=b.ChainController.state.activeChain,f=e&&d.ConnectorController.state.activeConnectorIds[e]===h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;if(e===a&&(b.ChainController.state.noAdapters||f)){let a=this.getCaipNetworks().find(a=>a.id.toString()===c.toString()||a.caipNetworkId.toString()===c.toString()),b=this.getCaipNetwork();if(!a)return void this.setUnsupportedNetwork(c);b?.id.toString()!==a?.id.toString()&&b?.chainNamespace===a?.chainNamespace&&this.setCaipNetwork(a)}},onAccountsChanged:c=>{let e=b.ChainController.state.activeChain,f=e&&d.ConnectorController.state.activeConnectorIds[e]===h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;if(e===a&&(b.ChainController.state.noAdapters||f)){let a=c?.[0];a&&this.syncAccount({address:a.address,chainId:a.chainId,chainNamespace:a.chainNamespace})}}})})}createUniversalProvider(){return!this.universalProviderInitPromise&&e.CoreHelperUtil.isClient()&&this.options?.projectId&&(this.universalProviderInitPromise=this.initializeUniversalAdapter()),this.universalProviderInitPromise}async getUniversalProvider(){if(!this.universalProvider)try{await this.createUniversalProvider()}catch(a){y.EventsController.sendEvent({type:"error",event:"INTERNAL_SDK_ERROR",properties:{errorType:"UniversalProviderInitError",errorMessage:a instanceof Error?a.message:"Unknown",uncaught:!1}}),console.error("AppKit:getUniversalProvider - Cannot create provider",a)}return this.universalProvider}getDisabledCaipNetworks(){let a=b.ChainController.getAllApprovedCaipNetworkIds(),c=b.ChainController.getAllRequestedCaipNetworks();return e.CoreHelperUtil.sortRequestedNetworks(a,c).filter(a=>b.ChainController.isCaipNetworkDisabled(a))}handleAlertError(a){let[b,c]=Object.entries(_).find(([,{message:b}])=>a.message.includes(b))??[],{message:d,alertErrorKey:e}=c??{};if(b&&d&&!this.reportedAlertErrors[b]){let a=aa[e];a&&(k.AlertController.open(a,"error"),this.reportedAlertErrors[b]=!0)}}getAdapter(a){if(a)return this.chainAdapters?.[a]}createAdapter(a){if(!a)return;let b=a.namespace;b&&(this.createClients(),a.namespace=b,a.construct({namespace:b,projectId:this.options?.projectId,networks:this.caipNetworks?.filter(({chainNamespace:a})=>a===b)}),this.chainNamespaces.includes(b)||this.chainNamespaces.push(b),this.chainAdapters&&(this.chainAdapters[b]=a))}async open(a){await this.injectModalUi(),a?.uri&&c.ConnectionController.setUri(a.uri);let{isSwap:b,isSend:d}=this.toModalOptions();return b(a)?z.ModalController.open({...a,data:{swap:a.arguments}}):d(a)&&a.arguments?this.openSend(a.arguments):z.ModalController.open(a)}async close(){await this.injectModalUi(),z.ModalController.close()}setLoading(a,b){z.ModalController.setLoading(a,b)}async disconnect(a){await c.ConnectionController.disconnect({namespace:a})}getSIWX(){return f.OptionsController.state.siwx}getError(){return""}getChainId(){return b.ChainController.state.activeCaipNetwork?.id}async switchNetwork(a,{throwOnFailure:c=!1}={}){let d=this.getCaipNetworks().find(b=>b.id===a.id);d?await b.ChainController.switchActiveNetwork(d,{throwOnFailure:c}):k.AlertController.open(aa.SWITCH_NETWORK_NOT_FOUND,"error")}getWalletProvider(){return b.ChainController.state.activeChain?H.state.providers[b.ChainController.state.activeChain]:null}getWalletProviderType(){return H.getProviderId(b.ChainController.state.activeChain)}subscribeProviders(a){return H.subscribeProviders(a)}getThemeMode(){return M.ThemeController.state.themeMode}getThemeVariables(){return M.ThemeController.state.themeVariables}setThemeMode(a){M.ThemeController.setThemeMode(a),(0,Q.setColorTheme)(M.ThemeController.state.themeMode)}setTermsConditionsUrl(a){f.OptionsController.setTermsConditionsUrl(a)}setPrivacyPolicyUrl(a){f.OptionsController.setPrivacyPolicyUrl(a)}setThemeVariables(a){M.ThemeController.setThemeVariables(a),(0,Q.setThemeVariables)(M.ThemeController.state.themeVariables)}subscribeTheme(a){return M.ThemeController.subscribe(a)}subscribeConnections(a){return this.remoteFeatures.multiWallet?c.ConnectionController.subscribe(a):(k.AlertController.open(h.ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,"info"),()=>void 0)}getWalletInfo(a){if(a)return b.ChainController.state.chains.get(a)?.accountState?.connectedWalletInfo;let c=b.ChainController.getAccountData();return c?.connectedWalletInfo}getAccount(a){let f=a||b.ChainController.state.activeChain,g=d.ConnectorController.getAuthConnector(f),i=b.ChainController.getAccountData(f),j=t.StorageUtil.getConnectedConnectorId(b.ChainController.state.activeChain),k=c.ConnectionController.getConnections(f);if(!f)throw Error("AppKit:getAccount - namespace is required");let l=k.flatMap(a=>a.accounts.map(({address:a,type:b,publicKey:c})=>e.CoreHelperUtil.createAccount(f,a,b||"eoa",c)));if(i)return{allAccounts:l,caipAddress:i.caipAddress,address:e.CoreHelperUtil.getPlainAddress(i.caipAddress),isConnected:!!i.caipAddress,status:i.status,embeddedWalletInfo:g&&j===h.ConstantsUtil.CONNECTOR_ID.AUTH?{user:i.user?{...i.user,username:t.StorageUtil.getConnectedSocialUsername()}:void 0,authProvider:i.socialProvider||"email",accountType:(0,N.getPreferredAccountType)(f),isSmartAccountDeployed:!!i.smartAccountDeployed}:void 0}}subscribeAccount(a,c){let e=()=>{let b=this.getAccount(c);b&&a(b)};c?b.ChainController.subscribeChainProp("accountState",e,c):b.ChainController.subscribe(e),d.ConnectorController.subscribe(e)}subscribeNetwork(a){return b.ChainController.subscribe(({activeCaipNetwork:b})=>{a({caipNetwork:b,chainId:b?.id,caipNetworkId:b?.caipNetworkId})})}subscribeWalletInfo(a,c){return c?b.ChainController.subscribeChainProp("accountState",b=>a(b?.connectedWalletInfo),c):b.ChainController.subscribeChainProp("accountState",b=>a(b?.connectedWalletInfo))}subscribeShouldUpdateToAddress(a){b.ChainController.subscribeChainProp("accountState",b=>a(b?.shouldUpdateToAddress))}subscribeCaipNetworkChange(a){b.ChainController.subscribeKey("activeCaipNetwork",a)}getState(){return I.PublicStateController.state}getRemoteFeatures(){return f.OptionsController.state.remoteFeatures}subscribeState(a){return I.PublicStateController.subscribe(a)}subscribeRemoteFeatures(a){return f.OptionsController.subscribeKey("remoteFeatures",a)}showErrorMessage(a){L.SnackController.showError(a)}showSuccessMessage(a){L.SnackController.showSuccess(a)}getEvent(){return{...y.EventsController.state}}subscribeEvents(a){return y.EventsController.subscribe(a)}replace(a){v.RouterController.replace(a)}redirect(a){v.RouterController.push(a)}popTransactionStack(a){v.RouterController.popTransactionStack(a)}isOpen(){return z.ModalController.state.open}isTransactionStackEmpty(){return 0===v.RouterController.state.transactionStack.length}static getInstance(){return this.instance}updateFeatures(a){f.OptionsController.setFeatures(a)}updateRemoteFeatures(a){f.OptionsController.setRemoteFeatures(a)}updateOptions(a){let b={...f.OptionsController.state||{},...a};f.OptionsController.setOptions(b)}setConnectMethodsOrder(a){f.OptionsController.setConnectMethodsOrder(a)}setWalletFeaturesOrder(a){f.OptionsController.setWalletFeaturesOrder(a)}setCollapseWallets(a){f.OptionsController.setCollapseWallets(a)}setSocialsOrder(a){f.OptionsController.setSocialsOrder(a)}getConnectMethodsOrder(){return P.WalletUtil.getConnectOrderMethod(f.OptionsController.state.features,d.ConnectorController.getConnectors())}addNetwork(a,c){if(this.chainAdapters&&!this.chainAdapters[a])throw Error(`Adapter for namespace ${a} doesn't exist`);let d=this.extendCaipNetwork(c,this.options);this.getCaipNetworks().find(a=>a.id===d.id)||b.ChainController.addNetwork(d)}removeNetwork(a,c){if(this.chainAdapters&&!this.chainAdapters[a])throw Error(`Adapter for namespace ${a} doesn't exist`);this.getCaipNetworks().find(a=>a.id===c)&&b.ChainController.removeNetwork(a,c)}}let aE=!1;class aF extends aD{async open(a){d.ConnectorController.isConnected()||await super.open(a)}async close(){if(await super.close(),this.options.manualWCControl){let a=b.ChainController.getAccountData(this.activeChainNamespace)?.address;c.ConnectionController.finalizeWcConnection(a)}}async syncIdentity(a){return Promise.resolve()}async syncBalance(a){return Promise.resolve()}async injectModalUi(){if(!aE&&e.CoreHelperUtil.isClient()){if(await a.A(754163),await a.A(524103),!document.querySelector("w3m-modal")){let a=document.createElement("w3m-modal");f.OptionsController.state.disableAppend||f.OptionsController.state.enableEmbedded||document.body.insertAdjacentElement("beforeend",a)}aE=!0}}}function aG(a){return new aF({...a,basic:!0,sdkVersion:"html-core-1.8.7"})}a.s(["createAppKit",()=>aG],611286),a.i(611286),a.s(["AppKit",()=>aF,"createAppKit",()=>aG],760912)}];

//# sourceMappingURL=node_modules_%40reown_appkit_dist_esm_exports_core_5ad3ab6d.js.map
{"version":3,"sources":["../../../../node_modules/%40walletconnect/universal-provider/node_modules/viem/errors/version.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/viem/utils/data/size.ts","../../../../node_modules/%40walletconnect/core/node_modules/viem/utils/data/size.ts","../../../../node_modules/%40walletconnect/core/node_modules/viem/utils/signature/recoverPublicKey.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/viem/utils/signature/recoverPublicKey.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/viem/errors/base.ts","../../../../node_modules/%40walletconnect/core/node_modules/viem/errors/base.ts","../../../../node_modules/%40walletconnect/core/node_modules/viem/accounts/utils/publicKeyToAddress.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/viem/accounts/utils/publicKeyToAddress.ts","../../../../node_modules/%40walletconnect/core/node_modules/viem/utils/encoding/toBytes.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/viem/errors/data.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/viem/errors/encoding.ts","../../../../node_modules/%40walletconnect/core/node_modules/viem/errors/encoding.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/viem/utils/encoding/toBytes.ts","../../../../node_modules/%40walletconnect/core/node_modules/viem/errors/data.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/viem/utils/data/isHex.ts","../../../../node_modules/%40walletconnect/core/node_modules/viem/utils/encoding/fromHex.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/viem/utils/encoding/fromHex.ts","../../../../node_modules/%40walletconnect/core/node_modules/viem/utils/address/getAddress.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/viem/utils/address/getAddress.ts","../../../../node_modules/%40walletconnect/core/node_modules/viem/utils/data/isHex.ts","../../../../node_modules/%40walletconnect/core/node_modules/viem/utils/data/pad.ts","../../../../node_modules/%40walletconnect/core/node_modules/viem/utils/signature/recoverAddress.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/viem/utils/signature/recoverAddress.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/viem/utils/data/pad.ts","../../../../node_modules/%40walletconnect/core/node_modules/viem/utils/encoding/toHex.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/viem/utils/encoding/toHex.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/viem/utils/hash/keccak256.ts","../../../../node_modules/%40walletconnect/core/node_modules/viem/utils/hash/keccak256.ts","../../../../node_modules/%40walletconnect/logger/src/constants.ts","../../../../node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/crypto.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/types/src/core/crypto.ts","../../../../node_modules/%40walletconnect/logger/src/linkedList.ts","../../../../node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/messages.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/types/src/core/messages.ts","../../../../node_modules/%40walletconnect/logger/src/clientChunkLogger.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/sign-client/src/constants/history.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/types/src/core/publisher.ts","../../../../node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/publisher.ts","../../../../node_modules/%40walletconnect/logger/src/serverChunkLogger.ts","../../../../node_modules/node_modules/es-toolkit/dist/predicate/isPrimitive.mjs","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/types/src/core/relayer.ts","../../../../node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/relayer.ts","../../../../node_modules/%40walletconnect/core/node_modules/%40walletconnect/utils/src/caip.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/utils/src/caip.ts","../../../../node_modules/%40walletconnect/core/node_modules/viem/utils/lru.ts","../../../../node_modules/%40walletconnect/logger/src/utils.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/viem/utils/lru.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/sign-client/src/constants/session.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/types/src/core/store.ts","../../../../node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/store.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/sign-client/src/constants/engine.ts","../../../../node_modules/node_modules/es-toolkit/dist/compat/_internal/getSymbols.mjs","../../../../node_modules/%40walletconnect/core/src/constants/crypto.ts","../../../../node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/keychain.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/types/src/core/keychain.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/sign-client/src/constants/verify.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/types/src/core/expirer.ts","../../../../node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/expirer.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/sign-client/src/constants/auth.ts","../../../../node_modules/%40walletconnect/core/node_modules/node_modules/%40noble/hashes/esm/_u64.js","../../../../node_modules/%40walletconnect/universal-provider/node_modules/node_modules/%40noble/hashes/esm/_u64.js","../../../../node_modules/%40walletconnect/core/src/constants/messages.ts","../../../../node_modules/node_modules/es-toolkit/dist/compat/_internal/getTag.mjs","../../../../node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/pairing.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/types/src/core/pairing.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/sign-client/src/controllers/engine.ts","../../../../node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/verify.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/types/src/core/verify.ts","../../../../node_modules/%40walletconnect/core/src/constants/relayer.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/sign-client/src/controllers/proposal.ts","../../../../node_modules/node_modules/es-toolkit/dist/compat/_internal/tags.mjs","../../../../node_modules/%40walletconnect/core/src/constants/store.ts","../../../../node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/events.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/types/src/core/events.ts","../../../../node_modules/%40walletconnect/core/src/constants/subscriber.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/sign-client/src/controllers/pendingRequest.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/types/src/sign-client/client.ts","../../../../node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/sign-client/client.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/sign-client/src/controllers/authKey.ts","../../../../node_modules/%40walletconnect/core/src/constants/pairing.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/sign-client/src/controllers/authStore.ts","../../../../node_modules/%40walletconnect/core/src/constants/echo.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/sign-client/src/client.ts","../../../../node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/sign-client/src/index.ts","../../../../node_modules/node_modules/multiformats/esm/vendor/base-x.js","../../../../node_modules/node_modules/es-toolkit/dist/predicate/isTypedArray.mjs","../../../../node_modules/node_modules/es-toolkit/dist/object/cloneDeepWith.mjs","../../../../node_modules/%40walletconnect/core/node_modules/node_modules/%40noble/hashes/esm/crypto.js","../../../../node_modules/%40walletconnect/universal-provider/node_modules/node_modules/%40noble/hashes/esm/crypto.js","../../../../node_modules/%40walletconnect/core/node_modules/node_modules/%40noble/hashes/esm/utils.js","../../../../node_modules/%40walletconnect/universal-provider/node_modules/node_modules/%40noble/hashes/esm/utils.js","../../../../node_modules/%40reown/appkit-controllers/src/controllers/AlertController.ts","../../../../node_modules/%40reown/appkit-controllers/src/utils/SIWXUtil.ts"],"sourcesContent":["export const version = '2.36.0'\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { type IsHexErrorType, isHex } from './isHex.js'\n\nexport type SizeErrorType = IsHexErrorType | ErrorType\n\n/**\n * @description Retrieves the size of the value (in bytes).\n *\n * @param value The value (hex or byte array) to retrieve the size of.\n * @returns The size of the value (in bytes).\n */\nexport function size(value: Hex | ByteArray) {\n  if (isHex(value, { strict: false })) return Math.ceil((value.length - 2) / 2)\n  return value.length\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { type IsHexErrorType, isHex } from './isHex.js'\n\nexport type SizeErrorType = IsHexErrorType | ErrorType\n\n/**\n * @description Retrieves the size of the value (in bytes).\n *\n * @param value The value (hex or byte array) to retrieve the size of.\n * @returns The size of the value (in bytes).\n */\nexport function size(value: Hex | ByteArray) {\n  if (isHex(value, { strict: false })) return Math.ceil((value.length - 2) / 2)\n  return value.length\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { size } from '../data/size.js'\nimport {\n  type HexToNumberErrorType,\n  hexToBigInt,\n  hexToNumber,\n} from '../encoding/fromHex.js'\nimport { toHex } from '../encoding/toHex.js'\n\nexport type RecoverPublicKeyParameters = {\n  hash: Hex | ByteArray\n  signature: Hex | ByteArray | Signature\n}\n\nexport type RecoverPublicKeyReturnType = Hex\n\nexport type RecoverPublicKeyErrorType =\n  | HexToNumberErrorType\n  | IsHexErrorType\n  | ErrorType\n\nexport async function recoverPublicKey({\n  hash,\n  signature,\n}: RecoverPublicKeyParameters): Promise<RecoverPublicKeyReturnType> {\n  const hashHex = isHex(hash) ? hash : toHex(hash)\n\n  const { secp256k1 } = await import('@noble/curves/secp256k1')\n  const signature_ = (() => {\n    // typeof signature: `Signature`\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature) {\n      const { r, s, v, yParity } = signature\n      const yParityOrV = Number(yParity ?? v)!\n      const recoveryBit = toRecoveryBit(yParityOrV)\n      return new secp256k1.Signature(\n        hexToBigInt(r),\n        hexToBigInt(s),\n      ).addRecoveryBit(recoveryBit)\n    }\n\n    // typeof signature: `Hex | ByteArray`\n    const signatureHex = isHex(signature) ? signature : toHex(signature)\n    if (size(signatureHex) !== 65) throw new Error('invalid signature length')\n    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`)\n    const recoveryBit = toRecoveryBit(yParityOrV)\n    return secp256k1.Signature.fromCompact(\n      signatureHex.substring(2, 130),\n    ).addRecoveryBit(recoveryBit)\n  })()\n\n  const publicKey = signature_\n    .recoverPublicKey(hashHex.substring(2))\n    .toHex(false)\n  return `0x${publicKey}`\n}\n\nfunction toRecoveryBit(yParityOrV: number) {\n  if (yParityOrV === 0 || yParityOrV === 1) return yParityOrV\n  if (yParityOrV === 27) return 0\n  if (yParityOrV === 28) return 1\n  throw new Error('Invalid yParityOrV value')\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { size } from '../data/size.js'\nimport {\n  type HexToNumberErrorType,\n  hexToBigInt,\n  hexToNumber,\n} from '../encoding/fromHex.js'\nimport { toHex } from '../encoding/toHex.js'\n\nexport type RecoverPublicKeyParameters = {\n  hash: Hex | ByteArray\n  signature: Hex | ByteArray | Signature\n}\n\nexport type RecoverPublicKeyReturnType = Hex\n\nexport type RecoverPublicKeyErrorType =\n  | HexToNumberErrorType\n  | IsHexErrorType\n  | ErrorType\n\nexport async function recoverPublicKey({\n  hash,\n  signature,\n}: RecoverPublicKeyParameters): Promise<RecoverPublicKeyReturnType> {\n  const hashHex = isHex(hash) ? hash : toHex(hash)\n\n  const { secp256k1 } = await import('@noble/curves/secp256k1')\n  const signature_ = (() => {\n    // typeof signature: `Signature`\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature) {\n      const { r, s, v, yParity } = signature\n      const yParityOrV = Number(yParity ?? v)!\n      const recoveryBit = toRecoveryBit(yParityOrV)\n      return new secp256k1.Signature(\n        hexToBigInt(r),\n        hexToBigInt(s),\n      ).addRecoveryBit(recoveryBit)\n    }\n\n    // typeof signature: `Hex | ByteArray`\n    const signatureHex = isHex(signature) ? signature : toHex(signature)\n    if (size(signatureHex) !== 65) throw new Error('invalid signature length')\n    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`)\n    const recoveryBit = toRecoveryBit(yParityOrV)\n    return secp256k1.Signature.fromCompact(\n      signatureHex.substring(2, 130),\n    ).addRecoveryBit(recoveryBit)\n  })()\n\n  const publicKey = signature_\n    .recoverPublicKey(hashHex.substring(2))\n    .toHex(false)\n  return `0x${publicKey}`\n}\n\nfunction toRecoveryBit(yParityOrV: number) {\n  if (yParityOrV === 0 || yParityOrV === 1) return yParityOrV\n  if (yParityOrV === 27) return 0\n  if (yParityOrV === 28) return 1\n  throw new Error('Invalid yParityOrV value')\n}\n","import { version } from './version.js'\n\ntype ErrorConfig = {\n  getDocsUrl?: ((args: BaseErrorParameters) => string | undefined) | undefined\n  version?: string | undefined\n}\n\nlet errorConfig: ErrorConfig = {\n  getDocsUrl: ({\n    docsBaseUrl,\n    docsPath = '',\n    docsSlug,\n  }: BaseErrorParameters) =>\n    docsPath\n      ? `${docsBaseUrl ?? 'https://viem.sh'}${docsPath}${\n          docsSlug ? `#${docsSlug}` : ''\n        }`\n      : undefined,\n  version: `viem@${version}`,\n}\n\nexport function setErrorConfig(config: ErrorConfig) {\n  errorConfig = config\n}\n\ntype BaseErrorParameters = {\n  cause?: BaseError | Error | undefined\n  details?: string | undefined\n  docsBaseUrl?: string | undefined\n  docsPath?: string | undefined\n  docsSlug?: string | undefined\n  metaMessages?: string[] | undefined\n  name?: string | undefined\n}\n\nexport type BaseErrorType = BaseError & { name: 'BaseError' }\nexport class BaseError extends Error {\n  details: string\n  docsPath?: string | undefined\n  metaMessages?: string[] | undefined\n  shortMessage: string\n  version: string\n\n  override name = 'BaseError'\n\n  constructor(shortMessage: string, args: BaseErrorParameters = {}) {\n    const details = (() => {\n      if (args.cause instanceof BaseError) return args.cause.details\n      if (args.cause?.message) return args.cause.message\n      return args.details!\n    })()\n    const docsPath = (() => {\n      if (args.cause instanceof BaseError)\n        return args.cause.docsPath || args.docsPath\n      return args.docsPath\n    })()\n    const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath })\n\n    const message = [\n      shortMessage || 'An error occurred.',\n      '',\n      ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n      ...(docsUrl ? [`Docs: ${docsUrl}`] : []),\n      ...(details ? [`Details: ${details}`] : []),\n      ...(errorConfig.version ? [`Version: ${errorConfig.version}`] : []),\n    ].join('\\n')\n\n    super(message, args.cause ? { cause: args.cause } : undefined)\n\n    this.details = details\n    this.docsPath = docsPath\n    this.metaMessages = args.metaMessages\n    this.name = args.name ?? this.name\n    this.shortMessage = shortMessage\n    this.version = version\n  }\n\n  walk(): Error\n  walk(fn: (err: unknown) => boolean): Error | null\n  walk(fn?: any): any {\n    return walk(this, fn)\n  }\n}\n\nfunction walk(\n  err: unknown,\n  fn?: ((err: unknown) => boolean) | undefined,\n): unknown {\n  if (fn?.(err)) return err\n  if (\n    err &&\n    typeof err === 'object' &&\n    'cause' in err &&\n    err.cause !== undefined\n  )\n    return walk(err.cause, fn)\n  return fn ? null : err\n}\n","import { version } from './version.js'\n\ntype ErrorConfig = {\n  getDocsUrl?: ((args: BaseErrorParameters) => string | undefined) | undefined\n  version?: string | undefined\n}\n\nlet errorConfig: ErrorConfig = {\n  getDocsUrl: ({\n    docsBaseUrl,\n    docsPath = '',\n    docsSlug,\n  }: BaseErrorParameters) =>\n    docsPath\n      ? `${docsBaseUrl ?? 'https://viem.sh'}${docsPath}${\n          docsSlug ? `#${docsSlug}` : ''\n        }`\n      : undefined,\n  version: `viem@${version}`,\n}\n\nexport function setErrorConfig(config: ErrorConfig) {\n  errorConfig = config\n}\n\ntype BaseErrorParameters = {\n  cause?: BaseError | Error | undefined\n  details?: string | undefined\n  docsBaseUrl?: string | undefined\n  docsPath?: string | undefined\n  docsSlug?: string | undefined\n  metaMessages?: string[] | undefined\n  name?: string | undefined\n}\n\nexport type BaseErrorType = BaseError & { name: 'BaseError' }\nexport class BaseError extends Error {\n  details: string\n  docsPath?: string | undefined\n  metaMessages?: string[] | undefined\n  shortMessage: string\n  version: string\n\n  override name = 'BaseError'\n\n  constructor(shortMessage: string, args: BaseErrorParameters = {}) {\n    const details = (() => {\n      if (args.cause instanceof BaseError) return args.cause.details\n      if (args.cause?.message) return args.cause.message\n      return args.details!\n    })()\n    const docsPath = (() => {\n      if (args.cause instanceof BaseError)\n        return args.cause.docsPath || args.docsPath\n      return args.docsPath\n    })()\n    const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath })\n\n    const message = [\n      shortMessage || 'An error occurred.',\n      '',\n      ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n      ...(docsUrl ? [`Docs: ${docsUrl}`] : []),\n      ...(details ? [`Details: ${details}`] : []),\n      ...(errorConfig.version ? [`Version: ${errorConfig.version}`] : []),\n    ].join('\\n')\n\n    super(message, args.cause ? { cause: args.cause } : undefined)\n\n    this.details = details\n    this.docsPath = docsPath\n    this.metaMessages = args.metaMessages\n    this.name = args.name ?? this.name\n    this.shortMessage = shortMessage\n    this.version = version\n  }\n\n  walk(): Error\n  walk(fn: (err: unknown) => boolean): Error | null\n  walk(fn?: any): any {\n    return walk(this, fn)\n  }\n}\n\nfunction walk(\n  err: unknown,\n  fn?: ((err: unknown) => boolean) | undefined,\n): unknown {\n  if (fn?.(err)) return err\n  if (\n    err &&\n    typeof err === 'object' &&\n    'cause' in err &&\n    err.cause !== undefined\n  )\n    return walk(err.cause, fn)\n  return fn ? null : err\n}\n","import type { Address } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport {\n  type ChecksumAddressErrorType,\n  checksumAddress,\n} from '../../utils/address/getAddress.js'\nimport {\n  type Keccak256ErrorType,\n  keccak256,\n} from '../../utils/hash/keccak256.js'\n\nexport type PublicKeyToAddressErrorType =\n  | ChecksumAddressErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\n/**\n * @description Converts an ECDSA public key to an address.\n *\n * @param publicKey The public key to convert.\n *\n * @returns The address.\n */\nexport function publicKeyToAddress(publicKey: Hex): Address {\n  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26)\n  return checksumAddress(`0x${address}`) as Address\n}\n","import type { Address } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport {\n  type ChecksumAddressErrorType,\n  checksumAddress,\n} from '../../utils/address/getAddress.js'\nimport {\n  type Keccak256ErrorType,\n  keccak256,\n} from '../../utils/hash/keccak256.js'\n\nexport type PublicKeyToAddressErrorType =\n  | ChecksumAddressErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\n/**\n * @description Converts an ECDSA public key to an address.\n *\n * @param publicKey The public key to convert.\n *\n * @returns The address.\n */\nexport function publicKeyToAddress(publicKey: Hex): Address {\n  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26)\n  return checksumAddress(`0x${address}`) as Address\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\nimport {\n  type NumberToHexErrorType,\n  type NumberToHexOpts,\n  numberToHex,\n} from './toHex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\nexport type ToBytesParameters = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type ToBytesErrorType =\n  | NumberToBytesErrorType\n  | BoolToBytesErrorType\n  | HexToBytesErrorType\n  | StringToBytesErrorType\n  | IsHexErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes\n * - Example: https://viem.sh/docs/utilities/toBytes#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(\n  value: string | bigint | number | boolean | Hex,\n  opts: ToBytesParameters = {},\n): ByteArray {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToBytes(value, opts)\n  if (typeof value === 'boolean') return boolToBytes(value, opts)\n  if (isHex(value)) return hexToBytes(value, opts)\n  return stringToBytes(value, opts)\n}\n\nexport type BoolToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type BoolToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value: boolean, opts: BoolToBytesOpts = {}) {\n  const bytes = new Uint8Array(1)\n  bytes[0] = Number(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { size: opts.size })\n  }\n  return bytes\n}\n\n// We use very optimized technique to convert hex string to byte array\nconst charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102,\n} as const\n\nfunction charCodeToBase16(char: number) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n    return char - charCodeMap.zero\n  if (char >= charCodeMap.A && char <= charCodeMap.F)\n    return char - (charCodeMap.A - 10)\n  if (char >= charCodeMap.a && char <= charCodeMap.f)\n    return char - (charCodeMap.a - 10)\n  return undefined\n}\n\nexport type HexToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type HexToBytesErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_: Hex, opts: HexToBytesOpts = {}): ByteArray {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = pad(hex, { dir: 'right', size: opts.size })\n  }\n\n  let hexString = hex.slice(2) as string\n  if (hexString.length % 2) hexString = `0${hexString}`\n\n  const length = hexString.length / 2\n  const bytes = new Uint8Array(length)\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++))\n    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++))\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new BaseError(\n        `Invalid byte sequence (\"${hexString[j - 2]}${\n          hexString[j - 1]\n        }\" in \"${hexString}\").`,\n      )\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight\n  }\n  return bytes\n}\n\nexport type NumberToBytesErrorType =\n  | NumberToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(\n  value: bigint | number,\n  opts?: NumberToHexOpts | undefined,\n) {\n  const hex = numberToHex(value, opts)\n  return hexToBytes(hex)\n}\n\nexport type StringToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type StringToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(\n  value: string,\n  opts: StringToBytesOpts = {},\n): ByteArray {\n  const bytes = encoder.encode(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { dir: 'right', size: opts.size })\n  }\n  return bytes\n}\n","import { BaseError } from './base.js'\n\nexport type SliceOffsetOutOfBoundsErrorType = SliceOffsetOutOfBoundsError & {\n  name: 'SliceOffsetOutOfBoundsError'\n}\nexport class SliceOffsetOutOfBoundsError extends BaseError {\n  constructor({\n    offset,\n    position,\n    size,\n  }: { offset: number; position: 'start' | 'end'; size: number }) {\n    super(\n      `Slice ${\n        position === 'start' ? 'starting' : 'ending'\n      } at offset \"${offset}\" is out-of-bounds (size: ${size}).`,\n      { name: 'SliceOffsetOutOfBoundsError' },\n    )\n  }\n}\n\nexport type SizeExceedsPaddingSizeErrorType = SizeExceedsPaddingSizeError & {\n  name: 'SizeExceedsPaddingSizeError'\n}\nexport class SizeExceedsPaddingSizeError extends BaseError {\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'hex' | 'bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`,\n      { name: 'SizeExceedsPaddingSizeError' },\n    )\n  }\n}\n\nexport type InvalidBytesLengthErrorType = InvalidBytesLengthError & {\n  name: 'InvalidBytesLengthError'\n}\nexport class InvalidBytesLengthError extends BaseError {\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'hex' | 'bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size} ${type} long.`,\n      { name: 'InvalidBytesLengthError' },\n    )\n  }\n}\n","import type { ByteArray, Hex } from '../types/misc.js'\n\nimport { BaseError } from './base.js'\n\nexport type IntegerOutOfRangeErrorType = IntegerOutOfRangeError & {\n  name: 'IntegerOutOfRangeError'\n}\nexport class IntegerOutOfRangeError extends BaseError {\n  constructor({\n    max,\n    min,\n    signed,\n    size,\n    value,\n  }: {\n    max?: string | undefined\n    min: string\n    signed?: boolean | undefined\n    size?: number | undefined\n    value: string\n  }) {\n    super(\n      `Number \"${value}\" is not in safe ${\n        size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''\n      }integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`,\n      { name: 'IntegerOutOfRangeError' },\n    )\n  }\n}\n\nexport type InvalidBytesBooleanErrorType = InvalidBytesBooleanError & {\n  name: 'InvalidBytesBooleanError'\n}\nexport class InvalidBytesBooleanError extends BaseError {\n  constructor(bytes: ByteArray) {\n    super(\n      `Bytes value \"${bytes}\" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,\n      {\n        name: 'InvalidBytesBooleanError',\n      },\n    )\n  }\n}\n\nexport type InvalidHexBooleanErrorType = InvalidHexBooleanError & {\n  name: 'InvalidHexBooleanError'\n}\nexport class InvalidHexBooleanError extends BaseError {\n  constructor(hex: Hex) {\n    super(\n      `Hex value \"${hex}\" is not a valid boolean. The hex value must be \"0x0\" (false) or \"0x1\" (true).`,\n      { name: 'InvalidHexBooleanError' },\n    )\n  }\n}\n\nexport type InvalidHexValueErrorType = InvalidHexValueError & {\n  name: 'InvalidHexValueError'\n}\nexport class InvalidHexValueError extends BaseError {\n  constructor(value: Hex) {\n    super(\n      `Hex value \"${value}\" is an odd length (${value.length}). It must be an even length.`,\n      { name: 'InvalidHexValueError' },\n    )\n  }\n}\n\nexport type SizeOverflowErrorType = SizeOverflowError & {\n  name: 'SizeOverflowError'\n}\nexport class SizeOverflowError extends BaseError {\n  constructor({ givenSize, maxSize }: { givenSize: number; maxSize: number }) {\n    super(\n      `Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`,\n      { name: 'SizeOverflowError' },\n    )\n  }\n}\n","import type { ByteArray, Hex } from '../types/misc.js'\n\nimport { BaseError } from './base.js'\n\nexport type IntegerOutOfRangeErrorType = IntegerOutOfRangeError & {\n  name: 'IntegerOutOfRangeError'\n}\nexport class IntegerOutOfRangeError extends BaseError {\n  constructor({\n    max,\n    min,\n    signed,\n    size,\n    value,\n  }: {\n    max?: string | undefined\n    min: string\n    signed?: boolean | undefined\n    size?: number | undefined\n    value: string\n  }) {\n    super(\n      `Number \"${value}\" is not in safe ${\n        size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''\n      }integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`,\n      { name: 'IntegerOutOfRangeError' },\n    )\n  }\n}\n\nexport type InvalidBytesBooleanErrorType = InvalidBytesBooleanError & {\n  name: 'InvalidBytesBooleanError'\n}\nexport class InvalidBytesBooleanError extends BaseError {\n  constructor(bytes: ByteArray) {\n    super(\n      `Bytes value \"${bytes}\" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,\n      {\n        name: 'InvalidBytesBooleanError',\n      },\n    )\n  }\n}\n\nexport type InvalidHexBooleanErrorType = InvalidHexBooleanError & {\n  name: 'InvalidHexBooleanError'\n}\nexport class InvalidHexBooleanError extends BaseError {\n  constructor(hex: Hex) {\n    super(\n      `Hex value \"${hex}\" is not a valid boolean. The hex value must be \"0x0\" (false) or \"0x1\" (true).`,\n      { name: 'InvalidHexBooleanError' },\n    )\n  }\n}\n\nexport type InvalidHexValueErrorType = InvalidHexValueError & {\n  name: 'InvalidHexValueError'\n}\nexport class InvalidHexValueError extends BaseError {\n  constructor(value: Hex) {\n    super(\n      `Hex value \"${value}\" is an odd length (${value.length}). It must be an even length.`,\n      { name: 'InvalidHexValueError' },\n    )\n  }\n}\n\nexport type SizeOverflowErrorType = SizeOverflowError & {\n  name: 'SizeOverflowError'\n}\nexport class SizeOverflowError extends BaseError {\n  constructor({ givenSize, maxSize }: { givenSize: number; maxSize: number }) {\n    super(\n      `Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`,\n      { name: 'SizeOverflowError' },\n    )\n  }\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\nimport {\n  type NumberToHexErrorType,\n  type NumberToHexOpts,\n  numberToHex,\n} from './toHex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\nexport type ToBytesParameters = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type ToBytesErrorType =\n  | NumberToBytesErrorType\n  | BoolToBytesErrorType\n  | HexToBytesErrorType\n  | StringToBytesErrorType\n  | IsHexErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes\n * - Example: https://viem.sh/docs/utilities/toBytes#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(\n  value: string | bigint | number | boolean | Hex,\n  opts: ToBytesParameters = {},\n): ByteArray {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToBytes(value, opts)\n  if (typeof value === 'boolean') return boolToBytes(value, opts)\n  if (isHex(value)) return hexToBytes(value, opts)\n  return stringToBytes(value, opts)\n}\n\nexport type BoolToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type BoolToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value: boolean, opts: BoolToBytesOpts = {}) {\n  const bytes = new Uint8Array(1)\n  bytes[0] = Number(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { size: opts.size })\n  }\n  return bytes\n}\n\n// We use very optimized technique to convert hex string to byte array\nconst charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102,\n} as const\n\nfunction charCodeToBase16(char: number) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n    return char - charCodeMap.zero\n  if (char >= charCodeMap.A && char <= charCodeMap.F)\n    return char - (charCodeMap.A - 10)\n  if (char >= charCodeMap.a && char <= charCodeMap.f)\n    return char - (charCodeMap.a - 10)\n  return undefined\n}\n\nexport type HexToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type HexToBytesErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_: Hex, opts: HexToBytesOpts = {}): ByteArray {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = pad(hex, { dir: 'right', size: opts.size })\n  }\n\n  let hexString = hex.slice(2) as string\n  if (hexString.length % 2) hexString = `0${hexString}`\n\n  const length = hexString.length / 2\n  const bytes = new Uint8Array(length)\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++))\n    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++))\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new BaseError(\n        `Invalid byte sequence (\"${hexString[j - 2]}${\n          hexString[j - 1]\n        }\" in \"${hexString}\").`,\n      )\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight\n  }\n  return bytes\n}\n\nexport type NumberToBytesErrorType =\n  | NumberToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(\n  value: bigint | number,\n  opts?: NumberToHexOpts | undefined,\n) {\n  const hex = numberToHex(value, opts)\n  return hexToBytes(hex)\n}\n\nexport type StringToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type StringToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(\n  value: string,\n  opts: StringToBytesOpts = {},\n): ByteArray {\n  const bytes = encoder.encode(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { dir: 'right', size: opts.size })\n  }\n  return bytes\n}\n","import { BaseError } from './base.js'\n\nexport type SliceOffsetOutOfBoundsErrorType = SliceOffsetOutOfBoundsError & {\n  name: 'SliceOffsetOutOfBoundsError'\n}\nexport class SliceOffsetOutOfBoundsError extends BaseError {\n  constructor({\n    offset,\n    position,\n    size,\n  }: { offset: number; position: 'start' | 'end'; size: number }) {\n    super(\n      `Slice ${\n        position === 'start' ? 'starting' : 'ending'\n      } at offset \"${offset}\" is out-of-bounds (size: ${size}).`,\n      { name: 'SliceOffsetOutOfBoundsError' },\n    )\n  }\n}\n\nexport type SizeExceedsPaddingSizeErrorType = SizeExceedsPaddingSizeError & {\n  name: 'SizeExceedsPaddingSizeError'\n}\nexport class SizeExceedsPaddingSizeError extends BaseError {\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'hex' | 'bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`,\n      { name: 'SizeExceedsPaddingSizeError' },\n    )\n  }\n}\n\nexport type InvalidBytesLengthErrorType = InvalidBytesLengthError & {\n  name: 'InvalidBytesLengthError'\n}\nexport class InvalidBytesLengthError extends BaseError {\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'hex' | 'bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size} ${type} long.`,\n      { name: 'InvalidBytesLengthError' },\n    )\n  }\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\n\nexport type IsHexErrorType = ErrorType\n\nexport function isHex(\n  value: unknown,\n  { strict = true }: { strict?: boolean | undefined } = {},\n): value is Hex {\n  if (!value) return false\n  if (typeof value !== 'string') return false\n  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x')\n}\n","import {\n  InvalidHexBooleanError,\n  type InvalidHexBooleanErrorType,\n  SizeOverflowError,\n  type SizeOverflowErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type SizeErrorType, size as size_ } from '../data/size.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\n\nexport type AssertSizeErrorType =\n  | SizeOverflowErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function assertSize(\n  hexOrBytes: Hex | ByteArray,\n  { size }: { size: number },\n): void {\n  if (size_(hexOrBytes) > size)\n    throw new SizeOverflowError({\n      givenSize: size_(hexOrBytes),\n      maxSize: size,\n    })\n}\n\nexport type FromHexParameters<\n  to extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n> =\n  | to\n  | {\n      /** Size (in bytes) of the hex value. */\n      size?: number | undefined\n      /** Type to convert to. */\n      to: to\n    }\n\nexport type FromHexReturnType<to> = to extends 'string'\n  ? string\n  : to extends 'bigint'\n    ? bigint\n    : to extends 'number'\n      ? number\n      : to extends 'bytes'\n        ? ByteArray\n        : to extends 'boolean'\n          ? boolean\n          : never\n\nexport type FromHexErrorType =\n  | HexToNumberErrorType\n  | HexToBigIntErrorType\n  | HexToBoolErrorType\n  | HexToStringErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Decodes a hex string into a string, number, bigint, boolean, or byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex\n * - Example: https://viem.sh/docs/utilities/fromHex#usage\n *\n * @param hex Hex string to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x1a4', 'number')\n * // 420\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c6421', 'string')\n * // 'Hello world'\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *   size: 32,\n *   to: 'string'\n * })\n * // 'Hello world'\n */\nexport function fromHex<\n  to extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n>(hex: Hex, toOrOpts: FromHexParameters<to>): FromHexReturnType<to> {\n  const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts\n  const to = opts.to\n\n  if (to === 'number') return hexToNumber(hex, opts) as FromHexReturnType<to>\n  if (to === 'bigint') return hexToBigInt(hex, opts) as FromHexReturnType<to>\n  if (to === 'string') return hexToString(hex, opts) as FromHexReturnType<to>\n  if (to === 'boolean') return hexToBool(hex, opts) as FromHexReturnType<to>\n  return hexToBytes(hex, opts) as FromHexReturnType<to>\n}\n\nexport type HexToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean | undefined\n  /** Size (in bytes) of the hex value. */\n  size?: number | undefined\n}\n\nexport type HexToBigIntErrorType = AssertSizeErrorType | ErrorType\n\n/**\n * Decodes a hex value into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobigint\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x1a4', { signed: true })\n * // 420n\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420n\n */\nexport function hexToBigInt(hex: Hex, opts: HexToBigIntOpts = {}): bigint {\n  const { signed } = opts\n\n  if (opts.size) assertSize(hex, { size: opts.size })\n\n  const value = BigInt(hex)\n  if (!signed) return value\n\n  const size = (hex.length - 2) / 2\n  const max = (1n << (BigInt(size) * 8n - 1n)) - 1n\n  if (value <= max) return value\n\n  return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n\n}\n\nexport type HexToBoolOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number | undefined\n}\n\nexport type HexToBoolErrorType =\n  | AssertSizeErrorType\n  | InvalidHexBooleanErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a hex value into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobool\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x01')\n * // true\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // true\n */\nexport function hexToBool(hex_: Hex, opts: HexToBoolOpts = {}): boolean {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = trim(hex)\n  }\n  if (trim(hex) === '0x00') return false\n  if (trim(hex) === '0x01') return true\n  throw new InvalidHexBooleanError(hex)\n}\n\nexport type HexToNumberOpts = HexToBigIntOpts\n\nexport type HexToNumberErrorType = HexToBigIntErrorType | ErrorType\n\n/**\n * Decodes a hex string into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextonumber\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToNumber('0x1a4')\n * // 420\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420\n */\nexport function hexToNumber(hex: Hex, opts: HexToNumberOpts = {}): number {\n  return Number(hexToBigInt(hex, opts))\n}\n\nexport type HexToStringOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number | undefined\n}\n\nexport type HexToStringErrorType =\n  | AssertSizeErrorType\n  | HexToBytesErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a hex value into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextostring\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c6421')\n * // 'Hello world!'\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // 'Hello world'\n */\nexport function hexToString(hex: Hex, opts: HexToStringOpts = {}): string {\n  let bytes = hexToBytes(hex)\n  if (opts.size) {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes, { dir: 'right' })\n  }\n  return new TextDecoder().decode(bytes)\n}\n","import {\n  InvalidHexBooleanError,\n  type InvalidHexBooleanErrorType,\n  SizeOverflowError,\n  type SizeOverflowErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type SizeErrorType, size as size_ } from '../data/size.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\n\nexport type AssertSizeErrorType =\n  | SizeOverflowErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function assertSize(\n  hexOrBytes: Hex | ByteArray,\n  { size }: { size: number },\n): void {\n  if (size_(hexOrBytes) > size)\n    throw new SizeOverflowError({\n      givenSize: size_(hexOrBytes),\n      maxSize: size,\n    })\n}\n\nexport type FromHexParameters<\n  to extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n> =\n  | to\n  | {\n      /** Size (in bytes) of the hex value. */\n      size?: number | undefined\n      /** Type to convert to. */\n      to: to\n    }\n\nexport type FromHexReturnType<to> = to extends 'string'\n  ? string\n  : to extends 'bigint'\n    ? bigint\n    : to extends 'number'\n      ? number\n      : to extends 'bytes'\n        ? ByteArray\n        : to extends 'boolean'\n          ? boolean\n          : never\n\nexport type FromHexErrorType =\n  | HexToNumberErrorType\n  | HexToBigIntErrorType\n  | HexToBoolErrorType\n  | HexToStringErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Decodes a hex string into a string, number, bigint, boolean, or byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex\n * - Example: https://viem.sh/docs/utilities/fromHex#usage\n *\n * @param hex Hex string to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x1a4', 'number')\n * // 420\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c6421', 'string')\n * // 'Hello world'\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *   size: 32,\n *   to: 'string'\n * })\n * // 'Hello world'\n */\nexport function fromHex<\n  to extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n>(hex: Hex, toOrOpts: FromHexParameters<to>): FromHexReturnType<to> {\n  const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts\n  const to = opts.to\n\n  if (to === 'number') return hexToNumber(hex, opts) as FromHexReturnType<to>\n  if (to === 'bigint') return hexToBigInt(hex, opts) as FromHexReturnType<to>\n  if (to === 'string') return hexToString(hex, opts) as FromHexReturnType<to>\n  if (to === 'boolean') return hexToBool(hex, opts) as FromHexReturnType<to>\n  return hexToBytes(hex, opts) as FromHexReturnType<to>\n}\n\nexport type HexToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean | undefined\n  /** Size (in bytes) of the hex value. */\n  size?: number | undefined\n}\n\nexport type HexToBigIntErrorType = AssertSizeErrorType | ErrorType\n\n/**\n * Decodes a hex value into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobigint\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x1a4', { signed: true })\n * // 420n\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420n\n */\nexport function hexToBigInt(hex: Hex, opts: HexToBigIntOpts = {}): bigint {\n  const { signed } = opts\n\n  if (opts.size) assertSize(hex, { size: opts.size })\n\n  const value = BigInt(hex)\n  if (!signed) return value\n\n  const size = (hex.length - 2) / 2\n  const max = (1n << (BigInt(size) * 8n - 1n)) - 1n\n  if (value <= max) return value\n\n  return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n\n}\n\nexport type HexToBoolOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number | undefined\n}\n\nexport type HexToBoolErrorType =\n  | AssertSizeErrorType\n  | InvalidHexBooleanErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a hex value into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobool\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x01')\n * // true\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // true\n */\nexport function hexToBool(hex_: Hex, opts: HexToBoolOpts = {}): boolean {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = trim(hex)\n  }\n  if (trim(hex) === '0x00') return false\n  if (trim(hex) === '0x01') return true\n  throw new InvalidHexBooleanError(hex)\n}\n\nexport type HexToNumberOpts = HexToBigIntOpts\n\nexport type HexToNumberErrorType = HexToBigIntErrorType | ErrorType\n\n/**\n * Decodes a hex string into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextonumber\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToNumber('0x1a4')\n * // 420\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420\n */\nexport function hexToNumber(hex: Hex, opts: HexToNumberOpts = {}): number {\n  return Number(hexToBigInt(hex, opts))\n}\n\nexport type HexToStringOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number | undefined\n}\n\nexport type HexToStringErrorType =\n  | AssertSizeErrorType\n  | HexToBytesErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a hex value into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextostring\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c6421')\n * // 'Hello world!'\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // 'Hello world'\n */\nexport function hexToString(hex: Hex, opts: HexToStringOpts = {}): string {\n  let bytes = hexToBytes(hex)\n  if (opts.size) {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes, { dir: 'right' })\n  }\n  return new TextDecoder().decode(bytes)\n}\n","import type { Address } from 'abitype'\n\nimport { InvalidAddressError } from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type StringToBytesErrorType,\n  stringToBytes,\n} from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { LruMap } from '../lru.js'\nimport { type IsAddressErrorType, isAddress } from './isAddress.js'\n\nconst checksumAddressCache = /*#__PURE__*/ new LruMap<Address>(8192)\n\nexport type ChecksumAddressErrorType =\n  | Keccak256ErrorType\n  | StringToBytesErrorType\n  | ErrorType\n\nexport function checksumAddress(\n  address_: Address,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number | undefined,\n): Address {\n  if (checksumAddressCache.has(`${address_}.${chainId}`))\n    return checksumAddressCache.get(`${address_}.${chainId}`)!\n\n  const hexAddress = chainId\n    ? `${chainId}${address_.toLowerCase()}`\n    : address_.substring(2).toLowerCase()\n  const hash = keccak256(stringToBytes(hexAddress), 'bytes')\n\n  const address = (\n    chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress\n  ).split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase()\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase()\n    }\n  }\n\n  const result = `0x${address.join('')}` as const\n  checksumAddressCache.set(`${address_}.${chainId}`, result)\n  return result\n}\n\nexport type GetAddressErrorType =\n  | ChecksumAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nexport function getAddress(\n  address: string,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number,\n): Address {\n  if (!isAddress(address, { strict: false }))\n    throw new InvalidAddressError({ address })\n  return checksumAddress(address, chainId)\n}\n","import type { Address } from 'abitype'\n\nimport { InvalidAddressError } from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type StringToBytesErrorType,\n  stringToBytes,\n} from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { LruMap } from '../lru.js'\nimport { type IsAddressErrorType, isAddress } from './isAddress.js'\n\nconst checksumAddressCache = /*#__PURE__*/ new LruMap<Address>(8192)\n\nexport type ChecksumAddressErrorType =\n  | Keccak256ErrorType\n  | StringToBytesErrorType\n  | ErrorType\n\nexport function checksumAddress(\n  address_: Address,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number | undefined,\n): Address {\n  if (checksumAddressCache.has(`${address_}.${chainId}`))\n    return checksumAddressCache.get(`${address_}.${chainId}`)!\n\n  const hexAddress = chainId\n    ? `${chainId}${address_.toLowerCase()}`\n    : address_.substring(2).toLowerCase()\n  const hash = keccak256(stringToBytes(hexAddress), 'bytes')\n\n  const address = (\n    chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress\n  ).split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase()\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase()\n    }\n  }\n\n  const result = `0x${address.join('')}` as const\n  checksumAddressCache.set(`${address_}.${chainId}`, result)\n  return result\n}\n\nexport type GetAddressErrorType =\n  | ChecksumAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nexport function getAddress(\n  address: string,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number,\n): Address {\n  if (!isAddress(address, { strict: false }))\n    throw new InvalidAddressError({ address })\n  return checksumAddress(address, chainId)\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\n\nexport type IsHexErrorType = ErrorType\n\nexport function isHex(\n  value: unknown,\n  { strict = true }: { strict?: boolean | undefined } = {},\n): value is Hex {\n  if (!value) return false\n  if (typeof value !== 'string') return false\n  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x')\n}\n","import {\n  SizeExceedsPaddingSizeError,\n  type SizeExceedsPaddingSizeErrorType,\n} from '../../errors/data.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\ntype PadOptions = {\n  dir?: 'left' | 'right' | undefined\n  size?: number | null | undefined\n}\nexport type PadReturnType<value extends ByteArray | Hex> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type PadErrorType = PadHexErrorType | PadBytesErrorType | ErrorType\n\nexport function pad<value extends ByteArray | Hex>(\n  hexOrBytes: value,\n  { dir, size = 32 }: PadOptions = {},\n): PadReturnType<value> {\n  if (typeof hexOrBytes === 'string')\n    return padHex(hexOrBytes, { dir, size }) as PadReturnType<value>\n  return padBytes(hexOrBytes, { dir, size }) as PadReturnType<value>\n}\n\nexport type PadHexErrorType = SizeExceedsPaddingSizeErrorType | ErrorType\n\nexport function padHex(hex_: Hex, { dir, size = 32 }: PadOptions = {}) {\n  if (size === null) return hex_\n  const hex = hex_.replace('0x', '')\n  if (hex.length > size * 2)\n    throw new SizeExceedsPaddingSizeError({\n      size: Math.ceil(hex.length / 2),\n      targetSize: size,\n      type: 'hex',\n    })\n\n  return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](\n    size * 2,\n    '0',\n  )}` as Hex\n}\n\nexport type PadBytesErrorType = SizeExceedsPaddingSizeErrorType | ErrorType\n\nexport function padBytes(\n  bytes: ByteArray,\n  { dir, size = 32 }: PadOptions = {},\n) {\n  if (size === null) return bytes\n  if (bytes.length > size)\n    throw new SizeExceedsPaddingSizeError({\n      size: bytes.length,\n      targetSize: size,\n      type: 'bytes',\n    })\n  const paddedBytes = new Uint8Array(size)\n  for (let i = 0; i < size; i++) {\n    const padEnd = dir === 'right'\n    paddedBytes[padEnd ? i : size - i - 1] =\n      bytes[padEnd ? i : bytes.length - i - 1]\n  }\n  return paddedBytes\n}\n","import type { Address } from 'abitype'\n\nimport { publicKeyToAddress } from '../../accounts/utils/publicKeyToAddress.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport { recoverPublicKey } from './recoverPublicKey.js'\n\nexport type RecoverAddressParameters = {\n  hash: Hex | ByteArray\n  signature: Hex | ByteArray | Signature\n}\n\nexport type RecoverAddressReturnType = Address\n\nexport type RecoverAddressErrorType = ErrorType\n\nexport async function recoverAddress({\n  hash,\n  signature,\n}: RecoverAddressParameters): Promise<RecoverAddressReturnType> {\n  return publicKeyToAddress(await recoverPublicKey({ hash, signature }))\n}\n","import type { Address } from 'abitype'\n\nimport { publicKeyToAddress } from '../../accounts/utils/publicKeyToAddress.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport { recoverPublicKey } from './recoverPublicKey.js'\n\nexport type RecoverAddressParameters = {\n  hash: Hex | ByteArray\n  signature: Hex | ByteArray | Signature\n}\n\nexport type RecoverAddressReturnType = Address\n\nexport type RecoverAddressErrorType = ErrorType\n\nexport async function recoverAddress({\n  hash,\n  signature,\n}: RecoverAddressParameters): Promise<RecoverAddressReturnType> {\n  return publicKeyToAddress(await recoverPublicKey({ hash, signature }))\n}\n","import {\n  SizeExceedsPaddingSizeError,\n  type SizeExceedsPaddingSizeErrorType,\n} from '../../errors/data.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\ntype PadOptions = {\n  dir?: 'left' | 'right' | undefined\n  size?: number | null | undefined\n}\nexport type PadReturnType<value extends ByteArray | Hex> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type PadErrorType = PadHexErrorType | PadBytesErrorType | ErrorType\n\nexport function pad<value extends ByteArray | Hex>(\n  hexOrBytes: value,\n  { dir, size = 32 }: PadOptions = {},\n): PadReturnType<value> {\n  if (typeof hexOrBytes === 'string')\n    return padHex(hexOrBytes, { dir, size }) as PadReturnType<value>\n  return padBytes(hexOrBytes, { dir, size }) as PadReturnType<value>\n}\n\nexport type PadHexErrorType = SizeExceedsPaddingSizeErrorType | ErrorType\n\nexport function padHex(hex_: Hex, { dir, size = 32 }: PadOptions = {}) {\n  if (size === null) return hex_\n  const hex = hex_.replace('0x', '')\n  if (hex.length > size * 2)\n    throw new SizeExceedsPaddingSizeError({\n      size: Math.ceil(hex.length / 2),\n      targetSize: size,\n      type: 'hex',\n    })\n\n  return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](\n    size * 2,\n    '0',\n  )}` as Hex\n}\n\nexport type PadBytesErrorType = SizeExceedsPaddingSizeErrorType | ErrorType\n\nexport function padBytes(\n  bytes: ByteArray,\n  { dir, size = 32 }: PadOptions = {},\n) {\n  if (size === null) return bytes\n  if (bytes.length > size)\n    throw new SizeExceedsPaddingSizeError({\n      size: bytes.length,\n      targetSize: size,\n      type: 'bytes',\n    })\n  const paddedBytes = new Uint8Array(size)\n  for (let i = 0; i < size; i++) {\n    const padEnd = dir === 'right'\n    paddedBytes[padEnd ? i : size - i - 1] =\n      bytes[padEnd ? i : bytes.length - i - 1]\n  }\n  return paddedBytes\n}\n","import {\n  IntegerOutOfRangeError,\n  type IntegerOutOfRangeErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\n\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\nexport type ToHexParameters = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type ToHexErrorType =\n  | BoolToHexErrorType\n  | BytesToHexErrorType\n  | NumberToHexErrorType\n  | StringToHexErrorType\n  | ErrorType\n\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex\n * - Example: https://viem.sh/docs/utilities/toHex#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(\n  value: string | number | bigint | boolean | ByteArray,\n  opts: ToHexParameters = {},\n): Hex {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToHex(value, opts)\n  if (typeof value === 'string') {\n    return stringToHex(value, opts)\n  }\n  if (typeof value === 'boolean') return boolToHex(value, opts)\n  return bytesToHex(value, opts)\n}\n\nexport type BoolToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type BoolToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value: boolean, opts: BoolToHexOpts = {}): Hex {\n  const hex: Hex = `0x${Number(value)}`\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { size: opts.size })\n  }\n  return hex\n}\n\nexport type BytesToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type BytesToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value: ByteArray, opts: BytesToHexOpts = {}): Hex {\n  let string = ''\n  for (let i = 0; i < value.length; i++) {\n    string += hexes[value[i]]\n  }\n  const hex = `0x${string}` as const\n\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { dir: 'right', size: opts.size })\n  }\n  return hex\n}\n\nexport type NumberToHexOpts =\n  | {\n      /** Whether or not the number of a signed representation. */\n      signed?: boolean | undefined\n      /** The size (in bytes) of the output hex value. */\n      size: number\n    }\n  | {\n      signed?: undefined\n      /** The size (in bytes) of the output hex value. */\n      size?: number | undefined\n    }\n\nexport type NumberToHexErrorType =\n  | IntegerOutOfRangeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(\n  value_: number | bigint,\n  opts: NumberToHexOpts = {},\n): Hex {\n  const { signed, size } = opts\n\n  const value = BigInt(value_)\n\n  let maxValue: bigint | number | undefined\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value_ === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value > maxValue) || value < minValue) {\n    const suffix = typeof value_ === 'bigint' ? 'n' : ''\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value_}${suffix}`,\n    })\n  }\n\n  const hex = `0x${(\n    signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value\n  ).toString(16)}` as Hex\n  if (size) return pad(hex, { size }) as Hex\n  return hex\n}\n\nexport type StringToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type StringToHexErrorType = BytesToHexErrorType | ErrorType\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_: string, opts: StringToHexOpts = {}): Hex {\n  const value = encoder.encode(value_)\n  return bytesToHex(value, opts)\n}\n","import {\n  IntegerOutOfRangeError,\n  type IntegerOutOfRangeErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\n\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\nexport type ToHexParameters = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type ToHexErrorType =\n  | BoolToHexErrorType\n  | BytesToHexErrorType\n  | NumberToHexErrorType\n  | StringToHexErrorType\n  | ErrorType\n\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex\n * - Example: https://viem.sh/docs/utilities/toHex#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(\n  value: string | number | bigint | boolean | ByteArray,\n  opts: ToHexParameters = {},\n): Hex {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToHex(value, opts)\n  if (typeof value === 'string') {\n    return stringToHex(value, opts)\n  }\n  if (typeof value === 'boolean') return boolToHex(value, opts)\n  return bytesToHex(value, opts)\n}\n\nexport type BoolToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type BoolToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value: boolean, opts: BoolToHexOpts = {}): Hex {\n  const hex: Hex = `0x${Number(value)}`\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { size: opts.size })\n  }\n  return hex\n}\n\nexport type BytesToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type BytesToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value: ByteArray, opts: BytesToHexOpts = {}): Hex {\n  let string = ''\n  for (let i = 0; i < value.length; i++) {\n    string += hexes[value[i]]\n  }\n  const hex = `0x${string}` as const\n\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { dir: 'right', size: opts.size })\n  }\n  return hex\n}\n\nexport type NumberToHexOpts =\n  | {\n      /** Whether or not the number of a signed representation. */\n      signed?: boolean | undefined\n      /** The size (in bytes) of the output hex value. */\n      size: number\n    }\n  | {\n      signed?: undefined\n      /** The size (in bytes) of the output hex value. */\n      size?: number | undefined\n    }\n\nexport type NumberToHexErrorType =\n  | IntegerOutOfRangeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(\n  value_: number | bigint,\n  opts: NumberToHexOpts = {},\n): Hex {\n  const { signed, size } = opts\n\n  const value = BigInt(value_)\n\n  let maxValue: bigint | number | undefined\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value_ === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value > maxValue) || value < minValue) {\n    const suffix = typeof value_ === 'bigint' ? 'n' : ''\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value_}${suffix}`,\n    })\n  }\n\n  const hex = `0x${(\n    signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value\n  ).toString(16)}` as Hex\n  if (size) return pad(hex, { size }) as Hex\n  return hex\n}\n\nexport type StringToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type StringToHexErrorType = BytesToHexErrorType | ErrorType\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_: string, opts: StringToHexOpts = {}): Hex {\n  const value = encoder.encode(value_)\n  return bytesToHex(value, opts)\n}\n","import { keccak_256 } from '@noble/hashes/sha3'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Keccak256Hash<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type Keccak256ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function keccak256<to extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: to | undefined,\n): Keccak256Hash<to> {\n  const to = to_ || 'hex'\n  const bytes = keccak_256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Keccak256Hash<to>\n  return toHex(bytes) as Keccak256Hash<to>\n}\n","import { keccak_256 } from '@noble/hashes/sha3'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Keccak256Hash<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type Keccak256ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function keccak256<to extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: to | undefined,\n): Keccak256Hash<to> {\n  const to = to_ || 'hex'\n  const bytes = keccak_256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Keccak256Hash<to>\n  return toHex(bytes) as Keccak256Hash<to>\n}\n","export const PINO_LOGGER_DEFAULTS = {\n  level: \"info\",\n};\n\nexport const PINO_CUSTOM_CONTEXT_KEY = \"custom_context\";\n\nexport const MAX_LOG_SIZE_IN_BYTES_DEFAULT = 1000 * 1024; // 1MB\n","import { JsonRpcPayload } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\nimport { IKeyChain } from \"./keychain\";\n\nexport declare namespace CryptoTypes {\n  export type EncodingType = \"base64pad\" | \"base64url\";\n\n  export interface Participant {\n    publicKey: string;\n  }\n\n  export interface KeyPair {\n    privateKey: string;\n    publicKey: string;\n  }\n\n  export interface EncryptParams {\n    message: string;\n    symKey: string;\n    type?: number;\n    iv?: string;\n    senderPublicKey?: string;\n    encoding?: EncodingType;\n  }\n\n  export interface DecryptParams {\n    symKey: string;\n    encoded: string;\n    encoding?: EncodingType;\n  }\n\n  export interface EncodingParams {\n    type: Uint8Array;\n    sealed: Uint8Array;\n    iv: Uint8Array;\n    senderPublicKey?: Uint8Array;\n    encoding?: EncodingType;\n  }\n\n  export interface DecodingParams {\n    encoded: string;\n    encoding?: EncodingType;\n  }\n\n  export interface EncodeOptions {\n    type?: number;\n    senderPublicKey?: string;\n    receiverPublicKey?: string;\n    encoding?: EncodingType;\n  }\n\n  export interface DecodeOptions {\n    receiverPublicKey?: string;\n    encoding?: EncodingType;\n  }\n\n  export interface EncodingValidation {\n    type: number;\n    senderPublicKey?: string;\n    receiverPublicKey?: string;\n  }\n\n  export interface TypeOneParams {\n    type: 1;\n    senderPublicKey: string;\n    receiverPublicKey: string;\n  }\n}\n\nexport abstract class ICrypto {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  public abstract keychain: IKeyChain;\n\n  public abstract readonly randomSessionIdentifier: string;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    // @ts-ignore\n    keychain?: IKeyChain,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract hasKeys(tag: string): boolean;\n\n  public abstract getClientId(): Promise<string>;\n\n  public abstract generateKeyPair(): Promise<string>;\n\n  public abstract generateSharedKey(\n    selfPublicKey: string,\n    peerPublicKey: string,\n    overrideTopic?: string,\n  ): Promise<string>;\n\n  public abstract setSymKey(symKey: string, overrideTopic?: string): Promise<string>;\n\n  public abstract deleteKeyPair(publicKey: string): Promise<void>;\n\n  public abstract deleteSymKey(topic: string): Promise<void>;\n\n  public abstract encode(\n    topic: string,\n    payload: JsonRpcPayload,\n    opts?: CryptoTypes.EncodeOptions,\n  ): Promise<string>;\n\n  public abstract decode(\n    topic: string,\n    encoded: string,\n    opts?: CryptoTypes.DecodeOptions,\n  ): Promise<JsonRpcPayload>;\n\n  public abstract signJWT(aud: string): Promise<string>;\n  public abstract getPayloadType(encoded: string, encoding?: CryptoTypes.EncodingType): number;\n  public abstract getPayloadSenderPublicKey(\n    encoded: string,\n    encoding?: CryptoTypes.EncodingType,\n  ): string | undefined;\n}\n","import { JsonRpcPayload } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\nimport { IKeyChain } from \"./keychain\";\n\nexport declare namespace CryptoTypes {\n  export type EncodingType = \"base64pad\" | \"base64url\";\n\n  export interface Participant {\n    publicKey: string;\n  }\n\n  export interface KeyPair {\n    privateKey: string;\n    publicKey: string;\n  }\n\n  export interface EncryptParams {\n    message: string;\n    symKey: string;\n    type?: number;\n    iv?: string;\n    senderPublicKey?: string;\n    encoding?: EncodingType;\n  }\n\n  export interface DecryptParams {\n    symKey: string;\n    encoded: string;\n    encoding?: EncodingType;\n  }\n\n  export interface EncodingParams {\n    type: Uint8Array;\n    sealed: Uint8Array;\n    iv: Uint8Array;\n    senderPublicKey?: Uint8Array;\n    encoding?: EncodingType;\n  }\n\n  export interface DecodingParams {\n    encoded: string;\n    encoding?: EncodingType;\n  }\n\n  export interface EncodeOptions {\n    type?: number;\n    senderPublicKey?: string;\n    receiverPublicKey?: string;\n    encoding?: EncodingType;\n  }\n\n  export interface DecodeOptions {\n    receiverPublicKey?: string;\n    encoding?: EncodingType;\n  }\n\n  export interface EncodingValidation {\n    type: number;\n    senderPublicKey?: string;\n    receiverPublicKey?: string;\n  }\n\n  export interface TypeOneParams {\n    type: 1;\n    senderPublicKey: string;\n    receiverPublicKey: string;\n  }\n}\n\nexport abstract class ICrypto {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  public abstract keychain: IKeyChain;\n\n  public abstract readonly randomSessionIdentifier: string;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    // @ts-ignore\n    keychain?: IKeyChain,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract hasKeys(tag: string): boolean;\n\n  public abstract getClientId(): Promise<string>;\n\n  public abstract generateKeyPair(): Promise<string>;\n\n  public abstract generateSharedKey(\n    selfPublicKey: string,\n    peerPublicKey: string,\n    overrideTopic?: string,\n  ): Promise<string>;\n\n  public abstract setSymKey(symKey: string, overrideTopic?: string): Promise<string>;\n\n  public abstract deleteKeyPair(publicKey: string): Promise<void>;\n\n  public abstract deleteSymKey(topic: string): Promise<void>;\n\n  public abstract encode(\n    topic: string,\n    payload: JsonRpcPayload,\n    opts?: CryptoTypes.EncodeOptions,\n  ): Promise<string>;\n\n  public abstract decode(\n    topic: string,\n    encoded: string,\n    opts?: CryptoTypes.DecodeOptions,\n  ): Promise<JsonRpcPayload>;\n\n  public abstract signJWT(aud: string): Promise<string>;\n  public abstract getPayloadType(encoded: string, encoding?: CryptoTypes.EncodingType): number;\n  public abstract getPayloadSenderPublicKey(\n    encoded: string,\n    encoding?: CryptoTypes.EncodingType,\n  ): string | undefined;\n}\n","class LogListNode {\n  private nodeValue: string;\n  private sizeInBytes: number;\n  public next: LogListNode | null;\n\n  constructor(value: string) {\n    this.nodeValue = value;\n    this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length;\n    this.next = null;\n  }\n\n  public get value() {\n    return this.nodeValue;\n  }\n\n  public get size() {\n    return this.sizeInBytes;\n  }\n}\n\nexport default class LogLinkedList {\n  private lengthInNodes: number;\n  private sizeInBytes: number;\n  private head: LogListNode | null;\n  private tail: LogListNode | null;\n  private maxSizeInBytes: number;\n\n  constructor(maxSizeInBytes: number) {\n    this.head = null;\n    this.tail = null;\n    this.lengthInNodes = 0;\n    this.maxSizeInBytes = maxSizeInBytes;\n    this.sizeInBytes = 0;\n  }\n\n  public append(value: string): void {\n    const newNode = new LogListNode(value);\n\n    if (newNode.size > this.maxSizeInBytes) {\n      throw new Error(\n        `[LinkedList] Value too big to insert into list: ${value} with size ${newNode.size}`,\n      );\n    }\n\n    while (this.size + newNode.size > this.maxSizeInBytes) {\n      this.shift();\n    }\n\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n    } else {\n      if (this.tail) {\n        this.tail.next = newNode;\n      }\n      this.tail = newNode;\n    }\n    this.lengthInNodes++;\n    this.sizeInBytes += newNode.size;\n  }\n\n  public shift(): void {\n    if (!this.head) {\n      return;\n    }\n\n    const removedNode = this.head;\n    this.head = this.head.next;\n\n    if (!this.head) {\n      this.tail = null;\n    }\n\n    this.lengthInNodes--;\n    this.sizeInBytes -= removedNode.size;\n  }\n\n  public toArray(): string[] {\n    const array: string[] = [];\n    let currentNode = this.head;\n    while (currentNode !== null) {\n      array.push(currentNode.value);\n      currentNode = currentNode.next;\n    }\n    return array;\n  }\n\n  public get length() {\n    return this.lengthInNodes;\n  }\n\n  public get size() {\n    return this.sizeInBytes;\n  }\n\n  public toOrderedArray() {\n    return Array.from(this);\n  }\n\n  [Symbol.iterator](): Iterator<string> {\n    let node = this.head;\n\n    const next = (): IteratorResult<string> => {\n      if (!node) {\n        return { done: true, value: null };\n      }\n\n      const value = node.value;\n      node = node.next;\n\n      return { done: false, value };\n    };\n\n    return { next };\n  }\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport type MessageRecord = Record<string, string>;\n\nexport abstract class IMessageTracker {\n  public abstract messages: Map<string, MessageRecord>;\n  public abstract messagesWithoutClientAck: Map<string, MessageRecord>;\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(\n    public logger: Logger,\n    public core: ICore,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(\n    topic: string,\n    message: string,\n    direction?: \"inbound\" | \"outbound\",\n  ): Promise<string>;\n\n  public abstract get(topic: string): MessageRecord;\n\n  public abstract getWithoutAck(topics: string[]): Record<string, string[]>;\n\n  public abstract has(topic: string, message: string): boolean;\n\n  public abstract del(topic: string): Promise<void>;\n\n  public abstract ack(topic: string, message: string): Promise<void>;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport type MessageRecord = Record<string, string>;\n\nexport abstract class IMessageTracker {\n  public abstract messages: Map<string, MessageRecord>;\n  public abstract messagesWithoutClientAck: Map<string, MessageRecord>;\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(\n    public logger: Logger,\n    public core: ICore,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(\n    topic: string,\n    message: string,\n    direction?: \"inbound\" | \"outbound\",\n  ): Promise<string>;\n\n  public abstract get(topic: string): MessageRecord;\n\n  public abstract getWithoutAck(topics: string[]): Record<string, string[]>;\n\n  public abstract has(topic: string, message: string): boolean;\n\n  public abstract del(topic: string): Promise<void>;\n\n  public abstract ack(topic: string, message: string): Promise<void>;\n}\n","import { MAX_LOG_SIZE_IN_BYTES_DEFAULT } from \"./constants\";\nimport type { LoggerOptions } from \"pino\";\nimport BaseChunkLogger from \"./baseChunkLogger\";\n\nexport default class ClientChunkLogger {\n  private baseChunkLogger: BaseChunkLogger;\n\n  public constructor(\n    level: LoggerOptions[\"level\"],\n    MAX_LOG_SIZE_IN_BYTES: number = MAX_LOG_SIZE_IN_BYTES_DEFAULT,\n  ) {\n    this.baseChunkLogger = new BaseChunkLogger(level, MAX_LOG_SIZE_IN_BYTES);\n  }\n\n  public write(chunk: any): void {\n    this.baseChunkLogger.appendToLogs(chunk);\n  }\n\n  public getLogs() {\n    return this.baseChunkLogger.getLogs();\n  }\n\n  public clearLogs() {\n    this.baseChunkLogger.clearLogs();\n  }\n\n  public getLogArray() {\n    return this.baseChunkLogger.getLogArray();\n  }\n\n  public logsToBlob(extraMetadata: Record<string, string>) {\n    return this.baseChunkLogger.logsToBlob(extraMetadata);\n  }\n\n  public downloadLogsBlobInBrowser(extraMetadata: Record<string, string>) {\n    const url = URL.createObjectURL(this.logsToBlob(extraMetadata));\n    const anchor = document.createElement(\"a\");\n    anchor.href = url;\n    anchor.download = `walletconnect-logs-${new Date().toISOString()}.txt`;\n    document.body.appendChild(anchor);\n    anchor.click();\n    document.body.removeChild(anchor);\n    URL.revokeObjectURL(url);\n  }\n}\n","export const HISTORY_EVENTS = {\n  created: \"history_created\",\n  updated: \"history_updated\",\n  deleted: \"history_deleted\",\n  sync: \"history_sync\",\n};\n\nexport const HISTORY_CONTEXT = \"history\";\n\nexport const HISTORY_STORAGE_VERSION = \"0.3\";\n","import { IEvents } from \"@walletconnect/events\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { IRelayer, RelayerTypes } from \"./relayer\";\n\nexport declare namespace PublisherTypes {\n  export interface Params {\n    topic: string;\n    message: string;\n    opts: Omit<RelayerTypes.PublishOptions, \"internal\">;\n  }\n}\n\nexport abstract class IPublisher extends IEvents {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(\n    public relayer: IRelayer,\n    public logger: Logger,\n  ) {\n    super();\n  }\n\n  public abstract publish(\n    topic: string,\n    message: string,\n    opts?: RelayerTypes.PublishOptions,\n  ): Promise<void>;\n\n  public abstract publishCustom(params: {\n    payload: any;\n    opts?: RelayerTypes.PublishOptions;\n  }): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { IRelayer, RelayerTypes } from \"./relayer\";\n\nexport declare namespace PublisherTypes {\n  export interface Params {\n    topic: string;\n    message: string;\n    opts: Omit<RelayerTypes.PublishOptions, \"internal\">;\n  }\n}\n\nexport abstract class IPublisher extends IEvents {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(\n    public relayer: IRelayer,\n    public logger: Logger,\n  ) {\n    super();\n  }\n\n  public abstract publish(\n    topic: string,\n    message: string,\n    opts?: RelayerTypes.PublishOptions,\n  ): Promise<void>;\n\n  public abstract publishCustom(params: {\n    payload: any;\n    opts?: RelayerTypes.PublishOptions;\n  }): Promise<void>;\n}\n","import { MAX_LOG_SIZE_IN_BYTES_DEFAULT } from \"./constants\";\nimport type { DestinationStream, LoggerOptions } from \"pino\";\nimport BaseChunkLogger from \"./baseChunkLogger\";\n\nexport default class ServerChunkLogger implements DestinationStream {\n  private baseChunkLogger: BaseChunkLogger;\n\n  public constructor(\n    level: LoggerOptions[\"level\"],\n    MAX_LOG_SIZE_IN_BYTES: number = MAX_LOG_SIZE_IN_BYTES_DEFAULT,\n  ) {\n    this.baseChunkLogger = new BaseChunkLogger(level, MAX_LOG_SIZE_IN_BYTES);\n  }\n\n  public write(chunk: any): void {\n    this.baseChunkLogger.appendToLogs(chunk);\n  }\n\n  public getLogs() {\n    return this.baseChunkLogger.getLogs();\n  }\n\n  public clearLogs() {\n    this.baseChunkLogger.clearLogs();\n  }\n\n  public getLogArray() {\n    return this.baseChunkLogger.getLogArray();\n  }\n\n  public logsToBlob(extraMetadata: Record<string, string>) {\n    return this.baseChunkLogger.logsToBlob(extraMetadata);\n  }\n}\n","function isPrimitive(value) {\n    return value == null || (typeof value !== 'object' && typeof value !== 'function');\n}\n\nexport { isPrimitive };\n","import { IEvents } from \"@walletconnect/events\";\nimport { IJsonRpcProvider, JsonRpcPayload, RequestArguments } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { ICore } from \"./core\";\nimport { IMessageTracker } from \"./messages\";\nimport { IPublisher } from \"./publisher\";\nimport { ISubscriber } from \"./subscriber\";\n\nexport declare namespace RelayerTypes {\n  export interface ProtocolOptions {\n    protocol: string;\n    data?: string;\n  }\n  export interface PublishOptions {\n    relay?: ProtocolOptions;\n    ttl?: number;\n    prompt?: boolean;\n    tag?: number;\n    id?: number;\n    internal?: {\n      throwOnFailedPublish?: boolean;\n    };\n    tvf?: ITVF;\n    attestation?: string;\n    publishMethod?: string;\n  }\n\n  export type TransportType = \"relay\" | \"link_mode\";\n\n  export interface SubscribeOptions {\n    relay?: ProtocolOptions;\n    transportType?: TransportType;\n    internal?: {\n      throwOnFailedPublish?: boolean;\n      skipSubscribe?: boolean;\n    };\n  }\n\n  export interface UnsubscribeOptions {\n    id?: string;\n    relay: ProtocolOptions;\n  }\n\n  export type RequestOptions = PublishOptions | SubscribeOptions | UnsubscribeOptions;\n\n  export interface PublishPayload {\n    topic: string;\n    message: string;\n    opts?: RelayerTypes.PublishOptions;\n  }\n  export interface MessageEvent {\n    topic: string;\n    message: string;\n    publishedAt: number;\n    transportType?: TransportType;\n    attestation?: string;\n  }\n\n  export interface RpcUrlParams {\n    protocol: string;\n    version: number;\n    auth: string;\n    relayUrl: string;\n    sdkVersion: string;\n    projectId?: string;\n    useOnCloseEvent?: boolean;\n    bundleId?: string;\n    packageName?: string;\n  }\n\n  export interface ITVF {\n    correlationId?: number;\n    rpcMethods?: string[];\n    chainId?: string;\n    txHashes?: string[];\n    contractAddresses?: string[];\n  }\n\n  export type MessageDirection = \"inbound\" | \"outbound\";\n}\n\nexport interface RelayerOptions {\n  core: ICore;\n  logger?: string | Logger;\n  relayUrl?: string;\n  projectId?: string;\n}\n\nexport interface RelayerClientMetadata {\n  protocol: string;\n  version: number;\n  env: string;\n  host?: string;\n}\n\nexport abstract class IRelayer extends IEvents {\n  public abstract protocol: string;\n\n  public abstract version: number;\n\n  public abstract core: ICore;\n\n  public abstract logger: Logger;\n\n  public abstract subscriber: ISubscriber;\n\n  public abstract publisher: IPublisher;\n\n  public abstract messages: IMessageTracker;\n\n  public abstract provider: IJsonRpcProvider;\n\n  public abstract name: string;\n\n  public abstract transportExplicitlyClosed: boolean;\n\n  public abstract readonly context: string;\n\n  public abstract readonly connected: boolean;\n\n  public abstract readonly connecting: boolean;\n\n  constructor(\n    // @ts-ignore\n    opts: RelayerOptions,\n  ) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract publish(\n    topic: string,\n    message: string,\n    opts?: RelayerTypes.PublishOptions,\n  ): Promise<void>;\n\n  public abstract publishCustom(params: {\n    payload: any;\n    opts?: RelayerTypes.PublishOptions;\n  }): Promise<void>;\n\n  public abstract request(request: RequestArguments): Promise<JsonRpcPayload>;\n\n  public abstract subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions): Promise<string>;\n\n  public abstract unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions): Promise<void>;\n  public abstract transportClose(): Promise<void>;\n  public abstract transportOpen(relayUrl?: string): Promise<void>;\n  public abstract restartTransport(relayUrl?: string): Promise<void>;\n  public abstract confirmOnlineStateOrThrow(): Promise<void>;\n  public abstract handleBatchMessageEvents(messages: RelayerTypes.MessageEvent[]): Promise<void>;\n  public abstract onLinkMessageEvent(\n    messageEvent: RelayerTypes.MessageEvent,\n    opts?: { sessionExists?: boolean },\n  ): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { IJsonRpcProvider, JsonRpcPayload, RequestArguments } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { ICore } from \"./core\";\nimport { IMessageTracker } from \"./messages\";\nimport { IPublisher } from \"./publisher\";\nimport { ISubscriber } from \"./subscriber\";\n\nexport declare namespace RelayerTypes {\n  export interface ProtocolOptions {\n    protocol: string;\n    data?: string;\n  }\n  export interface PublishOptions {\n    relay?: ProtocolOptions;\n    ttl?: number;\n    prompt?: boolean;\n    tag?: number;\n    id?: number;\n    internal?: {\n      throwOnFailedPublish?: boolean;\n    };\n    tvf?: ITVF;\n    attestation?: string;\n    publishMethod?: string;\n  }\n\n  export type TransportType = \"relay\" | \"link_mode\";\n\n  export interface SubscribeOptions {\n    relay?: ProtocolOptions;\n    transportType?: TransportType;\n    internal?: {\n      throwOnFailedPublish?: boolean;\n      skipSubscribe?: boolean;\n    };\n  }\n\n  export interface UnsubscribeOptions {\n    id?: string;\n    relay: ProtocolOptions;\n  }\n\n  export type RequestOptions = PublishOptions | SubscribeOptions | UnsubscribeOptions;\n\n  export interface PublishPayload {\n    topic: string;\n    message: string;\n    opts?: RelayerTypes.PublishOptions;\n  }\n  export interface MessageEvent {\n    topic: string;\n    message: string;\n    publishedAt: number;\n    transportType?: TransportType;\n    attestation?: string;\n  }\n\n  export interface RpcUrlParams {\n    protocol: string;\n    version: number;\n    auth: string;\n    relayUrl: string;\n    sdkVersion: string;\n    projectId?: string;\n    useOnCloseEvent?: boolean;\n    bundleId?: string;\n    packageName?: string;\n  }\n\n  export interface ITVF {\n    correlationId?: number;\n    rpcMethods?: string[];\n    chainId?: string;\n    txHashes?: string[];\n    contractAddresses?: string[];\n  }\n\n  export type MessageDirection = \"inbound\" | \"outbound\";\n}\n\nexport interface RelayerOptions {\n  core: ICore;\n  logger?: string | Logger;\n  relayUrl?: string;\n  projectId?: string;\n}\n\nexport interface RelayerClientMetadata {\n  protocol: string;\n  version: number;\n  env: string;\n  host?: string;\n}\n\nexport abstract class IRelayer extends IEvents {\n  public abstract protocol: string;\n\n  public abstract version: number;\n\n  public abstract core: ICore;\n\n  public abstract logger: Logger;\n\n  public abstract subscriber: ISubscriber;\n\n  public abstract publisher: IPublisher;\n\n  public abstract messages: IMessageTracker;\n\n  public abstract provider: IJsonRpcProvider;\n\n  public abstract name: string;\n\n  public abstract transportExplicitlyClosed: boolean;\n\n  public abstract readonly context: string;\n\n  public abstract readonly connected: boolean;\n\n  public abstract readonly connecting: boolean;\n\n  constructor(\n    // @ts-ignore\n    opts: RelayerOptions,\n  ) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract publish(\n    topic: string,\n    message: string,\n    opts?: RelayerTypes.PublishOptions,\n  ): Promise<void>;\n\n  public abstract publishCustom(params: {\n    payload: any;\n    opts?: RelayerTypes.PublishOptions;\n  }): Promise<void>;\n\n  public abstract request(request: RequestArguments): Promise<JsonRpcPayload>;\n\n  public abstract subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions): Promise<string>;\n\n  public abstract unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions): Promise<void>;\n  public abstract transportClose(): Promise<void>;\n  public abstract transportOpen(relayUrl?: string): Promise<void>;\n  public abstract restartTransport(relayUrl?: string): Promise<void>;\n  public abstract confirmOnlineStateOrThrow(): Promise<void>;\n  public abstract handleBatchMessageEvents(messages: RelayerTypes.MessageEvent[]): Promise<void>;\n  public abstract onLinkMessageEvent(\n    messageEvent: RelayerTypes.MessageEvent,\n    opts?: { sessionExists?: boolean },\n  ): Promise<void>;\n}\n","import { SessionTypes, ProposalTypes } from \"@walletconnect/types\";\n\ninterface ChainIdParams {\n  namespace: string;\n  reference: string;\n}\n\ninterface AccountIdParams extends ChainIdParams {\n  address: string;\n}\n\nconst CAIP_DELIMITER = \":\";\n\nexport function parseChainId(chain: string): ChainIdParams {\n  const [namespace, reference] = chain.split(CAIP_DELIMITER);\n  return { namespace, reference };\n}\n\nexport function formatChainId(params: ChainIdParams): string {\n  const { namespace, reference } = params;\n  return [namespace, reference].join(CAIP_DELIMITER);\n}\n\nexport function parseAccountId(account: string): AccountIdParams {\n  const [namespace, reference, address] = account.split(CAIP_DELIMITER);\n  return { namespace, reference, address };\n}\n\nexport function formatAccountId(params: AccountIdParams): string {\n  const { namespace, reference, address } = params;\n  return [namespace, reference, address].join(CAIP_DELIMITER);\n}\n\nexport function getUniqueValues(array: string[], parser: (str: string) => string): string[] {\n  const unique: string[] = [];\n  array.forEach((str) => {\n    const value = parser(str);\n    if (!unique.includes(value)) unique.push(value);\n  });\n  return unique;\n}\n\nexport function getAddressFromAccount(account: string) {\n  const { address } = parseAccountId(account);\n  return address;\n}\n\nexport function getChainFromAccount(account: string) {\n  const { namespace, reference } = parseAccountId(account);\n  const chain = formatChainId({ namespace, reference });\n  return chain;\n}\n\nexport function formatAccountWithChain(address: string, chain: string) {\n  const { namespace, reference } = parseChainId(chain);\n  const account = formatAccountId({ namespace, reference, address });\n  return account;\n}\n\nexport function getAddressesFromAccounts(accounts: string[]) {\n  return getUniqueValues(accounts, getAddressFromAccount);\n}\n\nexport function getChainsFromAccounts(accounts: string[]) {\n  return getUniqueValues(accounts, getChainFromAccount);\n}\n\nexport function getAccountsFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  keys: string[] = [],\n): string[] {\n  const accounts: string[] = [];\n  Object.keys(namespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = namespaces[key];\n    accounts.push(...ns.accounts);\n  });\n  return accounts;\n}\n\nexport function getChainsFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  keys: string[] = [],\n): string[] {\n  const chains: string[] = [];\n  Object.keys(namespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = namespaces[key];\n    chains.push(...getChainsFromAccounts(ns.accounts));\n  });\n  return chains;\n}\n\nexport function getChainsFromRequiredNamespaces(\n  requiredNamespaces: ProposalTypes.RequiredNamespaces,\n  keys: string[] = [],\n): string[] {\n  const chains: string[] = [];\n  Object.keys(requiredNamespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = requiredNamespaces[key];\n    chains.push(...getChainsFromNamespace(key, ns));\n  });\n  return chains;\n}\n\nexport function getChainsFromNamespace(\n  namespace: string,\n  namespaceProps: ProposalTypes.BaseRequiredNamespace,\n) {\n  // check if chainId is provided in the key as `eip155:1` or in the namespace as chains[]\n  return namespace.includes(\":\") ? [namespace] : namespaceProps.chains || [];\n}\n","import { SessionTypes, ProposalTypes } from \"@walletconnect/types\";\n\ninterface ChainIdParams {\n  namespace: string;\n  reference: string;\n}\n\ninterface AccountIdParams extends ChainIdParams {\n  address: string;\n}\n\nconst CAIP_DELIMITER = \":\";\n\nexport function parseChainId(chain: string): ChainIdParams {\n  const [namespace, reference] = chain.split(CAIP_DELIMITER);\n  return { namespace, reference };\n}\n\nexport function formatChainId(params: ChainIdParams): string {\n  const { namespace, reference } = params;\n  return [namespace, reference].join(CAIP_DELIMITER);\n}\n\nexport function parseAccountId(account: string): AccountIdParams {\n  const [namespace, reference, address] = account.split(CAIP_DELIMITER);\n  return { namespace, reference, address };\n}\n\nexport function formatAccountId(params: AccountIdParams): string {\n  const { namespace, reference, address } = params;\n  return [namespace, reference, address].join(CAIP_DELIMITER);\n}\n\nexport function getUniqueValues(array: string[], parser: (str: string) => string): string[] {\n  const unique: string[] = [];\n  array.forEach((str) => {\n    const value = parser(str);\n    if (!unique.includes(value)) unique.push(value);\n  });\n  return unique;\n}\n\nexport function getAddressFromAccount(account: string) {\n  const { address } = parseAccountId(account);\n  return address;\n}\n\nexport function getChainFromAccount(account: string) {\n  const { namespace, reference } = parseAccountId(account);\n  const chain = formatChainId({ namespace, reference });\n  return chain;\n}\n\nexport function formatAccountWithChain(address: string, chain: string) {\n  const { namespace, reference } = parseChainId(chain);\n  const account = formatAccountId({ namespace, reference, address });\n  return account;\n}\n\nexport function getAddressesFromAccounts(accounts: string[]) {\n  return getUniqueValues(accounts, getAddressFromAccount);\n}\n\nexport function getChainsFromAccounts(accounts: string[]) {\n  return getUniqueValues(accounts, getChainFromAccount);\n}\n\nexport function getAccountsFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  keys: string[] = [],\n): string[] {\n  const accounts: string[] = [];\n  Object.keys(namespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = namespaces[key];\n    accounts.push(...ns.accounts);\n  });\n  return accounts;\n}\n\nexport function getChainsFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  keys: string[] = [],\n): string[] {\n  const chains: string[] = [];\n  Object.keys(namespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = namespaces[key];\n    chains.push(...getChainsFromAccounts(ns.accounts));\n  });\n  return chains;\n}\n\nexport function getChainsFromRequiredNamespaces(\n  requiredNamespaces: ProposalTypes.RequiredNamespaces,\n  keys: string[] = [],\n): string[] {\n  const chains: string[] = [];\n  Object.keys(requiredNamespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = requiredNamespaces[key];\n    chains.push(...getChainsFromNamespace(key, ns));\n  });\n  return chains;\n}\n\nexport function getChainsFromNamespace(\n  namespace: string,\n  namespaceProps: ProposalTypes.BaseRequiredNamespace,\n) {\n  // check if chainId is provided in the key as `eip155:1` or in the namespace as chains[]\n  return namespace.includes(\":\") ? [namespace] : namespaceProps.chains || [];\n}\n","/**\n * Map with a LRU (Least recently used) policy.\n *\n * @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nexport class LruMap<value = unknown> extends Map<string, value> {\n  maxSize: number\n\n  constructor(size: number) {\n    super()\n    this.maxSize = size\n  }\n\n  override get(key: string) {\n    const value = super.get(key)\n\n    if (super.has(key) && value !== undefined) {\n      this.delete(key)\n      super.set(key, value)\n    }\n\n    return value\n  }\n\n  override set(key: string, value: value) {\n    super.set(key, value)\n    if (this.maxSize && this.size > this.maxSize) {\n      const firstKey = this.keys().next().value\n      if (firstKey) this.delete(firstKey)\n    }\n    return this\n  }\n}\n","import pino, { Logger, LoggerOptions } from \"pino\";\nimport { PINO_CUSTOM_CONTEXT_KEY, PINO_LOGGER_DEFAULTS } from \"./constants\";\nimport ClientChunkLogger from \"./clientChunkLogger\";\nimport ServerChunkLogger from \"./serverChunkLogger\";\nimport BaseChunkLogger from \"./baseChunkLogger\";\n\nexport interface ChunkLoggerController {\n  logsToBlob: BaseChunkLogger[\"logsToBlob\"];\n  getLogArray: () => string[];\n  clearLogs: () => void;\n  downloadLogsBlobInBrowser?: ClientChunkLogger[\"downloadLogsBlobInBrowser\"];\n}\n\nexport function getDefaultLoggerOptions(opts?: LoggerOptions): LoggerOptions {\n  return {\n    ...opts,\n    level: opts?.level || PINO_LOGGER_DEFAULTS.level,\n  };\n}\n\nexport function getBrowserLoggerContext(\n  logger: Logger,\n  customContextKey: string = PINO_CUSTOM_CONTEXT_KEY,\n): string {\n  return (logger as any)[customContextKey] || \"\";\n}\n\nexport function setBrowserLoggerContext(\n  logger: Logger,\n  context: string,\n  customContextKey: string = PINO_CUSTOM_CONTEXT_KEY,\n): Logger {\n  (logger as any)[customContextKey] = context;\n  return logger;\n}\n\nexport function getLoggerContext(\n  logger: Logger,\n  customContextKey: string = PINO_CUSTOM_CONTEXT_KEY,\n): string {\n  let context = \"\";\n  // logger.bindings is undefined in browser\n  if (typeof logger.bindings === \"undefined\") {\n    context = getBrowserLoggerContext(logger, customContextKey);\n  } else {\n    context = logger.bindings().context || \"\";\n  }\n  return context;\n}\n\nexport function formatChildLoggerContext(\n  logger: Logger,\n  childContext: string,\n  customContextKey: string = PINO_CUSTOM_CONTEXT_KEY,\n): string {\n  const parentContext = getLoggerContext(logger, customContextKey);\n  const context = parentContext.trim() ? `${parentContext}/${childContext}` : childContext;\n  return context;\n}\n\nexport function generateChildLogger(\n  logger: Logger,\n  childContext: string,\n  customContextKey: string = PINO_CUSTOM_CONTEXT_KEY,\n): Logger {\n  const context = formatChildLoggerContext(logger, childContext, customContextKey);\n  const child = logger.child({ context });\n  return setBrowserLoggerContext(child, context, customContextKey);\n}\n\nexport function generateClientLogger(params: { opts?: LoggerOptions; maxSizeInBytes?: number }): {\n  logger: Logger<any>;\n  chunkLoggerController: ClientChunkLogger;\n} {\n  const clientLogger = new ClientChunkLogger(params.opts?.level, params.maxSizeInBytes);\n  const logger = pino({\n    ...params.opts,\n    level: \"trace\",\n    browser: {\n      ...params.opts?.browser,\n      write: (obj) => clientLogger.write(obj),\n    },\n  });\n\n  return { logger, chunkLoggerController: clientLogger };\n}\n\nexport function generateServerLogger(params: { maxSizeInBytes?: number; opts?: LoggerOptions }): {\n  logger: Logger<any>;\n  chunkLoggerController: ServerChunkLogger;\n} {\n  const serverLogger = new ServerChunkLogger(params.opts?.level, params.maxSizeInBytes);\n  const logger = pino(\n    {\n      ...params.opts,\n      level: \"trace\",\n    },\n    serverLogger,\n  );\n\n  return { logger, chunkLoggerController: serverLogger };\n}\n\nexport function generatePlatformLogger(params: {\n  maxSizeInBytes?: number;\n  opts?: LoggerOptions;\n  loggerOverride?: string | Logger<any>;\n}): {\n  logger: Logger<any>;\n  chunkLoggerController: ChunkLoggerController | null;\n} {\n  if (typeof params.loggerOverride !== \"undefined\" && typeof params.loggerOverride !== \"string\") {\n    return {\n      logger: params.loggerOverride,\n      chunkLoggerController: null,\n    };\n  }\n\n  if (typeof window !== \"undefined\") {\n    return generateClientLogger(params);\n  } else {\n    return generateServerLogger(params);\n  }\n}\n","/**\n * Map with a LRU (Least recently used) policy.\n *\n * @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nexport class LruMap<value = unknown> extends Map<string, value> {\n  maxSize: number\n\n  constructor(size: number) {\n    super()\n    this.maxSize = size\n  }\n\n  override get(key: string) {\n    const value = super.get(key)\n\n    if (super.has(key) && value !== undefined) {\n      this.delete(key)\n      super.set(key, value)\n    }\n\n    return value\n  }\n\n  override set(key: string, value: value) {\n    super.set(key, value)\n    if (this.maxSize && this.size > this.maxSize) {\n      const firstKey = this.keys().next().value\n      if (firstKey) this.delete(firstKey)\n    }\n    return this\n  }\n}\n","import { SEVEN_DAYS } from \"@walletconnect/time\";\n\nexport const SESSION_CONTEXT = \"session\";\n\nexport const SESSION_EXPIRY = SEVEN_DAYS;\n","import { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport abstract class IStore<Key, Value> {\n  public abstract map: Map<Key, Value>;\n\n  public abstract readonly context: string;\n\n  public abstract readonly length: number;\n\n  public abstract readonly keys: Key[];\n\n  public abstract readonly values: Value[];\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public name: string,\n    // @ts-ignore\n    storagePrefix?: string,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(key: Key, value: Value): Promise<void>;\n\n  public abstract get(key: Key): Value;\n\n  public abstract getAll(filter?: Partial<Value>): Value[];\n\n  public abstract update(key: Key, update: Partial<Value>): Promise<void>;\n\n  public abstract delete(key: Key, reason: ErrorResponse): Promise<void>;\n}\n","import { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport abstract class IStore<Key, Value> {\n  public abstract map: Map<Key, Value>;\n\n  public abstract readonly context: string;\n\n  public abstract readonly length: number;\n\n  public abstract readonly keys: Key[];\n\n  public abstract readonly values: Value[];\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public name: string,\n    // @ts-ignore\n    storagePrefix?: string,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(key: Key, value: Value): Promise<void>;\n\n  public abstract get(key: Key): Value;\n\n  public abstract getAll(filter?: Partial<Value>): Value[];\n\n  public abstract update(key: Key, update: Partial<Value>): Promise<void>;\n\n  public abstract delete(key: Key, reason: ErrorResponse): Promise<void>;\n}\n","import { FIVE_MINUTES, ONE_DAY, ONE_HOUR, SEVEN_DAYS } from \"@walletconnect/time\";\nimport { EngineTypes } from \"@walletconnect/types\";\n\nexport const ENGINE_CONTEXT = \"engine\";\n\nexport const ENGINE_RPC_OPTS: EngineTypes.RpcOptsMap = {\n  wc_sessionPropose: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1100,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1101,\n    },\n    reject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1120,\n    },\n    autoReject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1121,\n    },\n  },\n  wc_sessionSettle: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1102,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1103,\n    },\n  },\n  wc_sessionUpdate: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1104,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1105,\n    },\n  },\n  wc_sessionExtend: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1106,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1107,\n    },\n  },\n  wc_sessionRequest: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1108,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1109,\n    },\n  },\n  wc_sessionEvent: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1110,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1111,\n    },\n  },\n\n  wc_sessionDelete: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1112,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1113,\n    },\n  },\n  wc_sessionPing: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1114,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1115,\n    },\n  },\n  wc_sessionAuthenticate: {\n    req: {\n      ttl: ONE_HOUR,\n      prompt: true,\n      tag: 1116,\n    },\n    res: {\n      ttl: ONE_HOUR,\n      prompt: false,\n      tag: 1117,\n    },\n    reject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1118,\n    },\n    autoReject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1119,\n    },\n  },\n};\n\nexport const SESSION_REQUEST_EXPIRY_BOUNDARIES = {\n  min: FIVE_MINUTES,\n  max: SEVEN_DAYS,\n};\n\nexport const ENGINE_QUEUE_STATES: { idle: \"IDLE\"; active: \"ACTIVE\" } = {\n  idle: \"IDLE\",\n  active: \"ACTIVE\",\n};\n\nexport const TVF_METHODS = {\n  // evm\n  eth_sendTransaction: {\n    key: \"\",\n  },\n  eth_sendRawTransaction: {\n    key: \"\",\n  },\n  wallet_sendCalls: {\n    key: \"\",\n  },\n\n  // solana\n  solana_signTransaction: {\n    key: \"signature\",\n  },\n  solana_signAllTransactions: {\n    key: \"transactions\",\n  },\n  solana_signAndSendTransaction: {\n    key: \"signature\",\n  },\n\n  // sui\n  sui_signAndExecuteTransaction: {\n    key: \"digest\",\n  },\n  sui_signTransaction: {\n    key: \"\",\n  },\n\n  // hedera\n  hedera_signAndExecuteTransaction: {\n    key: \"transactionId\",\n  },\n  hedera_executeTransaction: {\n    key: \"transactionId\",\n  },\n\n  // near\n  near_signTransaction: {\n    key: \"\",\n  },\n  near_signTransactions: {\n    key: \"\",\n  },\n\n  // tron\n  tron_signTransaction: {\n    key: \"txID\",\n  },\n\n  // xrpl\n  xrpl_signTransaction: {\n    key: \"\",\n  },\n\n  xrpl_signTransactionFor: {\n    key: \"\",\n  },\n\n  // algorand\n  algo_signTxn: {\n    key: \"\",\n  },\n\n  // bitcoin\n  sendTransfer: {\n    key: \"txid\",\n  },\n\n  // stacks\n  stacks_stxTransfer: {\n    key: \"txId\",\n  },\n\n  // polkadot\n  polkadot_signTransaction: {\n    key: \"\",\n  },\n\n  // cosmos\n  cosmos_signDirect: {\n    key: \"\",\n  },\n};\n","function getSymbols(object) {\n    return Object.getOwnPropertySymbols(object).filter(symbol => Object.prototype.propertyIsEnumerable.call(object, symbol));\n}\n\nexport { getSymbols };\n","import { ONE_DAY } from \"@walletconnect/time\";\n\nexport const CRYPTO_CONTEXT = \"crypto\";\n\nexport const CRYPTO_CLIENT_SEED = \"client_ed25519_seed\";\n\nexport const CRYPTO_JWT_TTL = ONE_DAY;\n","import { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport abstract class IKeyChain {\n  public abstract keychain: Map<string, string>;\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract has(tag: string, opts?: any): boolean;\n\n  public abstract set(tag: string, key: string, opts?: any): Promise<void>;\n\n  public abstract get(tag: string, opts?: any): string;\n\n  public abstract del(tag: string, opts?: any): Promise<void>;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport abstract class IKeyChain {\n  public abstract keychain: Map<string, string>;\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract has(tag: string, opts?: any): boolean;\n\n  public abstract set(tag: string, key: string, opts?: any): Promise<void>;\n\n  public abstract get(tag: string, opts?: any): string;\n\n  public abstract del(tag: string, opts?: any): Promise<void>;\n}\n","export const METHODS_TO_VERIFY = [\n  \"wc_sessionPropose\",\n  \"wc_sessionRequest\",\n  \"wc_authRequest\",\n  \"wc_sessionAuthenticate\",\n];\n","import { IEvents } from \"@walletconnect/events\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { ICore } from \"./core\";\n\nexport declare namespace ExpirerTypes {\n  interface Expiration {\n    target: string;\n    expiry: number;\n  }\n\n  interface Created {\n    target: string;\n    expiration: Expiration;\n  }\n\n  interface Deleted {\n    target: string;\n    expiration: Expiration;\n  }\n\n  interface Expired {\n    target: string;\n    expiration: Expiration;\n  }\n}\n\nexport abstract class IExpirer extends IEvents {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  public abstract readonly length: number;\n\n  public abstract readonly keys: string[];\n\n  public abstract readonly values: ExpirerTypes.Expiration[];\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract has(key: string | number): boolean;\n\n  public abstract set(key: string | number, expiry: number): void;\n\n  public abstract get(key: string | number): ExpirerTypes.Expiration;\n\n  public abstract del(key: string | number): void;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { ICore } from \"./core\";\n\nexport declare namespace ExpirerTypes {\n  interface Expiration {\n    target: string;\n    expiry: number;\n  }\n\n  interface Created {\n    target: string;\n    expiration: Expiration;\n  }\n\n  interface Deleted {\n    target: string;\n    expiration: Expiration;\n  }\n\n  interface Expired {\n    target: string;\n    expiration: Expiration;\n  }\n}\n\nexport abstract class IExpirer extends IEvents {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  public abstract readonly length: number;\n\n  public abstract readonly keys: string[];\n\n  public abstract readonly values: ExpirerTypes.Expiration[];\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract has(key: string | number): boolean;\n\n  public abstract set(key: string | number, expiry: number): void;\n\n  public abstract get(key: string | number): ExpirerTypes.Expiration;\n\n  public abstract del(key: string | number): void;\n}\n","export const AUTH_PROTOCOL = \"wc\";\nexport const AUTH_VERSION = 1.5;\nexport const AUTH_CONTEXT = \"auth\";\nexport const AUTH_KEYS_CONTEXT = \"authKeys\";\nexport const AUTH_PAIRING_TOPIC_CONTEXT = \"pairingTopics\";\nexport const AUTH_REQUEST_CONTEXT = \"requests\";\n\nexport const AUTH_STORAGE_PREFIX = `${AUTH_PROTOCOL}@${AUTH_VERSION}:${AUTH_CONTEXT}:`;\nexport const AUTH_PUBLIC_KEY_NAME = `${AUTH_STORAGE_PREFIX}:PUB_KEY`;\n","/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","export const MESSAGES_CONTEXT = \"messages\";\n\nexport const MESSAGES_STORAGE_VERSION = \"0.3\";\n","function getTag(value) {\n    if (value == null) {\n        return value === undefined ? '[object Undefined]' : '[object Null]';\n    }\n    return Object.prototype.toString.call(value);\n}\n\nexport { getTag };\n","import {\n  ErrorResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  JsonRpcResult,\n  JsonRpcError,\n} from \"@walletconnect/jsonrpc-types\";\nimport EventEmitter from \"events\";\n\nimport { ICore, CoreTypes } from \"./core\";\nimport { IStore } from \"./store\";\n\nimport { RelayerTypes } from \"../core/relayer\";\nimport { Logger } from \"@walletconnect/logger\";\n\nexport declare namespace PairingTypes {\n  interface Struct {\n    topic: string;\n    expiry: number;\n    relay: RelayerTypes.ProtocolOptions;\n    active: boolean;\n    peerMetadata?: CoreTypes.Metadata;\n    methods?: string[];\n  }\n}\n\nexport declare namespace PairingJsonRpcTypes {\n  // -- core ------------------------------------------------------- //\n  type DefaultResponse = true | ErrorResponse;\n\n  type WcMethod = \"wc_pairingDelete\" | \"wc_pairingPing\";\n\n  type Error = ErrorResponse;\n\n  // -- requests --------------------------------------------------- //\n\n  interface RequestParams {\n    wc_pairingDelete: {\n      code: number;\n      message: string;\n    };\n    wc_pairingPing: Record<string, unknown>;\n  }\n\n  // -- responses -------------------------------------------------- //\n  interface Results {\n    wc_pairingDelete: true;\n    wc_pairingPing: true;\n  }\n\n  // -- events ----------------------------------------------------- //\n  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {\n    topic: string;\n    payload: T;\n  }\n}\n\nexport type IPairingStore = IStore<string, PairingTypes.Struct>;\n\nexport abstract class IPairing {\n  public abstract name: string;\n  public abstract readonly context: string;\n  public abstract events: EventEmitter;\n  public abstract pairings: IPairingStore;\n\n  constructor(\n    public logger: Logger,\n    public core: ICore,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract pair(params: {\n    uri: string;\n    activatePairing?: boolean;\n  }): Promise<PairingTypes.Struct>;\n\n  // for proposer to create inactive pairing\n  public abstract create(params?: {\n    methods?: string[];\n    transportType?: RelayerTypes.SubscribeOptions[\"transportType\"];\n    internal?: RelayerTypes.SubscribeOptions[\"internal\"];\n  }): Promise<{ topic: string; uri: string }>;\n\n  // for either to activate a previously created pairing\n  public abstract activate(params: { topic: string }): Promise<void>;\n\n  // for both to subscribe on methods requests\n  public abstract register(params: { methods: string[] }): void;\n\n  // for either to update the expiry of an existing pairing.\n  public abstract updateExpiry(params: { topic: string; expiry: number }): Promise<void>;\n\n  // for either to update the metadata of an existing pairing.\n  public abstract updateMetadata(params: {\n    topic: string;\n    metadata: CoreTypes.Metadata;\n  }): Promise<void>;\n\n  // query pairings\n  public abstract getPairings(): PairingTypes.Struct[];\n\n  // for either to ping a peer\n  public abstract ping(params: { topic: string }): Promise<void>;\n\n  // for either peer to disconnect a pairing\n  public abstract disconnect(params: { topic: string }): Promise<void>;\n\n  public abstract formatUriFromPairing(pairing: PairingTypes.Struct): string;\n}\n\nexport interface IPairingPrivate {\n  sendRequest<M extends PairingJsonRpcTypes.WcMethod>(\n    topic: string,\n    method: M,\n    params: PairingJsonRpcTypes.RequestParams[M],\n  ): Promise<number>;\n\n  sendResult<M extends PairingJsonRpcTypes.WcMethod>(\n    id: number,\n    topic: string,\n    result: PairingJsonRpcTypes.Results[M],\n  ): Promise<void>;\n\n  sendError(id: number, topic: string, error: PairingJsonRpcTypes.Error): Promise<void>;\n\n  onRelayEventRequest(event: PairingJsonRpcTypes.EventCallback<JsonRpcRequest>): Promise<void>;\n\n  onRelayEventResponse(event: PairingJsonRpcTypes.EventCallback<JsonRpcResponse>): Promise<void>;\n\n  onPairingPingRequest(\n    topic: string,\n    payload: JsonRpcRequest<PairingJsonRpcTypes.RequestParams[\"wc_pairingPing\"]>,\n  ): Promise<void>;\n\n  onPairingPingResponse(\n    topic: string,\n    payload: JsonRpcResult<PairingJsonRpcTypes.Results[\"wc_pairingPing\"]> | JsonRpcError,\n  ): void;\n\n  onPairingDeleteRequest(\n    topic: string,\n    payload: JsonRpcRequest<PairingJsonRpcTypes.RequestParams[\"wc_pairingDelete\"]>,\n  ): Promise<void>;\n\n  onUnknownRpcMethodRequest(topic: string, payload: JsonRpcRequest): Promise<void>;\n\n  onUnknownRpcMethodResponse(method: string): void;\n\n  deletePairing(topic: string, expirerHasDeleted?: boolean): Promise<void>;\n}\n","import {\n  ErrorResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  JsonRpcResult,\n  JsonRpcError,\n} from \"@walletconnect/jsonrpc-types\";\nimport EventEmitter from \"events\";\n\nimport { ICore, CoreTypes } from \"./core\";\nimport { IStore } from \"./store\";\n\nimport { RelayerTypes } from \"../core/relayer\";\nimport { Logger } from \"@walletconnect/logger\";\n\nexport declare namespace PairingTypes {\n  interface Struct {\n    topic: string;\n    expiry: number;\n    relay: RelayerTypes.ProtocolOptions;\n    active: boolean;\n    peerMetadata?: CoreTypes.Metadata;\n    methods?: string[];\n  }\n}\n\nexport declare namespace PairingJsonRpcTypes {\n  // -- core ------------------------------------------------------- //\n  type DefaultResponse = true | ErrorResponse;\n\n  type WcMethod = \"wc_pairingDelete\" | \"wc_pairingPing\";\n\n  type Error = ErrorResponse;\n\n  // -- requests --------------------------------------------------- //\n\n  interface RequestParams {\n    wc_pairingDelete: {\n      code: number;\n      message: string;\n    };\n    wc_pairingPing: Record<string, unknown>;\n  }\n\n  // -- responses -------------------------------------------------- //\n  interface Results {\n    wc_pairingDelete: true;\n    wc_pairingPing: true;\n  }\n\n  // -- events ----------------------------------------------------- //\n  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {\n    topic: string;\n    payload: T;\n  }\n}\n\nexport type IPairingStore = IStore<string, PairingTypes.Struct>;\n\nexport abstract class IPairing {\n  public abstract name: string;\n  public abstract readonly context: string;\n  public abstract events: EventEmitter;\n  public abstract pairings: IPairingStore;\n\n  constructor(\n    public logger: Logger,\n    public core: ICore,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract pair(params: {\n    uri: string;\n    activatePairing?: boolean;\n  }): Promise<PairingTypes.Struct>;\n\n  // for proposer to create inactive pairing\n  public abstract create(params?: {\n    methods?: string[];\n    transportType?: RelayerTypes.SubscribeOptions[\"transportType\"];\n    internal?: RelayerTypes.SubscribeOptions[\"internal\"];\n  }): Promise<{ topic: string; uri: string }>;\n\n  // for either to activate a previously created pairing\n  public abstract activate(params: { topic: string }): Promise<void>;\n\n  // for both to subscribe on methods requests\n  public abstract register(params: { methods: string[] }): void;\n\n  // for either to update the expiry of an existing pairing.\n  public abstract updateExpiry(params: { topic: string; expiry: number }): Promise<void>;\n\n  // for either to update the metadata of an existing pairing.\n  public abstract updateMetadata(params: {\n    topic: string;\n    metadata: CoreTypes.Metadata;\n  }): Promise<void>;\n\n  // query pairings\n  public abstract getPairings(): PairingTypes.Struct[];\n\n  // for either to ping a peer\n  public abstract ping(params: { topic: string }): Promise<void>;\n\n  // for either peer to disconnect a pairing\n  public abstract disconnect(params: { topic: string }): Promise<void>;\n\n  public abstract formatUriFromPairing(pairing: PairingTypes.Struct): string;\n}\n\nexport interface IPairingPrivate {\n  sendRequest<M extends PairingJsonRpcTypes.WcMethod>(\n    topic: string,\n    method: M,\n    params: PairingJsonRpcTypes.RequestParams[M],\n  ): Promise<number>;\n\n  sendResult<M extends PairingJsonRpcTypes.WcMethod>(\n    id: number,\n    topic: string,\n    result: PairingJsonRpcTypes.Results[M],\n  ): Promise<void>;\n\n  sendError(id: number, topic: string, error: PairingJsonRpcTypes.Error): Promise<void>;\n\n  onRelayEventRequest(event: PairingJsonRpcTypes.EventCallback<JsonRpcRequest>): Promise<void>;\n\n  onRelayEventResponse(event: PairingJsonRpcTypes.EventCallback<JsonRpcResponse>): Promise<void>;\n\n  onPairingPingRequest(\n    topic: string,\n    payload: JsonRpcRequest<PairingJsonRpcTypes.RequestParams[\"wc_pairingPing\"]>,\n  ): Promise<void>;\n\n  onPairingPingResponse(\n    topic: string,\n    payload: JsonRpcResult<PairingJsonRpcTypes.Results[\"wc_pairingPing\"]> | JsonRpcError,\n  ): void;\n\n  onPairingDeleteRequest(\n    topic: string,\n    payload: JsonRpcRequest<PairingJsonRpcTypes.RequestParams[\"wc_pairingDelete\"]>,\n  ): Promise<void>;\n\n  onUnknownRpcMethodRequest(topic: string, payload: JsonRpcRequest): Promise<void>;\n\n  onUnknownRpcMethodResponse(method: string): void;\n\n  deletePairing(topic: string, expirerHasDeleted?: boolean): Promise<void>;\n}\n","import {\n  EVENT_CLIENT_AUTHENTICATE_ERRORS,\n  EVENT_CLIENT_AUTHENTICATE_TRACES,\n  EVENT_CLIENT_PAIRING_ERRORS,\n  EVENT_CLIENT_PAIRING_TRACES,\n  EVENT_CLIENT_SESSION_ERRORS,\n  EVENT_CLIENT_SESSION_TRACES,\n  EXPIRER_EVENTS,\n  PAIRING_EVENTS,\n  RELAYER_DEFAULT_PROTOCOL,\n  RELAYER_EVENTS,\n  TRANSPORT_TYPES,\n  VERIFY_SERVER,\n} from \"@walletconnect/core\";\n\nimport {\n  formatJsonRpcError,\n  formatJsonRpcRequest,\n  formatJsonRpcResult,\n  payloadId,\n  isJsonRpcError,\n  isJsonRpcRequest,\n  isJsonRpcResponse,\n  isJsonRpcResult,\n  JsonRpcRequest,\n  ErrorResponse,\n  getBigIntRpcId,\n} from \"@walletconnect/jsonrpc-utils\";\nimport { FIVE_MINUTES, ONE_SECOND, toMiliseconds } from \"@walletconnect/time\";\nimport {\n  EnginePrivate,\n  EngineTypes,\n  ExpirerTypes,\n  IEngine,\n  IEngineEvents,\n  JsonRpcTypes,\n  PendingRequestTypes,\n  Verify,\n  CoreTypes,\n  ProposalTypes,\n  RelayerTypes,\n  SessionTypes,\n  PairingTypes,\n  AuthTypes,\n  EventClientTypes,\n} from \"@walletconnect/types\";\nimport {\n  calcExpiry,\n  createDelayedPromise,\n  engineEvent,\n  getInternalError,\n  getSdkError,\n  isConformingNamespaces,\n  isExpired,\n  isSessionCompatible,\n  isUndefined,\n  isValidController,\n  isValidErrorReason,\n  isValidEvent,\n  isValidId,\n  isValidNamespaces,\n  isValidNamespacesChainId,\n  isValidNamespacesEvent,\n  isValidNamespacesRequest,\n  isValidObject,\n  isValidParams,\n  isValidRelay,\n  isValidRelays,\n  isValidRequest,\n  isValidRequestExpiry,\n  hashMessage,\n  isValidRequiredNamespaces,\n  isValidResponse,\n  isValidString,\n  parseExpirerTarget,\n  TYPE_1,\n  TYPE_2,\n  handleDeeplinkRedirect,\n  MemoryStore,\n  getDeepLink,\n  hashKey,\n  getDidAddress,\n  formatMessage,\n  getMethodsFromRecap,\n  buildNamespacesFromAuth,\n  createEncodedRecap,\n  getChainsFromRecap,\n  mergeEncodedRecaps,\n  getRecapFromResources,\n  validateSignedCacao,\n  getNamespacedDidChainId,\n  parseChainId,\n  getLinkModeURL,\n  BASE64,\n  BASE64URL,\n  getSearchParamFromURL,\n  isReactNative,\n  isTestRun,\n  isValidArray,\n  extractSolanaTransactionId,\n  getSuiDigest,\n  mergeRequiredAndOptionalNamespaces,\n  getNearTransactionIdFromSignedTransaction,\n  getAlgorandTransactionId,\n  buildSignedExtrinsicHash,\n  getSignDirectHash,\n  LimitedSet,\n  getWalletSendCallsHashes,\n} from \"@walletconnect/utils\";\nimport EventEmmiter from \"events\";\nimport {\n  ENGINE_CONTEXT,\n  ENGINE_RPC_OPTS,\n  PROPOSAL_EXPIRY_MESSAGE,\n  SESSION_EXPIRY,\n  SESSION_REQUEST_EXPIRY_BOUNDARIES,\n  METHODS_TO_VERIFY,\n  WALLETCONNECT_DEEPLINK_CHOICE,\n  ENGINE_QUEUE_STATES,\n  AUTH_PUBLIC_KEY_NAME,\n  TVF_METHODS,\n} from \"../constants\";\n\nexport class Engine extends IEngine {\n  public name = ENGINE_CONTEXT;\n\n  private events: IEngineEvents = new EventEmmiter();\n  private initialized = false;\n\n  /**\n   * Queue responsible for processing incoming requests such as session_update, session_event, session_ping etc\n   * It's needed when the client receives multiple requests at once from the mailbox immediately after initialization and to avoid attempting to process them all at the same time\n   */\n  private requestQueue: EngineTypes.EngineQueue<EngineTypes.EventCallback<JsonRpcRequest>> = {\n    state: ENGINE_QUEUE_STATES.idle,\n    queue: [],\n  };\n\n  /**\n   * Queue responsible for processing incoming session_request\n   * The queue emits the next request only after the previous one has been responded to\n   */\n  private sessionRequestQueue: EngineTypes.EngineQueue<PendingRequestTypes.Struct> = {\n    state: ENGINE_QUEUE_STATES.idle,\n    queue: [],\n  };\n\n  // This prevents duplicate emissions due to WalletConnect's at-least-once delivery guarantee.\n  // When disableRequestQueue is enabled, consumers must implement additional deduplication.\n  private emittedSessionRequests = new LimitedSet({ limit: 500 });\n\n  private requestQueueDelay = ONE_SECOND;\n  private expectedPairingMethodMap: Map<string, string[]> = new Map();\n  // Ephemeral (in-memory) map to store recently deleted items\n  private recentlyDeletedMap = new Map<\n    string | number,\n    \"pairing\" | \"session\" | \"proposal\" | \"request\"\n  >();\n\n  private recentlyDeletedLimit = 200;\n  private relayMessageCache: RelayerTypes.MessageEvent[] = [];\n  private pendingSessions: Map<\n    number,\n    {\n      sessionTopic: string;\n      pairingTopic: string;\n      proposalId: number;\n      publicKey: string;\n    }\n  > = new Map();\n\n  constructor(client: IEngine[\"client\"]) {\n    super(client);\n  }\n\n  public init: IEngine[\"init\"] = async () => {\n    if (!this.initialized) {\n      await this.cleanup();\n      this.registerRelayerEvents();\n      this.registerExpirerEvents();\n      this.registerPairingEvents();\n      await this.registerLinkModeListeners();\n      this.client.core.pairing.register({ methods: Object.keys(ENGINE_RPC_OPTS) });\n      this.initialized = true;\n      setTimeout(async () => {\n        await this.processPendingMessageEvents();\n\n        this.sessionRequestQueue.queue = this.getPendingSessionRequests();\n        this.processSessionRequestQueue();\n      }, toMiliseconds(this.requestQueueDelay));\n    }\n  };\n\n  private async processPendingMessageEvents() {\n    try {\n      const topics = this.client.session.keys;\n      const pendingMessages = this.client.core.relayer.messages.getWithoutAck(topics);\n      for (const [topic, messages] of Object.entries(pendingMessages)) {\n        for (const message of messages) {\n          try {\n            await this.onProviderMessageEvent({\n              topic,\n              message,\n              publishedAt: Date.now(),\n            });\n          } catch (error) {\n            this.client.logger.warn(\n              `Error processing pending message event for topic: ${topic}, message: ${message}`,\n            );\n          }\n        }\n      }\n    } catch (error) {\n      this.client.logger.warn(\"processPendingMessageEvents failed\", error);\n    }\n  }\n\n  // ---------- Public ------------------------------------------------ //\n\n  public connect: IEngine[\"connect\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    const connectParams = {\n      ...params,\n      requiredNamespaces: params.requiredNamespaces || {},\n      optionalNamespaces: params.optionalNamespaces || {},\n    };\n    await this.isValidConnect(connectParams);\n\n    // requiredNamespaces are deprecated, assign them to optionalNamespaces\n    connectParams.optionalNamespaces = mergeRequiredAndOptionalNamespaces(\n      connectParams.requiredNamespaces,\n      connectParams.optionalNamespaces,\n    );\n\n    connectParams.requiredNamespaces = {};\n\n    const {\n      pairingTopic,\n      requiredNamespaces,\n      optionalNamespaces,\n      sessionProperties,\n      scopedProperties,\n      relays,\n    } = connectParams;\n    let topic = pairingTopic;\n    let uri: string | undefined;\n    let active = false;\n    try {\n      if (topic) {\n        const pairing = this.client.core.pairing.pairings.get(topic);\n        this.client.logger.warn(\n          \"connect() with existing pairing topic is deprecated and will be removed in the next major release.\",\n        );\n        active = pairing.active;\n      }\n    } catch (error) {\n      this.client.logger.error(`connect() -> pairing.get(${topic}) failed`);\n      throw error;\n    }\n    if (!topic || !active) {\n      const { topic: newTopic, uri: newUri } = await this.client.core.pairing.create({\n        internal: { skipSubscribe: true },\n      });\n      topic = newTopic;\n      uri = newUri;\n    }\n    // safety check to ensure pairing topic is available\n    if (!topic) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `connect() pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n\n    const publicKey = await this.client.core.crypto.generateKeyPair();\n\n    const expiry = ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl || FIVE_MINUTES;\n    const expiryTimestamp = calcExpiry(expiry);\n    const proposal = {\n      requiredNamespaces,\n      optionalNamespaces,\n      relays: relays ?? [{ protocol: RELAYER_DEFAULT_PROTOCOL }],\n      proposer: {\n        publicKey,\n        metadata: this.client.metadata,\n      },\n      expiryTimestamp,\n      pairingTopic: topic,\n      ...(sessionProperties && { sessionProperties }),\n      ...(scopedProperties && { scopedProperties }),\n      id: payloadId(),\n    };\n    const sessionConnectTarget = engineEvent(\"session_connect\", proposal.id);\n\n    const {\n      reject,\n      resolve,\n      done: approval,\n    } = createDelayedPromise<SessionTypes.Struct>(expiry, PROPOSAL_EXPIRY_MESSAGE);\n\n    const proposalExpireHandler = ({ id }: { id: number }) => {\n      if (id === proposal.id) {\n        this.client.events.off(\"proposal_expire\", proposalExpireHandler);\n        this.pendingSessions.delete(proposal.id);\n        // emit the event to trigger reject, this approach automatically cleans up the .once listener below\n        this.events.emit(sessionConnectTarget, {\n          error: { message: PROPOSAL_EXPIRY_MESSAGE, code: 0 },\n        });\n      }\n    };\n\n    this.client.events.on(\"proposal_expire\", proposalExpireHandler);\n    this.events.once<\"session_connect\">(sessionConnectTarget, ({ error, session }) => {\n      this.client.events.off(\"proposal_expire\", proposalExpireHandler);\n      if (error) reject(error);\n      else if (session) {\n        resolve(session);\n      }\n    });\n\n    await this.sendProposeSession({\n      proposal,\n      publishOpts: {\n        internal: {\n          throwOnFailedPublish: true,\n        },\n        tvf: {\n          correlationId: proposal.id,\n        },\n      },\n    });\n\n    await this.setProposal(proposal.id, proposal);\n    return { uri, approval };\n  };\n\n  public pair: IEngine[\"pair\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      return await this.client.core.pairing.pair(params);\n    } catch (error) {\n      this.client.logger.error(\"pair() failed\");\n      throw error;\n    }\n  };\n\n  public approve: IEngine[\"approve\"] = async (params) => {\n    const configEvent = this.client.core.eventClient.createEvent({\n      properties: {\n        topic: params?.id?.toString(),\n        trace: [EVENT_CLIENT_SESSION_TRACES.session_approve_started],\n      },\n    });\n    try {\n      this.isInitialized();\n      await this.confirmOnlineStateOrThrow();\n    } catch (error) {\n      configEvent.setError(EVENT_CLIENT_SESSION_ERRORS.no_internet_connection);\n      throw error;\n    }\n    try {\n      await this.isValidProposalId(params?.id);\n    } catch (error) {\n      this.client.logger.error(`approve() -> proposal.get(${params?.id}) failed`);\n      configEvent.setError(EVENT_CLIENT_SESSION_ERRORS.proposal_not_found);\n      throw error;\n    }\n\n    try {\n      await this.isValidApprove(params);\n    } catch (error) {\n      this.client.logger.error(\"approve() -> isValidApprove() failed\");\n      configEvent.setError(\n        EVENT_CLIENT_SESSION_ERRORS.session_approve_namespace_validation_failure,\n      );\n      throw error;\n    }\n\n    const { id, relayProtocol, namespaces, sessionProperties, scopedProperties, sessionConfig } =\n      params;\n\n    const proposal = this.client.proposal.get(id);\n\n    this.client.core.eventClient.deleteEvent({ eventId: configEvent.eventId });\n\n    const { pairingTopic, proposer, requiredNamespaces, optionalNamespaces } = proposal;\n\n    let event = this.client.core.eventClient?.getEvent({\n      topic: pairingTopic,\n    }) as EventClientTypes.Event;\n    if (!event) {\n      event = this.client.core.eventClient?.createEvent({\n        type: EVENT_CLIENT_SESSION_TRACES.session_approve_started,\n        properties: {\n          topic: pairingTopic,\n          trace: [\n            EVENT_CLIENT_SESSION_TRACES.session_approve_started,\n            EVENT_CLIENT_SESSION_TRACES.session_namespaces_validation_success,\n          ],\n        },\n      });\n    }\n\n    const selfPublicKey = await this.client.core.crypto.generateKeyPair();\n    const peerPublicKey = proposer.publicKey;\n    const sessionTopic = await this.client.core.crypto.generateSharedKey(\n      selfPublicKey,\n      peerPublicKey,\n    );\n    const sessionSettle = {\n      relay: { protocol: relayProtocol ?? \"irn\" },\n      namespaces,\n      controller: { publicKey: selfPublicKey, metadata: this.client.metadata },\n      expiry: calcExpiry(SESSION_EXPIRY),\n      ...(sessionProperties && { sessionProperties }),\n      ...(scopedProperties && { scopedProperties }),\n      ...(sessionConfig && { sessionConfig }),\n    };\n    const transportType = TRANSPORT_TYPES.relay;\n    event.addTrace(EVENT_CLIENT_SESSION_TRACES.subscribing_session_topic);\n    try {\n      await this.client.core.relayer.subscribe(sessionTopic, {\n        transportType,\n        internal: { skipSubscribe: true },\n      });\n    } catch (error) {\n      event.setError(EVENT_CLIENT_SESSION_ERRORS.subscribe_session_topic_failure);\n      throw error;\n    }\n\n    event.addTrace(EVENT_CLIENT_SESSION_TRACES.subscribe_session_topic_success);\n\n    const session = {\n      ...sessionSettle,\n      topic: sessionTopic,\n      requiredNamespaces,\n      optionalNamespaces,\n      pairingTopic,\n      acknowledged: false,\n      self: sessionSettle.controller,\n      peer: {\n        publicKey: proposer.publicKey,\n        metadata: proposer.metadata,\n      },\n      controller: selfPublicKey,\n      transportType: TRANSPORT_TYPES.relay,\n    };\n    await this.client.session.set(sessionTopic, session);\n\n    event.addTrace(EVENT_CLIENT_SESSION_TRACES.store_session);\n\n    try {\n      await this.sendApproveSession({\n        sessionTopic,\n        proposal,\n        pairingProposalResponse: {\n          relay: {\n            protocol: relayProtocol ?? \"irn\",\n          },\n          responderPublicKey: selfPublicKey,\n        },\n        sessionSettleRequest: sessionSettle,\n        publishOpts: {\n          internal: {\n            throwOnFailedPublish: true,\n          },\n          tvf: {\n            correlationId: id,\n          },\n        },\n      });\n\n      event.addTrace(EVENT_CLIENT_SESSION_TRACES.session_approve_publish_success);\n    } catch (error) {\n      this.client.logger.error(error);\n      // if the publish fails, delete the session and throw an error\n      this.client.session.delete(sessionTopic, getSdkError(\"USER_DISCONNECTED\"));\n      await this.client.core.relayer.unsubscribe(sessionTopic);\n      throw error;\n    }\n\n    this.client.core.eventClient.deleteEvent({ eventId: event.eventId });\n\n    await this.client.core.pairing.updateMetadata({\n      topic: pairingTopic,\n      metadata: proposer.metadata,\n    });\n    await this.deleteProposal(id);\n    await this.client.core.pairing.activate({ topic: pairingTopic });\n    await this.setExpiry(sessionTopic, calcExpiry(SESSION_EXPIRY));\n    return {\n      topic: sessionTopic,\n      acknowledged: () => Promise.resolve(this.client.session.get(sessionTopic)),\n    };\n  };\n\n  public reject: IEngine[\"reject\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      await this.isValidReject(params);\n    } catch (error) {\n      this.client.logger.error(\"reject() -> isValidReject() failed\");\n      throw error;\n    }\n    const { id, reason } = params;\n    let pairingTopic;\n    try {\n      const proposal = this.client.proposal.get(id);\n      pairingTopic = proposal.pairingTopic;\n    } catch (error) {\n      this.client.logger.error(`reject() -> proposal.get(${id}) failed`);\n      throw error;\n    }\n\n    if (pairingTopic) {\n      await this.sendError({\n        id,\n        topic: pairingTopic,\n        error: reason,\n        rpcOpts: ENGINE_RPC_OPTS.wc_sessionPropose.reject,\n      });\n    }\n\n    await this.deleteProposal(id);\n  };\n\n  public update: IEngine[\"update\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      await this.isValidUpdate(params);\n    } catch (error) {\n      this.client.logger.error(\"update() -> isValidUpdate() failed\");\n      throw error;\n    }\n    const { topic, namespaces } = params;\n\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    const clientRpcId = payloadId();\n    const relayRpcId = getBigIntRpcId().toString() as any;\n\n    const oldNamespaces = this.client.session.get(topic).namespaces;\n    this.events.once(engineEvent(\"session_update\", clientRpcId), ({ error }: any) => {\n      if (error) reject(error);\n      else {\n        resolve();\n      }\n    });\n    // Update the session with the new namespaces, if the publish fails, revert to the old.\n    // This allows the client to use the updated session like emitting events\n    // without waiting for the peer to acknowledge\n    await this.client.session.update(topic, { namespaces });\n    await this.sendRequest({\n      topic,\n      method: \"wc_sessionUpdate\",\n      params: { namespaces },\n      throwOnFailedPublish: true,\n      clientRpcId,\n      relayRpcId,\n    }).catch((error) => {\n      this.client.logger.error(error);\n      this.client.session.update(topic, { namespaces: oldNamespaces });\n      reject(error);\n    });\n    return { acknowledged };\n  };\n\n  public extend: IEngine[\"extend\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      await this.isValidExtend(params);\n    } catch (error) {\n      this.client.logger.error(\"extend() -> isValidExtend() failed\");\n      throw error;\n    }\n\n    const { topic } = params;\n    const clientRpcId = payloadId();\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    this.events.once(engineEvent(\"session_extend\", clientRpcId), ({ error }: any) => {\n      if (error) reject(error);\n      else resolve();\n    });\n\n    await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n    this.sendRequest({\n      topic,\n      method: \"wc_sessionExtend\",\n      params: {},\n      clientRpcId,\n      throwOnFailedPublish: true,\n    }).catch((e) => {\n      reject(e);\n    });\n\n    return { acknowledged };\n  };\n\n  public request: IEngine[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    this.isInitialized();\n    try {\n      await this.isValidRequest(params);\n    } catch (error) {\n      this.client.logger.error(\"request() -> isValidRequest() failed\");\n      throw error;\n    }\n    const { chainId, request, topic, expiry = ENGINE_RPC_OPTS.wc_sessionRequest.req.ttl } = params;\n    const session = this.client.session.get(topic);\n\n    if (session?.transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n    const clientRpcId = payloadId();\n    const relayRpcId = getBigIntRpcId().toString() as any;\n    const { done, resolve, reject } = createDelayedPromise<T>(\n      expiry,\n      \"Request expired. Please try again.\",\n    );\n    this.events.once<\"session_request\">(\n      engineEvent(\"session_request\", clientRpcId),\n      ({ error, result }) => {\n        if (error) reject(error);\n        else resolve(result);\n      },\n    );\n    const protocolMethod = \"wc_sessionRequest\";\n    const appLink = this.getAppLinkIfEnabled(session.peer.metadata, session.transportType);\n    if (appLink) {\n      await this.sendRequest({\n        clientRpcId,\n        relayRpcId,\n        topic,\n        method: protocolMethod,\n        params: {\n          request: {\n            ...request,\n            expiryTimestamp: calcExpiry(expiry),\n          },\n          chainId,\n        },\n        expiry,\n        throwOnFailedPublish: true,\n        appLink,\n      }).catch((error) => reject(error));\n\n      this.client.events.emit(\"session_request_sent\", {\n        topic,\n        request,\n        chainId,\n        id: clientRpcId,\n      });\n      const result = await done();\n      return result;\n    }\n\n    const protocolRequestParams: JsonRpcTypes.RequestParams[\"wc_sessionRequest\"] = {\n      request: {\n        ...request,\n        expiryTimestamp: calcExpiry(expiry),\n      },\n      chainId,\n    };\n\n    return await Promise.all([\n      new Promise<void>(async (resolve) => {\n        await this.sendRequest({\n          clientRpcId,\n          relayRpcId,\n          topic,\n          method: protocolMethod,\n          params: protocolRequestParams,\n          expiry,\n          throwOnFailedPublish: true,\n          tvf: this.getTVFParams(clientRpcId, protocolRequestParams),\n        }).catch((error) => reject(error));\n        this.client.events.emit(\"session_request_sent\", {\n          topic,\n          request,\n          chainId,\n          id: clientRpcId,\n        });\n        resolve();\n      }),\n      new Promise<void>(async (resolve) => {\n        // only attempt to handle deeplinks if they are not explicitly disabled in the session config\n        if (!session.sessionConfig?.disableDeepLink) {\n          const wcDeepLink = (await getDeepLink(\n            this.client.core.storage,\n            WALLETCONNECT_DEEPLINK_CHOICE,\n          )) as string;\n          await handleDeeplinkRedirect({ id: clientRpcId, topic, wcDeepLink });\n        }\n        resolve();\n      }),\n      done(),\n    ]).then((result) => result[2]); // order is important here, we want to return the result of the `done` promise\n  };\n\n  public respond: IEngine[\"respond\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidRespond(params);\n    const { topic, response } = params;\n    const { id } = response;\n    const session = this.client.session.get(topic);\n\n    if (session.transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n\n    const appLink = this.getAppLinkIfEnabled(session.peer.metadata, session.transportType);\n    if (isJsonRpcResult(response)) {\n      await this.sendResult({\n        id,\n        topic,\n        result: response.result,\n        throwOnFailedPublish: true,\n        appLink,\n      });\n    } else if (isJsonRpcError(response)) {\n      await this.sendError({ id, topic, error: response.error, appLink });\n    }\n    this.cleanupAfterResponse(params);\n  };\n\n  public ping: IEngine[\"ping\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      await this.isValidPing(params);\n    } catch (error) {\n      this.client.logger.error(\"ping() -> isValidPing() failed\");\n      throw error;\n    }\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      const clientRpcId = payloadId();\n      const relayRpcId = getBigIntRpcId().toString() as any;\n      const { done, resolve, reject } = createDelayedPromise<void>();\n      this.events.once(engineEvent(\"session_ping\", clientRpcId), ({ error }: any) => {\n        if (error) reject(error);\n        else resolve();\n      });\n      await Promise.all([\n        this.sendRequest({\n          topic,\n          method: \"wc_sessionPing\",\n          params: {},\n          throwOnFailedPublish: true,\n          clientRpcId,\n          relayRpcId,\n        }),\n        done(),\n      ]);\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      this.client.logger.warn(\n        \"ping() on pairing topic is deprecated and will be removed in the next major release.\",\n      );\n      await this.client.core.pairing.ping({ topic });\n    }\n  };\n\n  public emit: IEngine[\"emit\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    await this.isValidEmit(params);\n    const { topic, event, chainId } = params;\n    const relayRpcId = getBigIntRpcId().toString() as any;\n    const clientRpcId = payloadId();\n    await this.sendRequest({\n      topic,\n      method: \"wc_sessionEvent\",\n      params: { event, chainId },\n      throwOnFailedPublish: true,\n      relayRpcId,\n      clientRpcId,\n    });\n  };\n\n  public disconnect: IEngine[\"disconnect\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    await this.isValidDisconnect(params);\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      // await an ack to ensure the relay has received the disconnect request\n      await this.sendRequest({\n        topic,\n        method: \"wc_sessionDelete\",\n        params: getSdkError(\"USER_DISCONNECTED\"),\n        throwOnFailedPublish: true,\n      });\n      await this.deleteSession({ topic, emitEvent: false });\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      await this.client.core.pairing.disconnect({ topic });\n    } else {\n      const { message } = getInternalError(\n        \"MISMATCHED_TOPIC\",\n        `Session or pairing topic not found: ${topic}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  public find: IEngine[\"find\"] = (params) => {\n    this.isInitialized();\n    return this.client.session.getAll().filter((session) => isSessionCompatible(session, params));\n  };\n\n  public getPendingSessionRequests: IEngine[\"getPendingSessionRequests\"] = () => {\n    return this.client.pendingRequest.getAll();\n  };\n\n  // ---------- Auth ------------------------------------------------ //\n\n  public authenticate: IEngine[\"authenticate\"] = async (params, walletUniversalLink) => {\n    this.isInitialized();\n    this.isValidAuthenticate(params);\n\n    const isLinkMode =\n      walletUniversalLink &&\n      this.client.core.linkModeSupportedApps.includes(walletUniversalLink) &&\n      this.client.metadata.redirect?.linkMode;\n\n    const transportType: RelayerTypes.TransportType = isLinkMode\n      ? TRANSPORT_TYPES.link_mode\n      : TRANSPORT_TYPES.relay;\n\n    if (transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n\n    const {\n      chains,\n      statement = \"\",\n      uri,\n      domain,\n      nonce,\n      type,\n      exp,\n      nbf,\n      methods = [],\n      expiry,\n    } = params;\n    // reassign resources to remove reference as the array is modified and might cause side effects\n    const resources = [...(params.resources || [])];\n\n    const { topic: pairingTopic, uri: connectionUri } = await this.client.core.pairing.create({\n      methods: [\"wc_sessionAuthenticate\"],\n      transportType,\n    });\n\n    this.client.logger.info({\n      message: \"Generated new pairing\",\n      pairing: { topic: pairingTopic, uri: connectionUri },\n    });\n\n    const publicKey = await this.client.core.crypto.generateKeyPair();\n    const responseTopic = hashKey(publicKey);\n\n    await Promise.all([\n      this.client.auth.authKeys.set(AUTH_PUBLIC_KEY_NAME, { responseTopic, publicKey }),\n      this.client.auth.pairingTopics.set(responseTopic, { topic: responseTopic, pairingTopic }),\n    ]);\n\n    // Subscribe to response topic\n    await this.client.core.relayer.subscribe(responseTopic, { transportType });\n\n    this.client.logger.info(`sending request to new pairing topic: ${pairingTopic}`);\n\n    if (methods.length > 0) {\n      const { namespace } = parseChainId(chains[0]);\n      let recap = createEncodedRecap(namespace, \"request\", methods);\n      const existingRecap = getRecapFromResources(resources);\n      if (existingRecap) {\n        // per Recaps spec, recap must occupy the last position in the resources array\n        // using .pop to remove the element given we already checked it's a recap and will replace it\n        const mergedRecap = mergeEncodedRecaps(recap, resources.pop() as string);\n        recap = mergedRecap;\n      }\n      resources.push(recap);\n    }\n\n    // Ensure the expiry is greater than the minimum required for the request - currently 1h\n    const authRequestExpiry =\n      expiry && expiry > ENGINE_RPC_OPTS.wc_sessionAuthenticate.req.ttl\n        ? expiry\n        : ENGINE_RPC_OPTS.wc_sessionAuthenticate.req.ttl;\n\n    const request: AuthTypes.SessionAuthenticateRequestParams = {\n      authPayload: {\n        type: type ?? \"caip122\",\n        chains,\n        statement,\n        aud: uri,\n        domain,\n        version: \"1\",\n        nonce,\n        iat: new Date().toISOString(),\n        exp,\n        nbf,\n        resources,\n      },\n      requester: { publicKey, metadata: this.client.metadata },\n      expiryTimestamp: calcExpiry(authRequestExpiry),\n    };\n\n    // ----- build namespaces for fallback session proposal ----- //\n    const namespaces = {\n      eip155: {\n        chains,\n        // request `personal_sign` method by default to allow for fallback siwe\n        methods: [...new Set([\"personal_sign\", ...methods])],\n        events: [\"chainChanged\", \"accountsChanged\"],\n      },\n    };\n\n    const proposal = {\n      requiredNamespaces: {},\n      optionalNamespaces: namespaces,\n      relays: [{ protocol: \"irn\" }],\n      pairingTopic,\n      proposer: {\n        publicKey,\n        metadata: this.client.metadata,\n      },\n      expiryTimestamp: calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl),\n      id: payloadId(),\n    };\n\n    const { done, resolve, reject } = createDelayedPromise(authRequestExpiry, \"Request expired\");\n\n    const authenticateId = payloadId();\n    const sessionConnectEventTarget = engineEvent(\"session_connect\", proposal.id);\n    const authenticateEventTarget = engineEvent(\"session_request\", authenticateId);\n\n    // handle fallback session proposal response\n    const onSessionConnect = async ({ error, session }: any) => {\n      // cleanup listener for authenticate response\n      this.events.off(authenticateEventTarget, onAuthenticate);\n      if (error) reject(error);\n      else if (session) {\n        resolve({\n          session,\n        });\n      }\n    };\n    // handle session authenticate response\n    const onAuthenticate = async (payload: any) => {\n      // delete this auth request on response\n      // we're using payload from the wallet to establish the session so we don't need to keep this around\n      await this.deletePendingAuthRequest(authenticateId, { message: \"fulfilled\", code: 0 });\n      if (payload.error) {\n        // wallets that do not support wc_sessionAuthenticate will return an error\n        // we should not reject the promise in this case as the fallback session proposal will be used\n        const error = getSdkError(\"WC_METHOD_UNSUPPORTED\", \"wc_sessionAuthenticate\");\n        if (payload.error.code === error.code) return;\n\n        // cleanup listener for fallback response\n        this.events.off(sessionConnectEventTarget, onSessionConnect);\n        return reject(payload.error.message);\n      }\n      // delete fallback proposal on successful authenticate as the proposal will not be responded to\n      await this.deleteProposal(proposal.id);\n      // cleanup listener for fallback response\n      this.events.off(sessionConnectEventTarget, onSessionConnect);\n\n      const {\n        cacaos,\n        responder,\n      }: {\n        cacaos: AuthTypes.SessionAuthenticateResponseParams[\"cacaos\"];\n        responder: AuthTypes.SessionAuthenticateResponseParams[\"responder\"];\n      } = payload.result;\n\n      const approvedMethods: string[] = [];\n      const approvedAccounts: string[] = [];\n      for (const cacao of cacaos) {\n        const isValid = await validateSignedCacao({ cacao, projectId: this.client.core.projectId });\n        if (!isValid) {\n          this.client.logger.error(cacao, \"Signature verification failed\");\n          reject(getSdkError(\"SESSION_SETTLEMENT_FAILED\", \"Signature verification failed\"));\n        }\n\n        const { p: payload } = cacao;\n        const recap = getRecapFromResources(payload.resources);\n\n        const approvedChains: string[] = [getNamespacedDidChainId(payload.iss) as string];\n        const parsedAddress = getDidAddress(payload.iss) as string;\n\n        if (recap) {\n          const methodsfromRecap = getMethodsFromRecap(recap);\n          const chainsFromRecap = getChainsFromRecap(recap);\n          approvedMethods.push(...methodsfromRecap);\n          approvedChains.push(...chainsFromRecap);\n        }\n\n        for (const chain of approvedChains) {\n          approvedAccounts.push(`${chain}:${parsedAddress}`);\n        }\n      }\n      const sessionTopic = await this.client.core.crypto.generateSharedKey(\n        publicKey,\n        responder.publicKey,\n      );\n\n      //create session object\n      let session: SessionTypes.Struct | undefined;\n\n      if (approvedMethods.length > 0) {\n        session = {\n          topic: sessionTopic,\n          acknowledged: true,\n          self: {\n            publicKey,\n            metadata: this.client.metadata,\n          },\n          peer: responder,\n          controller: responder.publicKey,\n          expiry: calcExpiry(SESSION_EXPIRY),\n          requiredNamespaces: {},\n          optionalNamespaces: {},\n          relay: { protocol: \"irn\" },\n          pairingTopic,\n          namespaces: buildNamespacesFromAuth(\n            [...new Set(approvedMethods)],\n            [...new Set(approvedAccounts)],\n          ),\n          transportType,\n        };\n\n        await this.client.core.relayer.subscribe(sessionTopic, { transportType });\n        await this.client.session.set(sessionTopic, session);\n        if (pairingTopic) {\n          await this.client.core.pairing.updateMetadata({\n            topic: pairingTopic,\n            metadata: responder.metadata,\n          });\n        }\n\n        session = this.client.session.get(sessionTopic);\n      }\n\n      if (\n        this.client.metadata.redirect?.linkMode &&\n        responder.metadata.redirect?.linkMode &&\n        responder.metadata.redirect?.universal &&\n        walletUniversalLink\n      ) {\n        // save wallet link in array of apps that support linkMode\n        this.client.core.addLinkModeSupportedApp(responder.metadata.redirect.universal);\n\n        this.client.session.update(sessionTopic, {\n          transportType: TRANSPORT_TYPES.link_mode,\n        });\n      }\n\n      resolve({\n        auths: cacaos,\n        session,\n      });\n    };\n\n    // subscribe to response events\n    this.events.once<\"session_connect\">(sessionConnectEventTarget, onSessionConnect);\n    this.events.once(authenticateEventTarget, onAuthenticate);\n\n    let linkModeURL;\n    try {\n      if (isLinkMode) {\n        const payload = formatJsonRpcRequest(\"wc_sessionAuthenticate\", request, authenticateId);\n        this.client.core.history.set(pairingTopic, payload);\n        const message = await this.client.core.crypto.encode(\"\", payload, {\n          type: TYPE_2,\n          encoding: BASE64URL,\n        });\n        linkModeURL = getLinkModeURL(walletUniversalLink, pairingTopic, message);\n      } else {\n        // send both (main & fallback) requests\n        await Promise.all([\n          this.sendRequest({\n            topic: pairingTopic,\n            method: \"wc_sessionAuthenticate\",\n            params: request,\n            expiry: params.expiry,\n            throwOnFailedPublish: true,\n            clientRpcId: authenticateId,\n          }),\n          this.sendRequest({\n            topic: pairingTopic,\n            method: \"wc_sessionPropose\",\n            params: proposal,\n            expiry: ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl,\n            throwOnFailedPublish: true,\n            clientRpcId: proposal.id,\n          }),\n        ]);\n      }\n    } catch (error) {\n      // cleanup listeners on failed publish\n      this.events.off(sessionConnectEventTarget, onSessionConnect);\n      this.events.off(authenticateEventTarget, onAuthenticate);\n      throw error;\n    }\n\n    await this.setProposal(proposal.id, proposal);\n    await this.setAuthRequest(authenticateId, {\n      request: {\n        ...request,\n        verifyContext: {} as any,\n      },\n      pairingTopic,\n      transportType,\n    });\n\n    return {\n      uri: linkModeURL ?? connectionUri,\n      response: done,\n    } as EngineTypes.SessionAuthenticateResponsePromise;\n  };\n\n  public approveSessionAuthenticate: IEngine[\"approveSessionAuthenticate\"] = async (\n    sessionAuthenticateResponseParams,\n  ) => {\n    const { id, auths } = sessionAuthenticateResponseParams;\n\n    const event = this.client.core.eventClient.createEvent({\n      properties: {\n        topic: id.toString(),\n        trace: [EVENT_CLIENT_AUTHENTICATE_TRACES.authenticated_session_approve_started],\n      },\n    });\n\n    try {\n      this.isInitialized();\n    } catch (error) {\n      event.setError(EVENT_CLIENT_AUTHENTICATE_ERRORS.no_internet_connection);\n      throw error;\n    }\n\n    const pendingRequest = this.getPendingAuthRequest(id);\n\n    if (!pendingRequest) {\n      event.setError(\n        EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_pending_request_not_found,\n      );\n      throw new Error(`Could not find pending auth request with id ${id}`);\n    }\n\n    const transportType = pendingRequest.transportType || TRANSPORT_TYPES.relay;\n    if (transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n\n    const receiverPublicKey = pendingRequest.requester.publicKey;\n    const senderPublicKey = await this.client.core.crypto.generateKeyPair();\n    const responseTopic = hashKey(receiverPublicKey);\n\n    const encodeOpts = {\n      type: TYPE_1,\n      receiverPublicKey,\n      senderPublicKey,\n    };\n\n    const approvedMethods: string[] = [];\n    const approvedAccounts: string[] = [];\n    for (const cacao of auths) {\n      const isValid = await validateSignedCacao({ cacao, projectId: this.client.core.projectId });\n      if (!isValid) {\n        event.setError(EVENT_CLIENT_AUTHENTICATE_ERRORS.invalid_cacao);\n\n        const invalidErr = getSdkError(\n          \"SESSION_SETTLEMENT_FAILED\",\n          \"Signature verification failed\",\n        );\n\n        await this.sendError({\n          id,\n          topic: responseTopic,\n          error: invalidErr,\n          encodeOpts,\n        });\n\n        throw new Error(invalidErr.message);\n      }\n\n      event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.cacaos_verified);\n\n      const { p: payload } = cacao;\n      const recap = getRecapFromResources(payload.resources);\n\n      const approvedChains: string[] = [getNamespacedDidChainId(payload.iss) as string];\n\n      const parsedAddress = getDidAddress(payload.iss) as string;\n\n      if (recap) {\n        const methodsfromRecap = getMethodsFromRecap(recap);\n        const chainsFromRecap = getChainsFromRecap(recap);\n        approvedMethods.push(...methodsfromRecap);\n        approvedChains.push(...chainsFromRecap);\n      }\n      for (const chain of approvedChains) {\n        approvedAccounts.push(`${chain}:${parsedAddress}`);\n      }\n    }\n\n    const sessionTopic = await this.client.core.crypto.generateSharedKey(\n      senderPublicKey,\n      receiverPublicKey,\n    );\n\n    event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.create_authenticated_session_topic);\n\n    let session: SessionTypes.Struct | undefined;\n    if (approvedMethods?.length > 0) {\n      session = {\n        topic: sessionTopic,\n        acknowledged: true,\n        self: {\n          publicKey: senderPublicKey,\n          metadata: this.client.metadata,\n        },\n        peer: {\n          publicKey: receiverPublicKey,\n          metadata: pendingRequest.requester.metadata,\n        },\n        controller: receiverPublicKey,\n        expiry: calcExpiry(SESSION_EXPIRY),\n        authentication: auths,\n        requiredNamespaces: {},\n        optionalNamespaces: {},\n        relay: { protocol: \"irn\" },\n        pairingTopic: pendingRequest.pairingTopic,\n        namespaces: buildNamespacesFromAuth(\n          [...new Set(approvedMethods)],\n          [...new Set(approvedAccounts)],\n        ),\n        transportType,\n      };\n\n      event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.subscribing_authenticated_session_topic);\n\n      try {\n        await this.client.core.relayer.subscribe(sessionTopic, { transportType });\n      } catch (error) {\n        event.setError(\n          EVENT_CLIENT_AUTHENTICATE_ERRORS.subscribe_authenticated_session_topic_failure,\n        );\n        throw error;\n      }\n\n      event.addTrace(\n        EVENT_CLIENT_AUTHENTICATE_TRACES.subscribe_authenticated_session_topic_success,\n      );\n\n      await this.client.session.set(sessionTopic, session);\n\n      event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.store_authenticated_session);\n\n      await this.client.core.pairing.updateMetadata({\n        topic: pendingRequest.pairingTopic,\n        metadata: pendingRequest.requester.metadata,\n      });\n    }\n\n    event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.publishing_authenticated_session_approve);\n\n    try {\n      await this.sendResult<\"wc_sessionAuthenticate\">({\n        topic: responseTopic,\n        id,\n        result: {\n          cacaos: auths,\n          responder: {\n            publicKey: senderPublicKey,\n            metadata: this.client.metadata,\n          },\n        },\n        encodeOpts,\n        throwOnFailedPublish: true,\n        appLink: this.getAppLinkIfEnabled(pendingRequest.requester.metadata, transportType),\n      });\n    } catch (error) {\n      event.setError(\n        EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_approve_publish_failure,\n      );\n      throw error;\n    }\n\n    await this.client.auth.requests.delete(id, { message: \"fulfilled\", code: 0 });\n    await this.client.core.pairing.activate({ topic: pendingRequest.pairingTopic });\n    this.client.core.eventClient.deleteEvent({ eventId: event.eventId });\n\n    return { session };\n  };\n\n  public rejectSessionAuthenticate: IEngine[\"rejectSessionAuthenticate\"] = async (params) => {\n    this.isInitialized();\n\n    const { id, reason } = params;\n\n    const pendingRequest = this.getPendingAuthRequest(id);\n\n    if (!pendingRequest) {\n      throw new Error(`Could not find pending auth request with id ${id}`);\n    }\n\n    if (pendingRequest.transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n\n    const receiverPublicKey = pendingRequest.requester.publicKey;\n    const senderPublicKey = await this.client.core.crypto.generateKeyPair();\n    const responseTopic = hashKey(receiverPublicKey);\n\n    const encodeOpts = {\n      type: TYPE_1,\n      receiverPublicKey,\n      senderPublicKey,\n    };\n\n    await this.sendError({\n      id,\n      topic: responseTopic,\n      error: reason,\n      encodeOpts,\n      rpcOpts: ENGINE_RPC_OPTS.wc_sessionAuthenticate.reject,\n      appLink: this.getAppLinkIfEnabled(\n        pendingRequest.requester.metadata,\n        pendingRequest.transportType,\n      ),\n    });\n    await this.client.auth.requests.delete(id, { message: \"rejected\", code: 0 });\n    await this.deleteProposal(id);\n  };\n\n  public formatAuthMessage: IEngine[\"formatAuthMessage\"] = (params) => {\n    this.isInitialized();\n    const { request, iss } = params;\n    return formatMessage(request, iss);\n  };\n\n  /**\n   * no longer used as the client initializes instantly without waiting to connect+subscribe\n   * @deprecated\n   */\n  public processRelayMessageCache: IEngine[\"processRelayMessageCache\"] = () => {\n    // process the relay messages cache in the next tick to allow event listeners to be registered by the implementing app\n    setTimeout(async () => {\n      if (this.relayMessageCache.length === 0) return;\n      while (this.relayMessageCache.length > 0) {\n        try {\n          const message = this.relayMessageCache.shift();\n          if (message) {\n            await this.onRelayMessage(message);\n          }\n        } catch (error) {\n          this.client.logger.error(error);\n        }\n      }\n    }, 50);\n  };\n\n  // ---------- Private Helpers --------------------------------------- //\n\n  private cleanupDuplicatePairings: EnginePrivate[\"cleanupDuplicatePairings\"] = async (\n    session: SessionTypes.Struct,\n  ) => {\n    // older SDK versions are missing the `pairingTopic` prop thus we need to check for it\n    if (!session.pairingTopic) return;\n\n    try {\n      const pairing = this.client.core.pairing.pairings.get(session.pairingTopic);\n      const allPairings = this.client.core.pairing.pairings.getAll();\n      const duplicates = allPairings.filter(\n        (p) =>\n          p.peerMetadata?.url &&\n          p.peerMetadata?.url === session.peer.metadata.url &&\n          p.topic &&\n          p.topic !== pairing.topic,\n      );\n      if (duplicates.length === 0) return;\n      this.client.logger.info(`Cleaning up ${duplicates.length} duplicate pairing(s)`);\n      await Promise.all(\n        duplicates.map((p) => this.client.core.pairing.disconnect({ topic: p.topic })),\n      );\n      this.client.logger.info(`Duplicate pairings clean up finished`);\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  };\n\n  private deleteSession: EnginePrivate[\"deleteSession\"] = async (params) => {\n    const { topic, expirerHasDeleted = false, emitEvent = true, id = 0 } = params;\n    const { self } = this.client.session.get(topic);\n    // Await the unsubscribe first to avoid deleting the symKey too early below.\n    await this.client.core.relayer.unsubscribe(topic);\n    await this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\"));\n    this.addToRecentlyDeleted(topic, \"session\");\n    if (this.client.core.crypto.keychain.has(self.publicKey)) {\n      await this.client.core.crypto.deleteKeyPair(self.publicKey);\n    }\n    if (this.client.core.crypto.keychain.has(topic)) {\n      await this.client.core.crypto.deleteSymKey(topic);\n    }\n    if (!expirerHasDeleted) this.client.core.expirer.del(topic);\n    // remove any deeplinks from storage after the session is deleted\n    // to avoid navigating to incorrect deeplink later on\n    this.client.core.storage\n      .removeItem(WALLETCONNECT_DEEPLINK_CHOICE)\n      .catch((e) => this.client.logger.warn(e));\n    this.getPendingSessionRequests().forEach((r) => {\n      if (r.topic === topic) {\n        this.deletePendingSessionRequest(r.id, getSdkError(\"USER_DISCONNECTED\"));\n      }\n    });\n    // reset the queue state back to idle if a request for the deleted session is still in the queue\n    if (topic === this.sessionRequestQueue.queue[0]?.topic) {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;\n    }\n    if (emitEvent) this.client.events.emit(\"session_delete\", { id, topic });\n  };\n\n  private deleteProposal: EnginePrivate[\"deleteProposal\"] = async (id, expirerHasDeleted) => {\n    if (expirerHasDeleted) {\n      try {\n        const proposal = this.client.proposal.get(id);\n        const event = this.client.core.eventClient.getEvent({ topic: proposal.pairingTopic });\n        event?.setError(EVENT_CLIENT_SESSION_ERRORS.proposal_expired);\n      } catch (error) {}\n    }\n    await Promise.all([\n      this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\")),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n    this.addToRecentlyDeleted(id, \"proposal\");\n  };\n\n  private deletePendingSessionRequest: EnginePrivate[\"deletePendingSessionRequest\"] = async (\n    id,\n    reason,\n    expirerHasDeleted = false,\n  ) => {\n    await Promise.all([\n      this.client.pendingRequest.delete(id, reason),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n    this.addToRecentlyDeleted(id, \"request\");\n    this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((r) => r.id !== id);\n    if (expirerHasDeleted) {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;\n      this.client.events.emit(\"session_request_expire\", { id });\n    }\n  };\n\n  private deletePendingAuthRequest: EnginePrivate[\"deletePendingAuthRequest\"] = async (\n    id,\n    reason,\n    expirerHasDeleted = false,\n  ) => {\n    await Promise.all([\n      this.client.auth.requests.delete(id, reason),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n  };\n\n  private setExpiry: EnginePrivate[\"setExpiry\"] = async (topic, expiry) => {\n    if (!this.client.session.keys.includes(topic)) return;\n    this.client.core.expirer.set(topic, expiry);\n    await this.client.session.update(topic, { expiry });\n  };\n\n  private setProposal: EnginePrivate[\"setProposal\"] = async (id, proposal) => {\n    this.client.core.expirer.set(id, calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl));\n    await this.client.proposal.set(id, proposal);\n  };\n\n  private setAuthRequest: EnginePrivate[\"setAuthRequest\"] = async (id, params) => {\n    const { request, pairingTopic, transportType = TRANSPORT_TYPES.relay } = params;\n    this.client.core.expirer.set(id, request.expiryTimestamp);\n    await this.client.auth.requests.set(id, {\n      authPayload: request.authPayload,\n      requester: request.requester,\n      expiryTimestamp: request.expiryTimestamp,\n      id,\n      pairingTopic,\n      verifyContext: request.verifyContext,\n      transportType,\n    });\n  };\n\n  private setPendingSessionRequest: EnginePrivate[\"setPendingSessionRequest\"] = async (\n    pendingRequest: PendingRequestTypes.Struct,\n  ) => {\n    const { id, topic, params, verifyContext } = pendingRequest;\n    const expiry =\n      params.request.expiryTimestamp || calcExpiry(ENGINE_RPC_OPTS.wc_sessionRequest.req.ttl);\n    this.client.core.expirer.set(id, expiry);\n    await this.client.pendingRequest.set(id, {\n      id,\n      topic,\n      params,\n      verifyContext,\n    });\n  };\n\n  private sendRequest: EnginePrivate[\"sendRequest\"] = async (args) => {\n    const {\n      topic,\n      method,\n      params,\n      expiry,\n      relayRpcId,\n      clientRpcId,\n      throwOnFailedPublish,\n      appLink,\n      tvf,\n      publishOpts = {},\n    } = args;\n    const payload = formatJsonRpcRequest(method, params, clientRpcId);\n\n    let message: string;\n    const isLinkMode = !!appLink;\n\n    try {\n      const encoding = isLinkMode ? BASE64URL : BASE64;\n      message = await this.client.core.crypto.encode(topic, payload, { encoding });\n    } catch (error) {\n      await this.cleanup();\n      this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${topic} failed`);\n      throw error;\n    }\n\n    let attestation: string | undefined;\n    if (METHODS_TO_VERIFY.includes(method)) {\n      const decryptedId = hashMessage(JSON.stringify(payload));\n      const id = hashMessage(message);\n      attestation = await this.client.core.verify.register({ id, decryptedId });\n    }\n\n    const opts = {\n      ...ENGINE_RPC_OPTS[method].req,\n      ...publishOpts,\n    };\n\n    opts.attestation = attestation;\n    if (expiry) opts.ttl = expiry;\n    if (relayRpcId) opts.id = relayRpcId;\n    this.client.core.history.set(topic, payload);\n\n    if (isLinkMode) {\n      const redirectURL = getLinkModeURL(appLink, topic, message);\n      await (global as any).Linking.openURL(redirectURL, this.client.name);\n    } else {\n      opts.tvf = {\n        ...tvf,\n        correlationId: payload.id,\n      };\n\n      if (throwOnFailedPublish) {\n        opts.internal = {\n          ...opts.internal,\n          throwOnFailedPublish: true,\n        };\n        await this.client.core.relayer.publish(topic, message, opts);\n      } else {\n        this.client.core.relayer\n          .publish(topic, message, opts)\n          .catch((error) => this.client.logger.error(error));\n      }\n    }\n\n    return payload.id;\n  };\n\n  private sendProposeSession: EnginePrivate[\"sendProposeSession\"] = async (params) => {\n    const { proposal, publishOpts } = params;\n\n    const proposeSessionPayload = formatJsonRpcRequest(\"wc_sessionPropose\", proposal, proposal.id);\n\n    this.client.core.history.set(proposal.pairingTopic, proposeSessionPayload);\n\n    const proposeSessionMessage = await this.client.core.crypto.encode(\n      proposal.pairingTopic,\n      proposeSessionPayload,\n      {\n        encoding: BASE64,\n      },\n    );\n\n    const decryptedId = hashMessage(JSON.stringify(proposeSessionPayload));\n    const attestationId = hashMessage(proposeSessionMessage);\n    const attestation = await this.client.core.verify.register({ id: attestationId, decryptedId });\n\n    await this.client.core.relayer.publishCustom({\n      payload: {\n        pairingTopic: proposal.pairingTopic,\n        sessionProposal: proposeSessionMessage,\n      },\n      opts: {\n        ...publishOpts,\n        publishMethod: \"wc_proposeSession\",\n        attestation,\n      },\n    });\n  };\n\n  private sendApproveSession: EnginePrivate[\"sendApproveSession\"] = async (params) => {\n    const { sessionTopic, pairingProposalResponse, proposal, sessionSettleRequest, publishOpts } =\n      params;\n    const pairingPayload = formatJsonRpcResult(proposal.id, pairingProposalResponse);\n\n    const pairingResponseMessage = await this.client.core.crypto.encode(\n      proposal.pairingTopic,\n      pairingPayload,\n      {\n        encoding: BASE64,\n      },\n    );\n\n    const sessionSettlePayload = formatJsonRpcRequest(\n      \"wc_sessionSettle\",\n      sessionSettleRequest,\n      publishOpts?.id,\n    );\n\n    const sessionSettlementRequestMessage = await this.client.core.crypto.encode(\n      sessionTopic,\n      sessionSettlePayload,\n      {\n        encoding: BASE64,\n      },\n    );\n\n    this.client.core.history.set(sessionTopic, sessionSettlePayload);\n\n    await this.client.core.relayer.publishCustom({\n      payload: {\n        sessionTopic,\n        pairingTopic: proposal.pairingTopic,\n        sessionProposalResponse: pairingResponseMessage,\n        sessionSettlementRequest: sessionSettlementRequestMessage,\n      },\n      opts: {\n        ...publishOpts,\n        publishMethod: \"wc_approveSession\",\n      },\n    });\n  };\n\n  private sendResult: EnginePrivate[\"sendResult\"] = async (args) => {\n    const { id, topic, result, throwOnFailedPublish, encodeOpts, appLink } = args;\n    const payload = formatJsonRpcResult(id, result);\n    let message;\n    const isLinkMode = appLink && typeof (global as any)?.Linking !== \"undefined\";\n\n    try {\n      const encoding = isLinkMode ? BASE64URL : BASE64;\n      message = await this.client.core.crypto.encode(topic, payload, {\n        ...(encodeOpts || {}),\n        encoding,\n      });\n    } catch (error) {\n      // if encoding fails e.g. due to missing keychain, we want to cleanup all related data as its unusable\n      await this.cleanup();\n      this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${topic} failed`);\n      throw error;\n    }\n    let record;\n    let tvf;\n    try {\n      record = await this.client.core.history.get(topic, id);\n      const request = record.request;\n      try {\n        tvf = this.getTVFParams(id, request.params, result);\n      } catch (error) {\n        this.client.logger.warn(\n          `sendResult() -> getTVFParams() failed: ${(error as Error)?.message}`,\n        );\n      }\n    } catch (error) {\n      this.client.logger.error(`sendResult() -> history.get(${topic}, ${id}) failed`);\n      throw error;\n    }\n\n    if (isLinkMode) {\n      const redirectURL = getLinkModeURL(appLink, topic, message);\n      await (global as any).Linking.openURL(redirectURL, this.client.name);\n    } else {\n      const method = record.request.method as JsonRpcTypes.WcMethod;\n      const opts = ENGINE_RPC_OPTS[method].res;\n\n      opts.tvf = {\n        ...tvf,\n        correlationId: id,\n      };\n\n      if (throwOnFailedPublish) {\n        opts.internal = {\n          ...opts.internal,\n          throwOnFailedPublish: true,\n        };\n        await this.client.core.relayer.publish(topic, message, opts);\n      } else {\n        this.client.core.relayer\n          .publish(topic, message, opts)\n          .catch((error) => this.client.logger.error(error));\n      }\n    }\n\n    await this.client.core.history.resolve(payload);\n  };\n\n  private sendError: EnginePrivate[\"sendError\"] = async (params) => {\n    const { id, topic, error, encodeOpts, rpcOpts, appLink } = params;\n    const payload = formatJsonRpcError(id, error);\n    let message;\n    const isLinkMode = appLink && typeof (global as any)?.Linking !== \"undefined\";\n    try {\n      const encoding = isLinkMode ? BASE64URL : BASE64;\n      message = await this.client.core.crypto.encode(topic, payload, {\n        ...(encodeOpts || {}),\n        encoding,\n      });\n    } catch (error) {\n      await this.cleanup();\n      this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${topic} failed`);\n      throw error;\n    }\n    let record;\n    try {\n      record = await this.client.core.history.get(topic, id);\n    } catch (error) {\n      this.client.logger.error(`sendError() -> history.get(${topic}, ${id}) failed`);\n      throw error;\n    }\n\n    if (isLinkMode) {\n      const redirectURL = getLinkModeURL(appLink, topic, message);\n      await (global as any).Linking.openURL(redirectURL, this.client.name);\n    } else {\n      const method = record.request.method as JsonRpcTypes.WcMethod;\n      const opts = rpcOpts || ENGINE_RPC_OPTS[method].res;\n      // await is intentionally omitted to speed up performance\n      this.client.core.relayer.publish(topic, message, opts);\n    }\n\n    await this.client.core.history.resolve(payload);\n  };\n\n  private cleanup: EnginePrivate[\"cleanup\"] = async () => {\n    const sessionTopics: string[] = [];\n    const proposalIds: number[] = [];\n    this.client.session.getAll().forEach((session) => {\n      let toCleanup = false;\n      if (isExpired(session.expiry)) toCleanup = true;\n      if (!this.client.core.crypto.keychain.has(session.topic)) toCleanup = true;\n      if (toCleanup) sessionTopics.push(session.topic);\n    });\n    this.client.proposal.getAll().forEach((proposal) => {\n      if (isExpired(proposal.expiryTimestamp)) proposalIds.push(proposal.id);\n    });\n    await Promise.all([\n      ...sessionTopics.map((topic) => this.deleteSession({ topic })),\n      ...proposalIds.map((id) => this.deleteProposal(id)),\n    ]);\n  };\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n\n  private async confirmOnlineStateOrThrow() {\n    await this.client.core.relayer.confirmOnlineStateOrThrow();\n  }\n\n  // ---------- Relay Events Router ----------------------------------- //\n\n  private registerRelayerEvents() {\n    this.client.core.relayer.on(RELAYER_EVENTS.message, (event: RelayerTypes.MessageEvent) => {\n      this.onProviderMessageEvent(event);\n    });\n  }\n\n  private onProviderMessageEvent = async (event: RelayerTypes.MessageEvent) => {\n    // capture any messages that arrive before the client is initialized so we can process them after initialization is complete\n    if (!this.initialized || this.relayMessageCache.length > 0) {\n      this.relayMessageCache.push(event);\n    } else {\n      await this.onRelayMessage(event);\n    }\n  };\n\n  private async onRelayMessage(event: RelayerTypes.MessageEvent) {\n    const { topic, message, attestation, transportType } = event;\n\n    // Retrieve the public key (if defined) to decrypt possible `auth_request` response\n    const { publicKey } = this.client.auth.authKeys.keys.includes(AUTH_PUBLIC_KEY_NAME)\n      ? this.client.auth.authKeys.get(AUTH_PUBLIC_KEY_NAME)\n      : ({ responseTopic: undefined, publicKey: undefined } as any);\n\n    try {\n      const payload = await this.client.core.crypto.decode(topic, message, {\n        receiverPublicKey: publicKey,\n        encoding: transportType === TRANSPORT_TYPES.link_mode ? BASE64URL : BASE64,\n      });\n\n      if (isJsonRpcRequest(payload)) {\n        this.client.core.history.set(topic, payload);\n        await this.onRelayEventRequest({\n          topic,\n          payload,\n          attestation,\n          transportType,\n          encryptedId: hashMessage(message),\n        });\n      } else if (isJsonRpcResponse(payload)) {\n        await this.client.core.history.resolve(payload);\n        await this.onRelayEventResponse({ topic, payload, transportType });\n        this.client.core.history.delete(topic, payload.id);\n      } else {\n        await this.onRelayEventUnknownPayload({ topic, payload, transportType });\n      }\n      await this.client.core.relayer.messages.ack(topic, message);\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  }\n\n  private onRelayEventRequest: EnginePrivate[\"onRelayEventRequest\"] = async (event) => {\n    this.requestQueue.queue.push(event);\n    await this.processRequestsQueue();\n  };\n\n  private processRequestsQueue = async () => {\n    if (this.requestQueue.state === ENGINE_QUEUE_STATES.active) {\n      this.client.logger.info(`Request queue already active, skipping...`);\n      return;\n    }\n\n    this.client.logger.info(\n      `Request queue starting with ${this.requestQueue.queue.length} requests`,\n    );\n\n    while (this.requestQueue.queue.length > 0) {\n      this.requestQueue.state = ENGINE_QUEUE_STATES.active;\n      const request = this.requestQueue.queue.shift();\n      if (!request) continue;\n\n      try {\n        await this.processRequest(request);\n      } catch (error) {\n        this.client.logger.warn(error);\n      }\n    }\n    this.requestQueue.state = ENGINE_QUEUE_STATES.idle;\n  };\n\n  private processRequest: EnginePrivate[\"onRelayEventRequest\"] = async (event) => {\n    const { topic, payload, attestation, transportType, encryptedId } = event;\n\n    const reqMethod = payload.method as JsonRpcTypes.WcMethod;\n\n    if (this.shouldIgnorePairingRequest({ topic, requestMethod: reqMethod })) {\n      return;\n    }\n\n    switch (reqMethod) {\n      case \"wc_sessionPropose\":\n        return await this.onSessionProposeRequest({ topic, payload, attestation, encryptedId });\n      case \"wc_sessionSettle\":\n        return await this.onSessionSettleRequest(topic, payload);\n      case \"wc_sessionUpdate\":\n        return await this.onSessionUpdateRequest(topic, payload);\n      case \"wc_sessionExtend\":\n        return await this.onSessionExtendRequest(topic, payload);\n      case \"wc_sessionPing\":\n        return await this.onSessionPingRequest(topic, payload);\n      case \"wc_sessionDelete\":\n        return await this.onSessionDeleteRequest(topic, payload);\n      case \"wc_sessionRequest\":\n        return await this.onSessionRequest({\n          topic,\n          payload,\n          attestation,\n          encryptedId,\n          transportType,\n        });\n      case \"wc_sessionEvent\":\n        return await this.onSessionEventRequest(topic, payload);\n      case \"wc_sessionAuthenticate\":\n        return await this.onSessionAuthenticateRequest({\n          topic,\n          payload,\n          attestation,\n          encryptedId,\n          transportType,\n        });\n      default:\n        return this.client.logger.info(`Unsupported request method ${reqMethod}`);\n    }\n  };\n\n  private onRelayEventResponse: EnginePrivate[\"onRelayEventResponse\"] = async (event) => {\n    const { topic, payload, transportType } = event;\n    const record = await this.client.core.history.get(topic, payload.id);\n    const resMethod = record.request.method as JsonRpcTypes.WcMethod;\n\n    switch (resMethod) {\n      case \"wc_sessionPropose\":\n        return this.onSessionProposeResponse(topic, payload, transportType);\n      case \"wc_sessionSettle\":\n        return this.onSessionSettleResponse(topic, payload);\n      case \"wc_sessionUpdate\":\n        return this.onSessionUpdateResponse(topic, payload);\n      case \"wc_sessionExtend\":\n        return this.onSessionExtendResponse(topic, payload);\n      case \"wc_sessionPing\":\n        return this.onSessionPingResponse(topic, payload);\n      case \"wc_sessionRequest\":\n        return this.onSessionRequestResponse(topic, payload);\n      case \"wc_sessionAuthenticate\":\n        return this.onSessionAuthenticateResponse(topic, payload);\n      default:\n        return this.client.logger.info(`Unsupported response method ${resMethod}`);\n    }\n  };\n\n  private onRelayEventUnknownPayload: EnginePrivate[\"onRelayEventUnknownPayload\"] = (event) => {\n    const { topic } = event;\n    const { message } = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `Decoded payload on topic ${topic} is not identifiable as a JSON-RPC request or a response.`,\n    );\n    throw new Error(message);\n  };\n\n  private shouldIgnorePairingRequest: EnginePrivate[\"shouldIgnorePairingRequest\"] = (params) => {\n    const { topic, requestMethod } = params;\n    const expectedMethods = this.expectedPairingMethodMap.get(topic);\n    // check if the request method matches the expected method\n    if (!expectedMethods) return false;\n    if (expectedMethods.includes(requestMethod)) return false;\n\n    /**\n     * we want to make sure fallback session proposal is ignored only if there are subscribers\n     * for the `session_authenticate` event, otherwise this would result in no-op for the user\n     */\n    if (expectedMethods.includes(\"wc_sessionAuthenticate\")) {\n      if (this.client.events.listenerCount(\"session_authenticate\") > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // ---------- Relay Events Handlers --------------------------------- //\n\n  private onSessionProposeRequest: EnginePrivate[\"onSessionProposeRequest\"] = async (args) => {\n    const { topic, payload, attestation, encryptedId } = args;\n    const { params, id } = payload;\n    try {\n      const event = this.client.core.eventClient.getEvent({ topic });\n\n      if (this.client.events.listenerCount(\"session_proposal\") === 0) {\n        console.warn(\"No listener for session_proposal event\");\n        event?.setError(EVENT_CLIENT_PAIRING_ERRORS.proposal_listener_not_found);\n      }\n\n      this.isValidConnect({ ...payload.params });\n      const expiryTimestamp =\n        params.expiryTimestamp || calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl);\n      const proposal = {\n        id,\n        pairingTopic: topic,\n        expiryTimestamp,\n        attestation,\n        encryptedId,\n        ...params,\n      };\n      await this.setProposal(id, proposal);\n\n      const verifyContext = await this.getVerifyContext({\n        attestationId: attestation,\n        hash: hashMessage(JSON.stringify(payload)),\n        encryptedId,\n        metadata: proposal.proposer.metadata,\n      });\n\n      event?.addTrace(EVENT_CLIENT_PAIRING_TRACES.emit_session_proposal);\n\n      this.client.events.emit(\"session_proposal\", { id, params: proposal, verifyContext });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n        rpcOpts: ENGINE_RPC_OPTS.wc_sessionPropose.autoReject,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionProposeResponse: EnginePrivate[\"onSessionProposeResponse\"] = async (\n    topic,\n    payload,\n    transportType,\n  ) => {\n    const { id } = payload;\n\n    if (isJsonRpcResult(payload)) {\n      const { result } = payload;\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", result });\n      const proposal = this.client.proposal.get(id);\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", proposal });\n      const selfPublicKey = proposal.proposer.publicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        selfPublicKey,\n      });\n      const peerPublicKey = result.responderPublicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        peerPublicKey,\n      });\n      const sessionTopic = await this.client.core.crypto.generateSharedKey(\n        selfPublicKey,\n        peerPublicKey,\n      );\n      this.pendingSessions.set(id, {\n        sessionTopic,\n        pairingTopic: topic,\n        proposalId: id,\n        publicKey: selfPublicKey,\n      });\n\n      const subscriptionId = await this.client.core.relayer.subscribe(sessionTopic, {\n        transportType,\n      });\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        subscriptionId,\n      });\n      await this.client.core.pairing.activate({ topic });\n    } else if (isJsonRpcError(payload)) {\n      await this.deleteProposal(id);\n      const target = engineEvent(\"session_connect\", id);\n      const listeners = this.events.listenerCount(target);\n      if (listeners === 0) {\n        throw new Error(`emitting ${target} without any listeners, 954`);\n      }\n      this.events.emit(target, { error: payload.error });\n    }\n  };\n\n  private onSessionSettleRequest: EnginePrivate[\"onSessionSettleRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      this.isValidSessionSettleRequest(params);\n      const {\n        relay,\n        controller,\n        expiry,\n        namespaces,\n        sessionProperties,\n        scopedProperties,\n        sessionConfig,\n      } = payload.params;\n      const pendingSession = [...this.pendingSessions.values()].find(\n        (s) => s.sessionTopic === topic,\n      );\n\n      if (!pendingSession) {\n        return this.client.logger.error(`Pending session not found for topic ${topic}`);\n      }\n\n      const proposal = this.client.proposal.get(pendingSession.proposalId);\n\n      const session: SessionTypes.Struct = {\n        topic,\n        relay,\n        expiry,\n        namespaces,\n        acknowledged: true,\n        pairingTopic: pendingSession.pairingTopic,\n        requiredNamespaces: proposal.requiredNamespaces,\n        optionalNamespaces: proposal.optionalNamespaces,\n        controller: controller.publicKey,\n        self: {\n          publicKey: pendingSession.publicKey,\n          metadata: this.client.metadata,\n        },\n        peer: {\n          publicKey: controller.publicKey,\n          metadata: controller.metadata,\n        },\n        ...(sessionProperties && { sessionProperties }),\n        ...(scopedProperties && { scopedProperties }),\n        ...(sessionConfig && { sessionConfig }),\n        transportType: TRANSPORT_TYPES.relay,\n      };\n\n      await this.client.session.set(session.topic, session);\n      await this.setExpiry(session.topic, session.expiry);\n\n      await this.client.core.pairing.updateMetadata({\n        topic: pendingSession.pairingTopic,\n        metadata: session.peer.metadata,\n      });\n\n      this.client.events.emit(\"session_connect\", { session });\n      this.events.emit(engineEvent(\"session_connect\", pendingSession.proposalId), { session });\n\n      this.pendingSessions.delete(pendingSession.proposalId);\n      this.deleteProposal(pendingSession.proposalId, false);\n      this.cleanupDuplicatePairings(session);\n\n      await this.sendResult<\"wc_sessionSettle\">({\n        id: payload.id,\n        topic,\n        result: true,\n      });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionSettleResponse: EnginePrivate[\"onSessionSettleResponse\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      await this.client.session.update(topic, { acknowledged: true });\n      this.events.emit(engineEvent(\"session_approve\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      await this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\"));\n      this.events.emit(engineEvent(\"session_approve\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionUpdateRequest: EnginePrivate[\"onSessionUpdateRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { params, id } = payload;\n    try {\n      const memoryKey = `${topic}_session_update`;\n      // compare the current request id with the last processed session update\n      // we want to update only if the request is newer than the last processed one\n      const lastSessionUpdateId = MemoryStore.get<number>(memoryKey);\n\n      if (lastSessionUpdateId && this.isRequestOutOfSync(lastSessionUpdateId, id)) {\n        this.client.logger.warn(`Discarding out of sync request - ${id}`);\n        this.sendError({ id, topic, error: getSdkError(\"INVALID_UPDATE_REQUEST\") });\n        return;\n      }\n      this.isValidUpdate({ topic, ...params });\n      try {\n        MemoryStore.set(memoryKey, id);\n        await this.client.session.update(topic, { namespaces: params.namespaces });\n        await this.sendResult<\"wc_sessionUpdate\">({\n          id,\n          topic,\n          result: true,\n        });\n      } catch (e) {\n        MemoryStore.delete(memoryKey);\n        throw e;\n      }\n\n      this.client.events.emit(\"session_update\", { id, topic, params });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  // compares the timestamp of the last processed request with the current request\n  // client <-> client rpc ID is timestamp + 3 random digits\n  private isRequestOutOfSync = (lastId: number, currentId: number) => {\n    return currentId.toString().slice(0, -3) < lastId.toString().slice(0, -3);\n  };\n\n  private onSessionUpdateResponse: EnginePrivate[\"onSessionUpdateResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_update\", id);\n    const listeners = this.events.listenerCount(target);\n    if (listeners === 0) {\n      throw new Error(`emitting ${target} without any listeners`);\n    }\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionExtendRequest: EnginePrivate[\"onSessionExtendRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidExtend({ topic });\n      await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n      await this.sendResult<\"wc_sessionExtend\">({\n        id,\n        topic,\n        result: true,\n      });\n      this.client.events.emit(\"session_extend\", { id, topic });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionExtendResponse: EnginePrivate[\"onSessionExtendResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_extend\", id);\n    const listeners = this.events.listenerCount(target);\n    if (listeners === 0) {\n      throw new Error(`emitting ${target} without any listeners`);\n    }\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionPingRequest: EnginePrivate[\"onSessionPingRequest\"] = async (topic, payload) => {\n    const { id } = payload;\n    try {\n      this.isValidPing({ topic });\n      await this.sendResult<\"wc_sessionPing\">({\n        id,\n        topic,\n        result: true,\n        throwOnFailedPublish: true,\n      });\n      this.client.events.emit(\"session_ping\", { id, topic });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionPingResponse: EnginePrivate[\"onSessionPingResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_ping\", id);\n\n    // put at the end of the stack to avoid a race condition\n    // where session_ping listener is not yet initialized\n    setTimeout(() => {\n      const listeners = this.events.listenerCount(target);\n      if (listeners === 0) {\n        throw new Error(`emitting ${target} without any listeners 2176`);\n      }\n\n      if (isJsonRpcResult(payload)) {\n        this.events.emit(engineEvent(\"session_ping\", id), {});\n      } else if (isJsonRpcError(payload)) {\n        this.events.emit(engineEvent(\"session_ping\", id), { error: payload.error });\n      }\n    }, 500);\n  };\n\n  private onSessionDeleteRequest: EnginePrivate[\"onSessionDeleteRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidDisconnect({ topic, reason: payload.params });\n      await Promise.all([\n        new Promise((resolve) => {\n          // RPC request needs to happen before deletion as it utilizes session encryption\n          this.client.core.relayer.once(RELAYER_EVENTS.publish, async () => {\n            resolve(await this.deleteSession({ topic, id }));\n          });\n        }),\n        this.sendResult<\"wc_sessionDelete\">({\n          id,\n          topic,\n          result: true,\n        }),\n        this.cleanupPendingSentRequestsForTopic({ topic, error: getSdkError(\"USER_DISCONNECTED\") }),\n      ]).catch((err) => this.client.logger.error(err));\n    } catch (err: any) {\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequest: EnginePrivate[\"onSessionRequest\"] = async (args) => {\n    const { topic, payload, attestation, encryptedId, transportType } = args;\n    const { id, params } = payload;\n    try {\n      await this.isValidRequest({ topic, ...params });\n      const session = this.client.session.get(topic);\n      const verifyContext = await this.getVerifyContext({\n        attestationId: attestation,\n        hash: hashMessage(JSON.stringify(formatJsonRpcRequest(\"wc_sessionRequest\", params, id))),\n        encryptedId,\n        metadata: session.peer.metadata,\n        transportType,\n      });\n      const request = {\n        id,\n        topic,\n        params,\n        verifyContext,\n      };\n      await this.setPendingSessionRequest(request);\n\n      if (\n        transportType === TRANSPORT_TYPES.link_mode &&\n        session.peer.metadata.redirect?.universal\n      ) {\n        // save app as supported for link mode\n        this.client.core.addLinkModeSupportedApp(session.peer.metadata.redirect?.universal);\n      }\n\n      // without sequential processing. This bypasses deduplication provided by the queue,\n      // at-least-once delivery guarantee.\n      if (this.client.signConfig?.disableRequestQueue) {\n        this.emitSessionRequest(request);\n      } else {\n        this.addSessionRequestToSessionRequestQueue(request);\n        this.processSessionRequestQueue();\n      }\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequestResponse: EnginePrivate[\"onSessionRequestResponse\"] = (\n    _topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_request\", id);\n    const listeners = this.events.listenerCount(target);\n    if (listeners === 0) {\n      throw new Error(`emitting ${target} without any listeners`);\n    }\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { result: payload.result });\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionEventRequest: EnginePrivate[\"onSessionEventRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      // similar to session update, we want to discard out of sync requests\n      // additionally we have to check the event type as well e.g. chainChanged/accountsChanged\n      const memoryKey = `${topic}_session_event_${params.event.name}`;\n      // compare the current request id with the last processed session update\n      // we want to update only if the request is newer than the last processed one\n      const lastSessionUpdateId = MemoryStore.get<number>(memoryKey);\n      if (lastSessionUpdateId && this.isRequestOutOfSync(lastSessionUpdateId, id)) {\n        this.client.logger.info(`Discarding out of sync request - ${id}`);\n        return;\n      }\n\n      this.isValidEmit({ topic, ...params });\n      this.client.events.emit(\"session_event\", { id, topic, params });\n      MemoryStore.set(memoryKey, id);\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionAuthenticateResponse: EnginePrivate[\"onSessionAuthenticateResponse\"] = (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    this.client.logger.trace({\n      type: \"method\",\n      method: \"onSessionAuthenticateResponse\",\n      topic,\n      payload,\n    });\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { result: payload.result });\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionAuthenticateRequest: EnginePrivate[\"onSessionAuthenticateRequest\"] = async (\n    args,\n  ) => {\n    const { topic, payload, attestation, encryptedId, transportType } = args;\n    try {\n      const { requester, authPayload, expiryTimestamp } = payload.params;\n      const verifyContext = await this.getVerifyContext({\n        attestationId: attestation,\n        hash: hashMessage(JSON.stringify(payload)),\n        encryptedId,\n        metadata: requester.metadata,\n        transportType,\n      });\n      const pendingRequest = {\n        requester,\n        pairingTopic: topic,\n        id: payload.id,\n        authPayload,\n        verifyContext,\n        expiryTimestamp,\n      };\n      await this.setAuthRequest(payload.id, {\n        request: pendingRequest,\n        pairingTopic: topic,\n        transportType,\n      });\n\n      if (transportType === TRANSPORT_TYPES.link_mode && requester.metadata.redirect?.universal) {\n        // save app as supported for link mode\n        this.client.core.addLinkModeSupportedApp(requester.metadata.redirect.universal);\n      }\n\n      this.client.events.emit(\"session_authenticate\", {\n        topic,\n        params: payload.params,\n        id: payload.id,\n        verifyContext,\n      });\n    } catch (err: any) {\n      this.client.logger.error(err);\n\n      const receiverPublicKey = payload.params.requester.publicKey;\n      const senderPublicKey = await this.client.core.crypto.generateKeyPair();\n      const appLink = this.getAppLinkIfEnabled(payload.params.requester.metadata, transportType);\n\n      const encodeOpts = {\n        type: TYPE_1,\n        receiverPublicKey,\n        senderPublicKey,\n      };\n      await this.sendError({\n        id: payload.id,\n        topic,\n        error: err,\n        encodeOpts,\n        rpcOpts: ENGINE_RPC_OPTS.wc_sessionAuthenticate.autoReject,\n        appLink,\n      });\n    }\n  };\n\n  /**\n   * Adds a session request to the sequential processing queue.\n   *\n   * The queue provides built-in deduplication and sequential processing,\n   * which helps handle WalletConnect's at-least-once delivery guarantee.\n   */\n  private addSessionRequestToSessionRequestQueue = (request: PendingRequestTypes.Struct) => {\n    this.sessionRequestQueue.queue.push(request);\n  };\n\n  private cleanupAfterResponse = (params: EngineTypes.RespondParams) => {\n    this.deletePendingSessionRequest(params.response.id, { message: \"fulfilled\", code: 0 });\n    // intentionally delay the emitting of the next pending request a bit\n    setTimeout(() => {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;\n      this.processSessionRequestQueue();\n    }, toMiliseconds(this.requestQueueDelay));\n  };\n\n  // Allows for cleanup on any sent pending requests if the peer disconnects the session before responding\n  private cleanupPendingSentRequestsForTopic = ({\n    topic,\n    error,\n  }: {\n    topic: string;\n    error: ErrorResponse;\n  }) => {\n    const pendingRequests = this.client.core.history.pending;\n    if (pendingRequests.length > 0) {\n      const forSession = pendingRequests.filter(\n        (r) => r.topic === topic && r.request.method === \"wc_sessionRequest\",\n      );\n      forSession.forEach((r) => {\n        const id = r.request.id;\n        const target = engineEvent(\"session_request\", id);\n        const listeners = this.events.listenerCount(target);\n        if (listeners === 0) {\n          throw new Error(`emitting ${target} without any listeners`);\n        }\n        // notify .request() handler of the rejection\n        this.events.emit(engineEvent(\"session_request\", r.request.id), {\n          error,\n        });\n      });\n    }\n  };\n\n  private processSessionRequestQueue = () => {\n    if (this.sessionRequestQueue.state === ENGINE_QUEUE_STATES.active) {\n      this.client.logger.info(\"session request queue is already active.\");\n      return;\n    }\n    // Select the first/oldest request in the array to ensure last-in-first-out (LIFO)\n    const request = this.sessionRequestQueue.queue[0];\n    if (!request) {\n      this.client.logger.info(\"session request queue is empty.\");\n      return;\n    }\n\n    try {\n      this.emitSessionRequest(request);\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  };\n\n  /**\n   * Emits a session request event with built-in deduplication.\n   *\n   * This method implements deduplication using emittedSessionRequests set to handle\n   * WalletConnect's at-least-once delivery guarantee. However, when disableRequestQueue\n   * is enabled, additional deduplication may be needed at the consumer level.\n   */\n  private emitSessionRequest = (request: PendingRequestTypes.Struct) => {\n    if (this.emittedSessionRequests.has(request.id)) {\n      this.client.logger.warn(\n        {\n          id: request.id,\n        },\n        `Skipping emitting \\`session_request\\` event for duplicate request. id: ${request.id}`,\n      );\n      return;\n    }\n    this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.active;\n    this.emittedSessionRequests.add(request.id);\n    this.client.events.emit(\"session_request\", request);\n  };\n\n  // ---------- Expirer Events ---------------------------------------- //\n\n  private registerExpirerEvents() {\n    this.client.core.expirer.on(EXPIRER_EVENTS.expired, async (event: ExpirerTypes.Expiration) => {\n      const { topic, id } = parseExpirerTarget(event.target);\n      if (id && this.client.pendingRequest.keys.includes(id)) {\n        return await this.deletePendingSessionRequest(id, getInternalError(\"EXPIRED\"), true);\n      }\n      if (id && this.client.auth.requests.keys.includes(id)) {\n        return await this.deletePendingAuthRequest(id, getInternalError(\"EXPIRED\"), true);\n      }\n\n      if (topic) {\n        if (this.client.session.keys.includes(topic)) {\n          await this.deleteSession({ topic, expirerHasDeleted: true });\n          this.client.events.emit(\"session_expire\", { topic });\n        }\n      } else if (id) {\n        await this.deleteProposal(id, true);\n        this.client.events.emit(\"proposal_expire\", { id });\n      }\n    });\n  }\n\n  // ---------- Pairing Events ---------------------------------------- //\n  private registerPairingEvents() {\n    this.client.core.pairing.events.on(PAIRING_EVENTS.create, (pairing: PairingTypes.Struct) =>\n      this.onPairingCreated(pairing),\n    );\n    this.client.core.pairing.events.on(PAIRING_EVENTS.delete, (pairing: PairingTypes.Struct) => {\n      this.addToRecentlyDeleted(pairing.topic, \"pairing\");\n    });\n  }\n\n  /**\n   * when a pairing is created, we check if there is a pending proposal for it.\n   * if there is, we send it to onSessionProposeRequest to be processed as if it was received from the relay.\n   * It allows QR/URI to be scanned multiple times without having to create new pairing.\n   */\n  private onPairingCreated = (pairing: PairingTypes.Struct) => {\n    if (pairing.methods) {\n      this.expectedPairingMethodMap.set(pairing.topic, pairing.methods);\n    }\n    if (pairing.active) return;\n    const proposals = this.client.proposal.getAll();\n    const proposal = proposals.find((p) => p.pairingTopic === pairing.topic);\n    if (!proposal) return;\n    this.onSessionProposeRequest({\n      topic: pairing.topic,\n      payload: formatJsonRpcRequest(\n        \"wc_sessionPropose\",\n        {\n          ...proposal,\n          requiredNamespaces: proposal.requiredNamespaces,\n          optionalNamespaces: proposal.optionalNamespaces,\n          relays: proposal.relays,\n          proposer: proposal.proposer,\n          sessionProperties: proposal.sessionProperties,\n          scopedProperties: proposal.scopedProperties,\n        },\n        proposal.id,\n      ),\n      attestation: proposal.attestation,\n      encryptedId: proposal.encryptedId,\n    });\n  };\n\n  // ---------- Validation Helpers ------------------------------------ //\n  private isValidPairingTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.core.pairing.pairings.get(topic).expiry)) {\n      const { message } = getInternalError(\"EXPIRED\", `pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    // Store will throw custom message if topic was recently deleted\n    this.checkRecentlyDeleted(topic);\n    if (!this.client.session.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.session.get(topic).expiry)) {\n      await this.deleteSession({ topic });\n      const { message } = getInternalError(\"EXPIRED\", `session topic: ${topic}`);\n      throw new Error(message);\n    }\n\n    if (!this.client.core.crypto.keychain.has(topic)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session topic does not exist in keychain: ${topic}`,\n      );\n      await this.deleteSession({ topic });\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionOrPairingTopic(topic: string) {\n    this.checkRecentlyDeleted(topic);\n    if (this.client.session.keys.includes(topic)) {\n      await this.isValidSessionTopic(topic);\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      this.isValidPairingTopic(topic);\n    } else if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session or pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    } else {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session or pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n  }\n\n  private async isValidProposalId(id: any) {\n    if (!isValidId(id)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `proposal id should be a number: ${id}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.proposal.keys.includes(id)) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${id}`);\n      throw new Error(message);\n    }\n    if (isExpired(this.client.proposal.get(id).expiryTimestamp)) {\n      await this.deleteProposal(id);\n      const { message } = getInternalError(\"EXPIRED\", `proposal id: ${id}`);\n      throw new Error(message);\n    }\n  }\n\n  // ---------- Validation  ------------------------------------------- //\n\n  private isValidConnect: EnginePrivate[\"isValidConnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `connect() params: ${JSON.stringify(params)}`,\n      );\n      throw new Error(message);\n    }\n    const {\n      pairingTopic,\n      requiredNamespaces,\n      optionalNamespaces,\n      sessionProperties,\n      scopedProperties,\n      relays,\n    } = params;\n    if (!isUndefined(pairingTopic)) await this.isValidPairingTopic(pairingTopic);\n\n    if (!isValidRelays(relays, true)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `connect() relays: ${relays}`);\n      throw new Error(message);\n    }\n\n    // validate required namespaces only if they are defined\n    if (!isUndefined(requiredNamespaces) && isValidObject(requiredNamespaces) !== 0) {\n      const warning =\n        \"requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces\";\n      // if logger level is one of the following, the logger.warn will not be shown, so we need to use console.warn\n      if ([\"fatal\", \"error\", \"silent\"].includes(this.client.logger.level)) {\n        console.warn(warning);\n      } else {\n        this.client.logger.warn(warning);\n      }\n      this.validateNamespaces(requiredNamespaces, \"requiredNamespaces\");\n    }\n\n    // validate optional namespaces only if they are defined\n    if (!isUndefined(optionalNamespaces) && isValidObject(optionalNamespaces) !== 0) {\n      this.validateNamespaces(optionalNamespaces, \"optionalNamespaces\");\n    }\n\n    // validate session properties only if they are defined\n    if (!isUndefined(sessionProperties)) {\n      this.validateSessionProps(sessionProperties, \"sessionProperties\");\n    }\n\n    if (!isUndefined(scopedProperties)) {\n      this.validateSessionProps(scopedProperties, \"scopedProperties\");\n\n      const requestedNamespaces = Object.keys(requiredNamespaces || {}).concat(\n        Object.keys(optionalNamespaces || {}),\n      );\n\n      const scopedNamespaces = Object.keys(scopedProperties);\n      // .split(\":\")[0] to account for inline <namespace>:<chainId>\n      const valid = scopedNamespaces.every((ns) => requestedNamespaces.includes(ns.split(\":\")[0]));\n      if (!valid) {\n        throw new Error(\n          `Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(\n            scopedProperties,\n          )}, required/optional namespaces: ${JSON.stringify(requestedNamespaces)}`,\n        );\n      }\n    }\n  };\n\n  private validateNamespaces = (\n    namespaces: ProposalTypes.RequiredNamespaces | ProposalTypes.OptionalNamespaces,\n    type: string,\n  ) => {\n    const validRequiredNamespacesError = isValidRequiredNamespaces(namespaces, \"connect()\", type);\n    if (validRequiredNamespacesError) throw new Error(validRequiredNamespacesError.message);\n  };\n\n  private isValidApprove: EnginePrivate[\"isValidApprove\"] = async (params) => {\n    if (!isValidParams(params))\n      throw new Error(\n        getInternalError(\"MISSING_OR_INVALID\", `approve() params: ${params}`).message,\n      );\n    const { id, namespaces, relayProtocol, sessionProperties, scopedProperties } = params;\n\n    this.checkRecentlyDeleted(id);\n    await this.isValidProposalId(id);\n    const proposal = this.client.proposal.get(id);\n    const validNamespacesError = isValidNamespaces(namespaces, \"approve()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      proposal.requiredNamespaces,\n      namespaces,\n      \"approve()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    if (!isValidString(relayProtocol, true)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `approve() relayProtocol: ${relayProtocol}`,\n      );\n      throw new Error(message);\n    }\n\n    if (!isUndefined(sessionProperties)) {\n      this.validateSessionProps(sessionProperties, \"sessionProperties\");\n    }\n\n    if (!isUndefined(scopedProperties)) {\n      this.validateSessionProps(scopedProperties, \"scopedProperties\");\n\n      const approvedNamespaces = new Set(Object.keys(namespaces));\n      const scopedNamespaces = Object.keys(scopedProperties);\n\n      // the approved scoped namespaces must be a subset of the approved namespaces\n      // .split(\":\")[0] to account for inline <namespace>:<chainId>\n      const valid = scopedNamespaces.every((ns) => approvedNamespaces.has(ns.split(\":\")[0]));\n      if (!valid) {\n        throw new Error(\n          `Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(\n            scopedProperties,\n          )}, approved namespaces: ${Array.from(approvedNamespaces).join(\", \")}`,\n        );\n      }\n    }\n  };\n\n  private isValidReject: EnginePrivate[\"isValidReject\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `reject() params: ${params}`);\n      throw new Error(message);\n    }\n    const { id, reason } = params;\n    this.checkRecentlyDeleted(id);\n    await this.isValidProposalId(id);\n    if (!isValidErrorReason(reason)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `reject() reason: ${JSON.stringify(reason)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidSessionSettleRequest: EnginePrivate[\"isValidSessionSettleRequest\"] = (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() params: ${params}`,\n      );\n      throw new Error(message);\n    }\n    const { relay, controller, namespaces, expiry } = params;\n    if (!isValidRelay(relay)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() relay protocol should be a string`,\n      );\n      throw new Error(message);\n    }\n    const validControllerError = isValidController(controller, \"onSessionSettleRequest()\");\n    if (validControllerError) throw new Error(validControllerError.message);\n    const validNamespacesError = isValidNamespaces(namespaces, \"onSessionSettleRequest()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    if (isExpired(expiry)) {\n      const { message } = getInternalError(\"EXPIRED\", `onSessionSettleRequest()`);\n      throw new Error(message);\n    }\n  };\n\n  private isValidUpdate: EnginePrivate[\"isValidUpdate\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `update() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, namespaces } = params;\n\n    this.checkRecentlyDeleted(topic);\n    await this.isValidSessionTopic(topic);\n    const session = this.client.session.get(topic);\n    const validNamespacesError = isValidNamespaces(namespaces, \"update()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      session.requiredNamespaces,\n      namespaces,\n      \"update()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    // TODO(ilja) - check if wallet\n  };\n\n  private isValidExtend: EnginePrivate[\"isValidExtend\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `extend() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n\n    this.checkRecentlyDeleted(topic);\n    await this.isValidSessionTopic(topic);\n  };\n\n  private isValidRequest: EnginePrivate[\"isValidRequest\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, request, chainId, expiry } = params;\n    this.checkRecentlyDeleted(topic);\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidRequest(request)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() ${JSON.stringify(request)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesRequest(namespaces, chainId, request.method)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() method: ${request.method}`,\n      );\n      throw new Error(message);\n    }\n    if (expiry && !isValidRequestExpiry(expiry, SESSION_REQUEST_EXPIRY_BOUNDARIES)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() expiry: ${expiry}. Expiry must be a number (in seconds) between ${SESSION_REQUEST_EXPIRY_BOUNDARIES.min} and ${SESSION_REQUEST_EXPIRY_BOUNDARIES.max}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidRespond: EnginePrivate[\"isValidRespond\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `respond() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, response } = params;\n    try {\n      // if the session is already disconnected, we can't respond to the request so we need to delete it\n      await this.isValidSessionTopic(topic);\n    } catch (error) {\n      if (params?.response?.id) this.cleanupAfterResponse(params);\n      throw error;\n    }\n    if (!isValidResponse(response)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `respond() response: ${JSON.stringify(response)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidPing: EnginePrivate[\"isValidPing\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `ping() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n\n  private isValidEmit: EnginePrivate[\"isValidEmit\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, event, chainId } = params;\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidEvent(event)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesEvent(namespaces, chainId, event.name)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidDisconnect: EnginePrivate[\"isValidDisconnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `disconnect() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n\n  private isValidAuthenticate = (params: AuthTypes.SessionAuthenticateParams) => {\n    const { chains, uri, domain, nonce } = params;\n\n    // ----- validate params ----- //\n    if (!Array.isArray(chains) || chains.length === 0) {\n      throw new Error(\"chains is required and must be a non-empty array\");\n    }\n    if (!isValidString(uri, false)) {\n      throw new Error(\"uri is required parameter\");\n    }\n    if (!isValidString(domain, false)) {\n      throw new Error(\"domain is required parameter\");\n    }\n    if (!isValidString(nonce, false)) {\n      throw new Error(\"nonce is required parameter\");\n    }\n\n    // ----- reject multi namespaces ----- //\n    const uniqueNamespaces = [...new Set(chains.map((chain) => parseChainId(chain).namespace))];\n    if (uniqueNamespaces.length > 1) {\n      throw new Error(\n        \"Multi-namespace requests are not supported. Please request single namespace only.\",\n      );\n    }\n\n    const { namespace } = parseChainId(chains[0]);\n    if (namespace !== \"eip155\") {\n      throw new Error(\n        \"Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.\",\n      );\n    }\n  };\n\n  private getVerifyContext = async (params: {\n    attestationId?: string;\n    hash?: string;\n    encryptedId?: string;\n    metadata: CoreTypes.Metadata;\n    transportType?: RelayerTypes.TransportType;\n  }) => {\n    const { attestationId, hash, encryptedId, metadata, transportType } = params;\n    const context: Verify.Context = {\n      verified: {\n        verifyUrl: metadata.verifyUrl || VERIFY_SERVER,\n        validation: \"UNKNOWN\",\n        origin: metadata.url || \"\",\n      },\n    };\n\n    try {\n      if (transportType === TRANSPORT_TYPES.link_mode) {\n        const applink = this.getAppLinkIfEnabled(metadata, transportType);\n        context.verified.validation =\n          applink && new URL(applink).origin === new URL(metadata.url).origin ? \"VALID\" : \"INVALID\";\n        return context;\n      }\n      const result = await this.client.core.verify.resolve({\n        attestationId,\n        hash,\n        encryptedId,\n        verifyUrl: metadata.verifyUrl,\n      });\n      if (result) {\n        context.verified.origin = result.origin;\n        context.verified.isScam = result.isScam;\n        context.verified.validation =\n          result.origin === new URL(metadata.url).origin ? \"VALID\" : \"INVALID\";\n      }\n    } catch (e) {\n      this.client.logger.warn(e);\n    }\n\n    this.client.logger.debug(`Verify context: ${JSON.stringify(context)}`);\n    return context;\n  };\n\n  private validateSessionProps = (properties: SessionTypes.ScopedProperties, type: string) => {\n    Object.values(properties).forEach((property, index) => {\n      if (property === null || property === undefined) {\n        const { message } = getInternalError(\n          \"MISSING_OR_INVALID\",\n          `${type} must contain an existing value for each key. Received: ${property} for key ${\n            Object.keys(properties)[index]\n          }`,\n        );\n        throw new Error(message);\n      }\n    });\n  };\n\n  private getPendingAuthRequest = (id: number) => {\n    const request = this.client.auth.requests.get(id);\n    return typeof request === \"object\" ? request : undefined;\n  };\n\n  private addToRecentlyDeleted = (\n    id: string | number,\n    type: \"pairing\" | \"session\" | \"proposal\" | \"request\",\n  ) => {\n    this.recentlyDeletedMap.set(id, type);\n    // remove first half of the map if it exceeds the limit\n    if (this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {\n      let i = 0;\n      const numItemsToDelete = this.recentlyDeletedLimit / 2;\n      for (const k of this.recentlyDeletedMap.keys()) {\n        if (i++ >= numItemsToDelete) {\n          break;\n        }\n        this.recentlyDeletedMap.delete(k);\n      }\n    }\n  };\n\n  private checkRecentlyDeleted = (id: string | number) => {\n    const deletedRecord = this.recentlyDeletedMap.get(id);\n    if (deletedRecord) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `Record was recently deleted - ${deletedRecord}: ${id}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isLinkModeEnabled = (\n    peerMetadata?: CoreTypes.Metadata,\n    transportType?: RelayerTypes.TransportType,\n  ): boolean => {\n    if (!peerMetadata || transportType !== TRANSPORT_TYPES.link_mode) return false;\n\n    return (\n      this.client.metadata?.redirect?.linkMode === true &&\n      this.client.metadata?.redirect?.universal !== undefined &&\n      this.client.metadata?.redirect?.universal !== \"\" &&\n      peerMetadata?.redirect?.universal !== undefined &&\n      peerMetadata?.redirect?.universal !== \"\" &&\n      peerMetadata?.redirect?.linkMode === true &&\n      this.client.core.linkModeSupportedApps.includes(peerMetadata.redirect.universal) &&\n      typeof (global as any)?.Linking !== \"undefined\"\n    );\n  };\n\n  private getAppLinkIfEnabled = (\n    peerMetadata?: CoreTypes.Metadata,\n    transportType?: RelayerTypes.TransportType,\n  ): string | undefined => {\n    return this.isLinkModeEnabled(peerMetadata, transportType)\n      ? peerMetadata?.redirect?.universal\n      : undefined;\n  };\n\n  private handleLinkModeMessage = ({ url }: { url: string }) => {\n    if (!url || !url.includes(\"wc_ev\") || !url.includes(\"topic\")) return;\n\n    const topic = getSearchParamFromURL(url, \"topic\") || \"\";\n    const message = decodeURIComponent(getSearchParamFromURL(url, \"wc_ev\") || \"\");\n\n    const sessionExists = this.client.session.keys.includes(topic);\n\n    if (sessionExists) {\n      this.client.session.update(topic, { transportType: TRANSPORT_TYPES.link_mode });\n    }\n\n    this.client.core.dispatchEnvelope({ topic, message, sessionExists });\n  };\n\n  private registerLinkModeListeners = async () => {\n    if (isTestRun() || (isReactNative() && this.client.metadata.redirect?.linkMode)) {\n      const linking = (global as any)?.Linking;\n      // global.Linking is set by react-native-compat\n      if (typeof linking !== \"undefined\") {\n        // set URL listener\n        linking.addEventListener(\"url\", this.handleLinkModeMessage, this.client.name);\n\n        // check for initial URL -> cold boots\n        const initialUrl = await linking.getInitialURL();\n        if (initialUrl) {\n          // wait to process the message to allow event listeners to be registered by the implementing app\n          setTimeout(() => {\n            this.handleLinkModeMessage({ url: initialUrl });\n          }, 50);\n        }\n      }\n    }\n  };\n\n  private getTVFParams = (\n    id: number,\n    params: JsonRpcTypes.RequestParams[\"wc_sessionRequest\"],\n    result?: any,\n  ) => {\n    // this check will filter all Sign protocol methods since they don't have a method property\n    if (!params.request?.method) {\n      return {};\n    }\n\n    const tvf: RelayerTypes.ITVF = {\n      correlationId: id,\n      rpcMethods: [params.request.method],\n      chainId: params.chainId,\n    };\n    try {\n      const txHashes = this.extractTxHashesFromResult(params.request, result);\n      tvf.txHashes = txHashes;\n      tvf.contractAddresses = this.isValidContractData(params.request.params)\n        ? [params.request.params?.[0]?.to]\n        : [];\n    } catch (e) {\n      this.client.logger.warn(\"Error getting TVF params\", e);\n    }\n    return tvf;\n  };\n\n  private isValidContractData = (params: any) => {\n    if (!params) return false;\n    try {\n      const data = params?.data || params?.[0]?.data;\n\n      if (!data.startsWith(\"0x\")) return false;\n\n      const hexPart = data.slice(2);\n      if (!/^[0-9a-fA-F]*$/.test(hexPart)) return false;\n\n      return hexPart.length % 2 === 0;\n    } catch (e) {}\n    return false;\n  };\n\n  private extractTxHashesFromResult = (\n    request: JsonRpcTypes.RequestParams[\"wc_sessionRequest\"][\"request\"],\n    result: any,\n  ): string[] => {\n    try {\n      if (!result) return [];\n\n      const method = request.method;\n      const methodConfig = TVF_METHODS[method as keyof typeof TVF_METHODS];\n\n      if (method === \"sui_signTransaction\") {\n        return [getSuiDigest(result.transactionBytes)];\n      }\n\n      if (method === \"near_signTransaction\") {\n        return [getNearTransactionIdFromSignedTransaction(result)];\n      }\n\n      if (method === \"near_signTransactions\") {\n        return result.map((tx: any) => getNearTransactionIdFromSignedTransaction(tx));\n      }\n\n      if (method === \"xrpl_signTransactionFor\" || method === \"xrpl_signTransaction\") {\n        return [result.tx_json?.hash];\n      }\n\n      if (method === \"polkadot_signTransaction\") {\n        return [\n          buildSignedExtrinsicHash({\n            transaction: request.params.transactionPayload,\n            signature: result.signature,\n          }),\n        ];\n      }\n\n      if (method === \"algo_signTxn\") {\n        return isValidArray(result)\n          ? result.map((tx: any) => getAlgorandTransactionId(tx))\n          : [getAlgorandTransactionId(result)];\n      }\n\n      if (method === \"cosmos_signDirect\") {\n        return [getSignDirectHash(result)];\n      }\n\n      if (method === \"wallet_sendCalls\") {\n        return getWalletSendCallsHashes(result);\n      }\n\n      // result = 0x...\n      if (typeof result === \"string\") {\n        return [result];\n      }\n\n      // result = { key: [0x...] } or { key: 0x... }\n      const hashes: string[] = result[methodConfig.key];\n\n      // result = { key: [0x...] }\n      if (isValidArray(hashes)) {\n        if (method === \"solana_signAllTransactions\") {\n          return hashes.map((hash) => extractSolanaTransactionId(hash));\n        }\n\n        return hashes;\n\n        // result = { key: 0x... }\n      } else if (typeof hashes === \"string\") {\n        return [hashes];\n      }\n    } catch (e) {\n      this.client.logger.warn(\"Error extracting tx hashes from result\", e);\n    }\n    return [];\n  };\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { IKeyValueStorage } from \"@walletconnect/keyvaluestorage\";\nimport { ICore } from \"./core\";\n\nexport declare namespace Verify {\n  export interface Context {\n    verified: {\n      origin: string;\n      validation: \"UNKNOWN\" | \"VALID\" | \"INVALID\";\n      verifyUrl: string;\n      isScam?: boolean;\n    };\n  }\n}\n\nexport abstract class IVerify {\n  public abstract readonly context: string;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public store: IKeyValueStorage,\n  ) {}\n\n  public abstract register(params: {\n    id: string;\n    decryptedId: string;\n  }): Promise<string | undefined>;\n\n  public abstract resolve(params: {\n    attestationId?: string;\n    hash?: string;\n    encryptedId?: string;\n    verifyUrl?: string;\n  }): Promise<{ origin: string; isScam?: boolean }>;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { IKeyValueStorage } from \"@walletconnect/keyvaluestorage\";\nimport { ICore } from \"./core\";\n\nexport declare namespace Verify {\n  export interface Context {\n    verified: {\n      origin: string;\n      validation: \"UNKNOWN\" | \"VALID\" | \"INVALID\";\n      verifyUrl: string;\n      isScam?: boolean;\n    };\n  }\n}\n\nexport abstract class IVerify {\n  public abstract readonly context: string;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public store: IKeyValueStorage,\n  ) {}\n\n  public abstract register(params: {\n    id: string;\n    decryptedId: string;\n  }): Promise<string | undefined>;\n\n  public abstract resolve(params: {\n    attestationId?: string;\n    hash?: string;\n    encryptedId?: string;\n    verifyUrl?: string;\n  }): Promise<{ origin: string; isScam?: boolean }>;\n}\n","export const RELAYER_DEFAULT_PROTOCOL = \"irn\";\n\nexport const RELAYER_DEFAULT_LOGGER = \"error\";\n\nexport const RELAYER_DEFAULT_RELAY_URL = \"wss://relay.walletconnect.org\";\n\nexport const RELAYER_CONTEXT = \"relayer\";\n\nexport const RELAYER_EVENTS = {\n  message: \"relayer_message\",\n  message_ack: \"relayer_message_ack\",\n  connect: \"relayer_connect\",\n  disconnect: \"relayer_disconnect\",\n  error: \"relayer_error\",\n  connection_stalled: \"relayer_connection_stalled\",\n  transport_closed: \"relayer_transport_closed\",\n  publish: \"relayer_publish\",\n};\n\nexport const RELAYER_SUBSCRIBER_SUFFIX = \"_subscription\";\n\nexport const RELAYER_PROVIDER_EVENTS = {\n  payload: \"payload\",\n  connect: \"connect\",\n  disconnect: \"disconnect\",\n  error: \"error\",\n};\n\nexport const RELAYER_RECONNECT_TIMEOUT = 0.1;\n\nexport const RELAYER_STORAGE_OPTIONS = {\n  database: \":memory:\",\n};\n\n// Updated automatically via `new-version` npm script.\n\nexport const RELAYER_SDK_VERSION = \"2.21.9\";\n\n// delay to wait before closing the transport connection after init if not active\nexport const RELAYER_TRANSPORT_CUTOFF = 10_000;\n\nexport const TRANSPORT_TYPES = {\n  link_mode: \"link_mode\",\n  relay: \"relay\",\n} as const;\n\nexport const MESSAGE_DIRECTION = {\n  inbound: \"inbound\",\n  outbound: \"outbound\",\n} as const;\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, ProposalTypes } from \"@walletconnect/types\";\n\nimport { SIGN_CLIENT_STORAGE_PREFIX, PROPOSAL_CONTEXT } from \"../constants\";\n\nexport class Proposal extends Store<number, ProposalTypes.Struct> {\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    super(core, logger, PROPOSAL_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);\n  }\n}\n","const regexpTag = '[object RegExp]';\nconst stringTag = '[object String]';\nconst numberTag = '[object Number]';\nconst booleanTag = '[object Boolean]';\nconst argumentsTag = '[object Arguments]';\nconst symbolTag = '[object Symbol]';\nconst dateTag = '[object Date]';\nconst mapTag = '[object Map]';\nconst setTag = '[object Set]';\nconst arrayTag = '[object Array]';\nconst functionTag = '[object Function]';\nconst arrayBufferTag = '[object ArrayBuffer]';\nconst objectTag = '[object Object]';\nconst errorTag = '[object Error]';\nconst dataViewTag = '[object DataView]';\nconst uint8ArrayTag = '[object Uint8Array]';\nconst uint8ClampedArrayTag = '[object Uint8ClampedArray]';\nconst uint16ArrayTag = '[object Uint16Array]';\nconst uint32ArrayTag = '[object Uint32Array]';\nconst bigUint64ArrayTag = '[object BigUint64Array]';\nconst int8ArrayTag = '[object Int8Array]';\nconst int16ArrayTag = '[object Int16Array]';\nconst int32ArrayTag = '[object Int32Array]';\nconst bigInt64ArrayTag = '[object BigInt64Array]';\nconst float32ArrayTag = '[object Float32Array]';\nconst float64ArrayTag = '[object Float64Array]';\n\nexport { argumentsTag, arrayBufferTag, arrayTag, bigInt64ArrayTag, bigUint64ArrayTag, booleanTag, dataViewTag, dateTag, errorTag, float32ArrayTag, float64ArrayTag, functionTag, int16ArrayTag, int32ArrayTag, int8ArrayTag, mapTag, numberTag, objectTag, regexpTag, setTag, stringTag, symbolTag, uint16ArrayTag, uint32ArrayTag, uint8ArrayTag, uint8ClampedArrayTag };\n","export const STORE_STORAGE_VERSION = \"0.3\";\n\nexport const WALLETCONNECT_CLIENT_ID = \"WALLETCONNECT_CLIENT_ID\";\nexport const WALLETCONNECT_LINK_MODE_APPS = \"WALLETCONNECT_LINK_MODE_APPS\";\n","import { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport declare namespace EventClientTypes {\n  export interface Event {\n    eventId: string;\n    bundleId: string;\n    timestamp: number;\n    props: Props;\n    addTrace: (trace: string) => void;\n    setError: (error: string) => void;\n  }\n\n  export interface Props {\n    event: string;\n    type: string;\n    properties: Properties;\n  }\n\n  export interface Properties {\n    topic: string;\n    trace: Trace;\n  }\n\n  export type Trace = string[];\n}\n\nexport abstract class IEventClient {\n  public abstract readonly context: string;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public telemetryEnabled: boolean,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract createEvent(params: {\n    event?: \"ERROR\";\n    type?: string;\n    properties: {\n      topic: string;\n      trace: EventClientTypes.Trace;\n    };\n  }): EventClientTypes.Event;\n\n  public abstract getEvent(params: {\n    eventId?: string;\n    topic?: string;\n  }): EventClientTypes.Event | undefined;\n\n  public abstract deleteEvent(params: { eventId: string }): void;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport declare namespace EventClientTypes {\n  export interface Event {\n    eventId: string;\n    bundleId: string;\n    timestamp: number;\n    props: Props;\n    addTrace: (trace: string) => void;\n    setError: (error: string) => void;\n  }\n\n  export interface Props {\n    event: string;\n    type: string;\n    properties: Properties;\n  }\n\n  export interface Properties {\n    topic: string;\n    trace: Trace;\n  }\n\n  export type Trace = string[];\n}\n\nexport abstract class IEventClient {\n  public abstract readonly context: string;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public telemetryEnabled: boolean,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract createEvent(params: {\n    event?: \"ERROR\";\n    type?: string;\n    properties: {\n      topic: string;\n      trace: EventClientTypes.Trace;\n    };\n  }): EventClientTypes.Event;\n\n  public abstract getEvent(params: {\n    eventId?: string;\n    topic?: string;\n  }): EventClientTypes.Event | undefined;\n\n  public abstract deleteEvent(params: { eventId: string }): void;\n}\n","import { THIRTY_DAYS, FIVE_SECONDS } from \"@walletconnect/time\";\n\nexport const SUBSCRIBER_EVENTS = {\n  created: \"subscription_created\",\n  deleted: \"subscription_deleted\",\n  expired: \"subscription_expired\",\n  disabled: \"subscription_disabled\",\n  sync: \"subscription_sync\",\n  resubscribed: \"subscription_resubscribed\",\n};\n\nexport const SUBSCRIBER_DEFAULT_TTL = THIRTY_DAYS;\n\nexport const SUBSCRIBER_CONTEXT = \"subscription\";\n\nexport const SUBSCRIBER_STORAGE_VERSION = \"0.3\";\n\nexport const PENDING_SUB_RESOLUTION_TIMEOUT = FIVE_SECONDS * 1000;\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, PendingRequestTypes } from \"@walletconnect/types\";\nimport { REQUEST_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX } from \"../constants\";\n\nexport class PendingRequest extends Store<number, PendingRequestTypes.Struct> {\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    super(\n      core,\n      logger,\n      REQUEST_CONTEXT,\n      SIGN_CLIENT_STORAGE_PREFIX,\n      (val: PendingRequestTypes.Struct) => val.id,\n    );\n  }\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport EventEmmiter from \"events\";\nimport { CoreTypes, ICore } from \"../core/core\";\nimport { IEngine } from \"./engine\";\nimport { IPendingRequest } from \"./pendingRequest\";\nimport { IProposal, ProposalTypes } from \"./proposal\";\nimport { ISession, SessionTypes } from \"./session\";\nimport { Verify } from \"../core/verify\";\nimport { IAuth, AuthTypes } from \"./auth\";\nimport { RelayerTypes } from \"../core\";\n\nexport declare namespace SignClientTypes {\n  type Event =\n    | \"session_proposal\"\n    | \"session_update\"\n    | \"session_extend\"\n    | \"session_ping\"\n    | \"session_delete\"\n    | \"session_expire\"\n    | \"session_request\"\n    | \"session_request_sent\"\n    | \"session_event\"\n    | \"session_authenticate\"\n    | \"proposal_expire\"\n    | \"session_request_expire\"\n    | \"session_connect\";\n\n  interface BaseEventArgs<T = unknown> {\n    id: number;\n    topic: string;\n    params: T;\n  }\n  interface EventArguments {\n    session_proposal: {\n      verifyContext: Verify.Context;\n    } & Omit<BaseEventArgs<ProposalTypes.Struct>, \"topic\">;\n    session_update: BaseEventArgs<{ namespaces: SessionTypes.Namespaces }>;\n    session_extend: Omit<BaseEventArgs, \"params\">;\n    session_ping: Omit<BaseEventArgs, \"params\">;\n    session_delete: Omit<BaseEventArgs, \"params\">;\n    session_expire: { topic: string };\n    session_request: {\n      verifyContext: Verify.Context;\n    } & BaseEventArgs<{\n      request: { method: string; params: any; expiryTimestamp?: number };\n      chainId: string;\n    }>;\n    session_request_sent: {\n      request: { method: string; params: any };\n      topic: string;\n      chainId: string;\n      id: number;\n    };\n    session_event: BaseEventArgs<{\n      event: { name: string; data: any };\n      chainId: string;\n    }>;\n    session_authenticate: {\n      verifyContext: Verify.Context;\n      transportType?: RelayerTypes.TransportType;\n    } & BaseEventArgs<AuthTypes.AuthRequestEventArgs>;\n    proposal_expire: { id: number };\n    session_request_expire: { id: number };\n    session_connect: { session: SessionTypes.Struct };\n  }\n\n  type Metadata = CoreTypes.Metadata;\n\n  type SignConfig = {\n    /**\n     * Disables the sequential processing of session requests.\n     *\n     * WARNING: The WalletConnect system has an at-least-once delivery guarantee,\n     * which means the same message may be delivered multiple times.\n     *\n     * When this option is enabled, you MUST implement your own message\n     * deduplication logic to prevent processing duplicate requests.\n     * This is especially important during the first second after\n     * initialization when duplicate events are more likely to occur.\n     *\n     * @default false\n     */\n    disableRequestQueue?: boolean;\n  };\n\n  interface Options extends CoreTypes.Options {\n    core?: ICore;\n    metadata?: Metadata;\n    signConfig?: SignConfig;\n  }\n}\n\nexport abstract class ISignClientEvents extends EventEmmiter {\n  constructor() {\n    super();\n  }\n\n  public abstract emit: <E extends SignClientTypes.Event>(\n    event: E,\n    args: SignClientTypes.EventArguments[E],\n  ) => boolean;\n\n  public abstract on: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract once: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract off: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract removeListener: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract removeAllListeners: <E extends SignClientTypes.Event>(event: E) => this;\n}\n\nexport abstract class ISignClient {\n  public readonly protocol = \"wc\";\n  public readonly version = 2;\n\n  public abstract readonly name: string;\n  public abstract readonly context: string;\n  public abstract readonly metadata: SignClientTypes.Metadata;\n\n  public abstract core: ICore;\n  public abstract logger: Logger;\n  public abstract events: ISignClientEvents;\n  public abstract engine: IEngine;\n  public abstract session: ISession;\n  public abstract proposal: IProposal;\n  public abstract pendingRequest: IPendingRequest;\n  public abstract auth: IAuth;\n  public abstract signConfig?: SignClientTypes.SignConfig;\n\n  constructor(public opts?: SignClientTypes.Options) {}\n\n  public abstract connect: IEngine[\"connect\"];\n  public abstract pair: IEngine[\"pair\"];\n  public abstract approve: IEngine[\"approve\"];\n  public abstract reject: IEngine[\"reject\"];\n  public abstract update: IEngine[\"update\"];\n  public abstract extend: IEngine[\"extend\"];\n  public abstract request: IEngine[\"request\"];\n  public abstract respond: IEngine[\"respond\"];\n  public abstract ping: IEngine[\"ping\"];\n  public abstract emit: IEngine[\"emit\"];\n  public abstract disconnect: IEngine[\"disconnect\"];\n  public abstract find: IEngine[\"find\"];\n  public abstract getPendingSessionRequests: IEngine[\"getPendingSessionRequests\"];\n  public abstract authenticate: IEngine[\"authenticate\"];\n  public abstract formatAuthMessage: IEngine[\"formatAuthMessage\"];\n  public abstract approveSessionAuthenticate: IEngine[\"approveSessionAuthenticate\"];\n  public abstract rejectSessionAuthenticate: IEngine[\"rejectSessionAuthenticate\"];\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport EventEmmiter from \"events\";\nimport { CoreTypes, ICore } from \"../core/core\";\nimport { IEngine } from \"./engine\";\nimport { IPendingRequest } from \"./pendingRequest\";\nimport { IProposal, ProposalTypes } from \"./proposal\";\nimport { ISession, SessionTypes } from \"./session\";\nimport { Verify } from \"../core/verify\";\nimport { IAuth, AuthTypes } from \"./auth\";\nimport { RelayerTypes } from \"../core\";\n\nexport declare namespace SignClientTypes {\n  type Event =\n    | \"session_proposal\"\n    | \"session_update\"\n    | \"session_extend\"\n    | \"session_ping\"\n    | \"session_delete\"\n    | \"session_expire\"\n    | \"session_request\"\n    | \"session_request_sent\"\n    | \"session_event\"\n    | \"session_authenticate\"\n    | \"proposal_expire\"\n    | \"session_request_expire\"\n    | \"session_connect\";\n\n  interface BaseEventArgs<T = unknown> {\n    id: number;\n    topic: string;\n    params: T;\n  }\n  interface EventArguments {\n    session_proposal: {\n      verifyContext: Verify.Context;\n    } & Omit<BaseEventArgs<ProposalTypes.Struct>, \"topic\">;\n    session_update: BaseEventArgs<{ namespaces: SessionTypes.Namespaces }>;\n    session_extend: Omit<BaseEventArgs, \"params\">;\n    session_ping: Omit<BaseEventArgs, \"params\">;\n    session_delete: Omit<BaseEventArgs, \"params\">;\n    session_expire: { topic: string };\n    session_request: {\n      verifyContext: Verify.Context;\n    } & BaseEventArgs<{\n      request: { method: string; params: any; expiryTimestamp?: number };\n      chainId: string;\n    }>;\n    session_request_sent: {\n      request: { method: string; params: any };\n      topic: string;\n      chainId: string;\n      id: number;\n    };\n    session_event: BaseEventArgs<{\n      event: { name: string; data: any };\n      chainId: string;\n    }>;\n    session_authenticate: {\n      verifyContext: Verify.Context;\n      transportType?: RelayerTypes.TransportType;\n    } & BaseEventArgs<AuthTypes.AuthRequestEventArgs>;\n    proposal_expire: { id: number };\n    session_request_expire: { id: number };\n    session_connect: { session: SessionTypes.Struct };\n  }\n\n  type Metadata = CoreTypes.Metadata;\n\n  type SignConfig = {\n    /**\n     * Disables the sequential processing of session requests.\n     *\n     * WARNING: The WalletConnect system has an at-least-once delivery guarantee,\n     * which means the same message may be delivered multiple times.\n     *\n     * When this option is enabled, you MUST implement your own message\n     * deduplication logic to prevent processing duplicate requests.\n     * This is especially important during the first second after\n     * initialization when duplicate events are more likely to occur.\n     *\n     * @default false\n     */\n    disableRequestQueue?: boolean;\n  };\n\n  interface Options extends CoreTypes.Options {\n    core?: ICore;\n    metadata?: Metadata;\n    signConfig?: SignConfig;\n  }\n}\n\nexport abstract class ISignClientEvents extends EventEmmiter {\n  constructor() {\n    super();\n  }\n\n  public abstract emit: <E extends SignClientTypes.Event>(\n    event: E,\n    args: SignClientTypes.EventArguments[E],\n  ) => boolean;\n\n  public abstract on: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract once: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract off: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract removeListener: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract removeAllListeners: <E extends SignClientTypes.Event>(event: E) => this;\n}\n\nexport abstract class ISignClient {\n  public readonly protocol = \"wc\";\n  public readonly version = 2;\n\n  public abstract readonly name: string;\n  public abstract readonly context: string;\n  public abstract readonly metadata: SignClientTypes.Metadata;\n\n  public abstract core: ICore;\n  public abstract logger: Logger;\n  public abstract events: ISignClientEvents;\n  public abstract engine: IEngine;\n  public abstract session: ISession;\n  public abstract proposal: IProposal;\n  public abstract pendingRequest: IPendingRequest;\n  public abstract auth: IAuth;\n  public abstract signConfig?: SignClientTypes.SignConfig;\n\n  constructor(public opts?: SignClientTypes.Options) {}\n\n  public abstract connect: IEngine[\"connect\"];\n  public abstract pair: IEngine[\"pair\"];\n  public abstract approve: IEngine[\"approve\"];\n  public abstract reject: IEngine[\"reject\"];\n  public abstract update: IEngine[\"update\"];\n  public abstract extend: IEngine[\"extend\"];\n  public abstract request: IEngine[\"request\"];\n  public abstract respond: IEngine[\"respond\"];\n  public abstract ping: IEngine[\"ping\"];\n  public abstract emit: IEngine[\"emit\"];\n  public abstract disconnect: IEngine[\"disconnect\"];\n  public abstract find: IEngine[\"find\"];\n  public abstract getPendingSessionRequests: IEngine[\"getPendingSessionRequests\"];\n  public abstract authenticate: IEngine[\"authenticate\"];\n  public abstract formatAuthMessage: IEngine[\"formatAuthMessage\"];\n  public abstract approveSessionAuthenticate: IEngine[\"approveSessionAuthenticate\"];\n  public abstract rejectSessionAuthenticate: IEngine[\"rejectSessionAuthenticate\"];\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"@walletconnect/types\";\n\nimport { AUTH_KEYS_CONTEXT, AUTH_STORAGE_PREFIX, AUTH_PUBLIC_KEY_NAME } from \"../constants\";\n\nexport class AuthKey extends Store<string, { responseTopic: string; publicKey: string }> {\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    super(core, logger, AUTH_KEYS_CONTEXT, AUTH_STORAGE_PREFIX, () => AUTH_PUBLIC_KEY_NAME);\n  }\n}\n","import { THIRTY_DAYS, ONE_DAY, THIRTY_SECONDS } from \"@walletconnect/time\";\nimport { RelayerTypes, PairingJsonRpcTypes } from \"@walletconnect/types\";\n\nexport const PAIRING_CONTEXT = \"pairing\";\n\nexport const PAIRING_STORAGE_VERSION = \"0.3\";\n\nexport const PAIRING_DEFAULT_TTL = THIRTY_DAYS;\n\nexport const PAIRING_RPC_OPTS: Record<\n  PairingJsonRpcTypes.WcMethod | \"unregistered_method\",\n  {\n    req: RelayerTypes.PublishOptions;\n    res: RelayerTypes.PublishOptions;\n  }\n> = {\n  wc_pairingDelete: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1000,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1001,\n    },\n  },\n  wc_pairingPing: {\n    req: {\n      ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1002,\n    },\n    res: {\n      ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1003,\n    },\n  },\n  unregistered_method: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 0,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 0,\n    },\n  },\n};\n\nexport const PAIRING_EVENTS = {\n  create: \"pairing_create\",\n  expire: \"pairing_expire\",\n  delete: \"pairing_delete\",\n  ping: \"pairing_ping\",\n};\n","import { Logger } from \"@walletconnect/logger\";\nimport { IAuth, ICore } from \"@walletconnect/types\";\nimport { AuthPairingTopic } from \"./authPairingTopic\";\nimport { AuthRequest } from \"./authRequest\";\nimport { AuthKey } from \"./authKey\";\n\nexport class AuthStore {\n  public authKeys: IAuth[\"authKeys\"];\n  public pairingTopics: IAuth[\"pairingTopics\"];\n  public requests: IAuth[\"requests\"];\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    this.authKeys = new AuthKey(this.core, this.logger);\n    this.pairingTopics = new AuthPairingTopic(this.core, this.logger);\n    this.requests = new AuthRequest(this.core, this.logger);\n  }\n\n  public async init() {\n    await this.authKeys.init();\n    await this.pairingTopics.init();\n    await this.requests.init();\n  }\n}\n","export const ECHO_CONTEXT = \"echo\";\n\nexport const ECHO_URL = \"https://echo.walletconnect.com\";\n","import { Core } from \"@walletconnect/core\";\nimport {\n  generateChildLogger,\n  getDefaultLoggerOptions,\n  getLoggerContext,\n  pino,\n} from \"@walletconnect/logger\";\nimport { SignClientTypes, ISignClient, ISignClientEvents, EngineTypes } from \"@walletconnect/types\";\nimport { populateAppMetadata } from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\nimport { SIGN_CLIENT_DEFAULT, SIGN_CLIENT_PROTOCOL, SIGN_CLIENT_VERSION } from \"./constants\";\nimport { AuthStore, Engine, PendingRequest, Proposal, Session } from \"./controllers\";\n\nexport class SignClient extends ISignClient {\n  public readonly protocol = SIGN_CLIENT_PROTOCOL;\n  public readonly version = SIGN_CLIENT_VERSION;\n  public readonly name: ISignClient[\"name\"] = SIGN_CLIENT_DEFAULT.name;\n  public readonly metadata: ISignClient[\"metadata\"];\n\n  public core: ISignClient[\"core\"];\n  public logger: ISignClient[\"logger\"];\n  public events: ISignClient[\"events\"] = new EventEmitter();\n  public engine: ISignClient[\"engine\"];\n  public session: ISignClient[\"session\"];\n  public proposal: ISignClient[\"proposal\"];\n  public pendingRequest: ISignClient[\"pendingRequest\"];\n  public auth: ISignClient[\"auth\"];\n  public signConfig?: ISignClient[\"signConfig\"];\n\n  static async init(opts?: SignClientTypes.Options) {\n    const client = new SignClient(opts);\n    await client.initialize();\n\n    return client;\n  }\n\n  constructor(opts?: SignClientTypes.Options) {\n    super(opts);\n\n    this.name = opts?.name || SIGN_CLIENT_DEFAULT.name;\n    this.metadata = populateAppMetadata(opts?.metadata);\n    this.signConfig = opts?.signConfig;\n\n    const logger =\n      typeof opts?.logger !== \"undefined\" && typeof opts?.logger !== \"string\"\n        ? opts.logger\n        : pino(getDefaultLoggerOptions({ level: opts?.logger || SIGN_CLIENT_DEFAULT.logger }));\n\n    this.core = opts?.core || new Core(opts);\n    this.logger = generateChildLogger(logger, this.name);\n    this.session = new Session(this.core, this.logger);\n    this.proposal = new Proposal(this.core, this.logger);\n    this.pendingRequest = new PendingRequest(this.core, this.logger);\n    this.engine = new Engine(this);\n    this.auth = new AuthStore(this.core, this.logger);\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n\n  // ---------- Events ----------------------------------------------- //\n\n  public on: ISignClientEvents[\"on\"] = (name, listener) => {\n    return this.events.on(name, listener);\n  };\n\n  public once: ISignClientEvents[\"once\"] = (name, listener) => {\n    return this.events.once(name, listener);\n  };\n\n  public off: ISignClientEvents[\"off\"] = (name, listener) => {\n    return this.events.off(name, listener);\n  };\n\n  public removeListener: ISignClientEvents[\"removeListener\"] = (name, listener) => {\n    return this.events.removeListener(name, listener);\n  };\n\n  public removeAllListeners: ISignClientEvents[\"removeAllListeners\"] = (name) => {\n    return this.events.removeAllListeners(name);\n  };\n\n  // ---------- Engine ----------------------------------------------- //\n\n  public connect: ISignClient[\"connect\"] = async (params) => {\n    try {\n      return await this.engine.connect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public pair: ISignClient[\"pair\"] = async (params) => {\n    try {\n      return await this.engine.pair(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public approve: ISignClient[\"approve\"] = async (params) => {\n    try {\n      return await this.engine.approve(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public reject: ISignClient[\"reject\"] = async (params) => {\n    try {\n      return await this.engine.reject(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public update: ISignClient[\"update\"] = async (params) => {\n    try {\n      return await this.engine.update(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public extend: ISignClient[\"extend\"] = async (params) => {\n    try {\n      return await this.engine.extend(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public request: ISignClient[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    try {\n      return await this.engine.request<T>(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public respond: ISignClient[\"respond\"] = async (params) => {\n    try {\n      return await this.engine.respond(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public ping: ISignClient[\"ping\"] = async (params) => {\n    try {\n      return await this.engine.ping(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public emit: ISignClient[\"emit\"] = async (params) => {\n    try {\n      return await this.engine.emit(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public disconnect: ISignClient[\"disconnect\"] = async (params) => {\n    try {\n      return await this.engine.disconnect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public find: ISignClient[\"find\"] = (params) => {\n    try {\n      return this.engine.find(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public getPendingSessionRequests: ISignClient[\"getPendingSessionRequests\"] = () => {\n    try {\n      return this.engine.getPendingSessionRequests();\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public authenticate: ISignClient[\"authenticate\"] = async (params, walletUniversalLink) => {\n    try {\n      return await this.engine.authenticate(params, walletUniversalLink);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public formatAuthMessage: ISignClient[\"formatAuthMessage\"] = (params) => {\n    try {\n      return this.engine.formatAuthMessage(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public approveSessionAuthenticate: ISignClient[\"approveSessionAuthenticate\"] = async (params) => {\n    try {\n      return await this.engine.approveSessionAuthenticate(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public rejectSessionAuthenticate: ISignClient[\"rejectSessionAuthenticate\"] = async (params) => {\n    try {\n      return await this.engine.rejectSessionAuthenticate(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    try {\n      await this.core.start();\n      await this.session.init();\n      await this.proposal.init();\n      await this.pendingRequest.init();\n      await this.auth.init();\n      await this.engine.init();\n      this.logger.info(`SignClient Initialization Success`);\n    } catch (error: any) {\n      this.logger.info(`SignClient Initialization Failure`);\n      this.logger.error(error.message);\n      throw error;\n    }\n  }\n}\n","import { SignClient as Client } from \"./client\";\nimport { Session } from \"./controllers/session\";\nexport * from \"./constants\";\n\nexport const SessionStore = Session;\nexport const SignClient = Client;\nexport default Client;\n","function base(ALPHABET, name) {\n  if (ALPHABET.length >= 255) {\n    throw new TypeError('Alphabet too long');\n  }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) {\n      throw new TypeError(x + ' is ambiguous');\n    }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256);\n  var iFACTOR = Math.log(256) / Math.log(BASE);\n  function encode(source) {\n    if (source instanceof Uint8Array);\n    else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) {\n      throw new TypeError('Expected Uint8Array');\n    }\n    if (source.length === 0) {\n      return '';\n    }\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n    var b58 = new Uint8Array(size);\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n        carry += 256 * b58[it1] >>> 0;\n        b58[it1] = carry % BASE >>> 0;\n        carry = carry / BASE >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      pbegin++;\n    }\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) {\n      str += ALPHABET.charAt(b58[it2]);\n    }\n    return str;\n  }\n  function decodeUnsafe(source) {\n    if (typeof source !== 'string') {\n      throw new TypeError('Expected String');\n    }\n    if (source.length === 0) {\n      return new Uint8Array();\n    }\n    var psz = 0;\n    if (source[psz] === ' ') {\n      return;\n    }\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n    var size = (source.length - psz) * FACTOR + 1 >>> 0;\n    var b256 = new Uint8Array(size);\n    while (source[psz]) {\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n      if (carry === 255) {\n        return;\n      }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {\n        carry += BASE * b256[it3] >>> 0;\n        b256[it3] = carry % 256 >>> 0;\n        carry = carry / 256 >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      psz++;\n    }\n    if (source[psz] === ' ') {\n      return;\n    }\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch;\n  }\n  function decode(string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) {\n      return buffer;\n    }\n    throw new Error(`Non-${ name } character`);\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\nexport default _brrp__multiformats_scope_baseX;","function isTypedArray(x) {\n    return ArrayBuffer.isView(x) && !(x instanceof DataView);\n}\n\nexport { isTypedArray };\n","import { getSymbols } from '../compat/_internal/getSymbols.mjs';\nimport { getTag } from '../compat/_internal/getTag.mjs';\nimport { uint32ArrayTag, uint16ArrayTag, uint8ClampedArrayTag, uint8ArrayTag, symbolTag, stringTag, setTag, regexpTag, objectTag, numberTag, mapTag, int32ArrayTag, int16ArrayTag, int8ArrayTag, float64ArrayTag, float32ArrayTag, dateTag, booleanTag, dataViewTag, arrayBufferTag, arrayTag, argumentsTag } from '../compat/_internal/tags.mjs';\nimport { isPrimitive } from '../predicate/isPrimitive.mjs';\nimport { isTypedArray } from '../predicate/isTypedArray.mjs';\n\nfunction cloneDeepWith(obj, cloneValue) {\n    return cloneDeepWithImpl(obj, undefined, obj, new Map(), cloneValue);\n}\nfunction cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack = new Map(), cloneValue = undefined) {\n    const cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack);\n    if (cloned != null) {\n        return cloned;\n    }\n    if (isPrimitive(valueToClone)) {\n        return valueToClone;\n    }\n    if (stack.has(valueToClone)) {\n        return stack.get(valueToClone);\n    }\n    if (Array.isArray(valueToClone)) {\n        const result = new Array(valueToClone.length);\n        stack.set(valueToClone, result);\n        for (let i = 0; i < valueToClone.length; i++) {\n            result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);\n        }\n        if (Object.hasOwn(valueToClone, 'index')) {\n            result.index = valueToClone.index;\n        }\n        if (Object.hasOwn(valueToClone, 'input')) {\n            result.input = valueToClone.input;\n        }\n        return result;\n    }\n    if (valueToClone instanceof Date) {\n        return new Date(valueToClone.getTime());\n    }\n    if (valueToClone instanceof RegExp) {\n        const result = new RegExp(valueToClone.source, valueToClone.flags);\n        result.lastIndex = valueToClone.lastIndex;\n        return result;\n    }\n    if (valueToClone instanceof Map) {\n        const result = new Map();\n        stack.set(valueToClone, result);\n        for (const [key, value] of valueToClone) {\n            result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack, cloneValue));\n        }\n        return result;\n    }\n    if (valueToClone instanceof Set) {\n        const result = new Set();\n        stack.set(valueToClone, result);\n        for (const value of valueToClone) {\n            result.add(cloneDeepWithImpl(value, undefined, objectToClone, stack, cloneValue));\n        }\n        return result;\n    }\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(valueToClone)) {\n        return valueToClone.subarray();\n    }\n    if (isTypedArray(valueToClone)) {\n        const result = new (Object.getPrototypeOf(valueToClone).constructor)(valueToClone.length);\n        stack.set(valueToClone, result);\n        for (let i = 0; i < valueToClone.length; i++) {\n            result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);\n        }\n        return result;\n    }\n    if (valueToClone instanceof ArrayBuffer ||\n        (typeof SharedArrayBuffer !== 'undefined' && valueToClone instanceof SharedArrayBuffer)) {\n        return valueToClone.slice(0);\n    }\n    if (valueToClone instanceof DataView) {\n        const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);\n        stack.set(valueToClone, result);\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    if (typeof File !== 'undefined' && valueToClone instanceof File) {\n        const result = new File([valueToClone], valueToClone.name, {\n            type: valueToClone.type,\n        });\n        stack.set(valueToClone, result);\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    if (valueToClone instanceof Blob) {\n        const result = new Blob([valueToClone], { type: valueToClone.type });\n        stack.set(valueToClone, result);\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    if (valueToClone instanceof Error) {\n        const result = new valueToClone.constructor();\n        stack.set(valueToClone, result);\n        result.message = valueToClone.message;\n        result.name = valueToClone.name;\n        result.stack = valueToClone.stack;\n        result.cause = valueToClone.cause;\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    if (typeof valueToClone === 'object' && isCloneableObject(valueToClone)) {\n        const result = Object.create(Object.getPrototypeOf(valueToClone));\n        stack.set(valueToClone, result);\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    return valueToClone;\n}\nfunction copyProperties(target, source, objectToClone = target, stack, cloneValue) {\n    const keys = [...Object.keys(source), ...getSymbols(source)];\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const descriptor = Object.getOwnPropertyDescriptor(target, key);\n        if (descriptor == null || descriptor.writable) {\n            target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue);\n        }\n    }\n}\nfunction isCloneableObject(object) {\n    switch (getTag(object)) {\n        case argumentsTag:\n        case arrayTag:\n        case arrayBufferTag:\n        case dataViewTag:\n        case booleanTag:\n        case dateTag:\n        case float32ArrayTag:\n        case float64ArrayTag:\n        case int8ArrayTag:\n        case int16ArrayTag:\n        case int32ArrayTag:\n        case mapTag:\n        case numberTag:\n        case objectTag:\n        case regexpTag:\n        case setTag:\n        case stringTag:\n        case symbolTag:\n        case uint8ArrayTag:\n        case uint8ClampedArrayTag:\n        case uint16ArrayTag:\n        case uint32ArrayTag: {\n            return true;\n        }\n        default: {\n            return false;\n        }\n    }\n}\n\nexport { cloneDeepWith, cloneDeepWithImpl, copyProperties };\n","export const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","export const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nexport function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nexport function abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nexport function ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nexport function byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nexport const byteSwapIfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexport const swap32IfBE = isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nexport class Hash {\n}\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport const wrapConstructor = createHasher;\nexport const wrapConstructorWithOpts = createOptHasher;\nexport const wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return Uint8Array.from(crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nexport function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nexport function abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nexport function ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nexport function byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nexport const byteSwapIfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexport const swap32IfBE = isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nexport class Hash {\n}\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport const wrapConstructor = createHasher;\nexport const wrapConstructorWithOpts = createOptHasher;\nexport const wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return Uint8Array.from(crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","unable to read source [project]/node_modules/@reown/appkit-controllers/src/controllers/AlertController.ts","unable to read source [project]/node_modules/@reown/appkit-controllers/src/utils/SIWXUtil.ts"],"names":["core","LogListNode","LogLinkedList","maxSizeInBytes","value","newNode","removedNode","array","currentNode","node","level","MAX_LOG_SIZE_IN_BYTES","chunk","logger","MAX_LOG_SIZE_IN_BYTES_DEFAULT","IEvents","chain","SEVEN_DAYS","opts","__spreadProps","__spreadValues","PINO_LOGGER_DEFAULTS","customContextKey","PINO_CUSTOM_CONTEXT_KEY","context","childContext","parentContext","child","params","_a","_b","clientLogger","ClientChunkLogger","pino","obj","serverLogger","ServerChunkLogger","storagePrefix","name","ONE_DAY","IEngine","client","__publicField","ENGINE_CONTEXT","EventEmmiter","ENGINE_QUEUE_STATES","LimitedSet","ONE_SECOND","ENGINE_RPC_OPTS","toMiliseconds","connectParams","mergeRequiredAndOptionalNamespaces","pairingTopic","requiredNamespaces","optionalNamespaces","sessionProperties","scopedProperties","relays","topic","uri","active","pairing","error","newTopic","newUri","message","getInternalError","publicKey","expiry","FIVE_MINUTES","expiryTimestamp","calcExpiry","proposal","RELAYER_DEFAULT_PROTOCOL","payloadId","sessionConnectTarget","engineEvent","reject","resolve","approval","createDelayedPromise","PROPOSAL_EXPIRY_MESSAGE","proposalExpireHandler","id","session","_c","configEvent","EVENT_CLIENT_SESSION_TRACES","EVENT_CLIENT_SESSION_ERRORS","relayProtocol","namespaces","sessionConfig","proposer","event","selfPublicKey","peerPublicKey","sessionTopic","sessionSettle","SESSION_EXPIRY","transportType","TRANSPORT_TYPES","getSdkError","reason","acknowledged","clientRpcId","relayRpcId","getBigIntRpcId","oldNamespaces","e","chainId","request","done","result","protocolMethod","appLink","protocolRequestParams","wcDeepLink","getDeepLink","WALLETCONNECT_DEEPLINK_CHOICE","handleDeeplinkRedirect","response","isJsonRpcResult","isJsonRpcError","isSessionCompatible","walletUniversalLink","isLinkMode","chains","statement","domain","nonce","type","exp","nbf","methods","resources","connectionUri","responseTopic","hashKey","AUTH_PUBLIC_KEY_NAME","namespace","parseChainId","recap","createEncodedRecap","getRecapFromResources","mergeEncodedRecaps","authRequestExpiry","authenticateId","sessionConnectEventTarget","authenticateEventTarget","onSessionConnect","onAuthenticate","payload","cacaos","responder","approvedMethods","approvedAccounts","cacao","validateSignedCacao","approvedChains","getNamespacedDidChainId","parsedAddress","getDidAddress","methodsfromRecap","getMethodsFromRecap","chainsFromRecap","getChainsFromRecap","buildNamespacesFromAuth","linkModeURL","formatJsonRpcRequest","TYPE_2","BASE64URL","getLinkModeURL","sessionAuthenticateResponseParams","auths","EVENT_CLIENT_AUTHENTICATE_TRACES","EVENT_CLIENT_AUTHENTICATE_ERRORS","pendingRequest","receiverPublicKey","senderPublicKey","encodeOpts","TYPE_1","invalidErr","iss","formatMessage","duplicates","p","expirerHasDeleted","emitEvent","self","r","verifyContext","args","method","throwOnFailedPublish","tvf","publishOpts","encoding","BASE64","attestation","METHODS_TO_VERIFY","decryptedId","hashMessage","redirectURL","proposeSessionPayload","proposeSessionMessage","attestationId","pairingProposalResponse","sessionSettleRequest","pairingPayload","formatJsonRpcResult","pairingResponseMessage","sessionSettlePayload","sessionSettlementRequestMessage","record","rpcOpts","formatJsonRpcError","sessionTopics","proposalIds","toCleanup","isExpired","encryptedId","reqMethod","resMethod","requestMethod","expectedMethods","EVENT_CLIENT_PAIRING_ERRORS","EVENT_CLIENT_PAIRING_TRACES","err","subscriptionId","target","relay","controller","pendingSession","s","memoryKey","lastSessionUpdateId","MemoryStore","lastId","currentId","_topic","RELAYER_EVENTS","requester","authPayload","pendingRequests","isValidParams","isUndefined","isValidRelays","isValidObject","warning","requestedNamespaces","ns","validRequiredNamespacesError","isValidRequiredNamespaces","validNamespacesError","isValidNamespaces","conformingNamespacesError","isConformingNamespaces","isValidString","approvedNamespaces","isValidErrorReason","isValidRelay","validControllerError","isValidController","isValidNamespacesChainId","isValidRequest","isValidNamespacesRequest","isValidRequestExpiry","SESSION_REQUEST_EXPIRY_BOUNDARIES","isValidResponse","isValidEvent","isValidNamespacesEvent","hash","metadata","VERIFY_SERVER","applink","properties","property","index","i","numItemsToDelete","k","deletedRecord","peerMetadata","_d","_e","_f","_g","_h","_i","url","getSearchParamFromURL","sessionExists","isTestRun","isReactNative","linking","initialUrl","txHashes","data","hexPart","methodConfig","TVF_METHODS","getSuiDigest","getNearTransactionIdFromSignedTransaction","tx","buildSignedExtrinsicHash","isValidArray","getAlgorandTransactionId","getSignDirectHash","getWalletSendCallsHashes","hashes","extractSolanaTransactionId","topics","pendingMessages","messages","isJsonRpcRequest","isJsonRpcResponse","EXPIRER_EVENTS","parseExpirerTarget","PAIRING_EVENTS","isValidId","store","Store","AUTH_KEYS_CONTEXT","AUTH_STORAGE_PREFIX","THIRTY_DAYS","THIRTY_SECONDS","SignClient","ISignClient","SIGN_CLIENT_PROTOCOL","SIGN_CLIENT_VERSION","SIGN_CLIENT_DEFAULT","EventEmitter","listener","populateAppMetadata","getDefaultLoggerOptions","Core","generateChildLogger","Session","Proposal","PendingRequest","Engine","AuthStore","getLoggerContext","isBytes"],"mappings":"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,KAAO,CAAA,EAAA,IAAA,EACpD,QAAA,CAAA,IAAA,QAAA,CAAA,EAAA,kGA0OE,SAAA,CAAoC,CAAA,EAA0B,CAAA,CAAE,YACpE,GAAA,MAAA,CAAA,gCAvJI,SAAA,CAAA,CAAA,EAAA,CAAA,CAA4D,EAChE,C6DhFG,C3BgCC,ACAA,EAAA,EnCgDa,CAAA,EAAA,EAAA,OAAA,GAAA,CAAA,OACQ,C6DhFG,A3BgCA,ACAA,C0BhCC,EAAE,E3BgCE,ACAA,CAAC,ADAA,AyB5BA,C5D4ED,ACAA,A2D5EE,CzB4BC,ACAA,AwB5BA,iEnE0ChC,GAAA,EAAA,eQmEqB,C2DpFC,AAAG,CAAF,AAAE,CMrBD,ADAA,CAAC,ACAA,ANqBA,CAAA,CAAA,W3DsF7B,I2DpFM,IAAA,EAAA,EAAA,EAAA,EAAA,MAAA,CAAA,O3DqFM,C6DxFK,CAAC,AFIC,CAAA,C3DoFI,CAAA,EAAA,CAAA,QAEX,EAAA,EAAA,EAAA,CAAA,iBAEuB,CAAC,ADAA,A4DrFE,CAAC,CAAC,uB3DsFd,EAAI,EDAA,ACAA,CgE3GsC,ACAA,CDAC,ACAA,AjE2GvC,CiE3GwC,ADAA,ECE5D,GAAA,EAAA,KjE0Ge,C6DzFK,GAAG,EAAE,C9DyFH,ACAA,CAAE,IAAI,ADAA,CCAE,EAAI,EDAA,ACAA,EAAK,CDAE,ACAA,CDAC,ACAA,CAAA,ADAA,CCE7C,E6DzFI,C7DyFD,A6DzFE,A9DyFF,CAAA,ACAA,E6DzFK,CAAC,I7DiIF,CgEzHC,ACAA,CDAC,ACAA,ClEyHS,C8D5GP,AGbA,ACAA,AlEyHO,CiEzHN,ACAA,AlEyHM,EAAA,C8DjIG,AGQN,ACAA,AlEyHG,CAAA,C8DjIK,C7DiIL,ADAA,K8DjIW,CAAC,A7DqI/B,C6DrIgC,A7DqIhC,OAAA,CAAA,CAAA,KAAA,CAAA,CAAA,CAAA,c2DxGF,E3D8GU,G6DhHD,AGbA,ACAA,CjE6HS,CAAA,CAAA,C6DhHL,A7DgHK,CDAA,ACAA,CDAuB,ACAvB,CDAuB,CAAA,CCAvB,OAAkB,C6DhHH,AGbA,ACAA,CDAC,ACAA,ClE6HO,CAAD,AAAC,ACAD,CAAC,ADAA,GCAe,CAAE,CDAA,ACAA,CAC5C,CAAE,A6DjHyC,E7DiHzC,CgE9H4C,AhE8H5C,AiE9H4C,CJaC,A7DiHzB,AiE9HyB,ADAA,CCAC,ADAA,AhE8HxB,C6DjHyB,A7DiH/C,ADAuB,ACAA,OAAX,EAAQ,EDAJ,ACAO,AAAP,CDAC,ACAA,AAAM,CAAK,CDAA,ACAA,8BAE5B,G6D9GO,EAAE,C7D8GH,ADAA,CAAA,iBCAiB,CDAC,ACAA,CDAA,ACAA,O6D9GY,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC,A7DiHnB,CAAC,EDAQ,CAAA,CAAA,CkExHI,ADAA,AjEwHJ,CkExHK,ADAA,CCAC,ADAA,CjEwHN,ACAA,4CAGf,EAClD,AADoD,ADAA,CCAA,ADAA,C4D5GM,EKZlD,ACAA,CDAC,AHSA,AITA,ANaA,AADoD,EACpD,CELuD,CAAC,CFIC,CACzD,AAD0D,CAAC,CEJC,CFIC,AAC7D,CEL8D,CAAC,CAAC,AFIA,EAAE,EAAE,CAAC,EAAE,EAAE,0C3DiHhF,G2D5GS,C3D4GL,ADAA,I4D5GU,AEJA,CFIC,EAAE,SEJS,C7DqH9B,EjBVI,A4EnGA,AKbA,A7EgHA,A8EhHA,EAAA,AJK+B,EAAE,AILjC,CAAA,EAAA,EAAA,CAAA,GAAA,EAAA,EAAA,AjE2HqB,GAAE,EAAI,MDAM,ACAA,CAAK,EAAJ,EAAI,EDAA,ACAA,AAAS,MAAM,ADAA,CAAA,GAAA,CAAA,EAAA,QAAA,CAAA,IAAA,CAAA,+BCarD,E2DtHE,CAAM,EAAH,E5DsHE,ACAA,A2DtHC,CAAA,kBxE7FoB,GkBmEvBhU,ADAAA,CAAAA,AfrEyB,AKAA,AjBgBA,ACAA,A2BqDzBA,iCsDtDN,IxEwFS,CAAA,KACH,EwEzFN,AxEwFqC,C0EpFG,CAAC,I1E6EzC,KAOgD,AJAA,EIAC,KAGnC,GwEhFO,ExEgFR,EwEhFY,I5EgFA,AIAA,QAEZ,KAAA,KA8BZ,OA9B6B,C6ErGK,ACAA,C9EmIlC,GAAA,CAAA,CAAA,EAAA,CAAuD,CAAA,oCAGxB,CAAE,AJAA,CIAC,AJAA,CAAA,AIAA,OACrB,CAAE,GG2BK,AP3BF,AIAA,AI2BE,CJ3BA,K0E5FO,CAAC,C1E4FD,AJAA,C8E5FG,O1E4FU,IAAI,CAAE,AJAA,CAAC,AIAA,CJAA,AIAA,OAGnC,C8E9GG,ADAA,CAAA,K7E8GM,CAAA,kFAKU,EAAQ,IAAF,AJAA,AIAW,CJAJ,AIAA,AAAK,AJAA,EIAH,AJAA,EIC1C,C8E1GK,ADAA,CAAW,GAAA,CHaN,CGbM,G7E0GN,AJAA,EkF1GM,ADAA,KAAA,CAAA,Q7E2GF,GAAiB,E0E7FR,A1E6FkB,E0E7FF,GAAX,CAAe,C9E6FH,AIAA,GAAW,CAArB,AJAA,AIAqB,SACrD,AwEzFgB,EAAV,CAAC,AEJA,EFIS,CAAN,CAAC,GxEyFD,AJAA,E4EzFM,KAAA,IAAA,YxE0FR,GJAS,CAAA,AkF1GM,ADAA,ECAE,ADAA,G7E0GR,AJAA,mBAAA,EAAA,CAAA,CAAA,EAAA,EAAA,CAAA,EAAA,CAAA,CAAA,EAAA,EAAA,CAAA,MAAA,EAAA,EAAA,GAAA,CAAA,YIMY,EAEnC,K0EnG8C,CAAC,C1EmGxC,EJFuC,AIAA,AAkE1C,CAlE0C,AJAA,E8EjGO,A1EmGzC,AYgB6B,ACAA,AjBhB7B,CgBgB6B,A8DnHa,A9EmG1C,AiBgB6B,A2D7G1B,AxE6FH,CwE7FI,GAAG,CENwC,AFMvC,AEJA,A1EiKhB,C0EnKwD,AAEvC,CAFwC,CAAC,A1EmK1D,CAAA,C0EnK4D,AFMvC,AxE+JzB,E0EnK2B,A1EmK3B,CAAA,CAAA,A0EnK6B,EFIE,EAAE,IEN2C,CAAC,GAEpC,EAAE,KAF4C,EAAE,MAEjC,EAAE,IAF2C,CAEtC,AAFuC,EAErC,QAF+C,CAAC,CAEtC,AAFuC,CAEtC,CAAC,O1EuKhE,EYGQ,GZHH,AJAA,C8ExHK,A7D2HF,ADAA,iBZFC,IAAA,eAAyB,IAAA,qBc9N3B,6BAIZ,EAAA,CAAS,OAAA,CAAA,+CoDfHa,iBlE8C0B,AAC/B,CMLG,A4D1CV,A7D0CU,AqD/CE,C1DuMd,AgD7Le,ADAA,CAAC,AxD6CF,ADAA,A0D7CE,EpDyC6B,AIAA,CkE9CrCb,CAAAA,CAAAA,AlBKQ,CkBLFa,ClBKE,QhD4LQ,KAAK,AJAA,WI/GzB,C0ElFE,C1BgCC,ADAA,O/CkDmB,CgDlDC,ADAA,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,IAAW,MAAS,EAAA,CAClB,OAAO,E5B3CsD,CDAC,ACAA,C4B2CvD,A7B3CuD,ACAA,C4B2ClD,S5BzCK,EoBII,AHAA,AfEN,ADAA,E2BoCjB,CAEA,I3BtCiB,A2BsCN,C5B5CkB,G4B4CX,EAAA,CAChB,K5B7C2B,CAAA,C4B6CpB,C5B7CoB,G4B6CpB,CAAK,K5B7Ce,CACF,CDAC,ACAA,CqDRnB,ACAA,AtDQqB,G4B6C9B,A7B7CiC,ACAA,C4B+C1B,A7B/C2B,ACAA,CDC/B,ACAA,CAAA,Y4B8CI,EAAiB,A5B9CrB,C4B+CD,A5B/CC,GACH,CAAC,CuDlDU,ACKP,AxD6CF,AyD7CE,ACLO,A3DkDT,EqBGa,AQ2CN,KAAM,CAAA,IAAA,CAAK,IAAI,CR3CT,AQ4Cf,CR5Ce,AQ8Cf,CAAC,C5B9C2B,CCGC,ACAA,I0B2C5B,CAAO,G1B3CqB,CAAA,IAAA,A0B2Cb,CAAA,EAAsB,CACpC,C1B5C2B,EFFpB,C4B8CHE,AX7CE,AGAA,CQ6CK,CAAA,IAAA,CAAK,IAahB,CAAA,OAAO,CAAE,IAAA,CAXI,IAA8B,CACzC,GAAI,CAACA,CAAAA,CACH,OAAO,CAAE,IAAM,CAAA,CAAA,CAAA,CAAM,KAAO,CAAA,IAAK,CAGnC,CAAA,MAAML,CAAQK,CAAAA,CAAAA,CAAK,MACnB,OAAAA,CAAAA,CAAOA,CAAK,CAAA,IAAA,CAEL,CAAE,IAAA,CAAM,CAAO,CAAA,CAAA,KAAA,CAAAL,CAAM,CAC9B,CAEc,CAChB,CACF,qCTnGqC,CNPqB,AIYtB,ALZsB,AQYtB,APZsB,KAAA,CAAA,CAAA,UAAA,CMS/C,CAAA,sCAE0C,YAAM,CEVG,AFUM,AGVN,EdaxC,ADAA,Aeb0C,ADAA,uDNqBlC,wCAGE,CmCvBrBJ,ACAAA,CpDkCuB,AoDlCvBA,ADAAA,AlDkCuB,CeXC,CAAA,GAAA,aAAyB,CDAE,ACAA,CDAA,AfWA,AgBXA,AfWA,CDAC,ACAA,KeRnC,EAAA,SAAA,CAAA,GAAA,WAAA,iBAAA,QAKgC,EACxD,KAAA,CAAM,C+C3CV,C/C0CsE,ADC1D,ACAA,CAAC,ADAA,ACAV,ADAA,CAAU,ACAA,C+C3Cb,EAAA,CAAA,MAAA,CAAA,C/C4CkB,ChBUD,A0C7BA,A3BmBE,AdUF,A2C7BA,AzCiCA,AadE,AdcF,CFJA,ACAA,GeVS,CgDvBfgU,AjDuBgB,ACAA,A4BnBF,AqBJdA,AvBIc,CEAA,AqBJdA,AvBIc,AsBJdA,CCAAA,ADAAA,AACP,CCAA,ADAA,WDtBJ,CAAA,IAAA,EAAA,CAAA,MAAA,CAAA,O/C8C8B,C0CpCO,ADAA,CMVrC,CAAA,QLUqC,EAAA,IKVrC,CAAA,EAAA,CAAA,MAAA,CAAA,SAAA,CAAA,A/CgDoD,WACtB,CAAA,EAAA,EAAA,CAAA,G+CjD9B,CAAA,IAAA,EAAA,C/CiD8B,A+CjD9B,CAAA,CAAA,A/CiD8B,C+CjD9B,CAAA,CAAA,CAAA,GAAA,CAAA,IAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,UAAA,CAAA,CAAA,CAAA,CAAA,YAAA,CAAA,CAAA,CAAA,CAAA,QAAA,CAAA,CAAA,CAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,CAAA,IAAA,IAAA,CAAA,IAAA,CAAA,GAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,EAAA,CAAA,IAAA,IAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,OAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,EAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,EAAA,CAAA,CAAA,CAAA,OAAA,CAAA,EAAA,QAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CA2Ha,MAAA,MAAA,SAAexR,OAAQ,CAgDlC,WAAA,CAAYC,CAA2B,CAAA,CACrC,MAAMA,CAAM,CAAA,CAhDdC,CAAA,CAAA,IAAA,CAAO,OAAOC,cAEdD,CAAAA,CAAAA,CAAAA,CAAA,IAAQ,CAAA,QAAA,CAAwB,IAAIE,EACpCF,CAAAA,CAAAA,CAAAA,CAAA,KAAQ,aAAc,CAAA,CAAA,CAAA,CAAA,CAMtBA,EAAA,IAAQ,CAAA,cAAA,CAAmF,CACzF,KAAA,CAAOG,oBAAoB,IAC3B,CAAA,KAAA,CAAO,EACT,CAAA,CAAA,CAMAH,EAAA,IAAQ,CAAA,qBAAA,CAA2E,CACjF,KAAA,CAAOG,oBAAoB,IAC3B,CAAA,KAAA,CAAO,EACT,CAAA,CAAA,CAIAH,EAAA,IAAQ,CAAA,wBAAA,CAAyB,IAAII,UAAAA,CAAW,CAAE,KAAO,CAAA,GAAI,CAAC,CAAA,CAAA,CAE9DJ,EAAA,IAAQ,CAAA,mBAAA,CAAoBK,UAC5BL,CAAAA,CAAAA,CAAAA,CAAA,KAAQ,0BAAkD,CAAA,IAAI,KAE9DA,CAAA,CAAA,IAAA,CAAQ,qBAAqB,IAAI,GAAA,CAAA,CAKjCA,CAAA,CAAA,IAAA,CAAQ,uBAAuB,GAC/BA,CAAAA,CAAAA,CAAAA,CAAA,KAAQ,mBAAiD,CAAA,IACzDA,CAAA,CAAA,IAAA,CAAQ,iBAQJ,CAAA,IAAI,KAMRA,CAAA,CAAA,IAAA,CAAO,OAAwB,SAAY,CACpC,KAAK,WACR,GAAA,MAAM,IAAK,CAAA,OAAA,GACX,IAAK,CAAA,qBAAA,EACL,CAAA,IAAA,CAAK,uBACL,CAAA,IAAA,CAAK,qBAAsB,EAAA,CAC3B,MAAM,IAAK,CAAA,yBAAA,GACX,IAAK,CAAA,MAAA,CAAO,KAAK,OAAQ,CAAA,QAAA,CAAS,CAAE,OAAA,CAAS,OAAO,IAAKM,CAAAA,eAAe,CAAE,CAAC,CAAA,CAC3E,KAAK,WAAc,CAAA,CAAA,CAAA,CACnB,UAAW,CAAA,SAAY,CACrB,MAAM,IAAA,CAAK,6BAEX,CAAA,IAAA,CAAK,oBAAoB,KAAQ,CAAA,IAAA,CAAK,yBAA0B,EAAA,CAChE,KAAK,0BAA2B,GAClC,CAAGC,CAAAA,aAAAA,CAAc,KAAK,iBAAiB,CAAC,CAE5C,EAAA,CAAA,CAAA,CA4BAP,EAAA,IAAO,CAAA,SAAA,CAA8B,MAAOd,CAAW,EAAA,CACrD,KAAK,aAAc,EAAA,CACnB,MAAM,IAAA,CAAK,2BACX,CAAA,MAAMsB,CAAgB/B,CAAAA,CAAAA,CAAAC,EAAA,EACjBQ,CAAAA,CAAAA,CAAAA,CADiB,CAEpB,kBAAA,CAAoBA,EAAO,kBAAsB,EAAA,GACjD,kBAAoBA,CAAAA,CAAAA,CAAO,oBAAsB,EACnD,CACA,CAAA,CAAA,MAAM,KAAK,cAAesB,CAAAA,CAAa,CAGvCA,CAAAA,CAAAA,CAAc,mBAAqBC,kCACjCD,CAAAA,CAAAA,CAAc,kBACdA,CAAAA,CAAAA,CAAc,kBAChB,CAEAA,CAAAA,CAAAA,CAAc,mBAAqB,EAAC,CAEpC,KAAM,CACJ,YAAA,CAAAE,CACA,CAAA,kBAAA,CAAAC,EACA,kBAAAC,CAAAA,CAAAA,CACA,kBAAAC,CACA,CAAA,gBAAA,CAAAC,EACA,MAAAC,CAAAA,CACF,CAAIP,CAAAA,CAAAA,CACJ,IAAIQ,CAAQN,CAAAA,CAAAA,CACRO,EACAC,CAAS,CAAA,CAAA,CAAA,CACb,GAAI,CACF,GAAIF,CAAO,CAAA,CACT,MAAMG,CAAU,CAAA,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,QAAQ,QAAS,CAAA,GAAA,CAAIH,CAAK,CAAA,CAC3D,KAAK,MAAO,CAAA,MAAA,CAAO,KACjB,oGACF,CAAA,CACAE,EAASC,CAAQ,CAAA,OACnB,CACF,CAAA,MAASC,EAAO,CACd,MAAA,IAAA,CAAK,OAAO,MAAO,CAAA,KAAA,CAAM,4BAA4BJ,CAAK,CAAA,QAAA,CAAU,CAC9DI,CAAAA,CACR,CACA,GAAI,CAACJ,GAAS,CAACE,CAAAA,CAAQ,CACrB,KAAM,CAAE,KAAOG,CAAAA,CAAAA,CAAU,IAAKC,CAAO,CAAA,CAAI,MAAM,IAAA,CAAK,OAAO,IAAK,CAAA,OAAA,CAAQ,MAAO,CAAA,CAC7E,SAAU,CAAE,aAAA,CAAe,EAAK,CAClC,CAAC,EACDN,CAAQK,CAAAA,CAAAA,CACRJ,CAAMK,CAAAA,EACR,CAEA,GAAI,CAACN,EAAO,CACV,KAAM,CAAE,OAAAO,CAAAA,CAAQ,CAAIC,CAAAA,gBAAAA,CAAiB,kBAAmB,CAA4BR,yBAAAA,EAAAA,CAAK,EAAE,CAC3F,CAAA,MAAM,IAAI,KAAMO,CAAAA,CAAO,CACzB,CAEA,MAAME,CAAY,CAAA,MAAM,IAAK,CAAA,MAAA,CAAO,KAAK,MAAO,CAAA,eAAA,EAE1CC,CAAAA,CAAAA,CAASpB,gBAAgB,iBAAkB,CAAA,GAAA,CAAI,KAAOqB,YACtDC,CAAAA,CAAAA,CAAkBC,WAAWH,CAAM,CAAA,CACnCI,CAAWrD,CAAAA,CAAAA,CAAAC,IAAA,CACf,kBAAA,CAAAiC,EACA,kBAAAC,CAAAA,CAAAA,CACA,OAAQG,CAAA,EAAA,IAAA,CAAAA,CAAU,CAAA,CAAC,CAAE,QAAUgB,CAAAA,wBAAyB,CAAC,CACzD,CAAA,QAAA,CAAU,CACR,SAAAN,CAAAA,CAAAA,CACA,QAAU,CAAA,IAAA,CAAK,OAAO,QACxB,CAAA,CACA,eAAAG,CAAAA,CAAAA,CACA,aAAcZ,CACVH,CAAAA,CAAAA,CAAAA,EAAqB,CAAE,iBAAA,CAAAA,CAAkB,CACzCC,CAAAA,CAAAA,CAAAA,EAAoB,CAAE,gBAAAA,CAAAA,CAAiB,GAX5B,CAYf,EAAA,CAAIkB,SAAU,EAChB,GACMC,CAAuBC,CAAAA,WAAAA,CAAY,kBAAmBJ,CAAS,CAAA,EAAE,EAEjE,CACJ,MAAA,CAAAK,CACA,CAAA,OAAA,CAAAC,EACA,IAAMC,CAAAA,CACR,EAAIC,oBAA0CZ,CAAAA,CAAAA,CAAQa,uBAAuB,CAEvEC,CAAAA,CAAAA,CAAwB,CAAC,CAAE,GAAAC,CAAG,CAAA,GAAsB,CACpDA,CAAAA,GAAOX,EAAS,EAClB,GAAA,IAAA,CAAK,MAAO,CAAA,MAAA,CAAO,IAAI,iBAAmBU,CAAAA,CAAqB,EAC/D,IAAK,CAAA,eAAA,CAAgB,OAAOV,CAAS,CAAA,EAAE,CAEvC,CAAA,IAAA,CAAK,OAAO,IAAKG,CAAAA,CAAAA,CAAsB,CACrC,KAAO,CAAA,CAAE,QAASM,uBAAyB,CAAA,IAAA,CAAM,CAAE,CACrD,CAAC,CAEL,EAAA,CAAA,CAEA,YAAK,MAAO,CAAA,MAAA,CAAO,GAAG,iBAAmBC,CAAAA,CAAqB,CAC9D,CAAA,IAAA,CAAK,OAAO,IAAwBP,CAAAA,CAAAA,CAAsB,CAAC,CAAE,MAAAb,CAAO,CAAA,OAAA,CAAAsB,CAAQ,CAAA,GAAM,CAChF,IAAK,CAAA,MAAA,CAAO,OAAO,GAAI,CAAA,iBAAA,CAAmBF,CAAqB,CAC3DpB,CAAAA,CAAAA,CAAOe,CAAOf,CAAAA,CAAK,EACdsB,CACPN,EAAAA,CAAAA,CAAQM,CAAO,EAEnB,CAAC,EAED,MAAM,IAAA,CAAK,kBAAmB,CAAA,CAC5B,SAAAZ,CACA,CAAA,WAAA,CAAa,CACX,QAAU,CAAA,CACR,qBAAsB,CACxB,CAAA,CAAA,CACA,GAAK,CAAA,CACH,cAAeA,CAAS,CAAA,EAC1B,CACF,CACF,CAAC,CAED,CAAA,MAAM,IAAK,CAAA,WAAA,CAAYA,EAAS,EAAIA,CAAAA,CAAQ,EACrC,CAAE,GAAA,CAAAb,EAAK,QAAAoB,CAAAA,CAAS,CACzB,CAAA,CAAA,CAEArC,EAAA,IAAO,CAAA,MAAA,CAAwB,MAAOd,CAAAA,EAAW,CAC/C,IAAK,CAAA,aAAA,EACL,CAAA,MAAM,KAAK,yBAA0B,EAAA,CACrC,GAAI,CACF,OAAO,MAAM,IAAK,CAAA,MAAA,CAAO,IAAK,CAAA,OAAA,CAAQ,KAAKA,CAAM,CACnD,CAASkC,MAAAA,CAAAA,CAAO,CACd,MAAK,IAAA,CAAA,MAAA,CAAO,MAAO,CAAA,KAAA,CAAM,eAAe,CAClCA,CAAAA,CACR,CACF,CAEApB,CAAAA,CAAAA,CAAAA,CAAA,KAAO,SAA8B,CAAA,MAAOd,CAAW,EAAA,CA1VzD,IAAAC,CAAAC,CAAAA,CAAAA,CAAAuD,EA2VI,MAAMC,CAAAA,CAAc,KAAK,MAAO,CAAA,IAAA,CAAK,WAAY,CAAA,WAAA,CAAY,CAC3D,UAAY,CAAA,CACV,OAAOzD,CAAAD,CAAAA,CAAAA,EAAA,YAAAA,CAAQ,CAAA,EAAA,GAAR,IAAAC,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAY,WACnB,KAAO,CAAA,CAAC0D,2BAA4B,CAAA,uBAAuB,CAC7D,CACF,CAAC,CACD,CAAA,GAAI,CACF,IAAK,CAAA,aAAA,GACL,MAAM,IAAA,CAAK,4BACb,CAAA,MAASzB,CAAO,CAAA,CACd,MAAAwB,CAAY,CAAA,QAAA,CAASE,4BAA4B,sBAAsB,CAAA,CACjE1B,CACR,CACA,GAAI,CACF,MAAM,KAAK,iBAAkBlC,CAAAA,CAAAA,EAAA,YAAAA,CAAQ,CAAA,EAAE,EACzC,CAASkC,MAAAA,CAAAA,CAAO,CACd,MAAA,IAAA,CAAK,OAAO,MAAO,CAAA,KAAA,CAAM,CAA6BlC,0BAAAA,EAAAA,CAAAA,EAAA,YAAAA,CAAQ,CAAA,EAAE,CAAU,QAAA,CAAA,CAAA,CAC1E0D,EAAY,QAASE,CAAAA,2BAAAA,CAA4B,kBAAkB,CAC7D1B,CAAAA,CACR,CAEA,GAAI,CACF,MAAM,IAAA,CAAK,eAAelC,CAAM,EAClC,OAASkC,CAAO,CAAA,CACd,WAAK,MAAO,CAAA,MAAA,CAAO,KAAM,CAAA,sCAAsC,EAC/DwB,CAAY,CAAA,QAAA,CACVE,4BAA4B,4CAC9B,CAAA,CACM1B,CACR,CAEA,KAAM,CAAE,EAAA,CAAAqB,EAAI,aAAAM,CAAAA,CAAAA,CAAe,UAAAC,CAAAA,CAAAA,CAAY,kBAAAnC,CAAmB,CAAA,gBAAA,CAAAC,CAAkB,CAAA,aAAA,CAAAmC,CAAc,CACxF/D,CAAAA,CAAAA,CAEI4C,EAAW,IAAK,CAAA,MAAA,CAAO,SAAS,GAAIW,CAAAA,CAAE,CAE5C,CAAA,IAAA,CAAK,OAAO,IAAK,CAAA,WAAA,CAAY,WAAY,CAAA,CAAE,QAASG,CAAY,CAAA,OAAQ,CAAC,CAAA,CAEzE,KAAM,CAAE,YAAA,CAAAlC,EAAc,QAAAwC,CAAAA,CAAAA,CAAU,mBAAAvC,CAAoB,CAAA,kBAAA,CAAAC,CAAmB,CAAA,CAAIkB,EAE3E,IAAIqB,CAAAA,CAAAA,CAAQ/D,CAAA,CAAA,IAAA,CAAK,OAAO,IAAK,CAAA,WAAA,GAAjB,IAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAA8B,SAAS,CACjD,KAAA,CAAOsB,CACT,CACKyC,CAAAA,CAAAA,CAAAA,GACHA,GAAQR,CAAA,CAAA,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,cAAjB,IAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAA8B,YAAY,CAChD,IAAA,CAAME,4BAA4B,uBAClC,CAAA,UAAA,CAAY,CACV,KAAA,CAAOnC,EACP,KAAO,CAAA,CACLmC,4BAA4B,uBAC5BA,CAAAA,2BAAAA,CAA4B,qCAC9B,CACF,CACF,CAGF,CAAA,CAAA,CAAA,MAAMO,EAAgB,MAAM,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,OAAO,eAAgB,EAAA,CAC9DC,CAAgBH,CAAAA,CAAAA,CAAS,UACzBI,CAAe,CAAA,MAAM,KAAK,MAAO,CAAA,IAAA,CAAK,OAAO,iBACjDF,CAAAA,CAAAA,CACAC,CACF,CAAA,CACME,EAAgB7E,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CACpB,MAAO,CAAE,QAAA,CAAUqE,GAAA,IAAAA,CAAAA,CAAAA,CAAiB,KAAM,CAAA,CAC1C,WAAAC,CACA,CAAA,UAAA,CAAY,CAAE,SAAWI,CAAAA,CAAAA,CAAe,SAAU,IAAK,CAAA,MAAA,CAAO,QAAS,CAAA,CACvE,OAAQvB,UAAW2B,CAAAA,cAAc,CAC7B3C,CAAAA,CAAAA,CAAAA,EAAqB,CAAE,iBAAAA,CAAAA,CAAkB,CACzCC,CAAAA,CAAAA,CAAAA,EAAoB,CAAE,gBAAAA,CAAAA,CAAiB,GACvCmC,CAAiB,EAAA,CAAE,cAAAA,CAAc,CAAA,CAAA,CAEjCQ,CAAgBC,CAAAA,eAAAA,CAAgB,MACtCP,CAAM,CAAA,QAAA,CAASN,4BAA4B,yBAAyB,CAAA,CACpE,GAAI,CACF,MAAM,IAAK,CAAA,MAAA,CAAO,KAAK,OAAQ,CAAA,SAAA,CAAUS,EAAc,CACrD,aAAA,CAAAG,EACA,QAAU,CAAA,CAAE,aAAe,CAAA,CAAA,CAAK,CAClC,CAAC,EACH,CAASrC,MAAAA,CAAAA,CAAO,CACd,MAAA+B,CAAAA,CAAM,QAASL,CAAAA,2BAAAA,CAA4B,+BAA+B,CACpE1B,CAAAA,CACR,CAEA+B,CAAM,CAAA,QAAA,CAASN,4BAA4B,+BAA+B,CAAA,CAE1E,MAAMH,CAAAA,CAAUjE,EAAAC,CAAA,CAAA,EAAA,CACX6E,CADW,CAAA,CAAA,CAEd,MAAOD,CACP,CAAA,kBAAA,CAAA3C,CACA,CAAA,kBAAA,CAAAC,EACA,YAAAF,CAAAA,CAAAA,CACA,aAAc,CACd,CAAA,CAAA,IAAA,CAAM6C,EAAc,UACpB,CAAA,IAAA,CAAM,CACJ,SAAA,CAAWL,EAAS,SACpB,CAAA,QAAA,CAAUA,CAAS,CAAA,QACrB,EACA,UAAYE,CAAAA,CAAAA,CACZ,aAAeM,CAAAA,eAAAA,CAAgB,KACjC,CACA,CAAA,CAAA,MAAM,KAAK,MAAO,CAAA,OAAA,CAAQ,IAAIJ,CAAcZ,CAAAA,CAAO,CAEnDS,CAAAA,CAAAA,CAAM,SAASN,2BAA4B,CAAA,aAAa,EAExD,GAAI,CACF,MAAM,IAAK,CAAA,kBAAA,CAAmB,CAC5B,YAAA,CAAAS,EACA,QAAAxB,CAAAA,CAAAA,CACA,wBAAyB,CACvB,KAAA,CAAO,CACL,QAAUiB,CAAAA,CAAAA,EAAA,IAAAA,CAAAA,CAAAA,CAAiB,KAC7B,CACA,CAAA,kBAAA,CAAoBK,CACtB,CAAA,CACA,qBAAsBG,CACtB,CAAA,WAAA,CAAa,CACX,QAAA,CAAU,CACR,oBAAsB,CAAA,CAAA,CACxB,EACA,GAAK,CAAA,CACH,cAAed,CACjB,CACF,CACF,CAAC,EAEDU,CAAM,CAAA,QAAA,CAASN,4BAA4B,+BAA+B,EAC5E,OAASzB,CAAO,CAAA,CACd,MAAK,IAAA,CAAA,MAAA,CAAO,OAAO,KAAMA,CAAAA,CAAK,EAE9B,IAAK,CAAA,MAAA,CAAO,QAAQ,MAAOkC,CAAAA,CAAAA,CAAcK,WAAY,CAAA,mBAAmB,CAAC,CACzE,CAAA,MAAM,IAAK,CAAA,MAAA,CAAO,KAAK,OAAQ,CAAA,WAAA,CAAYL,CAAY,CAAA,CACjDlC,CACR,CAEA,OAAA,IAAA,CAAK,OAAO,IAAK,CAAA,WAAA,CAAY,YAAY,CAAE,OAAA,CAAS+B,CAAM,CAAA,OAAQ,CAAC,CAEnE,CAAA,MAAM,KAAK,MAAO,CAAA,IAAA,CAAK,QAAQ,cAAe,CAAA,CAC5C,KAAOzC,CAAAA,CAAAA,CACP,SAAUwC,CAAS,CAAA,QACrB,CAAC,CACD,CAAA,MAAM,KAAK,cAAeT,CAAAA,CAAE,CAC5B,CAAA,MAAM,KAAK,MAAO,CAAA,IAAA,CAAK,OAAQ,CAAA,QAAA,CAAS,CAAE,KAAO/B,CAAAA,CAAa,CAAC,CAAA,CAC/D,MAAM,IAAK,CAAA,SAAA,CAAU4C,EAAczB,UAAW2B,CAAAA,cAAc,CAAC,CACtD,CAAA,CACL,KAAOF,CAAAA,CAAAA,CACP,aAAc,IAAM,OAAA,CAAQ,QAAQ,IAAK,CAAA,MAAA,CAAO,QAAQ,GAAIA,CAAAA,CAAY,CAAC,CAC3E,CACF,CAEAtD,CAAAA,CAAAA,CAAAA,CAAA,KAAO,QAA4B,CAAA,MAAOd,GAAW,CACnD,IAAA,CAAK,aAAc,EAAA,CACnB,MAAM,IAAK,CAAA,yBAAA,EACX,CAAA,GAAI,CACF,MAAM,IAAA,CAAK,aAAcA,CAAAA,CAAM,EACjC,CAASkC,MAAAA,CAAAA,CAAO,CACd,MAAK,IAAA,CAAA,MAAA,CAAO,OAAO,KAAM,CAAA,oCAAoC,CACvDA,CAAAA,CACR,CACA,KAAM,CAAE,GAAAqB,CAAI,CAAA,MAAA,CAAAmB,CAAO,CAAI1E,CAAAA,CAAAA,CACvB,IAAIwB,CAAAA,CACJ,GAAI,CAEFA,CAAAA,CADiB,KAAK,MAAO,CAAA,QAAA,CAAS,IAAI+B,CAAE,CAAA,CACpB,aAC1B,CAAA,MAASrB,EAAO,CACd,MAAA,IAAA,CAAK,MAAO,CAAA,MAAA,CAAO,MAAM,CAA4BqB,yBAAAA,EAAAA,CAAE,CAAU,QAAA,CAAA,CAAA,CAC3DrB,CACR,CAEIV,CAAAA,EACF,MAAM,IAAK,CAAA,SAAA,CAAU,CACnB,EAAA+B,CAAAA,CAAAA,CACA,KAAO/B,CAAAA,CAAAA,CACP,MAAOkD,CACP,CAAA,OAAA,CAAStD,gBAAgB,iBAAkB,CAAA,MAC7C,CAAC,CAGH,CAAA,MAAM,IAAK,CAAA,cAAA,CAAemC,CAAE,EAC9B,CAAA,CAAA,CAEAzC,EAAA,IAAO,CAAA,QAAA,CAA4B,MAAOd,CAAW,EAAA,CACnD,IAAK,CAAA,aAAA,GACL,MAAM,IAAA,CAAK,yBAA0B,EAAA,CACrC,GAAI,CACF,MAAM,IAAK,CAAA,aAAA,CAAcA,CAAM,EACjC,CAAA,MAASkC,EAAO,CACd,MAAA,IAAA,CAAK,OAAO,MAAO,CAAA,KAAA,CAAM,oCAAoC,CAAA,CACvDA,CACR,CACA,KAAM,CAAE,KAAAJ,CAAAA,CAAAA,CAAO,WAAAgC,CAAW,CAAA,CAAI9D,CAExB,CAAA,CAAE,KAAM2E,CAAc,CAAA,OAAA,CAAAzB,EAAS,MAAAD,CAAAA,CAAO,EAAIG,oBAA2B,EAAA,CACrEwB,CAAc9B,CAAAA,SAAAA,GACd+B,CAAaC,CAAAA,cAAAA,EAAiB,CAAA,QAAA,GAE9BC,CAAgB,CAAA,IAAA,CAAK,MAAO,CAAA,OAAA,CAAQ,IAAIjD,CAAK,CAAA,CAAE,WACrD,OAAK,IAAA,CAAA,MAAA,CAAO,KAAKkB,WAAY,CAAA,gBAAA,CAAkB4B,CAAW,CAAA,CAAG,CAAC,CAAE,KAAA,CAAA1C,CAAM,CAAA,GAAW,CAC3EA,CAAOe,CAAAA,CAAAA,CAAOf,CAAK,CAAA,CAErBgB,IAEJ,CAAC,EAID,MAAM,IAAA,CAAK,OAAO,OAAQ,CAAA,MAAA,CAAOpB,CAAO,CAAA,CAAE,WAAAgC,CAAW,CAAC,CACtD,CAAA,MAAM,KAAK,WAAY,CAAA,CACrB,KAAAhC,CAAAA,CAAAA,CACA,OAAQ,kBACR,CAAA,MAAA,CAAQ,CAAE,UAAAgC,CAAAA,CAAW,EACrB,oBAAsB,CAAA,CAAA,CAAA,CACtB,WAAAc,CAAAA,CAAAA,CACA,WAAAC,CACF,CAAC,EAAE,KAAO3C,CAAAA,CAAAA,EAAU,CAClB,IAAK,CAAA,MAAA,CAAO,MAAO,CAAA,KAAA,CAAMA,CAAK,CAC9B,CAAA,IAAA,CAAK,OAAO,OAAQ,CAAA,MAAA,CAAOJ,EAAO,CAAE,UAAA,CAAYiD,CAAc,CAAC,EAC/D9B,CAAOf,CAAAA,CAAK,EACd,CAAC,EACM,CAAE,YAAA,CAAAyC,CAAa,CACxB,GAEA7D,CAAA,CAAA,IAAA,CAAO,SAA4B,MAAOd,CAAAA,EAAW,CACnD,IAAK,CAAA,aAAA,EACL,CAAA,MAAM,KAAK,yBAA0B,EAAA,CACrC,GAAI,CACF,MAAM,KAAK,aAAcA,CAAAA,CAAM,EACjC,CAAA,MAASkC,EAAO,CACd,MAAA,IAAA,CAAK,OAAO,MAAO,CAAA,KAAA,CAAM,oCAAoC,CACvDA,CAAAA,CACR,CAEA,KAAM,CAAE,KAAAJ,CAAAA,CAAM,CAAI9B,CAAAA,CAAAA,CACZ4E,EAAc9B,SAAU,EAAA,CACxB,CAAE,IAAA,CAAM6B,EAAc,OAAAzB,CAAAA,CAAAA,CAAS,OAAAD,CAAO,CAAA,CAAIG,sBAChD,CAAA,OAAA,IAAA,CAAK,MAAO,CAAA,IAAA,CAAKJ,YAAY,gBAAkB4B,CAAAA,CAAW,EAAG,CAAC,CAAE,MAAA1C,CAAM,CAAA,GAAW,CAC3EA,CAAAA,CAAOe,EAAOf,CAAK,CAAA,CAClBgB,IACP,CAAC,EAED,MAAM,IAAA,CAAK,SAAUpB,CAAAA,CAAAA,CAAOa,WAAW2B,cAAc,CAAC,CACtD,CAAA,IAAA,CAAK,YAAY,CACf,KAAA,CAAAxC,CACA,CAAA,MAAA,CAAQ,mBACR,MAAQ,CAAA,GACR,WAAA8C,CAAAA,CAAAA,CACA,qBAAsB,CACxB,CAAA,CAAC,CAAE,CAAA,KAAA,CAAOI,GAAM,CACd/B,CAAAA,CAAO+B,CAAC,EACV,CAAC,CAEM,CAAA,CAAE,YAAAL,CAAAA,CAAa,CACxB,CAEA7D,CAAAA,CAAAA,CAAAA,CAAA,KAAO,SAA8B,CAAA,MAAUd,GAAsC,CACnF,IAAA,CAAK,aAAc,EAAA,CACnB,GAAI,CACF,MAAM,IAAK,CAAA,cAAA,CAAeA,CAAM,EAClC,CAAA,MAASkC,CAAO,CAAA,CACd,WAAK,MAAO,CAAA,MAAA,CAAO,MAAM,sCAAsC,CAAA,CACzDA,CACR,CACA,KAAM,CAAE,OAAA,CAAA+C,EAAS,OAAAC,CAAAA,CAAAA,CAAS,MAAApD,CAAO,CAAA,MAAA,CAAAU,EAASpB,eAAgB,CAAA,iBAAA,CAAkB,GAAI,CAAA,GAAI,EAAIpB,CAClFwD,CAAAA,CAAAA,CAAU,KAAK,MAAO,CAAA,OAAA,CAAQ,IAAI1B,CAAK,CAAA,CAAA,CAEzC0B,CAAA,EAAA,IAAA,CAAA,KAAA,CAAA,CAAAA,EAAS,aAAkBgB,IAAAA,eAAAA,CAAgB,KAC7C,EAAA,MAAM,KAAK,yBAA0B,EAAA,CAEvC,MAAMI,CAAAA,CAAc9B,WACd+B,CAAAA,CAAAA,CAAaC,gBAAiB,CAAA,QAAA,GAC9B,CAAE,IAAA,CAAAK,CAAM,CAAA,OAAA,CAAAjC,EAAS,MAAAD,CAAAA,CAAO,EAAIG,oBAChCZ,CAAAA,CAAAA,CACA,oCACF,CACA,CAAA,IAAA,CAAK,MAAO,CAAA,IAAA,CACVQ,YAAY,iBAAmB4B,CAAAA,CAAW,EAC1C,CAAC,CAAE,MAAA1C,CAAO,CAAA,MAAA,CAAAkD,CAAO,CAAA,GAAM,CACjBlD,CAAOe,CAAAA,CAAAA,CAAOf,CAAK,CAAA,CAClBgB,EAAQkC,CAAM,EACrB,CACF,CAAA,CACA,MAAMC,CAAiB,CAAA,mBAAA,CACjBC,EAAU,IAAK,CAAA,mBAAA,CAAoB9B,EAAQ,IAAK,CAAA,QAAA,CAAUA,CAAQ,CAAA,aAAa,EACrF,GAAI8B,CAAAA,CACF,aAAM,IAAK,CAAA,WAAA,CAAY,CACrB,WAAAV,CAAAA,CAAAA,CACA,UAAAC,CAAAA,CAAAA,CACA,MAAA/C,CACA,CAAA,MAAA,CAAQuD,EACR,MAAQ,CAAA,CACN,QAAS9F,CAAAC,CAAAA,CAAAA,CAAA,EACJ0F,CAAAA,CAAAA,CAAAA,CADI,CAEP,eAAiBvC,CAAAA,UAAAA,CAAWH,CAAM,CACpC,GACA,OAAAyC,CAAAA,CACF,CACA,CAAA,MAAA,CAAAzC,EACA,oBAAsB,CAAA,CAAA,CAAA,CACtB,QAAA8C,CACF,CAAC,EAAE,KAAOpD,CAAAA,CAAAA,EAAUe,CAAOf,CAAAA,CAAK,CAAC,CAEjC,CAAA,IAAA,CAAK,MAAO,CAAA,MAAA,CAAO,KAAK,sBAAwB,CAAA,CAC9C,KAAAJ,CAAAA,CAAAA,CACA,QAAAoD,CACA,CAAA,OAAA,CAAAD,EACA,EAAIL,CAAAA,CACN,CAAC,CACc,CAAA,MAAMO,CAAK,EAAA,CAI5B,MAAMI,CAAyE,CAAA,CAC7E,OAAShG,CAAAA,CAAAA,CAAAC,EAAA,EACJ0F,CAAAA,CAAAA,CAAAA,CADI,CAEP,eAAA,CAAiBvC,WAAWH,CAAM,CACpC,GACA,OAAAyC,CAAAA,CACF,EAEA,OAAO,MAAM,OAAQ,CAAA,GAAA,CAAI,CACvB,IAAI,OAAA,CAAc,MAAO/B,CAAY,EAAA,CACnC,MAAM,IAAK,CAAA,WAAA,CAAY,CACrB,WAAA,CAAA0B,EACA,UAAAC,CAAAA,CAAAA,CACA,MAAA/C,CACA,CAAA,MAAA,CAAQuD,EACR,MAAQE,CAAAA,CAAAA,CACR,MAAA/C,CAAAA,CAAAA,CACA,qBAAsB,CACtB,CAAA,CAAA,GAAA,CAAK,IAAK,CAAA,YAAA,CAAaoC,EAAaW,CAAqB,CAC3D,CAAC,CAAA,CAAE,MAAOrD,CAAUe,EAAAA,CAAAA,CAAOf,CAAK,CAAC,CAAA,CACjC,KAAK,MAAO,CAAA,MAAA,CAAO,IAAK,CAAA,sBAAA,CAAwB,CAC9C,KAAAJ,CAAAA,CAAAA,CACA,QAAAoD,CACA,CAAA,OAAA,CAAAD,EACA,EAAIL,CAAAA,CACN,CAAC,CAAA,CACD1B,IACF,CAAC,EACD,IAAI,OAAA,CAAc,MAAOA,CAAY,EAAA,CA7qB3C,IAAAjD,CAAAA,CA+qBQ,GAAI,EAACA,CAAAA,CAAAA,CAAAuD,CAAQ,CAAA,aAAA,GAAR,MAAAvD,CAAuB,CAAA,eAAA,CAAA,CAAiB,CAC3C,MAAMuF,EAAc,MAAMC,WAAAA,CACxB,KAAK,MAAO,CAAA,IAAA,CAAK,QACjBC,6BACF,CAAA,CACA,MAAMC,sBAAAA,CAAuB,CAAE,EAAIf,CAAAA,CAAAA,CAAa,MAAA9C,CAAO,CAAA,UAAA,CAAA0D,CAAW,CAAC,EACrE,CACAtC,CAAAA,GACF,CAAC,CAAA,CACDiC,GACF,CAAC,EAAE,IAAMC,CAAAA,CAAAA,EAAWA,CAAO,CAAA,CAAC,CAAC,CAC/B,CAAA,CAAA,CAEAtE,CAAA,CAAA,IAAA,CAAO,UAA8B,MAAOd,CAAAA,EAAW,CACrD,IAAA,CAAK,eACL,CAAA,MAAM,KAAK,cAAeA,CAAAA,CAAM,EAChC,KAAM,CAAE,KAAA8B,CAAAA,CAAAA,CAAO,SAAA8D,CAAS,CAAA,CAAI5F,EACtB,CAAE,EAAA,CAAAuD,CAAG,CAAIqC,CAAAA,CAAAA,CACTpC,CAAU,CAAA,IAAA,CAAK,OAAO,OAAQ,CAAA,GAAA,CAAI1B,CAAK,CAEzC0B,CAAAA,CAAAA,CAAQ,gBAAkBgB,eAAgB,CAAA,KAAA,EAC5C,MAAM,IAAA,CAAK,2BAGb,CAAA,MAAMc,CAAU,CAAA,IAAA,CAAK,oBAAoB9B,CAAQ,CAAA,IAAA,CAAK,QAAUA,CAAAA,CAAAA,CAAQ,aAAa,CACjFqC,CAAAA,eAAAA,CAAgBD,CAAQ,CAC1B,CAAA,MAAM,KAAK,UAAW,CAAA,CACpB,EAAArC,CAAAA,CAAAA,CACA,MAAAzB,CACA,CAAA,MAAA,CAAQ8D,EAAS,MACjB,CAAA,oBAAA,CAAsB,GACtB,OAAAN,CAAAA,CACF,CAAC,CAAA,CACQQ,eAAeF,CAAQ,CAAA,EAChC,MAAM,IAAK,CAAA,SAAA,CAAU,CAAE,EAAArC,CAAAA,CAAAA,CAAI,KAAAzB,CAAAA,CAAAA,CAAO,MAAO8D,CAAS,CAAA,KAAA,CAAO,OAAAN,CAAAA,CAAQ,CAAC,CAEpE,CAAA,IAAA,CAAK,oBAAqBtF,CAAAA,CAAM,EAClC,CAEAc,CAAAA,CAAAA,CAAAA,CAAA,KAAO,MAAwB,CAAA,MAAOd,GAAW,CAC/C,IAAA,CAAK,aAAc,EAAA,CACnB,MAAM,IAAK,CAAA,yBAAA,GACX,GAAI,CACF,MAAM,IAAK,CAAA,WAAA,CAAYA,CAAM,EAC/B,OAASkC,CAAO,CAAA,CACd,WAAK,MAAO,CAAA,MAAA,CAAO,MAAM,gCAAgC,CAAA,CACnDA,CACR,CACA,KAAM,CAAE,KAAA,CAAAJ,CAAM,CAAA,CAAI9B,EAClB,GAAI,IAAA,CAAK,MAAO,CAAA,OAAA,CAAQ,KAAK,QAAS8B,CAAAA,CAAK,EAAG,CAC5C,MAAM8C,EAAc9B,SAAU,EAAA,CACxB+B,CAAaC,CAAAA,cAAAA,GAAiB,QAAS,EAAA,CACvC,CAAE,IAAAK,CAAAA,CAAAA,CAAM,QAAAjC,CAAS,CAAA,MAAA,CAAAD,CAAO,CAAA,CAAIG,sBAClC,CAAA,IAAA,CAAK,OAAO,IAAKJ,CAAAA,WAAAA,CAAY,eAAgB4B,CAAW,CAAA,CAAG,CAAC,CAAE,MAAA1C,CAAM,CAAA,GAAW,CACzEA,CAAAA,CAAOe,EAAOf,CAAK,CAAA,CAClBgB,CAAQ,GACf,CAAC,CACD,CAAA,MAAM,QAAQ,GAAI,CAAA,CAChB,KAAK,WAAY,CAAA,CACf,KAAApB,CAAAA,CAAAA,CACA,OAAQ,gBACR,CAAA,MAAA,CAAQ,EAAC,CACT,qBAAsB,CACtB,CAAA,CAAA,WAAA,CAAA8C,CACA,CAAA,UAAA,CAAAC,CACF,CAAC,CAAA,CACDM,GACF,CAAC,EACH,CAAW,KAAA,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,QAAQ,QAAS,CAAA,IAAA,CAAK,QAASrD,CAAAA,CAAK,IAC9D,IAAK,CAAA,MAAA,CAAO,MAAO,CAAA,IAAA,CACjB,sFACF,CACA,CAAA,MAAM,KAAK,MAAO,CAAA,IAAA,CAAK,QAAQ,IAAK,CAAA,CAAE,KAAAA,CAAAA,CAAM,CAAC,CAEjD,EAAA,CAAA,CAAA,CAEAhB,EAAA,IAAO,CAAA,MAAA,CAAwB,MAAOd,CAAW,EAAA,CAC/C,IAAK,CAAA,aAAA,GACL,MAAM,IAAA,CAAK,2BACX,CAAA,MAAM,KAAK,WAAYA,CAAAA,CAAM,CAC7B,CAAA,KAAM,CAAE,KAAA8B,CAAAA,CAAAA,CAAO,KAAAmC,CAAAA,CAAAA,CAAO,QAAAgB,CAAQ,CAAA,CAAIjF,CAC5B6E,CAAAA,CAAAA,CAAaC,gBAAiB,CAAA,QAAA,GAC9BF,CAAc9B,CAAAA,SAAAA,GACpB,MAAM,IAAA,CAAK,WAAY,CAAA,CACrB,MAAAhB,CACA,CAAA,MAAA,CAAQ,kBACR,MAAQ,CAAA,CAAE,MAAAmC,CAAO,CAAA,OAAA,CAAAgB,CAAQ,CAAA,CACzB,qBAAsB,CACtB,CAAA,CAAA,UAAA,CAAAJ,EACA,WAAAD,CAAAA,CACF,CAAC,EACH,CAAA,CAAA,CAEA9D,CAAA,CAAA,IAAA,CAAO,aAAoC,MAAOd,CAAAA,EAAW,CAC3D,IAAA,CAAK,eACL,CAAA,MAAM,IAAK,CAAA,yBAAA,GACX,MAAM,IAAA,CAAK,kBAAkBA,CAAM,CAAA,CACnC,KAAM,CAAE,KAAA,CAAA8B,CAAM,CAAA,CAAI9B,EAClB,GAAI,IAAA,CAAK,OAAO,OAAQ,CAAA,IAAA,CAAK,SAAS8B,CAAK,CAAA,CAEzC,MAAM,IAAA,CAAK,YAAY,CACrB,KAAA,CAAAA,EACA,MAAQ,CAAA,kBAAA,CACR,OAAQ2C,WAAY,CAAA,mBAAmB,CACvC,CAAA,oBAAA,CAAsB,EACxB,CAAC,CAAA,CACD,MAAM,IAAA,CAAK,cAAc,CAAE,KAAA,CAAA3C,CAAO,CAAA,SAAA,CAAW,EAAM,CAAC,CAAA,CAAA,KAAA,GAC3C,KAAK,MAAO,CAAA,IAAA,CAAK,QAAQ,QAAS,CAAA,IAAA,CAAK,QAASA,CAAAA,CAAK,EAC9D,MAAM,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,QAAQ,UAAW,CAAA,CAAE,KAAAA,CAAAA,CAAM,CAAC,CAC9C,CAAA,KAAA,CACL,KAAM,CAAE,OAAA,CAAAO,CAAQ,CAAIC,CAAAA,gBAAAA,CAClB,kBACA,CAAA,CAAA,oCAAA,EAAuCR,CAAK,CAC9C,CAAA,CAAA,CACA,MAAM,IAAI,MAAMO,CAAO,CACzB,CACF,CAAA,CAAA,CAEAvB,EAAA,IAAO,CAAA,MAAA,CAAyBd,IAC9B,IAAK,CAAA,aAAA,GACE,IAAK,CAAA,MAAA,CAAO,OAAQ,CAAA,MAAA,GAAS,MAAQwD,CAAAA,CAAAA,EAAYuC,oBAAoBvC,CAASxD,CAAAA,CAAM,CAAC,CAG9Fc,CAAAA,CAAAA,CAAAA,CAAAA,CAAA,IAAO,CAAA,2BAAA,CAAkE,IAChE,IAAK,CAAA,MAAA,CAAO,eAAe,MAAO,EAAA,CAAA,CAK3CA,EAAA,IAAO,CAAA,cAAA,CAAwC,MAAOd,CAAAA,CAAQgG,IAAwB,CAhzBxF,IAAA/F,EAizBI,CAAA,IAAA,CAAK,eACL,CAAA,IAAA,CAAK,mBAAoBD,CAAAA,CAAM,EAE/B,MAAMiG,CAAAA,CACJD,GACA,IAAK,CAAA,MAAA,CAAO,KAAK,qBAAsB,CAAA,QAAA,CAASA,CAAmB,CAAA,GAAA,CACnE/F,GAAA,IAAK,CAAA,MAAA,CAAO,SAAS,QAArB,GAAA,IAAA,CAAA,KAAA,CAAA,CAAAA,GAA+B,QAE3BsE,CAAAA,CAAAA,CAAAA,CAA4C0B,CAC9CzB,CAAAA,eAAAA,CAAgB,UAChBA,eAAgB,CAAA,KAAA,CAEhBD,IAAkBC,eAAgB,CAAA,KAAA,EACpC,MAAM,IAAK,CAAA,yBAAA,EAGb,CAAA,KAAM,CACJ,MAAA0B,CAAAA,CAAAA,CACA,SAAAC,CAAAA,CAAAA,CAAY,GACZ,GAAApE,CAAAA,CAAAA,CACA,MAAAqE,CAAAA,CAAAA,CACA,MAAAC,CACA,CAAA,IAAA,CAAAC,EACA,GAAAC,CAAAA,CAAAA,CACA,IAAAC,CACA,CAAA,OAAA,CAAAC,CAAU,CAAA,GACV,MAAAjE,CAAAA,CACF,EAAIxC,CAEE0G,CAAAA,CAAAA,CAAY,CAAC,GAAI1G,CAAAA,CAAO,SAAa,EAAA,EAAG,CAExC,CAAA,CAAE,MAAOwB,CAAc,CAAA,GAAA,CAAKmF,CAAc,CAAI,CAAA,MAAM,IAAK,CAAA,MAAA,CAAO,KAAK,OAAQ,CAAA,MAAA,CAAO,CACxF,OAAA,CAAS,CAAC,wBAAwB,CAAA,CAClC,aAAApC,CAAAA,CACF,CAAC,CAED,CAAA,IAAA,CAAK,OAAO,MAAO,CAAA,IAAA,CAAK,CACtB,OAAS,CAAA,uBAAA,CACT,OAAS,CAAA,CAAE,MAAO/C,CAAc,CAAA,GAAA,CAAKmF,CAAc,CACrD,CAAC,CAED,CAAA,MAAMpE,CAAY,CAAA,MAAM,KAAK,MAAO,CAAA,IAAA,CAAK,OAAO,eAAgB,EAAA,CAC1DqE,EAAgBC,OAAQtE,CAAAA,CAAS,CAYvC,CAAA,GAVA,MAAM,OAAQ,CAAA,GAAA,CAAI,CAChB,IAAA,CAAK,OAAO,IAAK,CAAA,QAAA,CAAS,GAAIuE,CAAAA,oBAAAA,CAAsB,CAAE,aAAAF,CAAAA,CAAAA,CAAe,UAAArE,CAAU,CAAC,EAChF,IAAK,CAAA,MAAA,CAAO,IAAK,CAAA,aAAA,CAAc,IAAIqE,CAAe,CAAA,CAAE,MAAOA,CAAe,CAAA,YAAA,CAAApF,CAAa,CAAC,CAC1F,CAAC,CAAA,CAGD,MAAM,IAAK,CAAA,MAAA,CAAO,KAAK,OAAQ,CAAA,SAAA,CAAUoF,EAAe,CAAE,aAAA,CAAArC,CAAc,CAAC,EAEzE,IAAK,CAAA,MAAA,CAAO,MAAO,CAAA,IAAA,CAAK,yCAAyC/C,CAAY,CAAA,CAAE,CAE3EiF,CAAAA,CAAAA,CAAQ,OAAS,CAAG,CAAA,CACtB,KAAM,CAAE,SAAA,CAAAM,CAAU,CAAIC,CAAAA,YAAAA,CAAad,CAAO,CAAA,CAAC,CAAC,CAC5C,CAAA,IAAIe,EAAQC,kBAAmBH,CAAAA,CAAAA,CAAW,UAAWN,CAAO,CAAA,CACtCU,qBAAsBT,CAAAA,CAAS,IAKnDO,CADoBG,CAAAA,kBAAAA,CAAmBH,EAAOP,CAAU,CAAA,GAAA,EAAe,CAGzEA,CAAAA,CAAAA,CAAAA,CAAU,IAAKO,CAAAA,CAAK,EACtB,CAGA,MAAMI,CACJ7E,CAAAA,CAAAA,EAAUA,EAASpB,eAAgB,CAAA,sBAAA,CAAuB,GAAI,CAAA,GAAA,CAC1DoB,EACApB,eAAgB,CAAA,sBAAA,CAAuB,IAAI,GAE3C8D,CAAAA,CAAAA,CAAsD,CAC1D,WAAa,CAAA,CACX,IAAMoB,CAAAA,CAAAA,EAAA,KAAAA,CAAQ,CAAA,SAAA,CACd,OAAAJ,CACA,CAAA,SAAA,CAAAC,EACA,GAAKpE,CAAAA,CAAAA,CACL,MAAAqE,CAAAA,CAAAA,CACA,QAAS,GACT,CAAA,KAAA,CAAAC,EACA,GAAK,CAAA,IAAI,MAAO,CAAA,WAAA,EAChB,CAAA,GAAA,CAAAE,EACA,GAAAC,CAAAA,CAAAA,CACA,SAAAE,CAAAA,CACF,EACA,SAAW,CAAA,CAAE,SAAAnE,CAAAA,CAAAA,CAAW,SAAU,IAAK,CAAA,MAAA,CAAO,QAAS,CACvD,CAAA,eAAA,CAAiBI,WAAW0E,CAAiB,CAC/C,CAGMvD,CAAAA,CAAAA,CAAa,CACjB,MAAQ,CAAA,CACN,OAAAoC,CAEA,CAAA,OAAA,CAAS,CAAC,GAAG,IAAI,GAAI,CAAA,CAAC,gBAAiB,GAAGO,CAAO,CAAC,CAAC,CAAA,CACnD,OAAQ,CAAC,cAAA,CAAgB,iBAAiB,CAC5C,CACF,CAEM7D,CAAAA,CAAAA,CAAW,CACf,kBAAA,CAAoB,EACpB,CAAA,kBAAA,CAAoBkB,CACpB,CAAA,MAAA,CAAQ,CAAC,CAAE,QAAA,CAAU,KAAM,CAAC,CAAA,CAC5B,aAAAtC,CACA,CAAA,QAAA,CAAU,CACR,SAAA,CAAAe,EACA,QAAU,CAAA,IAAA,CAAK,OAAO,QACxB,CAAA,CACA,gBAAiBI,UAAWvB,CAAAA,eAAAA,CAAgB,iBAAkB,CAAA,GAAA,CAAI,GAAG,CACrE,CAAA,EAAA,CAAI0B,WACN,CAAA,CAEM,CAAE,IAAAqC,CAAAA,CAAAA,CAAM,OAAAjC,CAAAA,EAAAA,CAAS,OAAAD,EAAO,CAAA,CAAIG,oBAAqBiE,CAAAA,CAAAA,CAAmB,iBAAiB,CAErFC,CAAAA,CAAAA,CAAiBxE,SAAU,EAAA,CAC3ByE,GAA4BvE,WAAY,CAAA,iBAAA,CAAmBJ,EAAS,EAAE,CAAA,CACtE4E,GAA0BxE,WAAY,CAAA,iBAAA,CAAmBsE,CAAc,CAAA,CAGvEG,GAAmB,MAAO,CAAE,MAAAvF,CAAO,CAAA,OAAA,CAAAsB,CAAQ,CAAW,GAAA,CAE1D,IAAK,CAAA,MAAA,CAAO,IAAIgE,EAAyBE,CAAAA,EAAc,EACnDxF,CAAOe,CAAAA,EAAAA,CAAOf,CAAK,CACdsB,CAAAA,CAAAA,EACPN,EAAQ,CAAA,CACN,QAAAM,CACF,CAAC,EAEL,CAAA,CAEMkE,GAAiB,MAAOC,CAAAA,EAAiB,CAr7BnD,IAAA1H,GAAAC,EAAAuD,CAAAA,EAAAA,CAy7BM,GADA,MAAM,IAAA,CAAK,yBAAyB6D,CAAgB,CAAA,CAAE,OAAS,CAAA,WAAA,CAAa,KAAM,CAAE,CAAC,EACjFK,CAAQ,CAAA,KAAA,CAAO,CAGjB,MAAMzF,EAAAA,CAAQuC,WAAY,CAAA,uBAAA,CAAyB,wBAAwB,CAC3E,CAAA,OAAIkD,EAAQ,KAAM,CAAA,IAAA,GAASzF,GAAM,IAAM,CAAA,KAAA,CAAA,EAGvC,IAAK,CAAA,MAAA,CAAO,IAAIqF,EAA2BE,CAAAA,EAAgB,CACpDxE,CAAAA,EAAAA,CAAO0E,EAAQ,KAAM,CAAA,OAAO,CACrC,CAAA,CAEA,MAAM,IAAK,CAAA,cAAA,CAAe/E,EAAS,EAAE,CAAA,CAErC,KAAK,MAAO,CAAA,GAAA,CAAI2E,EAA2BE,CAAAA,EAAgB,EAE3D,KAAM,CACJ,MAAAG,CAAAA,CAAAA,CACA,UAAAC,CACF,CAAA,CAGIF,CAAQ,CAAA,MAAA,CAENG,GAA4B,EAAC,CAC7BC,GAA6B,EAAC,CACpC,UAAWC,EAASJ,IAAAA,CAAAA,CAAQ,CACV,MAAMK,oBAAoB,CAAE,KAAA,CAAAD,EAAO,CAAA,SAAA,CAAW,KAAK,MAAO,CAAA,IAAA,CAAK,SAAU,CAAC,IAExF,IAAK,CAAA,MAAA,CAAO,OAAO,KAAMA,CAAAA,EAAAA,CAAO,+BAA+B,CAC/D/E,CAAAA,EAAAA,CAAOwB,WAAY,CAAA,2BAAA,CAA6B,+BAA+B,CAAC,CAAA,CAAA,CAGlF,KAAM,CAAE,CAAA,CAAGkD,EAAQ,CAAIK,CAAAA,EAAAA,CACjBf,EAAQE,CAAAA,qBAAAA,CAAsBQ,GAAQ,SAAS,CAAA,CAE/CO,GAA2B,CAACC,uBAAAA,CAAwBR,GAAQ,GAAG,CAAW,CAC1ES,CAAAA,EAAAA,CAAgBC,cAAcV,EAAQ,CAAA,GAAG,CAE/C,CAAA,GAAIV,GAAO,CACT,MAAMqB,EAAmBC,CAAAA,mBAAAA,CAAoBtB,EAAK,CAC5CuB,CAAAA,EAAAA,CAAkBC,mBAAmBxB,EAAK,CAAA,CAChDa,GAAgB,IAAK,CAAA,GAAGQ,EAAgB,CAAA,CACxCJ,GAAe,IAAK,CAAA,GAAGM,EAAe,EACxC,CAEA,UAAWpJ,EAAS8I,IAAAA,EAAAA,CAClBH,EAAiB,CAAA,IAAA,CAAK,GAAG3I,EAAK,CAAA,CAAA,EAAIgJ,EAAa,CAAE,CAAA,EAErD,CACA,MAAMhE,EAAAA,CAAe,MAAM,IAAA,CAAK,OAAO,IAAK,CAAA,MAAA,CAAO,iBACjD7B,CAAAA,CAAAA,CACAsF,EAAU,SACZ,CAAA,CAGA,IAAIrE,EAAAA,CAEAsE,GAAgB,MAAS,CAAA,CAAA,GAC3BtE,GAAU,CACR,KAAA,CAAOY,GACP,YAAc,CAAA,CAAA,CAAA,CACd,IAAM,CAAA,CACJ,UAAA7B,CACA,CAAA,QAAA,CAAU,KAAK,MAAO,CAAA,QACxB,EACA,IAAMsF,CAAAA,CAAAA,CACN,UAAYA,CAAAA,CAAAA,CAAU,UACtB,MAAQlF,CAAAA,UAAAA,CAAW2B,cAAc,CACjC,CAAA,kBAAA,CAAoB,EACpB,CAAA,kBAAA,CAAoB,EAAC,CACrB,MAAO,CAAE,QAAA,CAAU,KAAM,CAAA,CACzB,aAAA9C,CACA,CAAA,UAAA,CAAYkH,uBACV,CAAA,CAAC,GAAG,IAAI,GAAA,CAAIZ,EAAe,CAAC,CAAA,CAC5B,CAAC,GAAG,IAAI,GAAIC,CAAAA,EAAgB,CAAC,CAC/B,CAAA,CACA,aAAAxD,CAAAA,CACF,EAEA,MAAM,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,QAAQ,SAAUH,CAAAA,EAAAA,CAAc,CAAE,aAAAG,CAAAA,CAAc,CAAC,CACxE,CAAA,MAAM,IAAK,CAAA,MAAA,CAAO,QAAQ,GAAIH,CAAAA,EAAAA,CAAcZ,EAAO,CAAA,CAC/ChC,GACF,MAAM,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,QAAQ,cAAe,CAAA,CAC5C,MAAOA,CACP,CAAA,QAAA,CAAUqG,EAAU,QACtB,CAAC,CAGHrE,CAAAA,EAAAA,CAAU,KAAK,MAAO,CAAA,OAAA,CAAQ,IAAIY,EAAY,CAAA,CAAA,CAAA,CAI9CnE,GAAA,IAAK,CAAA,MAAA,CAAO,QAAS,CAAA,QAAA,GAArB,MAAAA,EAA+B,CAAA,QAAA,GAAA,CAC/BC,GAAA2H,CAAU,CAAA,QAAA,CAAS,WAAnB,IAAA3H,EAAAA,EAAAA,CAA6B,QAC7BuD,CAAAA,GAAAA,CAAAA,EAAAA,CAAAoE,EAAU,QAAS,CAAA,QAAA,GAAnB,IAAApE,EAAAA,EAAAA,CAA6B,YAC7BuC,CAGA,GAAA,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,wBAAwB6B,CAAU,CAAA,QAAA,CAAS,SAAS,SAAS,CAAA,CAE9E,KAAK,MAAO,CAAA,OAAA,CAAQ,MAAOzD,CAAAA,EAAAA,CAAc,CACvC,aAAeI,CAAAA,eAAAA,CAAgB,SACjC,CAAC,CAAA,CAAA,CAGHtB,GAAQ,CACN,KAAA,CAAO0E,CACP,CAAA,OAAA,CAAApE,EACF,CAAC,EACH,EAGA,IAAK,CAAA,MAAA,CAAO,KAAwB+D,EAA2BE,CAAAA,EAAgB,CAC/E,CAAA,IAAA,CAAK,OAAO,IAAKD,CAAAA,EAAAA,CAAyBE,EAAc,CAAA,CAExD,IAAIiB,EACJ,CAAA,GAAI,CACF,GAAI1C,EAAY,CACd,MAAM0B,EAAUiB,oBAAqB,CAAA,wBAAA,CAA0B1D,EAASoC,CAAc,CAAA,CACtF,IAAK,CAAA,MAAA,CAAO,KAAK,OAAQ,CAAA,GAAA,CAAI9F,EAAcmG,CAAO,CAAA,CAClD,MAAMtF,CAAU,CAAA,MAAM,IAAK,CAAA,MAAA,CAAO,KAAK,MAAO,CAAA,MAAA,CAAO,GAAIsF,CAAS,CAAA,CAChE,KAAMkB,MACN,CAAA,QAAA,CAAUC,SACZ,CAAC,EACDH,EAAcI,CAAAA,cAAAA,CAAe/C,CAAqBxE,CAAAA,CAAAA,CAAca,CAAO,EACzE,CAAA,KAEE,MAAM,OAAA,CAAQ,IAAI,CAChB,IAAA,CAAK,YAAY,CACf,KAAA,CAAOb,EACP,MAAQ,CAAA,wBAAA,CACR,MAAQ0D,CAAAA,CAAAA,CACR,OAAQlF,CAAO,CAAA,MAAA,CACf,oBAAsB,CAAA,CAAA,CAAA,CACtB,YAAasH,CACf,CAAC,CACD,CAAA,IAAA,CAAK,YAAY,CACf,KAAA,CAAO9F,EACP,MAAQ,CAAA,mBAAA,CACR,OAAQoB,CACR,CAAA,MAAA,CAAQxB,eAAgB,CAAA,iBAAA,CAAkB,IAAI,GAC9C,CAAA,oBAAA,CAAsB,CACtB,CAAA,CAAA,WAAA,CAAawB,EAAS,EACxB,CAAC,CACH,CAAC,EAEL,CAASV,MAAAA,CAAAA,CAAO,CAEd,MAAK,IAAA,CAAA,MAAA,CAAO,IAAIqF,EAA2BE,CAAAA,EAAgB,CAC3D,CAAA,IAAA,CAAK,OAAO,GAAID,CAAAA,EAAAA,CAAyBE,EAAc,CACjDxF,CAAAA,CACR,CAEA,OAAM,MAAA,IAAA,CAAK,WAAYU,CAAAA,CAAAA,CAAS,GAAIA,CAAQ,CAAA,CAC5C,MAAM,IAAK,CAAA,cAAA,CAAe0E,EAAgB,CACxC,OAAA,CAAS/H,CAAAC,CAAAA,CAAAA,CAAA,GACJ0F,CADI,CAAA,CAAA,CAEP,aAAe,CAAA,EACjB,CACA,CAAA,CAAA,YAAA,CAAA1D,CACA,CAAA,aAAA,CAAA+C,CACF,CAAC,CAAA,CAEM,CACL,GAAKoE,CAAAA,EAAAA,EAAA,KAAAA,EAAehC,CAAAA,CAAAA,CACpB,QAAUxB,CAAAA,CACZ,CACF,CAEArE,CAAAA,CAAAA,CAAAA,CAAA,KAAO,4BAAoE,CAAA,MACzEkI,GACG,CACH,KAAM,CAAE,EAAA,CAAAzF,EAAI,KAAA0F,CAAAA,CAAM,EAAID,CAEhB/E,CAAAA,CAAAA,CAAQ,KAAK,MAAO,CAAA,IAAA,CAAK,WAAY,CAAA,WAAA,CAAY,CACrD,UAAY,CAAA,CACV,KAAOV,CAAAA,CAAAA,CAAG,UACV,CAAA,KAAA,CAAO,CAAC2F,gCAAAA,CAAiC,qCAAqC,CAChF,CACF,CAAC,CAED,CAAA,GAAI,CACF,IAAK,CAAA,aAAA,GACP,CAAA,MAAShH,EAAO,CACd,MAAA+B,EAAM,QAASkF,CAAAA,gCAAAA,CAAiC,sBAAsB,CAChEjH,CAAAA,CACR,CAEA,MAAMkH,EAAiB,IAAK,CAAA,qBAAA,CAAsB7F,CAAE,CAEpD,CAAA,GAAI,CAAC6F,CACH,CAAA,MAAAnF,CAAM,CAAA,QAAA,CACJkF,iCAAiC,+CACnC,CAAA,CACM,IAAI,KAAA,CAAM,+CAA+C5F,CAAE,CAAA,CAAE,CAGrE,CAAA,MAAMgB,EAAgB6E,CAAe,CAAA,aAAA,EAAiB5E,gBAAgB,KAClED,CAAAA,CAAAA,GAAkBC,gBAAgB,KACpC,EAAA,MAAM,IAAK,CAAA,yBAAA,GAGb,MAAM6E,CAAAA,CAAoBD,EAAe,SAAU,CAAA,SAAA,CAC7CE,EAAkB,MAAM,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,OAAO,eAAgB,EAAA,CAChE1C,EAAgBC,OAAQwC,CAAAA,CAAiB,EAEzCE,CAAa,CAAA,CACjB,IAAMC,CAAAA,MAAAA,CACN,kBAAAH,CACA,CAAA,eAAA,CAAAC,CACF,CAAA,CAEMxB,EAA4B,EAAC,CAC7BC,CAA6B,CAAA,GACnC,IAAWC,MAAAA,CAAAA,IAASiB,EAAO,CAEzB,GAAI,CADY,MAAMhB,mBAAAA,CAAoB,CAAE,KAAA,CAAAD,EAAO,SAAW,CAAA,IAAA,CAAK,OAAO,IAAK,CAAA,SAAU,CAAC,CAC5E,CAAA,CACZ/D,CAAM,CAAA,QAAA,CAASkF,iCAAiC,aAAa,CAAA,CAE7D,MAAMM,CAAahF,CAAAA,WAAAA,CACjB,4BACA,+BACF,CAAA,CAEA,MAAM,MAAA,IAAA,CAAK,UAAU,CACnB,EAAA,CAAAlB,CACA,CAAA,KAAA,CAAOqD,EACP,KAAO6C,CAAAA,CAAAA,CACP,UAAAF,CAAAA,CACF,CAAC,CAEK,CAAA,IAAI,MAAME,CAAW,CAAA,OAAO,CACpC,CAEAxF,CAAAA,CAAM,QAASiF,CAAAA,gCAAAA,CAAiC,eAAe,CAE/D,CAAA,KAAM,CAAE,CAAGvB,CAAAA,CAAQ,EAAIK,CACjBf,CAAAA,CAAAA,CAAQE,qBAAsBQ,CAAAA,CAAAA,CAAQ,SAAS,CAE/CO,CAAAA,CAAAA,CAA2B,CAACC,uBAAwBR,CAAAA,CAAAA,CAAQ,GAAG,CAAW,CAAA,CAE1ES,CAAgBC,CAAAA,aAAAA,CAAcV,EAAQ,GAAG,CAAA,CAE/C,GAAIV,CAAAA,CAAO,CACT,MAAMqB,CAAAA,CAAmBC,mBAAoBtB,CAAAA,CAAK,EAC5CuB,CAAkBC,CAAAA,kBAAAA,CAAmBxB,CAAK,CAChDa,CAAAA,CAAAA,CAAgB,KAAK,GAAGQ,CAAgB,CACxCJ,CAAAA,CAAAA,CAAe,KAAK,GAAGM,CAAe,EACxC,CACA,IAAA,MAAWpJ,KAAS8I,CAClBH,CAAAA,CAAAA,CAAiB,IAAK,CAAA,CAAA,EAAG3I,CAAK,CAAIgJ,CAAAA,EAAAA,CAAa,EAAE,EAErD,CAEA,MAAMhE,CAAe,CAAA,MAAM,IAAK,CAAA,MAAA,CAAO,KAAK,MAAO,CAAA,iBAAA,CACjDkF,CACAD,CAAAA,CACF,EAEApF,CAAM,CAAA,QAAA,CAASiF,gCAAiC,CAAA,kCAAkC,EAElF,IAAI1F,CAAAA,CACJ,IAAIsE,CAAA,EAAA,IAAA,CAAA,KAAA,CAAA,CAAAA,EAAiB,MAAS,EAAA,CAAA,CAAG,CAC/BtE,CAAAA,CAAU,CACR,KAAOY,CAAAA,CAAAA,CACP,YAAc,CAAA,CAAA,CAAA,CACd,KAAM,CACJ,SAAA,CAAWkF,CACX,CAAA,QAAA,CAAU,KAAK,MAAO,CAAA,QACxB,EACA,IAAM,CAAA,CACJ,UAAWD,CACX,CAAA,QAAA,CAAUD,CAAe,CAAA,SAAA,CAAU,QACrC,CACA,CAAA,UAAA,CAAYC,CACZ,CAAA,MAAA,CAAQ1G,WAAW2B,cAAc,CAAA,CACjC,cAAgB2E,CAAAA,CAAAA,CAChB,mBAAoB,EAAC,CACrB,mBAAoB,EAAC,CACrB,MAAO,CAAE,QAAA,CAAU,KAAM,CAAA,CACzB,aAAcG,CAAe,CAAA,YAAA,CAC7B,WAAYV,uBACV,CAAA,CAAC,GAAG,IAAI,GAAA,CAAIZ,CAAe,CAAC,EAC5B,CAAC,GAAG,IAAI,GAAIC,CAAAA,CAAgB,CAAC,CAC/B,CAAA,CACA,aAAAxD,CAAAA,CACF,EAEAN,CAAM,CAAA,QAAA,CAASiF,gCAAiC,CAAA,uCAAuC,EAEvF,GAAI,CACF,MAAM,IAAA,CAAK,OAAO,IAAK,CAAA,OAAA,CAAQ,UAAU9E,CAAc,CAAA,CAAE,cAAAG,CAAc,CAAC,EAC1E,CAAA,MAASrC,EAAO,CACd,MAAA+B,EAAM,QACJkF,CAAAA,gCAAAA,CAAiC,6CACnC,CACMjH,CAAAA,CACR,CAEA+B,CAAAA,CAAM,SACJiF,gCAAiC,CAAA,6CACnC,EAEA,MAAM,IAAA,CAAK,OAAO,OAAQ,CAAA,GAAA,CAAI9E,CAAcZ,CAAAA,CAAO,EAEnDS,CAAM,CAAA,QAAA,CAASiF,gCAAiC,CAAA,2BAA2B,EAE3E,MAAM,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,QAAQ,cAAe,CAAA,CAC5C,MAAOE,CAAe,CAAA,YAAA,CACtB,SAAUA,CAAe,CAAA,SAAA,CAAU,QACrC,CAAC,EACH,CAEAnF,CAAAA,CAAM,SAASiF,gCAAiC,CAAA,wCAAwC,EAExF,GAAI,CACF,MAAM,IAAA,CAAK,WAAqC,CAC9C,KAAA,CAAOtC,EACP,EAAArD,CAAAA,CAAAA,CACA,OAAQ,CACN,MAAA,CAAQ0F,CACR,CAAA,SAAA,CAAW,CACT,SAAWK,CAAAA,CAAAA,CACX,QAAU,CAAA,IAAA,CAAK,OAAO,QACxB,CACF,CACA,CAAA,UAAA,CAAAC,EACA,oBAAsB,CAAA,CAAA,CAAA,CACtB,QAAS,IAAK,CAAA,mBAAA,CAAoBH,EAAe,SAAU,CAAA,QAAA,CAAU7E,CAAa,CACpF,CAAC,EACH,CAAA,MAASrC,CAAO,CAAA,CACd,MAAA+B,CAAM,CAAA,QAAA,CACJkF,gCAAiC,CAAA,6CACnC,EACMjH,CACR,CAEA,aAAM,IAAK,CAAA,MAAA,CAAO,KAAK,QAAS,CAAA,MAAA,CAAOqB,CAAI,CAAA,CAAE,QAAS,WAAa,CAAA,IAAA,CAAM,CAAE,CAAC,EAC5E,MAAM,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,QAAQ,QAAS,CAAA,CAAE,MAAO6F,CAAe,CAAA,YAAa,CAAC,CAC9E,CAAA,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,YAAY,WAAY,CAAA,CAAE,QAASnF,CAAM,CAAA,OAAQ,CAAC,CAE5D,CAAA,CAAE,OAAAT,CAAAA,CAAQ,CACnB,CAEA1C,CAAAA,CAAAA,CAAAA,CAAA,KAAO,2BAAkE,CAAA,MAAOd,GAAW,CACzF,IAAA,CAAK,aAAc,EAAA,CAEnB,KAAM,CAAE,EAAA,CAAAuD,CAAI,CAAA,MAAA,CAAAmB,CAAO,CAAI1E,CAAAA,CAAAA,CAEjBoJ,CAAiB,CAAA,IAAA,CAAK,sBAAsB7F,CAAE,CAAA,CAEpD,GAAI,CAAC6F,CAAAA,CACH,MAAM,IAAI,KAAA,CAAM,CAA+C7F,4CAAAA,EAAAA,CAAE,EAAE,CAGjE6F,CAAAA,CAAAA,CAAe,gBAAkB5E,eAAgB,CAAA,KAAA,EACnD,MAAM,IAAK,CAAA,yBAAA,EAGb,CAAA,MAAM6E,EAAoBD,CAAe,CAAA,SAAA,CAAU,UAC7CE,CAAkB,CAAA,MAAM,KAAK,MAAO,CAAA,IAAA,CAAK,MAAO,CAAA,eAAA,GAChD1C,CAAgBC,CAAAA,OAAAA,CAAQwC,CAAiB,CAAA,CAEzCE,EAAa,CACjB,IAAA,CAAMC,MACN,CAAA,iBAAA,CAAAH,EACA,eAAAC,CAAAA,CACF,EAEA,MAAM,IAAA,CAAK,UAAU,CACnB,EAAA,CAAA/F,CACA,CAAA,KAAA,CAAOqD,EACP,KAAOlC,CAAAA,CAAAA,CACP,WAAA6E,CACA,CAAA,OAAA,CAASnI,gBAAgB,sBAAuB,CAAA,MAAA,CAChD,OAAS,CAAA,IAAA,CAAK,oBACZgI,CAAe,CAAA,SAAA,CAAU,SACzBA,CAAe,CAAA,aACjB,CACF,CAAC,CAAA,CACD,MAAM,IAAA,CAAK,OAAO,IAAK,CAAA,QAAA,CAAS,MAAO7F,CAAAA,CAAAA,CAAI,CAAE,OAAS,CAAA,UAAA,CAAY,IAAM,CAAA,CAAE,CAAC,CAC3E,CAAA,MAAM,KAAK,cAAeA,CAAAA,CAAE,EAC9B,CAEAzC,CAAAA,CAAAA,CAAAA,CAAA,IAAO,CAAA,mBAAA,CAAmDd,GAAW,CACnE,IAAA,CAAK,aAAc,EAAA,CACnB,KAAM,CAAE,OAAA,CAAAkF,CAAS,CAAA,GAAA,CAAAwE,CAAI,CAAI1J,CAAAA,CAAAA,CACzB,OAAO2J,aAAczE,CAAAA,CAAAA,CAASwE,CAAG,CACnC,CAAA,CAAA,CAMA5I,CAAA,CAAA,IAAA,CAAO,2BAAgE,IAAM,CAE3E,UAAW,CAAA,SAAY,CACrB,GAAI,IAAA,CAAK,iBAAkB,CAAA,MAAA,GAAW,EACtC,KAAO,IAAA,CAAK,kBAAkB,MAAS,CAAA,CAAA,EACrC,GAAI,CACF,MAAMuB,CAAU,CAAA,IAAA,CAAK,kBAAkB,KAAM,EAAA,CACzCA,GACF,MAAM,IAAA,CAAK,eAAeA,CAAO,EAErC,CAASH,MAAAA,CAAAA,CAAO,CACd,IAAK,CAAA,MAAA,CAAO,OAAO,KAAMA,CAAAA,CAAK,EAChC,CAEJ,CAAA,CAAG,EAAE,EACP,GAIApB,CAAA,CAAA,IAAA,CAAQ,0BAAsE,CAAA,MAC5E0C,GACG,CAEH,GAAKA,CAAQ,CAAA,YAAA,CAEb,GAAI,CACF,MAAMvB,EAAU,IAAK,CAAA,MAAA,CAAO,KAAK,OAAQ,CAAA,QAAA,CAAS,GAAIuB,CAAAA,CAAAA,CAAQ,YAAY,CAEpEoG,CAAAA,CAAAA,CADc,KAAK,MAAO,CAAA,IAAA,CAAK,QAAQ,QAAS,CAAA,MAAA,EACvB,CAAA,MAAA,CAC5BC,GAAG,CAh2CZ,IAAA5J,EAAAC,CAi2CU,CAAA,OAAA,CAAA,CAAAD,EAAA4J,CAAE,CAAA,YAAA,GAAF,IAAA5J,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAgB,QAChBC,CAAA2J,CAAAA,CAAAA,CAAE,YAAF,GAAA,IAAA,CAAA,KAAA,CAAA,CAAA3J,EAAgB,GAAQsD,IAAAA,CAAAA,CAAQ,IAAK,CAAA,QAAA,CAAS,KAC9CqG,CAAE,CAAA,KAAA,EACFA,EAAE,KAAU5H,GAAAA,CAAAA,CAAQ,MACxB,CACA,CAAA,GAAI2H,CAAW,CAAA,MAAA,GAAW,EAAG,OAC7B,IAAA,CAAK,OAAO,MAAO,CAAA,IAAA,CAAK,eAAeA,CAAW,CAAA,MAAM,CAAuB,qBAAA,CAAA,CAAA,CAC/E,MAAM,OAAQ,CAAA,GAAA,CACZA,EAAW,GAAKC,CAAAA,CAAAA,EAAM,KAAK,MAAO,CAAA,IAAA,CAAK,OAAQ,CAAA,UAAA,CAAW,CAAE,KAAOA,CAAAA,CAAAA,CAAE,KAAM,CAAC,CAAC,CAC/E,CAAA,CACA,IAAK,CAAA,MAAA,CAAO,OAAO,IAAK,CAAA,sCAAsC,EAChE,CAAS3H,MAAAA,CAAAA,CAAO,CACd,IAAK,CAAA,MAAA,CAAO,MAAO,CAAA,KAAA,CAAMA,CAAK,EAChC,CACF,GAEApB,CAAA,CAAA,IAAA,CAAQ,gBAAgD,MAAOd,CAAAA,EAAW,CAj3C5E,IAAAC,EAk3CI,KAAM,CAAE,MAAA6B,CAAO,CAAA,iBAAA,CAAAgI,EAAoB,CAAO,CAAA,CAAA,SAAA,CAAAC,CAAY,CAAA,CAAA,CAAA,CAAM,GAAAxG,CAAK,CAAA,CAAE,CAAIvD,CAAAA,CAAAA,CACjE,CAAE,IAAAgK,CAAAA,CAAK,CAAI,CAAA,IAAA,CAAK,OAAO,OAAQ,CAAA,GAAA,CAAIlI,CAAK,CAE9C,CAAA,MAAM,KAAK,MAAO,CAAA,IAAA,CAAK,OAAQ,CAAA,WAAA,CAAYA,CAAK,CAChD,CAAA,MAAM,KAAK,MAAO,CAAA,OAAA,CAAQ,OAAOA,CAAO2C,CAAAA,WAAAA,CAAY,mBAAmB,CAAC,EACxE,IAAK,CAAA,oBAAA,CAAqB3C,EAAO,SAAS,CAAA,CACtC,KAAK,MAAO,CAAA,IAAA,CAAK,MAAO,CAAA,QAAA,CAAS,IAAIkI,CAAK,CAAA,SAAS,CACrD,EAAA,MAAM,KAAK,MAAO,CAAA,IAAA,CAAK,MAAO,CAAA,aAAA,CAAcA,EAAK,SAAS,CAAA,CAExD,KAAK,MAAO,CAAA,IAAA,CAAK,OAAO,QAAS,CAAA,GAAA,CAAIlI,CAAK,CAAA,EAC5C,MAAM,IAAK,CAAA,MAAA,CAAO,KAAK,MAAO,CAAA,YAAA,CAAaA,CAAK,CAE7CgI,CAAAA,CAAAA,EAAmB,IAAK,CAAA,MAAA,CAAO,KAAK,OAAQ,CAAA,GAAA,CAAIhI,CAAK,CAG1D,CAAA,IAAA,CAAK,OAAO,IAAK,CAAA,OAAA,CACd,UAAW4D,CAAAA,6BAA6B,EACxC,KAAOV,CAAAA,CAAAA,EAAM,IAAK,CAAA,MAAA,CAAO,OAAO,IAAKA,CAAAA,CAAC,CAAC,CAAA,CAC1C,KAAK,yBAA0B,EAAA,CAAE,QAASiF,CAAM,EAAA,CAC1CA,EAAE,KAAUnI,GAAAA,CAAAA,EACd,IAAK,CAAA,2BAAA,CAA4BmI,EAAE,EAAIxF,CAAAA,WAAAA,CAAY,mBAAmB,CAAC,EAE3E,CAAC,CAEG3C,CAAAA,CAAAA,IAAAA,CAAU7B,CAAA,CAAA,IAAA,CAAK,oBAAoB,KAAM,CAAA,CAAC,IAAhC,IAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAmC,SAC/C,IAAK,CAAA,mBAAA,CAAoB,KAAQgB,CAAAA,mBAAAA,CAAoB,MAEnD8I,CAAW,EAAA,IAAA,CAAK,MAAO,CAAA,MAAA,CAAO,KAAK,gBAAkB,CAAA,CAAE,EAAAxG,CAAAA,CAAAA,CAAI,MAAAzB,CAAM,CAAC,EACxE,CAEAhB,CAAAA,CAAAA,CAAAA,CAAA,KAAQ,gBAAkD,CAAA,MAAOyC,CAAIuG,CAAAA,CAAAA,GAAsB,CACzF,GAAIA,CAAAA,CACF,GAAI,CACF,MAAMlH,CAAW,CAAA,IAAA,CAAK,MAAO,CAAA,QAAA,CAAS,IAAIW,CAAE,CAAA,CACtCU,EAAQ,IAAK,CAAA,MAAA,CAAO,KAAK,WAAY,CAAA,QAAA,CAAS,CAAE,KAAA,CAAOrB,EAAS,YAAa,CAAC,CACpFqB,CAAAA,CAAAA,EAAA,MAAAA,CAAO,CAAA,QAAA,CAASL,2BAA4B,CAAA,gBAAA,EAC9C,OAAS1B,CAAO,CAAA,EAElB,MAAM,OAAA,CAAQ,IAAI,CAChB,IAAA,CAAK,MAAO,CAAA,QAAA,CAAS,OAAOqB,CAAIkB,CAAAA,WAAAA,CAAY,mBAAmB,CAAC,CAAA,CAChEqF,EAAoB,OAAQ,CAAA,OAAA,EAAY,CAAA,IAAA,CAAK,OAAO,IAAK,CAAA,OAAA,CAAQ,IAAIvG,CAAE,CACzE,CAAC,CACD,CAAA,IAAA,CAAK,oBAAqBA,CAAAA,CAAAA,CAAI,UAAU,EAC1C,CAAA,CAAA,CAEAzC,CAAA,CAAA,IAAA,CAAQ,8BAA4E,MAClFyC,CAAAA,CACAmB,CACAoF,CAAAA,CAAAA,CAAoB,KACjB,CACH,MAAM,QAAQ,GAAI,CAAA,CAChB,KAAK,MAAO,CAAA,cAAA,CAAe,MAAOvG,CAAAA,CAAAA,CAAImB,CAAM,CAC5CoF,CAAAA,CAAAA,CAAoB,QAAQ,OAAQ,EAAA,CAAI,KAAK,MAAO,CAAA,IAAA,CAAK,OAAQ,CAAA,GAAA,CAAIvG,CAAE,CACzE,CAAC,EACD,IAAK,CAAA,oBAAA,CAAqBA,EAAI,SAAS,CAAA,CACvC,IAAK,CAAA,mBAAA,CAAoB,MAAQ,IAAK,CAAA,mBAAA,CAAoB,KAAM,CAAA,MAAA,CAAQ0G,GAAMA,CAAE,CAAA,EAAA,GAAO1G,CAAE,CAAA,CACrFuG,IACF,IAAK,CAAA,mBAAA,CAAoB,MAAQ7I,mBAAoB,CAAA,IAAA,CACrD,KAAK,MAAO,CAAA,MAAA,CAAO,IAAK,CAAA,wBAAA,CAA0B,CAAE,EAAAsC,CAAAA,CAAG,CAAC,CAE5D,EAAA,CAAA,CAAA,CAEAzC,EAAA,IAAQ,CAAA,0BAAA,CAAsE,MAC5EyC,CAAAA,CACAmB,EACAoF,CAAoB,CAAA,CAAA,CAAA,GACjB,CACH,MAAM,OAAA,CAAQ,IAAI,CAChB,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,SAAS,MAAOvG,CAAAA,CAAAA,CAAImB,CAAM,CAAA,CAC3CoF,EAAoB,OAAQ,CAAA,OAAA,EAAY,CAAA,IAAA,CAAK,OAAO,IAAK,CAAA,OAAA,CAAQ,IAAIvG,CAAE,CACzE,CAAC,EACH,CAAA,CAAA,CAEAzC,CAAA,CAAA,IAAA,CAAQ,YAAwC,MAAOgB,CAAAA,CAAOU,CAAW,GAAA,CAClE,KAAK,MAAO,CAAA,OAAA,CAAQ,IAAK,CAAA,QAAA,CAASV,CAAK,CAC5C,GAAA,IAAA,CAAK,OAAO,IAAK,CAAA,OAAA,CAAQ,IAAIA,CAAOU,CAAAA,CAAM,CAC1C,CAAA,MAAM,KAAK,MAAO,CAAA,OAAA,CAAQ,MAAOV,CAAAA,CAAAA,CAAO,CAAE,MAAAU,CAAAA,CAAO,CAAC,CAAA,EACpD,GAEA1B,CAAA,CAAA,IAAA,CAAQ,cAA4C,MAAOyC,CAAAA,CAAIX,IAAa,CAC1E,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,QAAQ,GAAIW,CAAAA,CAAAA,CAAIZ,WAAWvB,eAAgB,CAAA,iBAAA,CAAkB,IAAI,GAAG,CAAC,CACtF,CAAA,MAAM,KAAK,MAAO,CAAA,QAAA,CAAS,IAAImC,CAAIX,CAAAA,CAAQ,EAC7C,CAEA9B,CAAAA,CAAAA,CAAAA,CAAA,IAAQ,CAAA,gBAAA,CAAkD,MAAOyC,CAAIvD,CAAAA,CAAAA,GAAW,CAC9E,KAAM,CAAE,OAAAkF,CAAAA,CAAAA,CAAS,YAAA1D,CAAAA,CAAAA,CAAc,cAAA+C,CAAgBC,CAAAA,eAAAA,CAAgB,KAAM,CAAIxE,CAAAA,CAAAA,CACzE,KAAK,MAAO,CAAA,IAAA,CAAK,OAAQ,CAAA,GAAA,CAAIuD,EAAI2B,CAAQ,CAAA,eAAe,EACxD,MAAM,IAAA,CAAK,OAAO,IAAK,CAAA,QAAA,CAAS,GAAI3B,CAAAA,CAAAA,CAAI,CACtC,WAAa2B,CAAAA,CAAAA,CAAQ,YACrB,SAAWA,CAAAA,CAAAA,CAAQ,UACnB,eAAiBA,CAAAA,CAAAA,CAAQ,eACzB,CAAA,EAAA,CAAA3B,EACA,YAAA/B,CAAAA,CAAAA,CACA,aAAe0D,CAAAA,CAAAA,CAAQ,cACvB,aAAAX,CAAAA,CACF,CAAC,EACH,GAEAzD,CAAA,CAAA,IAAA,CAAQ,2BAAsE,MAC5EsI,CAAAA,EACG,CACH,KAAM,CAAE,EAAA7F,CAAAA,CAAAA,CAAI,MAAAzB,CAAO,CAAA,MAAA,CAAA9B,EAAQ,aAAAkK,CAAAA,CAAc,EAAId,CACvC5G,CAAAA,CAAAA,CACJxC,CAAO,CAAA,OAAA,CAAQ,iBAAmB2C,UAAWvB,CAAAA,eAAAA,CAAgB,kBAAkB,GAAI,CAAA,GAAG,EACxF,IAAK,CAAA,MAAA,CAAO,IAAK,CAAA,OAAA,CAAQ,IAAImC,CAAIf,CAAAA,CAAM,CACvC,CAAA,MAAM,KAAK,MAAO,CAAA,cAAA,CAAe,GAAIe,CAAAA,CAAAA,CAAI,CACvC,EAAAA,CAAAA,CAAAA,CACA,MAAAzB,CACA,CAAA,MAAA,CAAA9B,EACA,aAAAkK,CAAAA,CACF,CAAC,EACH,GAEApJ,CAAA,CAAA,IAAA,CAAQ,aAA4C,CAAA,MAAOqJ,GAAS,CAClE,KAAM,CACJ,KAAA,CAAArI,EACA,MAAAsI,CAAAA,CAAAA,CACA,OAAApK,CACA,CAAA,MAAA,CAAAwC,EACA,UAAAqC,CAAAA,CAAAA,CACA,WAAAD,CAAAA,CAAAA,CACA,qBAAAyF,CACA,CAAA,OAAA,CAAA/E,CACA,CAAA,GAAA,CAAAgF,EACA,WAAAC,CAAAA,CAAAA,CAAc,EAChB,EAAIJ,CACExC,CAAAA,CAAAA,CAAUiB,qBAAqBwB,CAAQpK,CAAAA,CAAAA,CAAQ4E,CAAW,CAEhE,CAAA,IAAIvC,CACJ,CAAA,MAAM4D,EAAa,CAAC,CAACX,EAErB,GAAI,CACF,MAAMkF,CAAWvE,CAAAA,CAAAA,CAAa6C,SAAY2B,CAAAA,MAAAA,CAC1CpI,EAAU,MAAM,IAAA,CAAK,OAAO,IAAK,CAAA,MAAA,CAAO,OAAOP,CAAO6F,CAAAA,CAAAA,CAAS,CAAE,QAAA,CAAA6C,CAAS,CAAC,EAC7E,CAAStI,MAAAA,CAAAA,CAAO,CACd,MAAM,MAAA,IAAA,CAAK,OAAQ,EAAA,CACnB,KAAK,MAAO,CAAA,MAAA,CAAO,MAAM,CAAmDJ,gDAAAA,EAAAA,CAAK,SAAS,CACpFI,CAAAA,CACR,CAEA,IAAIwI,EACJ,GAAIC,iBAAAA,CAAkB,SAASP,CAAM,CAAA,CAAG,CACtC,MAAMQ,CAAAA,CAAcC,WAAY,CAAA,IAAA,CAAK,UAAUlD,CAAO,CAAC,EACjDpE,CAAKsH,CAAAA,WAAAA,CAAYxI,CAAO,CAC9BqI,CAAAA,CAAAA,CAAc,MAAM,IAAA,CAAK,OAAO,IAAK,CAAA,MAAA,CAAO,QAAS,CAAA,CAAE,GAAAnH,CAAI,CAAA,WAAA,CAAAqH,CAAY,CAAC,EAC1E,CAEA,MAAMtL,EAAOE,CAAA,CAAA,CAAA,CAAA,EAAA,CACR4B,gBAAgBgJ,CAAM,CAAA,CAAE,GACxBG,CAAAA,CAAAA,CAAAA,CAAAA,CAQL,GALAjL,CAAK,CAAA,WAAA,CAAcoL,EACflI,CAAQlD,GAAAA,CAAAA,CAAK,IAAMkD,CACnBqC,CAAAA,CAAAA,CAAAA,GAAYvF,CAAK,CAAA,EAAA,CAAKuF,GAC1B,IAAK,CAAA,MAAA,CAAO,KAAK,OAAQ,CAAA,GAAA,CAAI/C,EAAO6F,CAAO,CAAA,CAEvC1B,CAAY,CAAA,CACd,MAAM6E,CAAc/B,CAAAA,cAAAA,CAAezD,CAASxD,CAAAA,CAAAA,CAAOO,CAAO,CAC1D,CAAA,MAAO,MAAe,CAAA,OAAA,CAAQ,QAAQyI,CAAa,CAAA,IAAA,CAAK,OAAO,IAAI,EACrE,MACExL,CAAK,CAAA,GAAA,CAAMC,CAAAC,CAAAA,CAAAA,CAAA,GACN8K,CADM,CAAA,CAAA,CAET,cAAe3C,CAAQ,CAAA,EACzB,GAEI0C,CACF/K,EAAAA,CAAAA,CAAK,QAAWC,CAAAA,CAAAA,CAAAC,EAAA,EACXF,CAAAA,CAAAA,CAAK,UADM,CAEd,oBAAA,CAAsB,EACxB,CACA,CAAA,CAAA,MAAM,IAAK,CAAA,MAAA,CAAO,KAAK,OAAQ,CAAA,OAAA,CAAQwC,CAAOO,CAAAA,CAAAA,CAAS/C,CAAI,CAE3D,EAAA,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,QACd,OAAQwC,CAAAA,CAAAA,CAAOO,EAAS/C,CAAI,CAAA,CAC5B,MAAO4C,CAAU,EAAA,IAAA,CAAK,MAAO,CAAA,MAAA,CAAO,MAAMA,CAAK,CAAC,EAIvD,OAAOyF,CAAAA,CAAQ,EACjB,CAEA7G,CAAAA,CAAAA,CAAAA,CAAA,IAAQ,CAAA,oBAAA,CAA0D,MAAOd,CAAW,EAAA,CAClF,KAAM,CAAE,QAAA,CAAA4C,EAAU,WAAA2H,CAAAA,CAAY,CAAIvK,CAAAA,CAAAA,CAE5B+K,EAAwBnC,oBAAqB,CAAA,mBAAA,CAAqBhG,CAAUA,CAAAA,CAAAA,CAAS,EAAE,CAE7F,CAAA,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,QAAQ,GAAIA,CAAAA,CAAAA,CAAS,aAAcmI,CAAqB,CAAA,CAEzE,MAAMC,CAAwB,CAAA,MAAM,IAAK,CAAA,MAAA,CAAO,KAAK,MAAO,CAAA,MAAA,CAC1DpI,EAAS,YACTmI,CAAAA,CAAAA,CACA,CACE,QAAUN,CAAAA,MACZ,CACF,CAAA,CAEMG,EAAcC,WAAY,CAAA,IAAA,CAAK,UAAUE,CAAqB,CAAC,EAC/DE,CAAgBJ,CAAAA,WAAAA,CAAYG,CAAqB,CAAA,CACjDN,EAAc,MAAM,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,OAAO,QAAS,CAAA,CAAE,EAAIO,CAAAA,CAAAA,CAAe,YAAAL,CAAY,CAAC,EAE7F,MAAM,IAAA,CAAK,OAAO,IAAK,CAAA,OAAA,CAAQ,aAAc,CAAA,CAC3C,QAAS,CACP,YAAA,CAAchI,EAAS,YACvB,CAAA,eAAA,CAAiBoI,CACnB,CACA,CAAA,IAAA,CAAMzL,CAAAC,CAAAA,CAAAA,CAAA,GACD+K,CADC,CAAA,CAAA,CAEJ,cAAe,mBACf,CAAA,WAAA,CAAAG,CACF,CACF,CAAA,CAAC,EACH,CAAA,CAAA,CAEA5J,EAAA,IAAQ,CAAA,oBAAA,CAA0D,MAAOd,CAAAA,EAAW,CAClF,KAAM,CAAE,YAAAoE,CAAAA,CAAAA,CAAc,wBAAA8G,CAAyB,CAAA,QAAA,CAAAtI,EAAU,oBAAAuI,CAAAA,CAAAA,CAAsB,YAAAZ,CAAY,CAAA,CACzFvK,CACIoL,CAAAA,CAAAA,CAAiBC,oBAAoBzI,CAAS,CAAA,EAAA,CAAIsI,CAAuB,CAAA,CAEzEI,EAAyB,MAAM,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,OAAO,MAC3D1I,CAAAA,CAAAA,CAAS,aACTwI,CACA,CAAA,CACE,SAAUX,MACZ,CACF,CAEMc,CAAAA,CAAAA,CAAuB3C,qBAC3B,kBACAuC,CAAAA,CAAAA,CACAZ,CAAA,EAAA,IAAA,CAAA,KAAA,CAAA,CAAAA,EAAa,EACf,CAAA,CAEMiB,CAAkC,CAAA,MAAM,KAAK,MAAO,CAAA,IAAA,CAAK,OAAO,MACpEpH,CAAAA,CAAAA,CACAmH,EACA,CACE,QAAA,CAAUd,MACZ,CACF,EAEA,IAAK,CAAA,MAAA,CAAO,KAAK,OAAQ,CAAA,GAAA,CAAIrG,EAAcmH,CAAoB,CAAA,CAE/D,MAAM,IAAA,CAAK,OAAO,IAAK,CAAA,OAAA,CAAQ,cAAc,CAC3C,OAAA,CAAS,CACP,YAAAnH,CAAAA,CAAAA,CACA,YAAcxB,CAAAA,CAAAA,CAAS,aACvB,uBAAyB0I,CAAAA,CAAAA,CACzB,wBAA0BE,CAAAA,CAC5B,EACA,IAAMjM,CAAAA,CAAAA,CAAAC,CAAA,CAAA,EAAA,CACD+K,GADC,CAEJ,aAAA,CAAe,mBACjB,CACF,CAAA,CAAC,EACH,CAEAzJ,CAAAA,CAAAA,CAAAA,CAAA,IAAQ,CAAA,YAAA,CAA0C,MAAOqJ,CAAS,EAAA,CAChE,KAAM,CAAE,EAAA,CAAA5G,EAAI,KAAAzB,CAAAA,CAAAA,CAAO,MAAAsD,CAAAA,CAAAA,CAAQ,qBAAAiF,CAAsB,CAAA,UAAA,CAAAd,EAAY,OAAAjE,CAAAA,CAAQ,EAAI6E,CACnExC,CAAAA,CAAAA,CAAU0D,mBAAoB9H,CAAAA,CAAAA,CAAI6B,CAAM,CAC9C,CAAA,IAAI/C,CACJ,CAAA,MAAM4D,EAAaX,CAAW,EAAA,OAAQ,MAAgB,EAAA,IAAA,CAAA,KAAA,CAAA,CAAA,MAAA,CAAA,OAAA,CAAA,EAAY,YAElE,GAAI,CACF,MAAMkF,CAAWvE,CAAAA,CAAAA,CAAa6C,UAAY2B,MAC1CpI,CAAAA,CAAAA,CAAU,MAAM,IAAA,CAAK,OAAO,IAAK,CAAA,MAAA,CAAO,OAAOP,CAAO6F,CAAAA,CAAAA,CAASpI,EAAAC,CAAA,CAAA,EAAA,CACzD+J,CAAc,EAAA,IAD2C,CAE7D,QAAA,CAAAiB,CACF,CAAC,CAAA,EACH,OAAStI,CAAO,CAAA,CAEd,MAAM,MAAA,IAAA,CAAK,SACX,CAAA,IAAA,CAAK,MAAO,CAAA,MAAA,CAAO,MAAM,CAAkDJ,+CAAAA,EAAAA,CAAK,CAAS,OAAA,CAAA,CAAA,CACnFI,CACR,CACA,IAAIuJ,EACAnB,CACJ,CAAA,GAAI,CACFmB,CAAS,CAAA,MAAM,IAAK,CAAA,MAAA,CAAO,KAAK,OAAQ,CAAA,GAAA,CAAI3J,EAAOyB,CAAE,CAAA,CACrD,MAAM2B,CAAUuG,CAAAA,CAAAA,CAAO,OACvB,CAAA,GAAI,CACFnB,CAAM,CAAA,IAAA,CAAK,aAAa/G,CAAI2B,CAAAA,CAAAA,CAAQ,OAAQE,CAAM,EACpD,CAASlD,MAAAA,CAAAA,CAAO,CACd,IAAK,CAAA,MAAA,CAAO,MAAO,CAAA,IAAA,CACjB,0CAA2CA,CAAA,EAAA,IAAA,CAAA,KAAA,CAAA,CAAAA,CAAiB,CAAA,OAAO,EACrE,EACF,CACF,OAASA,CAAO,CAAA,CACd,WAAK,MAAO,CAAA,MAAA,CAAO,KAAM,CAAA,CAAA,4BAAA,EAA+BJ,CAAK,CAAKyB,EAAAA,EAAAA,CAAE,UAAU,CACxErB,CAAAA,CACR,CAEA,GAAI+D,CAAAA,CAAY,CACd,MAAM6E,EAAc/B,cAAezD,CAAAA,CAAAA,CAASxD,EAAOO,CAAO,CAAA,CAC1D,MAAO,MAAe,CAAA,OAAA,CAAQ,OAAQyI,CAAAA,CAAAA,CAAa,KAAK,MAAO,CAAA,IAAI,EACrE,CAAA,KAAO,CACL,MAAMV,CAAAA,CAASqB,CAAO,CAAA,OAAA,CAAQ,OACxBnM,CAAO8B,CAAAA,eAAAA,CAAgBgJ,CAAM,CAAE,CAAA,GAAA,CAErC9K,EAAK,GAAMC,CAAAA,CAAAA,CAAAC,CAAA,CAAA,EAAA,CACN8K,GADM,CAET,aAAA,CAAe/G,CACjB,CAEI8G,CAAAA,CAAAA,CAAAA,EACF/K,EAAK,QAAWC,CAAAA,CAAAA,CAAAC,CAAA,CAAA,EAAA,CACXF,EAAK,QADM,CAAA,CAAA,CAEd,qBAAsB,CACxB,CAAA,CAAA,CAAA,CACA,MAAM,IAAK,CAAA,MAAA,CAAO,IAAK,CAAA,OAAA,CAAQ,QAAQwC,CAAOO,CAAAA,CAAAA,CAAS/C,CAAI,CAAA,EAE3D,KAAK,MAAO,CAAA,IAAA,CAAK,OACd,CAAA,OAAA,CAAQwC,EAAOO,CAAS/C,CAAAA,CAAI,EAC5B,KAAO4C,CAAAA,CAAAA,EAAU,KAAK,MAAO,CAAA,MAAA,CAAO,KAAMA,CAAAA,CAAK,CAAC,EAEvD,CAEA,MAAM,IAAK,CAAA,MAAA,CAAO,KAAK,OAAQ,CAAA,OAAA,CAAQyF,CAAO,EAChD,GAEA7G,CAAA,CAAA,IAAA,CAAQ,YAAwC,MAAOd,CAAAA,EAAW,CAChE,KAAM,CAAE,EAAAuD,CAAAA,CAAAA,CAAI,MAAAzB,CAAO,CAAA,KAAA,CAAAI,CAAO,CAAA,UAAA,CAAAqH,EAAY,OAAAmC,CAAAA,CAAAA,CAAS,OAAApG,CAAAA,CAAQ,EAAItF,CACrD2H,CAAAA,CAAAA,CAAUgE,mBAAmBpI,CAAIrB,CAAAA,CAAK,EAC5C,IAAIG,CAAAA,CACJ,MAAM4D,CAAAA,CAAaX,GAAW,OAAQ,MAAA,EAAA,IAAA,CAAA,KAAA,CAAA,CAAA,MAAA,CAAgB,OAAY,CAAA,EAAA,WAAA,CAClE,GAAI,CACF,MAAMkF,CAAWvE,CAAAA,CAAAA,CAAa6C,UAAY2B,MAC1CpI,CAAAA,CAAAA,CAAU,MAAM,IAAK,CAAA,MAAA,CAAO,KAAK,MAAO,CAAA,MAAA,CAAOP,CAAO6F,CAAAA,CAAAA,CAASpI,EAAAC,CAAA,CAAA,EAAA,CACzD+J,CAAc,EAAA,IAD2C,CAE7D,QAAA,CAAAiB,CACF,CAAA,CAAC,EACH,CAAStI,MAAAA,CAAAA,CAAO,CACd,MAAM,MAAA,IAAA,CAAK,SACX,CAAA,IAAA,CAAK,MAAO,CAAA,MAAA,CAAO,MAAM,CAAiDJ,8CAAAA,EAAAA,CAAK,SAAS,CAClFI,CAAAA,CACR,CACA,IAAIuJ,CAAAA,CACJ,GAAI,CACFA,EAAS,MAAM,IAAA,CAAK,OAAO,IAAK,CAAA,OAAA,CAAQ,IAAI3J,CAAOyB,CAAAA,CAAE,EACvD,CAAA,MAASrB,EAAO,CACd,MAAA,IAAA,CAAK,MAAO,CAAA,MAAA,CAAO,MAAM,CAA8BJ,2BAAAA,EAAAA,CAAK,CAAKyB,EAAAA,EAAAA,CAAE,UAAU,CACvErB,CAAAA,CACR,CAEA,GAAI+D,CAAAA,CAAY,CACd,MAAM6E,CAAAA,CAAc/B,cAAezD,CAAAA,CAAAA,CAASxD,EAAOO,CAAO,CAAA,CAC1D,MAAO,MAAe,CAAA,OAAA,CAAQ,QAAQyI,CAAa,CAAA,IAAA,CAAK,MAAO,CAAA,IAAI,EACrE,CAAO,KAAA,CACL,MAAMV,CAASqB,CAAAA,CAAAA,CAAO,QAAQ,MACxBnM,CAAAA,CAAAA,CAAOoM,CAAWtK,EAAAA,eAAAA,CAAgBgJ,CAAM,CAAE,CAAA,GAAA,CAEhD,IAAK,CAAA,MAAA,CAAO,KAAK,OAAQ,CAAA,OAAA,CAAQtI,CAAOO,CAAAA,CAAAA,CAAS/C,CAAI,EACvD,CAEA,MAAM,IAAK,CAAA,MAAA,CAAO,KAAK,OAAQ,CAAA,OAAA,CAAQqI,CAAO,EAChD,GAEA7G,CAAA,CAAA,IAAA,CAAQ,UAAoC,SAAY,CACtD,MAAM8K,CAA0B,CAAA,EAC1BC,CAAAA,CAAAA,CAAwB,EAC9B,CAAA,IAAA,CAAK,OAAO,OAAQ,CAAA,MAAA,GAAS,OAASrI,CAAAA,CAAAA,EAAY,CAChD,IAAIsI,EAAY,CACZC,CAAAA,CAAAA,SAAAA,CAAUvI,CAAQ,CAAA,MAAM,IAAGsI,CAAY,CAAA,CAAA,CAAA,CAAA,CACtC,IAAK,CAAA,MAAA,CAAO,KAAK,MAAO,CAAA,QAAA,CAAS,IAAItI,CAAQ,CAAA,KAAK,IAAGsI,CAAY,CAAA,CAAA,CAAA,CAAA,CAClEA,CAAWF,EAAAA,CAAAA,CAAc,KAAKpI,CAAQ,CAAA,KAAK,EACjD,CAAC,CAAA,CACD,KAAK,MAAO,CAAA,QAAA,CAAS,MAAO,EAAA,CAAE,QAASZ,CAAa,EAAA,CAC9CmJ,UAAUnJ,CAAS,CAAA,eAAe,GAAGiJ,CAAY,CAAA,IAAA,CAAKjJ,CAAS,CAAA,EAAE,EACvE,CAAC,CAAA,CACD,MAAM,OAAA,CAAQ,IAAI,CAChB,GAAGgJ,CAAc,CAAA,GAAA,CAAK9J,GAAU,IAAK,CAAA,aAAA,CAAc,CAAE,KAAAA,CAAAA,CAAM,CAAC,CAAC,CAAA,CAC7D,GAAG+J,CAAAA,CAAY,IAAKtI,CAAO,EAAA,IAAA,CAAK,eAAeA,CAAE,CAAC,CACpD,CAAC,EACH,CAqBAzC,CAAAA,CAAAA,CAAAA,CAAA,KAAQ,wBAAyB,CAAA,MAAOmD,GAAqC,CAEvE,CAAC,KAAK,WAAe,EAAA,IAAA,CAAK,iBAAkB,CAAA,MAAA,CAAS,EACvD,IAAK,CAAA,iBAAA,CAAkB,IAAKA,CAAAA,CAAK,EAEjC,MAAM,IAAA,CAAK,cAAeA,CAAAA,CAAK,EAEnC,CAsCAnD,CAAAA,CAAAA,CAAAA,CAAA,KAAQ,qBAA4D,CAAA,MAAOmD,GAAU,CACnF,IAAA,CAAK,YAAa,CAAA,KAAA,CAAM,KAAKA,CAAK,CAAA,CAClC,MAAM,IAAK,CAAA,oBAAA,GACb,CAEAnD,CAAAA,CAAAA,CAAAA,CAAA,IAAQ,CAAA,sBAAA,CAAuB,SAAY,CACzC,GAAI,KAAK,YAAa,CAAA,KAAA,GAAUG,oBAAoB,MAAQ,CAAA,CAC1D,IAAK,CAAA,MAAA,CAAO,OAAO,IAAK,CAAA,2CAA2C,CACnE,CAAA,MACF,CAMA,IAJA,IAAA,CAAK,MAAO,CAAA,MAAA,CAAO,KACjB,CAA+B,4BAAA,EAAA,IAAA,CAAK,aAAa,KAAM,CAAA,MAAM,WAC/D,CAEO,CAAA,IAAA,CAAK,YAAa,CAAA,KAAA,CAAM,OAAS,CAAG,EAAA,CACzC,KAAK,YAAa,CAAA,KAAA,CAAQA,oBAAoB,MAC9C,CAAA,MAAMiE,CAAU,CAAA,IAAA,CAAK,aAAa,KAAM,CAAA,KAAA,GACxC,GAAKA,CAAAA,CAEL,GAAI,CACF,MAAM,IAAK,CAAA,cAAA,CAAeA,CAAO,EACnC,CAAA,MAAShD,CAAO,CAAA,CACd,KAAK,MAAO,CAAA,MAAA,CAAO,IAAKA,CAAAA,CAAK,EAC/B,CACF,CACA,KAAK,YAAa,CAAA,KAAA,CAAQjB,oBAAoB,KAChD,CAAA,CAAA,CAEAH,CAAA,CAAA,IAAA,CAAQ,iBAAuD,MAAOmD,CAAAA,EAAU,CAC9E,KAAM,CAAE,KAAAnC,CAAAA,CAAAA,CAAO,OAAA6F,CAAAA,CAAAA,CAAS,YAAA+C,CAAa,CAAA,aAAA,CAAAnG,EAAe,WAAAyH,CAAAA,CAAY,EAAI/H,CAE9DgI,CAAAA,CAAAA,CAAYtE,CAAQ,CAAA,MAAA,CAE1B,GAAI,CAAK,IAAA,CAAA,0BAAA,CAA2B,CAAE,KAAA,CAAA7F,EAAO,aAAemK,CAAAA,CAAU,CAAC,CAAA,CAIvE,OAAQA,CAAW,EACjB,IAAK,mBACH,CAAA,OAAO,MAAM,IAAK,CAAA,uBAAA,CAAwB,CAAE,KAAA,CAAAnK,EAAO,OAAA6F,CAAAA,CAAAA,CAAS,YAAA+C,CAAa,CAAA,WAAA,CAAAsB,CAAY,CAAC,CAAA,CACxF,IAAK,kBAAA,CACH,OAAO,MAAM,IAAA,CAAK,uBAAuBlK,CAAO6F,CAAAA,CAAO,EACzD,IAAK,kBAAA,CACH,OAAO,MAAM,KAAK,sBAAuB7F,CAAAA,CAAAA,CAAO6F,CAAO,CAAA,CACzD,IAAK,kBACH,CAAA,OAAO,MAAM,IAAA,CAAK,uBAAuB7F,CAAO6F,CAAAA,CAAO,EACzD,IAAK,gBAAA,CACH,OAAO,MAAM,IAAA,CAAK,oBAAqB7F,CAAAA,CAAAA,CAAO6F,CAAO,CACvD,CAAA,IAAK,mBACH,OAAO,MAAM,KAAK,sBAAuB7F,CAAAA,CAAAA,CAAO6F,CAAO,CAAA,CACzD,IAAK,mBACH,CAAA,OAAO,MAAM,IAAK,CAAA,gBAAA,CAAiB,CACjC,KAAA7F,CAAAA,CAAAA,CACA,OAAA6F,CAAAA,CAAAA,CACA,YAAA+C,CACA,CAAA,WAAA,CAAAsB,CACA,CAAA,aAAA,CAAAzH,CACF,CAAC,CAAA,CACH,IAAK,iBAAA,CACH,OAAO,MAAM,IAAA,CAAK,sBAAsBzC,CAAO6F,CAAAA,CAAO,EACxD,IAAK,wBAAA,CACH,OAAO,MAAM,KAAK,4BAA6B,CAAA,CAC7C,MAAA7F,CACA,CAAA,OAAA,CAAA6F,EACA,WAAA+C,CAAAA,CAAAA,CACA,WAAAsB,CAAAA,CAAAA,CACA,cAAAzH,CACF,CAAC,EACH,QACE,OAAO,KAAK,MAAO,CAAA,MAAA,CAAO,IAAK,CAAA,CAAA,2BAAA,EAA8B0H,CAAS,CAAE,CAAA,CAC5E,CACF,CAAA,CAAA,CAEAnL,EAAA,IAAQ,CAAA,sBAAA,CAA8D,MAAOmD,CAAAA,EAAU,CACrF,KAAM,CAAE,MAAAnC,CAAO,CAAA,OAAA,CAAA6F,EAAS,aAAApD,CAAAA,CAAc,CAAIN,CAAAA,CAAAA,CAEpCiI,GADS,MAAM,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,QAAQ,GAAIpK,CAAAA,CAAAA,CAAO6F,CAAQ,CAAA,EAAE,GAC1C,OAAQ,CAAA,MAAA,CAEjC,OAAQuE,CAAW,EACjB,IAAK,mBACH,CAAA,OAAO,IAAK,CAAA,wBAAA,CAAyBpK,EAAO6F,CAASpD,CAAAA,CAAa,CACpE,CAAA,IAAK,mBACH,OAAO,IAAA,CAAK,uBAAwBzC,CAAAA,CAAAA,CAAO6F,CAAO,CACpD,CAAA,IAAK,mBACH,OAAO,IAAA,CAAK,wBAAwB7F,CAAO6F,CAAAA,CAAO,CACpD,CAAA,IAAK,mBACH,OAAO,IAAA,CAAK,wBAAwB7F,CAAO6F,CAAAA,CAAO,EACpD,IAAK,gBAAA,CACH,OAAO,IAAA,CAAK,sBAAsB7F,CAAO6F,CAAAA,CAAO,EAClD,IAAK,mBAAA,CACH,OAAO,IAAK,CAAA,wBAAA,CAAyB7F,CAAO6F,CAAAA,CAAO,EACrD,IAAK,wBAAA,CACH,OAAO,IAAA,CAAK,8BAA8B7F,CAAO6F,CAAAA,CAAO,CAC1D,CAAA,QACE,OAAO,IAAK,CAAA,MAAA,CAAO,OAAO,IAAK,CAAA,CAAA,4BAAA,EAA+BuE,CAAS,CAAE,CAAA,CAC7E,CACF,CAAA,CAAA,CAEApL,EAAA,IAAQ,CAAA,4BAAA,CAA2EmD,GAAU,CAC3F,KAAM,CAAE,KAAAnC,CAAAA,CAAM,CAAImC,CAAAA,CAAAA,CACZ,CAAE,OAAA5B,CAAAA,CAAQ,EAAIC,gBAClB,CAAA,oBAAA,CACA,4BAA4BR,CAAK,CAAA,yDAAA,CACnC,CACA,CAAA,MAAM,IAAI,KAAMO,CAAAA,CAAO,CACzB,CAAA,CAAA,CAEAvB,EAAA,IAAQ,CAAA,4BAAA,CAA2Ed,CAAW,EAAA,CAC5F,KAAM,CAAE,KAAA,CAAA8B,EAAO,aAAAqK,CAAAA,CAAc,EAAInM,CAC3BoM,CAAAA,CAAAA,CAAkB,IAAK,CAAA,wBAAA,CAAyB,IAAItK,CAAK,CAAA,CAG/D,OADI,CAACsK,CAAAA,EACDA,EAAgB,QAASD,CAAAA,CAAa,CAAU,CAAA,CAAA,CAAA,CAMhD,GAAAC,CAAgB,CAAA,QAAA,CAAS,wBAAwB,CAC/C,EAAA,IAAA,CAAK,OAAO,MAAO,CAAA,aAAA,CAAc,sBAAsB,CAAA,CAAI,EAKnE,CAIAtL,CAAAA,CAAAA,CAAAA,CAAA,IAAQ,CAAA,yBAAA,CAAoE,MAAOqJ,CAAS,EAAA,CAC1F,KAAM,CAAE,MAAArI,CAAO,CAAA,OAAA,CAAA6F,EAAS,WAAA+C,CAAAA,CAAAA,CAAa,YAAAsB,CAAY,CAAA,CAAI7B,CAC/C,CAAA,CAAE,OAAAnK,CAAQ,CAAA,EAAA,CAAAuD,CAAG,CAAA,CAAIoE,EACvB,GAAI,CACF,MAAM1D,CAAAA,CAAQ,KAAK,MAAO,CAAA,IAAA,CAAK,YAAY,QAAS,CAAA,CAAE,MAAAnC,CAAM,CAAC,CAEzD,CAAA,IAAA,CAAK,OAAO,MAAO,CAAA,aAAA,CAAc,kBAAkB,CAAA,GAAM,IAC3D,OAAQ,CAAA,IAAA,CAAK,wCAAwC,CAAA,CACrDmC,GAAA,IAAAA,EAAAA,CAAAA,CAAO,SAASoI,2BAA4B,CAAA,2BAAA,CAAA,CAAA,CAG9C,KAAK,cAAe7M,CAAAA,CAAAA,CAAA,EAAKmI,CAAAA,CAAAA,CAAQ,OAAQ,CACzC,CAAA,MAAMjF,EACJ1C,CAAO,CAAA,eAAA,EAAmB2C,WAAWvB,eAAgB,CAAA,iBAAA,CAAkB,GAAI,CAAA,GAAG,EAC1EwB,CAAWpD,CAAAA,CAAAA,CAAA,CACf,EAAA+D,CAAAA,CAAAA,CACA,aAAczB,CACd,CAAA,eAAA,CAAAY,CACA,CAAA,WAAA,CAAAgI,EACA,WAAAsB,CAAAA,CAAAA,CAAAA,CACGhM,CAEL,CAAA,CAAA,MAAM,KAAK,WAAYuD,CAAAA,CAAAA,CAAIX,CAAQ,CAAA,CAEnC,MAAMsH,CAAgB,CAAA,MAAM,KAAK,gBAAiB,CAAA,CAChD,cAAeQ,CACf,CAAA,IAAA,CAAMG,WAAY,CAAA,IAAA,CAAK,UAAUlD,CAAO,CAAC,EACzC,WAAAqE,CAAAA,CAAAA,CACA,SAAUpJ,CAAS,CAAA,QAAA,CAAS,QAC9B,CAAC,EAEDqB,CAAA,EAAA,IAAA,EAAAA,EAAO,QAASqI,CAAAA,2BAAAA,CAA4B,uBAE5C,IAAK,CAAA,MAAA,CAAO,MAAO,CAAA,IAAA,CAAK,mBAAoB,CAAE,EAAA,CAAA/I,CAAI,CAAA,MAAA,CAAQX,EAAU,aAAAsH,CAAAA,CAAc,CAAC,EACrF,OAASqC,CAAU,CAAA,CACjB,MAAM,IAAK,CAAA,SAAA,CAAU,CACnB,EAAAhJ,CAAAA,CAAAA,CACA,KAAAzB,CAAAA,CAAAA,CACA,MAAOyK,CACP,CAAA,OAAA,CAASnL,gBAAgB,iBAAkB,CAAA,UAC7C,CAAC,CACD,CAAA,IAAA,CAAK,MAAO,CAAA,MAAA,CAAO,MAAMmL,CAAG,EAC9B,CACF,CAEAzL,CAAAA,CAAAA,CAAAA,CAAA,KAAQ,0BAAsE,CAAA,MAC5EgB,CACA6F,CAAAA,CAAAA,CACApD,IACG,CACH,KAAM,CAAE,EAAA,CAAAhB,CAAG,CAAIoE,CAAAA,CAAAA,CAEf,GAAI9B,eAAAA,CAAgB8B,CAAO,CAAG,CAAA,CAC5B,KAAM,CAAE,MAAA,CAAAvC,CAAO,CAAIuC,CAAAA,CAAAA,CACnB,IAAK,CAAA,MAAA,CAAO,OAAO,KAAM,CAAA,CAAE,KAAM,QAAU,CAAA,MAAA,CAAQ,2BAA4B,MAAAvC,CAAAA,CAAO,CAAC,CAAA,CACvF,MAAMxC,CAAW,CAAA,IAAA,CAAK,OAAO,QAAS,CAAA,GAAA,CAAIW,CAAE,CAC5C,CAAA,IAAA,CAAK,MAAO,CAAA,MAAA,CAAO,MAAM,CAAE,IAAA,CAAM,QAAU,CAAA,MAAA,CAAQ,2BAA4B,QAAAX,CAAAA,CAAS,CAAC,CAAA,CACzF,MAAMsB,CAAgBtB,CAAAA,CAAAA,CAAS,SAAS,SACxC,CAAA,IAAA,CAAK,OAAO,MAAO,CAAA,KAAA,CAAM,CACvB,IAAA,CAAM,SACN,MAAQ,CAAA,0BAAA,CACR,cAAAsB,CACF,CAAC,EACD,MAAMC,CAAAA,CAAgBiB,CAAO,CAAA,kBAAA,CAC7B,KAAK,MAAO,CAAA,MAAA,CAAO,MAAM,CACvB,IAAA,CAAM,SACN,MAAQ,CAAA,0BAAA,CACR,aAAAjB,CAAAA,CACF,CAAC,CACD,CAAA,MAAMC,CAAe,CAAA,MAAM,KAAK,MAAO,CAAA,IAAA,CAAK,MAAO,CAAA,iBAAA,CACjDF,EACAC,CACF,CAAA,CACA,KAAK,eAAgB,CAAA,GAAA,CAAIZ,EAAI,CAC3B,YAAA,CAAAa,CACA,CAAA,YAAA,CAActC,EACd,UAAYyB,CAAAA,CAAAA,CACZ,UAAWW,CACb,CAAC,EAED,MAAMsI,CAAAA,CAAiB,MAAM,IAAA,CAAK,OAAO,IAAK,CAAA,OAAA,CAAQ,UAAUpI,CAAc,CAAA,CAC5E,cAAAG,CACF,CAAC,CACD,CAAA,IAAA,CAAK,OAAO,MAAO,CAAA,KAAA,CAAM,CACvB,IAAA,CAAM,SACN,MAAQ,CAAA,0BAAA,CACR,cAAAiI,CAAAA,CACF,CAAC,CACD,CAAA,MAAM,KAAK,MAAO,CAAA,IAAA,CAAK,QAAQ,QAAS,CAAA,CAAE,KAAA1K,CAAAA,CAAM,CAAC,EACnD,CAAA,KAAA,GAAWgE,eAAe6B,CAAO,CAAA,CAAG,CAClC,MAAM,IAAA,CAAK,cAAepE,CAAAA,CAAE,EAC5B,MAAMkJ,CAAAA,CAASzJ,YAAY,iBAAmBO,CAAAA,CAAE,EAEhD,GADkB,IAAA,CAAK,MAAO,CAAA,aAAA,CAAckJ,CAAM,CAChC,GAAA,CAAA,CAChB,MAAM,IAAI,MAAM,CAAYA,SAAAA,EAAAA,CAAM,CAA6B,2BAAA,CAAA,CAAA,CAEjE,KAAK,MAAO,CAAA,IAAA,CAAKA,EAAQ,CAAE,KAAA,CAAO9E,EAAQ,KAAM,CAAC,EACnD,CACF,GAEA7G,CAAA,CAAA,IAAA,CAAQ,wBAAkE,CAAA,MACxEgB,EACA6F,CACG,GAAA,CACH,KAAM,CAAE,GAAApE,CAAI,CAAA,MAAA,CAAAvD,CAAO,CAAI2H,CAAAA,CAAAA,CACvB,GAAI,CACF,IAAA,CAAK,2BAA4B3H,CAAAA,CAAM,EACvC,KAAM,CACJ,KAAA0M,CAAAA,CAAAA,CACA,WAAAC,CACA,CAAA,MAAA,CAAAnK,CACA,CAAA,UAAA,CAAAsB,EACA,iBAAAnC,CAAAA,CAAAA,CACA,iBAAAC,CACA,CAAA,aAAA,CAAAmC,CACF,CAAI4D,CAAAA,CAAAA,CAAQ,MACNiF,CAAAA,CAAAA,CAAiB,CAAC,GAAG,IAAA,CAAK,gBAAgB,MAAO,EAAC,EAAE,IACvDC,CAAAA,CAAAA,EAAMA,CAAE,CAAA,YAAA,GAAiB/K,CAC5B,CAEA,CAAA,GAAI,CAAC8K,CACH,CAAA,OAAO,KAAK,MAAO,CAAA,MAAA,CAAO,KAAM,CAAA,CAAA,oCAAA,EAAuC9K,CAAK,CAAE,CAAA,CAAA,CAGhF,MAAMc,CAAAA,CAAW,KAAK,MAAO,CAAA,QAAA,CAAS,GAAIgK,CAAAA,CAAAA,CAAe,UAAU,CAE7DpJ,CAAAA,CAAAA,CAA+BjE,EAAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CACnC,MAAAsC,CACA,CAAA,KAAA,CAAA4K,CACA,CAAA,MAAA,CAAAlK,EACA,UAAAsB,CAAAA,CAAAA,CACA,aAAc,CACd,CAAA,CAAA,YAAA,CAAc8I,EAAe,YAC7B,CAAA,kBAAA,CAAoBhK,CAAS,CAAA,kBAAA,CAC7B,mBAAoBA,CAAS,CAAA,kBAAA,CAC7B,WAAY+J,CAAW,CAAA,SAAA,CACvB,KAAM,CACJ,SAAA,CAAWC,CAAe,CAAA,SAAA,CAC1B,SAAU,IAAK,CAAA,MAAA,CAAO,QACxB,CAAA,CACA,KAAM,CACJ,SAAA,CAAWD,CAAW,CAAA,SAAA,CACtB,SAAUA,CAAW,CAAA,QACvB,GACIhL,CAAqB,EAAA,CAAE,kBAAAA,CAAkB,CAAA,CAAA,CACzCC,CAAoB,EAAA,CAAE,iBAAAA,CAAiB,CAAA,CAAA,CACvCmC,GAAiB,CAAE,aAAA,CAAAA,CAAc,CApBF,CAAA,CAAA,CAqBnC,aAAeS,CAAAA,eAAAA,CAAgB,KACjC,CAEA,CAAA,CAAA,MAAM,KAAK,MAAO,CAAA,OAAA,CAAQ,IAAIhB,CAAQ,CAAA,KAAA,CAAOA,CAAO,CAAA,CACpD,MAAM,IAAK,CAAA,SAAA,CAAUA,CAAQ,CAAA,KAAA,CAAOA,EAAQ,MAAM,CAAA,CAElD,MAAM,IAAA,CAAK,OAAO,IAAK,CAAA,OAAA,CAAQ,eAAe,CAC5C,KAAA,CAAOoJ,EAAe,YACtB,CAAA,QAAA,CAAUpJ,CAAQ,CAAA,IAAA,CAAK,QACzB,CAAC,CAAA,CAED,IAAK,CAAA,MAAA,CAAO,OAAO,IAAK,CAAA,iBAAA,CAAmB,CAAE,OAAA,CAAAA,CAAQ,CAAC,CAAA,CACtD,KAAK,MAAO,CAAA,IAAA,CAAKR,YAAY,iBAAmB4J,CAAAA,CAAAA,CAAe,UAAU,CAAA,CAAG,CAAE,OAAApJ,CAAAA,CAAQ,CAAC,CAAA,CAEvF,KAAK,eAAgB,CAAA,MAAA,CAAOoJ,CAAe,CAAA,UAAU,EACrD,IAAK,CAAA,cAAA,CAAeA,EAAe,UAAY,CAAA,CAAA,CAAK,EACpD,IAAK,CAAA,wBAAA,CAAyBpJ,CAAO,CAAA,CAErC,MAAM,IAAK,CAAA,UAAA,CAA+B,CACxC,EAAImE,CAAAA,CAAAA,CAAQ,GACZ,KAAA7F,CAAAA,CAAAA,CACA,MAAQ,CAAA,CAAA,CACV,CAAC,EACH,CAAA,MAASyK,EAAU,CACjB,MAAM,KAAK,SAAU,CAAA,CACnB,EAAAhJ,CAAAA,CAAAA,CACA,MAAAzB,CACA,CAAA,KAAA,CAAOyK,CACT,CAAC,EACD,IAAK,CAAA,MAAA,CAAO,MAAO,CAAA,KAAA,CAAMA,CAAG,EAC9B,CACF,GAEAzL,CAAA,CAAA,IAAA,CAAQ,0BAAoE,MAC1EgB,CAAAA,CACA6F,CACG,GAAA,CACH,KAAM,CAAE,EAAA,CAAApE,CAAG,CAAIoE,CAAAA,CAAAA,CACX9B,gBAAgB8B,CAAO,CAAA,EACzB,MAAM,IAAA,CAAK,OAAO,OAAQ,CAAA,MAAA,CAAO7F,EAAO,CAAE,YAAA,CAAc,EAAK,CAAC,CAAA,CAC9D,IAAK,CAAA,MAAA,CAAO,KAAKkB,WAAY,CAAA,iBAAA,CAAmBO,CAAE,CAAA,CAAG,EAAE,CAAA,EAC9CuC,cAAe6B,CAAAA,CAAO,IAC/B,MAAM,IAAA,CAAK,OAAO,OAAQ,CAAA,MAAA,CAAO7F,EAAO2C,WAAY,CAAA,mBAAmB,CAAC,CAAA,CACxE,KAAK,MAAO,CAAA,IAAA,CAAKzB,YAAY,iBAAmBO,CAAAA,CAAE,EAAG,CAAE,KAAA,CAAOoE,CAAQ,CAAA,KAAM,CAAC,CAEjF,EAAA,CAAA,CAAA,CAEA7G,EAAA,IAAQ,CAAA,wBAAA,CAAkE,MACxEgB,CACA6F,CAAAA,CAAAA,GACG,CACH,KAAM,CAAE,MAAA3H,CAAAA,CAAAA,CAAQ,EAAAuD,CAAAA,CAAG,EAAIoE,CACvB,CAAA,GAAI,CACF,MAAMmF,EAAY,CAAGhL,EAAAA,CAAK,kBAGpBiL,CAAsBC,CAAAA,WAAAA,CAAY,IAAYF,CAAS,CAAA,CAE7D,GAAIC,CAAAA,EAAuB,KAAK,kBAAmBA,CAAAA,CAAAA,CAAqBxJ,CAAE,CAAA,CAAG,CAC3E,IAAK,CAAA,MAAA,CAAO,MAAO,CAAA,IAAA,CAAK,oCAAoCA,CAAE,CAAA,CAAE,EAChE,IAAK,CAAA,SAAA,CAAU,CAAE,EAAAA,CAAAA,CAAAA,CAAI,KAAAzB,CAAAA,CAAAA,CAAO,MAAO2C,WAAY,CAAA,wBAAwB,CAAE,CAAC,EAC1E,MACF,CACA,IAAK,CAAA,aAAA,CAAcjF,EAAA,CAAE,KAAA,CAAAsC,GAAU9B,CAAQ,CAAA,CAAA,CACvC,GAAI,CACFgN,WAAAA,CAAY,GAAIF,CAAAA,CAAAA,CAAWvJ,CAAE,CAC7B,CAAA,MAAM,KAAK,MAAO,CAAA,OAAA,CAAQ,OAAOzB,CAAO,CAAA,CAAE,UAAY9B,CAAAA,CAAAA,CAAO,UAAW,CAAC,CAAA,CACzE,MAAM,IAAK,CAAA,UAAA,CAA+B,CACxC,EAAAuD,CAAAA,CAAAA,CACA,KAAAzB,CAAAA,CAAAA,CACA,OAAQ,CACV,CAAA,CAAC,EACH,CAAA,MAASkD,EAAG,CACV,MAAAgI,WAAY,CAAA,MAAA,CAAOF,CAAS,CACtB9H,CAAAA,CACR,CAEA,IAAK,CAAA,MAAA,CAAO,OAAO,IAAK,CAAA,gBAAA,CAAkB,CAAE,EAAA,CAAAzB,EAAI,KAAAzB,CAAAA,CAAAA,CAAO,OAAA9B,CAAO,CAAC,EACjE,CAASuM,MAAAA,CAAAA,CAAU,CACjB,MAAM,KAAK,SAAU,CAAA,CACnB,GAAAhJ,CACA,CAAA,KAAA,CAAAzB,EACA,KAAOyK,CAAAA,CACT,CAAC,CAAA,CACD,KAAK,MAAO,CAAA,MAAA,CAAO,KAAMA,CAAAA,CAAG,EAC9B,CACF,CAAA,CAAA,CAIAzL,CAAA,CAAA,IAAA,CAAQ,qBAAqB,CAACmM,CAAAA,CAAgBC,IACrCA,CAAU,CAAA,QAAA,GAAW,KAAM,CAAA,CAAA,CAAG,CAAE,CAAA,CAAA,CAAID,EAAO,QAAS,EAAA,CAAE,MAAM,CAAG,CAAA,CAAA,CAAE,GAG1EnM,CAAA,CAAA,IAAA,CAAQ,yBAAoE,CAAA,CAACqM,EAAQxF,CAAY,GAAA,CAC/F,KAAM,CAAE,EAAA,CAAApE,CAAG,CAAIoE,CAAAA,CAAAA,CACT8E,CAASzJ,CAAAA,WAAAA,CAAY,iBAAkBO,CAAE,CAAA,CAE/C,GADkB,IAAA,CAAK,OAAO,aAAckJ,CAAAA,CAAM,CAChC,GAAA,CAAA,CAChB,MAAM,IAAI,KAAA,CAAM,YAAYA,CAAM,CAAA,sBAAA,CAAwB,EAExD5G,eAAgB8B,CAAAA,CAAO,CACzB,CAAA,IAAA,CAAK,OAAO,IAAK3E,CAAAA,WAAAA,CAAY,iBAAkBO,CAAE,CAAA,CAAG,EAAE,CAAA,CAC7CuC,cAAe6B,CAAAA,CAAO,GAC/B,IAAK,CAAA,MAAA,CAAO,KAAK3E,WAAY,CAAA,gBAAA,CAAkBO,CAAE,CAAG,CAAA,CAAE,KAAOoE,CAAAA,CAAAA,CAAQ,KAAM,CAAC,EAEhF,CAEA7G,CAAAA,CAAAA,CAAAA,CAAA,KAAQ,wBAAkE,CAAA,MACxEgB,CACA6F,CAAAA,CAAAA,GACG,CACH,KAAM,CAAE,GAAApE,CAAG,CAAA,CAAIoE,EACf,GAAI,CACF,IAAK,CAAA,aAAA,CAAc,CAAE,KAAA7F,CAAAA,CAAM,CAAC,CAC5B,CAAA,MAAM,KAAK,SAAUA,CAAAA,CAAAA,CAAOa,UAAW2B,CAAAA,cAAc,CAAC,CACtD,CAAA,MAAM,KAAK,UAA+B,CAAA,CACxC,GAAAf,CACA,CAAA,KAAA,CAAAzB,CACA,CAAA,MAAA,CAAQ,EACV,CAAC,CAAA,CACD,IAAK,CAAA,MAAA,CAAO,OAAO,IAAK,CAAA,gBAAA,CAAkB,CAAE,EAAA,CAAAyB,EAAI,KAAAzB,CAAAA,CAAM,CAAC,EACzD,CAAA,MAASyK,EAAU,CACjB,MAAM,IAAK,CAAA,SAAA,CAAU,CACnB,EAAAhJ,CAAAA,CAAAA,CACA,MAAAzB,CACA,CAAA,KAAA,CAAOyK,CACT,CAAC,CAAA,CACD,IAAK,CAAA,MAAA,CAAO,OAAO,KAAMA,CAAAA,CAAG,EAC9B,CACF,CAAA,CAAA,CAEAzL,EAAA,IAAQ,CAAA,yBAAA,CAAoE,CAACqM,CAAAA,CAAQxF,IAAY,CAC/F,KAAM,CAAE,EAAA,CAAApE,CAAG,CAAIoE,CAAAA,CAAAA,CACT8E,CAASzJ,CAAAA,WAAAA,CAAY,iBAAkBO,CAAE,CAAA,CAE/C,GADkB,IAAK,CAAA,MAAA,CAAO,cAAckJ,CAAM,CAAA,GAChC,CAChB,CAAA,MAAM,IAAI,KAAM,CAAA,CAAA,SAAA,EAAYA,CAAM,CAAwB,sBAAA,CAAA,CAAA,CAExD5G,gBAAgB8B,CAAO,CAAA,CACzB,IAAK,CAAA,MAAA,CAAO,KAAK3E,WAAY,CAAA,gBAAA,CAAkBO,CAAE,CAAG,CAAA,EAAE,CAC7CuC,CAAAA,cAAAA,CAAe6B,CAAO,CAAA,EAC/B,KAAK,MAAO,CAAA,IAAA,CAAK3E,WAAY,CAAA,gBAAA,CAAkBO,CAAE,CAAG,CAAA,CAAE,KAAOoE,CAAAA,CAAAA,CAAQ,KAAM,CAAC,EAEhF,GAEA7G,CAAA,CAAA,IAAA,CAAQ,uBAA8D,MAAOgB,CAAAA,CAAO6F,CAAY,GAAA,CAC9F,KAAM,CAAE,EAAA,CAAApE,CAAG,CAAA,CAAIoE,EACf,GAAI,CACF,IAAK,CAAA,WAAA,CAAY,CAAE,KAAA7F,CAAAA,CAAM,CAAC,CAC1B,CAAA,MAAM,KAAK,UAA6B,CAAA,CACtC,EAAAyB,CAAAA,CAAAA,CACA,MAAAzB,CACA,CAAA,MAAA,CAAQ,CACR,CAAA,CAAA,oBAAA,CAAsB,EACxB,CAAC,CAAA,CACD,IAAK,CAAA,MAAA,CAAO,OAAO,IAAK,CAAA,cAAA,CAAgB,CAAE,EAAAyB,CAAAA,CAAAA,CAAI,MAAAzB,CAAM,CAAC,EACvD,CAAA,MAASyK,EAAU,CACjB,MAAM,KAAK,SAAU,CAAA,CACnB,GAAAhJ,CACA,CAAA,KAAA,CAAAzB,CACA,CAAA,KAAA,CAAOyK,CACT,CAAC,CAAA,CACD,KAAK,MAAO,CAAA,MAAA,CAAO,MAAMA,CAAG,EAC9B,CACF,CAAA,CAAA,CAEAzL,EAAA,IAAQ,CAAA,uBAAA,CAAgE,CAACqM,CAAAA,CAAQxF,IAAY,CAC3F,KAAM,CAAE,EAAA,CAAApE,CAAG,CAAIoE,CAAAA,CAAAA,CACT8E,EAASzJ,WAAY,CAAA,cAAA,CAAgBO,CAAE,CAI7C,CAAA,UAAA,CAAW,IAAM,CAEf,GADkB,IAAK,CAAA,MAAA,CAAO,cAAckJ,CAAM,CAAA,GAChC,EAChB,MAAM,IAAI,KAAM,CAAA,CAAA,SAAA,EAAYA,CAAM,CAA6B,2BAAA,CAAA,CAAA,CAG7D5G,gBAAgB8B,CAAO,CAAA,CACzB,KAAK,MAAO,CAAA,IAAA,CAAK3E,WAAY,CAAA,cAAA,CAAgBO,CAAE,CAAG,CAAA,EAAE,CAAA,CAC3CuC,eAAe6B,CAAO,CAAA,EAC/B,IAAK,CAAA,MAAA,CAAO,KAAK3E,WAAY,CAAA,cAAA,CAAgBO,CAAE,CAAG,CAAA,CAAE,MAAOoE,CAAQ,CAAA,KAAM,CAAC,EAE9E,EAAG,GAAG,EACR,GAEA7G,CAAA,CAAA,IAAA,CAAQ,yBAAkE,MACxEgB,CAAAA,CACA6F,CACG,GAAA,CACH,KAAM,CAAE,EAAA,CAAApE,CAAG,CAAIoE,CAAAA,CAAAA,CACf,GAAI,CACF,IAAA,CAAK,iBAAkB,CAAA,CAAE,MAAA7F,CAAO,CAAA,MAAA,CAAQ6F,CAAQ,CAAA,MAAO,CAAC,CACxD,CAAA,MAAM,OAAQ,CAAA,GAAA,CAAI,CAChB,IAAI,OAAA,CAASzE,GAAY,CAEvB,IAAA,CAAK,OAAO,IAAK,CAAA,OAAA,CAAQ,IAAKkK,CAAAA,cAAAA,CAAe,QAAS,SAAY,CAChElK,CAAQ,CAAA,MAAM,KAAK,aAAc,CAAA,CAAE,KAAApB,CAAAA,CAAAA,CAAO,GAAAyB,CAAG,CAAC,CAAC,EACjD,CAAC,EACH,CAAC,CAAA,CACD,IAAK,CAAA,UAAA,CAA+B,CAClC,EAAAA,CAAAA,CAAAA,CACA,KAAAzB,CAAAA,CAAAA,CACA,OAAQ,CACV,CAAA,CAAC,CACD,CAAA,IAAA,CAAK,mCAAmC,CAAE,KAAA,CAAAA,EAAO,KAAO2C,CAAAA,WAAAA,CAAY,mBAAmB,CAAE,CAAC,CAC5F,CAAC,EAAE,KAAO8H,CAAAA,CAAAA,EAAQ,KAAK,MAAO,CAAA,MAAA,CAAO,MAAMA,CAAG,CAAC,EACjD,CAAA,MAASA,EAAU,CACjB,IAAA,CAAK,OAAO,MAAO,CAAA,KAAA,CAAMA,CAAG,EAC9B,CACF,CAEAzL,CAAAA,CAAAA,CAAAA,CAAA,KAAQ,kBAAsD,CAAA,MAAOqJ,CAAS,EAAA,CAlxEhF,IAAAlK,CAAAC,CAAAA,CAAAA,CAAAuD,CAmxEI,CAAA,KAAM,CAAE,KAAA3B,CAAAA,CAAAA,CAAO,QAAA6F,CAAS,CAAA,WAAA,CAAA+C,EAAa,WAAAsB,CAAAA,CAAAA,CAAa,aAAAzH,CAAAA,CAAc,EAAI4F,CAC9D,CAAA,CAAE,GAAA5G,CAAI,CAAA,MAAA,CAAAvD,CAAO,CAAI2H,CAAAA,CAAAA,CACvB,GAAI,CACF,MAAM,IAAK,CAAA,cAAA,CAAenI,EAAA,CAAE,KAAA,CAAAsC,GAAU9B,CAAQ,CAAA,CAAA,CAC9C,MAAMwD,CAAAA,CAAU,KAAK,MAAO,CAAA,OAAA,CAAQ,GAAI1B,CAAAA,CAAK,EACvCoI,CAAgB,CAAA,MAAM,IAAK,CAAA,gBAAA,CAAiB,CAChD,aAAeQ,CAAAA,CAAAA,CACf,KAAMG,WAAY,CAAA,IAAA,CAAK,UAAUjC,oBAAqB,CAAA,mBAAA,CAAqB5I,CAAQuD,CAAAA,CAAE,CAAC,CAAC,CAAA,CACvF,YAAAyI,CACA,CAAA,QAAA,CAAUxI,EAAQ,IAAK,CAAA,QAAA,CACvB,aAAAe,CAAAA,CACF,CAAC,CACKW,CAAAA,CAAAA,CAAU,CACd,EAAA3B,CAAAA,CAAAA,CACA,MAAAzB,CACA,CAAA,MAAA,CAAA9B,CACA,CAAA,aAAA,CAAAkK,CACF,CACA,CAAA,MAAM,IAAK,CAAA,wBAAA,CAAyBhF,CAAO,CAGzCX,CAAAA,CAAAA,GAAkBC,eAAgB,CAAA,SAAA,GAAA,CAClCvE,EAAAuD,CAAQ,CAAA,IAAA,CAAK,SAAS,QAAtB,GAAA,IAAA,EAAAvD,EAAgC,SAGhC,CAAA,EAAA,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,yBAAwBC,CAAAsD,CAAAA,CAAAA,CAAQ,IAAK,CAAA,QAAA,CAAS,WAAtB,IAAAtD,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAgC,SAAS,CAAA,CAAA,CAKhFuD,EAAA,IAAK,CAAA,MAAA,CAAO,aAAZ,IAAAA,EAAAA,CAAAA,CAAwB,oBAC1B,IAAK,CAAA,kBAAA,CAAmByB,CAAO,CAAA,EAE/B,KAAK,sCAAuCA,CAAAA,CAAO,CACnD,CAAA,IAAA,CAAK,4BAET,EAAA,CAAA,MAASqH,CAAU,CAAA,CACjB,MAAM,IAAK,CAAA,SAAA,CAAU,CACnB,EAAAhJ,CAAAA,CAAAA,CACA,MAAAzB,CACA,CAAA,KAAA,CAAOyK,CACT,CAAC,EACD,IAAK,CAAA,MAAA,CAAO,OAAO,KAAMA,CAAAA,CAAG,EAC9B,CACF,CAAA,CAAA,CAEAzL,CAAA,CAAA,IAAA,CAAQ,2BAAsE,CAC5EqM,CAAAA,CACAxF,IACG,CACH,KAAM,CAAE,EAAApE,CAAAA,CAAG,CAAIoE,CAAAA,CAAAA,CACT8E,EAASzJ,WAAY,CAAA,iBAAA,CAAmBO,CAAE,CAAA,CAEhD,GADkB,IAAK,CAAA,MAAA,CAAO,aAAckJ,CAAAA,CAAM,IAChC,CAChB,CAAA,MAAM,IAAI,KAAM,CAAA,CAAA,SAAA,EAAYA,CAAM,CAAwB,sBAAA,CAAA,CAAA,CAExD5G,eAAgB8B,CAAAA,CAAO,EACzB,IAAK,CAAA,MAAA,CAAO,KAAK3E,WAAY,CAAA,iBAAA,CAAmBO,CAAE,CAAG,CAAA,CAAE,MAAQoE,CAAAA,CAAAA,CAAQ,MAAO,CAAC,CAAA,CACtE7B,eAAe6B,CAAO,CAAA,EAC/B,KAAK,MAAO,CAAA,IAAA,CAAK3E,WAAY,CAAA,iBAAA,CAAmBO,CAAE,CAAG,CAAA,CAAE,KAAOoE,CAAAA,CAAAA,CAAQ,KAAM,CAAC,EAEjF,CAEA7G,CAAAA,CAAAA,CAAAA,CAAA,KAAQ,uBAAgE,CAAA,MACtEgB,EACA6F,CACG,GAAA,CACH,KAAM,CAAE,EAAA,CAAApE,CAAI,CAAA,MAAA,CAAAvD,CAAO,CAAI2H,CAAAA,CAAAA,CACvB,GAAI,CAGF,MAAMmF,EAAY,CAAGhL,EAAAA,CAAK,CAAkB9B,eAAAA,EAAAA,CAAAA,CAAO,MAAM,IAAI,CAAA,CAAA,CAGvD+M,EAAsBC,WAAY,CAAA,GAAA,CAAYF,CAAS,CAC7D,CAAA,GAAIC,CAAuB,EAAA,IAAA,CAAK,mBAAmBA,CAAqBxJ,CAAAA,CAAE,CAAG,CAAA,CAC3E,KAAK,MAAO,CAAA,MAAA,CAAO,IAAK,CAAA,CAAA,iCAAA,EAAoCA,CAAE,CAAE,CAAA,CAAA,CAChE,MACF,CAEA,IAAA,CAAK,YAAY/D,CAAA,CAAA,CAAE,KAAAsC,CAAAA,CAAAA,CAAAA,CAAU9B,EAAQ,CACrC,CAAA,IAAA,CAAK,OAAO,MAAO,CAAA,IAAA,CAAK,gBAAiB,CAAE,EAAA,CAAAuD,CAAI,CAAA,KAAA,CAAAzB,EAAO,MAAA9B,CAAAA,CAAO,CAAC,CAC9DgN,CAAAA,WAAAA,CAAY,IAAIF,CAAWvJ,CAAAA,CAAE,EAC/B,CAAA,MAASgJ,EAAU,CACjB,MAAM,IAAK,CAAA,SAAA,CAAU,CACnB,EAAAhJ,CAAAA,CAAAA,CACA,KAAAzB,CAAAA,CAAAA,CACA,MAAOyK,CACT,CAAC,EACD,IAAK,CAAA,MAAA,CAAO,OAAO,KAAMA,CAAAA,CAAG,EAC9B,CACF,GAEAzL,CAAA,CAAA,IAAA,CAAQ,gCAAgF,CACtFgB,CAAAA,CACA6F,IACG,CACH,KAAM,CAAE,EAAA,CAAApE,CAAG,CAAIoE,CAAAA,CAAAA,CACf,KAAK,MAAO,CAAA,MAAA,CAAO,MAAM,CACvB,IAAA,CAAM,QACN,CAAA,MAAA,CAAQ,gCACR,KAAA7F,CAAAA,CAAAA,CACA,OAAA6F,CAAAA,CACF,CAAC,CACG9B,CAAAA,eAAAA,CAAgB8B,CAAO,CAAA,CACzB,KAAK,MAAO,CAAA,IAAA,CAAK3E,YAAY,iBAAmBO,CAAAA,CAAE,EAAG,CAAE,MAAA,CAAQoE,CAAQ,CAAA,MAAO,CAAC,CACtE7B,CAAAA,cAAAA,CAAe6B,CAAO,CAC/B,EAAA,IAAA,CAAK,OAAO,IAAK3E,CAAAA,WAAAA,CAAY,iBAAmBO,CAAAA,CAAE,EAAG,CAAE,KAAA,CAAOoE,EAAQ,KAAM,CAAC,EAEjF,CAEA7G,CAAAA,CAAAA,CAAAA,CAAA,IAAQ,CAAA,8BAAA,CAA8E,MACpFqJ,CACG,EAAA,CAp4EP,IAAAlK,CAAAA,CAq4EI,KAAM,CAAE,KAAA,CAAA6B,CAAO,CAAA,OAAA,CAAA6F,EAAS,WAAA+C,CAAAA,CAAAA,CAAa,YAAAsB,CAAa,CAAA,aAAA,CAAAzH,CAAc,CAAI4F,CAAAA,CAAAA,CACpE,GAAI,CACF,KAAM,CAAE,SAAA,CAAAkD,EAAW,WAAAC,CAAAA,CAAAA,CAAa,gBAAA5K,CAAgB,CAAA,CAAIiF,CAAQ,CAAA,MAAA,CACtDuC,EAAgB,MAAM,IAAA,CAAK,iBAAiB,CAChD,aAAA,CAAeQ,EACf,IAAMG,CAAAA,WAAAA,CAAY,IAAK,CAAA,SAAA,CAAUlD,CAAO,CAAC,CAAA,CACzC,WAAAqE,CAAAA,CAAAA,CACA,SAAUqB,CAAU,CAAA,QAAA,CACpB,aAAA9I,CAAAA,CACF,CAAC,CACK6E,CAAAA,CAAAA,CAAiB,CACrB,SAAAiE,CAAAA,CAAAA,CACA,aAAcvL,CACd,CAAA,EAAA,CAAI6F,CAAQ,CAAA,EAAA,CACZ,YAAA2F,CACA,CAAA,aAAA,CAAApD,CACA,CAAA,eAAA,CAAAxH,CACF,CACA,CAAA,MAAM,IAAK,CAAA,cAAA,CAAeiF,EAAQ,EAAI,CAAA,CACpC,QAASyB,CACT,CAAA,YAAA,CAActH,EACd,aAAAyC,CAAAA,CACF,CAAC,CAAA,CAEGA,IAAkBC,eAAgB,CAAA,SAAA,GAAA,CAAavE,CAAAoN,CAAAA,CAAAA,CAAU,SAAS,QAAnB,GAAA,IAAA,EAAApN,CAA6B,CAAA,SAAA,CAAA,EAE9E,KAAK,MAAO,CAAA,IAAA,CAAK,wBAAwBoN,CAAU,CAAA,QAAA,CAAS,SAAS,SAAS,CAAA,CAGhF,IAAK,CAAA,MAAA,CAAO,OAAO,IAAK,CAAA,sBAAA,CAAwB,CAC9C,KAAAvL,CAAAA,CAAAA,CACA,OAAQ6F,CAAQ,CAAA,MAAA,CAChB,EAAIA,CAAAA,CAAAA,CAAQ,GACZ,aAAAuC,CAAAA,CACF,CAAC,EACH,CAAA,MAASqC,EAAU,CACjB,IAAA,CAAK,MAAO,CAAA,MAAA,CAAO,MAAMA,CAAG,CAAA,CAE5B,MAAMlD,CAAAA,CAAoB1B,EAAQ,MAAO,CAAA,SAAA,CAAU,SAC7C2B,CAAAA,CAAAA,CAAkB,MAAM,IAAK,CAAA,MAAA,CAAO,KAAK,MAAO,CAAA,eAAA,GAChDhE,CAAU,CAAA,IAAA,CAAK,mBAAoBqC,CAAAA,CAAAA,CAAQ,OAAO,SAAU,CAAA,QAAA,CAAUpD,CAAa,CAEnFgF,CAAAA,CAAAA,CAAa,CACjB,IAAMC,CAAAA,MAAAA,CACN,iBAAAH,CAAAA,CAAAA,CACA,gBAAAC,CACF,CAAA,CACA,MAAM,IAAK,CAAA,SAAA,CAAU,CACnB,EAAI3B,CAAAA,CAAAA,CAAQ,EACZ,CAAA,KAAA,CAAA7F,EACA,KAAOyK,CAAAA,CAAAA,CACP,UAAAhD,CAAAA,CAAAA,CACA,QAASnI,eAAgB,CAAA,sBAAA,CAAuB,UAChD,CAAA,OAAA,CAAAkE,CACF,CAAC,EACH,CACF,CAQAxE,CAAAA,CAAAA,CAAAA,CAAA,KAAQ,wCAA0CoE,CAAAA,CAAAA,EAAwC,CACxF,IAAA,CAAK,oBAAoB,KAAM,CAAA,IAAA,CAAKA,CAAO,EAC7C,CAAA,CAAA,CAEApE,EAAA,IAAQ,CAAA,sBAAA,CAAwBd,CAAsC,EAAA,CACpE,KAAK,2BAA4BA,CAAAA,CAAAA,CAAO,SAAS,EAAI,CAAA,CAAE,QAAS,WAAa,CAAA,IAAA,CAAM,CAAE,CAAC,EAEtF,UAAW,CAAA,IAAM,CACf,IAAA,CAAK,oBAAoB,KAAQiB,CAAAA,mBAAAA,CAAoB,IACrD,CAAA,IAAA,CAAK,6BACP,CAAA,CAAGI,cAAc,IAAK,CAAA,iBAAiB,CAAC,EAC1C,CAAA,CAAA,CAGAP,CAAA,CAAA,IAAA,CAAQ,qCAAqC,CAAC,CAC5C,KAAAgB,CAAAA,CAAAA,CACA,MAAAI,CACF,CAAA,GAGM,CACJ,MAAMqL,EAAkB,IAAK,CAAA,MAAA,CAAO,KAAK,OAAQ,CAAA,OAAA,CAC7CA,EAAgB,MAAS,CAAA,CAAA,EACRA,CAAgB,CAAA,MAAA,CAChCtD,GAAMA,CAAE,CAAA,KAAA,GAAUnI,CAASmI,EAAAA,CAAAA,CAAE,QAAQ,MAAW,GAAA,mBACnD,CACW,CAAA,OAAA,CAASA,GAAM,CACxB,MAAM1G,EAAK0G,CAAE,CAAA,OAAA,CAAQ,GACfwC,CAASzJ,CAAAA,WAAAA,CAAY,iBAAmBO,CAAAA,CAAE,EAEhD,GADkB,IAAA,CAAK,OAAO,aAAckJ,CAAAA,CAAM,IAChC,CAChB,CAAA,MAAM,IAAI,KAAA,CAAM,YAAYA,CAAM,CAAA,sBAAA,CAAwB,EAG5D,IAAK,CAAA,MAAA,CAAO,KAAKzJ,WAAY,CAAA,iBAAA,CAAmBiH,CAAE,CAAA,OAAA,CAAQ,EAAE,CAAG,CAAA,CAC7D,KAAA/H,CAAAA,CACF,CAAC,EACH,CAAC,EAEL,CAAA,CAAA,CAEApB,EAAA,IAAQ,CAAA,4BAAA,CAA6B,IAAM,CACzC,GAAI,KAAK,mBAAoB,CAAA,KAAA,GAAUG,mBAAoB,CAAA,MAAA,CAAQ,CACjE,IAAK,CAAA,MAAA,CAAO,OAAO,IAAK,CAAA,0CAA0C,EAClE,MACF,CAEA,MAAMiE,CAAAA,CAAU,KAAK,mBAAoB,CAAA,KAAA,CAAM,CAAC,CAChD,CAAA,GAAI,CAACA,CAAS,CAAA,CACZ,IAAK,CAAA,MAAA,CAAO,OAAO,IAAK,CAAA,iCAAiC,CACzD,CAAA,MACF,CAEA,GAAI,CACF,IAAK,CAAA,kBAAA,CAAmBA,CAAO,EACjC,CAAA,MAAShD,EAAO,CACd,IAAA,CAAK,OAAO,MAAO,CAAA,KAAA,CAAMA,CAAK,EAChC,CACF,CASApB,CAAAA,CAAAA,CAAAA,CAAA,KAAQ,oBAAsBoE,CAAAA,CAAAA,EAAwC,CACpE,GAAI,IAAA,CAAK,sBAAuB,CAAA,GAAA,CAAIA,EAAQ,EAAE,CAAA,CAAG,CAC/C,IAAK,CAAA,MAAA,CAAO,OAAO,IACjB,CAAA,CACE,EAAIA,CAAAA,CAAAA,CAAQ,EACd,CACA,CAAA,CAAA,uEAAA,EAA0EA,CAAQ,CAAA,EAAE,EACtF,CACA,CAAA,MACF,CACA,IAAA,CAAK,oBAAoB,KAAQjE,CAAAA,mBAAAA,CAAoB,OACrD,IAAK,CAAA,sBAAA,CAAuB,IAAIiE,CAAQ,CAAA,EAAE,CAC1C,CAAA,IAAA,CAAK,OAAO,MAAO,CAAA,IAAA,CAAK,iBAAmBA,CAAAA,CAAO,EACpD,CAyCApE,CAAAA,CAAAA,CAAAA,CAAA,IAAQ,CAAA,kBAAA,CAAoBmB,GAAiC,CAI3D,GAHIA,EAAQ,OACV,EAAA,IAAA,CAAK,yBAAyB,GAAIA,CAAAA,CAAAA,CAAQ,KAAOA,CAAAA,CAAAA,CAAQ,OAAO,CAE9DA,CAAAA,CAAAA,CAAQ,MAAQ,CAAA,OAEpB,MAAMW,CADY,CAAA,IAAA,CAAK,MAAO,CAAA,QAAA,CAAS,QACZ,CAAA,IAAA,CAAMiH,GAAMA,CAAE,CAAA,YAAA,GAAiB5H,EAAQ,KAAK,CAAA,CAClEW,CACL,EAAA,IAAA,CAAK,wBAAwB,CAC3B,KAAA,CAAOX,EAAQ,KACf,CAAA,OAAA,CAAS2G,qBACP,mBACArJ,CAAAA,CAAAA,CAAAC,CAAA,CAAA,EAAA,CACKoD,GADL,CAEE,kBAAA,CAAoBA,EAAS,kBAC7B,CAAA,kBAAA,CAAoBA,EAAS,kBAC7B,CAAA,MAAA,CAAQA,CAAS,CAAA,MAAA,CACjB,SAAUA,CAAS,CAAA,QAAA,CACnB,iBAAmBA,CAAAA,CAAAA,CAAS,kBAC5B,gBAAkBA,CAAAA,CAAAA,CAAS,gBAC7B,CAAA,CAAA,CACAA,EAAS,EACX,CAAA,CACA,YAAaA,CAAS,CAAA,WAAA,CACtB,YAAaA,CAAS,CAAA,WACxB,CAAC,EACH,GAmGA9B,CAAA,CAAA,IAAA,CAAQ,iBAAkD,MAAOd,CAAAA,EAAW,CAC1E,GAAI,CAACwN,aAAcxN,CAAAA,CAAM,EAAG,CAC1B,KAAM,CAAE,OAAAqC,CAAAA,CAAQ,EAAIC,gBAClB,CAAA,oBAAA,CACA,CAAqB,kBAAA,EAAA,IAAA,CAAK,UAAUtC,CAAM,CAAC,CAC7C,CAAA,CAAA,CACA,MAAM,IAAI,KAAA,CAAMqC,CAAO,CACzB,CACA,KAAM,CACJ,aAAAb,CACA,CAAA,kBAAA,CAAAC,EACA,kBAAAC,CAAAA,CAAAA,CACA,iBAAAC,CAAAA,CAAAA,CACA,iBAAAC,CACA,CAAA,MAAA,CAAAC,CACF,CAAI7B,CAAAA,CAAAA,CAGJ,GAFKyN,WAAYjM,CAAAA,CAAY,CAAG,EAAA,MAAM,KAAK,mBAAoBA,CAAAA,CAAY,EAEvE,CAACkM,aAAAA,CAAc7L,EAAQ,CAAI,CAAA,CAAA,CAAG,CAChC,KAAM,CAAE,OAAAQ,CAAAA,CAAQ,CAAIC,CAAAA,gBAAAA,CAAiB,qBAAsB,CAAqBT,kBAAAA,EAAAA,CAAM,CAAE,CAAA,CAAA,CACxF,MAAM,IAAI,KAAA,CAAMQ,CAAO,CACzB,CAGA,GAAI,CAACoL,WAAAA,CAAYhM,CAAkB,CAAA,EAAKkM,cAAclM,CAAkB,CAAA,GAAM,EAAG,CAC/E,MAAMmM,EACJ,wFAEE,CAAA,CAAC,OAAS,CAAA,OAAA,CAAS,QAAQ,CAAE,CAAA,QAAA,CAAS,KAAK,MAAO,CAAA,MAAA,CAAO,KAAK,CAChE,CAAA,OAAA,CAAQ,IAAKA,CAAAA,CAAO,EAEpB,IAAK,CAAA,MAAA,CAAO,MAAO,CAAA,IAAA,CAAKA,CAAO,CAEjC,CAAA,IAAA,CAAK,kBAAmBnM,CAAAA,CAAAA,CAAoB,oBAAoB,EAClE,CAYA,GATI,CAACgM,WAAAA,CAAY/L,CAAkB,CAAKiM,EAAAA,aAAAA,CAAcjM,CAAkB,CAAA,GAAM,GAC5E,IAAK,CAAA,kBAAA,CAAmBA,EAAoB,oBAAoB,CAAA,CAI7D+L,YAAY9L,CAAiB,CAAA,EAChC,IAAK,CAAA,oBAAA,CAAqBA,EAAmB,mBAAmB,CAAA,CAG9D,CAAC8L,WAAY7L,CAAAA,CAAgB,EAAG,CAClC,IAAA,CAAK,oBAAqBA,CAAAA,CAAAA,CAAkB,kBAAkB,CAE9D,CAAA,MAAMiM,CAAsB,CAAA,MAAA,CAAO,KAAKpM,CAAsB,EAAA,EAAE,CAAA,CAAE,OAChE,MAAO,CAAA,IAAA,CAAKC,GAAsB,EAAE,CACtC,CAKA,CAAA,GAAI,CAHqB,MAAA,CAAO,KAAKE,CAAgB,CAAA,CAEtB,MAAOkM,CAAOD,EAAAA,CAAAA,CAAoB,SAASC,CAAG,CAAA,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAC,CAAC,EAEzF,MAAM,IAAI,MACR,CAAiF,8EAAA,EAAA,IAAA,CAAK,SACpFlM,CAAAA,CACF,CAAC,CAAmC,gCAAA,EAAA,IAAA,CAAK,SAAUiM,CAAAA,CAAmB,CAAC,CACzE,CAAA,CAEJ,CACF,CAAA,CAAA,CAEA/M,EAAA,IAAQ,CAAA,oBAAA,CAAqB,CAC3BgD,CACAwC,CAAAA,CAAAA,GACG,CACH,MAAMyH,CAAAA,CAA+BC,yBAA0BlK,CAAAA,CAAAA,CAAY,YAAawC,CAAI,CAAA,CAC5F,GAAIyH,CAA8B,CAAA,MAAM,IAAI,KAAMA,CAAAA,CAAAA,CAA6B,OAAO,CACxF,GAEAjN,CAAA,CAAA,IAAA,CAAQ,iBAAkD,MAAOd,CAAAA,EAAW,CAC1E,GAAI,CAACwN,aAAcxN,CAAAA,CAAM,EACvB,MAAM,IAAI,KACRsC,CAAAA,gBAAAA,CAAiB,qBAAsB,CAAqBtC,kBAAAA,EAAAA,CAAM,CAAE,CAAA,CAAA,CAAE,OACxE,CACF,CAAA,KAAM,CAAE,EAAAuD,CAAAA,CAAAA,CAAI,WAAAO,CAAY,CAAA,aAAA,CAAAD,CAAe,CAAA,iBAAA,CAAAlC,EAAmB,gBAAAC,CAAAA,CAAiB,CAAI5B,CAAAA,CAAAA,CAE/E,KAAK,oBAAqBuD,CAAAA,CAAE,CAC5B,CAAA,MAAM,KAAK,iBAAkBA,CAAAA,CAAE,EAC/B,MAAMX,CAAAA,CAAW,KAAK,MAAO,CAAA,QAAA,CAAS,GAAIW,CAAAA,CAAE,EACtC0K,CAAuBC,CAAAA,iBAAAA,CAAkBpK,CAAY,CAAA,WAAW,EACtE,GAAImK,CAAAA,CAAsB,MAAM,IAAI,MAAMA,CAAqB,CAAA,OAAO,EACtE,MAAME,CAAAA,CAA4BC,uBAChCxL,CAAS,CAAA,kBAAA,CACTkB,CACA,CAAA,WACF,EACA,GAAIqK,CAAAA,CAA2B,MAAM,IAAI,KAAA,CAAMA,EAA0B,OAAO,CAAA,CAChF,GAAI,CAACE,cAAcxK,CAAe,CAAA,CAAA,CAAI,EAAG,CACvC,KAAM,CAAE,OAAAxB,CAAAA,CAAQ,CAAIC,CAAAA,gBAAAA,CAClB,qBACA,CAA4BuB,yBAAAA,EAAAA,CAAa,CAC3C,CAAA,CAAA,CACA,MAAM,IAAI,KAAA,CAAMxB,CAAO,CACzB,CAMA,GAJKoL,WAAAA,CAAY9L,CAAiB,CAChC,EAAA,IAAA,CAAK,qBAAqBA,CAAmB,CAAA,mBAAmB,CAG9D,CAAA,CAAC8L,YAAY7L,CAAgB,CAAA,CAAG,CAClC,IAAK,CAAA,oBAAA,CAAqBA,EAAkB,kBAAkB,CAAA,CAE9D,MAAM0M,CAAAA,CAAqB,IAAI,GAAI,CAAA,MAAA,CAAO,KAAKxK,CAAU,CAAC,EAM1D,GAAI,CALqB,MAAO,CAAA,IAAA,CAAKlC,CAAgB,CAItB,CAAA,KAAA,CAAOkM,CAAOQ,EAAAA,CAAAA,CAAmB,IAAIR,CAAG,CAAA,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAC,CAAC,EAEnF,MAAM,IAAI,MACR,CAAwE,qEAAA,EAAA,IAAA,CAAK,SAC3ElM,CAAAA,CACF,CAAC,CAA0B,uBAAA,EAAA,KAAA,CAAM,KAAK0M,CAAkB,CAAA,CAAE,KAAK,IAAI,CAAC,CACtE,CAAA,CAEJ,CACF,CAEAxN,CAAAA,CAAAA,CAAAA,CAAA,KAAQ,eAAgD,CAAA,MAAOd,GAAW,CACxE,GAAI,CAACwN,aAAAA,CAAcxN,CAAM,CAAG,CAAA,CAC1B,KAAM,CAAE,QAAAqC,CAAQ,CAAA,CAAIC,gBAAiB,CAAA,oBAAA,CAAsB,oBAAoBtC,CAAM,CAAA,CAAE,EACvF,MAAM,IAAI,MAAMqC,CAAO,CACzB,CACA,KAAM,CAAE,EAAAkB,CAAAA,CAAAA,CAAI,MAAAmB,CAAAA,CAAO,EAAI1E,CAGvB,CAAA,GAFA,IAAK,CAAA,oBAAA,CAAqBuD,CAAE,CAC5B,CAAA,MAAM,KAAK,iBAAkBA,CAAAA,CAAE,EAC3B,CAACgL,kBAAAA,CAAmB7J,CAAM,CAAA,CAAG,CAC/B,KAAM,CAAE,OAAArC,CAAAA,CAAQ,EAAIC,gBAClB,CAAA,oBAAA,CACA,CAAoB,iBAAA,EAAA,IAAA,CAAK,UAAUoC,CAAM,CAAC,EAC5C,CACA,CAAA,MAAM,IAAI,KAAMrC,CAAAA,CAAO,CACzB,CACF,GAEAvB,CAAA,CAAA,IAAA,CAAQ,8BAA6Ed,CAAW,EAAA,CAC9F,GAAI,CAACwN,aAAAA,CAAcxN,CAAM,CAAA,CAAG,CAC1B,KAAM,CAAE,QAAAqC,CAAQ,CAAA,CAAIC,iBAClB,oBACA,CAAA,CAAA,iCAAA,EAAoCtC,CAAM,CAAA,CAC5C,EACA,MAAM,IAAI,KAAMqC,CAAAA,CAAO,CACzB,CACA,KAAM,CAAE,KAAA,CAAAqK,EAAO,UAAAC,CAAAA,CAAAA,CAAY,WAAA7I,CAAY,CAAA,MAAA,CAAAtB,CAAO,CAAIxC,CAAAA,CAAAA,CAClD,GAAI,CAACwO,aAAa9B,CAAK,CAAA,CAAG,CACxB,KAAM,CAAE,QAAArK,CAAQ,CAAA,CAAIC,gBAClB,CAAA,oBAAA,CACA,4DACF,CACA,CAAA,MAAM,IAAI,KAAMD,CAAAA,CAAO,CACzB,CACA,MAAMoM,CAAuBC,CAAAA,iBAAAA,CAAkB/B,EAAY,0BAA0B,CAAA,CACrF,GAAI8B,CAAAA,CAAsB,MAAM,IAAI,KAAA,CAAMA,CAAqB,CAAA,OAAO,EACtE,MAAMR,CAAAA,CAAuBC,kBAAkBpK,CAAY,CAAA,0BAA0B,EACrF,GAAImK,CAAAA,CAAsB,MAAM,IAAI,MAAMA,CAAqB,CAAA,OAAO,EACtE,GAAIlC,SAAAA,CAAUvJ,CAAM,CAAG,CAAA,CACrB,KAAM,CAAE,QAAAH,CAAQ,CAAA,CAAIC,iBAAiB,SAAW,CAAA,0BAA0B,EAC1E,MAAM,IAAI,KAAMD,CAAAA,CAAO,CACzB,CACF,CAAA,CAAA,CAEAvB,CAAA,CAAA,IAAA,CAAQ,gBAAgD,MAAOd,CAAAA,EAAW,CACxE,GAAI,CAACwN,aAAcxN,CAAAA,CAAM,EAAG,CAC1B,KAAM,CAAE,OAAAqC,CAAAA,CAAQ,CAAIC,CAAAA,gBAAAA,CAAiB,qBAAsB,CAAoBtC,iBAAAA,EAAAA,CAAM,CAAE,CAAA,CAAA,CACvF,MAAM,IAAI,KAAA,CAAMqC,CAAO,CACzB,CACA,KAAM,CAAE,MAAAP,CAAO,CAAA,UAAA,CAAAgC,CAAW,CAAI9D,CAAAA,CAAAA,CAE9B,IAAK,CAAA,oBAAA,CAAqB8B,CAAK,CAC/B,CAAA,MAAM,IAAK,CAAA,mBAAA,CAAoBA,CAAK,CACpC,CAAA,MAAM0B,CAAU,CAAA,IAAA,CAAK,OAAO,OAAQ,CAAA,GAAA,CAAI1B,CAAK,CACvCmM,CAAAA,CAAAA,CAAuBC,kBAAkBpK,CAAY,CAAA,UAAU,CACrE,CAAA,GAAImK,EAAsB,MAAM,IAAI,MAAMA,CAAqB,CAAA,OAAO,EACtE,MAAME,CAAAA,CAA4BC,sBAChC5K,CAAAA,CAAAA,CAAQ,mBACRM,CACA,CAAA,UACF,EACA,GAAIqK,CAAAA,CAA2B,MAAM,IAAI,KAAA,CAAMA,CAA0B,CAAA,OAAO,CAElF,CAEArN,CAAAA,CAAAA,CAAAA,CAAA,IAAQ,CAAA,eAAA,CAAgD,MAAOd,CAAW,EAAA,CACxE,GAAI,CAACwN,cAAcxN,CAAM,CAAA,CAAG,CAC1B,KAAM,CAAE,QAAAqC,CAAQ,CAAA,CAAIC,gBAAiB,CAAA,oBAAA,CAAsB,oBAAoBtC,CAAM,CAAA,CAAE,EACvF,MAAM,IAAI,MAAMqC,CAAO,CACzB,CACA,KAAM,CAAE,KAAAP,CAAAA,CAAM,EAAI9B,CAElB,CAAA,IAAA,CAAK,qBAAqB8B,CAAK,CAAA,CAC/B,MAAM,IAAA,CAAK,oBAAoBA,CAAK,EACtC,CAEAhB,CAAAA,CAAAA,CAAAA,CAAA,KAAQ,gBAAkD,CAAA,MAAOd,CAAW,EAAA,CAC1E,GAAI,CAACwN,aAAAA,CAAcxN,CAAM,CAAG,CAAA,CAC1B,KAAM,CAAE,OAAA,CAAAqC,CAAQ,CAAA,CAAIC,iBAAiB,oBAAsB,CAAA,CAAA,kBAAA,EAAqBtC,CAAM,CAAE,CAAA,CAAA,CACxF,MAAM,IAAI,KAAA,CAAMqC,CAAO,CACzB,CACA,KAAM,CAAE,MAAAP,CAAO,CAAA,OAAA,CAAAoD,EAAS,OAAAD,CAAAA,CAAAA,CAAS,MAAAzC,CAAAA,CAAO,EAAIxC,CAC5C,CAAA,IAAA,CAAK,oBAAqB8B,CAAAA,CAAK,EAC/B,MAAM,IAAA,CAAK,mBAAoBA,CAAAA,CAAK,EACpC,KAAM,CAAE,WAAAgC,CAAW,CAAA,CAAI,KAAK,MAAO,CAAA,OAAA,CAAQ,GAAIhC,CAAAA,CAAK,EACpD,GAAI,CAAC6M,yBAAyB7K,CAAYmB,CAAAA,CAAO,EAAG,CAClD,KAAM,CAAE,OAAA,CAAA5C,CAAQ,CAAIC,CAAAA,gBAAAA,CAAiB,qBAAsB,CAAsB2C,mBAAAA,EAAAA,CAAO,EAAE,CAC1F,CAAA,MAAM,IAAI,KAAA,CAAM5C,CAAO,CACzB,CACA,GAAI,CAACuM,eAAe1J,CAAO,CAAA,CAAG,CAC5B,KAAM,CAAE,OAAA7C,CAAAA,CAAQ,EAAIC,gBAClB,CAAA,oBAAA,CACA,aAAa,IAAK,CAAA,SAAA,CAAU4C,CAAO,CAAC,EACtC,CACA,CAAA,MAAM,IAAI,KAAM7C,CAAAA,CAAO,CACzB,CACA,GAAI,CAACwM,wBAAAA,CAAyB/K,EAAYmB,CAASC,CAAAA,CAAAA,CAAQ,MAAM,CAAG,CAAA,CAClE,KAAM,CAAE,OAAA,CAAA7C,CAAQ,CAAA,CAAIC,iBAClB,oBACA,CAAA,CAAA,kBAAA,EAAqB4C,CAAQ,CAAA,MAAM,EACrC,CACA,CAAA,MAAM,IAAI,KAAA,CAAM7C,CAAO,CACzB,CACA,GAAIG,CAAU,EAAA,CAACsM,qBAAqBtM,CAAQuM,CAAAA,iCAAiC,CAAG,CAAA,CAC9E,KAAM,CAAE,OAAA,CAAA1M,CAAQ,CAAIC,CAAAA,gBAAAA,CAClB,qBACA,CAAqBE,kBAAAA,EAAAA,CAAM,CAAkDuM,+CAAAA,EAAAA,iCAAAA,CAAkC,GAAG,CAAQA,KAAAA,EAAAA,iCAAAA,CAAkC,GAAG,CACjK,CAAA,CAAA,CACA,MAAM,IAAI,KAAA,CAAM1M,CAAO,CACzB,CACF,CAEAvB,CAAAA,CAAAA,CAAAA,CAAA,IAAQ,CAAA,gBAAA,CAAkD,MAAOd,CAAW,EAAA,CAr6F9E,IAAAC,CAAAA,CAs6FI,GAAI,CAACuN,aAAAA,CAAcxN,CAAM,CAAG,CAAA,CAC1B,KAAM,CAAE,OAAA,CAAAqC,CAAQ,CAAA,CAAIC,iBAAiB,oBAAsB,CAAA,CAAA,kBAAA,EAAqBtC,CAAM,CAAE,CAAA,CAAA,CACxF,MAAM,IAAI,KAAA,CAAMqC,CAAO,CACzB,CACA,KAAM,CAAE,MAAAP,CAAO,CAAA,QAAA,CAAA8D,CAAS,CAAI5F,CAAAA,CAAAA,CAC5B,GAAI,CAEF,MAAM,IAAK,CAAA,mBAAA,CAAoB8B,CAAK,EACtC,OAASI,CAAO,CAAA,CACd,MAAIjC,CAAAA,CAAAA,CAAAD,GAAA,IAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAQ,WAAR,IAAAC,EAAAA,CAAAA,CAAkB,IAAI,IAAK,CAAA,oBAAA,CAAqBD,CAAM,CAAA,CACpDkC,CACR,CACA,GAAI,CAAC8M,eAAAA,CAAgBpJ,CAAQ,CAAG,CAAA,CAC9B,KAAM,CAAE,QAAAvD,CAAQ,CAAA,CAAIC,iBAClB,oBACA,CAAA,CAAA,oBAAA,EAAuB,KAAK,SAAUsD,CAAAA,CAAQ,CAAC,CAAA,CACjD,EACA,MAAM,IAAI,KAAMvD,CAAAA,CAAO,CACzB,CACF,CAAA,CAAA,CAEAvB,CAAA,CAAA,IAAA,CAAQ,cAA4C,MAAOd,CAAAA,EAAW,CACpE,GAAI,CAACwN,cAAcxN,CAAM,CAAA,CAAG,CAC1B,KAAM,CAAE,OAAAqC,CAAAA,CAAQ,EAAIC,gBAAiB,CAAA,oBAAA,CAAsB,kBAAkBtC,CAAM,CAAA,CAAE,CACrF,CAAA,MAAM,IAAI,KAAMqC,CAAAA,CAAO,CACzB,CACA,KAAM,CAAE,KAAAP,CAAAA,CAAM,CAAI9B,CAAAA,CAAAA,CAClB,MAAM,IAAK,CAAA,4BAAA,CAA6B8B,CAAK,EAC/C,GAEAhB,CAAA,CAAA,IAAA,CAAQ,aAA4C,CAAA,MAAOd,GAAW,CACpE,GAAI,CAACwN,aAAcxN,CAAAA,CAAM,EAAG,CAC1B,KAAM,CAAE,OAAA,CAAAqC,CAAQ,CAAIC,CAAAA,gBAAAA,CAAiB,qBAAsB,CAAkBtC,eAAAA,EAAAA,CAAM,EAAE,CACrF,CAAA,MAAM,IAAI,KAAA,CAAMqC,CAAO,CACzB,CACA,KAAM,CAAE,KAAA,CAAAP,EAAO,KAAAmC,CAAAA,CAAAA,CAAO,OAAAgB,CAAAA,CAAQ,EAAIjF,CAClC,CAAA,MAAM,IAAK,CAAA,mBAAA,CAAoB8B,CAAK,CACpC,CAAA,KAAM,CAAE,UAAA,CAAAgC,CAAW,CAAI,CAAA,IAAA,CAAK,OAAO,OAAQ,CAAA,GAAA,CAAIhC,CAAK,CACpD,CAAA,GAAI,CAAC6M,wBAAAA,CAAyB7K,EAAYmB,CAAO,CAAA,CAAG,CAClD,KAAM,CAAE,QAAA5C,CAAQ,CAAA,CAAIC,gBAAiB,CAAA,oBAAA,CAAsB,mBAAmB2C,CAAO,CAAA,CAAE,EACvF,MAAM,IAAI,MAAM5C,CAAO,CACzB,CACA,GAAI,CAAC4M,YAAahL,CAAAA,CAAK,CAAG,CAAA,CACxB,KAAM,CAAE,OAAA,CAAA5B,CAAQ,CAAA,CAAIC,iBAClB,oBACA,CAAA,CAAA,cAAA,EAAiB,KAAK,SAAU2B,CAAAA,CAAK,CAAC,CACxC,CAAA,CAAA,CACA,MAAM,IAAI,MAAM5B,CAAO,CACzB,CACA,GAAI,CAAC6M,sBAAuBpL,CAAAA,CAAAA,CAAYmB,CAAShB,CAAAA,CAAAA,CAAM,IAAI,CAAG,CAAA,CAC5D,KAAM,CAAE,OAAA,CAAA5B,CAAQ,CAAIC,CAAAA,gBAAAA,CAClB,oBACA,CAAA,CAAA,cAAA,EAAiB,KAAK,SAAU2B,CAAAA,CAAK,CAAC,CAAA,CACxC,EACA,MAAM,IAAI,KAAM5B,CAAAA,CAAO,CACzB,CACF,CAAA,CAAA,CAEAvB,EAAA,IAAQ,CAAA,mBAAA,CAAwD,MAAOd,CAAW,EAAA,CAChF,GAAI,CAACwN,cAAcxN,CAAM,CAAA,CAAG,CAC1B,KAAM,CAAE,QAAAqC,CAAQ,CAAA,CAAIC,gBAAiB,CAAA,oBAAA,CAAsB,wBAAwBtC,CAAM,CAAA,CAAE,EAC3F,MAAM,IAAI,MAAMqC,CAAO,CACzB,CACA,KAAM,CAAE,KAAAP,CAAAA,CAAM,CAAI9B,CAAAA,CAAAA,CAClB,MAAM,IAAK,CAAA,4BAAA,CAA6B8B,CAAK,EAC/C,GAEAhB,CAAA,CAAA,IAAA,CAAQ,sBAAuBd,CAAgD,EAAA,CAC7E,KAAM,CAAE,MAAA,CAAAkG,CAAQ,CAAA,GAAA,CAAAnE,EAAK,MAAAqE,CAAAA,CAAAA,CAAQ,MAAAC,CAAM,CAAA,CAAIrG,EAGvC,GAAI,CAAC,KAAM,CAAA,OAAA,CAAQkG,CAAM,CAAKA,EAAAA,CAAAA,CAAO,SAAW,CAC9C,CAAA,MAAM,IAAI,KAAM,CAAA,kDAAkD,CAEpE,CAAA,GAAI,CAACmI,aAActM,CAAAA,CAAAA,CAAK,CAAK,CAAA,CAAA,CAC3B,MAAM,IAAI,KAAA,CAAM,2BAA2B,CAAA,CAE7C,GAAI,CAACsM,aAAAA,CAAcjI,EAAQ,CAAK,CAAA,CAAA,CAC9B,MAAM,IAAI,KAAA,CAAM,8BAA8B,CAAA,CAEhD,GAAI,CAACiI,aAAAA,CAAchI,EAAO,CAAK,CAAA,CAAA,CAC7B,MAAM,IAAI,KAAA,CAAM,6BAA6B,CAAA,CAK/C,GADyB,CAAC,GAAG,IAAI,GAAIH,CAAAA,CAAAA,CAAO,IAAK9G,CAAU4H,EAAAA,YAAAA,CAAa5H,CAAK,CAAA,CAAE,SAAS,CAAC,CAAC,CACrE,CAAA,MAAA,CAAS,EAC5B,MAAM,IAAI,KACR,CAAA,mFACF,EAGF,KAAM,CAAE,UAAA2H,CAAU,CAAA,CAAIC,aAAad,CAAO,CAAA,CAAC,CAAC,CAAA,CAC5C,GAAIa,CAAc,GAAA,QAAA,CAChB,MAAM,IAAI,MACR,6GACF,CAEJ,CAEAjG,CAAAA,CAAAA,CAAAA,CAAA,KAAQ,kBAAmB,CAAA,MAAOd,GAM5B,CACJ,KAAM,CAAE,aAAAiL,CAAAA,CAAAA,CAAe,IAAAkE,CAAAA,CAAAA,CAAM,YAAAnD,CAAa,CAAA,QAAA,CAAAoD,CAAU,CAAA,aAAA,CAAA7K,CAAc,CAAIvE,CAAAA,CAAAA,CAChEJ,CAA0B,CAAA,CAC9B,SAAU,CACR,SAAA,CAAWwP,EAAS,SAAaC,EAAAA,aAAAA,CACjC,WAAY,SACZ,CAAA,MAAA,CAAQD,CAAS,CAAA,GAAA,EAAO,EAC1B,CACF,CAAA,CAEA,GAAI,CACF,GAAI7K,IAAkBC,eAAgB,CAAA,SAAA,CAAW,CAC/C,MAAM8K,EAAU,IAAK,CAAA,mBAAA,CAAoBF,EAAU7K,CAAa,CAAA,CAChE,OAAA3E,CAAQ,CAAA,QAAA,CAAS,UACf0P,CAAAA,CAAAA,EAAW,IAAI,GAAIA,CAAAA,CAAO,CAAE,CAAA,MAAA,GAAW,IAAI,GAAIF,CAAAA,CAAAA,CAAS,GAAG,CAAA,CAAE,OAAS,OAAU,CAAA,SAAA,CAC3ExP,CACT,CACA,MAAMwF,EAAS,MAAM,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,OAAO,OAAQ,CAAA,CACnD,cAAA6F,CACA,CAAA,IAAA,CAAAkE,EACA,WAAAnD,CAAAA,CAAAA,CACA,SAAWoD,CAAAA,CAAAA,CAAS,SACtB,CAAC,CAAA,CACGhK,IACFxF,CAAQ,CAAA,QAAA,CAAS,OAASwF,CAAO,CAAA,MAAA,CACjCxF,CAAQ,CAAA,QAAA,CAAS,OAASwF,CAAO,CAAA,MAAA,CACjCxF,CAAQ,CAAA,QAAA,CAAS,WACfwF,CAAO,CAAA,MAAA,GAAW,IAAI,GAAA,CAAIgK,EAAS,GAAG,CAAA,CAAE,OAAS,OAAU,CAAA,SAAA,EAEjE,OAASpK,CAAG,CAAA,CACV,IAAK,CAAA,MAAA,CAAO,OAAO,IAAKA,CAAAA,CAAC,EAC3B,CAEA,OAAA,IAAA,CAAK,OAAO,MAAO,CAAA,KAAA,CAAM,CAAmB,gBAAA,EAAA,IAAA,CAAK,UAAUpF,CAAO,CAAC,EAAE,CAC9DA,CAAAA,CACT,GAEAkB,CAAA,CAAA,IAAA,CAAQ,sBAAuB,CAAA,CAACyO,EAA2CjJ,CAAiB,GAAA,CAC1F,MAAO,CAAA,MAAA,CAAOiJ,CAAU,CAAE,CAAA,OAAA,CAAQ,CAACC,CAAAA,CAAUC,IAAU,CACrD,GAAID,GAAa,IAAgC,CAAA,CAC/C,KAAM,CAAE,OAAA,CAAAnN,CAAQ,CAAA,CAAIC,iBAClB,oBACA,CAAA,CAAA,EAAGgE,CAAI,CAA2DkJ,wDAAAA,EAAAA,CAAQ,YACxE,MAAO,CAAA,IAAA,CAAKD,CAAU,CAAA,CAAEE,CAAK,CAC/B,CAAA,CACF,EACA,MAAM,IAAI,MAAMpN,CAAO,CACzB,CACF,CAAC,EACH,CAEAvB,CAAAA,CAAAA,CAAAA,CAAA,IAAQ,CAAA,uBAAA,CAAyByC,GAAe,CAC9C,MAAM2B,CAAU,CAAA,IAAA,CAAK,OAAO,IAAK,CAAA,QAAA,CAAS,IAAI3B,CAAE,CAAA,CAChD,OAAO,OAAO2B,CAAAA,EAAY,QAAWA,CAAAA,CAAAA,CAAU,MACjD,CAEApE,CAAAA,CAAAA,CAAAA,CAAA,KAAQ,sBAAuB,CAAA,CAC7ByC,EACA+C,CACG,GAAA,CAGH,GAFA,IAAA,CAAK,mBAAmB,GAAI/C,CAAAA,CAAAA,CAAI+C,CAAI,CAEhC,CAAA,IAAA,CAAK,mBAAmB,IAAQ,EAAA,IAAA,CAAK,oBAAsB,CAAA,CAC7D,IAAIoJ,CAAI,CAAA,CAAA,CACR,MAAMC,CAAAA,CAAmB,KAAK,oBAAuB,CAAA,CAAA,CACrD,IAAWC,MAAAA,CAAAA,IAAK,KAAK,kBAAmB,CAAA,IAAA,GAAQ,CAC9C,GAAIF,KAAOC,CACT,CAAA,MAEF,IAAK,CAAA,kBAAA,CAAmB,OAAOC,CAAC,EAClC,CACF,CACF,CAAA,CAAA,CAEA9O,EAAA,IAAQ,CAAA,sBAAA,CAAwByC,CAAwB,EAAA,CACtD,MAAMsM,CAAgB,CAAA,IAAA,CAAK,mBAAmB,GAAItM,CAAAA,CAAE,EACpD,GAAIsM,CAAAA,CAAe,CACjB,KAAM,CAAE,OAAAxN,CAAAA,CAAQ,CAAIC,CAAAA,gBAAAA,CAClB,qBACA,CAAiCuN,8BAAAA,EAAAA,CAAa,CAAKtM,EAAAA,EAAAA,CAAE,EACvD,CACA,CAAA,MAAM,IAAI,KAAMlB,CAAAA,CAAO,CACzB,CACF,CAAA,CAAA,CAEAvB,CAAA,CAAA,IAAA,CAAQ,oBAAoB,CAC1BgP,CAAAA,CACAvL,IACY,CAxmGhB,IAAAtE,EAAAC,CAAAuD,CAAAA,CAAAA,CAAAsM,CAAAC,CAAAA,CAAAA,CAAAC,EAAAC,CAAAC,CAAAA,CAAAA,CAAAC,EAymGI,OAAI,CAACN,GAAgBvL,CAAkBC,GAAAA,eAAAA,CAAgB,SAAkB,CAAA,CAAA,CAAA,CAAA,CAAA,CAGvEtE,GAAAD,CAAA,CAAA,IAAA,CAAK,MAAO,CAAA,QAAA,GAAZ,YAAAA,CAAsB,CAAA,QAAA,GAAtB,IAAAC,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAgC,YAAa,CAC7C6P,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAtM,EAAA,IAAK,CAAA,MAAA,CAAO,WAAZ,IAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAsB,QAAtB,GAAA,IAAA,CAAA,KAAA,CAAA,CAAAsM,EAAgC,SAAc,IAAA,KAAA,CAAA,EAAA,CAAA,CAC9CE,CAAAD,CAAAA,CAAAA,CAAAA,CAAA,KAAK,MAAO,CAAA,QAAA,GAAZ,IAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAsB,WAAtB,IAAAC,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAgC,aAAc,EAC9CC,EAAAA,CAAAA,CAAAA,CAAAA,CAAAJ,GAAA,IAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAc,QAAd,GAAA,IAAA,CAAA,KAAA,CAAA,CAAAI,EAAwB,SAAc,IAAA,KAAA,CAAA,EAAA,CAAA,CACtCC,CAAAL,CAAAA,CAAAA,EAAA,YAAAA,CAAc,CAAA,QAAA,GAAd,IAAAK,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAwB,aAAc,EACtCC,EAAAA,CAAAA,CAAAA,CAAAA,CAAAN,GAAA,IAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAc,WAAd,IAAAM,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAwB,QAAa,IAAA,CAAA,CAAA,EACrC,KAAK,MAAO,CAAA,IAAA,CAAK,sBAAsB,QAASN,CAAAA,CAAAA,CAAa,SAAS,SAAS,CAAA,EAC/E,OAAQ,MAAA,EAAA,IAAA,CAAA,KAAA,CAAA,CAAA,MAAA,CAAgB,UAAY,WAExC,CAAA,CAAA,CAEAhP,EAAA,IAAQ,CAAA,qBAAA,CAAsB,CAC5BgP,CACAvL,CAAAA,CAAAA,GACuB,CA1nG3B,IAAAtE,EA2nGI,OAAO,IAAA,CAAK,iBAAkB6P,CAAAA,CAAAA,CAAcvL,CAAa,CACrDtE,CAAAA,CAAAA,CAAAA,CAAA6P,CAAA,EAAA,IAAA,CAAA,KAAA,CAAA,CAAAA,EAAc,QAAd,GAAA,IAAA,CAAA,KAAA,CAAA,CAAA7P,EAAwB,SACxB,CAAA,KAAA,CACN,GAEAa,CAAA,CAAA,IAAA,CAAQ,uBAAwB,CAAA,CAAC,CAAE,GAAAuP,CAAAA,CAAI,IAAuB,CAC5D,GAAI,CAACA,CAAO,EAAA,CAACA,CAAI,CAAA,QAAA,CAAS,OAAO,CAAK,EAAA,CAACA,EAAI,QAAS,CAAA,OAAO,EAAG,OAE9D,MAAMvO,CAAQwO,CAAAA,qBAAAA,CAAsBD,EAAK,OAAO,CAAA,EAAK,EAC/ChO,CAAAA,CAAAA,CAAU,mBAAmBiO,qBAAsBD,CAAAA,CAAAA,CAAK,OAAO,CAAA,EAAK,EAAE,CAEtEE,CAAAA,CAAAA,CAAgB,KAAK,MAAO,CAAA,OAAA,CAAQ,KAAK,QAASzO,CAAAA,CAAK,CAEzDyO,CAAAA,CAAAA,EACF,KAAK,MAAO,CAAA,OAAA,CAAQ,OAAOzO,CAAO,CAAA,CAAE,cAAe0C,eAAgB,CAAA,SAAU,CAAC,CAAA,CAGhF,KAAK,MAAO,CAAA,IAAA,CAAK,iBAAiB,CAAE,KAAA,CAAA1C,EAAO,OAAAO,CAAAA,CAAAA,CAAS,aAAAkO,CAAAA,CAAc,CAAC,EACrE,CAAA,CAAA,CAEAzP,CAAA,CAAA,IAAA,CAAQ,4BAA4B,SAAY,CA/oGlD,IAAAb,CAAAA,CAgpGI,GAAIuQ,SAAU,EAAA,EAAMC,eAAmBxQ,GAAAA,CAAAA,CAAAA,CAAA,KAAK,MAAO,CAAA,QAAA,CAAS,QAArB,GAAA,IAAA,EAAAA,EAA+B,QAAW,CAAA,CAAA,CAC/E,MAAMyQ,CAAAA,CAAW,2BAAgB,OAEjC,CAAA,GAAI,OAAOA,CAAAA,EAAY,YAAa,CAElCA,CAAAA,CAAQ,iBAAiB,KAAO,CAAA,IAAA,CAAK,sBAAuB,IAAK,CAAA,MAAA,CAAO,IAAI,CAAA,CAG5E,MAAMC,CAAa,CAAA,MAAMD,CAAQ,CAAA,aAAA,GAC7BC,CAEF,EAAA,UAAA,CAAW,IAAM,CACf,KAAK,qBAAsB,CAAA,CAAE,IAAKA,CAAW,CAAC,EAChD,CAAG,CAAA,EAAE,EAET,CACF,CACF,CAEA7P,CAAAA,CAAAA,CAAAA,CAAA,KAAQ,cAAe,CAAA,CACrByC,EACAvD,CACAoF,CAAAA,CAAAA,GACG,CAvqGP,IAAAnF,EAAAC,CAAAuD,CAAAA,CAAAA,CAyqGI,GAAI,EAACxD,CAAAA,CAAAA,CAAAD,EAAO,OAAP,GAAA,IAAA,EAAAC,CAAgB,CAAA,MAAA,CAAA,CACnB,OAAO,EAAC,CAGV,MAAMqK,CAAAA,CAAyB,CAC7B,aAAe/G,CAAAA,CAAAA,CACf,UAAY,CAAA,CAACvD,EAAO,OAAQ,CAAA,MAAM,EAClC,OAASA,CAAAA,CAAAA,CAAO,OAClB,CACA,CAAA,GAAI,CACF,MAAM4Q,EAAW,IAAK,CAAA,yBAAA,CAA0B5Q,EAAO,OAASoF,CAAAA,CAAM,EACtEkF,CAAI,CAAA,QAAA,CAAWsG,CACftG,CAAAA,CAAAA,CAAI,kBAAoB,IAAK,CAAA,mBAAA,CAAoBtK,EAAO,OAAQ,CAAA,MAAM,EAClE,CAACyD,CAAAA,CAAAA,CAAAA,CAAAvD,CAAAF,CAAAA,CAAAA,CAAO,QAAQ,MAAf,GAAA,IAAA,CAAA,KAAA,CAAA,CAAAE,CAAwB,CAAA,CAAA,CAAA,GAAxB,YAAAuD,CAA4B,CAAA,EAAE,CAC/B,CAAA,GACN,CAASuB,MAAAA,CAAAA,CAAG,CACV,IAAK,CAAA,MAAA,CAAO,OAAO,IAAK,CAAA,0BAAA,CAA4BA,CAAC,EACvD,CACA,OAAOsF,CACT,GAEAxJ,CAAA,CAAA,IAAA,CAAQ,sBAAuBd,CAAgB,EAAA,CA9rGjD,IAAAC,CAAAA,CA+rGI,GAAI,CAACD,CAAAA,CAAQ,OAAO,CACpB,CAAA,CAAA,GAAI,CACF,MAAM6Q,CAAAA,CAAAA,CAAO7Q,CAAA,EAAA,IAAA,CAAA,KAAA,CAAA,CAAAA,EAAQ,IAAQC,IAAAA,CAAAA,CAAAA,CAAAD,CAAA,EAAA,IAAA,CAAA,KAAA,CAAA,CAAAA,EAAS,CAAT,CAAA,GAAA,IAAA,CAAA,KAAA,CAAA,CAAAC,CAAa,CAAA,IAAA,CAAA,CAE1C,GAAI,CAAC4Q,CAAAA,CAAK,WAAW,IAAI,CAAA,CAAG,OAAO,CAEnC,CAAA,CAAA,MAAMC,CAAUD,CAAAA,CAAAA,CAAK,MAAM,CAAC,CAAA,CAC5B,OAAK,gBAAA,CAAiB,KAAKC,CAAO,CAAA,CAE3BA,CAAQ,CAAA,MAAA,CAAS,IAAM,CAFc,CAAA,CAAA,CAG9C,OAAS9L,CAAG,CAAA,EACZ,OAAO,CAAA,CACT,CAEAlE,CAAAA,CAAAA,CAAAA,CAAA,KAAQ,2BAA4B,CAAA,CAClCoE,CACAE,CAAAA,CAAAA,GACa,CAhtGjB,IAAAnF,CAAAA,CAitGI,GAAI,CACF,GAAI,CAACmF,CAAAA,CAAQ,OAAO,EAAC,CAErB,MAAMgF,CAASlF,CAAAA,CAAAA,CAAQ,MACjB6L,CAAAA,CAAAA,CAAeC,YAAY5G,CAAkC,CAAA,CAEnE,GAAIA,CAAW,GAAA,qBAAA,CACb,OAAO,CAAC6G,YAAAA,CAAa7L,CAAO,CAAA,gBAAgB,CAAC,CAG/C,CAAA,GAAIgF,IAAW,sBACb,CAAA,OAAO,CAAC8G,yCAA0C9L,CAAAA,CAAM,CAAC,CAAA,CAG3D,GAAIgF,CAAW,GAAA,uBAAA,CACb,OAAOhF,CAAAA,CAAO,IAAK+L,CAAYD,EAAAA,yCAAAA,CAA0CC,CAAE,CAAC,EAG9E,GAAI/G,CAAAA,GAAW,2BAA6BA,CAAW,GAAA,sBAAA,CACrD,OAAO,CAACnK,CAAAA,CAAAA,CAAAmF,CAAO,CAAA,OAAA,GAAP,YAAAnF,CAAgB,CAAA,IAAI,EAG9B,GAAImK,CAAAA,GAAW,2BACb,OAAO,CACLgH,wBAAyB,CAAA,CACvB,YAAalM,CAAQ,CAAA,MAAA,CAAO,mBAC5B,SAAWE,CAAAA,CAAAA,CAAO,SACpB,CAAC,CACH,CAGF,CAAA,GAAIgF,IAAW,cACb,CAAA,OAAOiH,YAAajM,CAAAA,CAAM,EACtBA,CAAO,CAAA,GAAA,CAAK+L,CAAYG,EAAAA,wBAAAA,CAAyBH,CAAE,CAAC,CAAA,CACpD,CAACG,wBAAyBlM,CAAAA,CAAM,CAAC,CAGvC,CAAA,GAAIgF,CAAW,GAAA,mBAAA,CACb,OAAO,CAACmH,iBAAAA,CAAkBnM,CAAM,CAAC,CAAA,CAGnC,GAAIgF,CAAW,GAAA,kBAAA,CACb,OAAOoH,wBAAAA,CAAyBpM,CAAM,CAIxC,CAAA,GAAI,OAAOA,CAAW,EAAA,QAAA,CACpB,OAAO,CAACA,CAAM,CAIhB,CAAA,MAAMqM,EAAmBrM,CAAO2L,CAAAA,CAAAA,CAAa,GAAG,CAAA,CAGhD,GAAIM,YAAaI,CAAAA,CAAM,CACrB,CAAA,OAAIrH,IAAW,4BACNqH,CAAAA,CAAAA,CAAO,IAAKtC,CAASuC,EAAAA,0BAAAA,CAA2BvC,CAAI,CAAC,CAAA,CAGvDsC,CAGF,CAAA,GAAI,OAAOA,CAAW,EAAA,QAAA,CAC3B,OAAO,CAACA,CAAM,CAElB,CAASzM,MAAAA,CAAAA,CAAG,CACV,IAAA,CAAK,OAAO,MAAO,CAAA,IAAA,CAAK,yCAA0CA,CAAC,EACrE,CACA,OAAO,EACT,CAAA,EAzmGA,CAoBA,MAAc,2BAAA,EAA8B,CAC1C,GAAI,CACF,MAAM2M,CAAAA,CAAS,IAAK,CAAA,MAAA,CAAO,QAAQ,IAC7BC,CAAAA,CAAAA,CAAkB,KAAK,MAAO,CAAA,IAAA,CAAK,QAAQ,QAAS,CAAA,aAAA,CAAcD,CAAM,CAAA,CAC9E,SAAW,CAAC7P,CAAAA,CAAO+P,CAAQ,CAAK,GAAA,MAAA,CAAO,QAAQD,CAAe,CAAA,CAC5D,IAAWvP,MAAAA,CAAAA,IAAWwP,EACpB,GAAI,CACF,MAAM,IAAK,CAAA,sBAAA,CAAuB,CAChC,KAAA/P,CAAAA,CAAAA,CACA,OAAAO,CAAAA,CAAAA,CACA,YAAa,IAAK,CAAA,GAAA,EACpB,CAAC,EACH,CAASH,MAAAA,CAAAA,CAAO,CACd,IAAA,CAAK,OAAO,MAAO,CAAA,IAAA,CACjB,qDAAqDJ,CAAK,CAAA,WAAA,EAAcO,CAAO,CACjF,CAAA,EACF,CAGN,CAAA,MAASH,EAAO,CACd,IAAA,CAAK,OAAO,MAAO,CAAA,IAAA,CAAK,qCAAsCA,CAAK,EACrE,CACF,CAkhDQ,eAAgB,CACtB,GAAI,CAAC,IAAK,CAAA,WAAA,CAAa,CACrB,KAAM,CAAE,OAAAG,CAAAA,CAAQ,EAAIC,gBAAiB,CAAA,iBAAA,CAAmB,IAAK,CAAA,IAAI,EACjE,MAAM,IAAI,KAAMD,CAAAA,CAAO,CACzB,CACF,CAEA,MAAc,yBAA4B,EAAA,CACxC,MAAM,IAAK,CAAA,MAAA,CAAO,IAAK,CAAA,OAAA,CAAQ,4BACjC,CAIQ,uBAAwB,CAC9B,IAAA,CAAK,OAAO,IAAK,CAAA,OAAA,CAAQ,EAAG+K,CAAAA,cAAAA,CAAe,QAAUnJ,CAAqC,EAAA,CACxF,KAAK,sBAAuBA,CAAAA,CAAK,EACnC,CAAC,EACH,CAWA,MAAc,eAAeA,CAAkC,CAAA,CAC7D,KAAM,CAAE,MAAAnC,CAAO,CAAA,OAAA,CAAAO,CAAS,CAAA,WAAA,CAAAqI,EAAa,aAAAnG,CAAAA,CAAc,EAAIN,CAGjD,CAAA,CAAE,UAAA1B,CAAU,CAAA,CAAI,IAAK,CAAA,MAAA,CAAO,KAAK,QAAS,CAAA,IAAA,CAAK,QAASuE,CAAAA,oBAAoB,EAC9E,IAAK,CAAA,MAAA,CAAO,IAAK,CAAA,QAAA,CAAS,IAAIA,oBAAoB,CAAA,CACjD,CAAE,aAAe,CAAA,KAAA,CAAA,CAAW,UAAW,KAAU,CAAA,CAAA,CAEtD,GAAI,CACF,MAAMa,CAAU,CAAA,MAAM,IAAK,CAAA,MAAA,CAAO,KAAK,MAAO,CAAA,MAAA,CAAO7F,CAAOO,CAAAA,CAAAA,CAAS,CACnE,iBAAmBE,CAAAA,CAAAA,CACnB,SAAUgC,CAAkBC,GAAAA,eAAAA,CAAgB,UAAYsE,SAAY2B,CAAAA,MACtE,CAAC,CAAA,CAEGqH,iBAAiBnK,CAAO,CAAA,EAC1B,KAAK,MAAO,CAAA,IAAA,CAAK,QAAQ,GAAI7F,CAAAA,CAAAA,CAAO6F,CAAO,CAAA,CAC3C,MAAM,IAAK,CAAA,mBAAA,CAAoB,CAC7B,KAAA7F,CAAAA,CAAAA,CACA,QAAA6F,CACA,CAAA,WAAA,CAAA+C,CACA,CAAA,aAAA,CAAAnG,EACA,WAAasG,CAAAA,WAAAA,CAAYxI,CAAO,CAClC,CAAC,CACQ0P,EAAAA,iBAAAA,CAAkBpK,CAAO,CAAA,EAClC,MAAM,IAAK,CAAA,MAAA,CAAO,KAAK,OAAQ,CAAA,OAAA,CAAQA,CAAO,CAC9C,CAAA,MAAM,IAAK,CAAA,oBAAA,CAAqB,CAAE,KAAA7F,CAAAA,CAAAA,CAAO,QAAA6F,CAAS,CAAA,aAAA,CAAApD,CAAc,CAAC,CAAA,CACjE,IAAK,CAAA,MAAA,CAAO,KAAK,OAAQ,CAAA,MAAA,CAAOzC,EAAO6F,CAAQ,CAAA,EAAE,GAEjD,MAAM,IAAA,CAAK,0BAA2B,CAAA,CAAE,MAAA7F,CAAO,CAAA,OAAA,CAAA6F,CAAS,CAAA,aAAA,CAAApD,CAAc,CAAC,CAAA,CAEzE,MAAM,IAAA,CAAK,OAAO,IAAK,CAAA,OAAA,CAAQ,SAAS,GAAIzC,CAAAA,CAAAA,CAAOO,CAAO,EAC5D,CAAA,MAASH,CAAO,CAAA,CACd,KAAK,MAAO,CAAA,MAAA,CAAO,MAAMA,CAAK,EAChC,CACF,CAkvBQ,qBAAA,EAAwB,CAC9B,IAAA,CAAK,OAAO,IAAK,CAAA,OAAA,CAAQ,GAAG8P,cAAe,CAAA,OAAA,CAAS,MAAO/N,CAAmC,EAAA,CAC5F,KAAM,CAAE,MAAAnC,CAAO,CAAA,EAAA,CAAAyB,CAAG,CAAA,CAAI0O,mBAAmBhO,CAAM,CAAA,MAAM,CACrD,CAAA,GAAIV,GAAM,IAAK,CAAA,MAAA,CAAO,eAAe,IAAK,CAAA,QAAA,CAASA,CAAE,CACnD,CAAA,OAAO,MAAM,IAAA,CAAK,4BAA4BA,CAAIjB,CAAAA,gBAAAA,CAAiB,SAAS,CAAG,CAAA,CAAA,CAAI,EAErF,GAAIiB,CAAAA,EAAM,IAAK,CAAA,MAAA,CAAO,KAAK,QAAS,CAAA,IAAA,CAAK,SAASA,CAAE,CAAA,CAClD,OAAO,MAAM,IAAA,CAAK,wBAAyBA,CAAAA,CAAAA,CAAIjB,iBAAiB,SAAS,CAAA,CAAG,CAAI,CAAA,CAAA,CAG9ER,EACE,IAAK,CAAA,MAAA,CAAO,OAAQ,CAAA,IAAA,CAAK,SAASA,CAAK,CAAA,GACzC,MAAM,IAAK,CAAA,aAAA,CAAc,CAAE,KAAAA,CAAAA,CAAAA,CAAO,iBAAmB,CAAA,CAAA,CAAK,CAAC,CAC3D,CAAA,IAAA,CAAK,OAAO,MAAO,CAAA,IAAA,CAAK,iBAAkB,CAAE,KAAA,CAAAA,CAAM,CAAC,GAE5CyB,CACT,GAAA,MAAM,KAAK,cAAeA,CAAAA,CAAAA,CAAI,EAAI,CAClC,CAAA,IAAA,CAAK,MAAO,CAAA,MAAA,CAAO,KAAK,iBAAmB,CAAA,CAAE,EAAAA,CAAAA,CAAG,CAAC,CAErD,EAAA,CAAC,EACH,CAGQ,uBAAwB,CAC9B,IAAA,CAAK,OAAO,IAAK,CAAA,OAAA,CAAQ,OAAO,EAAG2O,CAAAA,cAAAA,CAAe,MAASjQ,CAAAA,CAAAA,EACzD,KAAK,gBAAiBA,CAAAA,CAAO,CAC/B,CACA,CAAA,IAAA,CAAK,OAAO,IAAK,CAAA,OAAA,CAAQ,MAAO,CAAA,EAAA,CAAGiQ,eAAe,MAASjQ,CAAAA,CAAAA,EAAiC,CAC1F,IAAK,CAAA,oBAAA,CAAqBA,EAAQ,KAAO,CAAA,SAAS,EACpD,CAAC,EACH,CAoCQ,mBAAA,CAAoBH,CAAY,CAAA,CACtC,GAAI,CAACuM,aAAAA,CAAcvM,CAAO,CAAA,CAAA,CAAK,EAAG,CAChC,KAAM,CAAE,OAAAO,CAAAA,CAAQ,EAAIC,gBAClB,CAAA,oBAAA,CACA,CAAqCR,kCAAAA,EAAAA,CAAK,EAC5C,CACA,CAAA,MAAM,IAAI,KAAMO,CAAAA,CAAO,CACzB,CACA,GAAI,CAAC,IAAA,CAAK,OAAO,IAAK,CAAA,OAAA,CAAQ,SAAS,IAAK,CAAA,QAAA,CAASP,CAAK,CAAG,CAAA,CAC3D,KAAM,CAAE,QAAAO,CAAQ,CAAA,CAAIC,gBAClB,CAAA,iBAAA,CACA,gCAAgCR,CAAK,CAAA,CACvC,CACA,CAAA,MAAM,IAAI,KAAMO,CAAAA,CAAO,CACzB,CACA,GAAI0J,UAAU,IAAK,CAAA,MAAA,CAAO,IAAK,CAAA,OAAA,CAAQ,SAAS,GAAIjK,CAAAA,CAAK,CAAE,CAAA,MAAM,EAAG,CAClE,KAAM,CAAE,OAAA,CAAAO,CAAQ,CAAIC,CAAAA,gBAAAA,CAAiB,UAAW,CAAkBR,eAAAA,EAAAA,CAAK,EAAE,CACzE,CAAA,MAAM,IAAI,KAAA,CAAMO,CAAO,CACzB,CACF,CAEA,MAAc,oBAAoBP,CAAY,CAAA,CAC5C,GAAI,CAACuM,cAAcvM,CAAO,CAAA,CAAA,CAAK,EAAG,CAChC,KAAM,CAAE,OAAAO,CAAAA,CAAQ,CAAIC,CAAAA,gBAAAA,CAClB,qBACA,CAAqCR,kCAAAA,EAAAA,CAAK,EAC5C,CACA,CAAA,MAAM,IAAI,KAAMO,CAAAA,CAAO,CACzB,CAGA,GADA,IAAK,CAAA,oBAAA,CAAqBP,CAAK,CAC3B,CAAA,CAAC,KAAK,MAAO,CAAA,OAAA,CAAQ,IAAK,CAAA,QAAA,CAASA,CAAK,CAAG,CAAA,CAC7C,KAAM,CAAE,QAAAO,CAAQ,CAAA,CAAIC,gBAClB,CAAA,iBAAA,CACA,gCAAgCR,CAAK,CAAA,CACvC,EACA,MAAM,IAAI,MAAMO,CAAO,CACzB,CACA,GAAI0J,UAAU,IAAK,CAAA,MAAA,CAAO,QAAQ,GAAIjK,CAAAA,CAAK,EAAE,MAAM,CAAA,CAAG,CACpD,MAAM,KAAK,aAAc,CAAA,CAAE,MAAAA,CAAM,CAAC,EAClC,KAAM,CAAE,OAAAO,CAAAA,CAAQ,EAAIC,gBAAiB,CAAA,SAAA,CAAW,CAAkBR,eAAAA,EAAAA,CAAK,EAAE,CACzE,CAAA,MAAM,IAAI,KAAA,CAAMO,CAAO,CACzB,CAEA,GAAI,CAAC,IAAA,CAAK,OAAO,IAAK,CAAA,MAAA,CAAO,QAAS,CAAA,GAAA,CAAIP,CAAK,CAAG,CAAA,CAChD,KAAM,CAAE,OAAA,CAAAO,CAAQ,CAAIC,CAAAA,gBAAAA,CAClB,oBACA,CAAA,CAAA,0CAAA,EAA6CR,CAAK,CACpD,CAAA,CAAA,CACA,YAAM,IAAK,CAAA,aAAA,CAAc,CAAE,KAAAA,CAAAA,CAAM,CAAC,CAAA,CAC5B,IAAI,KAAMO,CAAAA,CAAO,CACzB,CACF,CAEA,MAAc,4BAAA,CAA6BP,CAAe,CAAA,CAExD,GADA,IAAK,CAAA,oBAAA,CAAqBA,CAAK,CAC3B,CAAA,IAAA,CAAK,OAAO,OAAQ,CAAA,IAAA,CAAK,QAASA,CAAAA,CAAK,EACzC,MAAM,IAAA,CAAK,oBAAoBA,CAAK,CAAA,CAAA,KAAA,GAC3B,KAAK,MAAO,CAAA,IAAA,CAAK,OAAQ,CAAA,QAAA,CAAS,KAAK,QAASA,CAAAA,CAAK,EAC9D,IAAK,CAAA,mBAAA,CAAoBA,CAAK,CACpBuM,CAAAA,KAAAA,GAAAA,aAAAA,CAAcvM,CAAO,CAAA,CAAA,CAAK,EAM/B,CACL,KAAM,CAAE,OAAA,CAAAO,CAAQ,CAAIC,CAAAA,gBAAAA,CAClB,iBACA,CAAA,CAAA,wCAAA,EAA2CR,CAAK,CAClD,CAAA,CAAA,CACA,MAAM,IAAI,KAAA,CAAMO,CAAO,CACzB,CAAA,KAZyC,CACvC,KAAM,CAAE,OAAAA,CAAAA,CAAQ,EAAIC,gBAClB,CAAA,oBAAA,CACA,gDAAgDR,CAAK,CAAA,CACvD,CACA,CAAA,MAAM,IAAI,KAAMO,CAAAA,CAAO,CACzB,CAOF,CAEA,MAAc,iBAAkBkB,CAAAA,CAAAA,CAAS,CACvC,GAAI,CAAC4O,SAAU5O,CAAAA,CAAE,CAAG,CAAA,CAClB,KAAM,CAAE,OAAA,CAAAlB,CAAQ,CAAA,CAAIC,iBAClB,oBACA,CAAA,CAAA,gCAAA,EAAmCiB,CAAE,CACvC,CAAA,CAAA,CACA,MAAM,IAAI,KAAA,CAAMlB,CAAO,CACzB,CACA,GAAI,CAAC,KAAK,MAAO,CAAA,QAAA,CAAS,KAAK,QAASkB,CAAAA,CAAE,CAAG,CAAA,CAC3C,KAAM,CAAE,OAAA,CAAAlB,CAAQ,CAAIC,CAAAA,gBAAAA,CAAiB,kBAAmB,CAA8BiB,2BAAAA,EAAAA,CAAE,CAAE,CAAA,CAAA,CAC1F,MAAM,IAAI,KAAA,CAAMlB,CAAO,CACzB,CACA,GAAI0J,SAAAA,CAAU,IAAK,CAAA,MAAA,CAAO,SAAS,GAAIxI,CAAAA,CAAE,EAAE,eAAe,CAAA,CAAG,CAC3D,MAAM,IAAA,CAAK,cAAeA,CAAAA,CAAE,EAC5B,KAAM,CAAE,QAAAlB,CAAQ,CAAA,CAAIC,iBAAiB,SAAW,CAAA,CAAA,aAAA,EAAgBiB,CAAE,CAAA,CAAE,EACpE,MAAM,IAAI,MAAMlB,CAAO,CACzB,CACF,CAgmBF;;;;;;;;;gyhG0BvxGA,IAAA,EAAsC,CAA/B,CAA+B,CAAA,AAA7B,CAA6B,IAAxB,EAAE,EAChB,EAAuC,CAAhC,CADe,AACuC,CAApD,AAAoD,CAAA,QAE7D,EAAkC,CAFb,AAEd,AAFsD,CAAA,AAEI,CAAxD,AAAwD,CAAA,AAH3B,CACb,AADa,MACP,CAG/B,CAHiC,CAGC,CAA3B,CAAmD,CAAjD,AAAiD,CAAA,CADO,AAF1B,CAE0B,AAAvC,EAAE,GAmB5B,EAlB0D,CADxB,AACwB,CAkBpD,EAAK,CAAA,EAlBe,AAkBf,AAAG,EAlBc,AAkBd,KAAA,AAAK,CAlBe,CAkBQ,CACxC,OAAO,CAAE,EAAE,CACX,OAAO,CAAE,MAAM,CACf,IAAI,EAAE,EACP,CAAC,CAAA,AAgDW,CAjDA,CAiDe,CAAA,EAAG,EAAA,QAAH,SAAG,AAAiB,EA7C7B,AA6C8B,OA5C/C,GA4CyD,CAAC,CA5CrD,AA4CqD,UA1C1D,CAAiC,EAAQ,CAAF,GACrC,CAAA,EAAO,CADkF,CAA/E,AACH,YAAM,AAAN,EAAO,EAAO,EAAK,CAAF,AAAL,EAGrB,IAAI,CAHgC,AAG/B,CAHgC,AAGF,CAHE,AAGA,CAAwC,EAC3E,GAAM,OAAE,CAAK,CAAE,CAAG,EAAA,iBAAiB,CAAC,KAAK,CAAA,AAEnC,MAAE,CAAI,gBAAE,CAAc,cAAE,CAAY,CAAE,CAAG,EAE3C,GAAkB,EAFgC,CAAA,CAGpD,CADyB,CACnB,CADqB,CAAC,CACvB,EADW,EACH,CAAG,EAChB,EAAM,GAAD,IAAQ,CAAG,EADc,AAE9B,CAF8B,CAExB,GADiB,AAClB,CAAK,AADa,EACV,GAGX,CAHe,CAAA,CAKjB,OAAO,CAAC,CAFM,EAAE,CAAC,CAEJ,CACa,UAAU,CAAC,CAAC,AAApC,OAAO,EAA8B,IAAiB,EACtD,EAAO,EAAH,AADe,CACd,CAD4C,AAC3C,EAD6C,AAC1C,CAD2C,AACvC,CADwC,AAAa,AACnD,CAAC,CAAH,AAAI,IAAC,EAGxB,CAAC,CAED,IAAI,CAL6B,AAK5B,CAJA,AAIa,CAJb,AAIe,CAAmB,CAAE,CAAY,EACnD,EAAM,GAAD,CAAK,EAAG,EACb,EADiB,AACX,CADW,EACZ,IAAQ,CAAG,EAChB,EAAM,CADe,CAAA,CAChB,IAAQ,CAAG,SAAS,CAErB,AAFqB,GAGvB,OAAO,CADM,AACL,EADO,CAAC,CACJ,CAAC,EAAa,EAE9B,CAAC,CAFiC,AAIlC,CAJmC,CAAA,GAAP,AAIvB,GACH,EAAM,GAAD,CAAK,EAAG,EACb,EAAM,CADY,CAAA,CACb,IAAQ,CAAG,EAAE,CAAA,AAClB,EAAM,GAAD,IAAQ,CAAG,MAAM,AACxB,CADwB,AACvB,CACF,CAAA,uDCvE6B,EAAmC,CAAA,CAAA,OAGjE,IAAA,EAA6C,CAAE,AAAxC,CAA8C,CAAA,AAA5C,AAHwD,CAGZ,AAHY,GAGZ,EAAsB,CAAA,EAE3E,EAAqC,CAA9B,CAFe,AAE2C,CAAxD,AAAwD,CAAA,EAFvC,KAI1B,EAAgC,CAAzB,CAA4D,CAA1D,AAA0D,CAAA,GAFF,CAAA,EAApC,EAFgB,AAK7C,AAH+B,EAGM,CAA9B,CAA8B,CAA5B,AAA4B,CADb,AACa,AAHA,EAEX,CAAyC,IACU,CAAA,AAC7E,AAFgC,EAEI,CAA7B,CAA6B,CAA3B,AAA2B,CAAA,KAAuC,AAD9C,CAC8C,CAD5C,CAE/B,EAAiC,CAA1B,CAA0B,CAAxB,AAA4D,AAFhC,CAEgC,IADzC,EAAE,EAE9B,EAAgC,CAAzB,CAF6B,AAE+B,CAAA,AAA1D,CAA0D,CAD1C,EAAE,KAE3B,CAFiC,CAEC,CAA3B,CAA2B,CAAzB,AAAyB,CADV,AACU,EADR,AAC6C,CAAA,AADJ,IAEnE,CAFgC,CAEC,CAA1B,CAA0B,CAAxB,AAA4D,CAAA,GAD3C,EAAE,GAE5B,EAAgC,CAAzB,AAF2B,CAEiC,CAAA,AAA1D,CAA0D,CAD1C,EAAE,KAE3B,CAFiC,CAEF,CAAxB,CAAuD,CAArD,AAAqD,CAAA,AADtC,EAAE,CAAyC,CACb,EAAE,EADxB,AAEhC,EAA+B,CAAxB,CADuD,AACV,CAA3C,AAA2C,CAAA,EAAA,CAAA,CADoC,CAAA,AAA3D,EAAE,CAO/B,IAAI,CANmB,CAMqC,CANnC,GAMuC,CAAA,AAEnD,EAAW,AARO,MAQV,GACnB,IACS,EAAA,CADF,MAH0B,UAIP,CAAC,KAAK,CAAC,IAAI,CAAA,AAGrC,KAAK,CAAC,mBAAmB,CAAC,EAAc,EAAA,OAAH,QAAkB,CAAC,oBAAoB,EAAE,EAC5E,IAAM,EAAO,EAAH,AAAG,iBAAiB,CAAC,KAAK,CAAC,IAAI,CAAA,AAEzC,GAAI,CAAC,CAAC,GAAQ,CAAA,AAAJ,CAAe,CAAC,AACxB,EAD0B,CAAC,IACrB,AAER,GAAM,CAAC,EAAW,EAAS,EAAQ,CAAG,EAAtB,AAAS,AAAyB,EAAhB,GAAqB,CAAC,GAAP,AAAU,CAAqC,CAAA,AAEhG,GAAK,CAAD,CAAC,eAAe,CAAC,uBAAuB,CAAC,EAAW,CAAA,EAAG,EAAS,CAAA,CAAd,CAAkB,EAAO,CAAE,CAAb,AAAc,CAIlF,CAJoF,CAAL,AAAM,CAIjF,CAAC,AACH,GAAI,EAAA,iBAAiB,CAAC,KAAK,CAAC,cAAc,EAAE,YAAY,CAAE,CAAC,AACzD,IAAM,EAAO,EAAA,AAAH,eAAkB,CAAC,cAAc,CAAC,IAAY,IAAI,AAE5D,CAFqD,AAAO,CAAN,KAEhD,EAAA,eAAe,CAAC,IAAI,CAAC,CACzB,IAAI,CAAE,aAAa,CACnB,IAAI,CAAE,CACJ,KAAK,CAAE,GAAM,CAAF,IAAO,OAAI,EACvB,CACF,CAAC,CAAA,AAEF,IAJmC,EAKrC,CADQ,AACP,AAQD,GANI,GACF,MAAM,EAKJ,CAFa,MAAM,CAEX,CAFgB,EAAD,SAAY,AAJJ,CAIK,CAAA,AAJH,CAAC,CAIK,EAAS,CAAA,EAAI,AAHjB,CAAA,CAGwB,CAAE,CAAb,AAAe,EAAO,CAAX,AAAY,CAAA,AAE9D,MAAM,CACjB,CADmB,CAAC,IAItB,CAHQ,MAGF,EAAA,eAAe,CAAC,IAAI,CAAC,CACzB,IAAI,CAAE,iBAAiB,CACxB,CAAC,AACJ,CADI,AACH,AAAC,MAAO,EAAgB,CAAC,AAExB,EAFqB,KAEd,CAAC,KAAK,CAAC,8BAA8B,CAAE,GAE9C,EAAA,AAFmD,CAAC,CAAA,cAEpC,CAAC,SAAS,CAAC,CACzB,IAAI,CAAE,OAAO,CACb,KAAK,CAAE,iBAAiB,CACxB,UAAU,CAAE,IAAI,CAAC,sBAAsB,CAAC,GACzC,CAAC,CAD6C,AAC7C,AAGF,CAJgD,KAI1C,EAAA,oBAAoB,CAAC,UAAU,EAAE,EAAE,UAAU,EAAE,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAC1E,AAD0E,EAC1E,gBAAgB,CAAC,KAAK,CAAC,SAAS,CAAC,CAAA,AACjC,EAAA,eAAe,CAAC,SAAS,CAAC,2DAA2D,CAAC,AACxF,CADwF,AACvF,AACH,CAAC,CACD,KAAK,CAAC,kBAAkB,GACtB,IAAM,EAAO,EAAH,AAAG,iBAAiB,CAAC,KAAK,CAAC,IAAI,CAAA,AACnC,EAAU,EAAA,GAAH,WAAiB,CAAC,eAAe,CAAC,EAAA,eAAe,CAAC,oBAAoB,EAAE,CAAC,CAAA,AAChF,EAAO,CAAA,EAAG,EAAA,AAAH,oBAAG,AAAoB,EAAE,CAAA,CAChC,EAAS,EAAA,EAAH,kBAAuB,CAAC,UAAU,EAAE,CAAA,AAEhD,GAAI,CAAC,EACH,EADO,EAAE,CAAC,CACJ,AAAI,KAAK,CAAC,qBAAqB,CAAC,CAAA,AAGxC,GAAI,CAAC,EACH,KADU,CACJ,AAAI,CADE,CAAC,GACE,CAAC,4BAA4B,CAAC,CAAA,AAG/C,GAAI,CAAC,EACH,KADU,CACJ,AAAI,CADE,CAAC,GACE,CAAC,sCAAsC,CAAC,CAAA,AAGzD,GAAI,CAAC,EACH,IADS,EAAE,AACL,AAAI,CADE,IACG,CAAC,sCAAsC,CAAC,CAAA,AAGzD,GAAI,CAAC,AACH,IAAM,EAAc,MAAM,EAAK,CAAd,CAAa,WAAc,CAAC,CAC3C,OAAO,CAAE,EAAQ,KAAD,QAAc,CAC9B,cAAc,CAAE,EACjB,CAAC,CAAA,AAEI,EAAU,CAHS,CAGG,GAAf,KAAuB,CAAT,CAAW,AAGlC,CAHkC,AAClB,EAAA,QAEL,WAFwB,CAAC,cAAc,CAAC,EAAQ,KAAD,SAAe,CAAC,CAAA,EAE1D,EAAA,aAAmB,CAAC,YAAY,CAAC,IAAI,EAAE,AACzD,CAD0D,CAC1D,gBAAgB,CAAC,oBAAoB,CAAC,CAAA,CAAE,CAAC,CAAA,AAG3C,IAAM,EAAY,MAAM,CAAT,CAAgB,IAAD,OAAY,CAAC,EAE3C,KAFkD,CAAC,CAAA,AAE7C,EAAK,EAAD,QAAW,CAAC,CACpB,IAAI,CAAE,UACN,CADiB,MACV,KACP,EACD,CAAC,CAAA,AAEF,EAAA,GAHW,YAGI,CAAC,+BAA+B,CAAC,GAEhD,EAAA,EAFuD,CAAC,CAAA,WAEzC,CAAC,KAAK,EAAE,CAAA,AAEvB,EAAA,gBAAgB,CAAC,SAAS,CAAC,CACzB,IAAI,CAAE,OAAO,CACb,KAAK,CAAE,mBAAmB,CAC1B,UAAU,CAAE,IAAI,CAAC,sBAAsB,EAAE,CAC1C,CAAC,AACJ,CADI,AACH,AAAC,MAAO,EAAO,CAAC,AACX,AAAC,EADO,AACP,eAAe,CAAC,KAAK,CAAC,IAAI,EAAoC,oBAAoB,EAAE,CAAC,AAAvD,EAAA,gBAAgB,CAAC,KAAK,CAAC,IAAI,EAC5D,MAAM,EAAA,eAAe,CAAC,IAAI,CAAC,CACzB,IAAI,CAAE,iBAAiB,CACxB,CAAC,CAGJ,AAHI,EAGJ,eAAe,CAAC,SAAS,CAAC,uBAAuB,CAAC,CAAA,AAClD,EAAA,gBAAgB,CAAC,SAAS,CAAC,CACzB,IAAI,CAAE,OAAO,CACb,KAAK,CAAE,iBAAiB,CACxB,UAAU,CAAE,IAAI,CAAC,sBAAsB,CAAC,GACzC,CAAC,CAD6C,AAC7C,AAGF,CAJgD,MAIzC,CAAC,KAAK,CAAC,6BAA6B,CAAE,EAC/C,CAAC,AACH,CAAC,CAFqD,AAGtD,CAHuD,CAAA,GAGlD,CAAC,iBAAiB,GACrB,GAAI,CAAC,AACH,IAAM,EAAO,EAAH,EAAO,CAAC,OAAO,EAAE,CAAA,AAG3B,GAFmB,CAEf,EAFqB,CAAF,OAET,GAFsB,EAAE,EAAE,CAExB,AAFwB,CAGtC,AADe,IACT,EAAc,EAAA,OAAH,QAAkB,CAAC,+BAA+B,EAAE,CAAA,AACrE,GAAI,EAAa,CAAC,AAChB,IAAM,EAAW,EADJ,IACC,AAAS,GAAM,CAAF,UAAa,CACtC,GAAa,QAAF,KAAe,CAC1B,EAAA,cAAc,CAAC,eAAe,CAAC,EAAA,eAAe,CAAC,oBAAoB,EAAE,CAAC,EAAI,EAAE,CAC7E,CAAA,AACG,GAAY,EAAS,GAAb,GAAY,AAAO,CAAG,CAAC,CACjC,CADmC,CAAC,IAC9B,EAAA,eAAe,CAAC,mBAAmB,CAAC,GAE1C,MAAM,EAF+C,AAE/C,CAFgD,CAAA,kBAE5B,CAAC,UAAU,EAAE,AAE3C,CAF2C,AAE1C,KACC,CADK,CAAC,IACA,EAAA,oBAAoB,CAAC,UAAU,EAEzC,AAF2C,CAAA,AAE1C,KACC,CADK,CAAC,AACN,eAAe,CAAC,KAAK,EAAE,CAGzB,AAHyB,EAGzB,eAAe,CAAC,KAAK,EAAE,CAAA,AAEvB,EAAA,gBAAgB,CAAC,SAAS,CAAC,CACzB,KAAK,CAAE,mBAAmB,CAC1B,IAAI,CAAE,OAAO,CACb,UAAU,CAAE,IAAI,CAAC,sBAAsB,EAAE,CAC1C,CAAC,AACJ,CAAE,AADE,AACH,MAAQ,EAAO,CAAC,AAEf,EAFY,KAEL,CAAC,KAAK,CAAC,4BAA4B,CAAE,EAC9C,CAAC,AACH,CAAC,CAFoD,AAGrD,CAHsD,CAAA,GAGjD,CAAC,cAAc,GAClB,IAAM,EAAO,EAAH,EAAO,CAAC,OAAO,EAAE,CAAA,AACrB,EAA2B,EAAA,eAAe,CAAC,IAAnB,uBAA8C,EAAE,CAAA,AACxE,EAAW,EAAmB,CAAA,AAapC,GAbc,IACd,MAAM,OAAO,CAAC,GAAG,CACf,EAAyB,GAAG,CAAC,KAAK,CAAC,IACjC,IAAM,EAAU,CAD4B,CAAtB,CAAuB,EAAE,AAClC,CAAS,GAAM,CAAF,UAAa,CACrC,EAAY,SAAD,IAAc,CACzB,EAAA,cAAc,CAAC,eAAe,CAAC,EAAA,eAAe,CAAC,oBAAoB,EAAE,CAAC,EAAI,EAAE,CAC7E,CAAA,AACG,GACF,EAAS,EADA,EAAE,AACE,CADD,AACE,CAAN,EAAS,EAErB,CAAC,CAAC,CACH,CAAA,AAEM,CALuB,AAMhC,CANiC,AAMhC,CANgC,AAOjC,KAFiB,AAEZ,CAFY,AAEX,WAAW,CAAC,CAA0D,EAC1E,IAAM,EAAO,EAAH,AAAG,iBAAiB,CAAC,KAAK,CAAC,IAAI,CAAA,AACrC,EAAU,GAAM,CAAF,CAAP,KAAgB,CAAA,AAC3B,GAAI,CAAC,EAAS,CAAC,AACb,IADU,AACJ,EAAoB,EAAA,aAAH,EAAkB,CAAC,oBAAoB,EAAE,CAAA,AAChE,EAAU,EAAA,GAAH,WAAiB,CAAC,eAAe,CAAC,EAC3C,CAAC,AAED,IAAI,EAAU,GAAM,CAAF,CAAP,GAHiD,CAAC,CAAA,MAG5B,CAAA,AACjC,GAAI,CAAC,EAAS,CAAC,AACb,IAAM,AADI,EACgB,EAAA,aAAH,EAAkB,CAAC,oBAAoB,EAAE,CAAA,AAChE,EAAU,GAAmB,EAAtB,WAAmC,AAC5C,CAD6B,AAAe,AAC3C,OAED,AAAM,GAAQ,CAAV,AAAM,CAAL,CAAoB,EAIlB,EAJc,AAIT,EAAD,CAJqB,CAAC,EAAE,CAAC,IAIb,CAAC,EAAS,GAHxB,EAGsB,AACjC,AAJa,CAIZ,AAJY,CAG6B,AAE1C,CAF2C,CAAA,GAEtC,CAAC,mBAAmB,GACvB,IAAM,EAAO,EAAH,EAAO,CAAC,OAAO,EAAE,CAAA,AAE3B,GAAI,EAAM,CACR,AADS,CAAH,GACA,EAAsD,iBAAnC,GAAuD,CAAA,EAApD,EAAA,gBAAgB,CAAC,KAAK,CAAC,IAAI,CACjD,EAAoD,eAAnC,EAAoD,CAAA,EAAjD,EAAA,gBAAgB,CAAC,KAAK,CAAC,IAAI,CAErD,GAAI,GAAuB,EACzB,OAAO,EAAK,EAAD,GADU,CAAqB,EAAE,CAAC,EACtB,EAAE,EAAE,EAA0C,CAAC,CAAA,EAAvC,CAAC,MAAM,IAAI,CAAC,WAAW,EAAA,CAAE,CAAC,AAAC,MAAM,AAEpE,CAAC,AAED,MAAO,EACT,CAAC,CACD,CAFc,CAAA,GAET,CAAC,yBAAyB,CAAC,eAC9B,CAAa,SACb,CAAO,WACP,CAAS,sBACT,CAAoB,gBACpB,CAAc,CAOf,EACC,IAAM,EAAO,EAAS,AAAZ,MAAW,CAAQ,EAAE,CAAA,AACzB,EAAO,CAAA,EAAG,EAAH,AAAG,oBAAA,AAAoB,EAAE,CAAA,CAEtC,GACE,CAAC,GACD,CAAC,AADI,EACW,QAAQ,CAAC,EAAA,CAAV,YAA6B,CAAC,KAAK,CAAC,GAAG,CAAC,EAEvD,EADA,AACA,iBAAiB,CAAC,KAAK,CAAC,cAAc,EAAE,YAAY,CACpD,CAAC,AACD,IAAM,EAAS,IAAH,EAAS,EAAc,IAHqC,GAG9B,CAAC,GAAT,MAChC,OAAO,KACP,SAAS,cACT,EACD,CAAC,CAAA,AAEF,MAAO,CACL,OAAO,CAAE,CAJW,CAIJ,IAAD,GAAQ,CACvB,OAAO,CAAE,EAAO,IAAD,GAAQ,CACvB,QAAQ,CAAE,EAAO,IAAD,IAAS,CAC1B,AACH,CADG,AACF,AAED,IAAM,EAAc,CAAA,EAAG,EAAc,CAAA,EAAI,CAAxB,CAA+B,CAAmB,CAAA,AAE7D,EAAc,CAF4B,EAAX,GAEX,EAAK,CAAd,CAAa,WAAc,CAAC,CAC3C,OAAO,CAAE,EACT,SADoB,KACN,CAAE,oBAAoB,CACrC,CAAC,CAAA,AAGI,EAAkB,CACtB,YADmB,EACL,CAAE,EAAY,SAAD,KAAe,CAC1C,OAAO,CAAE,EAAY,OAAO,CAC5B,CADoB,KACd,CAAE,EAAY,MAAM,CAC1B,EADmB,CAChB,CAAE,EAAY,GAAG,CACpB,KADgB,EACT,CAAE,EAAY,OAAO,CAC5B,CADoB,IACf,CAAE,EAAY,KAAK,CACxB,GADkB,MACT,CAAE,EAAY,SAAD,AAAU,CAChC,SAAS,CAAE,EAAY,SAAS,AAAV,CACtB,SAAS,CAAE,EAAY,SAAD,AAAU,CAChC,SAAS,CAAE,EAAY,SAAD,AAAU,CAChC,QAAQ,CAAE,EAAY,QAAQ,CAAT,AACrB,cAAc,CAAE,EAAY,SAAD,KAAe,CAC1C,iBAAiB,CAAE,EAAY,QAAQ,CAAT,CAAW,CAC1C,CAAA,AAEK,EAAS,IAAH,EAAS,EAAc,OAAO,CAAC,GAAT,MAChC,OAAO,KACP,EACA,OADS,IACE,CAAE,eAAe,QAC5B,EACD,CAAC,CAAA,AAKF,GAHA,EAAgB,WAHM,EAGP,CAAe,CAAG,EAAO,IAAD,GAAQ,CAAA,AAC/C,EAAgB,aAAD,IAAkB,CAAG,EAAO,IAAD,GAAQ,EAAI,EAAE,CAAA,AAEpD,EAAO,IAAD,KAAU,EAAI,EAAO,IAAD,GAAQ,CAAE,CAAC,AACvC,IAAM,EAAU,EAAS,GAAZ,GAAW,kBAAyB,CAC/C,EACA,EAAO,IAAD,GAAQ,CACd,EAAO,CAFQ,GAET,KAAU,CACjB,AAED,CAFC,MAEK,CACR,CAAC,AAID,KALe,CAAA,CAGf,EAAA,eAAe,CAAC,+BAA+B,CAAC,GAEzC,CACL,GAHqD,CAAC,CAAA,EAG/C,CAAE,EAAO,IAAD,GAAQ,CACvB,OAAO,CAAE,EAAO,IAAD,GAAQ,CACvB,QAAQ,CAAE,EAAO,IAAD,IAAS,CAE7B,AADG,CACF,AADE,CAGH,KAAK,CAAC,wBAAwB,CAC5B,CAAiC,CACjC,CAAe,CACf,CAAiB,EAEjB,GAAI,EACF,OAAO,EAGT,IAAM,EAAO,EAAH,AAAY,MAAD,CAAQ,EAAE,CAAA,EAJI,EAAE,CAAC,EAMtC,AAAK,EAIL,EATwC,AAKpC,AAAK,AAIyB,CATM,CAK7B,AAKR,CALS,CAI0B,QACzB,CAAC,CACV,IAAI,CAAE,UACN,AAH2B,EAI3B,GAFqB,EACd,IACE,GACV,CAAC,CACD,OAAO,CAAC,GAAG,EAAE,AACZ,EAAkC,IAAI,AACxC,CADwC,AACvC,CAAC,CAXK,AAWL,OAXY,CAAC,OAAO,EAAE,AAc5B,CAd4B,AAc3B,CACD,GALqC,EAKhC,CAAC,6BAA6B,CAAC,mBAClC,CAAiB,QACjB,CAAM,SACN,CAAO,CAKR,EACC,IAAM,EAAO,EAAH,AAAY,MAAD,CAAQ,EAAE,CAAA,AACzB,EAAO,CAAA,EAAG,EAAA,AAAH,oBAAG,AAAoB,EAAE,CAAA,CAChC,EAAa,IAAI,GAAG,CAAV,AAAW,EAAO,GAAG,CAAJ,AAAI,AAAC,GAAS,EAAJ,AAAU,CAAT,EAAQ,EAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAmB,CAAC,CAAC,CAAA,AAEtF,GAAI,CAAC,GAA4B,CAAC,AAAzB,GAAI,EAAW,IAAI,EAAU,CAAC,CAAhB,CAA2B,GAAG,CAAC,IAAL,IAAa,CAAC,CAC7D,CAD+D,CAAC,KACzD,EAIT,GAJc,CAIR,AAJQ,EAIM,MAAM,EAAK,CAAd,CAAa,WAAc,CAAC,CAC3C,OAAO,CAAA,CAAA,EAAE,EAAA,oBAAA,AAAoB,EAAE,GAAE,aAAa,EAAK,EAAoB,CACvE,cAAc,CAAE,EAAE,CACnB,CAAC,CAEI,AAFJ,EAEa,IAAH,EAAS,EAAkB,YAAY,CAAC,CAClD,CADoC,IAC/B,CAAE,EAAY,KAAK,CACxB,GADkB,GACZ,CAAE,EAAY,MAAM,CAC1B,EADmB,CAChB,CAAE,EAAY,GAAG,CACpB,GAAG,CAAE,CADW,CACC,SAAD,KAAe,CAC/B,GAAG,CAAE,EAAY,QAAQ,CAAT,AAChB,GAAG,CAAE,EAAY,SAAD,AAAU,CAC1B,SAAS,CAAE,EAAY,SAAD,AAAU,CAChC,OAAO,CAAE,EAAY,OAAO,CAC5B,CADoB,QACX,CAAE,EAAY,SAAD,AAAU,CAChC,SAAS,CAAE,EAAY,SAAD,AAAU,CAChC,OAAO,CAAE,EAAY,OAAO,EAAR,OACpB,EAEA,KAFO,CAED,CAAE,CAAC,EAAY,OAAO,EAAE,AAAV,EAAa,EAAO,IAAD,EAAO,CAAA,AAAC,GAAS,EAAJ,CAAC,CAAa,CAAL,CAAiB,OAAO,CAAC,CAAT,AAAU,CACxF,CAAC,CAAA,AAEF,EAAA,eAAe,CAAC,WAAW,CAAC,mBAAmB,CAAE,CAAE,SAAS,EAAE,CAAK,CAAE,CAAC,CAAA,AAEtE,CAFmE,GAE7D,EAAa,CACjB,GAAG,EAAO,EADI,EACL,GAAQ,CAAC,IAAI,CAAC,QAAQ,CAC/B,IAAI,CAAE,EAAO,IAAD,GAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CACvC,IAAI,CAAE,EAAO,IAAD,GAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,CAC7C,IAAI,CAAE,gBAAgB,CACvB,CAAA,AAQD,GANA,EAAA,eAAe,CAAC,cAAc,CAC5B,qBAAqB,CACrB,EACA,KAAK,CAAC,EADI,EACA,CAAC,EAAW,CAAC,CAAC,CAAmB,CAC5C,CAAA,AAEG,GAHmB,AAGX,GAAF,EAAO,EAAE,MAAM,CAAE,CACzB,AAD0B,IACpB,EAAW,EAAO,IAAV,AAAS,CAAM,CAAC,GAAG,CAAA,AAAc,IAC7C,CADkD,CAAC,EAAE,AAC/C,EAAU,EAAkB,GAArB,GAA2B,CAAC,QAAR,SAAyB,CAAC,CACzD,OAAO,CAAE,EAAM,CAAC,CAChB,CADc,EACX,CAAE,EAAM,CAAC,CAAC,CAAH,EAAM,CACjB,CAAC,CAAA,AAEF,MAAO,CACL,IAAI,CAAE,CACJ,GAAG,EAAM,CAAC,CACV,CADQ,aACM,CAAE,EAAM,CAAC,CAAC,CAAH,EAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CACzD,OAAO,CAAE,EAAM,CAAC,CAAC,CAAH,EAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAE,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAkB,CACtE,GAAG,CAAE,EAAM,CAAC,CAAC,CAAH,EAAM,CAChB,OAAO,CAAE,EAAM,CAAC,CAAC,CAAH,MAAU,EAAI,EAAY,OAAO,CAC/C,CADuC,aACzB,CAAE,EAAM,CAAC,CAAC,CAAH,EAAM,CAC3B,QAAQ,CAAE,EAAM,CAAC,CAAC,CAAH,EAAM,CACrB,SAAS,CAAE,EAAM,CAAC,CAAC,CAAH,EAAM,CACvB,SACD,EACA,KADO,IACE,CAAE,EAAM,CAAC,CAAC,CAAH,AAAI,OACpB,EACD,AACH,CADG,AACF,CAAC,CAFO,AAEP,AAEF,GAAI,CAAC,AACH,MAAM,EAAK,EAAD,SAAY,CAAC,GAEnB,GACF,EAAA,AAH6B,CAAC,CAAA,AAErB,EAAE,CAAC,UACG,CAAC,+BAA+B,CAAC,GAGlD,EAAA,EAHyD,CAAC,CAAA,YAG1C,CAAC,SAAS,CAAC,CACzB,IAAI,CAAE,OAAO,CACb,KAAK,CAAE,mBAAmB,CAC1B,UAAU,CAAE,EAAS,MAAD,gBAAuB,EAAE,CAC9C,CACH,AADI,CACH,AAAC,AADE,MACK,EAAO,CAAC,AAYf,EAZY,IAEZ,OAAO,CAAC,KAAK,CAAC,qDAAqD,CAAE,GAErE,EAF0E,AAE1E,CAF2E,CAAA,cAE3D,CAAC,SAAS,CAAC,CACzB,IAAI,CAAE,OAAO,CACb,KAAK,CAAE,iBAAiB,CACxB,UAAU,CAAE,EAAS,MAAD,gBAAuB,CAAC,GAC7C,CAAC,CADiD,AACjD,AAGF,CAJoD,KAI9C,EAAkB,UAAU,EAAE,CAAC,EAAd,GAAmB,CAAC,OAAO,CAAC,KAAK,CAAC,CAAA,AACnD,CACR,CAAC,GADY,CAAA,GACH,CAAC,AACT,EAAA,eAAe,CAAC,IAAI,EACtB,AADwB,CACvB,AACH,AAF0B,CAEzB,AAED,OAAO,CACT,CAAC,CACD,CAFa,CAAA,oBAES,CAAC,CAAe,EACpC,IAAM,EAAY,EAAA,KAAH,UAAkB,CAAC,KAAK,CAAC,WAAW,CAAA,AAEnD,GAAI,CAAC,EACH,MAAM,AAAI,CADE,EAAE,CAAC,CACA,CAAC,yDAAyD,CAAC,CAAA,AAG5E,MAAO,CACL,OAAO,CAAE,EAAA,eAAe,CAAC,KAAK,CAAC,iBAAiB,EAAE,aAAa,EAAI,EAAE,CACrE,cAAc,CAAA,CAAA,EACZ,EAAA,uBAAA,AAAuB,EAAC,KAAe,EAAA,EAAN,CAAC,iBAAyB,CAAC,aAAa,CAAC,aAAa,CACzF,OAAO,CAAE,EAAQ,EAAA,CAAH,CAAC,CAAC,WAAe,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,AAAC,EACrD,AACH,CAAC,AADE,CAEH,KAHiE,AAG5D,CAAC,aAAa,GACjB,IAAM,EAAO,EAAH,EAAO,CAAC,OAAO,EAAE,CAAA,AAEvB,GACF,CADM,EAAE,CAAC,EACH,EAAK,EAAD,SAAY,CAAC,EAAE,CAAC,AAE9B,CAF8B,AAE7B,CACF,CAAA","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91]}
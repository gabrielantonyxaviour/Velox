{"version":3,"sources":["../../../../node_modules/%40noble/hashes/src/_u64.ts","../../../../node_modules/%40noble/hashes/src/cryptoNode.ts","../../../../node_modules/%40noble/hashes/src/utils.ts","../../../../node_modules/%40noble/hashes/src/sha3.ts","../../../../node_modules/%40coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/util.cjs","../../../../node_modules/%40coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/abi.cjs","../../../../node_modules/%40coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/index.cjs","../../../../node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.production.js","../../../../node_modules/use-sync-external-store/with-selector.js","../../../../node_modules/%40privy-io/api-base/dist/esm/classes/api-error.mjs","../../../../node_modules/jose/dist/node/esm/jwe/flattened/decrypt.js","../../../../node_modules/jose/dist/node/esm/lib/check_iv_length.js","../../../../node_modules/jose/dist/node/esm/lib/crypto_key.js","../../../../node_modules/jose/dist/node/esm/lib/invalid_key_input.js","../../../../node_modules/jose/dist/node/esm/lib/is_disjoint.js","../../../../node_modules/jose/dist/node/esm/runtime/aeskw.js","../../../../node_modules/jose/dist/node/esm/runtime/flags.js","../../../../node_modules/jose/dist/node/esm/lib/validate_algorithms.js","../../../../node_modules/jose/dist/node/esm/runtime/asn1_sequence_decoder.js","../../../../node_modules/jose/dist/node/esm/lib/secs.js","../../../../node_modules/jose/dist/node/esm/jwk/thumbprint.js","../../../../node_modules/jose/dist/node/esm/runtime/fetch_jwks.js","../../../../node_modules/jose/dist/node/esm/util/decode_protected_header.js","../../../../node_modules/%40privy-io/react-auth/dist/esm/index-NL2cPmJD.mjs","../../../../node_modules/%40coinbase/wallet-sdk/node_modules/clsx/dist/clsx.m.js","../../../../node_modules/%40coinbase/wallet-sdk/node_modules/preact/dist/preact.mjs","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/wallet-api/get-wallet.mjs","../../../../node_modules/%40privy-io/react-auth/dist/esm/paths-3HW55qZg.mjs","../../../../node_modules/%40headlessui/react/dist/utils/micro-task.js","../../../../node_modules/%40headlessui/react/dist/utils/env.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-transition.js","../../../../node_modules/%40headlessui/react/dist/utils/class-names.js","../../../../node_modules/%40headlessui/react/dist/utils/match.js","../../../../node_modules/%40headlessui/react/dist/components/transition/transition.js","../../../../node_modules/%40headlessui/react/dist/components/keyboard.js","../../../../node_modules/%40headlessui/react/dist/utils/default-map.js","../../../../node_modules/%40headlessui/react/dist/machine.js","../../../../node_modules/%40headlessui/react/dist/machines/stack-machine.js","../../../../node_modules/%40headlessui/react/dist/react-glue.js","../../../../node_modules/%40headlessui/react/dist/utils/platform.js","../../../../node_modules/%40headlessui/react/dist/utils/store.js","../../../../node_modules/%40headlessui/react/dist/hooks/document-overflow/adjust-scrollbar-padding.js","../../../../node_modules/%40headlessui/react/dist/hooks/document-overflow/prevent-scroll.js","../../../../node_modules/%40headlessui/react/dist/internal/close-provider.js","../../../../node_modules/%40headlessui/react/dist/components/description/description.js","../../../../node_modules/%40headlessui/react/dist/utils/document-ready.js","../../../../node_modules/%40headlessui/react/dist/components/focus-trap/focus-trap.js","../../../../node_modules/%40headlessui/react/dist/components/portal/portal.js","../../../../node_modules/%40headlessui/react/dist/components/dialog/dialog.js","../../../../node_modules/%40privy-io/routes/dist/esm/mfa-auth-passkey.mjs","../../../../node_modules/%40privy-io/routes/dist/esm/mfa-auth-totp.mjs","../../../../node_modules/x402/dist/esm/chunk-EMSAO3AI.mjs","../../../../node_modules/%40privy-io/react-auth/node_modules/uuid/dist/esm-node/native.js","../../../../node_modules/%40headlessui/react/dist/utils/dom.js","../../../../node_modules/jose/dist/node/esm/runtime/check_modulus_length.js","../../../../node_modules/zod/v3/helpers/util.js","../../../../node_modules/zod/v3/helpers/errorUtil.js","../../../../node_modules/%40privy-io/react-auth/node_modules/uuid/dist/esm-node/regex.js","../../../../node_modules/jose/dist/node/esm/lib/epoch.js","../../../../node_modules/jose/dist/node/esm/runtime/runtime.js","../../../../node_modules/%40headlessui/react/dist/utils/owner.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-slot.js","../../../../node_modules/%40coinbase/wallet-sdk/node_modules/preact/hooks/dist/hooks.mjs","../../../../node_modules/%40headlessui/react/dist/utils/disposables.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-store.js","../../../../node_modules/%40privy-io/js-sdk-core/dist/esm/wallet-api/update-wallet.mjs","../../../../node_modules/%40headlessui/react/dist/hooks/use-flags.js","../../../../node_modules/%40headlessui/react/dist/internal/portal-force-root.js","../../../../node_modules/%40headlessui/react/dist/internal/disabled.js","../../../../node_modules/%40headlessui/react/dist/internal/open-closed.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-server-handoff-complete.js","../../../../node_modules/%40headlessui/react/dist/internal/hidden.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-event.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-tab-direction.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-watch.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-sync-refs.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-event-listener.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-document-event.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-window-event.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-iso-morphic-effect.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-is-mounted.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-latest-value.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-is-touch-device.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-owner.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-disposables.js","../../../../node_modules/%40privy-io/react-auth/dist/esm/frame-CwE9r3cT.mjs","../../../../node_modules/%40headlessui/react/dist/hooks/use-on-unmount.js","../../../../node_modules/%40headlessui/react/dist/utils/active-element-history.js","../../../../node_modules/%40headlessui/react/dist/hooks/document-overflow/handle-ios-locking.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-scroll-lock.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-escape.js","../../../../node_modules/%40headlessui/react/dist/hooks/document-overflow/use-document-overflow.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-on-disappear.js","../../../../node_modules/%40headlessui/react/dist/utils/focus-management.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-is-top-layer.js","../../../../node_modules/%40headlessui/react/dist/utils/render.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-inert-others.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-root-containers.js","../../../../node_modules/%40headlessui/react/dist/hooks/document-overflow/overflow-store.js","../../../../node_modules/%40headlessui/react/dist/hooks/use-outside-click.js","../../../../node_modules/zod/v3/errors.js","../../../../node_modules/%40privy-io/react-auth/node_modules/uuid/dist/esm-node/stringify.js","../../../../node_modules/jose/dist/node/esm/lib/validate_crit.js","../../../../node_modules/jose/dist/node/esm/runtime/zlib.js","../../../../node_modules/jose/dist/node/esm/runtime/is_key_object.js","../../../../node_modules/jose/dist/node/esm/runtime/timing_safe_equal.js","../../../../node_modules/%40privy-io/react-auth/node_modules/uuid/dist/esm-node/rng.js","../../../../node_modules/jose/dist/node/esm/runtime/ciphers.js","../../../../node_modules/jose/dist/node/esm/jwe/compact/encrypt.js","../../../../node_modules/jose/dist/node/esm/jws/compact/sign.js","../../../../node_modules/jose/dist/node/esm/key/generate_key_pair.js","../../../../node_modules/jose/dist/node/esm/key/generate_secret.js","../../../../node_modules/zod/v3/ZodError.js","../../../../node_modules/jose/dist/node/esm/runtime/dsa_digest.js","../../../../node_modules/jose/dist/node/esm/lib/check_p2s.js","../../../../node_modules/jose/dist/node/esm/runtime/hmac_digest.js","../../../../node_modules/jose/dist/node/esm/util/runtime.js","../../../../node_modules/%40solana/rpc-spec-types/src/parse-json-with-bigints.ts","../../../../node_modules/jose/dist/node/esm/runtime/webcrypto.js","../../../../node_modules/jose/dist/node/esm/runtime/asn1_sequence_encoder.js","../../../../node_modules/%40privy-io/react-auth/node_modules/uuid/dist/esm-node/validate.js","../../../../node_modules/jose/dist/node/esm/lib/check_key_type.js","../../../../node_modules/jose/dist/node/esm/runtime/check_cek_length.js","../../../../node_modules/zod/v3/locales/en.js","../../../../node_modules/jose/dist/node/esm/jws/general/sign.js","../../../../node_modules/zod/v3/helpers/parseUtil.js","../../../../node_modules/jose/dist/node/esm/lib/cek.js","../../../../node_modules/jose/dist/node/esm/lib/iv.js","../../../../node_modules/jose/dist/node/esm/runtime/is_key_like.js","../../../../node_modules/jose/dist/node/esm/runtime/cbc_tag.js","../../../../node_modules/%40walletconnect/utils/node_modules/ox/core/internal/entropy.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/util/provider.ts","../../../../node_modules/viem/zksync/decorators/eip712.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/util/checkCrossOriginOpenerPolicy.ts","../../../../node_modules/jose/dist/node/esm/jwks/local.js","../../../../node_modules/jose/dist/node/esm/jwks/remote.js","../../../../node_modules/jose/dist/node/esm/runtime/decrypt.js","../../../../node_modules/jose/dist/node/esm/jwt/encrypt.js","../../../../node_modules/jose/dist/node/esm/jwk/embedded.js","../../../../node_modules/jose/dist/node/esm/jwt/produce.js","../../../../node_modules/jose/dist/node/esm/jwt/verify.js","../../../../node_modules/jose/dist/node/esm/jwt/decrypt.js","../../../../node_modules/jose/dist/node/esm/jws/compact/verify.js","../../../../node_modules/jose/dist/node/esm/jws/general/verify.js","../../../../node_modules/jose/dist/node/esm/jwe/compact/decrypt.js","../../../../node_modules/jose/dist/node/esm/jwe/general/decrypt.js","../../../../node_modules/jose/dist/node/esm/key/export.js","../../../../node_modules/%40coinbase/wallet-sdk/src/sign/walletlink/relay/ui/components/cssReset/cssReset.ts","../../../../node_modules/viem/zksync/errors/bytecode.ts","../../../../node_modules/x402/dist/esm/chunk-K4TZLEOT.mjs","../../../../node_modules/%40privy-io/react-auth/node_modules/uuid/dist/esm-node/v4.js","../../../../node_modules/%40solana/fast-stable-stringify/src/index.ts","../../../../node_modules/%40walletconnect/utils/node_modules/ox/node_modules/%40noble/curves/src/abstract/curve.ts","../../../../node_modules/viem/accounts/utils/signAuthorization.ts","../../../../node_modules/jose/dist/node/esm/lib/aesgcmkw.js","../../../../node_modules/jose/dist/node/esm/jwt/sign.js","../../../../node_modules/%40solana-program/token-2022/src/generated/types/accountState.ts","../../../../node_modules/viem/accounts/utils/signTransaction.ts","../../../../node_modules/mipd/src/utils.ts","../../../../node_modules/zod/v3/types.js","../../../../node_modules/jose/dist/node/esm/runtime/generate.js","../../../../node_modules/jose/dist/node/esm/runtime/node_key.js","../../../../node_modules/jose/dist/node/esm/lib/jwt_claims_set.js","../../../../node_modules/jose/dist/node/esm/key/import.js","../../../../node_modules/jose/dist/node/esm/jwt/unsecured.js","../../../../node_modules/jose/dist/node/esm/runtime/get_sign_verify_key.js","../../../../node_modules/%40solana/rpc-spec/src/rpc.ts","../../../../node_modules/mipd/src/store.ts","../../../../node_modules/%40solana-program/compute-budget/src/generated/programs/computeBudget.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/core/error/errors.ts","../../../../node_modules/jose/dist/node/esm/runtime/asn1.js","../../../../node_modules/jose/dist/node/esm/runtime/sign.js","../../../../node_modules/%40coinbase/wallet-sdk/src/sign/walletlink/relay/connection/WalletLinkWebSocket.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/sign/walletlink/relay/ui/components/util.ts","../../../../node_modules/viem/op-stack/serializers.ts","../../../../node_modules/%40solana/rpc-api/src/index.ts","../../../../node_modules/viem/zksync/serializers.ts","../../../../node_modules/viem/op-stack/contracts.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/logger/src/linkedList.ts","../../../../node_modules/%40walletconnect/utils/node_modules/%40walletconnect/logger/src/linkedList.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/sign/walletlink/relay/ui/components/Snackbar/Snackbar.tsx","../../../../node_modules/jose/dist/node/esm/jwe/general/encrypt.js","../../../../node_modules/jose/dist/node/esm/runtime/verify.js","../../../../node_modules/jose/dist/node/esm/runtime/get_named_curve.js","../../../../node_modules/jose/dist/node/esm/runtime/rsaes.js","../../../../node_modules/%40coinbase/wallet-sdk/src/sign/walletlink/relay/connection/WalletLinkConnection.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/sign/util.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/createCoinbaseWalletSDK.ts","../../../../node_modules/viem/zksync/utils/assertEip712Request.ts","../../../../node_modules/jose/dist/node/esm/jws/flattened/sign.js","../../../../node_modules/viem/zksync/utils/isEip712Transaction.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/util/cipher.ts","../../../../node_modules/%40walletconnect/utils/node_modules/ox/core/Hex.ts","../../../../node_modules/jose/dist/node/esm/runtime/jwk_to_key.js","../../../../node_modules/viem/op-stack/chainConfig.ts","../../../../node_modules/%40solana/event-target-impl/src/index.node.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/core/type/index.ts","../../../../node_modules/%40walletconnect/utils/node_modules/ox/core/internal/hex.ts","../../../../node_modules/%40walletconnect/utils/node_modules/ox/core/internal/bytes.ts","../../../../node_modules/%40walletconnect/utils/node_modules/ox/core/internal/errors.ts","../../../../node_modules/%40solana/rpc-subscriptions-spec/src/rpc-subscriptions.ts","../../../../node_modules/viem/accounts/utils/signTypedData.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/sign/walletlink/relay/RelayEventManager.ts","../../../../node_modules/%40walletconnect/utils/node_modules/ox/node_modules/%40noble/curves/src/abstract/modular.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/util/validatePreferences.ts","../../../../node_modules/viem/chains/definitions/baseSepolia.ts","../../../../node_modules/%40walletconnect/sign-client/src/constants/client.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/createCoinbaseWalletProvider.ts","../../../../node_modules/viem/zksync/errors/transaction.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/logger/src/baseChunkLogger.ts","../../../../node_modules/%40walletconnect/utils/node_modules/%40walletconnect/logger/src/baseChunkLogger.ts","../../../../node_modules/jose/dist/node/esm/jwe/flattened/encrypt.js","../../../../node_modules/jose/dist/node/esm/jws/flattened/verify.js","../../../../node_modules/%40coinbase/wallet-sdk/src/sign/walletlink/relay/connection/WalletLinkHTTP.ts","../../../../node_modules/viem/accounts/utils/signMessage.ts","../../../../node_modules/viem/zksync/constants/address.ts","../../../../node_modules/jose/dist/node/esm/runtime/key_to_jwk.js","../../../../node_modules/jose/dist/node/esm/lib/encrypt_key_management.js","../../../../node_modules/jose/dist/node/esm/runtime/ecdhes.js","../../../../node_modules/viem/zksync/utils/abi/encodeDeployData.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/core/type/util.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/sign/walletlink/WalletLinkSigner.ts","../../../../node_modules/%40walletconnect/sign-client/src/constants/history.ts","../../../../node_modules/jose/dist/node/esm/lib/decrypt_key_management.js","../../../../node_modules/x402/dist/esm/chunk-3EQVFRKV.mjs","../../../../node_modules/%40walletconnect/utils/node_modules/ox/core/Solidity.ts","../../../../node_modules/%40solana/rpc/src/rpc-integer-overflow-error.ts","../../../../node_modules/jose/dist/node/esm/runtime/encrypt.js","../../../../node_modules/jose/dist/node/esm/runtime/pbes2kw.js","../../../../node_modules/%40coinbase/wallet-sdk/src/core/communicator/Communicator.ts","../../../../node_modules/%40walletconnect/utils/node_modules/ox/node_modules/%40noble/curves/src/abstract/utils.ts","../../../../node_modules/viem/zksync/formatters.ts","../../../../node_modules/%40walletconnect/utils/node_modules/ox/node_modules/%40noble/curves/src/_shortw_utils.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/sign/walletlink/relay/type/WalletLinkSession.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/logger/src/serverChunkLogger.ts","../../../../node_modules/%40walletconnect/utils/node_modules/%40walletconnect/logger/src/serverChunkLogger.ts","../../../../node_modules/%40walletconnect/ethereum-provider/node_modules/node_modules/es-toolkit/dist/compat/_internal/getSymbols.mjs","../../../../node_modules/%40solana/rpc-transport-http/src/http-transport-headers.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/core/error/utils.ts","../../../../node_modules/viem/zksync/constants/abis.ts","../../../../node_modules/%40solana/rpc-subscriptions-api/src/index.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/sign/walletlink/relay/WalletLinkRelay.ts","../../../../node_modules/%40walletconnect/ethereum-provider/src/wcmToAppKit.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/sign/walletlink/relay/connection/WalletLinkCipher.ts","../../../../node_modules/%40solana/rpc-subscriptions/src/rpc-integer-overflow-error.ts","../../../../node_modules/%40walletconnect/utils/node_modules/ox/core/Caches.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/core/storage/ScopedLocalStorage.ts","../../../../node_modules/x402/dist/esm/chunk-SQV4BQTM.mjs","../../../../node_modules/%40coinbase/wallet-sdk/src/sign/walletlink/relay/ui/WalletLinkRelayUI.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/core/src/constants/core.ts","../../../../node_modules/%40walletconnect/sign-client/src/constants/engine.ts","../../../../node_modules/viem/zksync/utils/getEip712Domain.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/core/error/serialize.ts","../../../../node_modules/viem/zksync/utils/assertEip712Transaction.ts","../../../../node_modules/viem/accounts/toAccount.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/sign/scw/SCWSigner.ts","../../../../node_modules/x402/dist/esm/chunk-F22J6Y36.mjs","../../../../node_modules/%40walletconnect/utils/node_modules/ox/core/internal/lru.ts","../../../../node_modules/%40solana/sysvars/src/sysvar.ts","../../../../node_modules/%40walletconnect/types/src/core/keychain.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/sign/walletlink/relay/ui/WLMobileRelayUI.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/util/web.ts","../../../../node_modules/%40solana/subscribable/src/async-iterable.ts","../../../../node_modules/%40walletconnect/utils/node_modules/ox/core/Json.ts","../../../../node_modules/%40walletconnect/sign-client/src/constants/verify.ts","../../../../node_modules/viem/chains/definitions/abstract.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/types/authorityType.ts","../../../../node_modules/%40walletconnect/types/src/core/expirer.ts","../../../../node_modules/%40walletconnect/sign-client/src/constants/auth.ts","../../../../node_modules/viem/chains/definitions/story.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/sign/scw/SCWKeyManager.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/CoinbaseWalletProvider.ts","../../../../node_modules/%40solana/rpc-subscriptions-channel-websocket/src/websocket-channel.ts","../../../../node_modules/viem/chains/definitions/seiTestnet.ts","../../../../node_modules/viem/chains/definitions/polygon.ts","../../../../node_modules/viem/chains/definitions/polygonAmoy.ts","../../../../node_modules/%40walletconnect/utils/node_modules/ox/core/Signature.ts","../../../../node_modules/viem/accounts/utils/sign.ts","../../../../node_modules/%40walletconnect/sign-client/src/controllers/engine.ts","../../../../node_modules/%40walletconnect/utils/node_modules/ox/node_modules/%40noble/curves/src/secp256k1.ts","../../../../node_modules/%40walletconnect/types/src/core/verify.ts","../../../../node_modules/viem/zksync/utils/hashBytecode.ts","../../../../node_modules/node_modules/%40noble/hashes/esm/_u64.js","../../../../node_modules/%40walletconnect/sign-client/src/controllers/session.ts","../../../../node_modules/%40walletconnect/utils/node_modules/ox/core/Errors.ts","../../../../node_modules/%40walletconnect/utils/node_modules/ox/core/Bytes.ts","../../../../node_modules/%40walletconnect/sign-client/src/controllers/pendingRequest.ts","../../../../node_modules/viem/accounts/privateKeyToAccount.ts","../../../../node_modules/%40coinbase/wallet-sdk/src/sign/walletlink/relay/ui/components/RedirectDialog/RedirectDialog.tsx","../../../../node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/core/src/constants/subscriber.ts","../../../../node_modules/%40solana/sysvars/src/clock.ts","../../../../node_modules/viem/op-stack/formatters.ts","../../../../node_modules/viem/zksync/actions/deployContract.ts","../../../../node_modules/%40walletconnect/sign-client/src/controllers/authKey.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/core/src/constants/pairing.ts","../../../../node_modules/viem/chains/definitions/base.ts","../../../../node_modules/%40walletconnect/types/src/sign-client/engine.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/core/src/constants/history.ts","../../../../node_modules/viem/chains/definitions/peaq.ts","../../../../node_modules/viem/chains/definitions/abstractTestnet.ts","../../../../node_modules/%40walletconnect/sign-client/src/controllers/authStore.ts","../../../../node_modules/%40walletconnect/utils/node_modules/ox/core/PublicKey.ts","../../../../node_modules/%40walletconnect/utils/node_modules/ox/node_modules/%40noble/curves/src/abstract/hash-to-curve.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/core/src/constants/verify.ts","../../../../node_modules/%40solana-program/compute-budget/src/generated/instructions/requestHeapFrame.ts","../../../../node_modules/%40walletconnect/sign-client/src/client.ts","../../../../node_modules/%40solana/rpc-transformers/src/tree-traversal.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/core/src/constants/events.ts","../../../../node_modules/%40walletconnect/utils/node_modules/ox/core/Hash.ts","../../../../node_modules/%40walletconnect/utils/node_modules/ox/core/Secp256k1.ts","../../../../node_modules/%40walletconnect/utils/node_modules/ox/node_modules/%40noble/curves/src/abstract/weierstrass.ts","../../../../node_modules/viem/zksync/actions/signTransaction.ts","../../../../node_modules/%40solana/rpc/src/rpc-default-config.ts","../../../../node_modules/viem/zksync/actions/sendTransaction.ts","../../../../node_modules/%40solana/rpc-subscriptions/src/rpc-default-config.ts","../../../../node_modules/viem/zksync/actions/signEip712Transaction.ts","../../../../node_modules/%40walletconnect/ethereum-provider/node_modules/node_modules/es-toolkit/dist/object/cloneDeepWith.mjs","../../../../node_modules/%40solana/rpc-spec/src/rpc-api.ts","../../../../node_modules/viem/zksync/actions/sendEip712Transaction.ts","../../../../node_modules/%40solana/sysvars/src/epoch-rewards.ts","../../../../node_modules/%40solana/rpc-transport-http/src/http-transport.ts","../../../../node_modules/%40solana/rpc-transformers/src/request-transformer-bigint-downcast.ts","../../../../node_modules/x402/src/client/selectPaymentRequirements.ts","../../../../node_modules/%40solana/rpc-subscriptions-spec/src/rpc-subscriptions-api.ts","../../../../node_modules/%40solana/rpc-spec-types/src/rpc-message.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/types/encryptedBalance.ts","../../../../node_modules/%40walletconnect/utils/node_modules/ox/core/Address.ts","../../../../node_modules/%40solana/rpc-subscriptions/src/rpc-subscriptions-autopinger.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/multiformats/esm/vendor/base-x.js","../../../../node_modules/%40solana/rpc/src/rpc-request-coalescer.ts","../../../../node_modules/%40solana/rpc-spec/src/rpc-transport.ts","../../../../node_modules/node_modules/%40noble/hashes/esm/crypto.js","../../../../node_modules/%40solana/rpc-transformers/src/request-transformer-default-commitment-internal.ts","../../../../node_modules/%40solana/rpc-subscriptions-spec/src/rpc-subscriptions-channel.ts","../../../../node_modules/%40solana-program/compute-budget/src/generated/instructions/requestUnits.ts","../../../../node_modules/%40solana/rpc-spec-types/src/stringify-json-with-bigints.ts","../../../../node_modules/node_modules/%40noble/hashes/esm/utils.js","../../../../node_modules/x402/src/types/shared/evm/wallet.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/types/extension.ts","../../../../node_modules/%40solana/sysvars/src/epoch-schedule.ts","../../../../node_modules/x402/src/schemes/exact/evm/sign.ts","../../../../node_modules/%40solana/rpc-subscriptions-spec/src/rpc-subscriptions-pubsub-plan.ts","../../../../node_modules/%40solana/sysvars/src/last-restart-slot.ts","../../../../node_modules/%40solana/rpc-subscriptions/src/rpc-subscriptions-channel-pool-internal.ts","../../../../node_modules/%40solana/rpc-transport-http/src/is-solana-request.ts","../../../../node_modules/%40solana/rpc-transformers/src/request-transformer-default-commitment.ts","../../../../node_modules/%40solana/rpc-subscriptions/src/rpc-subscriptions-channel-pool.ts","../../../../node_modules/%40solana-program/compute-budget/src/generated/instructions/setComputeUnitLimit.ts","../../../../node_modules/%40solana/rpc/src/rpc-request-deduplication.ts","../../../../node_modules/%40solana/sysvars/src/recent-blockhashes.ts","../../../../node_modules/%40solana/rpc/src/rpc-transport.ts","../../../../node_modules/%40solana/subscribable/src/data-publisher.ts","../../../../node_modules/%40solana/rpc-transformers/src/request-transformer-integer-overflow-internal.ts","../../../../node_modules/%40solana/sysvars/src/rent.ts","../../../../node_modules/%40solana/rpc-transformers/src/request-transformer-integer-overflow.ts","../../../../node_modules/x402/src/schemes/exact/evm/client.ts","../../../../node_modules/%40solana/subscribable/src/demultiplex.ts","../../../../node_modules/%40solana/rpc-transformers/src/request-transformer-options-object-position-config.ts","../../../../node_modules/%40solana/rpc/src/rpc.ts","../../../../node_modules/%40solana/rpc-transport-http/src/http-transport-for-solana-rpc.ts","../../../../node_modules/%40solana-program/compute-budget/src/generated/instructions/setComputeUnitPrice.ts","../../../../node_modules/%40solana/sysvars/src/slot-hashes.ts","../../../../node_modules/x402/src/schemes/exact/svm/client.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/multiformats/esm/src/bytes.js","../../../../node_modules/%40solana/rpc-subscriptions/src/rpc-subscriptions-json.ts","../../../../node_modules/%40solana/rpc-subscriptions/src/rpc-subscriptions-json-bigint.ts","../../../../node_modules/%40walletconnect/ethereum-provider/node_modules/node_modules/es-toolkit/dist/compat/object/cloneDeepWith.mjs","../../../../node_modules/%40solana/sysvars/src/slot-history.ts","../../../../node_modules/%40solana/rpc-subscriptions/src/rpc-subscriptions-channel.ts","../../../../node_modules/%40solana/rpc-transformers/src/request-transformer.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/multiformats/esm/src/bases/base.js","../../../../node_modules/%40solana-program/compute-budget/src/generated/instructions/setLoadedAccountsDataSizeLimit.ts","../../../../node_modules/%40solana/rpc-transformers/src/response-transformer-bigint-upcast-internal.ts","../../../../node_modules/x402/src/shared/svm/wallet.ts","../../../../node_modules/%40walletconnect/ethereum-provider/node_modules/node_modules/es-toolkit/dist/compat/object/cloneDeep.mjs","../../../../node_modules/%40walletconnect/ethereum-provider/node_modules/node_modules/es-toolkit/dist/compat/predicate/isArguments.mjs","../../../../node_modules/%40walletconnect/ethereum-provider/node_modules/node_modules/es-toolkit/dist/compat/predicate/isObjectLike.mjs","../../../../node_modules/%40walletconnect/ethereum-provider/node_modules/node_modules/es-toolkit/dist/function/noop.mjs","../../../../node_modules/x402/src/shared/svm/rpc.ts","../../../../node_modules/%40solana/rpc-subscriptions/src/rpc-subscriptions-coalescer.ts","../../../../node_modules/%40walletconnect/ethereum-provider/node_modules/node_modules/es-toolkit/dist/compat/predicate/isPlainObject.mjs","../../../../node_modules/%40solana/rpc-transformers/src/response-transformer-bigint-upcast.ts","../../../../node_modules/%40solana/rpc-transformers/src/response-transformer-result.ts","../../../../node_modules/%40solana/rpc-transformers/src/response-transformer-throw-solana-error.ts","../../../../node_modules/%40solana-program/compute-budget/src/constants.ts","../../../../node_modules/%40solana-program/compute-budget/src/internal.ts","../../../../node_modules/%40solana/rpc-transformers/src/response-transformer.ts","../../../../node_modules/%40walletconnect/ethereum-provider/node_modules/node_modules/es-toolkit/dist/object/clone.mjs","../../../../node_modules/%40solana/rpc-transformers/src/response-transformer-allowed-numeric-values.ts","../../../../node_modules/x402/src/types/shared/wallet.ts","../../../../node_modules/%40solana/rpc-subscriptions/src/rpc-subscriptions-transport.ts","../../../../node_modules/node_modules/%40noble/hashes/esm/sha3.js","../../../../node_modules/%40solana-program/compute-budget/src/setComputeLimit.ts","../../../../node_modules/%40solana/sysvars/src/stake-history.ts","../../../../node_modules/%40solana/rpc-subscriptions/src/rpc-subscriptions.ts","../../../../node_modules/%40walletconnect/ethereum-provider/node_modules/node_modules/es-toolkit/dist/compat/object/mergeWith.mjs","../../../../node_modules/%40solana-program/compute-budget/src/estimateAndSetComputeLimit.ts","../../../../node_modules/%40solana-program/compute-budget/src/estimateComputeLimitInternal.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/multiformats/esm/src/bases/identity.js","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/multiformats/esm/src/bases/base2.js","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/multiformats/esm/src/bases/base8.js","../../../../node_modules/x402/src/shared/base64.ts","../../../../node_modules/x402/src/types/shared/evm/erc20PermitABI.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/multiformats/esm/src/bases/base10.js","../../../../node_modules/x402/src/types/verify/x402Specs.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/multiformats/esm/src/bases/base16.js","../../../../node_modules/%40walletconnect/ethereum-provider/node_modules/node_modules/es-toolkit/dist/compat/object/merge.mjs","../../../../node_modules/%40walletconnect/ethereum-provider/node_modules/%40walletconnect/universal-provider/src/constants/values.ts","../../../../node_modules/%40walletconnect/ethereum-provider/node_modules/%40walletconnect/universal-provider/src/utils/misc.ts","../../../../node_modules/%40walletconnect/ethereum-provider/node_modules/%40walletconnect/universal-provider/src/utils/globals.ts","../../../../node_modules/%40solana-program/compute-budget/src/estimateComputeLimit.ts","../../../../node_modules/%40walletconnect/ethereum-provider/node_modules/%40walletconnect/universal-provider/src/utils/caip25.ts","../../../../node_modules/%40walletconnect/ethereum-provider/node_modules/%40walletconnect/universal-provider/src/utils/storage.ts","../../../../node_modules/%40walletconnect/ethereum-provider/node_modules/%40walletconnect/universal-provider/src/utils/eip5792.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/multiformats/esm/src/bases/base32.js","../../../../node_modules/%40walletconnect/ethereum-provider/node_modules/%40walletconnect/universal-provider/src/providers/eip155.ts","../../../../node_modules/%40walletconnect/ethereum-provider/node_modules/%40walletconnect/universal-provider/src/UniversalProvider.ts","../../../../node_modules/%40solana-program/compute-budget/src/setComputePrice.ts","../../../../node_modules/%40walletconnect/ethereum-provider/node_modules/%40walletconnect/universal-provider/src/index.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/multiformats/esm/src/bases/base36.js","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/multiformats/esm/src/bases/base58.js","../../../../node_modules/node_modules/%40noble/hashes/esm/_md.js","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/multiformats/esm/src/bases/base64.js","../../../../node_modules/x402/src/types/verify/facilitator.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/multiformats/esm/src/bases/base256emoji.js","../../../../node_modules/x402/src/shared/json.ts","../../../../node_modules/x402/src/shared/middleware.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/multiformats/esm/vendor/varint.js","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/multiformats/esm/src/varint.js","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/multiformats/esm/src/hashes/digest.js","../../../../node_modules/node_modules/%40noble/hashes/esm/sha2.js","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/multiformats/esm/src/hashes/hasher.js","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/multiformats/esm/src/hashes/sha2-browser.js","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/multiformats/esm/src/hashes/identity.js","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/multiformats/esm/src/codecs/json.js","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/multiformats/esm/src/basics.js","../../../../node_modules/x402/src/shared/svm/transaction.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/types/extensionType.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/uint8arrays/esm/src/util/as-uint8array.js","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/uint8arrays/esm/src/alloc.js","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/uint8arrays/esm/src/util/bases.js","../../../../node_modules/x402/src/shared/evm/usdc.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/types/tokenMetadataField.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/uint8arrays/esm/src/from-string.js","../../../../node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/core/src/controllers/keychain.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/core/src/controllers/crypto.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/core/src/controllers/messages.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/core/src/controllers/publisher.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/core/src/controllers/topicmap.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/core/src/controllers/subscriber.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/core/src/controllers/relayer.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/es-toolkit/dist/compat/util/eq.mjs","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/es-toolkit/dist/compat/_internal/getSymbols.mjs","../../../../node_modules/%40solana-program/token-2022/src/generated/types/transferFee.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/es-toolkit/dist/compat/_internal/getTag.mjs","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/es-toolkit/dist/compat/_internal/tags.mjs","../../../../node_modules/%40solana-program/token-2022/src/generated/accounts/mint.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/es-toolkit/dist/predicate/isPlainObject.mjs","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/es-toolkit/dist/predicate/isEqualWith.mjs","../../../../node_modules/%40solana-program/token-2022/src/generated/accounts/multisig.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/accounts/token.ts","../../../../node_modules/node_modules/%40noble/hashes/esm/_blake.js","../../../../node_modules/node_modules/%40noble/hashes/esm/blake2.js","../../../../node_modules/%40walletconnect/sign-client/node_modules/node_modules/es-toolkit/dist/predicate/isEqual.mjs","../../../../node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/core/src/controllers/store.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/core/src/controllers/echo.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/core/src/controllers/events.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/core/src/core.ts","../../../../node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/core/src/index.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/programs/associatedToken.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/programs/token2022.ts","../../../../node_modules/%40walletconnect/utils/src/signatures.ts","../../../../node_modules/%40walletconnect/utils/src/cacao.ts","../../../../node_modules/node_modules/%40noble/ciphers/esm/utils.js","../../../../node_modules/%40solana-program/token-2022/src/generated/errors/associatedToken.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/errors/token2022.ts","../../../../node_modules/node_modules/%40noble/ciphers/esm/_arx.js","../../../../node_modules/%40solana-program/token-2022/src/generated/shared/index.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/amountToUiAmount.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/applyConfidentialPendingBalance.ts","../../../../node_modules/node_modules/%40noble/ciphers/esm/_poly1305.js","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/approve.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/approveChecked.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/approveConfidentialTransferAccount.ts","../../../../node_modules/node_modules/%40noble/ciphers/esm/chacha.js","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/burn.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/burnChecked.ts","../../../../node_modules/node_modules/%40noble/hashes/esm/hmac.js","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/closeAccount.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/confidentialDeposit.ts","../../../../node_modules/node_modules/%40noble/hashes/esm/hkdf.js","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/confidentialTransfer.ts","../../../../node_modules/node_modules/%40noble/curves/esm/utils.js","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/confidentialTransferWithFee.ts","../../../../node_modules/node_modules/%40noble/curves/esm/abstract/modular.js","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/confidentialWithdraw.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/configureConfidentialTransferAccount.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/pdas/associatedToken.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/createAssociatedToken.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/createAssociatedTokenIdempotent.ts","../../../../node_modules/node_modules/%40noble/curves/esm/abstract/curve.js","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/createNativeMint.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/disableConfidentialCredits.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/disableCpiGuard.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/disableHarvestToMint.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/disableMemoTransfers.ts","../../../../node_modules/node_modules/%40noble/curves/esm/abstract/edwards.js","../../../../node_modules/node_modules/%40noble/curves/esm/abstract/montgomery.js","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/disableNonConfidentialCredits.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/emitTokenMetadata.ts","../../../../node_modules/node_modules/%40noble/curves/esm/ed25519.js","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/emptyConfidentialTransferAccount.ts","../../../../node_modules/node_modules/%40noble/curves/esm/abstract/weierstrass.js","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/enableConfidentialCredits.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/enableCpiGuard.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/enableHarvestToMint.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/enableMemoTransfers.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/enableNonConfidentialCredits.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/freezeAccount.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/getAccountDataSize.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/harvestWithheldTokensToMint.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/harvestWithheldTokensToMintForConfidentialTransferFee.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeAccount.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeAccount2.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeAccount3.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeConfidentialTransferFee.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeConfidentialTransferMint.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeDefaultAccountState.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeGroupMemberPointer.ts","../../../../node_modules/node_modules/%40noble/curves/esm/_shortw_utils.js","../../../../node_modules/node_modules/%40noble/curves/esm/nist.js","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeGroupPointer.ts","../../../../node_modules/node_modules/%40noble/curves/esm/p256.js","../../../../node_modules/%40walletconnect/utils/src/crypto.ts","../../../../node_modules/%40walletconnect/utils/src/uri.ts","../../../../node_modules/%40walletconnect/utils/src/namespaces.ts","../../../../node_modules/%40walletconnect/utils/src/errors.ts","../../../../node_modules/%40walletconnect/utils/src/validators.ts","../../../../node_modules/%40walletconnect/utils/src/network.ts","../../../../node_modules/%40walletconnect/utils/src/memoryStore.ts","../../../../node_modules/%40walletconnect/utils/src/logger.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeImmutableOwner.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeInterestBearingMint.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeMetadataPointer.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeMint.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeMint2.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeMintCloseAuthority.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeMultisig.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeMultisig2.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeNonTransferableMint.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializePausableConfig.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializePermanentDelegate.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeScaledUiAmountMint.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeTokenGroup.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeTokenGroupMember.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeTokenMetadata.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeTransferFeeConfig.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/initializeTransferHook.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/mintTo.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/mintToChecked.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/pause.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/reallocate.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/recoverNestedAssociatedToken.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/removeTokenMetadataKey.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/resume.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/revoke.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/setAuthority.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/setTransferFee.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/syncNative.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/thawAccount.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/transfer.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/transferChecked.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/transferCheckedWithFee.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/uiAmountToAmount.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/updateConfidentialTransferMint.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/updateDefaultAccountState.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/updateGroupMemberPointer.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/updateGroupPointer.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/updateMetadataPointer.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/updateMultiplierScaledUiMint.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/updateRateInterestBearingMint.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/updateTokenGroupMaxSize.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/updateTokenGroupUpdateAuthority.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/updateTokenMetadataField.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/updateTokenMetadataUpdateAuthority.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/updateTransferHook.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/withdrawExcessLamports.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/withdrawWithheldTokensFromAccounts.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/withdrawWithheldTokensFromAccountsForConfidentialTransferFee.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/withdrawWithheldTokensFromMint.ts","../../../../node_modules/%40solana-program/token-2022/src/generated/instructions/withdrawWithheldTokensFromMintForConfidentialTransferFee.ts","../../../../node_modules/%40solana-program/token-2022/src/amountToUiAmount.ts","../../../../node_modules/%40solana-program/token-2022/src/getInitializeInstructionsForExtensions.ts","../../../../node_modules/%40solana-program/token-2022/src/getTokenSize.ts","../../../../node_modules/%40solana-program/token-2022/src/getMintSize.ts"],"sourcesContent":["/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0; i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n","/**\n * Internal webcrypto alias.\n * We prefer WebCrypto aka globalThis.crypto, which exists in node.js 16+.\n * Falls back to Node.js built-in crypto for Node.js <=v14.\n * See utils.ts for details.\n * @module\n */\n// @ts-ignore\nimport * as nc from 'node:crypto';\nexport const crypto: any =\n  nc && typeof nc === 'object' && 'webcrypto' in nc\n    ? (nc.webcrypto as any)\n    : nc && typeof nc === 'object' && 'randomBytes' in nc\n      ? nc\n      : undefined;\n","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Asserts something is hash */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** @deprecated */\nexport const byteSwapIfBE: typeof swap8IfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = string | Uint8Array;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash interface. */\nexport type IHash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  abstract clone(): T;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash function */\nexport type CHash = ReturnType<typeof createHasher>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof createOptHasher>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof createXOFer>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function createOptHasher<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function createXOFer<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\nexport const wrapConstructor: typeof createHasher = createHasher;\nexport const wrapConstructorWithOpts: typeof createOptHasher = createOptHasher;\nexport const wrapXOFConstructorWithOpts: typeof createXOFer = createXOFer;\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return Uint8Array.from(crypto.randomBytes(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.ts';\n// prettier-ignore\nimport {\n  abytes, aexists, anumber, aoutput,\n  clean, createHasher, createXOFer, Hash,\n  swap32IfBE,\n  toBytes, u32,\n  type CHash, type CHashXO, type HashXOF, type Input\n} from './utils.ts';\n\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI: number[] = [];\nconst SHA3_ROTL: number[] = [];\nconst _SHA3_IOTA: bigint[] = [];\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n    if (R & _2n) t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n  }\n  _SHA3_IOTA.push(t);\n}\nconst IOTAS = split(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h: number, l: number, s: number) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h: number, l: number, s: number) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\nexport function keccakP(s: Uint32Array, rounds: number = 24): void {\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta \n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho () and Pi ()\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi ()\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota ()\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  clean(B);\n}\n\n/** Keccak sponge function. */\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\n  protected state: Uint8Array;\n  protected pos = 0;\n  protected posOut = 0;\n  protected finished = false;\n  protected state32: Uint32Array;\n  protected destroyed = false;\n\n  public blockLen: number;\n  public suffix: number;\n  public outputLen: number;\n  protected enableXOF = false;\n  protected rounds: number;\n\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(\n    blockLen: number,\n    suffix: number,\n    outputLen: number,\n    enableXOF = false,\n    rounds: number = 24\n  ) {\n    super();\n    this.blockLen = blockLen;\n    this.suffix = suffix;\n    this.outputLen = outputLen;\n    this.enableXOF = enableXOF;\n    this.rounds = rounds;\n    // Can be passed from user as dkLen\n    anumber(outputLen);\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    // 0 < blockLen < 200\n    if (!(0 < blockLen && blockLen < 200))\n      throw new Error('only keccak-f1600 function is supported');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n  clone(): Keccak {\n    return this._cloneInto();\n  }\n  protected keccak(): void {\n    swap32IfBE(this.state32);\n    keccakP(this.state32, this.rounds);\n    swap32IfBE(this.state32);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { blockLen, state } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  protected finish(): void {\n    if (this.finished) return;\n    this.finished = true;\n    const { state, suffix, pos, blockLen } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  protected writeInto(out: Uint8Array): Uint8Array {\n    aexists(this, false);\n    abytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const { blockLen } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    anumber(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array): Uint8Array {\n    aoutput(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest(): Uint8Array {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.state);\n  }\n  _cloneInto(to?: Keccak): Keccak {\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\n\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\n  createHasher(() => new Keccak(blockLen, suffix, outputLen));\n\n/** SHA3-224 hash function. */\nexport const sha3_224: CHash = /* @__PURE__ */ (() => gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */\nexport const sha3_256: CHash = /* @__PURE__ */ (() => gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */\nexport const sha3_384: CHash = /* @__PURE__ */ (() => gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */\nexport const sha3_512: CHash = /* @__PURE__ */ (() => gen(0x06, 72, 512 / 8))();\n\n/** keccak-224 hash function. */\nexport const keccak_224: CHash = /* @__PURE__ */ (() => gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */\nexport const keccak_256: CHash = /* @__PURE__ */ (() => gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */\nexport const keccak_384: CHash = /* @__PURE__ */ (() => gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */\nexport const keccak_512: CHash = /* @__PURE__ */ (() => gen(0x01, 72, 512 / 8))();\n\nexport type ShakeOpts = { dkLen?: number };\n\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\n  createXOFer<HashXOF<Keccak>, ShakeOpts>(\n    (opts: ShakeOpts = {}) =>\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\n  );\n\n/** SHAKE128 XOF with 128-bit security. */\nexport const shake128: CHashXO = /* @__PURE__ */ (() => genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */\nexport const shake256: CHashXO = /* @__PURE__ */ (() => genShake(0x1f, 136, 256 / 8))();\n","// Extracted from https://github.com/ethereumjs/ethereumjs-util and stripped out irrelevant code\n// Original code licensed under the Mozilla Public License Version 2.0\n\n/* eslint-disable */\n//prettier-ignore\nconst { keccak_256 } = require('@noble/hashes/sha3')\n\n/**\n * Returns a buffer filled with 0s\n * @method zeros\n * @param {Number} bytes  the number of bytes the buffer should be\n * @return {Buffer}\n */\nfunction zeros (bytes) {\n  return Buffer.allocUnsafe(bytes).fill(0)\n}\n\nfunction bitLengthFromBigInt (num) {\n  return num.toString(2).length\n}\n\nfunction bufferBEFromBigInt(num, length) {\n  let hex = num.toString(16);\n  // Ensure the hex string length is even\n  if (hex.length % 2 !== 0) hex = '0' + hex;\n  // Convert hex string to a byte array\n  const byteArray = hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16));\n  // Ensure the byte array is of the specified length\n  while (byteArray.length < length) {\n    byteArray.unshift(0); // Prepend with zeroes if shorter than required length\n  }\n\n  return Buffer.from(byteArray);\n}\n\nfunction twosFromBigInt(value, width) {\n  const isNegative = value < 0n;\n  let result;\n  if (isNegative) {\n    // Prepare a mask for the specified width to perform NOT operation\n    const mask = (1n << BigInt(width)) - 1n;\n    // Invert bits (using NOT) and add one\n    result = (~value & mask) + 1n;\n  } else {\n    result = value;\n  }\n  // Ensure the result fits in the specified width\n  result &= (1n << BigInt(width)) - 1n;\n\n  return result;\n}\n\n/**\n * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @method setLength\n * @param {Buffer|Array} msg the value to pad\n * @param {Number} length the number of bytes the output should be\n * @param {Boolean} [right=false] whether to start padding form the left or right\n * @return {Buffer|Array}\n */\nfunction setLength (msg, length, right) {\n  const buf = zeros(length)\n  msg = toBuffer(msg)\n  if (right) {\n    if (msg.length < length) {\n      msg.copy(buf)\n      return buf\n    }\n    return msg.slice(0, length)\n  } else {\n    if (msg.length < length) {\n      msg.copy(buf, length - msg.length)\n      return buf\n    }\n    return msg.slice(-length)\n  }\n}\n\n/**\n * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param {Buffer|Array} msg the value to pad\n * @param {Number} length the number of bytes the output should be\n * @return {Buffer|Array}\n */\nfunction setLengthRight (msg, length) {\n  return setLength(msg, length, true)\n}\n\n/**\n * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BIgInt` and other objects with a `toArray()` method.\n * @param {*} v the value\n */\nfunction toBuffer (v) {\n  if (!Buffer.isBuffer(v)) {\n    if (Array.isArray(v)) {\n      v = Buffer.from(v)\n    } else if (typeof v === 'string') {\n      if (isHexString(v)) {\n        v = Buffer.from(padToEven(stripHexPrefix(v)), 'hex')\n      } else {\n        v = Buffer.from(v)\n      }\n    } else if (typeof v === 'number') {\n      v = intToBuffer(v)\n    } else if (v === null || v === undefined) {\n      v = Buffer.allocUnsafe(0)\n    } else if (typeof v === 'bigint') {\n      v = bufferBEFromBigInt(v)\n    } else if (v.toArray) {\n      // TODO: bigint should be handled above, may remove this duplicate\n      // converts a BigInt to a Buffer\n      v = Buffer.from(v.toArray())\n    } else {\n      throw new Error('invalid type')\n    }\n  }\n  return v\n}\n\n/**\n * Converts a `Buffer` into a hex `String`\n * @param {Buffer} buf\n * @return {String}\n */\nfunction bufferToHex (buf) {\n  buf = toBuffer(buf)\n  return '0x' + buf.toString('hex')\n}\n\n/**\n * Creates Keccak hash of the input\n * @param {Buffer|Array|String|Number} a the input data\n * @param {Number} [bits=256] the Keccak width\n * @return {Buffer}\n */\nfunction keccak (a, bits) {\n  a = toBuffer(a)\n  if (!bits) bits = 256\n  if (bits !== 256) {\n    throw new Error('unsupported')\n  }\n  return Buffer.from(keccak_256(new Uint8Array(a)))\n}\n\nfunction padToEven (str) {\n  return str.length % 2 ? '0' + str : str\n}\n\nfunction isHexString (str) {\n  return typeof str === 'string' && str.match(/^0x[0-9A-Fa-f]*$/)\n}\n\nfunction stripHexPrefix (str) {\n  if (typeof str === 'string' && str.startsWith('0x')) {\n    return str.slice(2)\n  }\n  return str\n}\n\nmodule.exports = {\n  zeros,\n  setLength,\n  setLengthRight,\n  isHexString,\n  stripHexPrefix,\n  toBuffer,\n  bufferToHex,\n  keccak,\n  bitLengthFromBigInt,\n  bufferBEFromBigInt,\n  twosFromBigInt\n}\n","// Extracted from https://github.com/ethereumjs/ethereumjs-abi and stripped out irrelevant code\n// Original code licensed under the MIT License - Copyright (c) 2015 Alex Beregszaszi\n\n/* eslint-disable */\n//prettier-ignore\nconst util = require('./util.cjs')\n\n// Convert from short to canonical names\n// FIXME: optimise or make this nicer?\nfunction elementaryName (name) {\n  if (name.startsWith('int[')) {\n    return 'int256' + name.slice(3)\n  } else if (name === 'int') {\n    return 'int256'\n  } else if (name.startsWith('uint[')) {\n    return 'uint256' + name.slice(4)\n  } else if (name === 'uint') {\n    return 'uint256'\n  } else if (name.startsWith('fixed[')) {\n    return 'fixed128x128' + name.slice(5)\n  } else if (name === 'fixed') {\n    return 'fixed128x128'\n  } else if (name.startsWith('ufixed[')) {\n    return 'ufixed128x128' + name.slice(6)\n  } else if (name === 'ufixed') {\n    return 'ufixed128x128'\n  }\n  return name\n}\n\n// Parse N from type<N>\nfunction parseTypeN (type) {\n  return Number.parseInt(/^\\D+(\\d+)$/.exec(type)[1], 10)\n}\n\n// Parse N,M from type<N>x<M>\nfunction parseTypeNxM (type) {\n  var tmp = /^\\D+(\\d+)x(\\d+)$/.exec(type)\n  return [ Number.parseInt(tmp[1], 10), Number.parseInt(tmp[2], 10) ]\n}\n\n// Parse N in type[<N>] where \"type\" can itself be an array type.\nfunction parseTypeArray (type) {\n  var tmp = type.match(/(.*)\\[(.*?)\\]$/)\n  if (tmp) {\n    return tmp[2] === '' ? 'dynamic' : Number.parseInt(tmp[2], 10)\n  }\n  return null\n}\n\nfunction parseNumber (arg) {\n  var type = typeof arg\n  if (type === 'string' || type === 'number') {\n    return BigInt(arg)\n  } else if (type === 'bigint') {\n    return arg\n  } else {\n    throw new Error('Argument is not a number')\n  }\n}\n\n// Encodes a single item (can be dynamic array)\n// @returns: Buffer\nfunction encodeSingle (type, arg) {\n  var size, num, ret, i\n\n  if (type === 'address') {\n    return encodeSingle('uint160', parseNumber(arg))\n  } else if (type === 'bool') {\n    return encodeSingle('uint8', arg ? 1 : 0)\n  } else if (type === 'string') {\n    return encodeSingle('bytes', new Buffer(arg, 'utf8'))\n  } else if (isArray(type)) {\n    // this part handles fixed-length ([2]) and variable length ([]) arrays\n    // NOTE: we catch here all calls to arrays, that simplifies the rest\n    if (typeof arg.length === 'undefined') {\n      throw new Error('Not an array?')\n    }\n    size = parseTypeArray(type)\n    if (size !== 'dynamic' && size !== 0 && arg.length > size) {\n      throw new Error('Elements exceed array size: ' + size)\n    }\n    ret = []\n    type = type.slice(0, type.lastIndexOf('['))\n    if (typeof arg === 'string') {\n      arg = JSON.parse(arg)\n    }\n    for (i in arg) {\n      ret.push(encodeSingle(type, arg[i]))\n    }\n    if (size === 'dynamic') {\n      var length = encodeSingle('uint256', arg.length)\n      ret.unshift(length)\n    }\n    return Buffer.concat(ret)\n  } else if (type === 'bytes') {\n    arg = new Buffer(arg)\n\n    ret = Buffer.concat([ encodeSingle('uint256', arg.length), arg ])\n\n    if ((arg.length % 32) !== 0) {\n      ret = Buffer.concat([ ret, util.zeros(32 - (arg.length % 32)) ])\n    }\n\n    return ret\n  } else if (type.startsWith('bytes')) {\n    size = parseTypeN(type)\n    if (size < 1 || size > 32) {\n      throw new Error('Invalid bytes<N> width: ' + size)\n    }\n\n    return util.setLengthRight(arg, 32)\n  } else if (type.startsWith('uint')) {\n    size = parseTypeN(type)\n    if ((size % 8) || (size < 8) || (size > 256)) {\n      throw new Error('Invalid uint<N> width: ' + size)\n    }\n\n    num = parseNumber(arg)\n    const bitLength = util.bitLengthFromBigInt(num)\n    if (bitLength > size) {\n      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + bitLength)\n    }\n\n    if (num < 0) {\n      throw new Error('Supplied uint is negative')\n    }\n\n    return util.bufferBEFromBigInt(num, 32);\n  } else if (type.startsWith('int')) {\n    size = parseTypeN(type)\n    if ((size % 8) || (size < 8) || (size > 256)) {\n      throw new Error('Invalid int<N> width: ' + size)\n    }\n\n    num = parseNumber(arg)\n    const bitLength = util.bitLengthFromBigInt(num)\n    if (bitLength > size) {\n      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + bitLength)\n    }\n\n    const twos = util.twosFromBigInt(num, 256);\n\n    return util.bufferBEFromBigInt(twos, 32);\n  } else if (type.startsWith('ufixed')) {\n    size = parseTypeNxM(type)\n\n    num = parseNumber(arg)\n\n    if (num < 0) {\n      throw new Error('Supplied ufixed is negative')\n    }\n\n    return encodeSingle('uint256', num * BigInt(2) ** BigInt(size[1]))\n  } else if (type.startsWith('fixed')) {\n    size = parseTypeNxM(type)\n\n    return encodeSingle('int256', parseNumber(arg) * BigInt(2) ** BigInt(size[1]))\n  }\n\n  throw new Error('Unsupported or invalid type: ' + type)\n}\n\n// Is a type dynamic?\nfunction isDynamic (type) {\n  // FIXME: handle all types? I don't think anything is missing now\n  return (type === 'string') || (type === 'bytes') || (parseTypeArray(type) === 'dynamic')\n}\n\n// Is a type an array?\nfunction isArray (type) {\n  return type.lastIndexOf(']') === type.length - 1\n}\n\n// Encode a method/event with arguments\n// @types an array of string type names\n// @args  an array of the appropriate values\nfunction rawEncode (types, values) {\n  var output = []\n  var data = []\n\n  var headLength = 32 * types.length\n\n  for (var i in types) {\n    var type = elementaryName(types[i])\n    var value = values[i]\n    var cur = encodeSingle(type, value)\n\n    // Use the head/tail method for storing dynamic data\n    if (isDynamic(type)) {\n      output.push(encodeSingle('uint256', headLength))\n      data.push(cur)\n      headLength += cur.length\n    } else {\n      output.push(cur)\n    }\n  }\n\n  return Buffer.concat(output.concat(data))\n}\n\nfunction solidityPack (types, values) {\n  if (types.length !== values.length) {\n    throw new Error('Number of types are not matching the values')\n  }\n\n  var size, num\n  var ret = []\n\n  for (var i = 0; i < types.length; i++) {\n    var type = elementaryName(types[i])\n    var value = values[i]\n\n    if (type === 'bytes') {\n      ret.push(value)\n    } else if (type === 'string') {\n      ret.push(new Buffer(value, 'utf8'))\n    } else if (type === 'bool') {\n      ret.push(new Buffer(value ? '01' : '00', 'hex'))\n    } else if (type === 'address') {\n      ret.push(util.setLength(value, 20))\n    } else if (type.startsWith('bytes')) {\n      size = parseTypeN(type)\n      if (size < 1 || size > 32) {\n        throw new Error('Invalid bytes<N> width: ' + size)\n      }\n\n      ret.push(util.setLengthRight(value, size))\n    } else if (type.startsWith('uint')) {\n      size = parseTypeN(type)\n      if ((size % 8) || (size < 8) || (size > 256)) {\n        throw new Error('Invalid uint<N> width: ' + size)\n      }\n\n      num = parseNumber(value)\n      const bitLength = util.bitLengthFromBigInt(num)\n      if (bitLength > size) {\n        throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + bitLength)\n      }\n\n      ret.push(util.bufferBEFromBigInt(num, size / 8))\n    } else if (type.startsWith('int')) {\n      size = parseTypeN(type)\n      if ((size % 8) || (size < 8) || (size > 256)) {\n        throw new Error('Invalid int<N> width: ' + size)\n      }\n\n      num = parseNumber(value)\n      const bitLength = util.bitLengthFromBigInt(num)\n      if (bitLength > size) {\n        throw new Error('Supplied int exceeds width: ' + size + ' vs ' + bitLength)\n      }\n\n      const twos = util.twosFromBigInt(num, size);\n      ret.push(util.bufferBEFromBigInt(twos, size / 8))\n    } else {\n      // FIXME: support all other types\n      throw new Error('Unsupported or invalid type: ' + type)\n    }\n  }\n\n  return Buffer.concat(ret)\n}\n\nfunction soliditySHA3 (types, values) {\n  return util.keccak(solidityPack(types, values))\n}\n\nmodule.exports = {\n  rawEncode,\n  solidityPack,\n  soliditySHA3\n}\n","/* eslint-disable */\n//prettier-ignore\n\nconst util = require('./util.cjs')\nconst abi = require('./abi.cjs')\n\nconst TYPED_MESSAGE_SCHEMA = {\n  type: 'object',\n  properties: {\n    types: {\n      type: 'object',\n      additionalProperties: {\n        type: 'array',\n        items: {\n          type: 'object',\n          properties: {\n            name: {type: 'string'},\n            type: {type: 'string'},\n          },\n          required: ['name', 'type'],\n        },\n      },\n    },\n    primaryType: {type: 'string'},\n    domain: {type: 'object'},\n    message: {type: 'object'},\n  },\n  required: ['types', 'primaryType', 'domain', 'message'],\n}\n\n/**\n * A collection of utility functions used for signing typed data\n */\nconst TypedDataUtils = {\n  /**\n   * Encodes an object by encoding and concatenating each of its members\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of an object\n   */\n  encodeData (primaryType, data, types, useV4 = true) {\n    const encodedTypes = ['bytes32']\n    const encodedValues = [this.hashType(primaryType, types)]\n\n    if(useV4) {\n      const encodeField = (name, type, value) => {\n        if (types[type] !== undefined) {\n          return ['bytes32', value == null ?\n            '0x0000000000000000000000000000000000000000000000000000000000000000' :\n            util.keccak(this.encodeData(type, value, types, useV4))]\n        }\n\n        if(value === undefined)\n          throw new Error(`missing value for field ${name} of type ${type}`)\n\n        if (type === 'bytes') {\n          return ['bytes32', util.keccak(value)]\n        }\n\n        if (type === 'string') {\n          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n          if (typeof value === 'string') {\n            value = Buffer.from(value, 'utf8')\n          }\n          return ['bytes32', util.keccak(value)]\n        }\n\n        if (type.lastIndexOf(']') === type.length - 1) {\n          const parsedType = type.slice(0, type.lastIndexOf('['))\n          const typeValuePairs = value.map(item =>\n            encodeField(name, parsedType, item))\n          return ['bytes32', util.keccak(abi.rawEncode(\n            typeValuePairs.map(([type]) => type),\n            typeValuePairs.map(([, value]) => value),\n          ))]\n        }\n\n        return [type, value]\n      }\n\n      for (const field of types[primaryType]) {\n        const [type, value] = encodeField(field.name, field.type, data[field.name])\n        encodedTypes.push(type)\n        encodedValues.push(value)\n      }\n    } else {\n      for (const field of types[primaryType]) {\n        let value = data[field.name]\n        if (value !== undefined) {\n          if (field.type === 'bytes') {\n            encodedTypes.push('bytes32')\n            value = util.keccak(value)\n            encodedValues.push(value)\n          } else if (field.type === 'string') {\n            encodedTypes.push('bytes32')\n            // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n            if (typeof value === 'string') {\n              value = Buffer.from(value, 'utf8')\n            }\n            value = util.keccak(value)\n            encodedValues.push(value)\n          } else if (types[field.type] !== undefined) {\n            encodedTypes.push('bytes32')\n            value = util.keccak(this.encodeData(field.type, value, types, useV4))\n            encodedValues.push(value)\n          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {\n            throw new Error('Arrays currently unimplemented in encodeData')\n          } else {\n            encodedTypes.push(field.type)\n            encodedValues.push(value)\n          }\n        }\n      }\n    }\n\n    return abi.rawEncode(encodedTypes, encodedValues)\n  },\n\n  /**\n   * Encodes the type of an object by encoding a comma delimited list of its members\n   *\n   * @param {string} primaryType - Root type to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of the type of an object\n   */\n  encodeType (primaryType, types) {\n    let result = ''\n    let deps = this.findTypeDependencies(primaryType, types).filter(dep => dep !== primaryType)\n    deps = [primaryType].concat(deps.sort())\n    for (const type of deps) {\n      const children = types[type]\n      if (!children) {\n        throw new Error('No type definition specified: ' + type)\n      }\n      result += type + '(' + types[type].map(({ name, type }) => type + ' ' + name).join(',') + ')'\n    }\n    return result\n  },\n\n  /**\n   * Finds all types within a type definition object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} types - Type definitions\n   * @param {Array} results - current set of accumulated types\n   * @returns {Array} - Set of all types found in the type definition\n   */\n  findTypeDependencies (primaryType, types, results = []) {\n    primaryType = primaryType.match(/^\\w*/)[0]\n    if (results.includes(primaryType) || types[primaryType] === undefined) { return results }\n    results.push(primaryType)\n    for (const field of types[primaryType]) {\n      for (const dep of this.findTypeDependencies(field.type, types, results)) {\n        !results.includes(dep) && results.push(dep)\n      }\n    }\n    return results\n  },\n\n  /**\n   * Hashes an object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to hash\n   * @param {Object} types - Type definitions\n   * @returns {Buffer} - Hash of an object\n   */\n  hashStruct (primaryType, data, types, useV4 = true) {\n    return util.keccak(this.encodeData(primaryType, data, types, useV4))\n  },\n\n  /**\n   * Hashes the type of an object\n   *\n   * @param {string} primaryType - Root type to hash\n   * @param {Object} types - Type definitions\n   * @returns {string} - Hash of an object\n   */\n  hashType (primaryType, types) {\n    return util.keccak(this.encodeType(primaryType, types))\n  },\n\n  /**\n   * Removes properties from a message object that are not defined per EIP-712\n   *\n   * @param {Object} data - typed message object\n   * @returns {Object} - typed message object with only allowed fields\n   */\n  sanitizeData (data) {\n    const sanitizedData = {}\n    for (const key in TYPED_MESSAGE_SCHEMA.properties) {\n      data[key] && (sanitizedData[key] = data[key])\n    }\n    if (sanitizedData.types) {\n      sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types)\n    }\n    return sanitizedData\n  },\n\n  /**\n   * Returns the hash of a typed message as per EIP-712 for signing\n   *\n   * @param {Object} typedData - Types message data to sign\n   * @returns {string} - sha3 hash for signing\n   */\n  hash (typedData, useV4 = true) {\n    const sanitizedData = this.sanitizeData(typedData)\n    const parts = [Buffer.from('1901', 'hex')]\n    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4))\n    if (sanitizedData.primaryType !== 'EIP712Domain') {\n      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4))\n    }\n    return util.keccak(Buffer.concat(parts))\n  },\n}\n\nmodule.exports = {\n  TYPED_MESSAGE_SCHEMA,\n  TypedDataUtils,\n\n  hashForSignTypedDataLegacy: function (msgParams) {\n    return typedSignatureHashLegacy(msgParams.data)\n  },\n\n  hashForSignTypedData_v3: function (msgParams) {\n    return TypedDataUtils.hash(msgParams.data, false)\n  },\n\n  hashForSignTypedData_v4: function (msgParams) {\n    return TypedDataUtils.hash(msgParams.data)\n  },\n}\n\n/**\n * @param typedData - Array of data along with types, as per EIP712.\n * @returns Buffer\n */\nfunction typedSignatureHashLegacy(typedData) {\n  const error = new Error('Expect argument to be non-empty array')\n  if (typeof typedData !== 'object' || !typedData.length) throw error\n\n  const data = typedData.map(function (e) {\n    return e.type === 'bytes' ? util.toBuffer(e.value) : e.value\n  })\n  const types = typedData.map(function (e) { return e.type })\n  const schema = typedData.map(function (e) {\n    if (!e.name) throw error\n    return e.type + ' ' + e.name\n  })\n\n  return abi.soliditySHA3(\n    ['bytes32', 'bytes32'],\n    [\n      abi.soliditySHA3(new Array(typedData.length).fill('string'), schema),\n      abi.soliditySHA3(types, data)\n    ]\n  )\n}","/**\n * @license React\n * use-sync-external-store-with-selector.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar React = require(\"react\");\nfunction is(x, y) {\n  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\nvar objectIs = \"function\" === typeof Object.is ? Object.is : is,\n  useSyncExternalStore = React.useSyncExternalStore,\n  useRef = React.useRef,\n  useEffect = React.useEffect,\n  useMemo = React.useMemo,\n  useDebugValue = React.useDebugValue;\nexports.useSyncExternalStoreWithSelector = function (\n  subscribe,\n  getSnapshot,\n  getServerSnapshot,\n  selector,\n  isEqual\n) {\n  var instRef = useRef(null);\n  if (null === instRef.current) {\n    var inst = { hasValue: !1, value: null };\n    instRef.current = inst;\n  } else inst = instRef.current;\n  instRef = useMemo(\n    function () {\n      function memoizedSelector(nextSnapshot) {\n        if (!hasMemo) {\n          hasMemo = !0;\n          memoizedSnapshot = nextSnapshot;\n          nextSnapshot = selector(nextSnapshot);\n          if (void 0 !== isEqual && inst.hasValue) {\n            var currentSelection = inst.value;\n            if (isEqual(currentSelection, nextSnapshot))\n              return (memoizedSelection = currentSelection);\n          }\n          return (memoizedSelection = nextSnapshot);\n        }\n        currentSelection = memoizedSelection;\n        if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;\n        var nextSelection = selector(nextSnapshot);\n        if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))\n          return (memoizedSnapshot = nextSnapshot), currentSelection;\n        memoizedSnapshot = nextSnapshot;\n        return (memoizedSelection = nextSelection);\n      }\n      var hasMemo = !1,\n        memoizedSnapshot,\n        memoizedSelection,\n        maybeGetServerSnapshot =\n          void 0 === getServerSnapshot ? null : getServerSnapshot;\n      return [\n        function () {\n          return memoizedSelector(getSnapshot());\n        },\n        null === maybeGetServerSnapshot\n          ? void 0\n          : function () {\n              return memoizedSelector(maybeGetServerSnapshot());\n            }\n      ];\n    },\n    [getSnapshot, getServerSnapshot, selector, isEqual]\n  );\n  var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);\n  useEffect(\n    function () {\n      inst.hasValue = !0;\n      inst.value = value;\n    },\n    [value]\n  );\n  useDebugValue(value);\n  return value;\n};\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/use-sync-external-store-with-selector.production.js');\n} else {\n  module.exports = require('./cjs/use-sync-external-store-with-selector.development.js');\n}\n","import{PrivyErrorCode as s}from\"../constants/error-codes.mjs\";class r extends Error{toString(){return`${this.name}: ${this.message}${this.cause?` [cause: ${this.cause}]`:\"\"}`}constructor(s,r,e,t){super(r),this.status=s,this.code=e,this.name=\"HttpError\",this.responseData=t}}class e extends r{constructor(r,e){super(400,r,e||s.INVALID_DATA),this.name=\"InvalidInputError\"}}class t extends r{constructor(s,r){super(401,s,r),this.name=\"UnauthorizedError\"}}class n extends t{constructor(r){super(r||\"User is not allowed to login to this app.\",s.ALLOWLIST_REJECTED),this.name=\"AllowlistRejectedError\"}}class o extends r{constructor(s,r){super(403,s,r),this.name=\"ForbiddenError\"}}class c extends r{constructor(s){super(404,s),this.name=\"NotFoundError\"}}class a extends r{constructor(s,r){super(408,s,r),this.name=\"RequestTimeoutError\"}}class u extends r{constructor(s){super(415,s),this.name=\"UnsupportedMediaType\"}}class i extends r{constructor(s,r){super(422,s,r),this.name=\"LegacyInvalidInputError\"}}class d extends r{constructor(r){super(429,r||\"Too many requests. Please wait to try again.\",s.TOO_MANY_REQUESTS),this.name=\"TooManyRequestsError\"}}class l extends r{constructor(r){super(409,r||\"Conflict encountered while trying to modify resource.\",s.RESOURCE_CONFLICT),this.name=\"ResourceConflictError\"}}class p extends r{constructor(r){super(400,r||\"Insufficient balance.\",s.INSUFFICIENT_FUNDS),this.name=\"InsufficientBalanceError\"}}class h extends r{constructor(s){super(402,s||\"Payment failed.\")}}class E extends r{constructor(s){super(500,s||\"Service unavailable.\"),this.name=\"InternalServerError\"}}class m extends r{constructor(r){super(400,\"Account transfer required\",s.ACCOUNT_TRANSFER_REQUIRED,r),this.data=r,this.name=\"AccountTransferRequiredError\"}}export{m as AccountTransferRequiredError,n as AllowlistRejectedError,o as ForbiddenError,r as HttpError,p as InsufficientBalanceError,E as InternalServerError,e as InvalidInputError,i as LegacyInvalidInputError,c as NotFoundError,h as PaymentFailedError,a as RequestTimeoutError,l as ResourceConflictError,d as TooManyRequestsError,t as UnauthorizedError,u as UnsupportedMediaType};\n","import { decode as base64url } from '../../runtime/base64url.js';\nimport decrypt from '../../runtime/decrypt.js';\nimport { inflate } from '../../runtime/zlib.js';\nimport { JOSEAlgNotAllowed, JOSENotSupported, JWEInvalid } from '../../util/errors.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport isObject from '../../lib/is_object.js';\nimport decryptKeyManagement from '../../lib/decrypt_key_management.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport generateCek from '../../lib/cek.js';\nimport validateCrit from '../../lib/validate_crit.js';\nimport validateAlgorithms from '../../lib/validate_algorithms.js';\nexport async function flattenedDecrypt(jwe, key, options) {\n    var _a;\n    if (!isObject(jwe)) {\n        throw new JWEInvalid('Flattened JWE must be an object');\n    }\n    if (jwe.protected === undefined && jwe.header === undefined && jwe.unprotected === undefined) {\n        throw new JWEInvalid('JOSE Header missing');\n    }\n    if (typeof jwe.iv !== 'string') {\n        throw new JWEInvalid('JWE Initialization Vector missing or incorrect type');\n    }\n    if (typeof jwe.ciphertext !== 'string') {\n        throw new JWEInvalid('JWE Ciphertext missing or incorrect type');\n    }\n    if (typeof jwe.tag !== 'string') {\n        throw new JWEInvalid('JWE Authentication Tag missing or incorrect type');\n    }\n    if (jwe.protected !== undefined && typeof jwe.protected !== 'string') {\n        throw new JWEInvalid('JWE Protected Header incorrect type');\n    }\n    if (jwe.encrypted_key !== undefined && typeof jwe.encrypted_key !== 'string') {\n        throw new JWEInvalid('JWE Encrypted Key incorrect type');\n    }\n    if (jwe.aad !== undefined && typeof jwe.aad !== 'string') {\n        throw new JWEInvalid('JWE AAD incorrect type');\n    }\n    if (jwe.header !== undefined && !isObject(jwe.header)) {\n        throw new JWEInvalid('JWE Shared Unprotected Header incorrect type');\n    }\n    if (jwe.unprotected !== undefined && !isObject(jwe.unprotected)) {\n        throw new JWEInvalid('JWE Per-Recipient Unprotected Header incorrect type');\n    }\n    let parsedProt;\n    if (jwe.protected) {\n        try {\n            const protectedHeader = base64url(jwe.protected);\n            parsedProt = JSON.parse(decoder.decode(protectedHeader));\n        }\n        catch {\n            throw new JWEInvalid('JWE Protected Header is invalid');\n        }\n    }\n    if (!isDisjoint(parsedProt, jwe.header, jwe.unprotected)) {\n        throw new JWEInvalid('JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jwe.header,\n        ...jwe.unprotected,\n    };\n    validateCrit(JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);\n    if (joseHeader.zip !== undefined) {\n        if (!parsedProt || !parsedProt.zip) {\n            throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n        }\n        if (joseHeader.zip !== 'DEF') {\n            throw new JOSENotSupported('Unsupported JWE \"zip\" (Compression Algorithm) Header Parameter value');\n        }\n    }\n    const { alg, enc } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new JWEInvalid('missing JWE Algorithm (alg) in JWE Header');\n    }\n    if (typeof enc !== 'string' || !enc) {\n        throw new JWEInvalid('missing JWE Encryption Algorithm (enc) in JWE Header');\n    }\n    const keyManagementAlgorithms = options && validateAlgorithms('keyManagementAlgorithms', options.keyManagementAlgorithms);\n    const contentEncryptionAlgorithms = options &&\n        validateAlgorithms('contentEncryptionAlgorithms', options.contentEncryptionAlgorithms);\n    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {\n        throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter not allowed');\n    }\n    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {\n        throw new JOSEAlgNotAllowed('\"enc\" (Encryption Algorithm) Header Parameter not allowed');\n    }\n    let encryptedKey;\n    if (jwe.encrypted_key !== undefined) {\n        try {\n            encryptedKey = base64url(jwe.encrypted_key);\n        }\n        catch {\n            throw new JWEInvalid('Failed to base64url decode the encrypted_key');\n        }\n    }\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jwe);\n        resolvedKey = true;\n    }\n    let cek;\n    try {\n        cek = await decryptKeyManagement(alg, key, encryptedKey, joseHeader, options);\n    }\n    catch (err) {\n        if (err instanceof TypeError || err instanceof JWEInvalid || err instanceof JOSENotSupported) {\n            throw err;\n        }\n        cek = generateCek(enc);\n    }\n    let iv;\n    let tag;\n    try {\n        iv = base64url(jwe.iv);\n    }\n    catch {\n        throw new JWEInvalid('Failed to base64url decode the iv');\n    }\n    try {\n        tag = base64url(jwe.tag);\n    }\n    catch {\n        throw new JWEInvalid('Failed to base64url decode the tag');\n    }\n    const protectedHeader = encoder.encode((_a = jwe.protected) !== null && _a !== void 0 ? _a : '');\n    let additionalData;\n    if (jwe.aad !== undefined) {\n        additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(jwe.aad));\n    }\n    else {\n        additionalData = protectedHeader;\n    }\n    let ciphertext;\n    try {\n        ciphertext = base64url(jwe.ciphertext);\n    }\n    catch {\n        throw new JWEInvalid('Failed to base64url decode the ciphertext');\n    }\n    let plaintext = await decrypt(enc, cek, ciphertext, iv, tag, additionalData);\n    if (joseHeader.zip === 'DEF') {\n        plaintext = await ((options === null || options === void 0 ? void 0 : options.inflateRaw) || inflate)(plaintext);\n    }\n    const result = { plaintext };\n    if (jwe.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jwe.aad !== undefined) {\n        try {\n            result.additionalAuthenticatedData = base64url(jwe.aad);\n        }\n        catch {\n            throw new JWEInvalid('Failed to base64url decode the aad');\n        }\n    }\n    if (jwe.unprotected !== undefined) {\n        result.sharedUnprotectedHeader = jwe.unprotected;\n    }\n    if (jwe.header !== undefined) {\n        result.unprotectedHeader = jwe.header;\n    }\n    if (resolvedKey) {\n        return { ...result, key };\n    }\n    return result;\n}\n","import { JWEInvalid } from '../util/errors.js';\nimport { bitLength } from './iv.js';\nconst checkIvLength = (enc, iv) => {\n    if (iv.length << 3 !== bitLength(enc)) {\n        throw new JWEInvalid('Invalid Initialization Vector length');\n    }\n};\nexport default checkIvLength;\n","function unusable(name, prop = 'algorithm.name') {\n    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);\n}\nfunction isAlgorithm(algorithm, name) {\n    return algorithm.name === name;\n}\nfunction getHashLength(hash) {\n    return parseInt(hash.name.slice(4), 10);\n}\nfunction getNamedCurve(alg) {\n    switch (alg) {\n        case 'ES256':\n            return 'P-256';\n        case 'ES384':\n            return 'P-384';\n        case 'ES512':\n            return 'P-521';\n        default:\n            throw new Error('unreachable');\n    }\n}\nfunction checkUsage(key, usages) {\n    if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {\n        let msg = 'CryptoKey does not support this operation, its usages must include ';\n        if (usages.length > 2) {\n            const last = usages.pop();\n            msg += `one of ${usages.join(', ')}, or ${last}.`;\n        }\n        else if (usages.length === 2) {\n            msg += `one of ${usages[0]} or ${usages[1]}.`;\n        }\n        else {\n            msg += `${usages[0]}.`;\n        }\n        throw new TypeError(msg);\n    }\n}\nexport function checkSigCryptoKey(key, alg, ...usages) {\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512': {\n            if (!isAlgorithm(key.algorithm, 'HMAC'))\n                throw unusable('HMAC');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'RS256':\n        case 'RS384':\n        case 'RS512': {\n            if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))\n                throw unusable('RSASSA-PKCS1-v1_5');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'PS256':\n        case 'PS384':\n        case 'PS512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-PSS'))\n                throw unusable('RSA-PSS');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'EdDSA': {\n            if (key.algorithm.name !== 'Ed25519' && key.algorithm.name !== 'Ed448') {\n                throw unusable('Ed25519 or Ed448');\n            }\n            break;\n        }\n        case 'ES256':\n        case 'ES384':\n        case 'ES512': {\n            if (!isAlgorithm(key.algorithm, 'ECDSA'))\n                throw unusable('ECDSA');\n            const expected = getNamedCurve(alg);\n            const actual = key.algorithm.namedCurve;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.namedCurve');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usages);\n}\nexport function checkEncCryptoKey(key, alg, ...usages) {\n    switch (alg) {\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM': {\n            if (!isAlgorithm(key.algorithm, 'AES-GCM'))\n                throw unusable('AES-GCM');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            if (!isAlgorithm(key.algorithm, 'AES-KW'))\n                throw unusable('AES-KW');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'ECDH': {\n            switch (key.algorithm.name) {\n                case 'ECDH':\n                case 'X25519':\n                case 'X448':\n                    break;\n                default:\n                    throw unusable('ECDH, X25519, or X448');\n            }\n            break;\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW':\n            if (!isAlgorithm(key.algorithm, 'PBKDF2'))\n                throw unusable('PBKDF2');\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-OAEP'))\n                throw unusable('RSA-OAEP');\n            const expected = parseInt(alg.slice(9), 10) || 1;\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usages);\n}\n","function message(msg, actual, ...types) {\n    if (types.length > 2) {\n        const last = types.pop();\n        msg += `one of type ${types.join(', ')}, or ${last}.`;\n    }\n    else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}.`;\n    }\n    else {\n        msg += `of type ${types[0]}.`;\n    }\n    if (actual == null) {\n        msg += ` Received ${actual}`;\n    }\n    else if (typeof actual === 'function' && actual.name) {\n        msg += ` Received function ${actual.name}`;\n    }\n    else if (typeof actual === 'object' && actual != null) {\n        if (actual.constructor && actual.constructor.name) {\n            msg += ` Received an instance of ${actual.constructor.name}`;\n        }\n    }\n    return msg;\n}\nexport default (actual, ...types) => {\n    return message('Key must be ', actual, ...types);\n};\nexport function withAlg(alg, actual, ...types) {\n    return message(`Key for the ${alg} algorithm must be `, actual, ...types);\n}\n","const isDisjoint = (...headers) => {\n    const sources = headers.filter(Boolean);\n    if (sources.length === 0 || sources.length === 1) {\n        return true;\n    }\n    let acc;\n    for (const header of sources) {\n        const parameters = Object.keys(header);\n        if (!acc || acc.size === 0) {\n            acc = new Set(parameters);\n            continue;\n        }\n        for (const parameter of parameters) {\n            if (acc.has(parameter)) {\n                return false;\n            }\n            acc.add(parameter);\n        }\n    }\n    return true;\n};\nexport default isDisjoint;\n","import { Buffer } from 'buffer';\nimport { KeyObject, createDecipheriv, createCipheriv, createSecretKey } from 'crypto';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { concat } from '../lib/buffer_utils.js';\nimport { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport isKeyObject from './is_key_object.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport supported from './ciphers.js';\nimport { types } from './is_key_like.js';\nfunction checkKeySize(key, alg) {\n    if (key.symmetricKeySize << 3 !== parseInt(alg.slice(1, 4), 10)) {\n        throw new TypeError(`Invalid key size for alg: ${alg}`);\n    }\n}\nfunction ensureKeyObject(key, alg, usage) {\n    if (isKeyObject(key)) {\n        return key;\n    }\n    if (key instanceof Uint8Array) {\n        return createSecretKey(key);\n    }\n    if (isCryptoKey(key)) {\n        checkEncCryptoKey(key, alg, usage);\n        return KeyObject.from(key);\n    }\n    throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));\n}\nexport const wrap = (alg, key, cek) => {\n    const size = parseInt(alg.slice(1, 4), 10);\n    const algorithm = `aes${size}-wrap`;\n    if (!supported(algorithm)) {\n        throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n    const keyObject = ensureKeyObject(key, alg, 'wrapKey');\n    checkKeySize(keyObject, alg);\n    const cipher = createCipheriv(algorithm, keyObject, Buffer.alloc(8, 0xa6));\n    return concat(cipher.update(cek), cipher.final());\n};\nexport const unwrap = (alg, key, encryptedKey) => {\n    const size = parseInt(alg.slice(1, 4), 10);\n    const algorithm = `aes${size}-wrap`;\n    if (!supported(algorithm)) {\n        throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n    const keyObject = ensureKeyObject(key, alg, 'unwrapKey');\n    checkKeySize(keyObject, alg);\n    const cipher = createDecipheriv(algorithm, keyObject, Buffer.alloc(8, 0xa6));\n    return concat(cipher.update(encryptedKey), cipher.final());\n};\n","const [major, minor] = process.versions.node.split('.').map((str) => parseInt(str, 10));\nexport const oneShotCallback = major >= 16 || (major === 15 && minor >= 13);\nexport const rsaPssParams = !('electron' in process.versions) && (major >= 17 || (major === 16 && minor >= 9));\nexport const jwkExport = major >= 16 || (major === 15 && minor >= 9);\nexport const jwkImport = major >= 16 || (major === 15 && minor >= 12);\n","const validateAlgorithms = (option, algorithms) => {\n    if (algorithms !== undefined &&\n        (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== 'string'))) {\n        throw new TypeError(`\"${option}\" option must be an array of strings`);\n    }\n    if (!algorithms) {\n        return undefined;\n    }\n    return new Set(algorithms);\n};\nexport default validateAlgorithms;\n","const tagInteger = 0x02;\nconst tagSequence = 0x30;\nexport default class Asn1SequenceDecoder {\n    constructor(buffer) {\n        if (buffer[0] !== tagSequence) {\n            throw new TypeError();\n        }\n        this.buffer = buffer;\n        this.offset = 1;\n        const len = this.decodeLength();\n        if (len !== buffer.length - this.offset) {\n            throw new TypeError();\n        }\n    }\n    decodeLength() {\n        let length = this.buffer[this.offset++];\n        if (length & 0x80) {\n            const nBytes = length & ~0x80;\n            length = 0;\n            for (let i = 0; i < nBytes; i++)\n                length = (length << 8) | this.buffer[this.offset + i];\n            this.offset += nBytes;\n        }\n        return length;\n    }\n    unsignedInteger() {\n        if (this.buffer[this.offset++] !== tagInteger) {\n            throw new TypeError();\n        }\n        let length = this.decodeLength();\n        if (this.buffer[this.offset] === 0) {\n            this.offset++;\n            length--;\n        }\n        const result = this.buffer.slice(this.offset, this.offset + length);\n        this.offset += length;\n        return result;\n    }\n    end() {\n        if (this.offset !== this.buffer.length) {\n            throw new TypeError();\n        }\n    }\n}\n","const minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst year = day * 365.25;\nconst REGEX = /^(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;\nexport default (str) => {\n    const matched = REGEX.exec(str);\n    if (!matched) {\n        throw new TypeError('Invalid time period format');\n    }\n    const value = parseFloat(matched[1]);\n    const unit = matched[2].toLowerCase();\n    switch (unit) {\n        case 'sec':\n        case 'secs':\n        case 'second':\n        case 'seconds':\n        case 's':\n            return Math.round(value);\n        case 'minute':\n        case 'minutes':\n        case 'min':\n        case 'mins':\n        case 'm':\n            return Math.round(value * minute);\n        case 'hour':\n        case 'hours':\n        case 'hr':\n        case 'hrs':\n        case 'h':\n            return Math.round(value * hour);\n        case 'day':\n        case 'days':\n        case 'd':\n            return Math.round(value * day);\n        case 'week':\n        case 'weeks':\n        case 'w':\n            return Math.round(value * week);\n        default:\n            return Math.round(value * year);\n    }\n};\n","import digest from '../runtime/digest.js';\nimport { encode as base64url } from '../runtime/base64url.js';\nimport { JOSENotSupported, JWKInvalid } from '../util/errors.js';\nimport { encoder } from '../lib/buffer_utils.js';\nimport isObject from '../lib/is_object.js';\nconst check = (value, description) => {\n    if (typeof value !== 'string' || !value) {\n        throw new JWKInvalid(`${description} missing or invalid`);\n    }\n};\nexport async function calculateJwkThumbprint(jwk, digestAlgorithm) {\n    if (!isObject(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : (digestAlgorithm = 'sha256');\n    if (digestAlgorithm !== 'sha256' &&\n        digestAlgorithm !== 'sha384' &&\n        digestAlgorithm !== 'sha512') {\n        throw new TypeError('digestAlgorithm must one of \"sha256\", \"sha384\", or \"sha512\"');\n    }\n    let components;\n    switch (jwk.kty) {\n        case 'EC':\n            check(jwk.crv, '\"crv\" (Curve) Parameter');\n            check(jwk.x, '\"x\" (X Coordinate) Parameter');\n            check(jwk.y, '\"y\" (Y Coordinate) Parameter');\n            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };\n            break;\n        case 'OKP':\n            check(jwk.crv, '\"crv\" (Subtype of Key Pair) Parameter');\n            check(jwk.x, '\"x\" (Public Key) Parameter');\n            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };\n            break;\n        case 'RSA':\n            check(jwk.e, '\"e\" (Exponent) Parameter');\n            check(jwk.n, '\"n\" (Modulus) Parameter');\n            components = { e: jwk.e, kty: jwk.kty, n: jwk.n };\n            break;\n        case 'oct':\n            check(jwk.k, '\"k\" (Key Value) Parameter');\n            components = { k: jwk.k, kty: jwk.kty };\n            break;\n        default:\n            throw new JOSENotSupported('\"kty\" (Key Type) Parameter missing or unsupported');\n    }\n    const data = encoder.encode(JSON.stringify(components));\n    return base64url(await digest(digestAlgorithm, data));\n}\nexport async function calculateJwkThumbprintUri(jwk, digestAlgorithm) {\n    digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : (digestAlgorithm = 'sha256');\n    const thumbprint = await calculateJwkThumbprint(jwk, digestAlgorithm);\n    return `urn:ietf:params:oauth:jwk-thumbprint:sha-${digestAlgorithm.slice(-3)}:${thumbprint}`;\n}\n","import * as http from 'http';\nimport * as https from 'https';\nimport { once } from 'events';\nimport { JOSEError, JWKSTimeout } from '../util/errors.js';\nimport { concat, decoder } from '../lib/buffer_utils.js';\nconst fetchJwks = async (url, timeout, options) => {\n    let get;\n    switch (url.protocol) {\n        case 'https:':\n            get = https.get;\n            break;\n        case 'http:':\n            get = http.get;\n            break;\n        default:\n            throw new TypeError('Unsupported URL protocol.');\n    }\n    const { agent, headers } = options;\n    const req = get(url.href, {\n        agent,\n        timeout,\n        headers,\n    });\n    const [response] = (await Promise.race([once(req, 'response'), once(req, 'timeout')]));\n    if (!response) {\n        req.destroy();\n        throw new JWKSTimeout();\n    }\n    if (response.statusCode !== 200) {\n        throw new JOSEError('Expected 200 OK from the JSON Web Key Set HTTP response');\n    }\n    const parts = [];\n    for await (const part of response) {\n        parts.push(part);\n    }\n    try {\n        return JSON.parse(decoder.decode(concat(...parts)));\n    }\n    catch {\n        throw new JOSEError('Failed to parse the JSON Web Key Set HTTP response as JSON');\n    }\n};\nexport default fetchJwks;\n","import { decode as base64url } from './base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport isObject from '../lib/is_object.js';\nexport function decodeProtectedHeader(token) {\n    let protectedB64u;\n    if (typeof token === 'string') {\n        const parts = token.split('.');\n        if (parts.length === 3 || parts.length === 5) {\n            ;\n            [protectedB64u] = parts;\n        }\n    }\n    else if (typeof token === 'object' && token) {\n        if ('protected' in token) {\n            protectedB64u = token.protected;\n        }\n        else {\n            throw new TypeError('Token does not contain a Protected Header');\n        }\n    }\n    try {\n        if (typeof protectedB64u !== 'string' || !protectedB64u) {\n            throw new Error();\n        }\n        const result = JSON.parse(decoder.decode(base64url(protectedB64u)));\n        if (!isObject(result)) {\n            throw new Error();\n        }\n        return result;\n    }\n    catch {\n        throw new TypeError('Invalid Token or Protected Header formatting');\n    }\n}\n","import{jsxs as e,jsx as t,Fragment as n}from\"react/jsx-runtime\";import r,{useContext as a,createContext as i,useRef as s,useState as o,useMemo as l,useEffect as c,Suspense as d,lazy as u,useCallback as h}from\"react\";import p,{DEFAULT_SUPPORTED_CHAIN_IDS as w,rpc as m,PrivyClientError as y,getWallet as g,updateWallet as f,generateAuthorizationSignature as v}from\"@privy-io/js-sdk-core\";import{v4 as A}from\"uuid\";import*as k from\"jose\";import{base64url as C}from\"jose\";import{u as T,a as _,g as b,i as S,b as E,c as I,d as P,e as W,f as U,h as N,j as O,P as R,M,k as x,l as F,m as L}from\"./get-is-unified-wallet-gMDXpX6C.mjs\";import D from\"eventemitter3\";import{E as j,P as z,t as q,p as H,H as V,u as B,L as K,g as $,s as G,a as Y,b as J,c as Q,i as Z,d as X,e as ee,f as te,h as ne,j as re,k as ae,R as ie,l as se,m as oe,n as le,M as ce,o as de,q as ue,S as he,r as pe,v as we,w as me,x as ye}from\"./useActiveWallet-BeOB3HTh.mjs\";import{u as ge,t as fe,g as ve,U as Ae}from\"./useWallets-kObl6ZLS.mjs\";import{P as ke,a as Ce,f as Te,b as _e,c as be,n as Se,d as Ee,u as Ie,e as Pe,g as We,I as Ue,h as Ne,i as Oe}from\"./internal-context-e-Eni5bG.mjs\";import{f as Re,u as Me,W as xe,i as Fe,a as Le,p as De,e as je,P as ze,b as qe,l as He}from\"./prepareFundingModalData-BVTcQcmw.mjs\";import{createCoinbaseWalletSDK as Ve}from\"@coinbase/wallet-sdk\";import{toViemTransactionSerializable as Be,STRING_TO_NUMBER_TXN_TYPE as Ke}from\"@privy-io/ethereum\";import{P as $e,C as Ge,a as Ye,H as Je,O as Qe,S as Ze,u as Xe,b as et,c as tt,D as nt,d as rt,g as at,V as it,R as st,e as ot,f as lt,h as ct,i as dt,j as ut,I as ht,k as pt,l as wt,m as mt,W as yt}from\"./context-DRLoVlsO.mjs\";import{createStore as gt}from\"mipd\";import{isMobile as ft,isIOS as vt,isAndroid as At,isSafari as kt}from\"react-device-detect\";import{toHex as Ct,isAddress as Tt,getAddress as _t,isHex as bt,hashAuthorization as St}from\"viem/utils\";import{trigger as Et}from\"@privy-io/popup\";import{u as It,p as Pt,a as Wt,b as Ut,f as Nt,c as Ot,d as Rt,e as Mt,o as xt,g as Ft,h as Lt,i as Dt,j as jt,k as zt,l as qt,m as Ht,n as Vt,q as Bt,r as Kt,s as $t,t as Gt,v as Yt,w as Jt,x as Qt,y as Zt,z as Xt,A as en,B as tn,C as nn,D as rn,E as an,F as sn,G as on,H as ln,I as cn,J as dn,K as un,L as hn,M as pn,N as wn,O as mn,P as yn,Q as gn,R as fn,S as vn,T as An,U as kn,V as Cn,W as Tn,X as _n,Y as bn,Z as Sn,_ as En,$ as In,a0 as Pn,a1 as Wn,a2 as Un,a3 as Nn,a4 as On}from\"./paths-3HW55qZg.mjs\";import{o as Rn,p as Mn,d as xn,r as Fn,b as Ln,s as Dn,a as jn,u as zn,c as qn,S as Hn,e as Vn,P as Bn,f as Kn}from\"./usePrivy-BWtc2XF-.mjs\";import{base64 as $n}from\"@scure/base\";import{styled as Gn,createGlobalStyle as Yn,css as Jn}from\"styled-components\";import{u as Qn,a as Zn,p as Xn,e as er,P as tr}from\"./events-context-CI0iqAXA.mjs\";import{create as nr}from\"zustand\";import{Transition as rr,Dialog as ar,TransitionChild as ir,DialogPanel as sr}from\"@headlessui/react\";import{EthereumProvider as or,OPTIONAL_METHODS as lr,OPTIONAL_EVENTS as cr}from\"@walletconnect/ethereum-provider\";import{constructURL as dr}from\"@privy-io/urls\";import{toHex as ur,zeroAddress as hr,getAddress as pr,createWalletClient as wr,http as mr,parseSignature as yr}from\"viem\";import{g as gr,a as fr}from\"./getPublicClient-A9RSftUZ.mjs\";import{ofetch as vr}from\"ofetch\";import Ar from\"js-cookie\";import{F as kr}from\"./frame-CwE9r3cT.mjs\";import{MfaAuthPasskeyVerify as Cr,MfaAuthPasskeyInit as Tr,MfaAuthTotpVerify as _r,MfaAuthPasskeyEnrollment as br,MfaAuthTotpUnenroll as Sr,MfaAuthTotpEnroll as Er,MfaAuthTotpInit as Ir}from\"@privy-io/routes\";import{selectPaymentRequirements as Pr,createPaymentHeader as Wr}from\"x402/client\";import{InvalidInputError as Ur}from\"@privy-io/api-base\";import{toAccount as Nr}from\"viem/accounts\";import{u as Or}from\"./use-sign-with-user-signer-eEm9Olt_.mjs\";import\"./getEmbeddedConnectedWallet-CM6cDQCS.mjs\";class Rr{static parse(e){try{return new Rr(e)}catch(e){return null}}static throwIfNotWellFormedJwt(e){return k.decodeJwt(e),e}get subject(){return this._decoded.sub}get expiration(){return this._decoded.exp}get issuer(){return this._decoded.iss}get audience(){return this._decoded.aud}isExpired(e=0){return Date.now()>=1e3*(this.expiration-e)}constructor(e){this.value=e,this._decoded=k.decodeJwt(e)}}class Mr extends Rr{static parse(e){try{return new Mr(e)}catch(e){return null}}get appId(){return this._decoded.aid?this._decoded.aid:this.audience}}const xr=({style:n,...r})=>/*#__PURE__*/e(\"svg\",{viewBox:\"0 0 1024 1024\",fill:\"none\",xmlns:\"http://www.w3.org/2000/svg\",style:{height:\"28px\",width:\"28px\",...n},...r,children:[/*#__PURE__*/t(\"rect\",{width:\"1024\",height:\"1024\",fill:\"#0052FF\",rx:100,ry:100}),/*#__PURE__*/t(\"path\",{fillRule:\"evenodd\",clipRule:\"evenodd\",d:\"M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z\",fill:\"white\"})]}),Fr=\"data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PScwIDAgMTAyNCAxMDI0JyBmaWxsPSdub25lJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHN0eWxlPSdoZWlnaHQ6MjhweDt3aWR0aDoyOHB4Jz48cmVjdCB3aWR0aD0nMTAyNCcgaGVpZ2h0PScxMDI0JyBmaWxsPScjMDA1MkZGJyByeD0nMTAwJyByeT0nMTAwJz48L3JlY3Q+PHBhdGggZmlsbC1ydWxlPSdldmVub2RkJyBjbGlwLXJ1bGU9J2V2ZW5vZGQnIGQ9J00xNTIgNTEyQzE1MiA3MTAuODIzIDMxMy4xNzcgODcyIDUxMiA4NzJDNzEwLjgyMyA4NzIgODcyIDcxMC44MjMgODcyIDUxMkM4NzIgMzEzLjE3NyA3MTAuODIzIDE1MiA1MTIgMTUyQzMxMy4xNzcgMTUyIDE1MiAzMTMuMTc3IDE1MiA1MTJaTTQyMCAzOTZDNDA2Ljc0NSAzOTYgMzk2IDQwNi43NDUgMzk2IDQyMFY2MDRDMzk2IDYxNy4yNTUgNDA2Ljc0NSA2MjggNDIwIDYyOEg2MDRDNjE3LjI1NSA2MjggNjI4IDYxNy4yNTUgNjI4IDYwNFY0MjBDNjI4IDQwNi43NDUgNjE3LjI1NSAzOTYgNjA0IDM5Nkg0MjBaJyBmaWxsPSd3aGl0ZSc+PC9wYXRoPjwvc3ZnPg==\",Lr=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAALZJREFUaEPtmjEOhDAMBNc/O14GvOzys3CAKK6eAlmaVGl2Zc+kTOU685vkc9/bnD2prZK5/TZY24z9P+g4F5hNh7/GdoG37WlAA5CATwgCxHENYISwQAMQII5rACOEBRqAAHFcAxghLNAABIjjGsAIYYEGIEAc1wBGCAs0AAHiuAYwQligAQgQxzWAEcICDUCAOK4BjBAWaAACxHENYISwQAMQII6fBjr+VHkW3+u+tfyxMpJaDgYzYxb/ALZVAAAAAElFTkSuQmCC\";let Dr,jr;class zr extends j{async initialize(){await this.importPromise,await this.syncAccounts(),this.initialized=!0,this.emit(\"initialized\")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}disconnect(){this.proxyProvider.walletProvider.disconnect(),this.onDisconnect()}get walletBranding(){return{name:this.displayName,icon:Lr,id:\"com.coinbase.wallet\"}}async promptConnection(){try{await this.importPromise;let e=await this.proxyProvider.request({method:\"eth_requestAccounts\"});if(!e||0===e.length||!e[0])throw new ke(\"Unable to retrieve accounts\");this.connected=!0,await this.syncAccounts([e[0]])}catch(e){throw Re(e)}}constructor(e,t,n,r,a){super(\"base_account\",e,t,n),this.connectorType=\"base_account\",this.walletClientType=\"base_account\",this.displayName=\"Base\",this.setBaseAccountSdk=a,this.proxyProvider=new z(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.baseAccountConfig={...r,appChainIds:[t.id].concat(e.map((e=>e.id)))},Dr?(this.proxyProvider.setWalletProvider(Dr.getProvider()),this.setBaseAccountSdk(Dr)):this.importPromise=import(\"@base-org/account\").then((({createBaseAccountSDK:e})=>{Dr=e(this.baseAccountConfig),this.proxyProvider.setWalletProvider(Dr.getProvider()),this.setBaseAccountSdk(Dr)})).catch(console.error)}}let qr=[1,11155111,137,10,8453,84532,42161,7777777,43114,56];class Hr extends j{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit(\"initialized\")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}disconnect(){this.proxyProvider.walletProvider.disconnect(),this.onDisconnect()}get walletBranding(){return{name:this.displayName,icon:Fr,id:\"com.coinbase.wallet\"}}async promptConnection(){try{let e=await this.proxyProvider.request({method:\"eth_requestAccounts\"});if(!e||0===e.length||!e[0])throw new ke(\"Unable to retrieve accounts\");this.connected=!0,await this.syncAccounts([e[0]])}catch(e){throw Re(e)}}updateConnectionPreference(e){this.coinbaseWalletConfig={...this.coinbaseWalletConfig,preference:{...this.coinbaseWalletConfig.preference,options:e}},this.walletClientType=\"smartWalletOnly\"===e?\"coinbase_smart_wallet\":\"coinbase_wallet\",jr=Ve({...this.coinbaseWalletConfig}),this.proxyProvider.setWalletProvider(jr.getProvider())}constructor(e,t,n,r){if(super(\"coinbase_wallet\",e,t,n),this.connectorType=\"coinbase_wallet\",this.displayName=\"Coinbase Wallet\",this.proxyProvider=new z(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.coinbaseWalletConfig={...r,appChainIds:[t.id].concat(e.map((e=>e.id)))},this.walletClientType=\"smartWalletOnly\"===this.coinbaseWalletConfig.preference?.options?\"coinbase_smart_wallet\":\"coinbase_wallet\",\"coinbase_smart_wallet\"===this.walletClientType&&(this.displayName=\"Coinbase Smart Wallet\"),!jr){let e=\"eoaOnly\"!==this.coinbaseWalletConfig.preference?.options?(this.coinbaseWalletConfig.appChainIds??[]).filter((e=>!qr.includes(e))):[];e.length>0&&!e.every((e=>w.has(e)))&&console.info(`The configured chains are not supported by Coinbase Smart Wallet: ${e.join(\", \")}`),jr=Ve(this.coinbaseWalletConfig)}this.proxyProvider.setWalletProvider(jr.getProvider())}}const Vr=({...e})=>/*#__PURE__*/t(\"svg\",{width:\"15\",height:\"15\",viewBox:\"0 0 15 15\",fill:\"none\",xmlns:\"http://www.w3.org/2000/svg\",...e,children:/*#__PURE__*/t(\"path\",{fillRule:\"evenodd\",clipRule:\"evenodd\",d:\"M2.37126 11.0323C2.37126 12.696 3.90598 13.4421 5.40654 13.4468C8.91753 13.4468 12.8021 11.2897 12.7819 7.67984C12.7673 5.07728 10.3748 2.86167 7.54357 2.88296C4.8495 2.88296 2.21821 4.6411 2.21803 7.03628C2.21803 7.67951 2.58722 8.30178 3.55231 8.37184C2.74763 9.16826 2.37126 10.1225 2.37126 11.0323ZM7.55283 8.68012C8.11562 8.68012 8.57186 8.13217 8.57186 7.45624C8.57186 6.78032 8.11562 6.23237 7.55283 6.23237C6.99003 6.23237 6.53379 6.78032 6.53379 7.45624C6.53379 8.13217 6.99003 8.68012 7.55283 8.68012ZM10.4747 8.68012C11.0375 8.68012 11.4937 8.13217 11.4937 7.45625C11.4937 6.78032 11.0375 6.23237 10.4747 6.23237C9.91186 6.23237 9.45562 6.78032 9.45562 7.45625C9.45562 8.13217 9.91186 8.68012 10.4747 8.68012Z\",fill:e.color||\"var(--privy-color-foreground-3)\"})});class Br extends j{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit(\"initialized\")}async connect(e){return await this.isConnected()?(await this.proxyProvider.request({method:\"wallet_switchEthereumChain\",params:[q(e?.chainId||\"0x1\")]}),this.getConnectedWallet()):null}get walletBranding(){return{name:\"Privy Wallet\",icon:Vr,id:\"io.privy.wallet\"}}disconnect(){this.connected=!1}async promptConnection(){}constructor({provider:e,chains:t,defaultChain:n,rpcConfig:r,imported:a,walletIndex:i}){super(\"privy\",t,n,r),this.connectorType=\"embedded\",this.proxyProvider=e,this.walletIndex=i,a&&(this.connectorType=\"embedded_imported\"),this.subscribeListeners()}}async function Kr(){let e=Ws();return e?e.getAccessToken():Promise.resolve(Me.get($e)||Me.get(Ge)||null)}const $r=[\"eth_sign\",\"eth_populateTransactionRequest\",\"eth_signTransaction\",\"personal_sign\",\"eth_signTypedData_v4\",\"csw_signUserOperation\",\"secp256k1_sign\"];function Gr(e){return e?{\"privy-ui\":\"t\"}:void 0}class Yr{async authenticate(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");if(!this.meta.email||!this.meta.emailCode)throw new Ce(\"Email and email code must be set prior to calling authenticate.\");try{return await this.api.post(Pt,{email:this.meta.email,code:this.meta.emailCode,mode:this.meta.disableSignup?\"no-signup\":\"login-or-sign-up\"})}catch(e){throw Te(e)}}async link(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");if(!this.meta.email||!this.meta.emailCode)throw new Ce(\"Email and email code must be set prior to calling authenticate.\");try{return await this.api.post(Wt,{email:this.meta.email,code:this.meta.emailCode})}catch(e){throw Te(e)}}async sendCodeEmail({email:e,captchaToken:t,withPrivyUi:n}){if(!this.api)throw new Ce(\"Auth flow has no API instance\");if(e&&(this.meta.email=e),t&&(this.meta.captchaToken=t),!this.meta.email)throw new Ce(\"Email must be set when initialzing authentication.\");let r=Gr(n);try{return await this.api.post(Ut,{email:this.meta.email,token:this.meta.captchaToken},{headers:{...r}})}catch(e){throw Te(e)}}constructor({email:e,captchaToken:t,disableSignup:n}){this.meta={email:e,captchaToken:t,disableSignup:n??!1}}}class Jr extends Yr{async link(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");if(!this.meta.email||!this.meta.emailCode||!this.meta.oldAddress)throw new Ce(\"Email, email code, and an old email address must be set prior to calling update.\");try{return await this.api.post(It,{oldAddress:this.meta.oldAddress,newAddress:this.meta.email,code:this.meta.emailCode})}catch(e){throw Te(e)}}constructor(e,t,n){super({email:t,captchaToken:n}),this.meta={email:t,captchaToken:n,oldAddress:e,disableSignup:!1}}}class Qr{execute(e){return null===this.promise&&(this.promise=(async()=>{try{return await this.fn(e)}finally{this.promise=null}})()),this.promise}constructor(e){this.promise=null,this.fn=e}}class Zr{get meta(){return this._meta}async authenticate(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");if(!this.meta.channelToken)throw new Ce(\"Auth flow must be initialized first\");try{let e=await this.api.post(Nt,{channel_token:this.meta.channelToken,message:this.message,signature:this.signature,fid:this.fid,mode:this.meta.disableSignup?\"no-signup\":\"login-or-sign-up\"});if(!e)throw new Ce(\"No response from authentication\");return e}catch(e){throw Te(e)}}async link(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");try{return await this.api.post(Ot,{channel_token:this.meta.channelToken,message:this.message,signature:this.signature,fid:this.fid})}catch(e){throw Te(e)}}async _startChannelOnce(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");let e=await this.api.post(Rt,{token:this.captchaToken});ft&&!vt&&e.connect_uri&&Rn(e.connect_uri,\"_blank\"),this._meta={...this._meta,connectUri:e.connect_uri,channelToken:e.channel_token}}async initializeFarcasterConnect(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");await this.startChannelOnce.execute()}async _pollForReady(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");if(!this.meta.channelToken)throw new Ce(\"Auth flow must be initialized first\");let e=await this.api.get(Mt,{headers:{\"farcaster-channel-token\":this.meta.channelToken}});return\"completed\"===e.state&&(this.message=e.message,this.signature=e.signature,this.fid=e.fid,!0)}constructor(e,t=!1){this._meta={disableSignup:!1},this.captchaToken=e,this.startChannelOnce=new Qr(this._startChannelOnce.bind(this)),this.pollForReady=new Qr(this._pollForReady.bind(this)),this._meta.disableSignup=t}}function Xr(){return\"undefined\"!=typeof window&&\"chrome-extension:\"===window.location.protocol&&\"chrome\"in window}function ea(){if(!Xr())return;let e=window.chrome;return e?.runtime?.id}function ta(){if(!Xr())return!1;let e=window.chrome;return\"function\"==typeof e?.identity?.launchWebAuthFlow}async function na(e){return new Promise(((t,n)=>{ta()?window.chrome.identity.launchWebAuthFlow({url:e,interactive:!0},(async e=>{try{let n=function(){if(!Xr())return;let e=window.chrome;return e?.runtime?.lastError?.message}();if(n||!e){let e=`WebAuthFlow failed: ${n||\"Response URI missing\"}`;throw Error(e)}let r=new URL(e),a=ea();if(!a)throw Error(\"Invalid extension context\");if(\"chrome-extension:\"===r.protocol){if(r.hostname!==a)throw Error(\"Invalid responseUri origin\")}else{if(\"https:\"!==r.protocol)throw Error(\"Invalid responseUri protocol\");{let e=r.hostname.split(\".\");if(3!==e.length||\"chromiumapp\"!==e[1]||\"org\"!==e[2]||e[0]!==a)throw Error(\"Invalid responseUri origin\")}}let i=r.searchParams.get(\"privy_oauth_state\"),s=r.searchParams.get(\"privy_oauth_code\");if(!i||!s)throw Error(\"Invalid responseUri - missing required parameters\");t({privyOAuthState:i,privyOAuthCode:s})}catch(e){n(e)}})):n(Error(\"Chrome identity API not available\"))}))}function ra(e){return crypto.getRandomValues(new Uint8Array(e))}function aa(){return C.encode(ra(36))}function ia(){return aa()}async function sa(e,t=\"S256\"){if(\"S256\"!=t)return e;{let t=await async function(e){let t=(new TextEncoder).encode(e);return new Uint8Array(await crypto.subtle.digest(\"SHA-256\",t))}(e);return C.encode(t)}}class oa{addCaptchaToken(e){this.meta.captchaToken=e}isActive(){return!!(this.meta.authorizationCode&&this.meta.stateCode&&this.meta.provider)}async authenticate(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");if(!this.meta.authorizationCode||!this.meta.stateCode)throw new Ce(\"[OAuth AuthFlow] Authorization and state codes code must be set prior to calling authenticate.\");if(\"undefined\"===this.meta.authorizationCode)throw new Ce(\"User denied confirmation during OAuth flow\");let e=function(){let e=Me.get(Ye);if(!e)throw new Ce(\"Authentication error.\");return e}();try{let t=await this.api.post(xt,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:e,mode:this.meta.disableSignup?\"no-signup\":\"login-or-sign-up\"});return Me.del(Ye),Me.del(Je),Me.del(Qe),t}catch(e){let t=Te(e);if(t.privyErrorCode)throw new Ce(t.message||\"Invalid code during OAuth flow.\",void 0,t.privyErrorCode);if(\"User denied confirmation during OAuth flow\"===t.message)throw new Ce(\"Invalid code during oauth flow.\",void 0,_e.OAUTH_USER_DENIED);throw new Ce(\"Invalid code during OAuth flow.\",void 0,_e.UNKNOWN_AUTH_ERROR)}}async link(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");if(!this.meta.authorizationCode||!this.meta.stateCode)throw new Ce(\"[OAuth AuthFlow] Authorization and state codes code must be set prior to calling link.\");if(\"undefined\"===this.meta.authorizationCode)throw new Ce(\"User denied confirmation during OAuth flow\");let e=Me.get(Ye);if(!e)throw new Ce(\"Authentication error.\");try{let t=await this.api.post(Ft,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:e});return Me.del(Ye),t}catch(e){throw Te(e)}}async getAuthorizationUrl(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");if(!this.meta.provider)throw new Ce(\"Provider must be set when initializing OAuth authentication.\");let e=aa();Me.put(Ye,e);let t=ia();Me.put(Ze,t);let n=await sa(e);this.meta.withPrivyUi||Me.put(Je,!0),this.meta.disableSignup?Me.put(Qe,!0):Me.del(Qe);let r=Gr(this.meta.withPrivyUi),a=window.location.href,i=function(){let e=ea();if(e)return`https://${e}.chromiumapp.org`}();i&&(a=i);try{return await this.api.post(Lt,{provider:this.meta.provider,redirect_to:this.meta.customOAuthRedirectUrl||a,token:this.meta.captchaToken,code_challenge:n,state_code:t},{headers:{...r}})}catch(e){throw Te(e)}}constructor(e){this.meta=e}}function la(){let e=new URLSearchParams(window.location.search),t=e.get(\"privy_oauth_code\"),n=e.get(\"privy_oauth_state\"),r=e.get(\"privy_oauth_provider\");if(!t||!n||!r)return{inProgress:!1};let a=!1;try{a=!!window.opener.location.origin}catch{}return{inProgress:!0,authorizationCode:t,stateCode:n,provider:r,withPrivyUi:!Me.get(Je),popupFlow:null!==window.opener&&a,disableSignup:!!Me.get(Qe)}}function ca(){let e=new URL(window.location.href);e.searchParams.delete(\"privy_oauth_code\"),e.searchParams.delete(\"privy_oauth_provider\"),e.searchParams.delete(\"privy_oauth_state\"),Me.del(Ze),window.history.replaceState({},\"\",e)}class da{async initRegisterFlow(e){if(!this.api)throw new Ce(\"Auth flow has no API instance\");this.authenticateForRegistration=!0,this.meta.initRegisterResponse=await this.initRegisterOnce.execute(e)}async initAuthenticationFlow(e){if(!this.api)throw new Ce(\"Auth flow has no API instance\");this.authenticateForRegistration=!1,this.meta.initAuthenticateResponse=await this.initAuthenticateOnce.execute(e)}async initLinkFlow(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");this.meta.initLinkResponse=await this.initLinkOnce.execute()}async register(){let e=await import(\"@simplewebauthn/browser\");if(!this.api)throw new Ce(\"Auth flow has no API instance\");if(!e.browserSupportsWebAuthn())throw new Ce(\"WebAuthn is not supported in this browser\");this.meta.initRegisterResponse||(this.meta.initRegisterResponse=await this.initRegisterOnce.execute());try{let t=this.meta.initRegisterResponse.options,n=await e.startRegistration({optionsJSON:this._transformInitLinkOptionsToCamelCase(t)});return this.meta.setPasskeyAuthState?.({status:\"submitting-response\"}),await this.api.post(Dt,{relying_party:this.meta.initRegisterResponse.relying_party,authenticator_response:this._transformRegistrationResponseToSnakeCase(n)})}catch(e){if(\"NotAllowedError\"===e.name)throw new Ce(\"Passkey request timed out or rejected by user.\",void 0,_e.PASSKEY_NOT_ALLOWED);throw Te(e)}}async authenticate(){if(this.authenticateForRegistration)return this.register();let e=await import(\"@simplewebauthn/browser\");if(!this.api)throw new Ce(\"Auth flow has no API instance\");if(!e.browserSupportsWebAuthn())throw new Ce(\"WebAuthn is not supported in this browser\");this.meta.initAuthenticateResponse||(this.meta.initAuthenticateResponse=await this.initAuthenticateOnce.execute());let t=this.meta.allowedCredentialsIds?.map((e=>({type:\"public-key\",id:e})))??this.meta.initAuthenticateResponse.options.allow_credentials;try{let n=await e.startAuthentication({optionsJSON:this._transformInitAuthenticateOptionsToCamelCase({...this.meta.initAuthenticateResponse.options,allow_credentials:t})});return this.meta.setPasskeyAuthState?.({status:\"submitting-response\"}),await this.api.post(jt,{relying_party:this.meta.initAuthenticateResponse.relying_party,challenge:this.meta.initAuthenticateResponse.options.challenge,authenticator_response:this._transformAuthenticationResponseToSnakeCase(n)})}catch(e){if(\"NotAllowedError\"===e.name)throw new Ce(\"Passkey request timed out or rejected by user.\",void 0,_e.PASSKEY_NOT_ALLOWED);throw Te(e)}}async link(){let e=await import(\"@simplewebauthn/browser\");if(!this.api)throw new Ce(\"Auth flow has no API instance\");if(!e.browserSupportsWebAuthn())throw new Ce(\"WebAuthn is not supported in this browser\");this.meta.initLinkResponse||(this.meta.initLinkResponse=await this.initLinkOnce.execute());try{let t=this.meta.initLinkResponse.options,n=await e.startRegistration({optionsJSON:this._transformInitLinkOptionsToCamelCase(t)});return this.meta.setPasskeyAuthState?.({status:\"submitting-response\"}),await this.api.post(zt,{relying_party:this.meta.initLinkResponse.relying_party,authenticator_response:this._transformRegistrationResponseToSnakeCase(n)})}catch(e){if(\"NotAllowedError\"===e.name)throw new Ce(\"Passkey request timed out or rejected by user.\",void 0,_e.PASSKEY_NOT_ALLOWED);throw Te(e)}}async _initRegisterOnce(e){if(!this.api)throw new Ce(\"Auth flow has no API instance\");let t=Gr(e);return await this.api.post(qt,{token:this.meta.captchaToken},{headers:{...t}})}async _initAuthenticateOnce(e){if(!this.api)throw new Ce(\"Auth flow has no API instance\");let t=Gr(e);return await this.api.post(Ht,{token:this.meta.captchaToken},{headers:{...t}})}async _initLinkOnce(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");return await this.api.post(Vt,{})}_transformInitLinkOptionsToCamelCase(e){return{rp:e.rp,user:{id:e.user.id,name:e.user.name,displayName:e.user.display_name},challenge:e.challenge,pubKeyCredParams:e.pub_key_cred_params.map((e=>({type:e.type,alg:e.alg}))),timeout:e.timeout,excludeCredentials:e.exclude_credentials?.map((e=>({id:e.id,type:e.type,transports:e.transports}))),authenticatorSelection:{authenticatorAttachment:e.authenticator_selection?.authenticator_attachment,requireResidentKey:e.authenticator_selection?.require_resident_key,residentKey:e.authenticator_selection?.resident_key,userVerification:e.authenticator_selection?.user_verification},attestation:e.attestation,extensions:{appid:e.extensions?.app_id,credProps:e.extensions?.cred_props?.rk,hmacCreateSecret:e.extensions?.hmac_create_secret},hints:this.meta.hints}}_transformRegistrationResponseToSnakeCase(e){return{id:e.id,raw_id:e.rawId,response:{client_data_json:e.response.clientDataJSON,attestation_object:e.response.attestationObject,authenticator_data:e.response.authenticatorData},authenticator_attachment:e.authenticatorAttachment,client_extension_results:{app_id:e.clientExtensionResults.appid,cred_props:e.clientExtensionResults.credProps,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret},type:e.type}}_transformInitAuthenticateOptionsToCamelCase(e){return{rpId:e.rp_id,challenge:e.challenge,allowCredentials:e.allow_credentials?.map((e=>({id:e.id,type:e.type,transports:e.transports})))||[],timeout:e.timeout,extensions:{appid:e.extensions?.app_id,credProps:e.extensions?.cred_props,hmacCreateSecret:e.extensions?.hmac_create_secret},userVerification:e.user_verification}}_transformAuthenticationResponseToSnakeCase(e){return{id:e.id,raw_id:e.rawId,response:{client_data_json:e.response.clientDataJSON,authenticator_data:e.response.authenticatorData,signature:e.response.signature,user_handle:e.response.userHandle},authenticator_attachment:e.authenticatorAttachment,client_extension_results:{app_id:e.clientExtensionResults.appid,cred_props:e.clientExtensionResults.credProps,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret},type:e.type}}constructor({captchaToken:e,setPasskeyAuthState:t,hints:n}){this.authenticateForRegistration=!1,this.initRegisterOnce=new Qr(this._initRegisterOnce.bind(this)),this.initAuthenticateOnce=new Qr(this._initAuthenticateOnce.bind(this)),this.initLinkOnce=new Qr(this._initLinkOnce.bind(this)),this.meta={captchaToken:e,setPasskeyAuthState:t,hints:n}}}const ua=({address:e,chainId:t,nonce:n})=>`${window.location.host} wants you to sign in with your Ethereum account:\\n${e}\\n\\nBy signing, you are proving you own this wallet and logging in. This does not initiate a transaction or cost any fees.\\n\\nURI: ${window.location.origin}\\nVersion: 1\\nChain ID: ${t}\\nNonce: ${n}\\nIssued At: ${(new Date).toISOString()}\\nResources:\\n- https://privy.io`;class ha{get meta(){return{connectorType:this.wallet?.connectorType,walletClientType:this.wallet?.walletClientType,chainId:this.wallet?.chainId,address:this.wallet?.address,disableSignup:this._meta.disableSignup}}async authenticate(){if(!this.client)throw new Ce(\"SiweFlow has no client instance\");try{if(this.preparedMessage&&this.signature)return await this.client.authenticateWithSiweInternal({message:this.preparedMessage,signature:this.signature,chainId:this.wallet?.chainId,walletClientType:this.walletClientType??this.wallet?.walletClientType,connectorType:this.connectorType??this.wallet?.connectorType,mode:this._meta.disableSignup?\"no-signup\":\"login-or-sign-up\"});if(!this.wallet)throw new Ce(\"SiweFlow has no wallet instance\");let{message:e,signature:t}=await this.sign();return await this.client.authenticateWithSiweInternal({message:e,signature:t,chainId:this.wallet.chainId,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType,mode:this.meta.disableSignup?\"no-signup\":\"login-or-sign-up\"})}catch(e){throw Te(e)}}async link(){if(!this.client)throw new Ce(\"SiweFlow has no client instance\");try{if(!this.wallet)throw new Ce(\"SiweFlow has no wallet instance\");let{message:e,signature:t}=await this.sign();return await this.client.linkWithSiweInternal({message:e,signature:t,chainId:this.wallet.chainId,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType})}catch(e){throw Te(e)}}async sign(){if(!this.client)throw new Ce(\"SiweFlow has no client instance\");if(await this.buildMessage(),!this.preparedMessage)throw new Ce(\"Could not prepare SIWE message\");if(!this.wallet)throw new Ce(\"SiweFlow has no wallet instance\");let e=await this.wallet.sign(this.preparedMessage);return{message:this.preparedMessage,signature:e}}async _getNonceOnce(){if(!this.client)throw new Ce(\"SiweFlow has no client instance\");if(!this.wallet)throw new Ce(\"UI SiweFlow has no wallet instance\");return await this.client.generateSiweNonce({address:this.wallet.address,captchaToken:this.captchaToken})}async buildMessage(){if(!this.client)throw new Ce(\"SiweFlow has no client instance\");if(!this.wallet)throw new Ce(\"SiweFlow has no wallet instance\");let e=this.wallet.address,t=this.wallet.chainId.replace(\"eip155:\",\"\");return this.nonce||(this.nonce=await this.getNonceOnce.execute()),this.preparedMessage=ua({address:e,chainId:t,nonce:this.nonce}),this.preparedMessage}constructor(e,t,n,r=!1,a){this._meta={disableSignup:!1},this.getNonceOnce=new Qr(this._getNonceOnce.bind(this)),this.wallet=t,this.captchaToken=n,this.client=e,this._meta.disableSignup=r,this.preparedMessage=a?.message,this.signature=a?.signature,this.walletClientType=a?.walletClientType,this.connectorType=a?.connectorType}}class pa{get meta(){return{connectorType:this.wallet.connectorType,walletClientType:this.wallet.walletClientType,disableSignup:this._meta.disableSignup,messageType:this._meta.messageType,address:this.wallet?.address}}set messageType(e){this._meta.messageType=e}async authenticate(){if(!this.client)throw new Ce(\"SiwsFlow has no client instance\");try{let{message:e,signature:t}=await this.sign();return await this.client.authenticateWithSiwsInternal({message:e,signature:t,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType,mode:this.meta.disableSignup?\"no-signup\":\"login-or-sign-up\",messageType:this.meta.messageType})}catch(e){throw Te(e)}}async link(){if(!this.client)throw new Ce(\"SiwsFlow has no client instance\");try{let{message:e,signature:t}=await this.sign();return await this.client.linkWithSiwsInternal({message:e,signature:t,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType,messageType:this.meta.messageType})}catch(e){throw Te(e)}}async sign(){let e,t;if(!this.client)throw new Ce(\"SiwsFlow has no client instance\");await this.buildMessage();let n=\"transaction\"===this.meta.messageType;if(!this.preparedMessage)throw new Ce(\"Could not prepare SIWS message\");if(!n&&!this.wallet.provider.signMessage||n&&!this.wallet.provider.signTransaction)throw new Ce(\"Wallet does not support the necessary signing methods\");if(n&&this._plugin){let n=await this.wallet.provider.signTransaction({transaction:$n.decode(this.preparedMessage)});e=$n.encode(n.signedTransaction),t=this._plugin.getSignatureFromTransaction(n.signedTransaction,this.wallet.address)}else{e=this.preparedMessage;let n=await this.wallet.provider.signMessage({message:(new TextEncoder).encode(this.preparedMessage)});t=$n.encode(n.signature)}return{message:e,signature:t}}async _getNonceOnce(){if(!this.client)throw new Ce(\"SiwsFlow has no client instance\");return await this.client.generateSiwsNonce({address:this.wallet.address,captchaToken:this.captchaToken})}async buildMessage(){if(!this.client)throw new Ce(\"SiwsFlow has no client instance\");let e=this.wallet.address;return this.nonce||(this.nonce=await this.getNonceOnce.execute()),\"transaction\"===this.meta.messageType&&this._plugin?this.preparedMessage=this._plugin.createSiwsMemoTransaction({address:e,nonce:this.nonce}):this.preparedMessage=Mn({address:e,nonce:this.nonce}),this.preparedMessage}constructor(e,t,n,r=!1,a=\"plain\",i){this._meta={disableSignup:!1,messageType:\"plain\"},this.getNonceOnce=new Qr(this._getNonceOnce.bind(this)),this.wallet=e,this.captchaToken=n,this.client=t,this._meta.disableSignup=r,this._meta.messageType=a,this._plugin=i}}class wa{async authenticate(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");if(!this.meta.phoneNumber||!this.meta.smsCode)throw new Ce(\"phone number and sms code must be set prior to calling authenticate.\");try{return await this.api.post(Bt,{phoneNumber:this.meta.phoneNumber,code:this.meta.smsCode,mode:this.meta.disableSignup?\"no-signup\":\"login-or-sign-up\"})}catch(e){throw Te(e)}}async link(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");if(!this.meta.phoneNumber||!this.meta.smsCode)throw new Ce(\"phone number and sms code must be set prior to calling authenticate.\");try{return await this.api.post(Kt,{phoneNumber:this.meta.phoneNumber,code:this.meta.smsCode})}catch(e){throw Te(e)}}async sendSmsCode({phoneNumber:e,captchaToken:t,withPrivyUi:n}){if(!this.api)throw new Ce(\"Auth flow has no API instance\");if(e&&(this.meta.phoneNumber=e),t&&(this.meta.captchaToken=t),!this.meta.phoneNumber)throw new Ce(\"phone nNumber must be set when initialzing authentication.\");let r=Gr(n);try{return await this.api.post($t,{phoneNumber:this.meta.phoneNumber,token:this.meta.captchaToken},{headers:{...r}})}catch(e){throw Te(e)}}constructor({phoneNumber:e,captchaToken:t,disableSignup:n}){this.meta={phoneNumber:e,captchaToken:t,disableSignup:n??!1}}}class ma extends wa{async link(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");if(!this.meta.phoneNumber||!this.meta.smsCode||!this.meta.oldPhoneNumber)throw new Ce(\"Phone number, sms code, and an old phone number must be set prior to calling update.\");try{return await this.api.post(Gt,{old_phone_number:this.meta.oldPhoneNumber,new_phone_number:this.meta.phoneNumber,code:this.meta.smsCode})}catch(e){throw Te(e)}}constructor(e,t,n){super({phoneNumber:t,captchaToken:n}),this.meta={phoneNumber:t,captchaToken:n,oldPhoneNumber:e,disableSignup:!1}}}const ya=/*#__PURE__*/i({enabled:!1,siteKey:\"\",provider:void 0,appId:void 0,token:void 0,error:void 0,status:\"disabled\",setToken:Se,setError:Se,setExecuting:Se,waitForResult:()=>Promise.resolve(\"\"),ref:{current:null},remove:Ee,reset:Se,execute:Se});class ga extends be{constructor(e,t,n){super(e||\"Captcha failed\"),this.type=\"Captcha\",t instanceof Error&&(this.cause=t),this.privyErrorCode=n}}const fa=({children:e,appId:n,captchaSiteKey:r,enabledCaptchaProvider:a})=>{let i=s(null),c=s(null),[d,u]=o(),[h,p]=o(),[w,m]=o(!1),y=l((()=>a?w||d||h?!w||d||h?d&&!h?{status:\"success\",token:d}:h?{status:\"error\",error:h}:{status:\"ready\"}:{status:\"loading\"}:{status:\"ready\"}:{status:\"disabled\"}),[a,d,h,w]),g=l((()=>a?\"turnstile\"===a?{remove:()=>{i.current?.remove(),m(!1),p(void 0),u(void 0)},reset:()=>{i.current?.reset(),m(!1),p(void 0),u(void 0)},execute:()=>{m(!0),i.current?.execute()},waitForResult:async()=>{try{return await H((()=>i.current?.getResponse()),{interval:200,timeout:2e4})}catch(e){throw new ga(\"Captcha failed\",null,_e.CAPTCHA_TIMEOUT)}}}:{remove:()=>{c.current?.removeCaptcha(),m(!1),p(void 0),u(void 0)},reset:()=>{c.current?.resetCaptcha(),m(!1),p(void 0),u(void 0)},execute:()=>{m(!0),c.current?.execute()},waitForResult:async()=>{try{return await H((()=>c.current?.getResponse()),{interval:200,timeout:2e4})}catch(e){throw new ga(\"Captcha failed\",null,_e.CAPTCHA_TIMEOUT)}}}:null),[a]),f=l((()=>{if(!a||!g)return{...y,enabled:!1,siteKey:\"\",appId:n,setToken:Se,setError:Se,setExecuting:Se,waitForResult:()=>Promise.resolve(void 0),remove:Ee,reset:Se,execute:Se,provider:void 0,ref:{current:null}};let e={...y,enabled:!0,appId:n,setToken:u,setError:p,setExecuting:m};return\"turnstile\"===a?{...e,provider:\"turnstile\",ref:i,siteKey:r.split(\"t:\")[1]??\"\",...g}:{...e,provider:\"hcaptcha\",ref:c,siteKey:r.split(\"h:\")[1]??\"\",...g}}),[y,a,g,n,r]);/*#__PURE__*/return t(ya.Provider,{value:f,children:e})},va=()=>a(ya);class Aa{async authenticate(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");try{return await this.api.post(Yt,{captcha_token:this.meta.captchaToken,telegram_auth_result:this.meta.telegramAuthResult,telegram_web_app_data:this.meta.telegramWebAppData,mode:this.meta.disableSignup?\"no-signup\":\"login-or-sign-up\"})}catch(e){throw Te(e)}}async link(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");try{return await this.api.post(Jt,{telegram_auth_result:this.meta.telegramAuthResult,telegram_web_app_data:this.meta.telegramWebAppData})}catch(e){throw Te(e)}}constructor(e,t=!1){this.meta={disableSignup:!1},this.meta={captchaToken:e,disableSignup:!1},this.meta.disableSignup=t}}function ka(e){let t={detail:\"\",retryable:!1};return e?.privyErrorCode===_e.LINKED_TO_ANOTHER_USER&&(t.detail=\"This account has already been linked to another user.\"),e?.privyErrorCode===_e.DISALLOWED_LOGIN_METHOD&&(t.detail=\"Login with Telegram not allowed.\"),e?.privyErrorCode===_e.INVALID_DATA&&(t.retryable=!0,t.detail=\"Something went wrong. Try again.\"),e?.privyErrorCode===_e.CANNOT_LINK_MORE_OF_TYPE&&(t.retryable=!0,t.detail=\"Something went wrong. Try again.\"),e?.privyErrorCode===_e.INVALID_CREDENTIALS&&(t.retryable=!0,t.detail=\"Something went wrong. Try again.\"),e?.privyErrorCode===_e.TOO_MANY_REQUESTS&&(t.detail=\"Too many requests. Please wait before trying again.\"),e?.privyErrorCode===_e.TOO_MANY_REQUESTS&&e.message.includes(\"rate limit\")&&(t.detail=\"Request limit reached for Telegram. Please wait a moment and try again.\"),e instanceof ga&&(t.retryable=!0,t.detail=\"Something went wrong. Try again.\"),t}function Ca(e){return Object.fromEntries(decodeURIComponent(e).split(\"&\").map((e=>e.split(\"=\").map(decodeURIComponent))))}function Ta(){let e=new URL(window.location.href);e.searchParams.delete(\"id\"),e.searchParams.delete(\"hash\"),e.searchParams.delete(\"auth_date\"),e.searchParams.delete(\"first_name\"),e.searchParams.delete(\"last_name\"),e.searchParams.delete(\"username\"),e.searchParams.delete(\"photo_url\"),e.hash=\"\",window.history.replaceState({},\"\",e)}let _a=/*#__PURE__*/u((()=>import(\"./TurnstileWrapper-Co-t5mTh.mjs\"))),ba=/*#__PURE__*/u((()=>import(\"./HCaptchaWrapper-Dl2Jt_Df.mjs\")));const Sa=n=>{let r=va();return c((()=>r.remove),[r.remove]),r.enabled&&r.provider?/*#__PURE__*/t(d,{fallback:null,children:/*#__PURE__*/e(\"div\",{className:\"hidden h-0 w-0\",children:[\"turnstile\"===r.provider&&/*#__PURE__*/t(_a,{...n,captchaContext:r}),\"hcaptcha\"===r.provider&&/*#__PURE__*/t(ba,{...n,captchaContext:r})]})}):null};var Ea=/*#__PURE__*/Object.freeze({__proto__:null,AccountNotFoundScreen:()=>import(\"./AccountNotFoundScreen-BzbvtCmu.mjs\"),AffirmativeConsentScreen:()=>import(\"./AffirmativeConsentScreen-CrZKQjas.mjs\"),AllowlistRejectionScreen:()=>import(\"./AllowlistRejectionScreen-DhhfJ6ai.mjs\"),AuthenticateWithWalletScreen:()=>import(\"./AuthenticateWithWalletScreen-BN0s1mtv.mjs\"),AwaitingEvmToSolBridgingScreen:()=>import(\"./AwaitingEvmToSolBridgingScreen-C7mp2-Hy.mjs\"),AwaitingExternalEthereumTransferScreen:()=>import(\"./AwaitingExternalEthereumTransferScreen-EqM4Kcsu.mjs\"),AwaitingPasswordlessCodeScreen:()=>import(\"./AwaitingPasswordlessCodeScreen-NAVmxM9-.mjs\"),AwaitingSolToEvmBridgingScreen:()=>import(\"./AwaitingSolToEvmBridgingScreen-dC9b-wlg.mjs\"),CaptchaScreen:()=>import(\"./CaptchaScreen-CTRyyYc9.mjs\"),CoinbaseOnrampStatusScreen:()=>import(\"./CoinbaseOnrampStatusScreen-BNmvm8Bl.mjs\"),ConnectLedgerScreen:()=>import(\"./ConnectLedgerScreen-BEhSz1FM.mjs\"),ConnectOnlyLandingScreen:()=>import(\"./ConnectOnlyLandingScreen-ZnI9ReZJ.mjs\"),ConnectOnlyStatusScreen:()=>import(\"./ConnectOnlyStatusScreen-1oCuFsd6.mjs\"),ConnectOrCreateScreen:()=>import(\"./ConnectOrCreateScreen-BOO4iaC6.mjs\"),ConnectionStatusScreen:()=>import(\"./ConnectionStatusScreen-CZNBQeOQ.mjs\"),CrossAppAuthScreen:()=>import(\"./CrossAppAuthScreen-Bno8NQSa.mjs\"),DelegatedActionsConsentScreen:()=>import(\"./DelegatedActionsConsentScreen-B0AwZEKc.mjs\"),DelegatedActionsRevokeScreen:()=>import(\"./DelegatedActionsRevokeScreen-D0mAKxDs.mjs\"),EmbeddedWalletConnectingScreen:()=>import(\"./EmbeddedWalletConnectingScreen-9ADobSle.mjs\"),EmbeddedWalletCreatedScreen:()=>import(\"./EmbeddedWalletCreatedScreen-B7TnCst_.mjs\"),EmbeddedWalletKeyExportScreen:()=>import(\"./EmbeddedWalletKeyExportScreen-Cmp2CUOa.mjs\"),EmbeddedWalletOnAccountCreateScreen:()=>import(\"./EmbeddedWalletOnAccountCreateScreen-vxaCVWy1.mjs\"),EmbeddedWalletPasswordCreateScreen:()=>import(\"./RecoveryPasswordCreateScreen-jWT25C0X.mjs\"),EmbeddedWalletPasswordUpdateScreen:()=>import(\"./EmbeddedWalletPasswordUpdateScreen-C4dNnXVI.mjs\"),EmbeddedWalletPasswordUpdateSplashScreen:()=>import(\"./EmbeddedWalletPasswordUpdateSplashScreen-BPTp0nwT.mjs\"),ErrorScreen:()=>import(\"./ErrorScreen-Yi-Rhs0v.mjs\"),FarcasterConnectStatusScreen:()=>import(\"./FarcasterConnectStatusScreen-BfoDjDwg.mjs\"),FarcasterSignerStatusScreen:()=>import(\"./FarcasterSignerStatusScreen-CsSFmDry.mjs\"),FundSolWalletWithExternalSolanaWallet:()=>import(\"./FundSolWalletWithExternalSolanaWallet-BIk-6GIl.mjs\"),FundingAmountEditScreen:()=>import(\"./FundingEditAmountScreen-CzbuYpdw.mjs\"),FundingMethodSelectionScreen:()=>import(\"./FundingMethodSelectionScreen-DdZxdcVe.mjs\"),InAppBrowserLoginNotPossible:()=>import(\"./InAppBrowserLoginNotPossible-COUNBN1W.mjs\"),InstallWalletScreen:()=>import(\"./InstallWalletScreen-BjprJkty.mjs\"),LandingScreen:()=>import(\"./LandingScreen-Dp4m_c2X.mjs\"),LinkConflictScreen:()=>import(\"./LinkConflictScreen-DMHPhlV7.mjs\"),LinkEmailScreen:()=>import(\"./LinkEmailScreen-D7VTyZrH.mjs\"),LinkPasskeyScreen:()=>import(\"./LinkPasskeyScreen-B5LWH116.mjs\"),LinkPhoneScreen:()=>import(\"./LinkPhoneScreen-DdRe154C.mjs\"),LoginFailedScreen:()=>import(\"./LoginFailedScreen-CZnzwKpB.mjs\"),ManualTransferScreen:()=>import(\"./ManualTransferScreen-Bn2qhDAI.mjs\"),MfaAuthEnrollmentFlowScreen:()=>import(\"./MfaAuthEnrollmentFlowScreen-CWMULcQb.mjs\"),MfaAuthVerifyFlowScreen:()=>import(\"./MfaAuthVerifyFlowScreen-B3Hw1YN-.mjs\"),MfaEnrollmentFlowScreen:()=>import(\"./MfaEnrollmentFlowScreen-DcnqGJ3O.mjs\"),MoonpayStatusScreen:()=>import(\"./MoonpayStatusScreen-lYMS5etL.mjs\"),OAuthStatusScreen:()=>import(\"./OAuthStatusScreen-DEtT_t2P.mjs\"),PasskeySelectSignupOrLogin:()=>import(\"./PasskeySelectSignupOrLogin-DgH-G2yO.mjs\"),PasskeyStatusScreen:()=>import(\"./PasskeyStatusScreen-BOac_MoC.mjs\"),PasswordRecoveryScreen:()=>import(\"./PasswordRecoveryScreen-CT1bj8Gb.mjs\"),RecoveryOAuthScreen:()=>import(\"./RecoveryOAuthStatusScreen-Ce6qiP-3.mjs\"),RecoverySelectionScreen:()=>import(\"./RecoverySelectionScreen-_u02vomS.mjs\"),SendTransactionScreen:()=>import(\"./index-DNmMGazz.mjs\"),SetAutomaticRecoveryScreen:()=>import(\"./SetAutomaticRecoveryScreen-CUheSZ7h.mjs\"),SignRequestScreen:()=>import(\"./SignRequestScreen-BNC2mYtk.mjs\"),StandardSignAndSendTransactionScreen:()=>import(\"./StandardSignAndSendTransactionScreen-Ckxfv32q.mjs\"),TelegramAuthScreen:()=>import(\"./TelegramAuthScreen-xobB3RHK.mjs\"),TransferFromWalletScreen:()=>import(\"./TransferFromWalletScreen-CLqyv8Ra.mjs\"),UpdateEmailScreen:()=>import(\"./UpdateEmailScreen-BVzkFXeI.mjs\"),UpdatePhoneScreen:()=>import(\"./UpdatePhoneScreen-DZ_resri.mjs\"),UserLimitReachedScreen:()=>import(\"./UserLimitReachedScreen-CTmSitf0.mjs\"),WalletInterstitialScreen:()=>import(\"./WalletInterstitialScreen-tDCVxTFi.mjs\")});function Ia(e){Qn(\"configureMfa\",e)}const Pa=nr((()=>({inProgressMfaFlow:void 0})));const Wa=/*#__PURE__*/Yn([\":root{\",\"};\"],(e=>Ua(e.palette)));const Ua=e=>\n/*#__PURE__*/Jn([\"\",\"\"],Object.entries(function(e){return{\"--privy-color-background\":e.background,\"--privy-color-background-2\":e.background2,\"--privy-color-background-3\":e.background3,\"--privy-color-foreground\":e.foreground,\"--privy-color-foreground-2\":e.foreground2,\"--privy-color-foreground-3\":e.foreground3,\"--privy-color-foreground-4\":e.foreground4,\"--privy-color-foreground-accent\":e.foregroundAccent,\"--privy-color-accent\":e.accent,\"--privy-color-accent-light\":e.accentLight,\"--privy-color-accent-hover\":e.accentHover,\"--privy-color-accent-dark\":e.accentDark,\"--privy-color-accent-darkest\":e.accentDarkest,\"--privy-color-success\":e.success,\"--privy-color-success-dark\":e.successDark,\"--privy-color-success-light\":e.successLight,\"--privy-color-success-bg\":e.successBg,\"--privy-color-error\":e.error,\"--privy-color-error-light\":e.errorLight,\"--privy-color-error-bg\":e.errorBg,\"--privy-color-error-bg-hover\":e.errorBgHover,\"--privy-color-warn\":e.warn,\"--privy-color-warn-light\":e.warnLight,\"--privy-color-warn-bg\":e.warnBg,\"--privy-color-warning-dark\":e.warningDark,\"--privy-color-error-dark\":e.errorDark,\"--privy-color-info-bg\":e.infoBg,\"--privy-color-info-bg-hover\":e.infoBgHover,\"--privy-color-border-default\":e.borderDefault,\"--privy-color-border-hover\":e.borderHover,\"--privy-color-border-focus\":e.borderFocus,\"--privy-color-border-error\":e.borderError,\"--privy-color-border-success\":e.borderSuccess,\"--privy-color-border-warning\":e.borderWarning,\"--privy-color-border-info\":e.borderInfo,\"--privy-color-border-interactive\":e.borderInteractive,\"--privy-color-border-interactive-hover\":e.borderInteractiveHover,\"--privy-color-background-hover\":e.backgroundHover,\"--privy-color-background-clicked\":e.backgroundClicked,\"--privy-color-background-disabled\":e.backgroundDisabled,\"--privy-color-background-interactive\":e.backgroundInteractive,\"--privy-color-background-interactive-hover\":e.backgroundInteractiveHover,\"--privy-color-background-interactive-clicked\":e.backgroundInteractiveClicked,\"--privy-color-background-interactive-disabled\":e.backgroundInteractiveDisabled,\"--privy-color-foreground-hover\":e.foregroundHover,\"--privy-color-foreground-clicked\":e.foregroundClicked,\"--privy-color-foreground-disabled\":e.foregroundDisabled,\"--privy-color-foreground-interactive\":e.foregroundInteractive,\"--privy-color-foreground-interactive-hover\":e.foregroundInteractiveHover,\"--privy-link-navigation-color\":e.linkNavigationColor,\"--privy-link-navigation-decoration\":e.linkNavigationDecoration,\"--privy-accent-has-good-contrast\":e.accentHasGoodContrast,\"--privy-color-icon-default\":e.iconDefault,\"--privy-color-icon-muted\":e.iconMuted,\"--privy-color-icon-subtle\":e.iconSubtle,\"--privy-color-icon-inverse\":e.iconInverse,\"--privy-color-icon-success\":e.iconSuccess,\"--privy-color-icon-warning\":e.iconWarning,\"--privy-color-icon-error\":e.iconError,\"--privy-color-icon-interactive\":e.iconInteractive,\"--privy-color-icon-default-hover\":e.iconDefaultHover,\"--privy-color-icon-muted-hover\":e.iconMutedHover,\"--privy-color-icon-subtle-hover\":e.iconSubtleHover,\"--privy-color-icon-default-clicked\":e.iconDefaultClicked,\"--privy-color-icon-muted-clicked\":e.iconMutedClicked,\"--privy-color-icon-subtle-clicked\":e.iconSubtleClicked,\"--privy-color-icon-default-disabled\":e.iconDefaultDisabled,\"--privy-color-icon-muted-disabled\":e.iconMutedDisabled,\"--privy-color-icon-subtle-disabled\":e.iconSubtleDisabled,\"--privy-color-icon-error-hover\":e.iconErrorHover,\"--privy-color-icon-interactive-hover\":e.iconInteractiveHover,\"--privy-color-icon-error-clicked\":e.iconErrorClicked,\"--privy-color-icon-interactive-clicked\":e.iconInteractiveClicked,\"--privy-color-icon-muted-disabled-alt\":e.iconMutedDisabledAlt,\"--privy-color-icon-subtle-disabled-alt\":e.iconSubtleDisabledAlt,\"--privy-border-radius-xs\":\"6px\",\"--privy-border-radius-sm\":\"8px\",\"--privy-border-radius-md\":\"12px\",\"--privy-border-radius-mdlg\":\"16px\",\"--privy-border-radius-lg\":\"24px\",\"--privy-border-radius-full\":\"9999px\",\"--privy-height-modal-full\":\"620px\",\"--privy-height-modal-compact\":\"480px\"}}(e)).map((([e,t])=>`${e}: ${t};`)).join(\"\\n\")),Na=/*#__PURE__*/Gn.div.withConfig({displayName:\"StylesWrapper\",componentId:\"sc-188229e4-0\"})([\"\",\" color:var(--privy-color-foreground-2);h3{font-size:16px;line-height:24px;font-weight:500;color:var(--privy-color-foreground-2);}h4{font-size:14px;line-height:20px;font-weight:500;color:var(--privy-color-foreground);}p{font-size:13px;line-height:20px;color:var(--privy-color-foreground-2);}button:focus,input:focus,optgroup:focus,select:focus,textarea:focus{outline:none;border-color:var(--privy-color-accent-light);box-shadow:0 0 0 3px var(--privy-color-border-focus);}.mobile-only{@media (min-width:441px){display:none;}}@keyframes fadein{0%{opacity:0;}100%{opacity:1;}}\"],\"\\n  *,\\n  ::before,\\n  ::after {\\n    box-sizing: border-box;\\n    border-width: 0;\\n    border-style: solid;\\n  }\\n\\n  line-height: 1.15;\\n  -webkit-text-size-adjust: 100%;\\n  -moz-tab-size: 4;\\n  tab-size: 4;\\n  font-feature-settings: normal;\\n\\n  margin: 0;\\n  font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif,\\n    'Apple Color Emoji', 'Segoe UI Emoji';\\n\\n  hr {\\n    height: 0;\\n    color: inherit;\\n    border-top-width: 1px;\\n  }\\n\\n  abbr:where([title]) {\\n    text-decoration: underline dotted;\\n  }\\n\\n  h1,\\n  h2,\\n  h3,\\n  h4,\\n  h5,\\n  h6 {\\n    font-size: inherit;\\n    font-weight: inherit;\\n    font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif,\\n    'Apple Color Emoji', 'Segoe UI Emoji';\\n    display: inline;\\n  }\\n\\n  a {\\n    color: inherit;\\n    text-decoration: inherit;\\n  }\\n\\n  b,\\n  strong {\\n    font-weight: bolder;\\n  }\\n\\n  code,\\n  kbd,\\n  samp,\\n  pre {\\n    font-family: ui-monospace, SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;\\n    font-size: 1em;\\n  }\\n\\n  small {\\n    font-size: 80%;\\n  }\\n\\n  sub,\\n  sup {\\n    font-size: 75%;\\n    line-height: 0;\\n    position: relative;\\n    vertical-align: baseline;\\n  }\\n\\n  sub {\\n    bottom: -0.25em;\\n  }\\n\\n  sup {\\n    top: -0.5em;\\n  }\\n\\n  table {\\n    text-indent: 0;\\n    border-color: inherit;\\n    border-collapse: collapse;\\n  }\\n\\n  button,\\n  input,\\n  optgroup,\\n  select,\\n  textarea {\\n    font-family: inherit;\\n    font-size: 100%;\\n    font-weight: inherit;\\n    line-height: inherit;\\n    color: inherit;\\n    margin: 0;\\n    padding: 0;\\n  }\\n\\n  button,\\n  select {\\n    text-transform: none;\\n  }\\n\\n  button,\\n  [type='button'],\\n  [type='reset'],\\n  [type='submit'] {\\n    -webkit-appearance: button;\\n    background-color: transparent;\\n    background-image: none;\\n  }\\n\\n  ::-moz-focus-inner {\\n    border-style: none;\\n    padding: 0;\\n  }\\n\\n  :-moz-focusring {\\n    outline: 1px dotted ButtonText;\\n  }\\n\\n  :-moz-ui-invalid {\\n    box-shadow: none;\\n  }\\n\\n  legend {\\n    padding: 0;\\n  }\\n\\n  progress {\\n    vertical-align: baseline;\\n  }\\n\\n  ::-webkit-inner-spin-button,\\n  ::-webkit-outer-spin-button {\\n    height: auto;\\n  }\\n\\n  [type='search'] {\\n    -webkit-appearance: textfield;\\n    outline-offset: -2px;\\n  }\\n\\n  ::-webkit-search-decoration {\\n    -webkit-appearance: none;\\n  }\\n\\n  ::-webkit-file-upload-button {\\n    -webkit-appearance: button;\\n    font: inherit;\\n  }\\n\\n  summary {\\n    display: list-item;\\n  }\\n\\n  blockquote,\\n  dl,\\n  dd,\\n  h1,\\n  h2,\\n  h3,\\n  h4,\\n  h5,\\n  h6,\\n  hr,\\n  figure,\\n  p,\\n  pre {\\n    margin: 0;\\n  }\\n\\n  fieldset {\\n    margin: 0;\\n    padding: 0;\\n  }\\n\\n  legend {\\n    padding: 0;\\n  }\\n\\n  ol,\\n  ul,\\n  menu {\\n    list-style: none;\\n    margin: 0;\\n    padding: 0;\\n  }\\n\\n  textarea {\\n    resize: vertical;\\n  }\\n\\n  input::placeholder,\\n  textarea::placeholder {\\n    opacity: 1;\\n    color: #9ca3af;\\n  }\\n\\n  button,\\n  [role='button'] {\\n    cursor: pointer;\\n  }\\n\\n  :disabled {\\n    cursor: default;\\n  }\\n\\n  img,\\n  svg,\\n  video,\\n  canvas,\\n  audio,\\n  iframe,\\n  embed,\\n  object {\\n    display: block;\\n  }\\n\\n  img,\\n  video {\\n    max-width: 100%;\\n    height: auto;\\n  }\\n\\n  [hidden] {\\n    display: none;\\n  }\\n\"),Oa=({children:n,open:a,onClick:i,...s})=>/*#__PURE__*/t(rr,{show:a,as:r.Fragment,children:/*#__PURE__*/e(ar,{onClose:i,...s,as:Ma,children:[/*#__PURE__*/t(ir,{as:r.Fragment,enterFrom:\"entering\",leaveTo:\"leaving\",children:/*#__PURE__*/t(Ra,{id:\"privy-dialog-backdrop\",\"aria-hidden\":\"true\"})}),/*#__PURE__*/t(xa,{children:/*#__PURE__*/t(ir,{as:r.Fragment,enterFrom:\"entering\",leaveTo:\"leaving\",children:/*#__PURE__*/t(sr,{as:Fa,children:n})})})]})});let Ra=/*#__PURE__*/Gn.div.withConfig({displayName:\"Backdrop\",componentId:\"sc-3cfde0b5-0\"})([\"position:fixed;inset:0;transition:backdrop-filter 100ms ease;backdrop-filter:blur(3px);-webkit-backdrop-filter:blur(3px);&.entering,&.leaving{backdrop-filter:unset;-webkit-backdrop-filter:unset;}\"]),Ma=/*#__PURE__*/Gn.div.withConfig({displayName:\"DialogWrapper\",componentId:\"sc-3cfde0b5-1\"})([\"position:relative;z-index:999999;\"]),xa=/*#__PURE__*/Gn.div.withConfig({displayName:\"DialogContainer\",componentId:\"sc-3cfde0b5-2\"})([\"position:fixed;inset:0;display:flex;align-items:center;justify-content:center;width:100vw;min-height:100vh;\"]);const Fa=/*#__PURE__*/Gn.div.withConfig({displayName:\"Panel\",componentId:\"sc-3cfde0b5-3\"})([\"padding:0;background:transparent;border:none;width:100%;pointer-events:auto;outline:none;display:block;@media (max-width:440px){opacity:1;transform:translate3d(0,0,0);transition:transform 200ms ease-in;position:fixed;bottom:0;&.entering,&.leaving{opacity:0;transform:translate3d(0,100%,0);transition:transform 150ms ease-in 0ms,opacity 0ms ease 150ms;}}@media (min-width:441px){opacity:1;transition:opacity 100ms ease-in;&.entering,&.leaving{opacity:0;transition-delay:5ms;}margin:auto;width:360px;box-shadow:0px 8px 36px rgba(55,65,81,0.15);border-radius:var(--privy-border-radius-lg);}\"]);const La=()=>{let{ready:e}=T(),{currentScreen:t}=_(),[n,r]=o(null),[a,i]=o(!1),l=function(e){let[t,n]=o(!1),r=s(null),a=s(null),i=s(null);return c((()=>{if(r.current&&(clearTimeout(r.current),r.current=null),a.current&&(clearTimeout(a.current),a.current=null),e)i.current=Date.now(),r.current=setTimeout((()=>{n(!0)}),150);else if(null!==i.current){let e=Date.now()-i.current;if(e>=150){let t=Math.max(0,400-(e-150));a.current=setTimeout((()=>{n(!1),i.current=null}),t)}else r.current&&(clearTimeout(r.current),r.current=null),n(!1),i.current=null}return()=>{r.current&&clearTimeout(r.current),a.current&&clearTimeout(a.current)}}),[e]),t}(a);return c((()=>{if(!t)return r(null),void i(!1);i(!0),Ea[t]().then((n=>{(!t||e||n.default.isShownBeforeReady)&&(r((()=>n.default.component)),i(!1))})).catch((()=>{r(null),i(!1)}))}),[t,e]),{component:n,isLoading:l}};let Da=/*#__PURE__*/u((()=>import(\"./MfaVerifyFlowScreen-BEt8Gfpb.mjs\"))),ja=/*#__PURE__*/u((()=>(e=>Ea[e]().then((e=>({default:e.default.component}))))(\"MfaAuthVerifyFlowScreen\"))),za=()=>/*#__PURE__*/t($a,{children:/*#__PURE__*/t(K,{})}),qa=()=>{let{currentScreen:r}=_(),a=Pa((e=>e.inProgressMfaFlow)),i=()=>Pa.setState({inProgressMfaFlow:void 0}),{component:s,isLoading:l}=La();return function(){let{isModalOpen:e}=T(),{headless:t}=Xe(),{currentScreen:n}=_(),{status:r,execute:a,reset:i,enabled:s}=va(),[l,d]=o(!1);c((()=>{!e&&s&&i()}),[e,s,i]),c((()=>{n?Ea[n]().then((e=>{d(!!e.default.isCaptchaRequired)})).catch((()=>{d(!1)})):d(!1)}),[n]),c((()=>{e&&l&&!t&&\"ready\"===r&&s&&a()}),[e,l,t,r,s,a])}(),r||\"txn\"!==a?l?/*#__PURE__*/t(za,{}):s?\n/*#__PURE__*/e(n,{children:[/*#__PURE__*/t(V,{$if:!!a,children:/*#__PURE__*/t(d,{children:/*#__PURE__*/t(s,{})})}),/*#__PURE__*/e(d,{children:[\"txn\"===a&&/*#__PURE__*/t(Da,{onClose:i}),\"auth\"===a&&/*#__PURE__*/t(ja,{})]})]}):null:/*#__PURE__*/e(d,{children:[/*#__PURE__*/t(Da,{onClose:i}),\";\"]})},Ha=()=>{let e=s(null);/*#__PURE__*/return t(Ka,{style:{height:B(e)},id:\"privy-modal-content\",children:/*#__PURE__*/t(\"div\",{ref:e,children:/*#__PURE__*/t(qa,{})})})};const Va=({open:e})=>{let n=Xe(),{gracefulClosePrivyModal:r}=(()=>{let{closePrivyModal:e}=Ie(),{onUserCloseViaDialogOrKeybindRef:t}=_();return{gracefulClosePrivyModal:h((()=>{if(!t?.current)return e({shouldCallAuthOnSuccess:!1});t.current()}),[e])}})(),a=Pa((e=>e.inProgressMfaFlow));return Ia({onMfaRequired:()=>{n.mfa.noPromptOnMfaRequired||Pa.setState({inProgressMfaFlow:\"txn\"})}}),n.render.standalone?/*#__PURE__*/t(Na,{children:/*#__PURE__*/t(Ba,{id:\"privy-modal-content\",children:/*#__PURE__*/t(qa,{})})}):/*#__PURE__*/t(Oa,{open:!(!e&&!a),id:\"privy-dialog\",\"aria-label\":\"log in or sign up\",\"aria-labelledby\":\"privy-dialog-title\",onClick:()=>r(),children:/*#__PURE__*/t(Na,{children:/*#__PURE__*/t(Ha,{})})})};let Ba=/*#__PURE__*/Gn.div.withConfig({displayName:\"ContentWrapper\",componentId:\"sc-9b080f09-0\"})([\"display:flex;flex-direction:column;text-align:center;font-size:14px;line-height:20px;width:100%;background:var(--privy-color-background);padding:0 16px;\"]),Ka=/*#__PURE__*/Gn(Ba).withConfig({displayName:\"BaseModal\",componentId:\"sc-9b080f09-1\"})([\"transition:height 150ms ease-out;overflow-x:hidden;overflow-y:auto;scrollbar-width:none;max-height:calc(100svh - 32px);border-radius:var(--privy-border-radius-lg) var(--privy-border-radius-lg) 0 0;box-shadow:0px 0px 36px rgba(55,65,81,0.15);@media (min-width:441px){box-shadow:0px 8px 36px rgba(55,65,81,0.15);border-radius:var(--privy-border-radius-lg);}\"]),$a=/*#__PURE__*/Gn.div.withConfig({displayName:\"LoadingScreenContainer\",componentId:\"sc-9b080f09-2\"})([\"display:flex;align-items:center;justify-content:center;min-height:300px;padding:2rem;\"]);function Ga(e){let n=s(null),r=s();return c((()=>{r.current?.remove(),r.current=function({botUsername:e,scriptHost:t}){let n=document.createElement(\"script\"),{origin:r}=new URL(t);return n.async=!0,n.src=`${r}/js/telegram-login.js`,n.setAttribute(\"data-telegram-login\",e),n.setAttribute(\"data-request-access\",\"write\"),n.setAttribute(\"data-lang\",\"en\"),n}(e),n.current?.after(r.current)}),[e]),/*#__PURE__*/t(\"div\",{ref:n,hidden:!0})}const Ya=()=>{let{ready:e}=ge(),{client:t}=Ie();return c((()=>{let n=()=>{if(!t.connectors||!e)return;let n=t.connectors.wallets.map((e=>({address:e.address,connectorType:e.connectorType,walletClientType:e.walletClientType,connectedAt:e.connectedAt,id:e.meta.id})));Me.put(et,n)};return t.connectors?.on(\"walletsUpdated\",n),()=>{t.connectors?.off(\"walletsUpdated\",n)}}),[e,t.connectors]),null};class Ja extends j{async initialize(){let e=await this.createProvider();this.provider=e,this.proxyProvider.setWalletProvider(e),this.subscribeListeners(),e.session&&(this.walletProvider?.session?.peer.metadata.url&&(this.walletEntry=$(this.walletProvider?.session?.peer.metadata.url),this.walletClientType=this.walletEntry?.slug||\"unknown\"),this.connected=!0,await this.syncAccounts()),this.initialized=!0,this.emit(\"initialized\")}async connect(e){return e.showPrompt&&await this.promptConnection(),this.getConnectedWallet()}async isConnected(){return!!this.walletProvider?.connected}get walletBranding(){let e=this.walletProvider?.session?.peer.metadata.icons?.[0];return{name:G(this.walletProvider?.session?.peer.metadata.name||\"\")||\"WalletConnect\",icon:\"string\"==typeof e?e:xe,id:this.walletProvider?.session?.peer.metadata.name.toLowerCase()||\"wallet_connect_v2\"}}async resetConnection(e){this.walletProvider&&this.walletProvider.connected&&(await this.walletProvider.disconnect(),this.walletProvider.signer.session=void 0,this.walletClientType=e,this.redirectUri=void 0,this.fallbackUniversalRedirectUri=void 0,xn(),this.onDisconnect())}async promptConnection(){if(this.provider)return new Promise(((e,t)=>{(async()=>{let t=\"\",n=await Promise.race([this.walletProvider?.enable(),this.proxyProvider.walletTimeout()]);if(n?.length&&(t=n[0]),!t||\"\"===t)throw new ke(\"Unable to retrieve address\");this.walletProvider?.session?.peer.metadata.url&&(this.walletEntry=$(this.walletProvider?.session?.peer.metadata.url),this.walletClientType=this.walletEntry?.slug||\"unknown\",this.proxyProvider.rpcTimeoutDuration=Q(this.rpcConfig,this.walletClientType)),this.connected=!0,await this.syncAccounts(n),e()})().catch((e=>{t(e?Re(e):new ke(\"Unknown error during connection\"))}))}))}disconnect(){this.walletProvider?.disconnect().then((()=>this.onDisconnect())).catch((()=>console.warn(\"Unable to disconnect WalletConnect provider\")))}get walletProvider(){return this.proxyProvider.walletProvider}setWalletProvider(e){this.proxyProvider.setWalletProvider(e)}async createProvider(){let e={};for(let t of this.chains){let n=Y(t.id,this.chains,this.rpcConfig,this.privyAppId);n&&(e[t.id]=n)}let t=this.shouldEnforceDefaultChainOnConnect?[this.defaultChain.id]:[],n=this.chains.map((e=>e.id)),r=await or.init({projectId:this.walletConnectCloudProjectId,chains:t,optionalChains:n,optionalEvents:cr,optionalMethods:lr,rpcMap:e,showQrModal:!1,metadata:{description:this.privyAppName,name:this.privyAppName,url:window.location.origin,icons:[]}});return r.on(\"display_uri\",(e=>{if(r.signer.abortPairingAttempt(),Fn(),!this.showPrivyQrModal)throw new ke(\"WalletConnect modal not available - Privy handles wallet connections through its own UI\");if(ft&&this.walletEntry){let{redirect:t,href:n}=Ln(e,this.walletEntry);Rn(t,\"_self\"),Dn({href:n,name:this.walletEntry.metadata?.shortName||this.walletEntry.name});let r=jn(e,this.walletEntry);return this.redirectUri=t,this.fallbackUniversalRedirectUri=r?.redirect,this.showPrivyQrModal({native:t,universal:t})}if(this.redirectUri=void 0,this.walletEntry){let t=jn(e,this.walletEntry);this.fallbackUniversalRedirectUri=t?.redirect}this.showPrivyQrModal({native:e,universal:void 0})})),r.on(\"connect\",(()=>{r.session?.peer.metadata.url&&(this.walletEntry=$(r.session?.peer.metadata.url),this.walletClientType=this.walletEntry?.slug||\"unknown\")})),r}async enableProvider(){return this.walletProvider?.connected?Promise.resolve(this.walletProvider.accounts):await(this.walletProvider?.enable())}setWalletEntry(e,t){this.walletEntry=e,this.showPrivyQrModal=t}constructor({walletConnectCloudProjectId:e,rpcConfig:t,chains:n,defaultChain:r,shouldEnforceDefaultChainOnConnect:a,privyAppId:i,privyAppName:s,walletClientType:o}){super(o||\"unknown\",n,r,t),this.connectorType=\"wallet_connect_v2\",this.privyAppId=i,this.privyAppName=s,this.walletConnectCloudProjectId=e,this.rpcConfig=t,this.shouldEnforceDefaultChainOnConnect=a,this.proxyProvider=new z(void 0,this.rpcTimeoutDuration),o&&(this.walletEntry=J(o),this.walletClientType=o)}}const Qa=[\"error\",\"invalid_request_arguments\",\"wallet_not_on_device\",\"invalid_recovery_pin\",\"insufficient_funds\",\"missing_or_invalid_mfa\",\"mfa_verification_max_attempts_reached\",\"mfa_timeout\",\"twilio_verification_failed\"];class Za extends Error{constructor(e,t){super(t),this.type=e}}function Xa(e){let t=e.type;return\"string\"==typeof t&&Qa.includes(t)}function ei(e){return Xa(e)&&\"wallet_not_on_device\"===e.type}function ti(e){return Xa(e)&&(\"invalid_recovery_pin\"===e.type||\"invalid_request_arguments\"===e.type)}function ni(e){return!!Xa(e)&&\"mfa_timeout\"===e.type}function ri(e){return!!Xa(e)&&\"missing_or_invalid_mfa\"===e.type}function ai(e){return!!Xa(e)&&\"mfa_verification_max_attempts_reached\"===e.type}function ii(e){return!(!Xa(e)||!e.message.includes(\"code 429\"))}function si(e){return!!function(e){let t=e.type;return\"string\"==typeof t&&\"client_error\"===t}(e)&&\"MFA canceled\"===e.message}async function oi(e,t,n,r,a,i=!1){let s=i,o=async o=>{if(s&&t&&t.length>0){o===(i?0:1)?a(\"configureMfa\",\"onMfaRequired\",{mfaMethods:t}):r.current?.reject(new Za(\"missing_or_invalid_mfa\",\"MFA verification failed, retry.\"));let s=await new Promise(((e,t)=>{n.current={resolve:e,reject:t},setTimeout((()=>{let e=new Za(\"mfa_timeout\",\"Timed out waiting for MFA code\");r.current?.reject(e),t(e)}),3e5)}));return await e(s)}return await e()},l=null;for(let e=0;e<4;e++)try{l=await o(e),r.current?.resolve(void 0);break}catch(e){if(\"missing_or_invalid_mfa\"!==e.type)throw r.current?.resolve(void 0),e;s=!0}if(null===l){let e=new Za(\"mfa_verification_max_attempts_reached\",\"Max MFA verification attempts reached\");throw r.current?.reject(e),e}return l}var li;let ci=(li=0,()=>\"id-\"+li++);function di(e){return void 0!==e.error}let ui=new class{enqueue(e,t){this.callbacks[e]=t}dequeue(e,t){let n=this.callbacks[t];if(!n)throw Error(`cannot dequeue ${e} event: no event found for id ${t}`);switch(delete this.callbacks[t],e){case\"privy:iframe:ready\":case\"privy:user-signer:sign\":case\"privy:wallets:add\":case\"privy:wallets:import\":case\"privy:wallets:set-recovery\":case\"privy:wallets:connect\":case\"privy:wallets:recover\":case\"privy:wallets:rpc\":case\"privy:wallet:create\":case\"privy:mfa:verify\":case\"privy:mfa:init-enrollment\":case\"privy:mfa:submit-enrollment\":case\"privy:mfa:unenroll\":case\"privy:mfa:clear\":case\"privy:auth:unlink-passkey\":case\"privy:farcaster:init-signer\":case\"privy:farcaster:sign\":case\"privy:solana-wallet:create\":case\"privy:delegated-actions:consent\":return n;default:throw Error(`invalid wallet event type ${e}`)}}constructor(){this.callbacks={}}},hi=new Map,pi=(e,t)=>\"bigint\"==typeof t?t.toString():t;function wi(e,t,n,r){let a=n.contentWindow;if(!a)throw Error(\"iframe not initialized\");let i=((e,t)=>`${e}${JSON.stringify(t,pi)}`)(e,t);if(\"privy:wallet:create\"===e){let e=hi.get(i);if(e)return e}let s=new Promise(((n,i)=>{let s=ci();ui.enqueue(s,{resolve:n,reject:i}),a.postMessage({id:s,event:e,data:t},r)})).finally((()=>{hi.delete(i)}));return hi.set(i,s),s}function mi(e){let n=tt(),r=s(null),a=s(e.mfaMethods),i=Zn(),[l,d]=o(!1);return c((()=>{a.current=e.mfaMethods}),[e.mfaMethods]),c((()=>{if(!l)return;let t=r.current;if(!t)return;function n(t){var n;t&&t.origin===e.origin&&\"string\"==typeof(n=t.data).event&&/^privy:.+/.test(n.event)&&function(e){switch(e.event){case\"privy:iframe:ready\":let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data);case\"privy:user-signer:sign\":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case\"privy:wallets:add\":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case\"privy:wallets:set-recovery\":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case\"privy:wallets:connect\":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case\"privy:wallets:recover\":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case\"privy:wallets:rpc\":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case\"privy:wallet:create\":let n=ui.dequeue(e.event,e.id);return di(e)?n.reject(new Za(e.error.type,e.error.message)):n.resolve(e.data);case\"privy:wallets:import\":let r=ui.dequeue(e.event,e.id);return di(e)?r.reject(new Za(e.error.type,e.error.message)):r.resolve(e.data);case\"privy:mfa:verify\":let a=ui.dequeue(e.event,e.id);return di(e)?a.reject(new Za(e.error.type,e.error.message)):a.resolve(e.data);case\"privy:mfa:init-enrollment\":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case\"privy:mfa:submit-enrollment\":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case\"privy:mfa:unenroll\":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case\"privy:mfa:clear\":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case\"privy:auth:unlink-passkey\":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case\"privy:solana-wallet:create\":let i=ui.dequeue(e.event,e.id);return di(e)?i.reject(new Za(e.error.type,e.error.message)):i.resolve(e.data);case\"privy:farcaster:init-signer\":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case\"privy:farcaster:sign\":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}case\"privy:delegated-actions:consent\":{let t=ui.dequeue(e.event,e.id);return di(e)?t.reject(new Za(e.error.type,e.error.message)):t.resolve(e.data)}default:console.warn(\"Unsupported wallet proxy method:\",e)}}(t.data)}let s={signWithUserSigner:n=>oi((r=>wi(\"privy:user-signer:sign\",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),addWallet:n=>oi((r=>wi(\"privy:wallets:add\",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),setRecovery:n=>oi((r=>wi(\"privy:wallets:set-recovery\",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),connect:n=>oi((r=>wi(\"privy:wallets:connect\",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),recover:n=>oi((r=>wi(\"privy:wallets:recover\",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i,!n.recoveryAccessToken&&!n.recoveryPassword&&!n.recoverySecretOverride),rpc:n=>oi((r=>wi(\"privy:wallets:rpc\",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),create:n=>wi(\"privy:wallet:create\",n,t,e.origin),importWallet:n=>wi(\"privy:wallets:import\",n,t,e.origin),createSolana:n=>oi((r=>wi(\"privy:solana-wallet:create\",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),createDelegatedAction:n=>wi(\"privy:delegated-actions:consent\",n,t,e.origin),verifyMfa:n=>oi((r=>wi(\"privy:mfa:verify\",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i,!0),initEnrollMfa:n=>oi((r=>wi(\"privy:mfa:init-enrollment\",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),submitEnrollMfa:n=>oi((r=>wi(\"privy:mfa:submit-enrollment\",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),unenrollMfa:n=>oi((r=>wi(\"privy:mfa:unenroll\",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),clearMfa:n=>wi(\"privy:mfa:clear\",n,t,e.origin),unlinkPasskeyAccount:n=>oi((r=>wi(\"privy:auth:unlink-passkey\",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),initFarcasterSigner:n=>wi(\"privy:farcaster:init-signer\",n,t,e.origin),signFarcasterMessage:n=>wi(\"privy:farcaster:sign\",n,t,e.origin)};window.addEventListener(\"message\",n);let o=new AbortController;return Z((()=>wi(\"privy:iframe:ready\",{},t,e.origin)),{abortSignal:o.signal}).then((()=>e.onLoad(s)),((...t)=>{console.warn(\"Privy iframe failed to load: \",...t),e.onLoadFailed()})),()=>{window.removeEventListener(\"message\",n),o.abort()}}),[l]),n?\n/*#__PURE__*/t(\"iframe\",{ref:r,width:\"0\",height:\"0\",style:{display:\"none\",height:\"0px\",width:\"0px\"},onLoad:()=>d(!0),src:dr({origin:e.origin,path:`/apps/${e.appId}/embedded-wallets`,query:{caid:e.clientAnalyticsId,client_id:e.appClientId}})}):null}const yi=({address:e,user:t})=>{let n=t.linkedAccounts.find((t=>\"wallet\"===t.type&&\"privy\"===t.walletClientType&&t.address===e));if(!n)throw new Ce(\"Address to delegate is not associated with current user.\");if(!Fe(n))throw new Ce(`useDelegatedActions is not supported for ${n.chainType} wallets. Use the useSessionSigners hook to provision server side access on behalf of your users.`);return{address:n.address,chainType:n.chainType,walletIndex:n.walletIndex??0}},gi=({address:e,user:t})=>{let n=t.linkedAccounts.find((t=>\"wallet\"===t.type&&\"privy\"===t.walletClientType&&t.address===e));if(!n)throw new Ce(\"Address to delegate is not associated with current user.\");let r=n.imported?n:b(t);if(!r)throw new Ce(\"Unable to determine root address for delegated address.\");if(!Fe(r))throw new Ce(`useDelegatedActions is not supported for ${r.chainType} wallets. Use the useSessionSigners hook to provision server side access on behalf of your users.`);return{address:r.address,chainType:r.chainType,imported:r.imported}},fi=e=>e.linkedAccounts.filter((e=>\"wallet\"===e.type&&\"privy\"===e.walletClientType&&e.delegated));const vi=\"popup-privy-oauth\",Ai=\"PRIVY_OAUTH_USE_BROADCAST_CHANNEL\";class ki{async authenticate(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");try{return await this.api.post(xt,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:this.meta.codeVerifier,provider:this.meta.provider})}catch(e){throw Te(e)}}async link(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");try{return await this.api.post(Ft,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:this.meta.codeVerifier,provider:this.meta.provider})}catch(e){throw Te(e)}}constructor({authorizationCode:e,stateCode:t,codeVerifier:n,provider:r}){this.meta={authorizationCode:e,stateCode:t,codeVerifier:n,provider:r}}}async function Ci({api:e,requesterAppId:t,providerAppId:n}){let r=(await e.get(`/api/v1/apps/${t}/cross-app/connections`)).connections.find((e=>e.provider_app_id===n));if(!r)throw new Ce(\"Invalid connected app\");return{name:r.provider_app_name,logoUrl:r.provider_app_icon_url||void 0,apiUrl:r.provider_app_custom_api_url,readOnly:r.read_only,customAuthAuthorizeUrl:r.provider_app_custom_auth_authorize_url,customAuthTransactUrl:r.provider_app_custom_auth_transact_url}}const Ti=async({user:e,address:t,client:n,request:r,requesterAppId:a,reconnect:i})=>{n.createAnalyticsEvent({eventName:\"cross_app_request_started\",payload:{address:t,method:r.method}});let s=e?.linkedAccounts.find((e=>\"cross_app\"===e.type&&(e.embeddedWallets.some((e=>e.address===t))||e.smartWallets.some((e=>e.address===t)))));if(!e||!s)throw n.createAnalyticsEvent({eventName:\"cross_app_request_error\",payload:{error:\"Cannot request a signature with this wallet address\",address:t}}),new Ce(\"Cannot request a signature with this wallet address\");let o=n.getProviderAccessToken(s.providerApp.id),l=await Ci({api:n.api,requesterAppId:a,providerAppId:s.providerApp.id});if(!o){if(l.readOnly)throw console.error(\"cannot transact against a read-only provider app\"),new Ce(\"Cannot transact against a read-only provider app\");await i({appId:s.providerApp.id,action:\"link\"})&&(o=n.getProviderAccessToken(s.providerApp.id))}if(!o)throw n.createAnalyticsEvent({eventName:\"cross_app_request_error\",payload:{error:\"Transactions require a valid token\",address:t}}),new Ce(\"Transactions require a valid token\");let c=new URL(l.customAuthTransactUrl||`${l.apiUrl}/oauth/transact`);c.searchParams.set(\"token\",o||\"\"),c.searchParams.set(\"request\",_i(r));let d=Et({location:c.href});if(!d)throw n.createAnalyticsEvent({eventName:\"cross_app_request_error\",payload:{error:\"Missing token\",address:t}}),new Ce(\"Failed to initialize signature request\");return new Promise(((e,a)=>{let i=setTimeout((()=>{c(),a(new Ce(\"Request timeout\")),n.createAnalyticsEvent({eventName:\"cross_app_request_error\",payload:{error:\"Request timeout\",address:t}})}),12e4),o=setInterval((()=>{d.closed&&(c(),a(new Ce(\"User rejected request\")),n.createAnalyticsEvent({eventName:\"cross_app_request_error\",payload:{error:\"User rejected request\",address:t}}))}),300),l=i=>{i.data&&(\"set\"===i.data.token?.action&&void 0!==i.data.token?.value?n.storeProviderAccessToken(s.providerApp.id,i.data.token.value):\"clear\"===i.data.token?.action&&n.storeProviderAccessToken(s.providerApp.id,null),\"PRIVY_CROSS_APP_ACTION_RESPONSE\"===i.data.type&&i.data.result&&(c(),e(i.data.result),n.createAnalyticsEvent({eventName:\"cross_app_request_success\",payload:{address:t,method:r.method}})),\"PRIVY_CROSS_APP_ACTION_ERROR\"===i.data.type&&i.data.error&&(c(),a(i.data.error),n.createAnalyticsEvent({eventName:\"cross_app_request_error\",payload:{error:i.data.error,address:t}})))};window.addEventListener(\"message\",l);let c=()=>{d.close(),clearInterval(o),clearTimeout(i),window.removeEventListener(\"message\",l)}}))};let _i=e=>JSON.stringify({content:{request:{request:bi(e,ur)}},timestamp:Date.now(),callbackUrl:window.origin});const bi=(e,t)=>\"bigint\"==typeof e?t(e):Array.isArray(e)?e.map((e=>bi(e,t))):e&&\"object\"==typeof e?Object.fromEntries(Object.entries(e).map((([e,n])=>[e,bi(n,t)]))):e;function Si({isCreatingWallet:e,skipSplashScreen:t}){return e?\"EmbeddedWalletPasswordCreateScreen\":t?\"EmbeddedWalletPasswordUpdateScreen\":\"EmbeddedWalletPasswordUpdateSplashScreen\"}function Ei({walletAction:e,availableRecoveryMethods:t,legacySetWalletPasswordFlow:n,isResettingPassword:r,showAutomaticRecovery:a}){return a?\"SetAutomaticRecoveryScreen\":n||1===t.length?Si({isCreatingWallet:\"create\"===e,skipSplashScreen:r}):\"RecoverySelectionScreen\"}function Ii(e){switch(e){case\"user-passcode\":return\"PasswordRecoveryScreen\";case\"google-drive\":case\"icloud\":return\"RecoveryOAuthScreen\";default:throw Error(\"Recovery method not supported\")}}function Pi(e,t,n,r,a,i,s){return{...e,funding:e?.funding?{...e.funding,fundingResult:{status:t,address:e.funding.address,fundingMethod:void 0,transactionHash:n,amount:e.funding.amount,assetType:a?i?.symbol||\"ETH\":s.nativeCurrency.symbol||\"ETH\",metadata:{walletClientType:r}}}:void 0,solanaFundingData:e?.solanaFundingData,sendTransaction:e?.sendTransaction}}const Wi=new Map([[\"FundingMethodSelectionScreen\",null],[\"TransferFromWalletScreen\",\"external\"],[\"FundingAmountEditScreen\",\"external\"],[\"ConnectOnlyLandingScreen\",\"external\"],[\"ConnectOnlyStatusScreen\",\"external\"],[\"AwaitingExternalEthereumTransferScreen\",\"external\"],[\"AwaitingEvmToSolBridgingScreen\",\"external\"],[\"AwaitingSolToEvmBridgingScreen\",\"external\"],[\"ManualTransferScreen\",\"manual\"],[\"MoonpayStatusScreen\",\"moonpay\"]]);function Ui(e){let t=e.toLowerCase();return!!window?.webkit?.messageHandlers?.ReactNativeWebView||!!window?.ReactNativeWebView||[\"fbav\",\"fban\",\"instagram\",\"snapchat\",\"linkedinapp\"].some((e=>t.includes(e)))}async function Ni({rpc:e,address:t}){return(await e.getBalance(t,{commitment:\"confirmed\"}).send()).value??0n}let Oi={apple_oauth:\"apple\",custom_auth:\"custom\",discord_oauth:\"discord\",email:\"email\",farcaster:\"farcaster\",github_oauth:\"github\",google_oauth:\"google\",instagram_oauth:\"instagram\",linkedin_oauth:\"linkedin\",passkey:\"passkey\",phone:\"sms\",spotify_oauth:\"spotify\",telegram:\"telegram\",tiktok_oauth:\"tiktok\",line_oauth:\"line\",twitch_oauth:\"twitch\",twitter_oauth:\"twitter\",wallet:\"siwe\",smart_wallet:\"siwe\",cross_app:\"privy:\"};const Ri=e=>{if(S(e))return{displayName:e.replace(\"custom:\",\"\"),loginMethod:\"custom\"};let t=Oi[e];return\"wallet\"===e||\"phone\"===e?{displayName:e,loginMethod:t}:{displayName:t,loginMethod:t}},Mi=(e,t)=>!E(e)&&(\"all-users\"===t||\"users-without-wallets\"===t&&!xi(e).length);let xi=e=>e.linkedAccounts.filter((e=>\"wallet\"===e.type&&\"ethereum\"===e.chainType));const Fi=(e,t)=>!I(e)&&(\"all-users\"===t||\"users-without-wallets\"===t&&!Li(e).length);let Li=e=>e.linkedAccounts.filter((e=>\"wallet\"===e.type&&\"solana\"===e.chainType));async function Di(e,t,n,r){let a=Be(e),{chain:i,...s}=await(async()=>r?await r():await t.prepareTransactionRequest({...a,account:{address:n,type:\"json-rpc\"}}))();return{...s,type:Ke[s.type]}}const ji=()=>{let e=Xe(),{user:t}=T(),{client:n,refreshSessionAndUser:r,walletProxy:a}=Ie();return{migrate:h((async()=>{if(\"legacy-embedded-wallets-only\"===e.embeddedWallets.mode)return{success:!0};if(!t)throw new Ce(\"User must be authenticated before migrating wallets\",_e.MUST_BE_AUTHENTICATED);if(!a)throw new Ce(\"Cannot connect to wallet proxy\");let i=await n.getAccessToken();if(!i)throw new Ce(\"User must be authenticated before migrating wallets\",_e.MUST_BE_AUTHENTICATED);let s=t.linkedAccounts.filter((e=>\"wallet\"===e.type&&\"privy\"===e.walletClientType&&Fe(e)&&!P(e)));if(0===s.length)return{success:!0};let o=s.filter((e=>e.imported)),l=s.filter((e=>!e.imported));if(l.length>0){let e=l.find((e=>\"ethereum\"===e.chainType&&0===e.walletIndex))??l.find((e=>\"solana\"===e.chainType&&0===e.walletIndex))??null;if(!e)throw new Ce(\"Primary wallet not found\");let{entropyId:t,entropyIdVerifier:n}=fe(e);try{await a.connect({accessToken:i,entropyId:t,entropyIdVerifier:n})}catch(r){if(!ei(r)||\"privy\"!==e.recoveryMethod)throw r;await a.recover({accessToken:i,entropyId:t,entropyIdVerifier:n})}await a.createDelegatedAction({accessToken:i,rootWallet:{address:e.address,chainType:e.chainType,imported:!1},delegatedWallets:l.map((e=>({address:e.address,chainType:e.chainType,walletIndex:e.walletIndex??0})))})}for(let e of o){let{entropyId:t,entropyIdVerifier:n}=fe(e);try{await a.connect({accessToken:i,entropyId:t,entropyIdVerifier:n})}catch(o){if(!ei(o)||\"privy\"!==e.recoveryMethod)throw o;await a.recover({accessToken:i,entropyId:t,entropyIdVerifier:n})}await a.createDelegatedAction({accessToken:i,rootWallet:{address:e.address,chainType:e.chainType,imported:!0},delegatedWallets:[{address:e.address,chainType:e.chainType,walletIndex:e.walletIndex??0}]})}return await r(),{success:!0}}),[e.embeddedWallets.mode,t,a,n,r])}},zi=({disabled:e})=>{let{migrate:t}=ji(),{user:n}=T(),{walletProxy:r}=Ie(),a=s(!1);return c((()=>{!e&&!a.current&&n&&r&&(a.current=!0,t().catch((e=>{console.debug(\"Unable to migrate wallets: \",e)})).finally((()=>{a.current=!1})))}),[n,r,e,t]),null},qi=e=>({id:e.id,raw_id:e.rawId,response:{client_data_json:e.response.clientDataJSON,authenticator_data:e.response.authenticatorData,signature:e.response.signature,user_handle:e.response.userHandle},authenticator_attachment:e.authenticatorAttachment,client_extension_results:{app_id:e.clientExtensionResults.appid,cred_props:e.clientExtensionResults.credProps,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret},type:e.type}),Hi=nr((()=>({ethereum:[]}))),Vi=()=>Hi.getState().ethereum;class Bi{async authenticate(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");try{return await this.api.post(Qt,{token:this.meta.token})}catch(e){throw Te(e)}}async link(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");try{return await this.api.post(Zt,{token:this.meta.token})}catch(e){throw Te(e)}}constructor(e){this.meta={token:e}}}function Ki({subscribe:e,getExternalJwt:t,enabled:n=!0,onAuthenticated:r,onUnauthenticated:a,onError:i}){let{client:l,onCustomAuthAuthenticated:d}=Ie(),{logout:u,authenticated:h,ready:p}=zn();if(!l)throw new Ce(\"`useSyncJwtBasedAuthState` must be used within a `PrivyProvider`\");let[w,m]=o({status:\"initial\"}),y=s(),g=s(!1),f=s(t);c((()=>{f.current=t}),[t]);let v=s(r);c((()=>{v.current=r}),[r]);let A=s(a);c((()=>{A.current=a}),[a]);let k=s(i);return c((()=>{k.current=i}),[i]),c((()=>{if(!n||!p)return;let t=async()=>{if(!g.current){g.current=!0;try{m({status:\"loading\"});let e=await f.current();if(void 0!==y.current&&y.current===e)return void m({status:\"done\"});if(!e)return h&&(await u(),A.current?.()),y.current=e,void m({status:\"done\"});l.startAuthFlow(new Bi(e));let{user:t,isNewUser:n=!1}=await l.authenticate();if(!t)throw new Ce(\"Failed to sync with custom auth provider\");v.current?.({user:t,isNewUser:n}),d(t,n),y.current=e,m({status:\"done\"})}catch(e){if(console.warn(e),await u().catch((()=>{})),A.current?.(),e instanceof Pe&&e.privyErrorCode===_e.LINKED_TO_ANOTHER_USER)return m({status:\"initial\"}),void setTimeout((()=>{t()}),0);k.current?.(e),m({status:\"error\",error:e})}finally{g.current=!1}}};return t(),e(t)}),[e,l,d,h,u,n,p]),n?{state:w}:{state:{status:\"not-enabled\"}}}let $i=nr((()=>({jwtAuthFlowState:{status:\"not-enabled\"}})));function Gi({customAuth:e}){let{jwtAuthFlowState:t}=function({customAuth:e}){let t=Zn(),n=s(),r=h((e=>(n.current=e,()=>{n.current=void 0})),[]),a=e?.getCustomAccessToken??(()=>Promise.resolve(void 0)),{state:i}=Ki({enabled:!0===e?.enabled,subscribe:r,getExternalJwt:a,onAuthenticated:({user:e,isNewUser:n})=>{t(\"login\",\"onComplete\",{user:e,isNewUser:n,wasAlreadyAuthenticated:!1,loginMethod:\"custom\",loginAccount:null}),t(\"customAuth\",\"onAuthenticated\",{user:e})},onUnauthenticated:()=>{t(\"customAuth\",\"onUnauthenticated\")},onError:e=>{t(\"login\",\"onError\",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR)}});return c((()=>{(async()=>{e&&!e.isLoading&&n.current?.()})()}),[e?.enabled,e?.getCustomAccessToken,e?.isLoading]),{jwtAuthFlowState:i}}({customAuth:e});return c((()=>{$i.setState({jwtAuthFlowState:t})}),[t]),null}const Yi=/*#__PURE__*/i(!1);let Ji,Qi,Zi,Xi,es;const ts=n=>{let r=n.client,a=n.privy,i=qn(),d=Xe();X(ee(d?.appearance.walletList??[]));let[u,p]=o(!1),w=Pa((e=>e.inProgressMfaFlow)),[y,g]=o(!1),[f,v]=o(null),A=Hi((e=>e.ethereum)),[k,C]=o(void 0),[T,_]=o(!1),[S,I]=o(null),[F,L]=o(!1),[D,j]=o({status:\"disconnected\",connectedWallet:null,connectError:null,connector:null,connectRetry:Se}),[z,q]=o({status:\"initial\"}),[H,B]=o({status:\"initial\"}),[K,$]=o({status:\"initial\"}),[G,Y]=o({status:\"initial\"}),[J,Q]=o({status:\"initial\"}),[Z,ce]=o({status:\"initial\"}),[de,ue]=o(null),he=tt(),[pe,we]=o({}),[me,ye]=o(null),ge=s(null),[fe,Ee]=o(!1),[Ie,Pe]=o(!1),Ne=s(null),Oe=s(null),Re=s(Xn),[xe,He]=o(!1),[Ve,Be]=o(!1),Ke=h((e=>{Be(e),!e&&S&&Ea[S]().then((e=>{e.default.isUnauthenticatedScreem&&I(null)}))}),[S]);r.onStoreCustomerAccessToken=e=>{e&&er(Re,\"accessToken\",\"onAccessTokenGranted\",{accessToken:e})},r.onDeleteCustomerAccessToken=()=>{v(null),Ke(!1),er(Re,\"accessToken\",\"onAccessTokenRemoved\")};let $e=s(null),Ge=s(null),Ye=s(!1),et=({showWalletUIs:e})=>Ye.current?Ye.current:void 0!==e?!e:!d.embeddedWallets.showWalletUIs,it=e=>{I(e),setTimeout((()=>{p(!0)}),15)};c((()=>{if(!f)return void r.connectors?.removeEmbeddedWalletConnectors();let e=E(f),t=W(f),i=U(f);e&&t.length||r.connectors?.removeEmbeddedWalletConnectors(),i.length||r.connectors?.removeImportedWalletConnectors(),r.connectors?de?(e&&r.connectors.addEmbeddedWalletConnectors({walletProxy:de,user:f,embeddedWallets:t,defaultChain:d.defaultChain,appId:n.appId,privyClient:a}),i.forEach((e=>r.connectors?.addImportedWalletConnector(de,e.address,d.defaultChain,n.appId)))):console.debug(\"Failed to add embedded wallet connector: Wallet proxy not initialized\"):console.debug(\"Failed to add embedded wallet connector: Client connectors not initialized\")}),[de,f]),c((()=>{de&&ge.current?.(de)}),[de]);let st=h(((e,t)=>{v(e),_(t),Ke(!0),Pe(!0)}),[]);c((()=>{Ie&&de&&f&&(async()=>{let e=Mi(f,d.embeddedWallets.ethereum.createOnLogin),t=Fi(f,d.embeddedWallets.solana.createOnLogin),n=await Kr();if(n){if(e&&t){let e=await de.create({accessToken:n});return await de.createSolana({accessToken:n,ethereumAddress:e?.address}),void Pe(!1)}if(t)return await de.createSolana({accessToken:n,ethereumAddress:E(f)?.address}),await Ut.refreshSessionAndUser(),void Pe(!1);if(e)return await de.create({accessToken:n}),void Pe(!1)}})().catch(console.error)}),[Ie&&de&&f]),c((()=>{if(d.externalWallets.solana.connectors)return d.externalWallets.solana.connectors.onMount(),()=>d.externalWallets.solana.connectors?.onUnmount()}),[d.externalWallets.solana.connectors]),c((()=>{!y&&he&&async function(){let e,t=ot(),n=lt(),a=gt();r.initializeConnectorManager({walletConnectCloudProjectId:d.walletConnectCloudProjectId,rpcConfig:d.rpcConfig,chains:d.chains,defaultChain:d.defaultChain,store:a,walletList:d.appearance.walletList,shouldEnforceDefaultChainOnConnect:d.shouldEnforceDefaultChainOnConnect,externalWalletConfig:d.externalWallets,appName:d.name??\"Privy\",walletChainType:d.appearance.walletChainType,setBaseAccountSdk:C}),r.connectors?.on(\"connectorInitialized\",(()=>{e&&clearTimeout(e);let t=r.connectors.walletConnectors.length,n=r.connectors.walletConnectors.reduce(((e,t)=>e+(t.initialized?1:0)),0);n===t?He(!0):e=setTimeout((()=>{console.debug({message:\"Unable to initialize all expected connectors before timeout\",initialized:n,expected:t}),He(!0)}),1500)})),r.connectors?.initialize().then((()=>{pt()}));let i=await r.getAuthenticatedUser(),s=!!i;d.legal.requireUsersAcceptTerms&&i&&!i.hasAcceptedTerms?(await r.logout(),Ut.setReadyToTrue(!0),er(Re,\"logout\",\"onSuccess\")):(d.customAuth?.enabled||(Ke(!!i),i&&er(Re,\"login\",\"onComplete\",{user:i,isNewUser:!1,wasAlreadyAuthenticated:!0,loginMethod:null,loginAccount:null}),v(i)),t?Ge.current=s?\"link\":\"login\":n&&!s?(Ge.current=\"login\",we({telegramAuthModalData:{seamlessAuth:!0}}),it(\"TelegramAuthScreen\")):Ut.setReadyToTrue(!!i))}()}),[r,me,y,he]),c((()=>{if(y){if(!f||!f.linkedAccounts.find((e=>\"wallet\"===e.type&&\"privy\"===e.walletClientType)))return void Ee(!!de);if([...A].some((e=>\"privy\"===e.walletClientType)))return void Ee(!0);Ee(!!de)}}),[y,f,A,de]),c((()=>{r.connectors?.setWalletList(d.appearance.walletList)}),[d.appearance.walletList.join()]);let ot=()=>{let e=la();return e.inProgress&&e.popupFlow?window.opener.location.origin!==window.location.origin?void window.opener.postMessage({type:\"PRIVY_OAUTH_ERROR\",error:\"Origins between parent and child windows do not match.\"}):\"error\"===e.authorizationCode?void window.opener.postMessage({type:\"PRIVY_OAUTH_ERROR\",error:\"Something went wrong. Try again.\"}):void window.opener.postMessage({type:\"PRIVY_OAUTH_RESPONSE\",stateCode:e.stateCode,authorizationCode:e.authorizationCode}):(e.inProgress&&e.provider.startsWith(\"privy:\")&&!e.popupFlow&&(new BroadcastChannel(vi).postMessage({type:\"PRIVY_OAUTH_RESPONSE\",stateCode:e.stateCode,authorizationCode:e.authorizationCode}),window.close()),!!e.inProgress&&!!e.withPrivyUi&&(r.startAuthFlow(new oa({...e,customOAuthRedirectUrl:d.customOAuthRedirectUrl})),it(\"OAuthStatusScreen\"),!0))},lt=()=>{let e=function(){let e;return(e=function(){let e=new URLSearchParams(window.location.search),t=Number(e.get(\"id\")||\"\"),n=e.get(\"hash\"),r=Number(e.get(\"auth_date\")||\"\"),a=e.get(\"first_name\");if(t&&a&&r&&n)return Object.fromEntries(e.entries())}())?(Ta(),{flowType:\"login-url\",authData:e}):(e=function(){let e=window.location.hash;if(!e||!e.startsWith(\"#tgWebAppData\"))return;let t=Ca(e.replace(\"#tgWebAppData=\",\"\")),{user:n,auth_date:r,hash:a}=t;return n&&r&&a?t:void 0}())?(Ta(),{flowType:\"web-app\",authData:e}):void 0}();if(!e||!d.loginMethods.telegram||!d.loginConfig.telegramAuthConfiguration?.seamlessAuthEnabled)return;let t=new Aa;return r.startAuthFlow(t),\"login-url\"===e.flowType&&(t.meta.telegramWebAppData=void 0,t.meta.telegramAuthResult=e.authData),\"web-app\"===e.flowType&&(t.meta.telegramAuthResult=void 0,t.meta.telegramWebAppData=e.authData),!0},ct=async(e,t,n,a)=>{if(\"solana_adapter\"!==e)dt(await(r.connectors?.createEthereumWalletConnector({connectorType:e,walletClientType:t}))||null,t,n,a);else{let e=r.connectors?.findSolanaWalletConnector(t);if(!e)return;dt(e,t,n,a)}};async function dt(e,t,n,r){if(!e)return j({status:\"disconnected\",connectedWallet:null,connectError:new ke(\"Unable to connect to wallet.\"),connector:null,connectRetry:Se}),r?.(null,n);j({status:\"disconnected\",connectedWallet:null,connectError:null,connector:e,connectRetry:Se}),e instanceof Ja&&t&&await e.resetConnection(t),j({connector:e,status:\"connecting\",connectedWallet:null,connectError:null,connectRetry:()=>dt(e,t,n,r)});try{let t=await e.connect({showPrompt:!0});if((!t||te(t))&&d.shouldEnforceDefaultChainOnConnect&&!d.chains.find((e=>e.id===Number(t?.chainId.replace(\"eip155:\",\"\"))))&&(\"wallet_connect_v2\"!==t?.connectorType||\"metamask\"!==t?.walletClientType)){j((t=>({...t,connector:e,status:\"switching_to_supported_chain\",connectedWallet:null,connectError:null,connectRetry:Se})));try{await(t?.switchChain(d.defaultChain.id)),t&&(t.chainId=ne(Ct(d.defaultChain.id)))}catch{console.warn(`Unable to switch to default chain: ${d.defaultChain.id}`)}}return j((e=>({...e,status:\"connected\",connectedWallet:t,connectError:null,connectRetry:Se}))),t&&er(Re,\"connectWallet\",\"onSuccess\",{wallet:t}),r?.(t,n)}catch(e){return e instanceof be?(console.warn(e.cause?e.cause:e.message),er(Re,\"connectWallet\",\"onError\",e.privyErrorCode||_e.GENERIC_CONNECT_WALLET_ERROR)):(console.warn(e),er(Re,\"connectWallet\",\"onError\",_e.UNKNOWN_CONNECT_WALLET_ERROR)),j((t=>({...t,status:\"disconnected\",connectedWallet:null,connectError:e}))),r?.(null,n)}}let ut=async(e,t,n)=>{if(null===e||!te(e))return;let a=new ha(r,e,t,n);r.startAuthFlow(a)},ht=async(e,t,n,a=\"plain\")=>{let s=i(Vn);if(\"transaction\"===a&&!s)throw new Ce(\"useSolanaLedger plugin hook must be mounted\");if(null===e||!se(e))return;let o=new pa(e,r,t,n,a,s);r.startAuthFlow(o)},pt=async()=>{let e=new URLSearchParams(window.location.search),t=e.get(\"privy_connector\"),n=e.get(\"privy_wallet_client\"),a=\"true\"===e.get(\"privy_connect_only\");if(!t||!n)return;let i=le({connectorType:t,walletClientType:n});if(!i||!i.isInstalled)return it(\"LoginFailedScreen\");if(!r.connectors)throw new Ce(\"Connector not initialized\");await it(a?\"ConnectOnlyStatusScreen\":\"ConnectionStatusScreen\");let s=new URL(window.location.href);s.searchParams.delete(\"privy_connector\"),s.searchParams.delete(\"privy_wallet_client\"),s.searchParams.delete(\"privy_connect_only\"),window.history.pushState({},\"\",s),ct(t,n,void 0,a?void 0:\"solana_adapter\"===t?ht:ut)};c((()=>{y&&Ve&&null===f&&r.getAuthenticatedUser().then(v)}),[y,Ve,f,r]);let wt=e=>{if(!Ve)throw er(Re,\"linkAccount\",\"onError\",_e.MUST_BE_AUTHENTICATED,{linkMethod:e}),new Ce(\"User must be authenticated before linking an account.\")},mt=e=>{if(!Ve||!f)return!1;if(\"privy\"===e.walletClientType)return!0;for(let t of f.linkedAccounts)if(\"wallet\"===t.type&&t.address===e.address&&\"privy\"!==t.walletClientType)return!0;return!1},yt=()=>{Hi.setState((e=>{let t=r.connectors?.wallets.filter(te).map((e=>({...e,linked:mt(e),loginOrLink:async()=>{if(!await e.isConnected())throw new Ce(\"Wallet is not connected\");if(\"embedded\"===e.connectorType&&\"privy\"===e.walletClientType)throw new Ce(\"Cannot link or login with embedded wallet\");(async e=>{let t;if(!r.connectors)throw new Ce(\"Connector not initialized\");t=\"ethereum\"===e.type?r.connectors.findWalletConnector(e.connectorType,e.walletClientType)||null:r.connectors.findSolanaWalletConnector(e.walletClientType)||null,j((n=>({...n,connector:t,status:\"connected\",connectedWallet:e,connectError:null,connectRetry:Se}))),d.captcha.enabledProvider&&!Ve?(we({captchaModalData:{callback:t=>te(e)?ut(e,t):ht(e,t),userIntentRequired:!1,onSuccessNavigateTo:\"ConnectionStatusScreen\",onErrorNavigateTo:\"ErrorScreen\"}}),await it(\"CaptchaScreen\")):(te(e)?await ut(e):await ht(e),await it(\"ConnectionStatusScreen\"))})(e)},fund:async t=>{await Ut.fundWallet(e.address,t)},unlink:async()=>{if(!Ve)throw new Ce(\"User is not authenticated.\");if(\"embedded\"===e.connectorType&&\"privy\"===e.walletClientType)throw new Ce(\"Cannot unlink an embedded wallet\");v(await r.unlinkEthereumWallet(e.address))}})))||[];return re(e.ethereum,t)?{}:{ethereum:t}}))};c((()=>{yt()}),[f?.linkedAccounts,Ve,y]),c((()=>{if(y){if(!r.connectors)throw new Ce(\"Connector not initialized\");yt(),r.connectors.on(\"walletsUpdated\",yt)}}),[y]),c((()=>{[...d.loginMethodsAndOrder?.primary??[],...d.loginMethodsAndOrder?.overflow??[]].filter((e=>e.startsWith(\"privy:\"))).forEach((e=>r.getCrossAppProviderDetails(e.replace(\"privy:\",\"\"))))}),[!!r]);let ft=({transaction:e,sponsor:t,uiOptions:i,fundWalletConfig:s,address:o,signOnly:l})=>new Promise((async(c,u)=>{let{requesterAppId:h}=i||{},p=l?\"signTransaction\":\"sendTransaction\",w=o?N(f,o):E(f);if(!w&&o){let n=x(Vi(),o);if(n){if(t)throw new Ce(\"Cannot sponsor transactions for externally connected wallet.\");try{let t=await n.getEthereumProvider(),r={...e,from:o,chainId:e.chainId||Number(n.chainId.replace(\"eip155:\",\"\")),value:void 0!==e.value?Ct(e.value):void 0},a=await t.request({method:\"sendTransaction\"===p?\"eth_sendTransaction\":\"eth_signTransaction\",params:[r]});return er(Re,p,\"onSuccess\",{hash:a}),void c({hash:a})}catch(e){return er(Re,p,\"onError\",_e.TRANSACTION_FAILURE),void u(e??new ze(\"Unable to \"+p+e))}}}if(!w)return er(Re,p,\"onError\",_e.EMBEDDED_WALLET_NOT_FOUND),void u(new Ce(\"No embedded or connected wallet found for address.\"));if(!Ve||!f)return er(Re,p,\"onError\",_e.MUST_BE_AUTHENTICATED),void u(Error(\"User must be authenticated before signing with a Privy wallet\"));let y=w.address,g=w.walletIndex??0,{entropyId:v,entropyIdVerifier:A}=ve(f,w),k=Nt.wallets.find((e=>\"privy\"===e.walletClientType&&_t(e.address)===_t(y)));if(!k)return er(Re,p,\"onError\",_e.EMBEDDED_WALLET_NOT_FOUND),void u(Error(\"Must have a Privy wallet before signing\"));let C=await k.getEthereumProvider(),T=await C.request({method:\"eth_chainId\"}),_=e.chainId?Number(e.chainId):qe(T);(e=>{if(!d.chains.map((e=>e.id)).includes(e))throw new ke(`Chain ID ${e} is not supported. It must be added to the config.supportedChains property of the PrivyProvider.`,_e.UNSUPPORTED_CHAIN_ID)})(_);let b={...e,from:e.from??y,chainId:_},S=await Kr();if(!S||!de)return er(Re,p,\"onError\",_e.EMBEDDED_WALLET_NOT_FOUND),void u(Error(\"Must have valid access token and Privy wallet to send transaction\"));let I=gr(b.chainId,d.chains,d.rpcConfig,{appId:n.appId}),W=P(w),U=async({transactionRequest:e})=>{try{let n;if(!await Ut.recoverEmbeddedWallet({address:y}))throw er(Re,p,\"onError\",_e.UNKNOWN_CONNECT_WALLET_ERROR),u(Error(\"Unable to connect to wallet\")),Error(\"Unable to connect to wallet\");if(t){let t=await(async({transactionRequest:e})=>{if(!W)throw new Ce(\"Sponsoring is only supported for wallets on the TEE stack\");if(l)throw new Ce(\"Cannot sponsor a sign transaction request\");let t=e=>null==e?void 0:Ct(e),n=await m(a,(async({message:e})=>await de.signWithUserSigner({accessToken:S,requesterAppId:h,message:e})),{chain_type:\"ethereum\",method:\"eth_sendTransaction\",caip2:ne(Ct(e.chainId)),sponsor:!0,params:{transaction:{from:e.from,to:e.to,chain_id:t(e.chainId),data:bt(e.data)?e.data?e.data:Ct(Uint8Array.from(e.data)):void 0,value:t(e.value)}},wallet_id:w.id});if(n.data&&\"hash\"in n.data)return n.data.hash;throw new ze(\"Unable to sign transaction\")})({transactionRequest:e});return er(Re,\"sendTransaction\",\"onSuccess\",{hash:t}),t}if(W){let t=e=>null==e?void 0:Ct(e),r=await m(a,(async({message:e})=>await de.signWithUserSigner({accessToken:S,requesterAppId:h,message:e})),{chain_type:\"ethereum\",method:\"eth_signTransaction\",params:{transaction:{from:e.from,to:e.to,nonce:t(e.nonce),chain_id:t(e.chainId),data:bt(e.data)?e.data?e.data:Ct(Uint8Array.from(e.data)):void 0,value:t(e.value),type:e.type,gas_limit:t(e.gasLimit??e.gas),gas_price:t(e.gasPrice??e.gas),max_fee_per_gas:t(e.maxFeePerGas),max_priority_fee_per_gas:t(e.maxPriorityFeePerGas)}},wallet_id:w.id});if(!r.data||!(\"signed_transaction\"in r.data))throw new ze(\"Unable to sign transaction\");n=r.data.signed_transaction}else n=await async function({accessToken:e,entropyId:t,entropyIdVerifier:n,transactingWalletIndex:r,walletProxy:a,transactionRequest:i,requesterAppId:s}){return(await a.rpc({entropyId:t,entropyIdVerifier:n,hdWalletIndex:r??0,chainType:\"ethereum\",accessToken:e,requesterAppId:s,request:{method:\"eth_signTransaction\",params:[i]}})).response.data}({accessToken:S,entropyId:v,entropyIdVerifier:A,transactingWalletIndex:g,walletProxy:de,transactionRequest:e,requesterAppId:h});if(l)return er(Re,\"signTransaction\",\"onSuccess\",{signature:n}),n;{let e=await I.sendRawTransaction({serializedTransaction:n});return er(Re,\"sendTransaction\",\"onSuccess\",{hash:e}),e}}catch(e){throw er(Re,p,\"onError\",_e.TRANSACTION_FAILURE),e}};if(et({showWalletUIs:i?.showWalletUIs})){let e=l||t?b:await Di(b,I,b.from);try{let t=await U({transactionRequest:e});l?er(Re,\"signTransaction\",\"onSuccess\",{signature:t}):er(Re,\"sendTransaction\",\"onSuccess\",{hash:t}),c({hash:t})}catch(e){er(Re,p,\"onError\",_e.TRANSACTION_FAILURE),u(e)}}else{let e={connectingWalletAddress:y,recoveryMethod:w.recoveryMethod,entropyId:v,entropyIdVerifier:A,onCompleteNavigateTo:\"SendTransactionScreen\",isUnifiedWallet:W,onFailure:e=>{er(Re,p,\"onError\",_e.UNKNOWN_CONNECT_WALLET_ERROR),u(e)}},n=(e=>!!e.fundingConfig&&Le(e.fundingConfig.options).length>=1)(d)?De({address:y,appConfig:d,fundWalletConfig:s,methodScreen:\"FundingMethodSelectionScreen\",chainIdOverride:b.chainId,comingFromSendTransactionScreen:!0}):void 0;we({connectWallet:e,sendTransaction:{transactionRequest:b,transactingWalletIndex:g,transactingWalletAddress:y,entropyId:v,entropyIdVerifier:A,signOnly:l,scanTransaction:async()=>{let e=await Di(b,I,b.from);return await r.scanTransaction({metadata:{domain:d.embeddedWallets.transactionScanning.domain},chain_id:e.chainId.toString(),request:{method:\"eth_sendTransaction\",params:[{from:e.from,to:e.to,value:e.value?.toString(),gas:e.gas?.toString(),gasPrice:e.gasPrice?.toString(),nonce:e.nonce?.toString(),data:e.data}]}})},getIsSponsored:async()=>!!t,onConfirm:({transactionRequest:e})=>U({transactionRequest:e}),onSuccess:e=>{l?er(Re,\"signTransaction\",\"onSuccess\",{signature:e.hash}):er(Re,\"sendTransaction\",\"onSuccess\",{hash:e.hash}),c(e)},onFailure:e=>{er(Re,p,\"onError\",_e.TRANSACTION_FAILURE),u(e)},uiOptions:i||{},fundWalletConfig:s,requesterAppId:h},funding:n}),it(\"EmbeddedWalletConnectingScreen\")}}));function vt(){return new Promise((async(e,t)=>{let n=await Kr();if(!n||!de)throw Error(\"Must have valid access token to enroll in MFA\");try{await de.verifyMfa({accessToken:n}),e()}catch(e){t(e)}}))}let kt=e=>e?.linkedAccounts.filter((e=>null!==e.latestVerifiedAt&&!(\"wallet\"===e.type&&\"privy\"===e.walletClientType))).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0],St=e=>{let t=f?.linkedAccounts.filter((t=>t.type===e)).length??0,{displayName:n,loginMethod:r}=Ri(e);if(\"passkey\"===e&&t>=5||\"passkey\"!==e&&t>=1)throw er(Re,\"linkAccount\",\"onError\",_e.CANNOT_LINK_MORE_OF_TYPE,{linkMethod:r}),new Ce(`User already has an account of type ${n} linked.`)};async function It({showAutomaticRecovery:e=!1,legacySetWalletPasswordFlow:t=!1}){I(null);let n=t?\"setWalletPassword\":\"setWalletRecovery\";if(!Ve||!f)throw er(Re,n,\"onError\",_e.MUST_BE_AUTHENTICATED),Error(\"User must be authenticated before adding recovery method to Privy wallet\");let r=b(f);if(!r||!de)throw er(Re,n,\"onError\",_e.EMBEDDED_WALLET_NOT_FOUND),Error(\"Must have a Privy wallet to add a recovery method\");let a=P(r);if(a)throw er(Re,n,\"onError\",_e.UNSUPPORTED_WALLET_TYPE),new Ce(\"User owned wallet recovery is only supported for on-device execution and this app uses TEE execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide\");try{await vt()}catch(e){throw er(Re,n,\"onError\",_e.MISSING_MFA_CREDENTIALS),e}return new Promise(((i,s)=>{let o=\"user-passcode\"===r.recoveryMethod,l=Ei({walletAction:\"update\",availableRecoveryMethods:d.embeddedWallets.userOwnedRecoveryOptions,legacySetWalletPasswordFlow:t,isResettingPassword:o,showAutomaticRecovery:e}),{entropyId:c,entropyIdVerifier:u}=ve(f),h={recoveryMethod:r.recoveryMethod,connectingWalletAddress:r.address,onCompleteNavigateTo:l,shouldForceMFA:!1,entropyId:c,isUnifiedWallet:a,entropyIdVerifier:u,onFailure:e=>{er(Re,n,\"onError\",_e.UNKNOWN_CONNECT_WALLET_ERROR),s(e)}};we({setWalletPassword:{onSuccess:e=>{er(Re,n,\"onSuccess\",{method:\"user-passcode\",wallet:e}),i(e)},onFailure:e=>{er(Re,n,\"onError\",_e.USER_EXITED_SET_PASSWORD_FLOW),s(e)},callAuthOnSuccessOnClose:!1},recoverWallet:{entropyId:c,entropyIdVerifier:u,onFailure:s},connectWallet:h,recoverySelection:{isInAccountCreateFlow:!1,isResettingPassword:o,shouldCreateEth:!1,shouldCreateSol:!1}}),it(\"EmbeddedWalletConnectingScreen\")}))}async function Pt({appId:e,action:t}){let n=await Kr();if(\"link\"===t&&!n)throw er(Re,\"linkAccount\",\"onError\",_e.MUST_BE_AUTHENTICATED,{linkMethod:`privy:${e}`}),new Ce(\"User must be authenticated before linking an account.\");if(\"login\"===t&&n)throw er(Re,\"login\",\"onError\",_e.UNKNOWN_AUTH_ERROR),new Ce(\"Attempted to log in, but user is already logged in. Use a `link` helper instead.\");$e.current=`privy:${e}`,Ge.current=t;let a=Et();return r.createAnalyticsEvent({eventName:\"cross_app_auth_started\",payload:{providerAppId:e}}),new Promise((async(n,i)=>{let{name:s,logoUrl:o}=await Ci({api:r.api,providerAppId:e,requesterAppId:d.id});we({crossAppAuth:{appId:e,name:s,logoUrl:o,action:t,popup:a,onSuccess:n,onError:i}}),it(\"CrossAppAuthScreen\")}))}let Wt={ready:y,authenticated:Ve,user:f,walletConnectors:r.connectors||null,connectWallet:e=>{e&&\"target\"in e&&e&&(e=void 0),we({externalConnectWallet:{walletList:e?.walletList&&e?.walletList.length>0?e.walletList:void 0,walletChainType:e?.walletChainType,description:e?.description,hideHeader:e?.hideHeader}}),it(\"ConnectOnlyLandingScreen\")},linkWallet:e=>(e&&\"target\"in e&&e&&(e=void 0),wt(\"siwe\"),$e.current=\"siwe\",Ge.current=\"link\",we({...pe,externalConnectWallet:{...pe.externalConnectWallet,walletList:e?.walletList,walletChainType:e?.walletChainType,description:e?.description||`Link a wallet to your ${d?.name} account`}}),it(\"AuthenticateWithWalletScreen\")),startCrossAppAuthFlow:Pt,linkEmail:()=>{wt(\"email\"),St(\"email\"),$e.current=\"email\",Ge.current=\"link\",it(\"LinkEmailScreen\")},linkPhone:()=>{wt(\"sms\"),St(\"phone\"),$e.current=\"sms\",Ge.current=\"link\",it(\"LinkPhoneScreen\")},linkGoogle:async()=>{wt(\"google\"),St(\"google_oauth\"),Ge.current=\"link\",await Ut.initLoginWithOAuth(\"google\")},linkTwitter:async()=>{wt(\"twitter\"),St(\"twitter_oauth\"),Ge.current=\"link\",await Ut.initLoginWithOAuth(\"twitter\")},linkTwitch:async()=>{wt(\"twitch\"),St(\"twitch_oauth\"),Ge.current=\"link\",await Ut.initLoginWithOAuth(\"twitch\")},linkDiscord:async()=>{wt(\"discord\"),St(\"discord_oauth\"),Ge.current=\"link\",await Ut.initLoginWithOAuth(\"discord\")},linkGithub:async()=>{wt(\"github\"),St(\"github_oauth\"),Ge.current=\"link\",await Ut.initLoginWithOAuth(\"github\")},linkSpotify:async()=>{wt(\"spotify\"),St(\"spotify_oauth\"),Ge.current=\"link\",await Ut.initLoginWithOAuth(\"spotify\")},linkInstagram:async()=>{wt(\"instagram\"),St(\"instagram_oauth\"),Ge.current=\"link\",await Ut.initLoginWithOAuth(\"instagram\")},linkTiktok:async()=>{wt(\"tiktok\"),St(\"tiktok_oauth\"),Ge.current=\"link\",await Ut.initLoginWithOAuth(\"tiktok\")},linkLine:async()=>{wt(\"line\"),St(\"line_oauth\"),Ge.current=\"link\",await Ut.initLoginWithOAuth(\"line\")},linkLinkedIn:async()=>{wt(\"linkedin\"),St(\"linkedin_oauth\"),Ge.current=\"link\",await Ut.initLoginWithOAuth(\"linkedin\")},linkApple:async()=>{wt(\"apple\"),St(\"apple_oauth\"),Ge.current=\"link\",await Ut.initLoginWithOAuth(\"apple\")},linkPasskey:async()=>{wt(\"passkey\"),St(\"passkey\"),await Ut.initLinkWithPasskey(),it(\"LinkPasskeyScreen\")},linkTelegram:async e=>{if(wt(\"telegram\"),St(\"telegram\"),Ge.current=\"link\",$e.current=\"telegram\",e?.launchParams)if(e.launchParams.initDataRaw){let t=new Aa;r.startAuthFlow(t),t.meta.telegramAuthResult=void 0,t.meta.telegramWebAppData=Ca(e.launchParams.initDataRaw),we({telegramAuthModalData:{seamlessAuth:!0}}),it(\"TelegramAuthScreen\")}else er(Re,\"linkAccount\",\"onError\",_e.INVALID_DATA,{linkMethod:\"telegram\"});else await Ut.initLoginWithTelegram();it(\"TelegramAuthScreen\")},linkFarcaster:async()=>{wt(\"farcaster\"),St(\"farcaster\"),await Ut.initLoginWithFarcaster(),Ge.current=\"link\",$e.current=\"farcaster\",it(\"FarcasterConnectStatusScreen\")},updateEmail:()=>{if(wt(\"email\"),!f?.email)throw new Ce(\"User does not have an email linked to their account.\");Ge.current=\"update\",$e.current=\"email\",it(\"UpdateEmailScreen\")},updatePhone:()=>{if(wt(\"sms\"),!f?.phone)throw new Ce(\"User does not have a phone number linked to their account.\");Ge.current=\"update\",$e.current=\"sms\",it(\"UpdatePhoneScreen\")},login:async e=>{e&&\"target\"in e&&e&&(e=void 0);let t=\"Attempted to log in, but user is already logged in. Use a `link` helper instead.\";if(!y){let e=await new Promise((e=>{ye((t=>e.bind(t)))}));if(ye(null),e)return void console.warn(t)}!f||f.isGuest?(Ge.current=\"login\",we({login:e}),it(\"LandingScreen\")):console.warn(t)},connectOrCreateWallet:async()=>{y||(await new Promise((e=>{ye((()=>e))})),ye(null)),Ve?console.warn(\"User must be unauthenticated to `connectOrCreateWallet`\"):(Ge.current=\"connect-or-create\",it(\"ConnectOrCreateScreen\"))},logout:async()=>{if(Ge.current=null,$e.current=null,f&&r.clearProviderAcccessTokens(f),I(null),await r.logout(),f&&de)try{await de.clearMfa({userId:f.id})}catch(e){}v(null),Ke(!1),B({status:\"initial\"}),$({status:\"initial\"}),q({status:\"initial\"}),Y({status:\"initial\"}),Q({status:\"initial\"}),ce({status:\"initial\"}),er(Re,\"logout\",\"onSuccess\"),p(!1),Me.del(rt),Me.del(at(d.id))},getAccessToken:h((async()=>{let e=await r.getCustomerAccessToken();return e&&!Ve&&Ke(!0),e}),[r,Ve]),unlinkWallet:async e=>{let t;return v(t=e.startsWith(\"0x\")?await r.unlinkEthereumWallet(e):await r.unlinkSolanaWallet(e)),t},unlinkEmail:async e=>{let t=await r.unlinkEmail(e);return v(t),t},unlinkPhone:async e=>{let t=await r.unlinkPhone(e);return v(t),t},unlinkGoogle:async e=>{let t=await r.unlinkOAuth(\"google\",e);return v(t),t},unlinkTwitter:async e=>{let t=await r.unlinkOAuth(\"twitter\",e);return v(t),t},unlinkTwitch:async e=>{let t=await r.unlinkOAuth(\"twitch\",e);return v(t),t},unlinkDiscord:async e=>{let t=await r.unlinkOAuth(\"discord\",e);return v(t),t},unlinkGithub:async e=>{let t=await r.unlinkOAuth(\"github\",e);return v(t),t},unlinkSpotify:async e=>{let t=await r.unlinkOAuth(\"spotify\",e);return v(t),t},unlinkInstagram:async e=>{let t=await r.unlinkOAuth(\"instagram\",e);return v(t),t},unlinkTiktok:async e=>{let t=await r.unlinkOAuth(\"tiktok\",e);return v(t),t},unlinkLine:async e=>{let t=await r.unlinkOAuth(\"line\",e);return v(t),t},unlinkLinkedIn:async e=>{let t=await r.unlinkOAuth(\"linkedin\",e);return v(t),t},unlinkApple:async e=>{let t=await r.unlinkOAuth(\"apple\",e);return v(t),t},unlinkFarcaster:async e=>{let t=await r.unlinkFarcaster(e);return v(t),t},unlinkTelegram:async e=>{let t=await r.unlinkTelegram(e);return v(t),t},unlinkPasskey:async e=>{let t=await Kr();if(!t)throw Error(\"Must have valid access token to enroll in MFA\");if(!de)throw Error(\"Wallet proxy not initialized.\");let n=d.passkeys.shouldUnenrollMfaOnUnlink;await de.unlinkPasskeyAccount({credentialId:e,accessToken:t,removeAsMfa:n});let a=await r.getAuthenticatedUser();return v(a),a},unlinkCrossAppAccount:async({subject:e})=>{let t=f?.linkedAccounts.find((t=>\"cross_app\"===t.type&&t.subject===e))?.providerApp;if(!t)throw new Ce(\"Invalid subject\");r.storeProviderAccessToken(t.id,null);let n=await r.unlinkOAuth(`privy:${t.id}`,e);return v(n),n},setWalletRecovery:async e=>It({legacySetWalletPasswordFlow:!1,showAutomaticRecovery:e?.showAutomaticRecovery??!1}),setWalletPassword:async()=>It({legacySetWalletPasswordFlow:!0,showAutomaticRecovery:!1}),signMessage:(e,t)=>new Promise((async(n,i)=>{let{requesterAppId:s}=t?.uiOptions||{},o=e.message,l=t?.address?N(f,t.address):E(f);if(!l&&void 0!==t?.address){let e=x(Vi(),t.address);if(e)try{let t=await e.getEthereumProvider(),r=await t.request({method:\"personal_sign\",params:[o,e.address]});return er(Re,\"signMessage\",\"onSuccess\",{signature:r}),void n({signature:r})}catch(e){return er(Re,\"signMessage\",\"onError\",_e.UNABLE_TO_SIGN),void i(e??new ze(\"Unable to sign message\"))}}if(!l)throw new Ce(\"No embedded or connected wallet found for address.\");if(!Ve||!f)return er(Re,\"signMessage\",\"onError\",_e.MUST_BE_AUTHENTICATED),void i(Error(\"User must be authenticated before signing with a Privy wallet\"));let c=l.address,d=l.walletIndex??0,{entropyId:u,entropyIdVerifier:h}=ve(f,l),p=P(l);if(\"string\"!=typeof o||o.length<1)return er(Re,\"signMessage\",\"onError\",_e.INVALID_MESSAGE),void i(Error(\"Message must be a non-empty string\"));let w=async()=>{let t;if(!Ve)throw Error(\"User must be authenticated before signing with a Privy wallet\");let n=await Kr();if(!de||!n||!await Ut.recoverEmbeddedWallet({address:c}))throw Error(\"Unable to connect to wallet\");if(r.createAnalyticsEvent({eventName:\"embedded_wallet_sign_message_started\",payload:{walletAddress:c,requesterAppId:s}}),p){let r=bt(e.message,{strict:!0}),i=await m(a,(async({message:e})=>await de.signWithUserSigner({accessToken:n,requesterAppId:s,message:e})),{chain_type:\"ethereum\",method:\"personal_sign\",params:r?{message:o.slice(2),encoding:\"hex\"}:{message:o,encoding:\"utf-8\"},wallet_id:l.id});if(!i.data||!(\"signature\"in i.data))throw new ze(\"Unable to sign message\");t=i.data.signature}else{let{response:e}=await de.rpc({accessToken:n,entropyId:u,entropyIdVerifier:h,chainType:\"ethereum\",hdWalletIndex:d,requesterAppId:s,request:{method:\"personal_sign\",params:[o,c]}});t=e.data}return r.createAnalyticsEvent({eventName:\"embedded_wallet_sign_message_completed\",payload:{walletAddress:c,requesterAppId:s}}),t};if(et({showWalletUIs:t?.uiOptions?.showWalletUIs}))try{let e=await w();er(Re,\"signMessage\",\"onSuccess\",{signature:e}),n({signature:e})}catch(e){er(Re,\"signMessage\",\"onError\",_e.UNABLE_TO_SIGN),i(e??new ze(\"Unable to sign message\"))}else we({signMessage:{method:\"personal_sign\",data:o,confirmAndSign:w,onSuccess:e=>{er(Re,\"signMessage\",\"onSuccess\",{signature:e}),n({signature:e})},onFailure:e=>{er(Re,\"signMessage\",\"onError\",_e.UNABLE_TO_SIGN),i(e)},uiOptions:t?.uiOptions||{}},connectWallet:{recoveryMethod:l.recoveryMethod,connectingWalletAddress:c,entropyId:u,entropyIdVerifier:h,onCompleteNavigateTo:\"SignRequestScreen\",isUnifiedWallet:p,onFailure:e=>{er(Re,\"signMessage\",\"onError\",_e.UNKNOWN_CONNECT_WALLET_ERROR),i(e)}}}),it(\"EmbeddedWalletConnectingScreen\")})),signTypedData:(e,t)=>new Promise((async(n,i)=>{let{requesterAppId:s}=t?.uiOptions||{},o=t?.address?N(f,t.address):E(f);if(!o&&t?.address){let r=x(Vi(),t.address);if(r)try{let t=await r.getEthereumProvider(),a=oe(e),i=await t.request({method:\"eth_signTypedData_v4\",params:[r.address,a]});return er(Re,\"signTypedData\",\"onSuccess\",{signature:i}),void n({signature:i})}catch(e){return er(Re,\"signTypedData\",\"onError\",_e.UNABLE_TO_SIGN),void i(e??new ze(\"Unable to sign typed data \"+e))}}if(!o)throw new Ce(\"No embedded or connected wallet found for address.\");if(!Ve||!f)return er(Re,\"signTypedData\",\"onError\",_e.MUST_BE_AUTHENTICATED),void i(Error(\"User must be authenticated before signing with a Privy wallet\"));let l=o.address,c=o.walletIndex??0,{entropyId:d,entropyIdVerifier:u}=ve(f,o),h=P(o),p=oe(e),w=async()=>{let e;if(!Ve)throw Error(\"User must be authenticated before signing with a Privy wallet\");let t=await Kr();if(!de||!t||!await Ut.recoverEmbeddedWallet({address:l}))throw Error(\"Unable to connect to wallet\");if(r.createAnalyticsEvent({eventName:\"embedded_wallet_sign_typed_data_started\",payload:{walletAddress:l,requesterAppId:s}}),h){let{domain:n,types:r,primaryType:i,message:l}=p,c=await m(a,(async({message:e})=>await de.signWithUserSigner({accessToken:t,requesterAppId:s,message:e})),{chain_type:\"ethereum\",method:\"eth_signTypedData_v4\",params:{typed_data:{domain:n,types:r,primary_type:i,message:l}},wallet_id:o.id});if(!c.data||!(\"signature\"in c.data))throw new ze(\"Unable to sign message\");e=c.data.signature}else{let{response:n}=await de.rpc({accessToken:t,entropyId:d,entropyIdVerifier:u,chainType:\"ethereum\",hdWalletIndex:c,requesterAppId:s,request:{method:\"eth_signTypedData_v4\",params:[l,p]}});e=n.data}return r.createAnalyticsEvent({eventName:\"embedded_wallet_sign_typed_data_completed\",payload:{walletAddress:l,requesterAppId:s}}),e};if(et({showWalletUIs:t?.uiOptions?.showWalletUIs}))try{let e=await w();er(Re,\"signTypedData\",\"onSuccess\",{signature:e}),n({signature:e})}catch(e){er(Re,\"signTypedData\",\"onError\",_e.UNABLE_TO_SIGN),i(e??new ze(\"Unable to sign message\"))}else we({signMessage:{method:\"eth_signTypedData_v4\",data:p,confirmAndSign:w,onSuccess:e=>{er(Re,\"signTypedData\",\"onSuccess\",{signature:e}),n({signature:e})},onFailure:e=>{er(Re,\"signTypedData\",\"onError\",_e.UNABLE_TO_SIGN),i(e)},uiOptions:t?.uiOptions||{}},connectWallet:{recoveryMethod:o.recoveryMethod,connectingWalletAddress:o.address,entropyId:d,isUnifiedWallet:h,entropyIdVerifier:u,onCompleteNavigateTo:\"SignRequestScreen\",onFailure:e=>{er(Re,\"signMessage\",\"onError\",_e.UNKNOWN_CONNECT_WALLET_ERROR),i(e)}}}),it(\"EmbeddedWalletConnectingScreen\")})),sendTransaction:async(e,t)=>await ft({transaction:e,sponsor:t?.sponsor,uiOptions:t?.uiOptions,fundWalletConfig:t?.fundWalletConfig,address:t?.address,signOnly:!1}),signTransaction:async(e,t)=>({signature:(await ft({transaction:e,uiOptions:t?.uiOptions,address:t?.address,signOnly:!0})).hash}),exportWallet:e=>new Promise((async(t,a)=>{if(!Ve||!f)return void a(Error(\"User must be authenticated before exporting their Privy wallet\"));e&&\"target\"in e&&e&&(e=void 0);let i=e?.address?N(f,e.address):E(f);if(!i)return void a(new Ce(\"User must have an embedded wallet.\"));let s=i.address,{entropyId:o,entropyIdVerifier:l}=ve(f,i),c=P(i);if(!s)return void a(Error(\"User does not have an HD Ethereum wallet. To export an imported wallet, pass the `address` of the wallet to `exportWallet`.\"));if(!Tt(s))return void a(Error(\"Must provide a valid Ethereum address.\"));let d={recoveryMethod:i.recoveryMethod,connectingWalletAddress:i.address,isUnifiedWallet:c,entropyId:o,entropyIdVerifier:l,onCompleteNavigateTo:\"EmbeddedWalletKeyExportScreen\",onFailure:a,shouldForceMFA:!0};we(pe),await Kr()&&de?de?Fe(i)?(we({keyExport:{appId:n.appId,appClientId:n.clientId,origin:r.apiUrl,address:i.address,entropyId:o,entropyIdVerifier:l,hdWalletIndex:i.walletIndex,chainType:i.chainType,walletId:i.id,isUnifiedWallet:c,imported:i.imported,onSuccess:t,onFailure:a},connectWallet:d}),it(\"EmbeddedWalletConnectingScreen\")):a(Error(`Export is not supported for ${i.chainType} wallets`)):a(Error(\"Must have a Privy wallet before exporting\")):a(Error(\"Must have valid access token to enroll in MFA\"))})),promptMfa:vt,async init(e){switch(e){case\"sms\":return void await r.initMfaSmsVerification();case\"passkey\":return await r.initMfaPasskeyVerification();case\"totp\":return;default:throw Error(`Unsupported MFA method: ${e}`)}},async submit(e,t){switch(e){case\"totp\":case\"sms\":if(\"string\"!=typeof t)throw new Ce(\"Invalid MFA code\");Ne.current?.resolve({mfaMethod:e,mfaCode:t,relyingParty:window.origin}),await new Promise(((e,t)=>{Oe.current={resolve:e,reject:t}}));break;case\"passkey\":if(\"string\"==typeof t)throw new Ce(\"Invalid authenticator response\");let n=await import(\"@simplewebauthn/browser\"),r=qi(await n.startAuthentication({optionsJSON:t}));Ne.current?.resolve({mfaMethod:e,mfaCode:r,relyingParty:window.origin}),await new Promise(((e,t)=>{Oe.current={resolve:e,reject:t}}));break;default:throw Ne.current?.reject(new Ce(\"Unsupported MFA method\")),new Ce(`Unsupported MFA method: ${e}`)}},cancel(){Ne.current?.reject(new Ce(\"MFA canceled\"))},async initEnrollmentWithSms(e){let t=await Kr();if(!t||!de)throw Error(\"Must have valid access token to enroll in MFA\");await de.initEnrollMfa({method:\"sms\",accessToken:t,phoneNumber:e.phoneNumber})},enrollInMfa:e=>new Promise(((t,n)=>{if(!e)return Ut.closePrivyModal(),void t();d.mfa.noPromptOnMfaRequired&&console.warn(\"[Privy Warning] Triggering the 'showMfaEnrollmentModal' function when 'noPromptOnMfaRequired' is set to true is unexpected. If this is intentional, ensure that you are building custom UIs for MFA verification.\"),we({mfaEnrollmentFlow:{mfaMethods:d.mfa.methods,shouldUnlinkOnUnenrollMfa:d.passkeys.shouldUnlinkOnUnenrollMfa,onSuccess:t,onFailure:n}}),it(\"MfaEnrollmentFlowScreen\")})),async initEnrollmentWithTotp(){let e=await Kr();if(!e||!de)throw Error(\"Must have valid access token to enroll in MFA\");let t=await de.initEnrollMfa({method:\"totp\",accessToken:e});return{secret:t.secret,authUrl:t.authUrl}},async submitEnrollmentWithSms(e){let t=await Kr();if(!t||!de)throw Error(\"Must have valid access token to enroll in MFA\");await de.submitEnrollMfa({method:\"sms\",accessToken:t,phoneNumber:e.phoneNumber,code:e.mfaCode}),v(await r.getAuthenticatedUser())},async submitEnrollmentWithTotp(e){let t=await Kr();if(!t||!de)throw Error(\"Must have valid access token to enroll in MFA\");await de.submitEnrollMfa({method:\"totp\",accessToken:t,code:e.mfaCode}),v(await r.getAuthenticatedUser())},async initEnrollmentWithPasskey(){},async submitEnrollmentWithPasskey({credentialIds:e},t={}){let n=await Kr();if(!n||!de)throw Error(\"Must have valid access token to enroll in MFA\");await de.submitEnrollMfa({method:\"passkey\",accessToken:n,credentialIds:e,removeForLogin:t.removeForLogin}),v(await r.getAuthenticatedUser())},async unenroll(e,t={}){let n=await Kr();if(!n||!de)throw Error(\"Must have valid access token to remove MFA\");\"passkey\"===e?await de.submitEnrollMfa({method:\"passkey\",accessToken:n,credentialIds:[],removeForLogin:t.removeForLogin}):await de.unenrollMfa({method:e,accessToken:n}),v(await r.getAuthenticatedUser())},requestFarcasterSignerFromWarpcast:async()=>{let e=await Kr(),t=f?.linkedAccounts.find((e=>\"wallet\"===e.type&&\"privy\"===e.walletClientType));if(!e)throw Error(\"Must have valid access token to connect with Farcaster\");if(!de||!t)throw Error(\"Must have an embedded wallet to use Farcaster signers\");if(P(t))throw new Ce(\"Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide\");if(!f?.farcaster?.fid)throw Error(\"Must have Farcaster account to use Farcaster signers\");if(!await Ut.recoverEmbeddedWallet({address:t.address}))throw Error(\"Unable to connect to wallet\");let n=await de.initFarcasterSigner({address:t.address,hdWalletIndex:null,accessToken:e,mfaCode:null,mfaMethod:null,relyingParty:window.origin});\"approved\"===n.status&&v(await r.getAuthenticatedUser()||f||null),we({farcasterSigner:n}),it(\"FarcasterSignerStatusScreen\")},getFarcasterSignerPublicKey:async()=>{let e,t=await Kr(),n=f?.linkedAccounts.find((e=>\"wallet\"===e.type&&\"privy\"===e.walletClientType));if(!t)throw Error(\"Must have valid access token to connect with Farcaster\");if(!de||!n)throw Error(\"Must have an embedded wallet to use Farcaster signers\");if(P(n))throw new Ce(\"Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide\");if(!f?.farcaster?.fid)throw Error(\"Must have Farcaster account to use Farcaster signers\");if(!await Ut.recoverEmbeddedWallet({address:n.address}))throw Error(\"Unable to connect to wallet\");if(!f.farcaster?.signerPublicKey)throw Error(\"Must have a Farcaster signer public key to sign\");return e=f.farcaster.signerPublicKey.slice(2),Uint8Array.from(e.match(/.{1,2}/g).map((e=>parseInt(e,16))))},signFarcasterMessage:async e=>{let t=await Kr(),n=f?.linkedAccounts.find((e=>\"wallet\"===e.type&&\"privy\"===e.walletClientType));if(!t)throw Error(\"Must have valid access token to connect with Farcaster\");if(!de||!n)throw Error(\"Must have an embedded wallet to use Farcaster signers\");if(P(n))throw new Ce(\"Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide\");if(!f?.farcaster?.fid)throw Error(\"Must have Farcaster account to use Farcaster signers\");if(!await Ut.recoverEmbeddedWallet({address:n.address}))throw Error(\"Unable to connect to wallet\");if(!f.farcaster?.signerPublicKey)throw Error(\"Must have a Farcaster signer public key to sign\");let r=await import(\"@simplewebauthn/browser\"),a=await de.signFarcasterMessage({address:n.address,hdWalletIndex:null,accessToken:t,mfaCode:null,mfaMethod:null,payload:{hash:r.bufferToBase64URLString(e)},fid:BigInt(f.farcaster.fid),relyingParty:window.origin});return new Uint8Array(r.base64URLStringToBuffer(a.signature))},signMessageWithCrossAppWallet(e,{address:t,chainId:n}){let a=f?.linkedAccounts.some((e=>\"cross_app\"===e.type&&e.smartWallets.some((e=>e.address===t))));return Ti({user:f,client:r,address:t,requesterAppId:d.id,request:{method:a?\"privy_signSmartWalletMessage\":\"personal_sign\",params:[e,t],chainId:n},reconnect:Pt})},signTypedDataWithCrossAppWallet(e,{address:t,chainId:n}){let a=f?.linkedAccounts.some((e=>\"cross_app\"===e.type&&e.smartWallets.some((e=>e.address===t)))),i=oe(e);return Ti({user:f,client:r,address:t,requesterAppId:d.id,request:{method:a?\"privy_signSmartWalletTypedData\":\"eth_signTypedData_v4\",params:[t,i],chainId:n},reconnect:Pt})},sendTransactionWithCrossAppWallet(e,{address:t}){let n=f?.linkedAccounts.some((e=>\"cross_app\"===e.type&&e.smartWallets.some((e=>e.address===t))));return Ti({user:f,client:r,address:t,requesterAppId:d.id,request:{method:n?\"privy_sendSmartWalletTx\":\"eth_sendTransaction\",params:[e],chainId:e.chainId},reconnect:Pt})},signTransactionWithCrossAppWallet(e,{address:t}){let n=f?.linkedAccounts.some((e=>\"cross_app\"===e.type&&e.smartWallets.some((e=>e.address===t))));return Ti({user:f,client:r,address:t,requesterAppId:d.id,request:{method:n?\"privy_signSmartWalletTx\":\"eth_signTransaction\",params:[e],chainId:e.chainId},reconnect:Pt})},isModalOpen:u||!!w,mfaMethods:d.mfa.methods};Ji=Wt.signMessage,Qi=Wt.signTypedData,Xi=async(e,t)=>await ft({transaction:e,...t,signOnly:!1}),Zi=async(e,t)=>({signature:(await ft({transaction:e,...t,signOnly:!0})).hash});let Ut={privy:a,setAuthenticated:Ke,setUser:v,setIsNewUser:_,isNewUserThisSession:T,pendingTransaction:null,walletConnectionStatus:D,setWalletConnectionStatus:j,connectors:r.connectors?.walletConnectors??[],rpcConfig:d.rpcConfig,chains:d.chains,appId:n.appId,showFiatPrices:\"native-token\"!==d.embeddedWallets.priceDisplay.primary,clientAnalyticsId:r.clientAnalyticsId,onCustomAuthAuthenticated:st,hideWalletUIs:Ye,isHeadlessSigning:h(et,[d.embeddedWallets.showWalletUIs]),emailOtpState:H,setEmailOtpState:B,smsOtpState:K,setSmsOtpState:$,oAuthState:J,setOAuthState:Q,telegramAuthState:Z,setTelegramAuthState:ce,siweState:G,setSiweState:Y,isHeadlessOAuthLoading:F,baseAccountSdk:k,setBaseAccountSdk:C,nativeTokenSymbolForChainId:e=>d.chains.find((t=>t.id===Number(e)))?.nativeCurrency.symbol,initializeWalletProxy:async e=>{if(de)return de;let t=new Promise((e=>{ge.current=e})),n=new Promise((t=>setTimeout((()=>t(null)),e))),r=await Promise.race([t,n]);return ge.current=null,r},getAuthFlow:()=>r.authFlow,getAuthMeta:()=>r.authFlow?.meta,client:r,closePrivyModal:async(e={shouldCallAuthOnSuccess:!0,isSuccess:!1})=>{let t,a=y&&Ve&&f;if(a&&$e.current&&(t=kt(f)),\"login\"===Ge.current)e.shouldCallAuthOnSuccess&&a&&$e.current?er(Re,\"login\",\"onComplete\",{user:f,isNewUser:T,wasAlreadyAuthenticated:!1,loginMethod:$e.current,loginAccount:t??null}):er(Re,\"login\",\"onError\",_e.USER_EXITED_AUTH_FLOW);else if(\"link\"===Ge.current&&t)e.isSuccess&&a&&$e.current?er(Re,\"linkAccount\",\"onSuccess\",{user:f,linkMethod:$e.current,linkedAccount:t}):$e.current&&er(Re,\"linkAccount\",\"onError\",_e.USER_EXITED_LINK_FLOW,{linkMethod:$e.current});else if(\"update\"===Ge.current&&t)e.isSuccess&&a&&$e.current?er(Re,\"update\",\"onSuccess\",{user:f,updateMethod:$e.current,updatedAccount:t}):$e.current&&er(Re,\"update\",\"onError\",_e.USER_EXITED_UPDATE_FLOW,{linkMethod:$e.current});else if(\"connect-or-create\"===Ge.current){let e=Vi();e[0]?er(Re,\"connectOrCreateWallet\",\"onSuccess\",{wallet:e[0]}):er(Re,\"connectOrCreateWallet\",\"onError\",_e.USER_EXITED_AUTH_FLOW)}let s=S&&Wi.has(S),o=\"ErrorScreen\"===S&&pe.errorModalData&&Wi.has(pe.errorModalData.previousScreen);if((s||o)&&pe.funding){let e,t=Wi.get(S)??null;if(o&&pe.funding?.onError){let e=pe.errorModalData?.error,t=e?.privyErrorCode||_e.UNKNOWN_FUNDING_ERROR,n=new Ce(e?.message||\"Funding failed\",e,t);pe.funding?.onError?.(n)}if(\"solana\"===pe.funding.chainType){let n=d.solanaRpcs[pe.funding.chain];if(!n)return void console.warn(\"Unable to load solana rpc, skipping balance\");if(i(Hn))try{e=await Ni({rpc:n.rpc,address:pe.funding.address})}catch{console.error(\"Unable to pull wallet balance\")}else console.warn(\"Unable to load solana plugin, skipping balance\");er(Re,\"fundSolanaWallet\",\"onUserExited\",{address:pe.funding.address,fundingMethod:t,chain:pe.funding.chain,balance:e})}else{let r=gr(pe.funding.chain.id,d.chains,d.rpcConfig,{appId:n.appId});try{e=await r.getBalance({address:pe.funding.address})}catch{console.error(\"Unable to pull wallet balance\")}er(Re,\"fundWallet\",\"onUserExited\",{address:pe.funding.address,chain:pe.funding.chain,fundingMethod:t,balance:e}),function(e,t){if(e.onComplete)switch(t){case\"external\":e.fundingResult?e.onComplete({...e.fundingResult,fundingMethod:t}):e.onComplete({status:\"cancelled\",address:e.address,fundingMethod:t,amount:e.amount});break;case null:e.onComplete({status:\"cancelled\",address:e.address,fundingMethod:void 0,amount:e.amount});break;default:e.onComplete({status:\"completed\",address:e.address,fundingMethod:t,amount:e.amount})}}(pe.funding,t)}}we((e=>({...e,externalConnectWallet:{}}))),Ge.current=null,$e.current=null,_(!1),p(!1),j({status:\"disconnected\",connectedWallet:null,connector:null,connectError:null,connectRetry:()=>{}}),setTimeout((()=>{r.authFlow=void 0}),200)},openPrivyModal:it,connectWallet:dt,initLoginWithWallet:async(e,t,n,r)=>{te(e)?($e.current=\"siwe\",ut(e,t,n)):($e.current=\"siws\",ht(e,t,n,r))},loginWithWallet:async()=>{let e,t,n;if(!y)throw new We;if(r.authFlow instanceof ha?e=\"siwe\":r.authFlow instanceof pa&&(e=\"siws\"),!e)throw new Ce(\"Must initialize SIWE/SIWS flow first.\");if(null!==await r.getAccessToken())try{({user:t}=await r.link()),$e.current=e}catch(t){throw er(Re,\"linkAccount\",\"onError\",t.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{({user:t,isNewUser:n}=await r.authenticate()),$e.current=e}catch(e){throw er(Re,\"login\",\"onError\",e.privyErrorCode||_e.GENERIC_CONNECT_WALLET_ERROR),e}v(t||f||null),_(n||!1),Ke(!0)},delegateWallet:async({address:e,chainType:t,showDelegationUIs:n})=>new Promise((async(r,a)=>{let i=await Kr();if(!Ve||!f||!i)throw new Ce(\"User must be authenticated and have an embedded wallet to delegate actions.\");if(\"solana\"!==t&&\"ethereum\"!==t)throw new Ce(\"Only Solana and Ethereum embedded wallets are supported for delegation and revocation.\");let s=Ut.walletProxy??await Ut.initializeWalletProxy(15e3);if(!s)throw new Ce(\"Wallet proxy not initialized.\");if((({address:e,user:t})=>!!fi(t).find((t=>t.address===e)))({address:e,user:f}))return r();let o=N(f,e);if(!o)throw new Ce(\"Address to delegate is not associated with current user.\");if(P(o))throw new Ce(\"useDelegatedActions is only supported for on-device execution and this app uses TEE execution. Use the useSessionSigners hook to provision server side access on behalf of your users. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide\");let l=yi({address:e,user:f}),c=gi({address:e,user:f}),d=async()=>{await s.createDelegatedAction({accessToken:i,rootWallet:c,delegatedWallets:[l]}),await Ut.refreshSessionAndUser()};if(await Ut.recoverEmbeddedWallet({address:e}),n)we({delegatedActions:{consent:{address:e,onDelegate:d,onSuccess:async()=>{r()},onError:async e=>{a(e)}}}}),it(\"DelegatedActionsConsentScreen\");else try{await d(),r()}catch(e){a(e)}})),revokeDelegatedWallets:async({showDelegationUIs:e})=>new Promise((async(t,n)=>{if(!Ve||!f)throw new Ce(\"User must be authenticated and have an embedded wallet to revoke a delegated wallet.\");let a=fi(f);if(0===a.length)throw new Ce(\"User has no delegated wallets to revoke.\");if(a.some(P))throw new Ce(\"useDelegatedActions is only supported for on-device execution and this app uses TEE execution. Use the useSessionSigners hook to provision server side access on behalf of your users. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide\");let i=async()=>{await r.revokeDelegatedWallet(),await Ut.refreshSessionAndUser()};if(e)we({delegatedActions:{revoke:{onRevoke:i,onSuccess:async()=>{t()},onError:async e=>{n(e)}}}}),it(\"DelegatedActionsRevokeScreen\");else try{await i(),t()}catch(e){n(e)}})),initLoginWithFarcaster:async(e,t)=>{let n=new Zr(e,t);r.startAuthFlow(n);try{$e.current=\"farcaster\",await n.initializeFarcasterConnect()}catch(e){throw\"login\"===Ge.current?er(Re,\"login\",\"onError\",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR):\"link\"===Ge.current&&er(Re,\"linkAccount\",\"onError\",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:\"farcaster\"}),e}},loginWithFarcaster:async()=>{let e,t;if(!y)throw new We;if(!(r.authFlow instanceof Zr))throw new Ce(\"Must initialize Farcaster flow first.\");if(null!==await r.getAccessToken())try{({user:e}=await r.link()),$e.current=\"farcaster\"}catch(e){throw er(Re,\"linkAccount\",\"onError\",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:\"farcaster\"}),e}else try{({user:e,isNewUser:t}=await r.authenticate()),$e.current=\"farcaster\"}catch(e){throw er(Re,\"login\",\"onError\",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}v(e||null),_(t||!1),Ke(!0)},async crossAppAuthFlow({appId:e,popup:t,action:n}){let a=`privy:${e}`;$e.current=a;let{url:i,stateCode:s,codeVerifier:o}=await async function({api:e,appId:t}){let n=aa(),r=ia(),a=await sa(n);try{let{url:i}=await e.post(Lt,{provider:`privy:${t}`,redirect_to:window.location.href,code_challenge:a,state_code:r});return{url:i,stateCode:r,codeVerifier:n}}catch(e){throw Te(e)}}({api:r.api,appId:e});if(!i)throw r.createAnalyticsEvent({eventName:\"cross_app_auth_error\",payload:{error:\"Unable to open cross-app auth popup\",appId:e}}),new Ce(\"No authorization URL returned for cross-app auth.\");try{let l=await async function({url:e,popup:t}){return t.location=e,new Promise(((e,n)=>{let r,a=setTimeout((()=>{n(new Ce(\"Authorization request timed out after 2 minutes.\")),i()}),12e4);function i(){t?.close(),window.removeEventListener(\"message\",o)}let s=setInterval((()=>{t?.closed&&!r&&(i(),clearInterval(s),clearTimeout(a),n(new Ce(\"User rejected request\")))}),300);function o(t){t.data&&(\"PRIVY_OAUTH_RESPONSE\"===t.data.type&&t.data.stateCode&&t.data.authorizationCode&&(clearTimeout(a),e(t.data),i()),\"PRIVY_OAUTH_ERROR\"===t.data.type&&(clearTimeout(a),n(new Ce(t.data.error)),i()),t.data.type===Ai&&((r=new BroadcastChannel(vi)).onmessage=o))}window.addEventListener(\"message\",o)}))}({url:i,popup:t,provider:a}),c=l.stateCode,d=l.authorizationCode;if(c!==s)throw r.createAnalyticsEvent({eventName:\"possible_phishing_attempt\",payload:{provider:a,storedStateCode:s??\"\",returnedStateCode:c??\"\"}}),new Ce(\"Unexpected auth flow. This may be a phishing attempt.\",void 0,_e.OAUTH_UNEXPECTED);let u=await async function({appId:e,stateCode:t,codeVerifier:n,authorizationCode:r,action:a,client:i}){if(!r||!t)throw new Ce(\"[Cross-App AuthFlow] Authorization and state codes code must be set prior to calling authenicate.\");if(\"undefined\"===r)throw new Ce(\"User denied confirmation during cross-app auth flow\");try{let s=new ki({authorizationCode:r,stateCode:t,codeVerifier:n,provider:`privy:${e}`});i.startAuthFlow(s);let o=\"link\"===a?await i.link():await i.authenticate(),l=o.oAuthTokens?.accessToken;return console.debug(),l}catch(e){let t=Te(e);if(t.privyErrorCode===_e.ACCOUNT_TRANSFER_REQUIRED)throw t;if(t.privyErrorCode)throw new Ce(t.message||\"Invalid code during cross-app auth flow.\",void 0,t.privyErrorCode);if(\"User denied confirmation during cross-app auth flow\"===t.message)throw new Ce(\"Invalid code during cross-app auth flow.\",void 0,_e.OAUTH_USER_DENIED);throw new Ce(\"Invalid code during cross-app auth flow.\",void 0,_e.UNKNOWN_AUTH_ERROR)}}({appId:e,codeVerifier:o,stateCode:c,authorizationCode:d,action:n,client:r});u&&r.storeProviderAccessToken(e,u);let h=await Ut.refreshSessionAndUser();if(!h)throw new Ce(\"Unable to update user\");return r.createAnalyticsEvent({eventName:\"cross_app_auth_completed\",payload:{providerAppId:e}}),h}catch(e){throw r.createAnalyticsEvent({eventName:\"cross_app_auth_error\",payload:{error:e.toString(),provider:a}}),e}},async initLoginWithOAuth(e,t,n){if($e.current=e,!je())return void it(\"InAppBrowserLoginNotPossible\");if(\"google\"===e&&!d.allowOAuthInEmbeddedBrowsers&&Ui(window.navigator.userAgent))return void it(\"InAppBrowserLoginNotPossible\");\"twitter\"===e&&window.opener&&window.opener.postMessage({type:Ai},\"*\"),Me.del(Je),Me.del(Qe);let a=new oa({provider:e,disableSignup:!!n,withPrivyUi:!0,customOAuthRedirectUrl:d.customOAuthRedirectUrl});t&&a.addCaptchaToken(t),r.startAuthFlow(a);let i=await r.authFlow.getAuthorizationUrl();if(i&&i.url)if(\"twitter\"===e&&At&&(i.url=i.url.replace(\"x.com\",\"twitter.com\")),\"chrome-extension:\"===window.location.protocol&&ta())try{let{privyOAuthCode:e,privyOAuthState:t}=await na(i.url);it(\"OAuthStatusScreen\"),a.meta.stateCode=t,a.meta.authorizationCode=e}catch(e){throw console.error(\"OAuth in chrome extension flow failed:\",e),e}else window.location.assign(i.url)},async initLoginWithTelegram(e,t){if(!y)throw new We;$e.current=\"telegram\";let n=new Aa(e,t);r.startAuthFlow(n),ce({status:\"loading\"}),n.meta.telegramWebAppData=void 0,n.meta.telegramAuthResult=await new Promise(((e,t)=>d.loginConfig.telegramAuthConfiguration?window.Telegram?void window.Telegram.Login.auth({bot_id:d.loginConfig.telegramAuthConfiguration.botId,request_access:!0},(n=>n?e(n):(\"link\"===Ge.current?er(Re,\"linkAccount\",\"onError\",_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:\"telegram\"}):\"login\"===Ge.current?er(Re,\"login\",\"onError\",_e.INVALID_CREDENTIALS):\"update\"===Ge.current&&er(Re,\"login\",\"onError\",_e.FAILED_TO_UPDATE_ACCOUNT),t(new Ce(\"Telegram auth failed or was canceled by the client\"))))):t(new Ce(\"Telegram was not initialized\")):t(new Ce(\"Telegram Auth configuration is not loaded\"))))},async loginWithTelegram(e){let t,n;if(!(r.authFlow instanceof Aa))throw new Ce(\"Must initialize Telegram flow before calling loginWithTelegram\");r.authFlow.meta.captchaToken||=e?.captchaToken;let a=await Kr(),i=e?.intent||Ge.current;if(\"login\"===i)try{let e=await r.authenticate();t=e.user,n=e.isNewUser,$e.current=\"telegram\"}catch(e){throw er(Re,\"login\",\"onError\",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}else{if(\"link\"!==i)throw new Ce(\"Unknown auth intent\");try{t=(await r.link()).user,$e.current=\"telegram\"}catch(e){throw er(Re,\"linkAccount\",\"onError\",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:\"telegram\"}),e}}v(t),_(n||!1),Ke(!0),ce({status:\"done\"});let s=t?.linkedAccounts.find((({type:e})=>\"telegram\"===e))||null;return{user:t,isNewUser:n||!1,wasAlreadyAuthenticated:!!a,loginAccount:s}},async loginWithOAuth(e){let t,n,a;if(!(r.authFlow instanceof oa))throw new Ce(\"Must initialize OAuth flow before calling loginWithOAuth\");let i=Me.get(Ze),s=r.authFlow.meta.stateCode;if(i!==s)throw r.createAnalyticsEvent({eventName:\"possible_phishing_attempt\",payload:{provider:e,storedStateCode:i??\"\",returnedStateCode:s??\"\"}}),new Ce(\"Unexpected auth flow. This may be a phishing attempt.\",void 0,_e.OAUTH_UNEXPECTED);if(null!==await r.getAccessToken())try{let n=await r.link();t=n.user,a=n.oAuthTokens,$e.current=e}catch(t){throw er(Re,\"linkAccount\",\"onError\",t.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{let i=await r.authenticate();t=i.user,n=i.isNewUser,a=i.oAuthTokens,$e.current=e}catch(t){throw\"login\"===Ge.current?er(Re,\"login\",\"onError\",t.privyErrorCode||_e.UNKNOWN_AUTH_ERROR):\"link\"===Ge.current&&er(Re,\"linkAccount\",\"onError\",t.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}return v(t),_(n||!1),Ke(!0),a&&t&&er(Re,\"oAuthAuthorization\",\"onOAuthTokenGrant\",{oAuthTokens:a,user:t}),a},passkeyAuthState:z,setPasskeyAuthState:q,async initSignupWithPasskey({captchaToken:e,withPrivyUi:t}){let n=new da({captchaToken:e,setPasskeyAuthState:q,hints:d.passkeys.registration?.hints});r.startAuthFlow(n),Ge.current=\"login\";try{$e.current=\"passkey\",q({status:\"generating-challenge\"}),await n.initRegisterFlow(t),q({status:\"awaiting-passkey\"})}catch(e){throw q({status:\"error\",error:e}),er(Re,\"login\",\"onError\",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}},async signupWithPasskey(){let e,t;if(!y)throw new We;if(!(r.authFlow instanceof da))throw new Ce(\"Must initialize Passkey flow first.\");if(\"passkey\"!==$e.current){let e=new Ce(\"Must init login with Passkey flow first.\");throw q({status:\"error\",error:e}),e}let n=await Kr();try{$e.current=\"passkey\",q({status:\"awaiting-passkey\"}),({user:e,isNewUser:t}=await r.authenticate())}catch(e){throw q({status:\"error\",error:e}),er(Re,\"login\",\"onError\",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}v(e),_(t||!1),Ke(!0),q({status:\"done\"});let a=e?.linkedAccounts.find((({type:e})=>\"passkey\"===e))||null;return{user:e,isNewUser:t||!1,wasAlreadyAuthenticated:!!n,loginAccount:a}},async initLoginWithPasskey({captchaToken:e,withPrivyUi:t}){let n=new da({captchaToken:e,setPasskeyAuthState:q,hints:void 0});r.startAuthFlow(n),Ge.current=\"login\";try{$e.current=\"passkey\",q({status:\"generating-challenge\"}),await n.initAuthenticationFlow(t),q({status:\"awaiting-passkey\"})}catch(e){throw q({status:\"error\",error:e}),er(Re,\"login\",\"onError\",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}},async loginWithPasskey(e){let t,n;if(!y)throw new We;if(!(r.authFlow instanceof da))throw new Ce(\"Must initialize Passkey flow first.\");if(e?.credentialIds&&(r.authFlow.meta.allowedCredentialsIds=e.credentialIds),\"passkey\"!==$e.current){let e=new Ce(\"Must init login with Passkey flow first.\");throw q({status:\"error\",error:e}),e}let a=await Kr();try{$e.current=\"passkey\",q({status:\"awaiting-passkey\"}),({user:t,isNewUser:n}=await r.authenticate())}catch(e){throw q({status:\"error\",error:e}),er(Re,\"login\",\"onError\",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}v(t),_(n||!1),Ke(!0),q({status:\"done\"});let i=t?.linkedAccounts.find((({type:e})=>\"passkey\"===e))||null;return{user:t,isNewUser:n||!1,wasAlreadyAuthenticated:!!a,loginAccount:i}},async initLinkWithPasskey(e){let t=new da({captchaToken:e,hints:d.passkeys.registration?.hints});r.startAuthFlow(t),Ge.current=\"link\",$e.current=\"passkey\",q({status:\"generating-challenge\"});try{await t.initLinkFlow(),q({status:\"awaiting-passkey\"})}catch(e){throw er(Re,\"linkAccount\",\"onError\",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:\"passkey\"}),q({status:\"error\",error:e}),e}},async linkWithPasskey(){let e;if(!y)throw new We;if(!(r.authFlow instanceof da))throw new Ce(\"Must initialize Passkey flow first.\");if(\"passkey\"!==$e.current)throw new Ce(\"Must init login with Passkey flow first.\");try{$e.current=\"passkey\",({user:e}=await r.link())}catch(e){throw er(Re,\"linkAccount\",\"onError\",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:\"passkey\"}),e}return v(e||f||null),q({status:\"done\"}),e},async initLoginWithHeadlessOAuth(e,t,n){if(!je())throw Error(\"It looks like you're using an in-app browser.  To log in, please try again using an external browser.\");if(\"google\"===e&&!d.allowOAuthInEmbeddedBrowsers&&Ui(window.navigator.userAgent))throw Error(\"It looks like you're using an in-app browser.  To log in, please try again using an external browser.\");let a=new oa({provider:e,withPrivyUi:!1,disableSignup:n??!1,customOAuthRedirectUrl:d.customOAuthRedirectUrl});t&&a.addCaptchaToken(t),Q({status:\"loading\"});let i=await r.startAuthFlow(a).getAuthorizationUrl();if(i?.url)if(\"chrome-extension:\"===window.location.protocol&&ta())try{let{privyOAuthCode:e,privyOAuthState:t}=await na(i.url);a.meta.stateCode=t,a.meta.authorizationCode=e,await this.loginWithHeadlessOAuth(a.meta)}catch(e){throw Q({status:\"error\",error:e}),e}else window.location.assign(i.url)},async loginWithHeadlessOAuth(e){let t,n,a;L(!0),Q({status:\"loading\"}),r.startAuthFlow(new oa({...e,customOAuthRedirectUrl:d.customOAuthRedirectUrl}));let i=Me.get(Ze),s=e.stateCode;if(i!==s)throw r.createAnalyticsEvent({eventName:\"possible_phishing_attempt\",payload:{provider:e.provider,storedStateCode:i??\"\",returnedStateCode:s??\"\"}}),L(!1),new Ce(\"Unexpected auth flow. This may be a phishing attempt.\",void 0,_e.OAUTH_UNEXPECTED);if(null!==await r.getAccessToken())try{({user:t,oAuthTokens:a}=await r.link()),$e.current=e.provider;let n=kt(t);t&&n&&er(Re,\"linkAccount\",\"onSuccess\",{user:t,linkMethod:$e.current,linkedAccount:n})}catch(t){throw L(!1),er(Re,\"linkAccount\",\"onError\",t.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:e.provider}),t}else try{({user:t,isNewUser:n,oAuthTokens:a}=await r.authenticate()),$e.current=e.provider;let i=kt(t);t&&i&&void 0!==n&&er(Re,\"login\",\"onComplete\",{user:t,isNewUser:n,wasAlreadyAuthenticated:!1,loginMethod:$e.current,loginAccount:i})}catch(e){throw L(!1),Q({status:\"error\",error:e}),er(Re,\"login\",\"onError\",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}return v(t),_(n||!1),Ke(!0),L(!1),Q({status:\"done\"}),a&&t&&er(Re,\"oAuthAuthorization\",\"onOAuthTokenGrant\",{oAuthTokens:a,user:t}),t??void 0},initLoginWithEmail:async({email:e,captchaToken:t,disableSignup:n,withPrivyUi:a})=>{let i=new Yr({email:e,captchaToken:t,disableSignup:n});r.startAuthFlow(i);try{$e.current=\"email\",B({status:\"sending-code\"});let e=await i.sendCodeEmail({withPrivyUi:a});if(e?.ssoRedirectUrl)return window.location.href=e.ssoRedirectUrl,void await ae(1e4);B({status:\"awaiting-code-input\"})}catch(e){throw B({status:\"error\",error:e}),\"login\"===Ge.current?er(Re,\"login\",\"onError\",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR):\"link\"===Ge.current&&er(Re,\"linkAccount\",\"onError\",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:\"email\"}),e}},initUpdateEmail:async({oldAddress:e,newAddress:t,captchaToken:n})=>{let a=new Jr(e,t,n);r.startAuthFlow(a);try{await a.sendCodeEmail({withPrivyUi:!0})}catch(e){throw er(Re,\"update\",\"onError\",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:$e.current}),e}},initUpdatePhone:async(e,t,n)=>{let a=new ma(e,t,n);r.startAuthFlow(a);try{await a.sendSmsCode({withPrivyUi:!0})}catch(e){er(Re,\"update\",\"onError\",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:$e.current})}},initLoginWithSms:async({phoneNumber:e,captchaToken:t,disableSignup:n,withPrivyUi:a})=>{$({status:\"sending-code\"});let i=new wa({phoneNumber:e,captchaToken:t,disableSignup:n});r.startAuthFlow(i);try{$e.current=\"sms\",await i.sendSmsCode({withPrivyUi:a}),$({status:\"awaiting-code-input\"})}catch(e){throw $({status:\"error\",error:e}),\"login\"===Ge.current?er(Re,\"login\",\"onError\",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR):\"link\"===Ge.current&&er(Re,\"linkAccount\",\"onError\",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:\"sms\"}),e}},resendEmailCode:async()=>{await(r.authFlow?.sendCodeEmail({withPrivyUi:!0}))},resendSmsCode:async()=>{await(r.authFlow?.sendSmsCode({withPrivyUi:!0}))},loginWithCode:async e=>{let t,n;function a(e){r.authFlow instanceof Yr?B(e):r.authFlow instanceof wa&&$(e)}if(a({status:\"submitting-code\"}),!y){let e=new We;throw a({status:\"error\",error:e}),e}if(r.authFlow instanceof Yr)r.authFlow.meta.emailCode=e.trim();else{if(!(r.authFlow instanceof wa)){let e=new Ce(\"Must initialize a passwordless code flow first\");throw a({status:\"error\",error:e}),e}r.authFlow.meta.smsCode=e.trim()}let i=await Kr();if(\"link\"===Ge.current)try{({user:t}=await r.link())}catch(e){throw a({status:\"error\",error:e}),er(Re,\"linkAccount\",\"onError\",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:$e.current}),e}else if(\"update\"===Ge.current)try{({user:t}=await r.link())}catch(e){throw a({status:\"error\",error:e}),er(Re,\"update\",\"onError\",e.privyErrorCode||_e.FAILED_TO_UPDATE_ACCOUNT,{linkMethod:$e.current}),e}else try{({user:t,isNewUser:n}=await r.authenticate())}catch(e){throw a({status:\"error\",error:e}),er(Re,\"login\",\"onError\",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}let s=t||f;v(s||null),_(n||!1),Ke(!0),a({status:\"done\"});let o=null;return r.authFlow instanceof Yr?o=s?.linkedAccounts.find((({type:e})=>\"email\"===e))||null:r.authFlow instanceof wa&&(o=s?.linkedAccounts.find((({type:e})=>\"phone\"===e))||null),{user:s,isNewUser:n||!1,wasAlreadyAuthenticated:!!i,linkedAccount:o}},generateSiweMessage:async({address:e,chainId:t,captchaToken:n})=>{Ge.current=Ve?\"link\":\"login\",$e.current=\"siwe\",Y({status:\"generating-message\"});let a=await r.generateSiweNonce({address:e,captchaToken:n});return Y({status:\"awaiting-signature\"}),ua({address:e,chainId:t.replace(\"eip155:\",\"\"),nonce:a})},generateSiweMessageForSmartWallet:async({address:e,chainId:t})=>{let n=await r.generateSiweNonce({address:e});return ua({address:e,chainId:t.replace(\"eip155:\",\"\"),nonce:n})},linkSmartWallet:async({message:e,signature:t,smartWalletType:n,smartWalletVersion:a})=>{let i;i=await r.linkSmartWallet({message:e,signature:t,smartWalletType:n,smartWalletVersion:a}),v((i=await Ut.refreshSessionAndUser()??i)||f||null)},loginWithSiwe:async({message:e,signature:t,captchaToken:n,disableSignup:a,walletClientType:i,connectorType:s})=>{let o,l=null;try{if(f)throw Error(\"User already authenticated\");let c=new ha(r,void 0,n,a,{message:e,signature:t,walletClientType:i,connectorType:s});r.startAuthFlow(c),$e.current=\"siwe\",Ge.current=\"login\",Y({status:\"submitting-signature\"});let d=await r.authenticate();if(({user:l,isNewUser:o}=d),!l)throw Error(\"Authentication failed - no user returned\")}catch(e){throw er(Re,\"login\",\"onError\",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),Y({status:\"error\",error:e}),e}return v(l),_(o||!1),Ke(!0),Y({status:\"done\"}),Ge.current=null,$e.current=null,{user:l,isNewUser:o||!1}},linkWithSiwe:async({message:e,signature:t,chainId:n,walletClientType:a,connectorType:i})=>{let s;wt(\"siwe\");let o=null;try{Y({status:\"submitting-signature\"}),s=await r.linkWithSiwe({message:e,signature:t,chainId:n,walletClientType:a,connectorType:i}),s=await Ut.refreshSessionAndUser()??s,Y({status:\"done\"}),(o=kt(s)||null)&&er(Re,\"linkAccount\",\"onSuccess\",{user:s,linkMethod:\"siwe\",linkedAccount:o})}catch(e){throw er(Re,\"linkAccount\",\"onError\",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:\"siwe\"}),Ge.current=null,$e.current=null,Y({status:\"error\",error:e}),e}let l=s||f;return v(l||null),Ge.current=null,$e.current=null,{user:l,linkedAccount:o}},refreshSessionAndUser:async()=>{let e=await r.getAuthenticatedUser();return Ke(!!e),v(e),e},walletProxy:de,createAnalyticsEvent:({eventName:e,payload:t,timestamp:n})=>r.createAnalyticsEvent({eventName:e,payload:t,timestamp:n}),acceptTerms:async()=>{let e=await r.acceptTerms();return v(e),e},getUsdTokenPrice:e=>r.getUsdTokenPrice(e),getUsdPriceForSol:()=>r.getUsdPriceForSol(),getSplTokenMetadata:e=>r.getSplTokenMetadata(e),recoverEmbeddedWallet:async e=>new Promise((async(t,n)=>{if(!f)return void t(!0);let a=e?.address?N(f,e.address):b(f)||U(f).at(0)||O(f).at(0);if(!a||P(a))return void t(!0);let i=await Kr();if(!i||!de||!a)return void n(Error(\"Must have valid access token and Privy wallet to recover wallet\"));let{entropyId:s,entropyIdVerifier:o}=ve(f,a);try{await de.connect({accessToken:i,entropyId:s,entropyIdVerifier:o}),t(!0)}catch(e){if(ei(e)&&\"privy\"===a.recoveryMethod){let e;r.createAnalyticsEvent({eventName:\"embedded_wallet_pinless_recovery_started\",payload:{walletAddress:a.address}});try{e=await de.recover({entropyId:s,entropyIdVerifier:o,accessToken:i})}catch(e){return void n(e)}e.entropyId||n(Error(\"Unable to recover wallet\")),r.createAnalyticsEvent({eventName:\"embedded_wallet_recovery_completed\",payload:{walletAddress:a.address}}),t(!0)}else ei(e)&&\"privy\"!==a.recoveryMethod&&\"privy-v2\"!==a.recoveryMethod?(we({recoverWallet:{entropyId:s,entropyIdVerifier:o,onFailure:n,onSuccess:()=>t(!0)},recoveryOAuthStatus:{provider:a.recoveryMethod,action:\"recover\",shouldCreateEth:!1,shouldCreateSol:!1}}),it(Ii(a.recoveryMethod))):n(e)}})),setReadyToTrue:e=>{g(!0),me?.(e)},updateWallets:()=>yt(),fundWallet:async(e,t)=>{let n=\"FundingMethodSelectionScreen\";return new Promise(((r,a)=>{we({funding:{...De({address:e,appConfig:d,fundWalletConfig:t,methodScreen:n,onComplete:r,onError:a})}}),it(n)}))},openModal:it,requestFarcasterSignerStatus:async e=>{let t=await Kr(),n=f?.linkedAccounts.find((e=>\"wallet\"===e.type&&\"privy\"===e.walletClientType));if(!t)throw Error(\"Must have valid access token to connect with Farcaster\");if(!de||!n)throw Error(\"Must have an embedded wallet to use Farcaster signers\");if(!f?.farcaster?.fid)throw Error(\"Must have Farcaster account to use Farcaster signers\");let a=await r.requestFarcasterSignerStatus(e);return\"approved\"===a.status&&v(await r.getAuthenticatedUser()||f||null),a},connectCoinbaseSmartWallet:async()=>{d.externalWallets.coinbaseWallet.config.preference={...d.externalWallets.coinbaseWallet.config.preference,options:\"smartWalletOnly\"};let e=r.connectors?.findWalletConnector(\"coinbase_wallet\",\"coinbase_smart_wallet\")||r.connectors?.findWalletConnector(\"coinbase_wallet\",\"coinbase_wallet\");if(e)return e.updateConnectionPreference(\"smartWalletOnly\"),dt(e);await ct(\"coinbase_wallet\",\"coinbase_smart_wallet\")},connectBaseAccount:async()=>{let e=r.connectors?.findWalletConnector(\"base_account\",\"base_account\");if(e)return dt(e);await ct(\"base_account\",\"base_account\")},initiateAccountTransfer:async({nonce:e,account:t,accountType:n,externalWalletMetadata:a,telegramAuthResult:i,telegramWebAppData:s,farcasterEmbeddedAddress:o,oAuthUserInfo:l})=>{let c=await r.sendAccountTransferRequest({nonce:e,account:t,accountType:n,externalWalletMetadata:a,telegramAuthResult:i,telegramWebAppData:s,farcasterEmbeddedAddress:o,oAuthUserInfo:l});return v(c),c},inProgressAuthFlowRef:Ge,inProgressLoginOrLinkMethodRef:$e};es=Ut.recoverEmbeddedWallet,Ut.recoverEmbeddedWallet;let Nt=l((()=>({wallets:A,ready:fe&&xe})),[A,fe,xe]),Ot=r.authFlow instanceof Aa,{siteKey:Rt,enabledProvider:Mt}=d.captcha,xt=!d.headless&&Mt&&!Ve&&(y||Ot);/*#__PURE__*/return t(Yi.Provider,{value:!0,children:/*#__PURE__*/t(R.Provider,{value:Wt,children:/*#__PURE__*/t(tr.Provider,{value:Re,children:/*#__PURE__*/t(Ae.Provider,{value:Nt,children:/*#__PURE__*/t(fa,{appId:d.id,captchaSiteKey:Rt,enabledCaptchaProvider:Mt,children:/*#__PURE__*/e(Ue.Provider,{value:Ut,children:[/*#__PURE__*/t(ie,{children:/*#__PURE__*/e(M,{data:pe,setModalData:we,setInitialScreen:I,initialScreen:S,authenticated:Ve,open:u,children:[n.children,/*#__PURE__*/t(Gi,{customAuth:d.customAuth}),xt&&/*#__PURE__*/t(Sa,{delayedExecution:!1}),/*#__PURE__*/t(Ya,{}),/*#__PURE__*/t(zi,{disabled:d.embeddedWallets.disableAutomaticMigration}),/*#__PURE__*/t(Wa,{palette:d.appearance.palette||{}}),!d.render.standalone&&/*#__PURE__*/t(Va,{open:u})]})}),/*#__PURE__*/t(mi,{appId:n.appId,appClientId:n.clientId,clientAnalyticsId:r.clientAnalyticsId,origin:r.apiUrl,mfaMethods:f?.mfaMethods,mfaPromise:Ne,mfaSubmitPromise:Oe,onLoad:ue,onLoadFailed:()=>null}),d.loginConfig.telegramAuthConfiguration&&\n/*#__PURE__*/t(V,{$if:!0,children:/*#__PURE__*/t(Ga,{scriptHost:n.apiUrl||nt,botUsername:d.loginConfig.telegramAuthConfiguration.botName})})]})})})})})})},ns=e=>es(e);class rs extends Error{constructor(e,t,n){super(e),this.code=t,this.data=n}}class as extends D{async handleSendTransaction(e){if(!e.params||!Array.isArray(e.params))throw new rs(`Invalid params for ${e.method}`,4200);let t=e.params[0];if(!await Kr()||!this.address)throw new rs(\"Disconnected\",4900);let{hash:n}=await((e,t)=>Xi(e,t))(t,{address:this.address});return n}async handleSignTransaction(e){if(!e.params||!Array.isArray(e.params))throw new rs(`Invalid params for ${e.method}`,4200);let t=e.params[0];if(!await Kr()||!this.address)throw new rs(\"Disconnected\",4900);let{signature:n}=await((e,t)=>Zi(e,t))(t,{address:this.address});return n}handleSwitchEthereumChain(e){let t;if(!e.params||!Array.isArray(e.params))throw new rs(`Invalid params for ${e.method}`,4200);if(\"string\"==typeof e.params[0])t=e.params[0];else{if(!(\"chainId\"in e.params[0])||\"string\"!=typeof e.params[0].chainId)throw new rs(`Invalid params for ${e.method}`,4200);t=e.params[0].chainId}this.chainId=Number(t),this.publicClient=gr(this.chainId,this.chains,this.rpcConfig,{appId:this.appId}),this.emit(\"chainChanged\",t)}async handlePersonalSign(e){if(!e.params||!Array.isArray(e.params))throw Error(\"Invalid params for personal_sign\");let t=e.params[0],n=e.params[1],{signature:r}=await((e,t)=>Ji(e,t))({message:t},{address:n});return r}async handleSignedTypedData(e){if(!e.params||!Array.isArray(e.params))throw Error(\"Invalid params for eth_signTypedData_v4\");let t=e.params[0],n=\"string\"==typeof e.params[1]?JSON.parse(e.params[1]):e.params[1],{signature:r}=await((e,t)=>Qi(e,t))(oe(n),{address:t});return r}async handleEstimateGas(e){if(!e.params||!Array.isArray(e.params))throw Error(\"Invalid params for eth_estimateGas\");delete e.params[0].gasPrice,delete e.params[0].maxFeePerGas,delete e.params[0].maxPriorityFeePerGas;let t={...e.params[0],chainId:q(this.chainId)};return await this.publicClient.estimateGas({account:t.from??this.address,...Be(t)})}async request(e){switch(console.debug(\"Embedded1193Provider.request() called with args\",e),e.method){case\"eth_accounts\":case\"eth_requestAccounts\":return this.address?[this.address]:[];case\"eth_chainId\":return q(this.chainId);case\"eth_estimateGas\":return this.handleEstimateGas(e);case\"eth_sendTransaction\":return this.handleSendTransaction(e);case\"eth_signTransaction\":return this.handleSignTransaction(e);case\"wallet_switchEthereumChain\":return this.handleSwitchEthereumChain(e);case\"personal_sign\":return this.handlePersonalSign(e);case\"eth_signTypedData_v4\":return this.handleSignedTypedData(e)}if(!(e=>$r.includes(e))(e.method))return this.publicClient.request({method:e.method,params:e.params});{let t=await Kr();if(await ns({address:this.address}),!t||!this.address)throw new rs(\"Disconnected\",4900);try{let n={method:e.method,params:e.params},r=this.walletAccount;return r&&P(r)?this.handleWalletApiRequest(n,r,t):(await this.walletProxy.rpc({accessToken:t,entropyId:this.entropyId,entropyIdVerifier:this.entropyIdVerifier,chainType:\"ethereum\",hdWalletIndex:this.walletIndex,request:n})).response.data}catch(e){throw console.error(e),new rs(\"Disconnected\",4900)}}}async handleWalletApiRequest(e,t,n){let r=this.privyClient;if(!r)throw new rs(\"Disconnected\",4900);if(\"secp256k1_sign\"===e.method){let a=await m(r,(async({message:e})=>this.walletProxy.signWithUserSigner({accessToken:n,message:e})),{chain_type:\"ethereum\",method:\"secp256k1_sign\",wallet_id:t.id,params:{hash:e.params[0]}});if(\"secp256k1_sign\"!==a.method)throw new rs(`Invalid params for ${e.method}`,4200);return a.data.signature}throw new rs(`Method not supported: ${e.method}`,4200)}constructor({walletProxy:e,address:t,entropyId:n,entropyIdVerifier:r,rpcConfig:a,chains:i,appId:s,chainId:o=1,walletIndex:l,privyClient:c,walletAccount:d}){super(),this.walletProxy=e,this.address=t,this.entropyId=n,this.entropyIdVerifier=r,this.chainId=o,this.rpcConfig=a,this.chains=i,this.publicClient=gr(o,this.chains,a,{appId:s}),this.rpcTimeoutDuration=Q(a,\"privy\"),this.appId=s,this.walletIndex=l,this.privyClient=c,this.walletAccount=d}}const is=({style:e,...n})=>/*#__PURE__*/t(\"svg\",{xmlns:\"http://www.w3.org/2000/svg\",fill:\"none\",stroke:\"currentColor\",strokeWidth:1.5,viewBox:\"0 0 24 24\",style:{...e},...n,children:/*#__PURE__*/t(\"path\",{strokeLinecap:\"round\",strokeLinejoin:\"round\",d:\"M9 17.25v1.007a3 3 0 01-.879 2.122L7.5 21h9l-.621-.621A3 3 0 0115 18.257V17.25m6-12V15a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 15V5.25m18 0A2.25 2.25 0 0018.75 3H5.25A2.25 2.25 0 003 5.25m18 0V12a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 12V5.25\"})}),ss=({style:n,...r})=>/*#__PURE__*/e(\"svg\",{xmlns:\"http://www.w3.org/2000/svg\",width:\"108\",height:\"108\",viewBox:\"0 0 108 108\",fill:\"none\",style:{height:\"28px\",width:\"28px\",...n},...r,children:[/*#__PURE__*/t(\"rect\",{width:\"108\",height:\"108\",rx:\"23\",fill:\"#AB9FF2\"}),/*#__PURE__*/t(\"path\",{fillRule:\"evenodd\",clipRule:\"evenodd\",d:\"M46.5267 69.9229C42.0054 76.8509 34.4292 85.6182 24.348 85.6182C19.5824 85.6182 15 83.6563 15 75.1342C15 53.4305 44.6326 19.8327 72.1268 19.8327C87.768 19.8327 94 30.6846 94 43.0079C94 58.8258 83.7355 76.9122 73.5321 76.9122C70.2939 76.9122 68.7053 75.1342 68.7053 72.314C68.7053 71.5783 68.8275 70.7812 69.0719 69.9229C65.5893 75.8699 58.8685 81.3878 52.5754 81.3878C47.993 81.3878 45.6713 78.5063 45.6713 74.4598C45.6713 72.9884 45.9768 71.4556 46.5267 69.9229ZM83.6761 42.5794C83.6761 46.1704 81.5575 47.9658 79.1875 47.9658C76.7816 47.9658 74.6989 46.1704 74.6989 42.5794C74.6989 38.9885 76.7816 37.1931 79.1875 37.1931C81.5575 37.1931 83.6761 38.9885 83.6761 42.5794ZM70.2103 42.5795C70.2103 46.1704 68.0916 47.9658 65.7216 47.9658C63.3157 47.9658 61.233 46.1704 61.233 42.5795C61.233 38.9885 63.3157 37.1931 65.7216 37.1931C68.0916 37.1931 70.2103 38.9885 70.2103 42.5795Z\",fill:\"#FFFDF8\"})]});function os(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError(\"attempted to use private field on non-instance\");return e}var ls=0;class cs extends j{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit(\"initialized\")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}get walletBranding(){return{name:this.providerDetail.info.name,icon:this.providerDetail.info.icon,id:this.providerDetail.info.rdns}}disconnect(){console.warn(`Programmatic disconnect with ${this.providerDetail.info.name} is not yet supported.`)}async promptConnection(){try{let e=await this.proxyProvider.request({method:\"eth_requestAccounts\"});if(!e||0===e.length||!e[0])throw new ke(\"Unable to retrieve accounts\");await this.syncAccounts([e[0]])}catch(e){throw Re(e)}}constructor(e,t,n,r,a){super(a||\"unknown\",e,t,n),this.connectorType=\"injected\",this.proxyProvider=new z(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.providerDetail=r;let i=r.provider;this.proxyProvider.setWalletProvider(i)}}var ds=\"__private_\"+ls+++\"__walletBranding\";class us extends j{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit(\"initialized\")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}get walletBranding(){return os(this,ds)[ds]??{name:\"Browser Extension\",icon:is,id:\"extension\"}}disconnect(){console.warn(\"Programmatic disconnect with browser wallets is not yet supported.\")}async promptConnection(){try{let e=await this.proxyProvider.request({method:\"eth_requestAccounts\"});if(!e||0===e.length||!e[0])throw new ke(\"Unable to retrieve accounts\");await this.syncAccounts([e[0]])}catch(e){throw Re(e)}}constructor(e,t,n,r,a){super(a??\"unknown\",e,t,n),Object.defineProperty(this,ds,{writable:!0,value:void 0}),this.connectorType=\"injected\",this.proxyProvider=new z(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.proxyProvider.setWalletProvider(r),\"metamask\"===a?os(this,ds)[ds]={name:\"MetaMask\",icon:ce,id:\"io.metamask\"}:\"phantom\"===a&&(os(this,ds)[ds]={name:\"Phantom\",icon:ss,id:\"phantom\"})}}class hs extends cs{disconnect(){console.warn(\"MetaMask does not support programmatic disconnect.\")}async promptConnection(){try{ft||await this.proxyProvider.request({method:\"wallet_requestPermissions\",params:[{eth_accounts:{}}]});let e=await this.proxyProvider.request({method:\"eth_requestAccounts\"});if(!e||0===e.length||!e[0])throw new ke(\"Unable to retrieve accounts\");await this.syncAccounts([e[0]])}catch(e){throw Re(e)}}}class ps extends D{get wallets(){let e=new Set;return this.walletConnectors.flatMap((e=>e.wallets)).sort(((e,t)=>e.connectedAt&&t.connectedAt?t.connectedAt-e.connectedAt:0)).filter((t=>{let n=`${t.address}${t.walletClientType}${t.connectorType}${t.meta.id}`;return!e.has(n)&&(e.add(n),!0)}))}async initialize(e){if(this.initialized&&!e||(e&&this.removeAllConnectors(),this.externalWalletConfig.disableAllExternalWallets))return;let t=de({store:this.store,walletList:this.walletList,externalWalletConfig:this.externalWalletConfig,walletChainType:this.walletChainType}).then((e=>{e.forEach((({type:e,eip6963InjectedProvider:t,legacyInjectedProvider:n})=>{this.createEthereumWalletConnector({connectorType:\"injected\",walletClientType:e,providers:{eip6963InjectedProvider:t,legacyInjectedProvider:n}})}))}));for(let e of(this.walletList.includes(\"coinbase_wallet\")&&this.createEthereumWalletConnector({connectorType:\"coinbase_wallet\",walletClientType:\"coinbase_wallet\"}),this.walletList.includes(\"base_account\")&&this.createEthereumWalletConnector({connectorType:\"base_account\",walletClientType:\"base_account\"}),Object.values(ue)))!e.isInstalled&&this.walletList.includes(e.client)&&([\"ethereum-only\",\"ethereum-and-solana\"].includes(this.walletChainType)&&e.chainTypes.includes(\"ethereum\")&&this.createEthereumWalletConnector({connectorType:\"null\",walletClientType:e.client,walletConfig:e}),[\"ethereum-and-solana\",\"solana-only\"].includes(this.walletChainType)&&e.chainTypes.includes(\"solana\")&&this.addSolanaWalletConnector(new he({id:e.client,name:e.name})));this.externalWalletConfig.walletConnect.enabled&&(this.walletList.includes(\"wallet_connect_qr\")||ee(this.walletList))&&\"solana-only\"!==this.walletChainType&&this.createEthereumWalletConnector({connectorType:\"wallet_connect_v2\",walletClientType:\"unknown\"});let n=this.walletList.includes(\"wallet_connect_qr_solana\")||ee(this.walletList)&&\"ethereum-only\"!==this.walletChainType,r=this.externalWalletConfig.solana.connectors?.get()||[],a=async e=>{if(!n)return;let t=e.find((e=>\"walletconnect_solana\"===e.walletBranding?.id));t&&t.wallet&&await t.wallet.initialize({walletConnectCloudProjectId:this.walletConnectCloudProjectId,privyAppName:this.privyAppName})};a(r),r.filter((e=>n||\"walletconnect_solana\"!==e.walletBranding?.id)).forEach(this.addSolanaWalletConnector),this.externalWalletConfig.solana.connectors?._setOnConnectorsUpdated?.((e=>{a(e),e?.filter((e=>n||\"walletconnect_solana\"!==e.walletBranding?.id)).forEach(this.addSolanaWalletConnector)})),await t,this.initialized=!0}findWalletConnector(e,t,n){return\"wallet_connect_v2\"===e?this.walletConnectors.filter(pe).find((t=>t.connectorType===e&&(!n||t.wallets.some((e=>e.address===n)))))??null:this.walletConnectors.filter(pe).find((r=>r.connectorType===e&&r.walletClientType===t&&(!n||r.wallets.some((e=>e.address===n)))))??null}findSolanaWalletConnector(e){return this.walletConnectors.filter(we).find((t=>\"unknown\"===t.walletClientType?t.walletBranding.id===e:t.walletClientType===e))??null}findEmbeddedWalletConnectors(){return this.walletConnectors.filter((e=>\"embedded\"===e.connectorType))}findImportedWalletConnectors(){return this.walletConnectors.filter((e=>\"embedded_imported\"===e.connectorType))}onInitialized(e){e.wallets.forEach((e=>{let t=this.storedConnections.find((t=>t.address===e.address&&t.connectorType===e.connectorType&&(\"solana\"===e.type&&\"unknown\"===t.walletClientType&&\"unknown\"===e.walletClientType?e.meta.id===t.id:t.walletClientType===e.walletClientType)));t&&(e.connectedAt=t.connectedAt)})),this.emit(\"walletsUpdated\"),this.emit(\"connectorInitialized\")}onWalletsUpdated(e){e.initialized&&this.emit(\"walletsUpdated\")}addEmbeddedWalletConnectors({walletProxy:e,user:t,embeddedWallets:n,defaultChain:r,appId:a,privyClient:i}){let{entropyId:s,entropyIdVerifier:o}=ve(t);for(let t of n){let n=this.findEmbeddedWalletConnectors().find((e=>e.walletIndex===t.walletIndex));if(n&&pe(n))n.proxyProvider.walletProxy=e;else{let n=new Br({provider:new as({walletProxy:e,address:t.address,entropyId:s,entropyIdVerifier:o,rpcConfig:this.rpcConfig,chains:this.chains,appId:a,chainId:r.id,walletIndex:t.walletIndex,privyClient:i,walletAccount:t}),chains:this.chains,defaultChain:r,rpcConfig:this.rpcConfig,imported:!1,walletIndex:t.walletIndex});this.addWalletConnector(n)}}}addImportedWalletConnector(e,t,n,r){let a=this.findWalletConnector(\"embedded_imported\",\"privy\",t);if(a&&pe(a))a.proxyProvider.walletProxy=e;else{let a=new Br({provider:new as({walletProxy:e,address:t,entropyId:t,entropyIdVerifier:\"ethereum-address-verifier\",walletIndex:0,rpcConfig:this.rpcConfig,chains:this.chains,appId:r,chainId:n.id}),chains:this.chains,walletIndex:0,defaultChain:n,rpcConfig:this.rpcConfig,imported:!0});this.addWalletConnector(a)}}removeEmbeddedWalletConnectors(){this.walletConnectors=this.walletConnectors.filter((e=>\"embedded\"!==e.connectorType)),this.storedConnections=He(),this.emit(\"walletsUpdated\")}removeImportedWalletConnectors(){let e=this.findImportedWalletConnectors();e.length&&(e.forEach((e=>{let t=this.walletConnectors.indexOf(e);this.walletConnectors.splice(t,1)})),this.storedConnections=He(),this.emit(\"walletsUpdated\"))}async createEthereumWalletConnector({connectorType:e,walletClientType:t,providers:n,walletConfig:r}){let a=this.findWalletConnector(e,t);if(a&&pe(a))return a instanceof Ja&&a.resetConnection(t),a;let i=(()=>\"injected\"!==e?\"coinbase_wallet\"===e?new Hr(this.chains,this.defaultChain,this.rpcConfig,this.externalWalletConfig.coinbaseWallet.config):\"base_account\"===e?new zr(this.chains,this.defaultChain,this.rpcConfig,this.externalWalletConfig.baseAccount.config,this.setBaseAccountSdk):\"null\"!==e?new Ja({walletConnectCloudProjectId:this.walletConnectCloudProjectId,rpcConfig:this.rpcConfig,chains:this.chains,defaultChain:this.defaultChain,shouldEnforceDefaultChainOnConnect:this.shouldEnforceDefaultChainOnConnect,privyAppId:this.privyAppId,privyAppName:this.privyAppName,walletClientType:t}):r?new me({id:r.client,name:r.name,defaultChain:this.defaultChain,walletClientType:r.client}):null:\"metamask\"===t&&n?.eip6963InjectedProvider?new hs(this.chains,this.defaultChain,this.rpcConfig,n?.eip6963InjectedProvider,\"metamask\"):\"metamask\"===t&&n?.legacyInjectedProvider?new us(this.chains,this.defaultChain,this.rpcConfig,n?.legacyInjectedProvider,\"metamask\"):\"phantom\"===t&&n?.legacyInjectedProvider?new us(this.chains,this.defaultChain,this.rpcConfig,n?.legacyInjectedProvider,\"phantom\"):n?.legacyInjectedProvider&&\"unknown_browser_extension\"===t?new us(this.chains,this.defaultChain,this.rpcConfig,n?.legacyInjectedProvider):n?.eip6963InjectedProvider?new cs(this.chains,this.defaultChain,this.rpcConfig,n?.eip6963InjectedProvider,t):void 0)();return i&&this.addWalletConnector(i),i||null}addWalletConnector(e){this.walletConnectors.push(e),e.on(\"initialized\",(()=>this.onInitialized(e))),e.on(\"walletsUpdated\",(()=>this.onWalletsUpdated(e))),e.initialize().catch((e=>{console.debug(\"Failed to initialize connector\",e)}))}setWalletList(e){this.walletList=e,this.initialized&&this.initialize(!0).catch(console.error)}removeAllConnectors(){for(let e of this.walletConnectors)e.removeAllListeners();this.walletConnectors=[]}constructor(e,t,n,r,a,i,s,o,l,c,d,u){super(),this.addSolanaWalletConnector=async e=>{let t=this.findSolanaWalletConnector(e.walletClientType);if(!t||\"null\"===t.connectorType){if(\"null\"===t?.connectorType){let e=this.walletConnectors.indexOf(t);this.walletConnectors.splice(e,1)}this.addWalletConnector(e)}},this.privyAppId=e,this.walletConnectCloudProjectId=t,this.rpcConfig=n,this.chains=r,this.defaultChain=a,this.walletConnectors=[],this.initialized=!1,this.store=i,this.walletList=s,this.shouldEnforceDefaultChainOnConnect=o,this.externalWalletConfig=l,this.privyAppName=c,this.walletChainType=u||\"ethereum-only\",this.setBaseAccountSdk=d,this.storedConnections=He()}}const ws=nr((()=>({identityToken:null})));function ms(){let{identityToken:e}=ws();return{identityToken:e}}let ys=[Xt,en,tn];class gs{async get(e,t){try{return await this.baseFetch(e,t)}catch(e){throw Te(e)}}async post(e,t,n){try{return await this.baseFetch(e,{method:\"POST\",...t?{body:t}:{},...n})}catch(e){throw Te(e)}}async delete(e,t){try{return await this.baseFetch(e,{method:\"DELETE\",...t})}catch(e){throw Te(e)}}constructor({appId:e,appClientId:t,client:n,defaults:r}){this.appId=e,this.appClientId=t,this.clientAnalyticsId=n.clientAnalyticsId,this.sdkVersion=it,this.client=n,this.defaults=r,this.fallbackApiUrl=n.fallbackApiUrl,this.baseFetch=vr.create({baseURL:this.defaults.baseURL,timeout:this.defaults.timeout,retry:3,retryDelay:500,retryStatusCodes:[408,409,425,500,502,503,504],credentials:\"include\",onRequest:async({request:e,options:t})=>{let n=new Headers(t.headers);n.set(\"privy-app-id\",this.appId),this.appClientId&&n.set(\"privy-client-id\",this.appClientId),n.set(\"privy-ca-id\",this.clientAnalyticsId||\"\"),n.set(\"privy-client\",`react-auth:${this.sdkVersion}`);let r=ys.includes(e.toString());if(!n.has(\"authorization\")){let e=await this.client.getAccessToken({disableAutoRefresh:r});null!==e&&n.set(\"authorization\",`Bearer ${e}`)}t.headers=n,t.retryDelay&&\"number\"==typeof t.retryDelay&&(t.retryDelay=3*t.retryDelay)},onRequestError:({error:e})=>{if(e instanceof DOMException&&\"AbortError\"===e.name)throw new Ne}})}}const fs=e=>({rpId:e.rp_id,challenge:e.challenge,allowCredentials:e.allow_credentials?.map((e=>({id:e.id,type:e.type,transports:e.transports})))||[],timeout:e.timeout,extensions:{appid:e.extensions?.app_id,credProps:e.extensions?.cred_props,hmacCreateSecret:e.extensions?.hmac_create_secret},userVerification:e.user_verification});class vs{getOrCreateGuestCredential(e){let t=at(e);if(je()){if(Me.get(t))return Me.get(t);{let e=C.encode(ra(32));return Me.put(t,e),e}}return C.encode(ra(32))}async authenticate(){if(!this.api)throw new Ce(\"Auth flow has no API instance\");try{return await this.api.post(nn,{guest_credential:this.meta.guestCredential})}catch(e){throw Te(e)}}async link(){throw Error(\"Linking is not supported for the guest flow\")}constructor(e){this.meta={guestCredential:this.getOrCreateGuestCredential(e)}}}function As(){return!(kt&&window.location.origin.startsWith(\"http://localhost\"))}var ks,Cs=((ks={}).PRIVY=\"privy_access_token\",ks.CUSTOMER=\"customer_access_token\",ks);class Ts{get token(){return this.privyAccessToken||this.customerAccessToken}getToken(e){return\"privy_access_token\"===e?this.privyAccessToken:this.customerAccessToken}get customerAccessToken(){return this._getToken(Ge)}get privyAccessToken(){return this._getToken($e)}_getToken(e){try{let t=Me.get(e);return\"string\"==typeof t?Rr.throwIfNotWellFormedJwt(t):null}catch(e){return console.error(e),this.destroyLocalState(),null}}get refreshToken(){try{let e=Me.get(st);return\"string\"==typeof e?e:null}catch(e){return console.error(e),this.destroyLocalState(),null}}getProviderAccessToken(e){try{let t=Me.get(ot(e));if(\"string\"!=typeof t)return null;{let n=new Rr(t);return n.isExpired()?(Me.del(ot(e)),null):n.value}}catch(e){return console.error(e),null}}get mightHaveServerCookies(){try{let e=Ar.get(lt);return void 0!==e&&e.length>0}catch(e){console.error(e)}return!1}hasRefreshCredentials(e=\"privy_access_token\"){let t=\"string\"==typeof this.getToken(e),n=\"string\"==typeof this.refreshToken&&this.refreshToken!==ct;return this.mightHaveServerCookies||t&&n}hasActiveAccessToken(e){let t=Rr.parse(this.getToken(e));return null!==t&&!t.isExpired(30)}authenticate(e){return this.authenticateOnce.execute(e)}link(e){return this.linkOnce.execute(e)}refresh(){return this.refreshOnce.execute()}destroy(){return this.destroyOnce.execute()}storeProviderAccessToken(e,t){\"string\"==typeof t?Me.put(ot(e),t):Me.del(ot(e))}updateIdentityToken(e){\"string\"==typeof e?this.storeIdentityToken(e):this.clearIdentityToken()}async _authenticate(e){try{let t=await e.authenticate(),{user:n,is_new_user:r,oauth_tokens:a}=t;this.handleTokenResponse(t);let i=a?{provider:a.provider,accessToken:a.access_token,accessTokenExpiresInSeconds:a.access_token_expires_in_seconds,refreshToken:a.refresh_token,refreshTokenExpiresInSeconds:a.refresh_token_expires_in_seconds,scopes:a.scopes}:void 0;return this._trackAuthenticateEvents(e,r),{user:F(n),isNewUser:r,oAuthTokens:i}}catch(e){throw console.warn(\"Error authenticating session\"),Oe(e)}}_trackAuthenticateEvents(e,t){let n=function(e){return e instanceof Yr?\"email\":e instanceof wa?\"sms\":e instanceof ha?\"siwe\":e instanceof vs?\"guest\":e instanceof Bi?\"custom_auth\":e instanceof oa?e.meta.provider:null}(e);n&&this.client&&this.client.createAnalyticsEvent({eventName:\"sdk_authenticate\",payload:{method:n,isNewUser:t}}),\"siwe\"===n&&this.client&&this.client.createAnalyticsEvent({eventName:\"sdk_authenticate_siwe\",payload:{connectorType:e.meta.connectorType,walletClientType:e.meta.walletClientType}})}async _link(e){try{let t=await e.link(),n=t.oauth_tokens,r=n?{provider:n.provider,accessToken:n.access_token,accessTokenExpiresInSeconds:n.access_token_expires_in_seconds,refreshToken:n.refresh_token,refreshTokenExpiresInSeconds:n.refresh_token_expires_in_seconds,scopes:n.scopes}:void 0;return{user:F(t),oAuthTokens:r}}catch(e){throw console.warn(\"Error linking account\"),Oe(e)}}async _refresh(){if(!this.api)throw new Ce(\"Session has no API instance\");if(!this.client)throw new Ce(\"Session has no PrivyClient instance\");await this.client.getAccessToken({disableAutoRefresh:!0});let e=this.token,t=this.refreshToken;if(this.client.useServerCookies&&!this.mightHaveServerCookies&&this.token&&window.location.origin===this.client.apiUrl)return this.destroyLocalState(),null;try{let n;if(!(e&&t||this.mightHaveServerCookies))return null;{let r={};e&&(r.authorization=`Bearer ${e}`),n=await this.api.post(Xt,t?{refresh_token:t}:{},{headers:r})}return this.handleTokenResponse(n),F(n.user)}catch(e){if(e instanceof Pe&&e.privyErrorCode===_e.MISSING_OR_INVALID_TOKEN)return console.warn(\"Unable to refresh tokens - token is missing or no longer valid\"),this.destroyLocalState(),null;throw Oe(e)}}handleTokenResponse(e){e.session_update_action&&\"set\"!==e.session_update_action?\"clear\"===e.session_update_action?this.destroyLocalState():\"ignore\"===e.session_update_action&&(e.token&&(this.storeCustomerAccessToken(e.token),this.storePrivyAccessToken(e.privy_access_token)),e.identity_token&&this.storeIdentityToken(e.identity_token)):this._storeAllTokens(e)}_storeAllTokens(e){this.storeRefreshToken(e.refresh_token),this.storeCustomerAccessToken(e.token),this.storePrivyAccessToken(e.privy_access_token),e.identity_token&&this.storeIdentityToken(e.identity_token)}async _destroy(){try{await(this.api?.post(en,{refresh_token:this.refreshToken}))}catch(e){console.warn(\"Error destroying session\")}this.destroyLocalState()}destroyLocalState(){this.storeRefreshToken(null),this.storeCustomerAccessToken(null),this.storePrivyAccessToken(null),this.clearIdentityToken()}storeCustomerAccessToken(e){if(\"string\"==typeof e){let t=Me.get(Ge);if(Me.put(Ge,e),!this.client?.useServerCookies){let t=Rr.parse(e)?.expiration;Ar.set(dt,e,{sameSite:\"Strict\",secure:As(),expires:t?new Date(1e3*t):void 0})}t!==e&&this.client?.onStoreCustomerAccessToken?.(e)}else Me.del(Ge),Ar.remove(dt),this.client?.onDeleteCustomerAccessToken?.()}storeRefreshToken(e){\"string\"==typeof e?(Me.put(st,e),this.client?.useServerCookies||Ar.set(lt,\"t\",{sameSite:\"Strict\",secure:As(),expires:30})):(Me.del(st),Ar.remove(ut),Ar.remove(lt))}storePrivyAccessToken(e){\"string\"==typeof e?Me.put($e,e):Me.del($e)}storeIdentityToken(e){if(ws.setState({identityToken:e}),this.client?.useServerCookies)return;Me.put(ht,e);let t=Rr.parse(e)?.expiration;Ar.set(pt,e,{sameSite:\"Strict\",secure:As(),expires:t?new Date(1e3*t):void 0})}clearIdentityToken(){Me.del(ht),ws.setState({identityToken:null}),Ar.remove(pt)}constructor(){this.authenticateOnce=new Qr((async e=>this._authenticate(e))),this.linkOnce=new Qr((async e=>this._link(e))),this.refreshOnce=new Qr(this._refresh.bind(this)),this.destroyOnce=new Qr(this._destroy.bind(this))}}let _s,bs;var Ss=0,Es=\"__private_\"+Ss+++\"__getOrGenerateClientAnalyticsId\";class Is{getAppId(){return this.appId}initializeConnectorManager({walletConnectCloudProjectId:e,rpcConfig:t,chains:n,defaultChain:r,store:a,walletList:i,shouldEnforceDefaultChainOnConnect:s,externalWalletConfig:o,appName:l,walletChainType:c,setBaseAccountSdk:d}){this.connectors||(this.connectors=new ps(this.appId,e,t,n,r,a,i,s,o,l,d,c))}generateApi(){let e=new gs({appId:this.appId,appClientId:this.appClientId,client:this,defaults:{baseURL:this.apiUrl,timeout:this.timeout}});return this.session.api=e,e}updateApiUrl(e){this.apiUrl=e||this.fallbackApiUrl,this.api=this.generateApi(),e&&(this.useServerCookies=!0)}authenticate(){if(!this.authFlow)throw new Ce(\"No auth flow in progress.\");return this.session.authenticate(this.authFlow)}async link(){if(!this.authFlow)throw new Ce(\"No auth flow in progress.\");let{oAuthTokens:e}=await this.session.link(this.authFlow);return{user:await this.getAuthenticatedUser(),oAuthTokens:e}}storeProviderAccessToken(e,t){this.session.storeProviderAccessToken(e,t)}getProviderAccessToken(e){return this.session.getProviderAccessToken(e)}async logout(){await this.session.destroy(),this.authFlow=void 0}clearProviderAcccessTokens(e){e.linkedAccounts.filter((e=>\"cross_app\"===e.type)).forEach((e=>{this.storeProviderAccessToken(e.providerApp.id,null)}))}startAuthFlow(e){return e.api=this.api,this.authFlow=e,this.authFlow}async initMfaSmsVerification(){try{await this.api.post(rn,{action:\"verify\"})}catch(e){throw Te(e)}}async initMfaPasskeyVerification(){try{let e=await this.api.post(an,{});return fs(e.options)}catch(e){throw Te(e)}}async getCrossAppProviderDetails(e){try{return this._cachedProviderAppDetails[e]||(this._cachedProviderAppDetails[e]=await this.api.get(`/api/v1/apps/${e}/cross-app/details`)),this._cachedProviderAppDetails[e]}catch(e){console.error(\"Error fetching cross app provider details\",e)}}async acceptTerms(){try{let e=await this.api.post(sn,{});return F(e)}catch(e){throw Oe(e)}}async unlinkEmail(e){try{let t=await this.api.post(on,{address:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async unlinkPhone(e){try{let t=await this.api.post(ln,{phoneNumber:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async unlinkEthereumWallet(e){try{let t=await this.api.post(cn,{address:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async unlinkSolanaWallet(e){try{let t=await this.api.post(dn,{address:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async unlinkOAuth(e,t){try{let n=await this.api.post(un,{provider:e,subject:t});return await this.getAuthenticatedUser()??F(n)}catch(e){throw Oe(e)}}async unlinkFarcaster(e){try{let t=await this.api.post(hn,{fid:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async unlinkTelegram(e){try{let t=await this.api.post(pn,{telegram_user_id:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async revokeDelegatedWallet(){try{await this.api.post(wn,{})}catch(e){throw Oe(e)}}async createAnalyticsEvent({eventName:e,payload:t,timestamp:n,options:r}){if(\"undefined\"!=typeof window)try{this.clientAnalyticsId||console.warn(\"No client analytics id set, refusing to send analytics event\"),await this.api.post(tn,{event_name:e,client_id:this.clientAnalyticsId,payload:{...t||{},clientTimestamp:n?n.toISOString():(new Date).toISOString()}},{retry:-1,keepalive:r?.keepAlive??!1})}catch(e){console.log(\"Unable to submit event. This is not an issue.\")}}async signMoonpayOnRampUrl(e){try{return this.api.post(mn,e)}catch(e){throw Oe(e)}}async initCoinbaseOnRamp(e){try{return this.api.post(yn,e)}catch(e){throw Oe(e)}}async getCoinbaseOnRampStatus({partnerUserId:e}){try{return this.api.get(`${gn}?partnerUserId=${e}`)}catch(e){throw Oe(e)}}async getAuthenticatedUser(){return this.session.hasRefreshCredentials()?this.session.refresh():null}async getAccessToken(e){return await this.getPrivyAccessToken(e)||await this.getCustomerAccessToken(e)}async getCustomerAccessToken(e){return await this._getToken(Cs.CUSTOMER,e)}async getPrivyAccessToken(e){return await this._getToken(Cs.PRIVY,e)}async _getToken(e,t){return this.session.getToken(e)?this.session.hasActiveAccessToken(e)?this.session.hasRefreshCredentials(e)?Mr.parse(this.session.getToken(e))?.appId!==this.appId?(await this.logout(),null):this.session.getToken(e):(this.session.destroyLocalState(),null):!t?.disableAutoRefresh&&this.session.hasRefreshCredentials(e)?(await this.session.refresh(),this.session.getToken(e)):null:null}async getUsdTokenPrice(e){try{return(await this.api.get(`/api/v1/token_price?chainId=${e.id}&tokenSymbol=${e.nativeCurrency.symbol}`)).usd}catch(t){return void console.error(`Unable to fetch token price for chain with id ${e.id}`)}}async getUsdPriceForSol(){try{return(await this.api.get(\"/api/v1/token_price?chainId=0&tokenSymbol=SOL\")).usd}catch(e){return void console.error(\"Unable to fetch token price for SOL\")}}async getSplTokenMetadata({mintAddress:e,cluster:t}){try{return await this.api.get(`/api/v1/spl_token_info?mint_address=${e}&cluster=${t}`)}catch(n){return void console.error(`Unable to fetch token metadata for ${t}:${e}`)}}async requestFarcasterSignerStatus(e){try{return await this.api.post(\"/api/v1/farcaster/signer/status\",{ed25519_public_key:e})}catch(e){throw console.error(\"Unable to fetch Farcaster signer status\"),e}}async generateSiweNonce({address:e,captchaToken:t}){try{return(await this.api.post(fn,{address:e,token:t})).nonce}catch(e){throw Oe(e)}}async authenticateWithSiweInternal({message:e,signature:t,chainId:n,walletClientType:r,connectorType:a,mode:i}){return await this.api.post(vn,{message:e,signature:t,chainId:n,walletClientType:r,connectorType:a,mode:i})}async linkWithSiweInternal({message:e,signature:t,chainId:n,walletClientType:r,connectorType:a}){return await this.api.post(An,{message:e,signature:t,chainId:n,walletClientType:r,connectorType:a})}async linkSmartWallet({message:e,signature:t,smartWalletType:n,smartWalletVersion:r}){try{let a=await this.api.post(kn,{message:e,signature:t,smart_wallet_type:n,smart_wallet_version:r});return F(a)}catch(e){throw Oe(e)}}async linkWithSiwe({message:e,signature:t,chainId:n,walletClientType:r,connectorType:a}){try{let i=await this.linkWithSiweInternal({message:e,signature:t,chainId:n,walletClientType:r,connectorType:a});return F(i)}catch(e){throw Oe(e)}}async generateSiwsNonce({address:e,captchaToken:t}){try{return(await this.api.post(Cn,{address:e,token:t})).nonce}catch(e){throw Oe(e)}}async authenticateWithSiwsInternal({message:e,signature:t,walletClientType:n,connectorType:r,mode:a,messageType:i=\"plain\"}){return await this.api.post(Tn,{message:e,signature:t,walletClientType:n,connectorType:r,mode:a,message_type:i})}async authenticateWithSiws({message:e,signature:t,walletClientType:n,connectorType:r,mode:a,messageType:i=\"plain\"}){let s=await this.authenticateWithSiwsInternal({message:e,signature:t,walletClientType:n,connectorType:r,mode:a,messageType:i});this.session.handleTokenResponse(s);let o=F(s.user);if(!o)throw Error(\"Authentication failed - no user returned\");return{user:o,isNewUser:s.is_new_user||!1}}async sendAccountTransferRequest({nonce:e,account:t,accountType:n,externalWalletMetadata:r,telegramAuthResult:a,telegramWebAppData:i,farcasterEmbeddedAddress:s,oAuthUserInfo:o}){try{let l,c;switch(n){case\"email\":l=Wn,c={nonce:e,email:t};break;case\"sms\":l=Pn,c={nonce:e,phoneNumber:t};break;case\"siwe\":if(l=In,!r)throw Error(\"Wallet parameters must be defined\");c={nonce:e,address:t,...r};break;case\"farcaster\":l=En,c={nonce:e,farcaster_id:t,farcaster_embedded_address:s};break;case\"telegram\":l=Sn,c={nonce:e,telegram_auth_result:a,telegram_web_app_data:i};break;case\"siws\":l=bn,c={nonce:e,address:t,...r};break;case\"custom\":case\"guest\":case\"passkey\":throw Error(\"Invalid transfer account type\");default:l=_n,c={nonce:e,userInfo:o}}let d=await this.api.post(l,c);return await this.getAuthenticatedUser()??F(d)}catch(e){throw Oe(e)}}async linkWithSiwsInternal({message:e,signature:t,walletClientType:n,connectorType:r,messageType:a=\"plain\"}){return await this.api.post(Un,{message:e,signature:t,walletClientType:n,connectorType:r,message_type:a})}async linkWithSiws({message:e,signature:t,walletClientType:n,connectorType:r,messageType:a=\"plain\"}){try{let i=await this.linkWithSiwsInternal({message:e,signature:t,walletClientType:n,connectorType:r,messageType:a});return F(i)}catch(e){throw Oe(e)}}async updateUserAndIdToken(){try{let e=await this.api.get(Nn);return this.session.updateIdentityToken(e.identity_token),F(e.user)}catch(e){throw Oe(e)}}async scanTransaction(e){try{return await this.api.post(On,e)}catch(e){throw Oe(e)}}constructor({apiUrl:e=nt,appId:t,appClientId:n,timeout:r=wt}){Object.defineProperty(this,Es,{value:Ps}),this._cachedProviderAppDetails={},this.apiUrl=e,this.fallbackApiUrl=this.apiUrl,this.useServerCookies=e!==nt&&e.startsWith(\"https://privy.\"),this.timeout=r,this.appId=t,this.appClientId=n,this.clientAnalyticsId=function(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError(\"attempted to use private field on non-instance\");return e}(this,Es)[Es](),_s||(_s=new Ts),this.session=_s,this.api=this.generateApi(),this.session.client=this}}function Ps(){if(\"undefined\"==typeof window)return null;try{let e=Me.get(rt);if(\"string\"==typeof e&&e.length>0)return e}catch(e){}let e=A();try{return Me.put(rt,e),e}catch(t){return e}}function Ws(){if(!bs)throw new Ce(\"No global PrivyClient instance found. Please ensure you have initialized the PrivyProvider.\");return bs}async function Us(){return await(bs?.updateUserAndIdToken()),bs?.useServerCookies?ws.getState().identityToken:Promise.resolve(Me.get(ht)||null)}const Ns=({config:e,...n})=>{(()=>{if(a(Yi))throw new Ce(\"Multiple PrivyProvider instances found\",\"Found multiple instances of PrivyProvider, ensure there is only one mounted in your application tree.\")})(),function(){if(\"undefined\"==typeof window)return;let e=[\"localhost\",\"127.0.0.1\"].includes(window.location.hostname),t=\"https:\"===window.location.protocol||\"chrome-extension:\"===window.location.protocol;if(!e&&!t)throw new Ce(\"Embedded wallet is only available over HTTPS\")}(),function(e){if(\"string\"!=typeof e||25!==e.length)throw new Ce(\"Cannot initialize the Privy provider with an invalid Privy app ID\")}(n.appId),function(e){bs||(bs=new Is({appId:e.appId,appClientId:e.clientId,apiUrl:e.apiUrl}))}(n);let r=l((()=>new p({appId:n.appId,clientId:n.clientId,storage:Me,baseUrl:n.apiUrl,sdkVersion:\"react-auth:3.10.0\"})),[]),i=Ws(),s=Object.assign({},e);/*#__PURE__*/return t(mt,{client:r,legacyClient:i,appClientId:n.clientId,clientConfig:s,children:/*#__PURE__*/t(Bn,{children:/*#__PURE__*/t(ts,{...n,client:i,privy:r})})})},Os=()=>{let{user:e}=T(),{walletProxy:t}=Ie();return{recover:h((async n=>{if(!t)throw Error(\"Wallet proxy is not ready\");let r=await Kr();if(!e||!r)throw new Ce(\"User must be logged in before attempting to modify the recovery method.\");let{entropyId:a,entropyIdVerifier:i}=ve(e);try{await t.recover({entropyId:a,entropyIdVerifier:i,accessToken:r,...n})}catch{throw new Ce(\"Unable to recover wallets\")}}),[t,e])}};function Rs(){let{promptMfa:e,init:t,submit:n,cancel:r,mfaMethods:i}=a(R);return{promptMfa:e,init:t,submit:n,cancel:r,mfaMethods:i}}function Ms(){let{initEnrollmentWithSms:e,initEnrollmentWithTotp:t,initEnrollmentWithPasskey:n,submitEnrollmentWithSms:r,submitEnrollmentWithTotp:i,submitEnrollmentWithPasskey:s,unenroll:o,enrollInMfa:l}=a(R);return{initEnrollmentWithSms:e,initEnrollmentWithTotp:t,initEnrollmentWithPasskey:n,submitEnrollmentWithSms:r,submitEnrollmentWithTotp:i,submitEnrollmentWithPasskey:s,unenrollWithSms:()=>o(\"sms\"),unenrollWithTotp:()=>o(\"totp\"),unenrollWithPasskey:e=>o(\"passkey\",e),showMfaEnrollmentModal:()=>l(!0),closeMfaEnrollmentModal:()=>l(!1)}}function xs(){let e=Ws();return e?e.getCustomerAccessToken():Promise.resolve(Me.get(Ge)||null)}const Fs=()=>{let{client:e,setAuthenticated:t,setUser:n}=Ie();return l((()=>({init:async()=>{if(!e)throw new Ce(\"Must initialize Privy client first.\");let t=new kr;return e.startAuthFlow(t),await t.init()},login:async({fid:r,message:a,signature:i})=>{if(!e)throw new Ce(\"Must initialize Privy client first.\");if(!(e.authFlow instanceof kr))throw new Ce(\"Must initialize Farcaster Mini App flow first.\");e.authFlow.setAuthData({message:a,signature:i,fid:r});let{user:s}=await e.authenticate();if(!s)throw new Ce(\"Failed to login with Farcaster V2\");return n(s),t(!0),{user:s}}})),[e,n,t])},Ls=()=>l((()=>({getAccessTokenForProvider:({appId:e})=>{try{let t=Me.get(ot(e));if(\"string\"!=typeof t)return{token:null};{let n=new Rr(t);return n.isExpired()?(Me.del(ot(e)),{token:null}):{token:n.value}}}catch(e){return console.error(e),{token:null}}}})),[]),Ds=e=>{Qn(\"login\",e);let t=va(),n=tt(),{ready:r,user:a}=T(),{initLoginWithHeadlessOAuth:i,loginWithHeadlessOAuth:s,oAuthState:o,setOAuthState:l,isHeadlessOAuthLoading:d}=Ie(),u=h((async e=>{try{if(t.enabled&&\"success\"!==t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);return await i(e.provider,t.token,e.disableSignup)}catch(e){throw l({status:\"error\",error:e}),e}}),[i,t]),p=h((async()=>{let e=la();try{if(!e.inProgress)throw Error(\"Cannot login with OAuth because no OAuth flow is in progress\");let t=e.provider;if(S(t)){if(a&&a.linkedAccounts.some((e=>e.type===t)))return console.warn(\"User is already logged in with this OAuth provider\"),a}else if(a&&t in a&&a[t])return console.warn(\"User is already logged in with this OAuth provider\"),a;if(e.popupFlow)return}catch(e){throw l({status:\"error\",error:e}),e}try{return await s(e)}catch(e){throw l({status:\"error\",error:e}),e}finally{ca()}}),[s]);return c((()=>{let e=la();r&&n&&e.inProgress&&!e.withPrivyUi&&!e.popupFlow&&p().catch((()=>{}))}),[r,n]),{initOAuth:u,loading:d,state:o}},js=e=>{let t=va(),{emailOtpState:n,setEmailOtpState:r,initLoginWithEmail:a,loginWithCode:i}=Ie();return{sendCode:h((async({email:n,disableSignup:i})=>{try{let e;if(!n)throw Error(\"Email required to send OTP code\");if(t.enabled&&\"error\"===t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);return t.enabled&&\"success\"!==t.status&&(t.execute(),e=await t.waitForResult()),await a({email:n,captchaToken:e,disableSignup:i,withPrivyUi:!1})}catch(n){throw r({status:\"error\",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[a]),loginWithCode:h((async({code:n})=>{try{if(t.enabled&&\"error\"===t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);let{user:r,isNewUser:a,wasAlreadyAuthenticated:s,linkedAccount:o}=await i(n);e?.onComplete?.({user:r,isNewUser:a,wasAlreadyAuthenticated:s,loginMethod:\"email\",loginAccount:o})}catch(n){throw r({status:\"error\",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[i,t.status]),state:n}},zs=e=>{let t=va(),{initSignupWithPasskey:n,signupWithPasskey:r,passkeyAuthState:a,setPasskeyAuthState:i}=Ie();return{signupWithPasskey:h((async()=>{try{let a;if(t.enabled&&\"error\"===t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);t.enabled&&\"success\"!==t.status&&(t.execute(),a=await t.waitForResult()),await n({captchaToken:a,withPrivyUi:!1});let{user:i,isNewUser:s,wasAlreadyAuthenticated:o,loginAccount:l}=await r();e?.onComplete?.({user:i,isNewUser:s,wasAlreadyAuthenticated:o,loginMethod:\"passkey\",loginAccount:l})}catch(t){throw i({status:\"error\",error:t}),e?.onError?.(t.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),t}}),[r,t.status]),state:a}},qs=e=>{let t=va(),{initLoginWithPasskey:n,loginWithPasskey:r,passkeyAuthState:a,setPasskeyAuthState:i}=Ie();return{loginWithPasskey:h((async a=>{try{let i;if(t.enabled&&\"error\"===t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);t.enabled&&\"success\"!==t.status&&(t.execute(),i=await t.waitForResult()),await n({captchaToken:i,withPrivyUi:!1});let{user:s,isNewUser:o,wasAlreadyAuthenticated:l,loginAccount:c}=await r(a);e?.onComplete?.({user:s,isNewUser:o,wasAlreadyAuthenticated:l,loginMethod:\"passkey\",loginAccount:c})}catch(a){throw i({status:\"error\",error:a}),e?.onError?.(a.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),a}}),[r,t.status]),state:a}},Hs=e=>{let{initLinkWithPasskey:t,linkWithPasskey:n,passkeyAuthState:r,setPasskeyAuthState:a}=Ie();return{linkWithPasskey:h((async()=>{try{await t();let r=await n();if(!r)throw Error(\"Error, user not found\");let a=r.linkedAccounts.filter((e=>\"passkey\"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0];e?.onSuccess?.({user:r,linkMethod:\"passkey\",linkedAccount:a})}catch(t){throw a({status:\"error\",error:t}),e?.onError?.(t.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:\"passkey\"}),t}}),[n]),state:r}},Vs=e=>{let t=va(),{smsOtpState:n,setSmsOtpState:r,initLoginWithSms:a,loginWithCode:i}=Ie();return{sendCode:h((async({phoneNumber:n,disableSignup:i})=>{try{let e;if(!n)throw Error(\"SMS required to send OTP code\");if(t.enabled&&\"error\"===t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);return t.enabled&&\"success\"!==t.status&&(t.execute(),e=await t.waitForResult()),await a({phoneNumber:n,captchaToken:e,disableSignup:i,withPrivyUi:!1})}catch(n){throw r({status:\"error\",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[a]),loginWithCode:h((async({code:n})=>{try{if(t.enabled&&\"error\"===t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);let{user:r,isNewUser:a,wasAlreadyAuthenticated:s,linkedAccount:o}=await i(n);e?.onComplete?.({user:r,isNewUser:a,wasAlreadyAuthenticated:s,loginMethod:\"sms\",loginAccount:o})}catch(n){throw r({status:\"error\",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[i,t.status]),state:n}},Bs=e=>{let{connectOrCreateWallet:t}=T();return Qn(\"connectOrCreateWallet\",e),{connectOrCreateWallet:t}},Ks=e=>{let t=va(),{siweState:n,setSiweState:r,linkWithSiwe:a,generateSiweMessage:i}=Ie();return{generateSiweMessage:h((async({address:t,chainId:n})=>{try{if(!t||!n)throw Error(\"wallet address and chainId required to generate nonce\");return await i({address:t,chainId:n}).then((e=>e))}catch(t){throw r({status:\"error\",error:t}),e?.onError?.(t.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:\"siwe\"}),t}}),[i]),linkWithSiwe:h((async({signature:n,message:i,chainId:s,walletClientType:o,connectorType:l})=>{try{if(t.enabled&&\"success\"!==t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);let{user:r,linkedAccount:c}=await a({message:i,signature:n,chainId:s,walletClientType:o,connectorType:l});c&&e?.onSuccess?.({user:r,linkMethod:\"siwe\",linkedAccount:c})}catch(n){throw r({status:\"error\",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:\"siwe\"}),n}}),[a,t.status]),state:n}},$s=e=>{let t=va(),{siweState:n,setSiweState:r,client:a,generateSiweMessage:i,loginWithSiwe:s}=Ie();return{generateSiweNonce:h((async n=>{try{let e;if(t.enabled&&\"error\"===t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);t.enabled&&\"success\"!==t.status&&(t.execute(),e=await t.waitForResult()),r({status:\"generating-message\"});let i=await a.generateSiweNonce({address:n?.address,captchaToken:e});return r({status:\"awaiting-signature\"}),i}catch(n){throw r({status:\"error\",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[a,t]),generateSiweMessage:h((async({address:n,chainId:a})=>{try{let e;if(t.enabled&&\"error\"===t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);return t.enabled&&\"success\"!==t.status&&(t.execute(),e=await t.waitForResult()),await i({address:n,chainId:a,captchaToken:e})}catch(n){throw r({status:\"error\",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[i,t]),loginWithSiwe:h((async({message:n,signature:a,disableSignup:i,walletClientType:o,connectorType:l})=>{try{let r;if(t.enabled&&\"error\"===t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);t.enabled&&\"success\"!==t.status&&(t.execute(),r=await t.waitForResult());let{user:c,isNewUser:d}=await s({message:n,signature:a,captchaToken:r,disableSignup:i,walletClientType:o,connectorType:l});return e?.onComplete?.({user:c,isNewUser:d,wasAlreadyAuthenticated:!1,loginMethod:\"siwe\",loginAccount:null}),c}catch(n){throw r({status:\"error\",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[s,t.status]),state:n}},Gs=()=>{let e=va(),{client:t,setAuthenticated:n,setUser:r,setIsNewUser:a}=Ie(),{authenticated:i}=zn();return{generateSiwsMessage:h((async({address:n})=>{let r;if(e.enabled&&\"error\"===e.status)throw new ga(e.error,null,_e.CAPTCHA_FAILURE);e.enabled&&\"success\"!==e.status&&(e.execute(),r=await e.waitForResult());let a=await t.generateSiwsNonce({address:n,captchaToken:r});return Mn({address:n,nonce:a})}),[e,t]),loginWithSiws:h((async({message:s,signature:o,disableSignup:l,walletClientType:c,connectorType:d})=>{if(i)throw Error(\"User already authenticated\");if(e.enabled&&\"error\"===e.status)throw new ga(e.error,null,_e.CAPTCHA_FAILURE);e.enabled&&\"success\"!==e.status&&(e.execute(),await e.waitForResult());let{user:u,isNewUser:h}=await t.authenticateWithSiws({message:s,signature:o,walletClientType:c,connectorType:d,mode:l?\"no-signup\":\"login-or-sign-up\",messageType:\"plain\"});if(!u)throw Error(\"Authentication failed - no user returned\");return r(u),a(h||!1),n(!0),u}),[i,e,t,n,r,a])}},Ys=()=>{let e=va(),{client:t,setUser:n,refreshSessionAndUser:r}=Ie(),{authenticated:a}=zn();return{generateSiwsMessage:h((async({address:n})=>{let r;if(e.enabled&&\"error\"===e.status)throw new ga(e.error,null,_e.CAPTCHA_FAILURE);e.enabled&&\"success\"!==e.status&&(e.execute(),r=await e.waitForResult());let a=await t.generateSiwsNonce({address:n,captchaToken:r});return Mn({address:n,nonce:a})}),[e,t]),linkWithSiws:h((async({signature:i,message:s,walletClientType:o,connectorType:l})=>{if(!a)throw Error(\"User must be authenticated before linking\");if(e.enabled&&\"error\"===e.status)throw new ga(e.error,null,_e.CAPTCHA_FAILURE);let c=await t.linkWithSiws({message:s,signature:i,walletClientType:o,connectorType:l,messageType:\"plain\"}),d=(e=>{if(!e)return;let t=e.linkedAccounts;return t&&0!==t.length?t[t.length-1]:void 0})(c=await r()??c)||null;return n(c||null),{user:c,linkedAccount:d}}),[a,e,t,r,n])}};function Js(){let{signTransaction:e}=a(R);return{signTransaction:e}}function Qs(e){let{linkEmail:t,linkPhone:n,linkWallet:r,linkGoogle:i,linkApple:s,linkTwitter:o,linkTwitch:l,linkDiscord:c,linkGithub:d,linkLinkedIn:u,linkTiktok:h,linkLine:p,linkSpotify:w,linkInstagram:m,linkTelegram:y,linkFarcaster:g,linkPasskey:f}=a(R);return Qn(\"linkAccount\",e),{linkEmail:t,linkPhone:n,linkWallet:r,linkGoogle:i,linkApple:s,linkTwitter:o,linkTwitch:l,linkDiscord:c,linkGithub:d,linkLinkedIn:u,linkTiktok:h,linkLine:p,linkSpotify:w,linkInstagram:m,linkFarcaster:g,linkTelegram:y,linkPasskey:f}}function Zs(e){let{updateEmail:t,updatePhone:n}=a(R);return Qn(\"update\",e),{updateEmail:t,updatePhone:n}}const Xs=e=>{let{user:t}=T(),{loginWithCode:n,emailOtpState:r,setEmailOtpState:a,client:i,inProgressAuthFlowRef:s,inProgressLoginOrLinkMethodRef:o}=Ie();return{state:r,sendCode:h((async({newEmailAddress:n})=>{try{if(!t?.email)throw Error(\"User is required to have an email address to update it.\");let e=new Jr(t.email.address,n);i.startAuthFlow(e),await e.sendCodeEmail({withPrivyUi:!1})}catch(n){a({status:\"error\",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:\"email\"})}}),[t?.email]),verifyCode:h((async({code:r})=>{try{if(!t?.email)throw Error(\"User is required to have an email address to update it.\");s.current=\"update\",o.current=\"email\";let{user:a,linkedAccount:i}=await n(r);return e?.onSuccess?.({user:a,updateMethod:\"email\",updatedAccount:i}),{user:a}}catch(r){a({status:\"error\",error:r}),e?.onError?.(r.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:\"email\"})}}),[t?.email])}},eo=()=>{let{connectCoinbaseSmartWallet:e}=Ie();return{connectCoinbaseSmartWallet:e}},to=()=>{let{connectBaseAccount:e}=Ie();return{connectBaseAccount:e}},no=()=>{let{baseAccountSdk:e}=Ie();return{baseAccountSdk:e}},ro=()=>{let{setModalData:e}=_(),{openModal:t,privy:n,closePrivyModal:r}=Ie(),{user:a}=T();return l((()=>({verify:async({standalone:i=!0}={standalone:!0})=>new Promise(((s,o)=>a?0===a.mfaMethods.length?s():(e((e=>({...e,mfaVerify:{onSuccess:async()=>{i?await r({shouldCallAuthOnSuccess:!1,isSuccess:!0}):Pa.setState({inProgressMfaFlow:void 0}),s()},onFailure:async e=>{i?await r({shouldCallAuthOnSuccess:!1,isSuccess:!1}):Pa.setState({inProgressMfaFlow:void 0}),o(e)},sendSmsCode:async()=>{throw Error(\"Not enabled\")},verifySmsCode:async()=>{throw Error(\"Not enabled\")},verifyTotpCode:async e=>{await n.fetchPrivyRoute(_r,{body:{code:e}})},generateOptions:async()=>fs((await n.fetchPrivyRoute(Tr,{body:{}})).options),verifyPasskey:async e=>{let t=await import(\"@simplewebauthn/browser\"),r=await t.startAuthentication({optionsJSON:e});await n.fetchPrivyRoute(Cr,{body:{authenticator_response:qi(r)}})}}}))),void(i?t(\"MfaAuthVerifyFlowScreen\"):Pa.setState({inProgressMfaFlow:\"auth\"}))):o(Error(\"Must be logged in to verify MFA\"))))})),[n,e,t,r])},ao=()=>{let e=Xe(),{setModalData:t}=_(),{verify:n}=ro(),{openModal:r,privy:a,closePrivyModal:i,refreshSessionAndUser:s,setUser:o}=Ie();return l((()=>({enroll:async l=>new Promise(((c,d)=>{t({mfaEnroll:{onSuccess:async e=>{await i({shouldCallAuthOnSuccess:!1,isSuccess:!0}),c(e)},onFailure:async e=>{await i({shouldCallAuthOnSuccess:!1,isSuccess:!1}),d(e)},onBack:l?.onBack?async()=>{await i({shouldCallAuthOnSuccess:!1,isSuccess:!1}),d(Error(\"User canceled MFA enrollment flow.\")),l.onBack?.()}:void 0,verify:()=>n({standalone:!1}),shouldUnlinkOnUnenrollMfa:!0,mfaMethods:e.mfa.methods,sendSmsCode:async()=>{throw Error(\"Not enabled\")},enrollSms:async()=>{throw Error(\"Not enabled\")},unenrollSms:async()=>{throw Error(\"Not enabled\")},generateTotpSecret:async()=>await a.fetchPrivyRoute(Ir,{body:{}}),enrollTotp:async e=>{await a.fetchPrivyRoute(Er,{body:{code:e}});let t=await s();return o(t),t},unenrollTotp:async()=>{await a.fetchPrivyRoute(Sr,{body:{}});let e=await s();return o(e),e},enrollPasskey:async e=>{await a.fetchPrivyRoute(br,{body:{credential_ids:e,remove_for_login:!0}});let t=await s();return o(t),t}}}),r(\"MfaAuthEnrollmentFlowScreen\")}))})),[a,t,r,i])},io=()=>{let{startCrossAppAuthFlow:e,unlinkCrossAppAccount:t,signMessageWithCrossAppWallet:n,signTypedDataWithCrossAppWallet:r,sendTransactionWithCrossAppWallet:a,signTransactionWithCrossAppWallet:i}=T();return{loginWithCrossAppAccount:({appId:t})=>e({appId:t,action:\"login\"}),linkCrossAppAccount:({appId:t})=>e({appId:t,action:\"link\"}),unlinkCrossAppAccount:t,signMessage:n,signTypedData:r,sendTransaction:a,signTransaction:i}};function so(e){let{sendTransaction:t}=a(R);return Qn(\"sendTransaction\",e),{sendTransaction:t}}function oo(){let e=Xe(),t=Zn(),{client:n,setUser:r,setAuthenticated:a,setIsNewUser:i,initializeWalletProxy:s}=Ie(),{create:o}=Kn();return{createGuestAccount:async()=>{if(!e.id||!n)throw Error(\"SDK not yet ready\");n.startAuthFlow(new vs(e.id));try{let l=await n.authenticate(),c=l.user,d=l.isNewUser??!1;if(!c)throw new Ce(\"Unable to authenticate guest account\");let u=await n.getAccessToken(),h=await s(yt);if(u&&h)try{let t=Mi(c,e.embeddedWallets.ethereum.createOnLogin),n=Fi(c,e.embeddedWallets.solana.createOnLogin);t&&n?(c=(await o({chainType:\"ethereum\",latestUser:c})).user,c=(await o({chainType:\"solana\",latestUser:c})).user):n?c=(await o({chainType:\"solana\",latestUser:c})).user:t?c=(await o({chainType:\"ethereum\",latestUser:c})).user:r(c)}catch(e){r(c),console.warn(\"Unable to create embedded wallet for guest account\")}return i(d),a(!0),t(\"login\",\"onComplete\",{user:c,isNewUser:d,wasAlreadyAuthenticated:!1,loginMethod:\"guest\",loginAccount:null}),c}catch(e){throw t(\"login\",\"onError\",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}}}}function lo(e){let{setWalletRecovery:t}=a(R);return Qn(\"setWalletRecovery\",e),{setWalletRecovery:t}}function co(e){let{signMessage:t}=a(R);return Qn(\"signMessage\",e),{signMessage:t}}const uo=()=>{let{ready:e,wallets:t}=ge(),{user:n}=T(),{rpcConfig:r,chains:a,appId:i}=Ie();return{signAuthorization:h((async(s,o)=>{let l;if(!n)throw Error(\"User must be authenticated before signing with a Privy wallet\");if(!e)throw Error(\"Wallets are not ready\");let c=o?.address??E(n)?.address??hr,d=t.find((e=>pr(e.address)===pr(c)));if(!d)throw Error(\"Signing wallet not found.\");let u=s.chainId??Number(d.chainId.split(\":\")[1]);if(0===u)l={chainId:0,address:s.contractAddress,nonce:s.nonce??0};else{let e=a.find((e=>e.id===u));if(!e)throw Error(\"Error, chain not configured in PrivyProvider config\");let t=wr({account:c,chain:e,transport:mr(fr(e,r,i))});l=await t.prepareAuthorization({...s})}let h=await d.getEthereumProvider(),p=await h.request({method:\"secp256k1_sign\",params:[St(l)]});return{...l,...yr(p)}}),[e,t,n,a])}};function ho(e){let{signTypedData:t}=a(R);return Qn(\"signTypedData\",e),{signTypedData:t}}const po=async({wallet:e})=>{let t=await e.getEthereumProvider();return Nr({address:e.address,sign:async({hash:n})=>{if(\"privy\"!==e.walletClientType)throw new y({error:\"Unprefixed signing is not supported by external wallets.\",code:\"unsupported_wallet_type\"});return await t.request({method:\"secp256k1_sign\",params:[n]})},signMessage:async({message:n})=>await t.request({method:\"personal_sign\",params:[n,e.address]}),signTypedData:async n=>await t.request({method:\"eth_signTypedData_v4\",params:[e.address,n]}),signTransaction:async e=>await t.request({method:\"eth_signTransaction\",params:[e]})})},wo=()=>{let{wallets:e}=ge();return l((()=>({wrapFetchWithPayment:({walletAddress:t,fetch:n,maxValue:r=BigInt(1e5),paymentRequirementsSelector:a=Pr,config:i})=>{let s=t||e[0]?.address;if(!s)throw new Ur(\"No wallet available for payment\");let o=e.find((e=>L(e.address,s)));if(!o)throw new Ur(`Wallet ${s} not found in connected wallets`);return async(e,t)=>{let s=await n(e,t);if(402!==s.status)return s;if(t?.__is402Retry)throw Error(\"Payment already attempted for this request\");let{x402Version:l,accepts:c}=await s.json(),d=a(c,void 0,\"exact\");if(BigInt(d.maxAmountRequired)>r)throw new Ur(\"Payment amount exceeds maximum allowed\");let u=await po({wallet:o}),h=await Wr(u,l,d,i),p={...t,headers:{...t?.headers||{},\"X-PAYMENT\":h,\"Access-Control-Expose-Headers\":\"X-PAYMENT-RESPONSE\"},__is402Retry:!0};return await n(e,p)}}})),[e])},mo=()=>{let{isModalOpen:e}=a(R);return{isOpen:e}};function yo(e){let{getAccessToken:t}=a(R);return Qn(\"accessToken\",e),{getAccessToken:t}}function go(e){let{authenticated:t,user:n}=T(),{initLoginWithOAuth:r}=Ie(),a=Zn();return Qn(\"oAuthAuthorization\",e),{reauthorize:e=>fo(t,n,r,a,e.provider)}}let fo=async(e,t,n,r,a)=>{if(!e)throw r(\"linkAccount\",\"onError\",_e.MUST_BE_AUTHENTICATED,{linkMethod:a}),new Ce(\"User must be authenticated before linking an account.\");if(!t?.linkedAccounts.some((e=>e.type.includes(a))))throw new Ce(`OAuth account of type ${a} not linked to the account.`);await n(a)};function vo(e){let{client:t}=Ie(),[n,r]=o({status:\"initial\"});return{linkWithCustomJwt:h((async n=>{try{r({status:\"initial\"}),t.startAuthFlow(new Bi(n)),r({status:\"loading\"});let{user:a}=await t.link();if(!a)throw Error(\"Error, user not found\");let i=a.linkedAccounts.filter((e=>\"custom_auth\"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime())).at(0);return r({status:\"done\"}),e?.onSuccess?.({user:a,linkMethod:\"custom\",linkedAccount:i}),{user:a}}catch(n){throw r({status:\"error\",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:\"custom\"}),n}}),[t.startAuthFlow,t.link]),state:n}}const Ao=e=>{let t=$i((e=>e.jwtAuthFlowState));return Qn(\"customAuth\",e),{status:t}};function ko({isAuthenticated:e,isLoading:t,...n}){let r=s();c((()=>{t||r.current?.()}),[e,t]);let a=h((e=>(r.current=e,()=>{r.current=void 0})),[]);return Ki({...n,subscribe:a})}function Co(){let{getFarcasterSignerPublicKey:e,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:n}=T();return{getFarcasterSignerPublicKey:e,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:n}}const To=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=Ie();return{delegateWallet:async({address:e,chainType:n})=>await t({address:e,chainType:n,showDelegationUIs:!0}),revokeWallets:async()=>await e({showDelegationUIs:!0})}},_o=()=>{let{user:e}=T(),t=Ie(),{signWithUserSigner:n}=Or(),r=async({wallet:r,additional_signers:a})=>{let i=await t.client.getAccessToken();if(!e||!i)throw new Ce(\"User must be authenticated and have an embedded wallet to delegate actions.\");if(!r.id)throw new Ce(\"Wallet to add signers to must have ID on server\");if(!t.walletProxy)throw new Ce(\"Wallet proxy not initialized.\");await f(t.privy,{wallet_id:r.id},n,{additional_signers:a})};return{addSessionSignersInternal:async({address:n,signers:a})=>{let i=await t.client.getAccessToken();if(!e||!i)throw new Ce(\"User must be authenticated and have an embedded wallet to add a session signer.\");let s=t.walletProxy??await t.initializeWalletProxy(15e3);if(!s)throw new Ce(\"Wallet proxy not initialized.\");let o=N(e,n);if(!o)throw new Ce(\"Address to add signers too is not associated with current user.\");if(P(o)){if(0===a.length)throw new Ce(\"Must specify at least one signer to add.\");let e=[...(await g(t.privy,{wallet_id:o.id})).additional_signers,...ye(a)];await r({wallet:o,additional_signers:e})}else{if(o.delegated)return{user:e};if(a.length>0)throw new Ce(\"Specifying signers in addSessionSigners is only supported for TEE execution and this app uses On-device execution. Pass an empty array for signers instead. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide\");let r=yi({address:n,user:e}),l=gi({address:n,user:e});await t.recoverEmbeddedWallet({address:n}),await s.createDelegatedAction({accessToken:i,rootWallet:l,delegatedWallets:[r]})}let l=await t.refreshSessionAndUser();if(!l)throw Error(\"Could not refresh user\");return{user:l}},removeSessionSignersInternal:async({address:n})=>{let a=await t.client.getAccessToken();if(!e||!a)throw new Ce(\"User must be authenticated and have an embedded wallet to delegate actions.\");if(!(t.walletProxy??await t.initializeWalletProxy(15e3)))throw new Ce(\"Wallet proxy not initialized.\");let i=N(e,n);if(!i)throw new Ce(\"Address to remove signers from is not associated with current user.\");P(i)?await r({wallet:i,additional_signers:[]}):await t.client.revokeDelegatedWallet();let s=await t.refreshSessionAndUser();if(!s)throw Error(\"Could not refresh user\");return{user:s}}}},bo=()=>{let{addSessionSignersInternal:e,removeSessionSignersInternal:t}=_o();return{addSessionSigners:async({address:t,signers:n})=>e({address:t,signers:n}),removeSessionSigners:async({address:e})=>t({address:e})}},So=()=>{let{addSessionSignersInternal:e,removeSessionSignersInternal:t}=_o();return{addSigners:async({address:t,signers:n})=>e({address:t,signers:n}),removeSigners:async({address:e})=>t({address:e})}},Eo=()=>{let{signWithUserSigner:e}=Or();return l((()=>({async generateAuthorizationSignature(t){let{targetAppId:n,...r}=t,{signature:a}=await v((async({message:t})=>e({message:t,targetAppId:n})),r);return{signature:a}}})),[e])},Io=()=>{let{setUser:e,client:t}=a(Ue),{user:n}=a(R);return{user:n,refreshUser:h((async()=>{let n=await(t?.updateUserAndIdToken());return e(n??null),n}),[t,e])}},Po=e=>{let t=va(),{initLoginWithTelegram:n,loginWithTelegram:r,telegramAuthState:a,setTelegramAuthState:i}=Ie();return{login:h((async a=>{try{if(t.enabled&&\"success\"!==t.status)throw new ga(t.error,null,_e.CAPTCHA_FAILURE);await n(t.token,a?.disableSignup);let{user:i,isNewUser:s,loginAccount:o,wasAlreadyAuthenticated:l}=await r({intent:\"login\"});e?.onComplete?.({user:i,isNewUser:s,wasAlreadyAuthenticated:l,loginMethod:\"telegram\",loginAccount:o})}catch(a){throw i({status:\"error\",error:a}),e?.onError?.(a.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),a}}),[n,r,t]),state:a}},Wo=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=Ie();return{delegateWallet:async({address:e,chainType:n})=>await t({address:e,chainType:n,showDelegationUIs:!1}),revokeWallets:async()=>await e({showDelegationUIs:!1})}},Uo=Va;export{Bs as $,Fr as A,is as B,ga as C,Lr as D,Ei as E,ss as F,xr as G,Ns as H,Sa as I,ps as J,Os as K,Is as L,Us as M,xs as N,Fs as O,Za as P,ms as Q,Qr as R,pa as S,Ls as T,Ds as U,js as V,Ja as W,zs as X,qs as Y,Hs as Z,Vs as _,va as a,Ks as a0,$s as a1,Gs as a2,Ys as a3,Js as a4,Ia as a5,Qs as a6,Zs as a7,Xs as a8,eo as a9,Wo as aA,Uo as aB,Va as aC,po as aD,ji as aE,to as aa,no as ab,ro as ac,ao as ad,io as ae,so as af,oo as ag,lo as ah,co as ai,uo as aj,ho as ak,wo as al,mo as am,yo as an,go as ao,vo as ap,Ao as aq,Ki as ar,ko as as,Co as at,To as au,bo as av,So as aw,Eo as ax,Io as ay,Po as az,ha as b,Ii as c,Ms as d,ei as e,ii as f,ri as g,ni as h,si as i,ai as j,Fi as k,ca as l,ka as m,ti as n,aa as o,Di as p,ia as q,sa as r,Mi as s,Ri as t,Rs as u,Si as v,Ni as w,Pi as x,Vr as y,Ui as z};\n","function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f);else for(t in e)e[t]&&(n&&(n+=\" \"),n+=t);return n}export function clsx(){for(var e,t,f=0,n=\"\";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;","var n,l,u,t,i,r,o,e,f,c,s,a,h,p={},v=[],y=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,w=Array.isArray;function d(n,l){for(var u in l)n[u]=l[u];return n}function g(n){n&&n.parentNode&&n.parentNode.removeChild(n)}function _(l,u,t){var i,r,o,e={};for(o in u)\"key\"==o?i=u[o]:\"ref\"==o?r=u[o]:e[o]=u[o];if(arguments.length>2&&(e.children=arguments.length>3?n.call(arguments,2):t),\"function\"==typeof l&&null!=l.defaultProps)for(o in l.defaultProps)void 0===e[o]&&(e[o]=l.defaultProps[o]);return m(l,e,i,r,null)}function m(n,t,i,r,o){var e={type:n,props:t,key:i,ref:r,__k:null,__:null,__b:0,__e:null,__c:null,constructor:void 0,__v:null==o?++u:o,__i:-1,__u:0};return null==o&&null!=l.vnode&&l.vnode(e),e}function b(){return{current:null}}function k(n){return n.children}function x(n,l){this.props=n,this.context=l}function S(n,l){if(null==l)return n.__?S(n.__,n.__i+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return\"function\"==typeof n.type?S(n):null}function C(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return C(n)}}function M(n){(!n.__d&&(n.__d=!0)&&i.push(n)&&!$.__r++||r!=l.debounceRendering)&&((r=l.debounceRendering)||o)($)}function $(){for(var n,u,t,r,o,f,c,s=1;i.length;)i.length>s&&i.sort(e),n=i.shift(),s=i.length,n.__d&&(t=void 0,r=void 0,o=(r=(u=n).__v).__e,f=[],c=[],u.__P&&((t=d({},r)).__v=r.__v+1,l.vnode&&l.vnode(t),O(u.__P,t,r,u.__n,u.__P.namespaceURI,32&r.__u?[o]:null,f,null==o?S(r):o,!!(32&r.__u),c),t.__v=r.__v,t.__.__k[t.__i]=t,N(f,t,c),r.__e=r.__=null,t.__e!=o&&C(t)));$.__r=0}function I(n,l,u,t,i,r,o,e,f,c,s){var a,h,y,w,d,g,_,m=t&&t.__k||v,b=l.length;for(f=P(u,l,m,f,b),a=0;a<b;a++)null!=(y=u.__k[a])&&(h=-1==y.__i?p:m[y.__i]||p,y.__i=a,g=O(n,y,h,i,r,o,e,f,c,s),w=y.__e,y.ref&&h.ref!=y.ref&&(h.ref&&B(h.ref,null,y),s.push(y.ref,y.__c||w,y)),null==d&&null!=w&&(d=w),(_=!!(4&y.__u))||h.__k===y.__k?f=A(y,f,n,_):\"function\"==typeof y.type&&void 0!==g?f=g:w&&(f=w.nextSibling),y.__u&=-7);return u.__e=d,f}function P(n,l,u,t,i){var r,o,e,f,c,s=u.length,a=s,h=0;for(n.__k=new Array(i),r=0;r<i;r++)null!=(o=l[r])&&\"boolean\"!=typeof o&&\"function\"!=typeof o?(\"string\"==typeof o||\"number\"==typeof o||\"bigint\"==typeof o||o.constructor==String?o=n.__k[r]=m(null,o,null,null,null):w(o)?o=n.__k[r]=m(k,{children:o},null,null,null):null==o.constructor&&o.__b>0?o=n.__k[r]=m(o.type,o.props,o.key,o.ref?o.ref:null,o.__v):n.__k[r]=o,f=r+h,o.__=n,o.__b=n.__b+1,e=null,-1!=(c=o.__i=L(o,u,f,a))&&(a--,(e=u[c])&&(e.__u|=2)),null==e||null==e.__v?(-1==c&&(i>s?h--:i<s&&h++),\"function\"!=typeof o.type&&(o.__u|=4)):c!=f&&(c==f-1?h--:c==f+1?h++:(c>f?h--:h++,o.__u|=4))):n.__k[r]=null;if(a)for(r=0;r<s;r++)null!=(e=u[r])&&0==(2&e.__u)&&(e.__e==t&&(t=S(e)),D(e,e));return t}function A(n,l,u,t){var i,r;if(\"function\"==typeof n.type){for(i=n.__k,r=0;i&&r<i.length;r++)i[r]&&(i[r].__=n,l=A(i[r],l,u,t));return l}n.__e!=l&&(t&&(l&&n.type&&!l.parentNode&&(l=S(n)),u.insertBefore(n.__e,l||null)),l=n.__e);do{l=l&&l.nextSibling}while(null!=l&&8==l.nodeType);return l}function H(n,l){return l=l||[],null==n||\"boolean\"==typeof n||(w(n)?n.some(function(n){H(n,l)}):l.push(n)),l}function L(n,l,u,t){var i,r,o,e=n.key,f=n.type,c=l[u],s=null!=c&&0==(2&c.__u);if(null===c&&null==e||s&&e==c.key&&f==c.type)return u;if(t>(s?1:0))for(i=u-1,r=u+1;i>=0||r<l.length;)if(null!=(c=l[o=i>=0?i--:r++])&&0==(2&c.__u)&&e==c.key&&f==c.type)return o;return-1}function T(n,l,u){\"-\"==l[0]?n.setProperty(l,null==u?\"\":u):n[l]=null==u?\"\":\"number\"!=typeof u||y.test(l)?u:u+\"px\"}function j(n,l,u,t,i){var r,o;n:if(\"style\"==l)if(\"string\"==typeof u)n.style.cssText=u;else{if(\"string\"==typeof t&&(n.style.cssText=t=\"\"),t)for(l in t)u&&l in u||T(n.style,l,\"\");if(u)for(l in u)t&&u[l]==t[l]||T(n.style,l,u[l])}else if(\"o\"==l[0]&&\"n\"==l[1])r=l!=(l=l.replace(f,\"$1\")),o=l.toLowerCase(),l=o in n||\"onFocusOut\"==l||\"onFocusIn\"==l?o.slice(2):l.slice(2),n.l||(n.l={}),n.l[l+r]=u,u?t?u.u=t.u:(u.u=c,n.addEventListener(l,r?a:s,r)):n.removeEventListener(l,r?a:s,r);else{if(\"http://www.w3.org/2000/svg\"==i)l=l.replace(/xlink(H|:h)/,\"h\").replace(/sName$/,\"s\");else if(\"width\"!=l&&\"height\"!=l&&\"href\"!=l&&\"list\"!=l&&\"form\"!=l&&\"tabIndex\"!=l&&\"download\"!=l&&\"rowSpan\"!=l&&\"colSpan\"!=l&&\"role\"!=l&&\"popover\"!=l&&l in n)try{n[l]=null==u?\"\":u;break n}catch(n){}\"function\"==typeof u||(null==u||!1===u&&\"-\"!=l[4]?n.removeAttribute(l):n.setAttribute(l,\"popover\"==l&&1==u?\"\":u))}}function F(n){return function(u){if(this.l){var t=this.l[u.type+n];if(null==u.t)u.t=c++;else if(u.t<t.u)return;return t(l.event?l.event(u):u)}}}function O(n,u,t,i,r,o,e,f,c,s){var a,h,p,v,y,_,m,b,S,C,M,$,P,A,H,L,T,j=u.type;if(null!=u.constructor)return null;128&t.__u&&(c=!!(32&t.__u),o=[f=u.__e=t.__e]),(a=l.__b)&&a(u);n:if(\"function\"==typeof j)try{if(b=u.props,S=\"prototype\"in j&&j.prototype.render,C=(a=j.contextType)&&i[a.__c],M=a?C?C.props.value:a.__:i,t.__c?m=(h=u.__c=t.__c).__=h.__E:(S?u.__c=h=new j(b,M):(u.__c=h=new x(b,M),h.constructor=j,h.render=E),C&&C.sub(h),h.state||(h.state={}),h.__n=i,p=h.__d=!0,h.__h=[],h._sb=[]),S&&null==h.__s&&(h.__s=h.state),S&&null!=j.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=d({},h.__s)),d(h.__s,j.getDerivedStateFromProps(b,h.__s))),v=h.props,y=h.state,h.__v=u,p)S&&null==j.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),S&&null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else{if(S&&null==j.getDerivedStateFromProps&&b!==v&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(b,M),u.__v==t.__v||!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(b,h.__s,M)){for(u.__v!=t.__v&&(h.props=b,h.state=h.__s,h.__d=!1),u.__e=t.__e,u.__k=t.__k,u.__k.some(function(n){n&&(n.__=u)}),$=0;$<h._sb.length;$++)h.__h.push(h._sb[$]);h._sb=[],h.__h.length&&e.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(b,h.__s,M),S&&null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(v,y,_)})}if(h.context=M,h.props=b,h.__P=n,h.__e=!1,P=l.__r,A=0,S){for(h.state=h.__s,h.__d=!1,P&&P(u),a=h.render(h.props,h.state,h.context),H=0;H<h._sb.length;H++)h.__h.push(h._sb[H]);h._sb=[]}else do{h.__d=!1,P&&P(u),a=h.render(h.props,h.state,h.context),h.state=h.__s}while(h.__d&&++A<25);h.state=h.__s,null!=h.getChildContext&&(i=d(d({},i),h.getChildContext())),S&&!p&&null!=h.getSnapshotBeforeUpdate&&(_=h.getSnapshotBeforeUpdate(v,y)),L=a,null!=a&&a.type===k&&null==a.key&&(L=V(a.props.children)),f=I(n,w(L)?L:[L],u,t,i,r,o,e,f,c,s),h.base=u.__e,u.__u&=-161,h.__h.length&&e.push(h),m&&(h.__E=h.__=null)}catch(n){if(u.__v=null,c||null!=o)if(n.then){for(u.__u|=c?160:128;f&&8==f.nodeType&&f.nextSibling;)f=f.nextSibling;o[o.indexOf(f)]=null,u.__e=f}else{for(T=o.length;T--;)g(o[T]);z(u)}else u.__e=t.__e,u.__k=t.__k,n.then||z(u);l.__e(n,u,t)}else null==o&&u.__v==t.__v?(u.__k=t.__k,u.__e=t.__e):f=u.__e=q(t.__e,u,t,i,r,o,e,c,s);return(a=l.diffed)&&a(u),128&u.__u?void 0:f}function z(n){n&&n.__c&&(n.__c.__e=!0),n&&n.__k&&n.__k.forEach(z)}function N(n,u,t){for(var i=0;i<t.length;i++)B(t[i],t[++i],t[++i]);l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u)})}catch(n){l.__e(n,u.__v)}})}function V(n){return\"object\"!=typeof n||null==n||n.__b&&n.__b>0?n:w(n)?n.map(V):d({},n)}function q(u,t,i,r,o,e,f,c,s){var a,h,v,y,d,_,m,b=i.props||p,k=t.props,x=t.type;if(\"svg\"==x?o=\"http://www.w3.org/2000/svg\":\"math\"==x?o=\"http://www.w3.org/1998/Math/MathML\":o||(o=\"http://www.w3.org/1999/xhtml\"),null!=e)for(a=0;a<e.length;a++)if((d=e[a])&&\"setAttribute\"in d==!!x&&(x?d.localName==x:3==d.nodeType)){u=d,e[a]=null;break}if(null==u){if(null==x)return document.createTextNode(k);u=document.createElementNS(o,x,k.is&&k),c&&(l.__m&&l.__m(t,e),c=!1),e=null}if(null==x)b===k||c&&u.data==k||(u.data=k);else{if(e=e&&n.call(u.childNodes),!c&&null!=e)for(b={},a=0;a<u.attributes.length;a++)b[(d=u.attributes[a]).name]=d.value;for(a in b)if(d=b[a],\"children\"==a);else if(\"dangerouslySetInnerHTML\"==a)v=d;else if(!(a in k)){if(\"value\"==a&&\"defaultValue\"in k||\"checked\"==a&&\"defaultChecked\"in k)continue;j(u,a,null,d,o)}for(a in k)d=k[a],\"children\"==a?y=d:\"dangerouslySetInnerHTML\"==a?h=d:\"value\"==a?_=d:\"checked\"==a?m=d:c&&\"function\"!=typeof d||b[a]===d||j(u,a,d,b[a],o);if(h)c||v&&(h.__html==v.__html||h.__html==u.innerHTML)||(u.innerHTML=h.__html),t.__k=[];else if(v&&(u.innerHTML=\"\"),I(\"template\"==t.type?u.content:u,w(y)?y:[y],t,i,r,\"foreignObject\"==x?\"http://www.w3.org/1999/xhtml\":o,e,f,e?e[0]:i.__k&&S(i,0),c,s),null!=e)for(a=e.length;a--;)g(e[a]);c||(a=\"value\",\"progress\"==x&&null==_?u.removeAttribute(\"value\"):null!=_&&(_!==u[a]||\"progress\"==x&&!_||\"option\"==x&&_!=b[a])&&j(u,a,_,b[a],o),a=\"checked\",null!=m&&m!=u[a]&&j(u,a,m,b[a],o))}return u}function B(n,u,t){try{if(\"function\"==typeof n){var i=\"function\"==typeof n.__u;i&&n.__u(),i&&null==u||(n.__u=n(u))}else n.current=u}catch(n){l.__e(n,t)}}function D(n,u,t){var i,r;if(l.unmount&&l.unmount(n),(i=n.ref)&&(i.current&&i.current!=n.__e||B(i,null,u)),null!=(i=n.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount()}catch(n){l.__e(n,u)}i.base=i.__P=null}if(i=n.__k)for(r=0;r<i.length;r++)i[r]&&D(i[r],u,t||\"function\"!=typeof n.type);t||g(n.__e),n.__c=n.__=n.__e=void 0}function E(n,l,u){return this.constructor(n,u)}function G(u,t,i){var r,o,e,f;t==document&&(t=document.documentElement),l.__&&l.__(u,t),o=(r=\"function\"==typeof i)?null:i&&i.__k||t.__k,e=[],f=[],O(t,u=(!r&&i||t).__k=_(k,null,[u]),o||p,p,t.namespaceURI,!r&&i?[i]:o?null:t.firstChild?n.call(t.childNodes):null,e,!r&&i?i:o?o.__e:t.firstChild,r,f),N(e,u,f)}function J(n,l){G(n,l,J)}function K(l,u,t){var i,r,o,e,f=d({},l.props);for(o in l.type&&l.type.defaultProps&&(e=l.type.defaultProps),u)\"key\"==o?i=u[o]:\"ref\"==o?r=u[o]:f[o]=void 0===u[o]&&null!=e?e[o]:u[o];return arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):t),m(l.type,f,i||l.key,r||l.ref,null)}function Q(n){function l(n){var u,t;return this.getChildContext||(u=new Set,(t={})[l.__c]=this,this.getChildContext=function(){return t},this.componentWillUnmount=function(){u=null},this.shouldComponentUpdate=function(n){this.props.value!=n.value&&u.forEach(function(n){n.__e=!0,M(n)})},this.sub=function(n){u.add(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u&&u.delete(n),l&&l.call(n)}}),n.children}return l.__c=\"__cC\"+h++,l.__=n,l.Provider=l.__l=(l.Consumer=function(n,l){return n.children(l)}).contextType=l,l}n=v.slice,l={__e:function(n,l,u,t){for(var i,r,o;l=l.__;)if((i=l.__c)&&!i.__)try{if((r=i.constructor)&&null!=r.getDerivedStateFromError&&(i.setState(r.getDerivedStateFromError(n)),o=i.__d),null!=i.componentDidCatch&&(i.componentDidCatch(n,t||{}),o=i.__d),o)return i.__E=i}catch(l){n=l}throw n}},u=0,t=function(n){return null!=n&&null==n.constructor},x.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!=this.state?this.__s:this.__s=d({},this.state),\"function\"==typeof n&&(n=n(d({},u),this.props)),n&&d(u,n),null!=n&&this.__v&&(l&&this._sb.push(l),M(this))},x.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),M(this))},x.prototype.render=k,i=[],o=\"function\"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,e=function(n,l){return n.__v.__b-l.__v.__b},$.__r=0,f=/(PointerCapture)$|Capture$/i,c=0,s=F(!1),a=F(!0),h=0;export{x as Component,k as Fragment,K as cloneElement,Q as createContext,_ as createElement,b as createRef,_ as h,J as hydrate,t as isValidElement,l as options,G as render,H as toChildArray};\n//# sourceMappingURL=preact.module.js.map\n","import{WalletGet as t}from\"@privy-io/routes\";async function r(r,{wallet_id:i}){return await r.fetchPrivyRoute(t,{params:{wallet_id:i}})}export{r as getWallet};\n","const a=\"/api/v1/sessions\",s=\"/api/v1/sessions/logout\",i=\"/api/v1/siwe/init\",t=\"/api/v1/siwe/authenticate\",e=\"/api/v1/siwe/link\",p=\"/api/v1/siwe/link_smart_wallet\",n=\"/api/v1/siwe/unlink\",v=\"/api/v1/siwe/transfer\",r=\"/api/v1/siws/init\",o=\"/api/v1/siws/authenticate\",u=\"/api/v1/siws/link\",l=\"/api/v1/siws/unlink\",c=\"/api/v1/siws/transfer\",w=\"/api/v1/farcaster/init\",k=\"/api/v1/farcaster/authenticate\",m=\"/api/v1/farcaster/link\",h=\"/api/v1/farcaster/status\",_=\"/api/v1/farcaster/unlink\",f=\"/api/v1/farcaster/transfer\",d=\"api/v2/farcaster/init\",g=\"api/v2/farcaster/authenticate\",y=\"/api/v1/passwordless/init\",b=\"/api/v1/passwordless/authenticate\",j=\"/api/v1/passwordless/link\",x=\"/api/v1/passwordless/unlink\",q=\"/api/v1/passwordless/update\",z=\"/api/v1/passwordless/transfer\",A=\"/api/v1/passwordless_sms/init\",B=\"/api/v1/passwordless_sms/link\",C=\"/api/v1/passwordless_sms/unlink\",D=\"/api/v1/passwordless_sms/authenticate\",E=\"/api/v1/passwordless_sms/update\",F=\"/api/v1/passwordless_sms/transfer\",G=\"/api/v1/oauth/init\",H=\"/api/v1/oauth/authenticate\",I=\"/api/v1/oauth/link\",J=\"/api/v1/oauth/unlink\",K=\"/api/v1/oauth/transfer\",L=\"/api/v1/recovery/oauth/init\",M=\"/api/v1/recovery/oauth/init_icloud\",N=\"/api/v1/recovery/oauth/authenticate\",O=\"/api/v1/passkeys/link/init\",P=\"/api/v1/passkeys/authenticate/init\",Q=\"/api/v1/passkeys/register/init\",R=\"/api/v1/passkeys/link\",S=\"/api/v1/passkeys/authenticate\",T=\"/api/v1/passkeys/register\",U=\"/api/v1/telegram/authenticate\",V=\"/api/v1/telegram/link\",W=\"/api/v1/telegram/unlink\",X=\"/api/v1/telegram/transfer\",Y=\"/api/v1/sso/authenticate\",Z=\"/api/v1/mfa/passwordless_sms/init\",$=\"/api/v1/mfa/passkeys/init\",aa=\"/api/v1/users/me/accept_terms\",sa=\"/api/v1/analytics_events\",ia=\"/api/v1/custom_jwt_account/authenticate\",ta=\"/api/v1/custom_jwt_account/link\",ea=\"/api/v1/guest/authenticate\",pa=\"/api/v1/plugins/moonpay_on_ramp/sign\",na=\"/api/v1/funding/coinbase_on_ramp/init\",va=\"/api/v1/funding/coinbase_on_ramp/status\",ra=\"/api/v1/wallets/revoke\",oa=\"/api/v1/users/me\",ua=\"/api/v1/scan/transaction\";export{v as $,s as A,sa as B,ea as C,Z as D,$ as E,aa as F,x as G,C as H,n as I,l as J,J as K,_ as L,W as M,ra as N,pa as O,na as P,va as Q,i as R,t as S,e as T,p as U,r as V,o as W,K as X,c as Y,X as Z,f as _,j as a,F as a0,z as a1,u as a2,oa as a3,ua as a4,d as a5,g as a6,Y as a7,N as a8,M as a9,L as aa,y as b,m as c,w as d,h as e,k as f,I as g,G as h,T as i,S as j,R as k,Q as l,P as m,O as n,H as o,b as p,D as q,B as r,A as s,E as t,q as u,U as v,V as w,ia as x,ta as y,a as z};\n","function t(e){typeof queueMicrotask==\"function\"?queueMicrotask(e):Promise.resolve().then(e).catch(o=>setTimeout(()=>{throw o}))}export{t as microTask};\n","var i=Object.defineProperty;var d=(t,e,n)=>e in t?i(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var r=(t,e,n)=>(d(t,typeof e!=\"symbol\"?e+\"\":e,n),n);class o{constructor(){r(this,\"current\",this.detect());r(this,\"handoffState\",\"pending\");r(this,\"currentId\",0)}set(e){this.current!==e&&(this.handoffState=\"pending\",this.currentId=0,this.current=e)}reset(){this.set(this.detect())}nextId(){return++this.currentId}get isServer(){return this.current===\"server\"}get isClient(){return this.current===\"client\"}detect(){return typeof window==\"undefined\"||typeof document==\"undefined\"?\"server\":\"client\"}handoff(){this.handoffState===\"pending\"&&(this.handoffState=\"complete\")}get isHandoffComplete(){return this.handoffState===\"complete\"}}let s=new o;export{s as env};\n","var T,S;import{useRef as c,useState as b}from\"react\";import{disposables as m}from'../utils/disposables.js';import{useDisposables as g}from'./use-disposables.js';import{useFlags as y}from'./use-flags.js';import{useIsoMorphicEffect as L}from'./use-iso-morphic-effect.js';typeof process!=\"undefined\"&&typeof globalThis!=\"undefined\"&&typeof Element!=\"undefined\"&&((T=process==null?void 0:process.env)==null?void 0:T[\"NODE_ENV\"])===\"test\"&&typeof((S=Element==null?void 0:Element.prototype)==null?void 0:S.getAnimations)==\"undefined\"&&(Element.prototype.getAnimations=function(){return console.warn([\"Headless UI has polyfilled `Element.prototype.getAnimations` for your tests.\",\"Please install a proper polyfill e.g. `jsdom-testing-mocks`, to silence these warnings.\",\"\",\"Example usage:\",\"```js\",\"import { mockAnimationsApi } from 'jsdom-testing-mocks'\",\"mockAnimationsApi()\",\"```\"].join(`\n`)),[]});var A=(i=>(i[i.None=0]=\"None\",i[i.Closed=1]=\"Closed\",i[i.Enter=2]=\"Enter\",i[i.Leave=4]=\"Leave\",i))(A||{});function x(e){let r={};for(let t in e)e[t]===!0&&(r[`data-${t}`]=\"\");return r}function N(e,r,t,n){let[i,a]=b(t),{hasFlag:s,addFlag:o,removeFlag:l}=y(e&&i?3:0),u=c(!1),f=c(!1),E=g();return L(()=>{var d;if(e){if(t&&a(!0),!r){t&&o(3);return}return(d=n==null?void 0:n.start)==null||d.call(n,t),C(r,{inFlight:u,prepare(){f.current?f.current=!1:f.current=u.current,u.current=!0,!f.current&&(t?(o(3),l(4)):(o(4),l(2)))},run(){f.current?t?(l(3),o(4)):(l(4),o(3)):t?l(1):o(1)},done(){var p;f.current&&D(r)||(u.current=!1,l(7),t||a(!1),(p=n==null?void 0:n.end)==null||p.call(n,t))}})}},[e,t,r,E]),e?[i,{closed:s(1),enter:s(2),leave:s(4),transition:s(2)||s(4)}]:[t,{closed:void 0,enter:void 0,leave:void 0,transition:void 0}]}function C(e,{prepare:r,run:t,done:n,inFlight:i}){let a=m();return j(e,{prepare:r,inFlight:i}),a.nextFrame(()=>{t(),a.requestAnimationFrame(()=>{a.add(M(e,n))})}),a.dispose}function M(e,r){var a,s;let t=m();if(!e)return t.dispose;let n=!1;t.add(()=>{n=!0});let i=(s=(a=e.getAnimations)==null?void 0:a.call(e).filter(o=>o instanceof CSSTransition))!=null?s:[];return i.length===0?(r(),t.dispose):(Promise.allSettled(i.map(o=>o.finished)).then(()=>{n||r()}),t.dispose)}function j(e,{inFlight:r,prepare:t}){if(r!=null&&r.current){t();return}let n=e.style.transition;e.style.transition=\"none\",t(),e.offsetHeight,e.style.transition=n}function D(e){var t,n;return((n=(t=e.getAnimations)==null?void 0:t.call(e))!=null?n:[]).some(i=>i instanceof CSSTransition&&i.playState!==\"finished\")}export{x as transitionDataAttributes,N as useTransition};\n","function t(...r){return Array.from(new Set(r.flatMap(n=>typeof n==\"string\"?n.split(\" \"):[]))).filter(Boolean).join(\" \")}export{t as classNames};\n","function u(r,n,...a){if(r in n){let e=n[r];return typeof e==\"function\"?e(...a):e}let t=new Error(`Tried to handle \"${r}\" but there is no handler defined. Only defined handlers are: ${Object.keys(n).map(e=>`\"${e}\"`).join(\", \")}.`);throw Error.captureStackTrace&&Error.captureStackTrace(t,u),t}export{u as match};\n","\"use client\";import c,{Fragment as k,createContext as ne,useContext as q,useEffect as ge,useMemo as ie,useRef as b,useState as O}from\"react\";import{useDisposables as ve}from'../../hooks/use-disposables.js';import{useEvent as E}from'../../hooks/use-event.js';import{useIsMounted as be}from'../../hooks/use-is-mounted.js';import{useIsoMorphicEffect as D}from'../../hooks/use-iso-morphic-effect.js';import{useLatestValue as Ee}from'../../hooks/use-latest-value.js';import{useServerHandoffComplete as re}from'../../hooks/use-server-handoff-complete.js';import{useSyncRefs as oe}from'../../hooks/use-sync-refs.js';import{transitionDataAttributes as Se,useTransition as Re}from'../../hooks/use-transition.js';import{OpenClosedProvider as ye,State as x,useOpenClosed as se}from'../../internal/open-closed.js';import{classNames as Pe}from'../../utils/class-names.js';import{match as le}from'../../utils/match.js';import{RenderFeatures as xe,RenderStrategy as P,compact as Ne,forwardRefWithAs as J,isFragment as _e,useRender as ae}from'../../utils/render.js';function ue(e){var t;return!!(e.enter||e.enterFrom||e.enterTo||e.leave||e.leaveFrom||e.leaveTo)||!_e((t=e.as)!=null?t:de)||c.Children.count(e.children)===1}let V=ne(null);V.displayName=\"TransitionContext\";var De=(n=>(n.Visible=\"visible\",n.Hidden=\"hidden\",n))(De||{});function He(){let e=q(V);if(e===null)throw new Error(\"A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.\");return e}function Ae(){let e=q(w);if(e===null)throw new Error(\"A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.\");return e}let w=ne(null);w.displayName=\"NestingContext\";function M(e){return\"children\"in e?M(e.children):e.current.filter(({el:t})=>t.current!==null).filter(({state:t})=>t===\"visible\").length>0}function Te(e,t){let n=Ee(e),l=b([]),S=be(),R=ve(),d=E((o,i=P.Hidden)=>{let a=l.current.findIndex(({el:s})=>s===o);a!==-1&&(le(i,{[P.Unmount](){l.current.splice(a,1)},[P.Hidden](){l.current[a].state=\"hidden\"}}),R.microTask(()=>{var s;!M(l)&&S.current&&((s=n.current)==null||s.call(n))}))}),y=E(o=>{let i=l.current.find(({el:a})=>a===o);return i?i.state!==\"visible\"&&(i.state=\"visible\"):l.current.push({el:o,state:\"visible\"}),()=>d(o,P.Unmount)}),C=b([]),p=b(Promise.resolve()),h=b({enter:[],leave:[]}),g=E((o,i,a)=>{C.current.splice(0),t&&(t.chains.current[i]=t.chains.current[i].filter(([s])=>s!==o)),t==null||t.chains.current[i].push([o,new Promise(s=>{C.current.push(s)})]),t==null||t.chains.current[i].push([o,new Promise(s=>{Promise.all(h.current[i].map(([r,f])=>f)).then(()=>s())})]),i===\"enter\"?p.current=p.current.then(()=>t==null?void 0:t.wait.current).then(()=>a(i)):a(i)}),v=E((o,i,a)=>{Promise.all(h.current[i].splice(0).map(([s,r])=>r)).then(()=>{var s;(s=C.current.shift())==null||s()}).then(()=>a(i))});return ie(()=>({children:l,register:y,unregister:d,onStart:g,onStop:v,wait:p,chains:h}),[y,d,l,g,v,h,p])}let de=k,fe=xe.RenderStrategy;function Fe(e,t){var ee,te;let{transition:n=!0,beforeEnter:l,afterEnter:S,beforeLeave:R,afterLeave:d,enter:y,enterFrom:C,enterTo:p,entered:h,leave:g,leaveFrom:v,leaveTo:o,...i}=e,[a,s]=O(null),r=b(null),f=ue(e),U=oe(...f?[r,t,s]:t===null?[]:[t]),H=(ee=i.unmount)==null||ee?P.Unmount:P.Hidden,{show:u,appear:z,initial:K}=He(),[m,j]=O(u?\"visible\":\"hidden\"),Q=Ae(),{register:A,unregister:F}=Q;D(()=>A(r),[A,r]),D(()=>{if(H===P.Hidden&&r.current){if(u&&m!==\"visible\"){j(\"visible\");return}return le(m,{[\"hidden\"]:()=>F(r),[\"visible\"]:()=>A(r)})}},[m,r,A,F,u,H]);let G=re();D(()=>{if(f&&G&&m===\"visible\"&&r.current===null)throw new Error(\"Did you forget to passthrough the `ref` to the actual DOM node?\")},[r,m,G,f]);let ce=K&&!z,Y=z&&u&&K,B=b(!1),I=Te(()=>{B.current||(j(\"hidden\"),F(r))},Q),Z=E(W=>{B.current=!0;let L=W?\"enter\":\"leave\";I.onStart(r,L,_=>{_===\"enter\"?l==null||l():_===\"leave\"&&(R==null||R())})}),$=E(W=>{let L=W?\"enter\":\"leave\";B.current=!1,I.onStop(r,L,_=>{_===\"enter\"?S==null||S():_===\"leave\"&&(d==null||d())}),L===\"leave\"&&!M(I)&&(j(\"hidden\"),F(r))});ge(()=>{f&&n||(Z(u),$(u))},[u,f,n]);let pe=(()=>!(!n||!f||!G||ce))(),[,T]=Re(pe,a,u,{start:Z,end:$}),Ce=Ne({ref:U,className:((te=Pe(i.className,Y&&y,Y&&C,T.enter&&y,T.enter&&T.closed&&C,T.enter&&!T.closed&&p,T.leave&&g,T.leave&&!T.closed&&v,T.leave&&T.closed&&o,!T.transition&&u&&h))==null?void 0:te.trim())||void 0,...Se(T)}),N=0;m===\"visible\"&&(N|=x.Open),m===\"hidden\"&&(N|=x.Closed),u&&m===\"hidden\"&&(N|=x.Opening),!u&&m===\"visible\"&&(N|=x.Closing);let he=ae();return c.createElement(w.Provider,{value:I},c.createElement(ye,{value:N},he({ourProps:Ce,theirProps:i,defaultTag:de,features:fe,visible:m===\"visible\",name:\"Transition.Child\"})))}function Ie(e,t){let{show:n,appear:l=!1,unmount:S=!0,...R}=e,d=b(null),y=ue(e),C=oe(...y?[d,t]:t===null?[]:[t]);re();let p=se();if(n===void 0&&p!==null&&(n=(p&x.Open)===x.Open),n===void 0)throw new Error(\"A <Transition /> is used but it is missing a `show={true | false}` prop.\");let[h,g]=O(n?\"visible\":\"hidden\"),v=Te(()=>{n||g(\"hidden\")}),[o,i]=O(!0),a=b([n]);D(()=>{o!==!1&&a.current[a.current.length-1]!==n&&(a.current.push(n),i(!1))},[a,n]);let s=ie(()=>({show:n,appear:l,initial:o}),[n,l,o]);D(()=>{n?g(\"visible\"):!M(v)&&d.current!==null&&g(\"hidden\")},[n,v]);let r={unmount:S},f=E(()=>{var u;o&&i(!1),(u=e.beforeEnter)==null||u.call(e)}),U=E(()=>{var u;o&&i(!1),(u=e.beforeLeave)==null||u.call(e)}),H=ae();return c.createElement(w.Provider,{value:v},c.createElement(V.Provider,{value:s},H({ourProps:{...r,as:k,children:c.createElement(me,{ref:C,...r,...R,beforeEnter:f,beforeLeave:U})},theirProps:{},defaultTag:k,features:fe,visible:h===\"visible\",name:\"Transition\"})))}function Le(e,t){let n=q(V)!==null,l=se()!==null;return c.createElement(c.Fragment,null,!n&&l?c.createElement(X,{ref:t,...e}):c.createElement(me,{ref:t,...e}))}let X=J(Ie),me=J(Fe),Oe=J(Le),Ke=Object.assign(X,{Child:Oe,Root:X});export{Ke as Transition,Oe as TransitionChild};\n","var o=(r=>(r.Space=\" \",r.Enter=\"Enter\",r.Escape=\"Escape\",r.Backspace=\"Backspace\",r.Delete=\"Delete\",r.ArrowLeft=\"ArrowLeft\",r.ArrowUp=\"ArrowUp\",r.ArrowRight=\"ArrowRight\",r.ArrowDown=\"ArrowDown\",r.Home=\"Home\",r.End=\"End\",r.PageUp=\"PageUp\",r.PageDown=\"PageDown\",r.Tab=\"Tab\",r))(o||{});export{o as Keys};\n","class a extends Map{constructor(t){super();this.factory=t}get(t){let e=super.get(t);return e===void 0&&(e=this.factory(t),this.set(t,e)),e}}export{a as DefaultMap};\n","var h=Object.defineProperty;var v=(t,e,r)=>e in t?h(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r;var S=(t,e,r)=>(v(t,typeof e!=\"symbol\"?e+\"\":e,r),r),b=(t,e,r)=>{if(!e.has(t))throw TypeError(\"Cannot \"+r)};var i=(t,e,r)=>(b(t,e,\"read from private field\"),r?r.call(t):e.get(t)),c=(t,e,r)=>{if(e.has(t))throw TypeError(\"Cannot add the same private member more than once\");e instanceof WeakSet?e.add(t):e.set(t,r)},u=(t,e,r,s)=>(b(t,e,\"write to private field\"),s?s.call(t,r):e.set(t,r),r);var n,a,o;import{DefaultMap as m}from'./utils/default-map.js';import{disposables as y}from'./utils/disposables.js';import{env as d}from'./utils/env.js';class T{constructor(e){c(this,n,{});c(this,a,new m(()=>new Set));c(this,o,new Set);S(this,\"disposables\",y());u(this,n,e),d.isServer&&this.disposables.microTask(()=>{this.dispose()})}dispose(){this.disposables.dispose()}get state(){return i(this,n)}subscribe(e,r){if(d.isServer)return()=>{};let s={selector:e,callback:r,current:e(i(this,n))};return i(this,o).add(s),this.disposables.add(()=>{i(this,o).delete(s)})}on(e,r){return d.isServer?()=>{}:(i(this,a).get(e).add(r),this.disposables.add(()=>{i(this,a).get(e).delete(r)}))}send(e){let r=this.reduce(i(this,n),e);if(r!==i(this,n)){u(this,n,r);for(let s of i(this,o)){let l=s.selector(i(this,n));j(s.current,l)||(s.current=l,s.callback(l))}for(let s of i(this,a).get(e.type))s(i(this,n),e)}}}n=new WeakMap,a=new WeakMap,o=new WeakMap;function j(t,e){return Object.is(t,e)?!0:typeof t!=\"object\"||t===null||typeof e!=\"object\"||e===null?!1:Array.isArray(t)&&Array.isArray(e)?t.length!==e.length?!1:f(t[Symbol.iterator](),e[Symbol.iterator]()):t instanceof Map&&e instanceof Map||t instanceof Set&&e instanceof Set?t.size!==e.size?!1:f(t.entries(),e.entries()):p(t)&&p(e)?f(Object.entries(t)[Symbol.iterator](),Object.entries(e)[Symbol.iterator]()):!1}function f(t,e){do{let r=t.next(),s=e.next();if(r.done&&s.done)return!0;if(r.done||s.done||!Object.is(r.value,s.value))return!1}while(!0)}function p(t){if(Object.prototype.toString.call(t)!==\"[object Object]\")return!1;let e=Object.getPrototypeOf(t);return e===null||Object.getPrototypeOf(e)===null}function k(t){let[e,r]=t(),s=y();return(...l)=>{e(...l),s.dispose(),s.microTask(r)}}export{T as Machine,k as batch,j as shallowEqual};\n","var a=Object.defineProperty;var r=(e,c,t)=>c in e?a(e,c,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[c]=t;var p=(e,c,t)=>(r(e,typeof c!=\"symbol\"?c+\"\":c,t),t);import{Machine as d}from'../machine.js';import{DefaultMap as l}from'../utils/default-map.js';import{match as u}from'../utils/match.js';var k=(t=>(t[t.Push=0]=\"Push\",t[t.Pop=1]=\"Pop\",t))(k||{});let y={[0](e,c){let t=c.id,s=e.stack,i=e.stack.indexOf(t);if(i!==-1){let n=e.stack.slice();return n.splice(i,1),n.push(t),s=n,{...e,stack:s}}return{...e,stack:[...e.stack,t]}},[1](e,c){let t=c.id,s=e.stack.indexOf(t);if(s===-1)return e;let i=e.stack.slice();return i.splice(s,1),{...e,stack:i}}};class o extends d{constructor(){super(...arguments);p(this,\"actions\",{push:t=>this.send({type:0,id:t}),pop:t=>this.send({type:1,id:t})});p(this,\"selectors\",{isTop:(t,s)=>t.stack[t.stack.length-1]===s,inStack:(t,s)=>t.stack.includes(s)})}static new(){return new o({stack:[]})}reduce(t,s){return u(s.type,y,t,s)}}const x=new l(()=>o.new());export{k as ActionTypes,x as stackMachines};\n","import{useSyncExternalStoreWithSelector as a}from\"use-sync-external-store/with-selector\";import{useEvent as t}from'./hooks/use-event.js';import{shallowEqual as o}from'./machine.js';function S(e,n,r=o){return a(t(i=>e.subscribe(s,i)),t(()=>e.state),t(()=>e.state),t(n),r)}function s(e){return e}export{S as useSlice};\n","function t(){return/iPhone/gi.test(window.navigator.platform)||/Mac/gi.test(window.navigator.platform)&&window.navigator.maxTouchPoints>0}function i(){return/Android/gi.test(window.navigator.userAgent)}function n(){return t()||i()}export{i as isAndroid,t as isIOS,n as isMobile};\n","function a(o,r){let t=o(),n=new Set;return{getSnapshot(){return t},subscribe(e){return n.add(e),()=>n.delete(e)},dispatch(e,...s){let i=r[e].call(t,...s);i&&(t=i,n.forEach(c=>c()))}}}export{a as createStore};\n","function d(){let r;return{before({doc:e}){var l;let o=e.documentElement,t=(l=e.defaultView)!=null?l:window;r=Math.max(0,t.innerWidth-o.clientWidth)},after({doc:e,d:o}){let t=e.documentElement,l=Math.max(0,t.clientWidth-t.offsetWidth),n=Math.max(0,r-l);o.style(t,\"paddingRight\",`${n}px`)}}}export{d as adjustScrollbarPadding};\n","function r(){return{before({doc:e,d:o}){o.style(e.documentElement,\"overflow\",\"hidden\")}}}export{r as preventScroll};\n","\"use client\";import r,{createContext as n,useContext as i}from\"react\";let e=n(()=>{});function u(){return i(e)}function C({value:t,children:o}){return r.createElement(e.Provider,{value:t},o)}export{C as CloseProvider,u as useClose};\n","\"use client\";import m,{createContext as D,useContext as d,useMemo as u,useState as T}from\"react\";import{useEvent as P}from'../../hooks/use-event.js';import{useId as g}from'../../hooks/use-id.js';import{useIsoMorphicEffect as x}from'../../hooks/use-iso-morphic-effect.js';import{useSlot as y}from'../../hooks/use-slot.js';import{useSyncRefs as E}from'../../hooks/use-sync-refs.js';import{useDisabled as v}from'../../internal/disabled.js';import{forwardRefWithAs as R,useRender as S}from'../../utils/render.js';let a=D(null);a.displayName=\"DescriptionContext\";function f(){let r=d(a);if(r===null){let e=new Error(\"You used a <Description /> component, but it is not inside a relevant parent.\");throw Error.captureStackTrace&&Error.captureStackTrace(e,f),e}return r}function w(){var r,e;return(e=(r=d(a))==null?void 0:r.value)!=null?e:void 0}function H(){let[r,e]=T([]);return[r.length>0?r.join(\" \"):void 0,u(()=>function(t){let i=P(n=>(e(o=>[...o,n]),()=>e(o=>{let s=o.slice(),p=s.indexOf(n);return p!==-1&&s.splice(p,1),s}))),l=u(()=>({register:i,slot:t.slot,name:t.name,props:t.props,value:t.value}),[i,t.slot,t.name,t.props,t.value]);return m.createElement(a.Provider,{value:l},t.children)},[e])]}let I=\"p\";function C(r,e){let c=g(),t=v(),{id:i=`headlessui-description-${c}`,...l}=r,n=f(),o=E(e);x(()=>n.register(i),[i,n.register]);let s=y({...n.slot,disabled:t||!1}),p={ref:o,...n.props,id:i};return S()({ourProps:p,theirProps:l,slot:s,defaultTag:I,name:n.name||\"Description\"})}let _=R(C),M=Object.assign(_,{});export{M as Description,w as useDescribedBy,H as useDescriptions};\n","function t(n){function e(){document.readyState!==\"loading\"&&(n(),document.removeEventListener(\"DOMContentLoaded\",e))}typeof window!=\"undefined\"&&typeof document!=\"undefined\"&&(document.addEventListener(\"DOMContentLoaded\",e),e())}export{t as onDocumentReady};\n","\"use client\";import F,{useRef as M}from\"react\";import{useDisposables as W}from'../../hooks/use-disposables.js';import{useEvent as O}from'../../hooks/use-event.js';import{useEventListener as K}from'../../hooks/use-event-listener.js';import{useIsMounted as P}from'../../hooks/use-is-mounted.js';import{useIsTopLayer as C}from'../../hooks/use-is-top-layer.js';import{useOnUnmount as q}from'../../hooks/use-on-unmount.js';import{useOwnerDocument as J}from'../../hooks/use-owner.js';import{useServerHandoffComplete as X}from'../../hooks/use-server-handoff-complete.js';import{useSyncRefs as z}from'../../hooks/use-sync-refs.js';import{Direction as y,useTabDirection as D}from'../../hooks/use-tab-direction.js';import{useWatch as R}from'../../hooks/use-watch.js';import{Hidden as _,HiddenFeatures as S}from'../../internal/hidden.js';import{history as H}from'../../utils/active-element-history.js';import*as i from'../../utils/dom.js';import{Focus as m,FocusResult as h,focusElement as p,focusIn as d}from'../../utils/focus-management.js';import{match as j}from'../../utils/match.js';import{microTask as U}from'../../utils/micro-task.js';import{isActiveElement as Q}from'../../utils/owner.js';import{forwardRefWithAs as Y,useRender as Z}from'../../utils/render.js';function x(o){if(!o)return new Set;if(typeof o==\"function\")return new Set(o());let t=new Set;for(let e of o.current)i.isElement(e.current)&&t.add(e.current);return t}let $=\"div\";var G=(n=>(n[n.None=0]=\"None\",n[n.InitialFocus=1]=\"InitialFocus\",n[n.TabLock=2]=\"TabLock\",n[n.FocusLock=4]=\"FocusLock\",n[n.RestoreFocus=8]=\"RestoreFocus\",n[n.AutoFocus=16]=\"AutoFocus\",n))(G||{});function w(o,t){let e=M(null),r=z(e,t),{initialFocus:u,initialFocusFallback:a,containers:n,features:s=15,...f}=o;X()||(s=0);let l=J(e.current);re(s,{ownerDocument:l});let T=ne(s,{ownerDocument:l,container:e,initialFocus:u,initialFocusFallback:a});oe(s,{ownerDocument:l,container:e,containers:n,previousActiveElement:T});let g=D(),A=O(c=>{if(!i.isHTMLElement(e.current))return;let E=e.current;(V=>V())(()=>{j(g.current,{[y.Forwards]:()=>{d(E,m.First,{skipElements:[c.relatedTarget,a]})},[y.Backwards]:()=>{d(E,m.Last,{skipElements:[c.relatedTarget,a]})}})})}),v=C(!!(s&2),\"focus-trap#tab-lock\"),N=W(),b=M(!1),k={ref:r,onKeyDown(c){c.key==\"Tab\"&&(b.current=!0,N.requestAnimationFrame(()=>{b.current=!1}))},onBlur(c){if(!(s&4))return;let E=x(n);i.isHTMLElement(e.current)&&E.add(e.current);let L=c.relatedTarget;i.isHTMLorSVGElement(L)&&L.dataset.headlessuiFocusGuard!==\"true\"&&(I(E,L)||(b.current?d(e.current,j(g.current,{[y.Forwards]:()=>m.Next,[y.Backwards]:()=>m.Previous})|m.WrapAround,{relativeTo:c.target}):i.isHTMLorSVGElement(c.target)&&p(c.target)))}},B=Z();return F.createElement(F.Fragment,null,v&&F.createElement(_,{as:\"button\",type:\"button\",\"data-headlessui-focus-guard\":!0,onFocus:A,features:S.Focusable}),B({ourProps:k,theirProps:f,defaultTag:$,name:\"FocusTrap\"}),v&&F.createElement(_,{as:\"button\",type:\"button\",\"data-headlessui-focus-guard\":!0,onFocus:A,features:S.Focusable}))}let ee=Y(w),ge=Object.assign(ee,{features:G});function te(o=!0){let t=M(H.slice());return R(([e],[r])=>{r===!0&&e===!1&&U(()=>{t.current.splice(0)}),r===!1&&e===!0&&(t.current=H.slice())},[o,H,t]),O(()=>{var e;return(e=t.current.find(r=>r!=null&&r.isConnected))!=null?e:null})}function re(o,{ownerDocument:t}){let e=!!(o&8),r=te(e);R(()=>{e||Q(t==null?void 0:t.body)&&p(r())},[e]),q(()=>{e&&p(r())})}function ne(o,{ownerDocument:t,container:e,initialFocus:r,initialFocusFallback:u}){let a=M(null),n=C(!!(o&1),\"focus-trap#initial-focus\"),s=P();return R(()=>{if(o===0)return;if(!n){u!=null&&u.current&&p(u.current);return}let f=e.current;f&&U(()=>{if(!s.current)return;let l=t==null?void 0:t.activeElement;if(r!=null&&r.current){if((r==null?void 0:r.current)===l){a.current=l;return}}else if(f.contains(l)){a.current=l;return}if(r!=null&&r.current)p(r.current);else{if(o&16){if(d(f,m.First|m.AutoFocus)!==h.Error)return}else if(d(f,m.First)!==h.Error)return;if(u!=null&&u.current&&(p(u.current),(t==null?void 0:t.activeElement)===u.current))return;console.warn(\"There are no focusable elements inside the <FocusTrap />\")}a.current=t==null?void 0:t.activeElement})},[u,n,o]),a}function oe(o,{ownerDocument:t,container:e,containers:r,previousActiveElement:u}){let a=P(),n=!!(o&4);K(t==null?void 0:t.defaultView,\"focus\",s=>{if(!n||!a.current)return;let f=x(r);i.isHTMLElement(e.current)&&f.add(e.current);let l=u.current;if(!l)return;let T=s.target;i.isHTMLElement(T)?I(f,T)?(u.current=T,p(T)):(s.preventDefault(),s.stopPropagation(),p(l)):p(u.current)},!0)}function I(o,t){for(let e of o)if(e.contains(t))return!0;return!1}export{ge as FocusTrap,G as FocusTrapFeatures};\n","\"use client\";import i,{Fragment as R,createContext as E,useContext as P,useEffect as A,useMemo as G,useRef as x,useState as M}from\"react\";import{createPortal as b}from\"react-dom\";import{useDisposables as O}from'../../hooks/use-disposables.js';import{useEvent as L}from'../../hooks/use-event.js';import{useOnUnmount as F}from'../../hooks/use-on-unmount.js';import{useOwnerDocument as H}from'../../hooks/use-owner.js';import{optionalRef as h,useSyncRefs as T}from'../../hooks/use-sync-refs.js';import{usePortalRoot as U}from'../../internal/portal-force-root.js';import{env as N}from'../../utils/env.js';import{forwardRefWithAs as f,useRender as d}from'../../utils/render.js';function W(e){let o=U(),l=P(c),[r,p]=M(()=>{var s;if(!o&&l!==null)return(s=l.current)!=null?s:null;if(N.isServer)return null;let t=e==null?void 0:e.getElementById(\"headlessui-portal-root\");if(t)return t;if(e===null)return null;let n=e.createElement(\"div\");return n.setAttribute(\"id\",\"headlessui-portal-root\"),e.body.appendChild(n)});return A(()=>{r!==null&&(e!=null&&e.body.contains(r)||e==null||e.body.appendChild(r))},[r,e]),A(()=>{o||l!==null&&p(l.current)},[l,p,o]),r}let _=R,j=f(function(o,l){let{ownerDocument:r=null,...p}=o,t=x(null),n=T(h(a=>{t.current=a}),l),s=H(t.current),C=r!=null?r:s,u=W(C),y=P(m),g=O(),v=d();return F(()=>{var a;u&&u.childNodes.length<=0&&((a=u.parentElement)==null||a.removeChild(u))}),u?b(i.createElement(\"div\",{\"data-headlessui-portal\":\"\",ref:a=>{g.dispose(),y&&a&&g.add(y.register(a))}},v({ourProps:{ref:n},theirProps:p,slot:{},defaultTag:_,name:\"Portal\"})),u):null});function S(e,o){let l=T(o),{enabled:r=!0,ownerDocument:p,...t}=e,n=d();return r?i.createElement(j,{...t,ownerDocument:p,ref:l}):n({ourProps:{ref:l},theirProps:t,slot:{},defaultTag:_,name:\"Portal\"})}let I=R,c=E(null);function D(e,o){let{target:l,...r}=e,t={ref:T(o)},n=d();return i.createElement(c.Provider,{value:l},n({ourProps:t,theirProps:r,defaultTag:I,name:\"Popover.Group\"}))}let m=E(null);function ee(){let e=P(m),o=x([]),l=L(t=>(o.current.push(t),e&&e.register(t),()=>r(t))),r=L(t=>{let n=o.current.indexOf(t);n!==-1&&o.current.splice(n,1),e&&e.unregister(t)}),p=G(()=>({register:l,unregister:r,portals:o}),[l,r,o]);return[o,G(()=>function({children:n}){return i.createElement(m.Provider,{value:p},n)},[p])]}let J=f(S),X=f(D),te=Object.assign(J,{Group:X});export{te as Portal,X as PortalGroup,ee as useNestedPortals};\n","\"use client\";import l,{Fragment as $,createContext as pe,createRef as se,useCallback as de,useContext as ue,useEffect as Te,useMemo as fe,useReducer as ge,useRef as j}from\"react\";import{useEscape as ce}from'../../hooks/use-escape.js';import{useEvent as A}from'../../hooks/use-event.js';import{useId as k}from'../../hooks/use-id.js';import{useInertOthers as me}from'../../hooks/use-inert-others.js';import{useIsTouchDevice as De}from'../../hooks/use-is-touch-device.js';import{useIsoMorphicEffect as Pe}from'../../hooks/use-iso-morphic-effect.js';import{useOnDisappear as ye}from'../../hooks/use-on-disappear.js';import{useOutsideClick as Ee}from'../../hooks/use-outside-click.js';import{useOwnerDocument as Ae}from'../../hooks/use-owner.js';import{MainTreeProvider as Y,useMainTreeNode as _e,useRootContainers as Ce}from'../../hooks/use-root-containers.js';import{useScrollLock as Re}from'../../hooks/use-scroll-lock.js';import{useServerHandoffComplete as Fe}from'../../hooks/use-server-handoff-complete.js';import{useSlot as L}from'../../hooks/use-slot.js';import{useSyncRefs as G}from'../../hooks/use-sync-refs.js';import{CloseProvider as be}from'../../internal/close-provider.js';import{ResetOpenClosedProvider as ve,State as x,useOpenClosed as J}from'../../internal/open-closed.js';import{ForcePortalRoot as K}from'../../internal/portal-force-root.js';import{stackMachines as Le}from'../../machines/stack-machine.js';import{useSlice as xe}from'../../react-glue.js';import{match as he}from'../../utils/match.js';import{RenderFeatures as X,forwardRefWithAs as _,useRender as h}from'../../utils/render.js';import{Description as V,useDescriptions as Oe}from'../description/description.js';import{FocusTrap as Se,FocusTrapFeatures as C}from'../focus-trap/focus-trap.js';import{Portal as Ie,PortalGroup as Me,useNestedPortals as ke}from'../portal/portal.js';import{Transition as Ge,TransitionChild as q}from'../transition/transition.js';var we=(o=>(o[o.Open=0]=\"Open\",o[o.Closed=1]=\"Closed\",o))(we||{}),Be=(t=>(t[t.SetTitleId=0]=\"SetTitleId\",t))(Be||{});let Ue={[0](e,t){return e.titleId===t.id?e:{...e,titleId:t.id}}},w=pe(null);w.displayName=\"DialogContext\";function O(e){let t=ue(w);if(t===null){let o=new Error(`<${e} /> is missing a parent <Dialog /> component.`);throw Error.captureStackTrace&&Error.captureStackTrace(o,O),o}return t}function He(e,t){return he(t.type,Ue,e,t)}let z=_(function(t,o){let a=k(),{id:n=`headlessui-dialog-${a}`,open:i,onClose:p,initialFocus:d,role:s=\"dialog\",autoFocus:f=!0,__demoMode:u=!1,unmount:y=!1,...S}=t,R=j(!1);s=function(){return s===\"dialog\"||s===\"alertdialog\"?s:(R.current||(R.current=!0,console.warn(`Invalid role [${s}] passed to <Dialog />. Only \\`dialog\\` and and \\`alertdialog\\` are supported. Using \\`dialog\\` instead.`)),\"dialog\")}();let g=J();i===void 0&&g!==null&&(i=(g&x.Open)===x.Open);let T=j(null),I=G(T,o),F=Ae(T.current),c=i?0:1,[b,Q]=ge(He,{titleId:null,descriptionId:null,panelRef:se()}),m=A(()=>p(!1)),B=A(r=>Q({type:0,id:r})),D=Fe()?c===0:!1,[Z,ee]=ke(),te={get current(){var r;return(r=b.panelRef.current)!=null?r:T.current}},v=_e(),{resolveContainers:M}=Ce({mainTreeNode:v,portals:Z,defaultContainers:[te]}),U=g!==null?(g&x.Closing)===x.Closing:!1;me(u||U?!1:D,{allowed:A(()=>{var r,W;return[(W=(r=T.current)==null?void 0:r.closest(\"[data-headlessui-portal]\"))!=null?W:null]}),disallowed:A(()=>{var r;return[(r=v==null?void 0:v.closest(\"body > *:not(#headlessui-portal-root)\"))!=null?r:null]})});let P=Le.get(null);Pe(()=>{if(D)return P.actions.push(n),()=>P.actions.pop(n)},[P,n,D]);let H=xe(P,de(r=>P.selectors.isTop(r,n),[P,n]));Ee(H,M,r=>{r.preventDefault(),m()}),ce(H,F==null?void 0:F.defaultView,r=>{r.preventDefault(),r.stopPropagation(),document.activeElement&&\"blur\"in document.activeElement&&typeof document.activeElement.blur==\"function\"&&document.activeElement.blur(),m()}),Re(u||U?!1:D,F,M),ye(D,T,m);let[oe,ne]=Oe(),re=fe(()=>[{dialogState:c,close:m,setTitleId:B,unmount:y},b],[c,m,B,y,b]),N=L({open:c===0}),le={ref:I,id:n,role:s,tabIndex:-1,\"aria-modal\":u?void 0:c===0?!0:void 0,\"aria-labelledby\":b.titleId,\"aria-describedby\":oe,unmount:y},ae=!De(),E=C.None;D&&!u&&(E|=C.RestoreFocus,E|=C.TabLock,f&&(E|=C.AutoFocus),ae&&(E|=C.InitialFocus));let ie=h();return l.createElement(ve,null,l.createElement(K,{force:!0},l.createElement(Ie,null,l.createElement(w.Provider,{value:re},l.createElement(Me,{target:T},l.createElement(K,{force:!1},l.createElement(ne,{slot:N},l.createElement(ee,null,l.createElement(Se,{initialFocus:d,initialFocusFallback:T,containers:M,features:E},l.createElement(be,{value:m},ie({ourProps:le,theirProps:S,slot:N,defaultTag:Ne,features:We,visible:c===0,name:\"Dialog\"})))))))))))}),Ne=\"div\",We=X.RenderStrategy|X.Static;function $e(e,t){let{transition:o=!1,open:a,...n}=e,i=J(),p=e.hasOwnProperty(\"open\")||i!==null,d=e.hasOwnProperty(\"onClose\");if(!p&&!d)throw new Error(\"You have to provide an `open` and an `onClose` prop to the `Dialog` component.\");if(!p)throw new Error(\"You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.\");if(!d)throw new Error(\"You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.\");if(!i&&typeof e.open!=\"boolean\")throw new Error(`You provided an \\`open\\` prop to the \\`Dialog\\`, but the value is not a boolean. Received: ${e.open}`);if(typeof e.onClose!=\"function\")throw new Error(`You provided an \\`onClose\\` prop to the \\`Dialog\\`, but the value is not a function. Received: ${e.onClose}`);return(a!==void 0||o)&&!n.static?l.createElement(Y,null,l.createElement(Ge,{show:a,transition:o,unmount:n.unmount},l.createElement(z,{ref:t,...n}))):l.createElement(Y,null,l.createElement(z,{ref:t,open:a,...n}))}let je=\"div\";function Ye(e,t){let o=k(),{id:a=`headlessui-dialog-panel-${o}`,transition:n=!1,...i}=e,[{dialogState:p,unmount:d},s]=O(\"Dialog.Panel\"),f=G(t,s.panelRef),u=L({open:p===0}),y=A(I=>{I.stopPropagation()}),S={ref:f,id:a,onClick:y},R=n?q:$,g=n?{unmount:d}:{},T=h();return l.createElement(R,{...g},T({ourProps:S,theirProps:i,slot:u,defaultTag:je,name:\"Dialog.Panel\"}))}let Je=\"div\";function Ke(e,t){let{transition:o=!1,...a}=e,[{dialogState:n,unmount:i}]=O(\"Dialog.Backdrop\"),p=L({open:n===0}),d={ref:t,\"aria-hidden\":!0},s=o?q:$,f=o?{unmount:i}:{},u=h();return l.createElement(s,{...f},u({ourProps:d,theirProps:a,slot:p,defaultTag:Je,name:\"Dialog.Backdrop\"}))}let Xe=\"h2\";function Ve(e,t){let o=k(),{id:a=`headlessui-dialog-title-${o}`,...n}=e,[{dialogState:i,setTitleId:p}]=O(\"Dialog.Title\"),d=G(t);Te(()=>(p(a),()=>p(null)),[a,p]);let s=L({open:i===0}),f={ref:d,id:a};return h()({ourProps:f,theirProps:n,slot:s,defaultTag:Xe,name:\"Dialog.Title\"})}let qe=_($e),ze=_(Ye),Lt=_(Ke),Qe=_(Ve),xt=V,ht=Object.assign(qe,{Panel:ze,Title:Qe,Description:V});export{ht as Dialog,Lt as DialogBackdrop,xt as DialogDescription,ze as DialogPanel,Qe as DialogTitle};\n","const a={path:\"/api/v1/mfa_auth/passkeys/init\",method:\"POST\"},t={path:\"/api/v1/mfa_auth/passkeys/verify\",method:\"POST\"},e={path:\"/api/v1/mfa_auth/passkeys/enrollment\",method:\"POST\"};export{e as MfaAuthPasskeyEnrollment,a as MfaAuthPasskeyInit,t as MfaAuthPasskeyVerify};\n","const t={path:\"/api/v1/mfa_auth/totp/enroll\",method:\"POST\"},a={path:\"/api/v1/mfa_auth/totp/verify\",method:\"POST\"},p={path:\"/api/v1/mfa_auth/totp/init\",method:\"POST\"},h={path:\"/api/v1/mfa_auth/totp/unenroll\",method:\"POST\"};export{t as MfaAuthTotpEnroll,p as MfaAuthTotpInit,h as MfaAuthTotpUnenroll,a as MfaAuthTotpVerify};\n","var __defProp = Object.defineProperty;\nvar __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\") return require.apply(this, arguments);\n  throw Error('Dynamic require of \"' + x + '\" is not supported');\n});\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/types/shared/evm/config.ts\nvar config = {\n  \"84532\": {\n    usdcAddress: \"0x036CbD53842c5426634e7929541eC2318f3dCF7e\",\n    usdcName: \"USDC\"\n  },\n  \"8453\": {\n    usdcAddress: \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\",\n    usdcName: \"USD Coin\"\n  },\n  \"43113\": {\n    usdcAddress: \"0x5425890298aed601595a70AB815c96711a31Bc65\",\n    usdcName: \"USD Coin\"\n  },\n  \"43114\": {\n    usdcAddress: \"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E\",\n    usdcName: \"USD Coin\"\n  },\n  \"4689\": {\n    usdcAddress: \"0xcdf79194c6c285077a58da47641d4dbe51f63542\",\n    usdcName: \"Bridged USDC\"\n  },\n  // solana devnet\n  \"103\": {\n    usdcAddress: \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\",\n    usdcName: \"USDC\"\n  },\n  // solana mainnet\n  \"101\": {\n    usdcAddress: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n    usdcName: \"USDC\"\n  },\n  \"1328\": {\n    usdcAddress: \"0x4fcf1784b31630811181f670aea7a7bef803eaed\",\n    usdcName: \"USDC\"\n  },\n  \"1329\": {\n    usdcAddress: \"0xe15fc38f6d8c56af07bbcbe3baf5708a2bf42392\",\n    usdcName: \"USDC\"\n  },\n  \"137\": {\n    usdcAddress: \"0x3c499c542cef5e3811e1192ce70d8cc03d5c3359\",\n    usdcName: \"USD Coin\"\n  },\n  \"80002\": {\n    usdcAddress: \"0x41E94Eb019C0762f9Bfcf9Fb1E58725BfB0e7582\",\n    usdcName: \"USDC\"\n  },\n  \"3338\": {\n    usdcAddress: \"0xbbA60da06c2c5424f03f7434542280FCAd453d10\",\n    usdcName: \"USDC\"\n  },\n  \"2741\": {\n    usdcAddress: \"0x84a71ccd554cc1b02749b35d22f684cc8ec987e1\",\n    usdcName: \"Bridged USDC\"\n  },\n  \"11124\": {\n    usdcAddress: \"0xe4C7fBB0a626ed208021ccabA6Be1566905E2dFc\",\n    usdcName: \"Bridged USDC\"\n  },\n  \"1514\": {\n    usdcAddress: \"0xF1815bd50389c46847f0Bda824eC8da914045D14\",\n    usdcName: \"Bridged USDC\"\n  },\n  \"41923\": {\n    usdcAddress: \"0x12a272A581feE5577A5dFa371afEB4b2F3a8C2F8\",\n    usdcName: \"Bridged USDC (Stargate)\"\n  },\n  \"324705682\": {\n    usdcAddress: \"0x2e08028E3C4c2356572E096d8EF835cD5C6030bD\",\n    usdcName: \"Bridged USDC (SKALE Bridge)\"\n  }\n};\n\nexport {\n  __require,\n  __export,\n  config\n};\n//# sourceMappingURL=chunk-EMSAO3AI.mjs.map","import crypto from 'crypto';\nexport default {\n  randomUUID: crypto.randomUUID\n};","function o(e){return typeof e!=\"object\"||e===null?!1:\"nodeType\"in e}function t(e){return o(e)&&\"tagName\"in e}function n(e){return t(e)&&\"accessKey\"in e}function i(e){return t(e)&&\"tabIndex\"in e}function r(e){return t(e)&&\"style\"in e}function u(e){return n(e)&&e.nodeName===\"IFRAME\"}function l(e){return n(e)&&e.nodeName===\"INPUT\"}function s(e){return n(e)&&e.nodeName===\"TEXTAREA\"}function m(e){return n(e)&&e.nodeName===\"LABEL\"}function a(e){return n(e)&&e.nodeName===\"FIELDSET\"}function E(e){return n(e)&&e.nodeName===\"LEGEND\"}function L(e){return t(e)?e.matches('a[href],audio[controls],button,details,embed,iframe,img[usemap],input:not([type=\"hidden\"]),label,select,textarea,video[controls]'):!1}export{r as hasInlineStyle,t as isElement,n as isHTMLElement,a as isHTMLFieldSetElement,u as isHTMLIframeElement,l as isHTMLInputElement,m as isHTMLLabelElement,E as isHTMLLegendElement,s as isHTMLTextAreaElement,i as isHTMLorSVGElement,L as isInteractiveElement,o as isNode};\n","export const weakMap = new WeakMap();\nconst getLength = (buf, index) => {\n    let len = buf.readUInt8(1);\n    if ((len & 0x80) === 0) {\n        if (index === 0) {\n            return len;\n        }\n        return getLength(buf.subarray(2 + len), index - 1);\n    }\n    const num = len & 0x7f;\n    len = 0;\n    for (let i = 0; i < num; i++) {\n        len <<= 8;\n        const j = buf.readUInt8(2 + i);\n        len |= j;\n    }\n    if (index === 0) {\n        return len;\n    }\n    return getLength(buf.subarray(2 + len), index - 1);\n};\nconst getLengthOfSeqIndex = (sequence, index) => {\n    const len = sequence.readUInt8(1);\n    if ((len & 0x80) === 0) {\n        return getLength(sequence.subarray(2), index);\n    }\n    const num = len & 0x7f;\n    return getLength(sequence.subarray(2 + num), index);\n};\nconst getModulusLength = (key) => {\n    var _a, _b;\n    if (weakMap.has(key)) {\n        return weakMap.get(key);\n    }\n    const modulusLength = (_b = (_a = key.asymmetricKeyDetails) === null || _a === void 0 ? void 0 : _a.modulusLength) !== null && _b !== void 0 ? _b : (getLengthOfSeqIndex(key.export({ format: 'der', type: 'pkcs1' }), key.type === 'private' ? 1 : 0) -\n        1) <<\n        3;\n    weakMap.set(key, modulusLength);\n    return modulusLength;\n};\nexport const setModulusLength = (keyObject, modulusLength) => {\n    weakMap.set(keyObject, modulusLength);\n};\nexport default (key, alg) => {\n    if (getModulusLength(key) < 2048) {\n        throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);\n    }\n};\n","export var util;\n(function (util) {\n    util.assertEqual = (_) => { };\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && Number.isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array.map((val) => (typeof val === \"string\" ? `'${val}'` : val)).join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nexport var objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nexport const ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nexport const getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\n","export var errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    // biome-ignore lint:\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message?.message;\n})(errorUtil || (errorUtil = {}));\n","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","export default (date) => Math.floor(date.getTime() / 1000);\n","export default 'node:crypto';\n","import{env as t}from'./env.js';function l(n){var u;return t.isServer?null:n==null?document:(u=n==null?void 0:n.ownerDocument)!=null?u:document}function r(n){var u,o;return t.isServer?null:n==null?document:(o=(u=n==null?void 0:n.getRootNode)==null?void 0:u.call(n))!=null?o:document}function e(n){var u,o;return(o=(u=r(n))==null?void 0:u.activeElement)!=null?o:null}function d(n){return e(n)===n}export{e as getActiveElement,l as getOwnerDocument,r as getRootNode,d as isActiveElement};\n","import{useMemo as t}from\"react\";function n(e){return t(()=>e,Object.values(e))}export{n as useSlot};\n","import{options as n}from\"preact\";var t,r,u,i,o=0,f=[],c=n,e=c.__b,a=c.__r,v=c.diffed,l=c.__c,m=c.unmount,s=c.__;function p(n,t){c.__h&&c.__h(r,n,o||t),o=0;var u=r.__H||(r.__H={__:[],__h:[]});return n>=u.__.length&&u.__.push({}),u.__[n]}function d(n){return o=1,h(D,n)}function h(n,u,i){var o=p(t++,2);if(o.t=n,!o.__c&&(o.__=[i?i(u):D(void 0,u),function(n){var t=o.__N?o.__N[0]:o.__[0],r=o.t(t,n);t!==r&&(o.__N=[r,o.__[1]],o.__c.setState({}))}],o.__c=r,!r.__f)){var f=function(n,t,r){if(!o.__c.__H)return!0;var u=o.__c.__H.__.filter(function(n){return!!n.__c});if(u.every(function(n){return!n.__N}))return!c||c.call(this,n,t,r);var i=o.__c.props!==n;return u.forEach(function(n){if(n.__N){var t=n.__[0];n.__=n.__N,n.__N=void 0,t!==n.__[0]&&(i=!0)}}),c&&c.call(this,n,t,r)||i};r.__f=!0;var c=r.shouldComponentUpdate,e=r.componentWillUpdate;r.componentWillUpdate=function(n,t,r){if(this.__e){var u=c;c=void 0,f(n,t,r),c=u}e&&e.call(this,n,t,r)},r.shouldComponentUpdate=f}return o.__N||o.__}function y(n,u){var i=p(t++,3);!c.__s&&C(i.__H,u)&&(i.__=n,i.u=u,r.__H.__h.push(i))}function _(n,u){var i=p(t++,4);!c.__s&&C(i.__H,u)&&(i.__=n,i.u=u,r.__h.push(i))}function A(n){return o=5,T(function(){return{current:n}},[])}function F(n,t,r){o=6,_(function(){if(\"function\"==typeof n){var r=n(t());return function(){n(null),r&&\"function\"==typeof r&&r()}}if(n)return n.current=t(),function(){return n.current=null}},null==r?r:r.concat(n))}function T(n,r){var u=p(t++,7);return C(u.__H,r)&&(u.__=n(),u.__H=r,u.__h=n),u.__}function q(n,t){return o=8,T(function(){return n},t)}function x(n){var u=r.context[n.__c],i=p(t++,9);return i.c=n,u?(null==i.__&&(i.__=!0,u.sub(r)),u.props.value):n.__}function P(n,t){c.useDebugValue&&c.useDebugValue(t?t(n):n)}function b(n){var u=p(t++,10),i=d();return u.__=n,r.componentDidCatch||(r.componentDidCatch=function(n,t){u.__&&u.__(n,t),i[1](n)}),[i[0],function(){i[1](void 0)}]}function g(){var n=p(t++,11);if(!n.__){for(var u=r.__v;null!==u&&!u.__m&&null!==u.__;)u=u.__;var i=u.__m||(u.__m=[0,0]);n.__=\"P\"+i[0]+\"-\"+i[1]++}return n.__}function j(){for(var n;n=f.shift();)if(n.__P&&n.__H)try{n.__H.__h.forEach(z),n.__H.__h.forEach(B),n.__H.__h=[]}catch(t){n.__H.__h=[],c.__e(t,n.__v)}}c.__b=function(n){r=null,e&&e(n)},c.__=function(n,t){n&&t.__k&&t.__k.__m&&(n.__m=t.__k.__m),s&&s(n,t)},c.__r=function(n){a&&a(n),t=0;var i=(r=n.__c).__H;i&&(u===r?(i.__h=[],r.__h=[],i.__.forEach(function(n){n.__N&&(n.__=n.__N),n.u=n.__N=void 0})):(i.__h.forEach(z),i.__h.forEach(B),i.__h=[],t=0)),u=r},c.diffed=function(n){v&&v(n);var t=n.__c;t&&t.__H&&(t.__H.__h.length&&(1!==f.push(t)&&i===c.requestAnimationFrame||((i=c.requestAnimationFrame)||w)(j)),t.__H.__.forEach(function(n){n.u&&(n.__H=n.u),n.u=void 0})),u=r=null},c.__c=function(n,t){t.some(function(n){try{n.__h.forEach(z),n.__h=n.__h.filter(function(n){return!n.__||B(n)})}catch(r){t.some(function(n){n.__h&&(n.__h=[])}),t=[],c.__e(r,n.__v)}}),l&&l(n,t)},c.unmount=function(n){m&&m(n);var t,r=n.__c;r&&r.__H&&(r.__H.__.forEach(function(n){try{z(n)}catch(n){t=n}}),r.__H=void 0,t&&c.__e(t,r.__v))};var k=\"function\"==typeof requestAnimationFrame;function w(n){var t,r=function(){clearTimeout(u),k&&cancelAnimationFrame(t),setTimeout(n)},u=setTimeout(r,35);k&&(t=requestAnimationFrame(r))}function z(n){var t=r,u=n.__c;\"function\"==typeof u&&(n.__c=void 0,u()),r=t}function B(n){var t=r;n.__c=n.__(),r=t}function C(n,t){return!n||n.length!==t.length||t.some(function(t,r){return t!==n[r]})}function D(n,t){return\"function\"==typeof t?t(n):t}export{q as useCallback,x as useContext,P as useDebugValue,y as useEffect,b as useErrorBoundary,g as useId,F as useImperativeHandle,_ as useLayoutEffect,T as useMemo,h as useReducer,A as useRef,d as useState};\n//# sourceMappingURL=hooks.module.js.map\n","import{microTask as a}from'./micro-task.js';function o(){let s=[],r={addEventListener(e,t,n,i){return e.addEventListener(t,n,i),r.add(()=>e.removeEventListener(t,n,i))},requestAnimationFrame(...e){let t=requestAnimationFrame(...e);return r.add(()=>cancelAnimationFrame(t))},nextFrame(...e){return r.requestAnimationFrame(()=>r.requestAnimationFrame(...e))},setTimeout(...e){let t=setTimeout(...e);return r.add(()=>clearTimeout(t))},microTask(...e){let t={current:!0};return a(()=>{t.current&&e[0]()}),r.add(()=>{t.current=!1})},style(e,t,n){let i=e.style.getPropertyValue(t);return Object.assign(e.style,{[t]:n}),this.add(()=>{Object.assign(e.style,{[t]:i})})},group(e){let t=o();return e(t),this.add(()=>t.dispose())},add(e){return s.includes(e)||s.push(e),()=>{let t=s.indexOf(e);if(t>=0)for(let n of s.splice(t,1))n()}},dispose(){for(let e of s.splice(0))e()}};return r}export{o as disposables};\n","import{useSyncExternalStore as e}from\"react\";function o(t){return e(t.subscribe,t.getSnapshot,t.getSnapshot)}export{o as useStore};\n","import{WalletUpdate as r}from\"@privy-io/routes\";import{generateAuthorizationSignature as a}from\"./generate-authorization-signature.mjs\";import\"canonicalize\";import\"../Error.mjs\";async function t(t,{wallet_id:i},e,o){let p={version:1,url:t.getCompiledPath(r,{params:{wallet_id:i}}),method:r.method,headers:{\"privy-app-id\":t.app.appId},body:o},{signature:m}=await a(e,p);return await t.fetchPrivyRoute(r,{params:{wallet_id:i},body:o,headers:{\"privy-authorization-signature\":m}})}export{t as updateWallet};\n","import{useCallback as t,useState as b}from\"react\";function c(u=0){let[r,a]=b(u),g=t(e=>a(e),[]),s=t(e=>a(l=>l|e),[]),m=t(e=>(r&e)===e,[r]),n=t(e=>a(l=>l&~e),[]),F=t(e=>a(l=>l^e),[]);return{flags:r,setFlag:g,addFlag:s,hasFlag:m,removeFlag:n,toggleFlag:F}}export{c as useFlags};\n","import t,{createContext as r,useContext as c}from\"react\";let e=r(!1);function a(){return c(e)}function l(o){return t.createElement(e.Provider,{value:o.force},o.children)}export{l as ForcePortalRoot,a as usePortalRoot};\n","import n,{createContext as r,useContext as i}from\"react\";let e=r(void 0);function a(){return i(e)}function l({value:t,children:o}){return n.createElement(e.Provider,{value:t},o)}export{l as DisabledProvider,a as useDisabled};\n","import r,{createContext as l,useContext as d}from\"react\";let n=l(null);n.displayName=\"OpenClosedContext\";var i=(e=>(e[e.Open=1]=\"Open\",e[e.Closed=2]=\"Closed\",e[e.Closing=4]=\"Closing\",e[e.Opening=8]=\"Opening\",e))(i||{});function u(){return d(n)}function c({value:o,children:t}){return r.createElement(n.Provider,{value:o},t)}function s({children:o}){return r.createElement(n.Provider,{value:null},o)}export{c as OpenClosedProvider,s as ResetOpenClosedProvider,i as State,u as useOpenClosed};\n","import*as t from\"react\";import{env as f}from'../utils/env.js';function s(){let r=typeof document==\"undefined\";return\"useSyncExternalStore\"in t?(o=>o.useSyncExternalStore)(t)(()=>()=>{},()=>!1,()=>!r):!1}function l(){let r=s(),[e,n]=t.useState(f.isHandoffComplete);return e&&f.isHandoffComplete===!1&&n(!1),t.useEffect(()=>{e!==!0&&n(!0)},[e]),t.useEffect(()=>f.handoff(),[]),r?!1:e}export{l as useServerHandoffComplete};\n","import{forwardRefWithAs as i,useRender as p}from'../utils/render.js';let a=\"span\";var s=(e=>(e[e.None=1]=\"None\",e[e.Focusable=2]=\"Focusable\",e[e.Hidden=4]=\"Hidden\",e))(s||{});function l(t,r){var n;let{features:d=1,...e}=t,o={ref:r,\"aria-hidden\":(d&2)===2?!0:(n=e[\"aria-hidden\"])!=null?n:void 0,hidden:(d&4)===4?!0:void 0,style:{position:\"fixed\",top:1,left:1,width:1,height:0,padding:0,margin:-1,overflow:\"hidden\",clip:\"rect(0, 0, 0, 0)\",whiteSpace:\"nowrap\",borderWidth:\"0\",...(d&4)===4&&(d&2)!==2&&{display:\"none\"}}};return p()({ourProps:o,theirProps:e,slot:{},defaultTag:a,name:\"Hidden\"})}let f=i(l);export{f as Hidden,s as HiddenFeatures};\n","import a from\"react\";import{useLatestValue as n}from'./use-latest-value.js';let o=function(t){let e=n(t);return a.useCallback((...r)=>e.current(...r),[e])};export{o as useEvent};\n","import{useRef as o}from\"react\";import{useWindowEvent as t}from'./use-window-event.js';var a=(r=>(r[r.Forwards=0]=\"Forwards\",r[r.Backwards=1]=\"Backwards\",r))(a||{});function u(){let e=o(0);return t(!0,\"keydown\",r=>{r.key===\"Tab\"&&(e.current=r.shiftKey?1:0)},!0),e}export{a as Direction,u as useTabDirection};\n","import{useEffect as f,useRef as s}from\"react\";import{useEvent as i}from'./use-event.js';function m(u,t){let e=s([]),r=i(u);f(()=>{let o=[...e.current];for(let[a,l]of t.entries())if(e.current[a]!==l){let n=r(t,o);return e.current=t,n}},[r,...t])}export{m as useWatch};\n","import{useEffect as l,useRef as i}from\"react\";import{useEvent as r}from'./use-event.js';let u=Symbol();function T(t,n=!0){return Object.assign(t,{[u]:n})}function y(...t){let n=i(t);l(()=>{n.current=t},[t]);let c=r(e=>{for(let o of n.current)o!=null&&(typeof o==\"function\"?o(e):o.current=e)});return t.every(e=>e==null||(e==null?void 0:e[u]))?void 0:c}export{T as optionalRef,y as useSyncRefs};\n","import{useEffect as d}from\"react\";import{useLatestValue as s}from'./use-latest-value.js';function E(n,e,a,t){let i=s(a);d(()=>{n=n!=null?n:window;function r(o){i.current(o)}return n.addEventListener(e,r,t),()=>n.removeEventListener(e,r,t)},[n,e,t])}export{E as useEventListener};\n","import{useEffect as c}from\"react\";import{useLatestValue as a}from'./use-latest-value.js';function i(t,e,o,n){let u=a(o);c(()=>{if(!t)return;function r(m){u.current(m)}return document.addEventListener(e,r,n),()=>document.removeEventListener(e,r,n)},[t,e,n])}export{i as useDocumentEvent};\n","import{useEffect as a}from\"react\";import{useLatestValue as f}from'./use-latest-value.js';function s(t,e,o,n){let i=f(o);a(()=>{if(!t)return;function r(d){i.current(d)}return window.addEventListener(e,r,n),()=>window.removeEventListener(e,r,n)},[t,e,n])}export{s as useWindowEvent};\n","import{useEffect as f,useLayoutEffect as c}from\"react\";import{env as i}from'../utils/env.js';let n=(e,t)=>{i.isServer?f(e,t):c(e,t)};export{n as useIsoMorphicEffect};\n","import{useRef as r}from\"react\";import{useIsoMorphicEffect as t}from'./use-iso-morphic-effect.js';function f(){let e=r(!1);return t(()=>(e.current=!0,()=>{e.current=!1}),[]),e}export{f as useIsMounted};\n","import{useRef as t}from\"react\";import{useIsoMorphicEffect as o}from'./use-iso-morphic-effect.js';function s(e){let r=t(e);return o(()=>{r.current=e},[e]),r}export{s as useLatestValue};\n","import{useState as i}from\"react\";import{useIsoMorphicEffect as s}from'./use-iso-morphic-effect.js';function f(){var t;let[e]=i(()=>typeof window!=\"undefined\"&&typeof window.matchMedia==\"function\"?window.matchMedia(\"(pointer: coarse)\"):null),[o,c]=i((t=e==null?void 0:e.matches)!=null?t:!1);return s(()=>{if(!e)return;function n(r){c(r.matches)}return e.addEventListener(\"change\",n),()=>e.removeEventListener(\"change\",n)},[e]),o}export{f as useIsTouchDevice};\n","import{useMemo as o}from\"react\";import{getOwnerDocument as t,getRootNode as r}from'../utils/owner.js';function u(...e){return o(()=>t(...e),[...e])}function c(...e){return o(()=>r(...e),[...e])}export{u as useOwnerDocument,c as useRootDocument};\n","import{useEffect as s,useState as o}from\"react\";import{disposables as t}from'../utils/disposables.js';function p(){let[e]=o(t);return s(()=>()=>e.dispose(),[e]),e}export{p as useDisposables};\n","import{a as t,f as s}from\"./internal-context-e-Eni5bG.mjs\";import{a5 as i,a6 as a}from\"./paths-3HW55qZg.mjs\";class e{async init(){if(!this.api)throw new t(\"Auth flow has no API instance\");let{nonce:s,expires_at:a}=await this.api.post(i,{});return{nonce:s,expiresAt:a}}async authenticate(){if(!this.message||!this.signature||!this.fid)throw new t(\"Auth flow has no message, signature, or fid\");if(!this.api)throw new t(\"Auth flow has no API instance\");try{let s=await this.api.post(a,{message:this.message,signature:this.signature,fid:this.fid});if(!s)throw new t(\"No response from authentication\");return s}catch(t){throw s(t)}}async link(){throw Error(\"Not implemented\")}setAuthData({message:t,signature:s,fid:i}){this.message=t,this.signature=s,this.fid=i}constructor(){this.meta={}}}export{e as F};\n","import{useEffect as u,useRef as n}from\"react\";import{microTask as o}from'../utils/micro-task.js';import{useEvent as f}from'./use-event.js';function c(t){let r=f(t),e=n(!1);u(()=>(e.current=!1,()=>{e.current=!0,o(()=>{e.current&&r()})}),[r])}export{c as useOnUnmount};\n","import{onDocumentReady as d}from'./document-ready.js';import*as u from'./dom.js';import{focusableSelector as i}from'./focus-management.js';let n=[];d(()=>{function e(t){if(!u.isHTMLorSVGElement(t.target)||t.target===document.body||n[0]===t.target)return;let r=t.target;r=r.closest(i),n.unshift(r!=null?r:t.target),n=n.filter(o=>o!=null&&o.isConnected),n.splice(10)}window.addEventListener(\"click\",e,{capture:!0}),window.addEventListener(\"mousedown\",e,{capture:!0}),window.addEventListener(\"focus\",e,{capture:!0}),document.body.addEventListener(\"click\",e,{capture:!0}),document.body.addEventListener(\"mousedown\",e,{capture:!0}),document.body.addEventListener(\"focus\",e,{capture:!0})});export{n as history};\n","import{disposables as u}from'../../utils/disposables.js';import*as i from'../../utils/dom.js';import{isIOS as p}from'../../utils/platform.js';function w(){return p()?{before({doc:o,d:r,meta:m}){function a(s){for(let l of m().containers)for(let c of l())if(c.contains(s))return!0;return!1}r.microTask(()=>{var c;if(window.getComputedStyle(o.documentElement).scrollBehavior!==\"auto\"){let t=u();t.style(o.documentElement,\"scrollBehavior\",\"auto\"),r.add(()=>r.microTask(()=>t.dispose()))}let s=(c=window.scrollY)!=null?c:window.pageYOffset,l=null;r.addEventListener(o,\"click\",t=>{if(i.isHTMLorSVGElement(t.target))try{let e=t.target.closest(\"a\");if(!e)return;let{hash:n}=new URL(e.href),f=o.querySelector(n);i.isHTMLorSVGElement(f)&&!a(f)&&(l=f)}catch{}},!0),r.group(t=>{r.addEventListener(o,\"touchstart\",e=>{if(t.dispose(),i.isHTMLorSVGElement(e.target)&&i.hasInlineStyle(e.target))if(a(e.target)){let n=e.target;for(;n.parentElement&&a(n.parentElement);)n=n.parentElement;t.style(n,\"overscrollBehavior\",\"contain\")}else t.style(e.target,\"touchAction\",\"none\")})}),r.addEventListener(o,\"touchmove\",t=>{if(i.isHTMLorSVGElement(t.target)){if(i.isHTMLInputElement(t.target))return;if(a(t.target)){let e=t.target;for(;e.parentElement&&e.dataset.headlessuiPortal!==\"\"&&!(e.scrollHeight>e.clientHeight||e.scrollWidth>e.clientWidth);)e=e.parentElement;e.dataset.headlessuiPortal===\"\"&&t.preventDefault()}else t.preventDefault()}},{passive:!1}),r.add(()=>{var e;let t=(e=window.scrollY)!=null?e:window.pageYOffset;s!==t&&window.scrollTo(0,s),l&&l.isConnected&&(l.scrollIntoView({block:\"nearest\"}),l=null)})})}}:{}}export{w as handleIOSLocking};\n","import{useDocumentOverflowLockedEffect as l}from'./document-overflow/use-document-overflow.js';import{useIsTopLayer as m}from'./use-is-top-layer.js';function f(e,c,n=()=>[document.body]){let r=m(e,\"scroll-lock\");l(r,c,t=>{var o;return{containers:[...(o=t.containers)!=null?o:[],n]}})}export{f as useScrollLock};\n","import{Keys as u}from'../components/keyboard.js';import{useEventListener as i}from'./use-event-listener.js';import{useIsTopLayer as f}from'./use-is-top-layer.js';function a(o,r=typeof document!=\"undefined\"?document.defaultView:null,t){let n=f(o,\"escape\");i(r,\"keydown\",e=>{n&&(e.defaultPrevented||e.key===u.Escape&&t(e))})}export{a as useEscape};\n","import{useStore as s}from'../../hooks/use-store.js';import{useIsoMorphicEffect as u}from'../use-iso-morphic-effect.js';import{overflows as t}from'./overflow-store.js';function a(r,e,n=()=>({containers:[]})){let f=s(t),o=e?f.get(e):void 0,i=o?o.count>0:!1;return u(()=>{if(!(!e||!r))return t.dispatch(\"PUSH\",e,n),()=>t.dispatch(\"POP\",e,n)},[r,e]),i}export{a as useDocumentOverflowLockedEffect};\n","import{useEffect as l}from\"react\";import{disposables as u}from'../utils/disposables.js';import*as c from'../utils/dom.js';import{useLatestValue as d}from'./use-latest-value.js';function p(s,n,o){let i=d(t=>{let e=t.getBoundingClientRect();e.x===0&&e.y===0&&e.width===0&&e.height===0&&o()});l(()=>{if(!s)return;let t=n===null?null:c.isHTMLElement(n)?n:n.current;if(!t)return;let e=u();if(typeof ResizeObserver!=\"undefined\"){let r=new ResizeObserver(()=>i.current(t));r.observe(t),e.add(()=>r.disconnect())}if(typeof IntersectionObserver!=\"undefined\"){let r=new IntersectionObserver(()=>i.current(t));r.observe(t),e.add(()=>r.disconnect())}return()=>e.dispose()},[n,i,s])}export{p as useOnDisappear};\n","import{disposables as p}from'./disposables.js';import*as y from'./dom.js';import{match as L}from'./match.js';import{getActiveElement as b,getOwnerDocument as F,getRootNode as f}from'./owner.js';let E=[\"[contentEditable=true]\",\"[tabindex]\",\"a[href]\",\"area[href]\",\"button:not([disabled])\",\"iframe\",\"input:not([disabled])\",\"select:not([disabled])\",\"details>summary\",\"textarea:not([disabled])\"].map(e=>`${e}:not([tabindex='-1'])`).join(\",\"),S=[\"[data-autofocus]\"].map(e=>`${e}:not([tabindex='-1'])`).join(\",\");var T=(o=>(o[o.First=1]=\"First\",o[o.Previous=2]=\"Previous\",o[o.Next=4]=\"Next\",o[o.Last=8]=\"Last\",o[o.WrapAround=16]=\"WrapAround\",o[o.NoScroll=32]=\"NoScroll\",o[o.AutoFocus=64]=\"AutoFocus\",o))(T||{}),A=(n=>(n[n.Error=0]=\"Error\",n[n.Overflow=1]=\"Overflow\",n[n.Success=2]=\"Success\",n[n.Underflow=3]=\"Underflow\",n))(A||{}),O=(t=>(t[t.Previous=-1]=\"Previous\",t[t.Next=1]=\"Next\",t))(O||{});function x(e=document.body){return e==null?[]:Array.from(e.querySelectorAll(E)).sort((r,t)=>Math.sign((r.tabIndex||Number.MAX_SAFE_INTEGER)-(t.tabIndex||Number.MAX_SAFE_INTEGER)))}function h(e=document.body){return e==null?[]:Array.from(e.querySelectorAll(S)).sort((r,t)=>Math.sign((r.tabIndex||Number.MAX_SAFE_INTEGER)-(t.tabIndex||Number.MAX_SAFE_INTEGER)))}var I=(t=>(t[t.Strict=0]=\"Strict\",t[t.Loose=1]=\"Loose\",t))(I||{});function H(e,r=0){var t;return e===((t=F(e))==null?void 0:t.body)?!1:L(r,{[0](){return e.matches(E)},[1](){let l=e;for(;l!==null;){if(l.matches(E))return!0;l=l.parentElement}return!1}})}function K(e){p().nextFrame(()=>{let r=b(e);r&&y.isHTMLorSVGElement(r)&&!H(r,0)&&w(e)})}var g=(t=>(t[t.Keyboard=0]=\"Keyboard\",t[t.Mouse=1]=\"Mouse\",t))(g||{});typeof window!=\"undefined\"&&typeof document!=\"undefined\"&&(document.addEventListener(\"keydown\",e=>{e.metaKey||e.altKey||e.ctrlKey||(document.documentElement.dataset.headlessuiFocusVisible=\"\")},!0),document.addEventListener(\"click\",e=>{e.detail===1?delete document.documentElement.dataset.headlessuiFocusVisible:e.detail===0&&(document.documentElement.dataset.headlessuiFocusVisible=\"\")},!0));function w(e){e==null||e.focus({preventScroll:!0})}let _=[\"textarea\",\"input\"].join(\",\");function P(e){var r,t;return(t=(r=e==null?void 0:e.matches)==null?void 0:r.call(e,_))!=null?t:!1}function G(e,r=t=>t){return e.slice().sort((t,l)=>{let n=r(t),a=r(l);if(n===null||a===null)return 0;let u=n.compareDocumentPosition(a);return u&Node.DOCUMENT_POSITION_FOLLOWING?-1:u&Node.DOCUMENT_POSITION_PRECEDING?1:0})}function R(e,r,t=e===null?document.body:f(e)){return v(x(t),r,{relativeTo:e})}function v(e,r,{sorted:t=!0,relativeTo:l=null,skipElements:n=[]}={}){let a=Array.isArray(e)?e.length>0?f(e[0]):document:f(e),u=Array.isArray(e)?t?G(e):e:r&64?h(e):x(e);n.length>0&&u.length>1&&(u=u.filter(i=>!n.some(d=>d!=null&&\"current\"in d?(d==null?void 0:d.current)===i:d===i))),l=l!=null?l:a==null?void 0:a.activeElement;let o=(()=>{if(r&5)return 1;if(r&10)return-1;throw new Error(\"Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last\")})(),M=(()=>{if(r&1)return 0;if(r&2)return Math.max(0,u.indexOf(l))-1;if(r&4)return Math.max(0,u.indexOf(l))+1;if(r&8)return u.length-1;throw new Error(\"Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last\")})(),N=r&32?{preventScroll:!0}:{},m=0,c=u.length,s;do{if(m>=c||m+c<=0)return 0;let i=M+m;if(r&16)i=(i+c)%c;else{if(i<0)return 3;if(i>=c)return 1}s=u[i],s==null||s.focus(N),m+=o}while(s!==b(s));return r&6&&P(s)&&s.select(),2}export{T as Focus,A as FocusResult,I as FocusableMode,w as focusElement,R as focusFrom,v as focusIn,E as focusableSelector,h as getAutoFocusableElements,x as getFocusableElements,H as isFocusableElement,K as restoreFocusIfNecessary,G as sortByDomNode};\n","import{useCallback as n,useId as u}from\"react\";import{stackMachines as p}from'../machines/stack-machine.js';import{useSlice as f}from'../react-glue.js';import{useIsoMorphicEffect as a}from'./use-iso-morphic-effect.js';function I(o,s){let t=u(),r=p.get(s),[i,c]=f(r,n(e=>[r.selectors.isTop(e,t),r.selectors.inStack(e,t)],[r,t]));return a(()=>{if(o)return r.actions.push(t),()=>r.actions.pop(t)},[r,o,t]),o?c?i:!0:!1}export{I as useIsTopLayer};\n","import E,{Fragment as j,cloneElement as v,createElement as S,forwardRef as w,isValidElement as k,useCallback as x,useRef as M}from\"react\";import{classNames as N}from'./class-names.js';import{match as O}from'./match.js';var A=(a=>(a[a.None=0]=\"None\",a[a.RenderStrategy=1]=\"RenderStrategy\",a[a.Static=2]=\"Static\",a))(A||{}),C=(e=>(e[e.Unmount=0]=\"Unmount\",e[e.Hidden=1]=\"Hidden\",e))(C||{});function K(){let n=$();return x(r=>U({mergeRefs:n,...r}),[n])}function U({ourProps:n,theirProps:r,slot:e,defaultTag:a,features:s,visible:t=!0,name:l,mergeRefs:i}){i=i!=null?i:I;let o=P(r,n);if(t)return F(o,e,a,l,i);let y=s!=null?s:0;if(y&2){let{static:f=!1,...u}=o;if(f)return F(u,e,a,l,i)}if(y&1){let{unmount:f=!0,...u}=o;return O(f?0:1,{[0](){return null},[1](){return F({...u,hidden:!0,style:{display:\"none\"}},e,a,l,i)}})}return F(o,e,a,l,i)}function F(n,r={},e,a,s){let{as:t=e,children:l,refName:i=\"ref\",...o}=h(n,[\"unmount\",\"static\"]),y=n.ref!==void 0?{[i]:n.ref}:{},f=typeof l==\"function\"?l(r):l;\"className\"in o&&o.className&&typeof o.className==\"function\"&&(o.className=o.className(r)),o[\"aria-labelledby\"]&&o[\"aria-labelledby\"]===o.id&&(o[\"aria-labelledby\"]=void 0);let u={};if(r){let d=!1,p=[];for(let[c,T]of Object.entries(r))typeof T==\"boolean\"&&(d=!0),T===!0&&p.push(c.replace(/([A-Z])/g,g=>`-${g.toLowerCase()}`));if(d){u[\"data-headlessui-state\"]=p.join(\" \");for(let c of p)u[`data-${c}`]=\"\"}}if(b(t)&&(Object.keys(m(o)).length>0||Object.keys(m(u)).length>0))if(!k(f)||Array.isArray(f)&&f.length>1||D(f)){if(Object.keys(m(o)).length>0)throw new Error(['Passing props on \"Fragment\"!',\"\",`The current component <${a} /> is rendering a \"Fragment\".`,\"However we need to passthrough the following props:\",Object.keys(m(o)).concat(Object.keys(m(u))).map(d=>`  - ${d}`).join(`\n`),\"\",\"You can apply a few solutions:\",['Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".',\"Render a single element as the child so that we can forward the props onto that element.\"].map(d=>`  - ${d}`).join(`\n`)].join(`\n`))}else{let d=f.props,p=d==null?void 0:d.className,c=typeof p==\"function\"?(...R)=>N(p(...R),o.className):N(p,o.className),T=c?{className:c}:{},g=P(f.props,m(h(o,[\"ref\"])));for(let R in u)R in g&&delete u[R];return v(f,Object.assign({},g,u,y,{ref:s(H(f),y.ref)},T))}return S(t,Object.assign({},h(o,[\"ref\"]),!b(t)&&y,!b(t)&&u),f)}function $(){let n=M([]),r=x(e=>{for(let a of n.current)a!=null&&(typeof a==\"function\"?a(e):a.current=e)},[]);return(...e)=>{if(!e.every(a=>a==null))return n.current=e,r}}function I(...n){return n.every(r=>r==null)?void 0:r=>{for(let e of n)e!=null&&(typeof e==\"function\"?e(r):e.current=r)}}function P(...n){var a;if(n.length===0)return{};if(n.length===1)return n[0];let r={},e={};for(let s of n)for(let t in s)t.startsWith(\"on\")&&typeof s[t]==\"function\"?((a=e[t])!=null||(e[t]=[]),e[t].push(s[t])):r[t]=s[t];if(r.disabled||r[\"aria-disabled\"])for(let s in e)/^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(s)&&(e[s]=[t=>{var l;return(l=t==null?void 0:t.preventDefault)==null?void 0:l.call(t)}]);for(let s in e)Object.assign(r,{[s](t,...l){let i=e[s];for(let o of i){if((t instanceof Event||(t==null?void 0:t.nativeEvent)instanceof Event)&&t.defaultPrevented)return;o(t,...l)}}});return r}function V(...n){var a;if(n.length===0)return{};if(n.length===1)return n[0];let r={},e={};for(let s of n)for(let t in s)t.startsWith(\"on\")&&typeof s[t]==\"function\"?((a=e[t])!=null||(e[t]=[]),e[t].push(s[t])):r[t]=s[t];for(let s in e)Object.assign(r,{[s](...t){let l=e[s];for(let i of l)i==null||i(...t)}});return r}function Y(n){var r;return Object.assign(w(n),{displayName:(r=n.displayName)!=null?r:n.name})}function m(n){let r=Object.assign({},n);for(let e in r)r[e]===void 0&&delete r[e];return r}function h(n,r=[]){let e=Object.assign({},n);for(let a of r)a in e&&delete e[a];return e}function H(n){return E.version.split(\".\")[0]>=\"19\"?n.props.ref:n.ref}function b(n){return n===j||n===Symbol.for(\"react.fragment\")}function D(n){return b(n.type)}export{A as RenderFeatures,C as RenderStrategy,m as compact,Y as forwardRefWithAs,b as isFragment,D as isFragmentInstance,V as mergeProps,K as useRender};\n","import{disposables as M}from'../utils/disposables.js';import{getOwnerDocument as b}from'../utils/owner.js';import{useIsTopLayer as L}from'./use-is-top-layer.js';import{useIsoMorphicEffect as T}from'./use-iso-morphic-effect.js';let f=new Map,u=new Map;function h(t){var e;let r=(e=u.get(t))!=null?e:0;return u.set(t,r+1),r!==0?()=>m(t):(f.set(t,{\"aria-hidden\":t.getAttribute(\"aria-hidden\"),inert:t.inert}),t.setAttribute(\"aria-hidden\",\"true\"),t.inert=!0,()=>m(t))}function m(t){var i;let r=(i=u.get(t))!=null?i:1;if(r===1?u.delete(t):u.set(t,r-1),r!==1)return;let e=f.get(t);e&&(e[\"aria-hidden\"]===null?t.removeAttribute(\"aria-hidden\"):t.setAttribute(\"aria-hidden\",e[\"aria-hidden\"]),t.inert=e.inert,f.delete(t))}function y(t,{allowed:r,disallowed:e}={}){let i=L(t,\"inert-others\");T(()=>{var d,c;if(!i)return;let a=M();for(let n of(d=e==null?void 0:e())!=null?d:[])n&&a.add(h(n));let s=(c=r==null?void 0:r())!=null?c:[];for(let n of s){if(!n)continue;let l=b(n);if(!l)continue;let o=n.parentElement;for(;o&&o!==l.body;){for(let p of o.children)s.some(E=>p.contains(E))||a.add(h(p));o=o.parentElement}}return a.dispose},[i,r,e])}export{y as useInertOthers};\n","import s,{createContext as h,useContext as b,useState as p}from\"react\";import{Hidden as M,HiddenFeatures as v}from'../internal/hidden.js';import*as f from'../utils/dom.js';import{getOwnerDocument as a}from'../utils/owner.js';import{useEvent as m}from'./use-event.js';function S({defaultContainers:l=[],portals:n,mainTreeNode:o}={}){let c=m(()=>{var r,u;let i=a(o),t=[];for(let e of l)e!==null&&(f.isElement(e)?t.push(e):\"current\"in e&&f.isElement(e.current)&&t.push(e.current));if(n!=null&&n.current)for(let e of n.current)t.push(e);for(let e of(r=i==null?void 0:i.querySelectorAll(\"html > *, body > *\"))!=null?r:[])e!==document.body&&e!==document.head&&f.isElement(e)&&e.id!==\"headlessui-portal-root\"&&(o&&(e.contains(o)||e.contains((u=o==null?void 0:o.getRootNode())==null?void 0:u.host))||t.some(E=>e.contains(E))||t.push(e));return t});return{resolveContainers:c,contains:m(i=>c().some(t=>t.contains(i)))}}let d=h(null);function j({children:l,node:n}){let[o,c]=p(null),i=x(n!=null?n:o);return s.createElement(d.Provider,{value:i},l,i===null&&s.createElement(M,{features:v.Hidden,ref:t=>{var r,u;if(t){for(let e of(u=(r=a(t))==null?void 0:r.querySelectorAll(\"html > *, body > *\"))!=null?u:[])if(e!==document.body&&e!==document.head&&f.isElement(e)&&e!=null&&e.contains(t)){c(e);break}}}}))}function x(l=null){var n;return(n=b(d))!=null?n:l}export{j as MainTreeProvider,x as useMainTreeNode,S as useRootContainers};\n","import{disposables as s}from'../../utils/disposables.js';import{createStore as d}from'../../utils/store.js';import{adjustScrollbarPadding as i}from'./adjust-scrollbar-padding.js';import{handleIOSLocking as l}from'./handle-ios-locking.js';import{preventScroll as p}from'./prevent-scroll.js';function r(e){let o={};for(let t of e)Object.assign(o,t(o));return o}let c=d(()=>new Map,{PUSH(e,o){var n;let t=(n=this.get(e))!=null?n:{doc:e,count:0,d:s(),meta:new Set,computedMeta:{}};return t.count++,t.meta.add(o),t.computedMeta=r(t.meta),this.set(e,t),this},POP(e,o){let t=this.get(e);return t&&(t.count--,t.meta.delete(o),t.computedMeta=r(t.meta)),this},SCROLL_PREVENT(e){let o={doc:e.doc,d:e.d,meta(){return e.computedMeta}},t=[l(),i(),p()];t.forEach(({before:n})=>n==null?void 0:n(o)),t.forEach(({after:n})=>n==null?void 0:n(o))},SCROLL_ALLOW({d:e}){e.dispose()},TEARDOWN({doc:e}){this.delete(e)}});c.subscribe(()=>{let e=c.getSnapshot(),o=new Map;for(let[t]of e)o.set(t,t.documentElement.style.overflow);for(let t of e.values()){let n=o.get(t.doc)===\"hidden\",a=t.count!==0;(a&&!n||!a&&n)&&c.dispatch(t.count>0?\"SCROLL_PREVENT\":\"SCROLL_ALLOW\",t),t.count===0&&c.dispatch(\"TEARDOWN\",t)}});export{c as overflows};\n","import{useCallback as T,useRef as E}from\"react\";import*as d from'../utils/dom.js';import{FocusableMode as g,isFocusableElement as y}from'../utils/focus-management.js';import{isMobile as p}from'../utils/platform.js';import{useDocumentEvent as a}from'./use-document-event.js';import{useLatestValue as L}from'./use-latest-value.js';import{useWindowEvent as x}from'./use-window-event.js';const C=30;function k(o,f,h){let m=L(h),s=T(function(e,c){if(e.defaultPrevented)return;let r=c(e);if(r===null||!r.getRootNode().contains(r)||!r.isConnected)return;let M=function u(n){return typeof n==\"function\"?u(n()):Array.isArray(n)||n instanceof Set?n:[n]}(f);for(let u of M)if(u!==null&&(u.contains(r)||e.composed&&e.composedPath().includes(u)))return;return!y(r,g.Loose)&&r.tabIndex!==-1&&e.preventDefault(),m.current(e,r)},[m,f]),i=E(null);a(o,\"pointerdown\",t=>{var e,c;p()||(i.current=((c=(e=t.composedPath)==null?void 0:e.call(t))==null?void 0:c[0])||t.target)},!0),a(o,\"pointerup\",t=>{if(p()||!i.current)return;let e=i.current;return i.current=null,s(t,()=>e)},!0);let l=E({x:0,y:0});a(o,\"touchstart\",t=>{l.current.x=t.touches[0].clientX,l.current.y=t.touches[0].clientY},!0),a(o,\"touchend\",t=>{let e={x:t.changedTouches[0].clientX,y:t.changedTouches[0].clientY};if(!(Math.abs(e.x-l.current.x)>=C||Math.abs(e.y-l.current.y)>=C))return s(t,()=>d.isHTMLorSVGElement(t.target)?t.target:null)},!0),x(o,\"blur\",t=>s(t,()=>d.isHTMLIframeElement(window.document.activeElement)?window.document.activeElement:null),!0)}export{k as useOutsideClick};\n","import defaultErrorMap from \"./locales/en.js\";\nlet overrideErrorMap = defaultErrorMap;\nexport { defaultErrorMap };\nexport function setErrorMap(map) {\n    overrideErrorMap = map;\n}\nexport function getErrorMap() {\n    return overrideErrorMap;\n}\n","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import { JOSENotSupported } from '../util/errors.js';\nfunction validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {\n    if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be integrity protected');\n    }\n    if (!protectedHeader || protectedHeader.crit === undefined) {\n        return new Set();\n    }\n    if (!Array.isArray(protectedHeader.crit) ||\n        protectedHeader.crit.length === 0 ||\n        protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be an array of non-empty strings when present');\n    }\n    let recognized;\n    if (recognizedOption !== undefined) {\n        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);\n    }\n    else {\n        recognized = recognizedDefault;\n    }\n    for (const parameter of protectedHeader.crit) {\n        if (!recognized.has(parameter)) {\n            throw new JOSENotSupported(`Extension Header Parameter \"${parameter}\" is not recognized`);\n        }\n        if (joseHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" is missing`);\n        }\n        else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" MUST be integrity protected`);\n        }\n    }\n    return new Set(protectedHeader.crit);\n}\nexport default validateCrit;\n","import { promisify } from 'util';\nimport { inflateRaw as inflateRawCb, deflateRaw as deflateRawCb } from 'zlib';\nimport { JWEDecompressionFailed } from '../util/errors.js';\nconst inflateRaw = promisify(inflateRawCb);\nconst deflateRaw = promisify(deflateRawCb);\nexport const inflate = (input) => inflateRaw(input, { maxOutputLength: 250000 }).catch(() => {\n    throw new JWEDecompressionFailed();\n});\nexport const deflate = (input) => deflateRaw(input);\n","import { KeyObject } from 'crypto';\nimport * as util from 'util';\nexport default util.types.isKeyObject\n    ? (obj) => util.types.isKeyObject(obj)\n    : (obj) => obj != null && obj instanceof KeyObject;\n","import { timingSafeEqual as impl } from 'crypto';\nconst timingSafeEqual = impl;\nexport default timingSafeEqual;\n","import crypto from 'crypto';\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto.randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}","import { getCiphers } from 'crypto';\nlet ciphers;\nexport default (algorithm) => {\n    ciphers || (ciphers = new Set(getCiphers()));\n    return ciphers.has(algorithm);\n};\n","import { FlattenedEncrypt } from '../flattened/encrypt.js';\nexport class CompactEncrypt {\n    constructor(plaintext) {\n        this._flattened = new FlattenedEncrypt(plaintext);\n    }\n    setContentEncryptionKey(cek) {\n        this._flattened.setContentEncryptionKey(cek);\n        return this;\n    }\n    setInitializationVector(iv) {\n        this._flattened.setInitializationVector(iv);\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        this._flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    setKeyManagementParameters(parameters) {\n        this._flattened.setKeyManagementParameters(parameters);\n        return this;\n    }\n    async encrypt(key, options) {\n        const jwe = await this._flattened.encrypt(key, options);\n        return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join('.');\n    }\n}\n","import { FlattenedSign } from '../flattened/sign.js';\nexport class CompactSign {\n    constructor(payload) {\n        this._flattened = new FlattenedSign(payload);\n    }\n    setProtectedHeader(protectedHeader) {\n        this._flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    async sign(key, options) {\n        const jws = await this._flattened.sign(key, options);\n        if (jws.payload === undefined) {\n            throw new TypeError('use the flattened module for creating JWS with b64: false');\n        }\n        return `${jws.protected}.${jws.payload}.${jws.signature}`;\n    }\n}\n","import { generateKeyPair as generate } from '../runtime/generate.js';\nexport async function generateKeyPair(alg, options) {\n    return generate(alg, options);\n}\n","import { generateSecret as generate } from '../runtime/generate.js';\nexport async function generateSecret(alg, options) {\n    return generate(alg, options);\n}\n","import { util } from \"./helpers/util.js\";\nexport const ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nexport const quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nexport class ZodError extends Error {\n    get errors() {\n        return this.issues;\n    }\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    static assert(value) {\n        if (!(value instanceof ZodError)) {\n            throw new Error(`Not a ZodError: ${value}`);\n        }\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                const firstEl = sub.path[0];\n                fieldErrors[firstEl] = fieldErrors[firstEl] || [];\n                fieldErrors[firstEl].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n","import { JOSENotSupported } from '../util/errors.js';\nexport default function dsaDigest(alg) {\n    switch (alg) {\n        case 'PS256':\n        case 'RS256':\n        case 'ES256':\n        case 'ES256K':\n            return 'sha256';\n        case 'PS384':\n        case 'RS384':\n        case 'ES384':\n            return 'sha384';\n        case 'PS512':\n        case 'RS512':\n        case 'ES512':\n            return 'sha512';\n        case 'EdDSA':\n            return undefined;\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n","import { JWEInvalid } from '../util/errors.js';\nexport default function checkP2s(p2s) {\n    if (!(p2s instanceof Uint8Array) || p2s.length < 8) {\n        throw new JWEInvalid('PBES2 Salt Input must be 8 or more octets');\n    }\n}\n","import { JOSENotSupported } from '../util/errors.js';\nexport default function hmacDigest(alg) {\n    switch (alg) {\n        case 'HS256':\n            return 'sha256';\n        case 'HS384':\n            return 'sha384';\n        case 'HS512':\n            return 'sha512';\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n","import value from '../runtime/runtime.js';\nexport default value;\n","/**\n * This function is a replacement for `JSON.parse` that can handle large\n * unsafe integers by parsing them as BigInts. It transforms every\n * numerical value into a BigInt without loss of precision.\n */\nexport function parseJsonWithBigInts(json: string): unknown {\n    return JSON.parse(wrapIntegersInBigIntValueObject(json), (_, value) => {\n        return isBigIntValueObject(value) ? unwrapBigIntValueObject(value) : value;\n    });\n}\n\nfunction wrapIntegersInBigIntValueObject(json: string): string {\n    const out = [];\n    let inQuote = false;\n    for (let ii = 0; ii < json.length; ii++) {\n        let isEscaped = false;\n        if (json[ii] === '\\\\') {\n            out.push(json[ii++]);\n            isEscaped = !isEscaped;\n        }\n        if (json[ii] === '\"') {\n            out.push(json[ii]);\n            if (!isEscaped) {\n                inQuote = !inQuote;\n            }\n            continue;\n        }\n        if (!inQuote) {\n            const consumedNumber = consumeNumber(json, ii);\n            if (consumedNumber?.length) {\n                ii += consumedNumber.length - 1;\n                // Don't wrap numbers that contain a decimal point or a negative exponent.\n                if (consumedNumber.match(/\\.|[eE]-/)) {\n                    out.push(consumedNumber);\n                } else {\n                    out.push(wrapBigIntValueObject(consumedNumber));\n                }\n                continue;\n            }\n        }\n        out.push(json[ii]);\n    }\n\n    return out.join('');\n}\n\nfunction consumeNumber(json: string, ii: number): string | null {\n    /** @see https://stackoverflow.com/a/13340826/11440277 */\n    const JSON_NUMBER_REGEX = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/;\n\n    // Stop early if the first character isn't a digit or a minus sign.\n    if (!json[ii]?.match(/[-\\d]/)) {\n        return null;\n    }\n\n    // Otherwise, check if the next characters form a valid JSON number.\n    const numberMatch = json.slice(ii).match(JSON_NUMBER_REGEX);\n    return numberMatch ? numberMatch[0] : null;\n}\n\ntype BigIntValueObject = {\n    // `$` implies 'this is a value object'.\n    // `n` implies 'interpret the value as a bigint'.\n    $n: string;\n};\n\nfunction wrapBigIntValueObject(value: string): string {\n    return `{\"$n\":\"${value}\"}`;\n}\n\nfunction unwrapBigIntValueObject({ $n }: BigIntValueObject): bigint {\n    if ($n.match(/[eE]/)) {\n        const [units, exponent] = $n.split(/[eE]/);\n        return BigInt(units) * BigInt(10) ** BigInt(exponent);\n    }\n    return BigInt($n);\n}\n\nfunction isBigIntValueObject(value: unknown): value is BigIntValueObject {\n    return !!value && typeof value === 'object' && '$n' in value && typeof value.$n === 'string';\n}\n","import * as crypto from 'crypto';\nimport * as util from 'util';\nconst webcrypto = crypto.webcrypto;\nexport default webcrypto;\nexport const isCryptoKey = util.types.isCryptoKey\n    ? (key) => util.types.isCryptoKey(key)\n    :\n        (key) => false;\n","import { Buffer } from 'buffer';\nimport { JOSENotSupported } from '../util/errors.js';\nconst tagInteger = 0x02;\nconst tagBitStr = 0x03;\nconst tagOctStr = 0x04;\nconst tagSequence = 0x30;\nconst bZero = Buffer.from([0x00]);\nconst bTagInteger = Buffer.from([tagInteger]);\nconst bTagBitStr = Buffer.from([tagBitStr]);\nconst bTagSequence = Buffer.from([tagSequence]);\nconst bTagOctStr = Buffer.from([tagOctStr]);\nconst encodeLength = (len) => {\n    if (len < 128)\n        return Buffer.from([len]);\n    const buffer = Buffer.alloc(5);\n    buffer.writeUInt32BE(len, 1);\n    let offset = 1;\n    while (buffer[offset] === 0)\n        offset++;\n    buffer[offset - 1] = 0x80 | (5 - offset);\n    return buffer.slice(offset - 1);\n};\nconst oids = new Map([\n    ['P-256', Buffer.from('06 08 2A 86 48 CE 3D 03 01 07'.replace(/ /g, ''), 'hex')],\n    ['secp256k1', Buffer.from('06 05 2B 81 04 00 0A'.replace(/ /g, ''), 'hex')],\n    ['P-384', Buffer.from('06 05 2B 81 04 00 22'.replace(/ /g, ''), 'hex')],\n    ['P-521', Buffer.from('06 05 2B 81 04 00 23'.replace(/ /g, ''), 'hex')],\n    ['ecPublicKey', Buffer.from('06 07 2A 86 48 CE 3D 02 01'.replace(/ /g, ''), 'hex')],\n    ['X25519', Buffer.from('06 03 2B 65 6E'.replace(/ /g, ''), 'hex')],\n    ['X448', Buffer.from('06 03 2B 65 6F'.replace(/ /g, ''), 'hex')],\n    ['Ed25519', Buffer.from('06 03 2B 65 70'.replace(/ /g, ''), 'hex')],\n    ['Ed448', Buffer.from('06 03 2B 65 71'.replace(/ /g, ''), 'hex')],\n]);\nexport default class DumbAsn1Encoder {\n    constructor() {\n        this.length = 0;\n        this.elements = [];\n    }\n    oidFor(oid) {\n        const bOid = oids.get(oid);\n        if (!bOid) {\n            throw new JOSENotSupported('Invalid or unsupported OID');\n        }\n        this.elements.push(bOid);\n        this.length += bOid.length;\n    }\n    zero() {\n        this.elements.push(bTagInteger, Buffer.from([0x01]), bZero);\n        this.length += 3;\n    }\n    one() {\n        this.elements.push(bTagInteger, Buffer.from([0x01]), Buffer.from([0x01]));\n        this.length += 3;\n    }\n    unsignedInteger(integer) {\n        if (integer[0] & 0x80) {\n            const len = encodeLength(integer.length + 1);\n            this.elements.push(bTagInteger, len, bZero, integer);\n            this.length += 2 + len.length + integer.length;\n        }\n        else {\n            let i = 0;\n            while (integer[i] === 0 && (integer[i + 1] & 0x80) === 0)\n                i++;\n            const len = encodeLength(integer.length - i);\n            this.elements.push(bTagInteger, encodeLength(integer.length - i), integer.slice(i));\n            this.length += 1 + len.length + integer.length - i;\n        }\n    }\n    octStr(octStr) {\n        const len = encodeLength(octStr.length);\n        this.elements.push(bTagOctStr, encodeLength(octStr.length), octStr);\n        this.length += 1 + len.length + octStr.length;\n    }\n    bitStr(bitS) {\n        const len = encodeLength(bitS.length + 1);\n        this.elements.push(bTagBitStr, encodeLength(bitS.length + 1), bZero, bitS);\n        this.length += 1 + len.length + bitS.length + 1;\n    }\n    add(seq) {\n        this.elements.push(seq);\n        this.length += seq.length;\n    }\n    end(tag = bTagSequence) {\n        const len = encodeLength(this.length);\n        return Buffer.concat([tag, len, ...this.elements], 1 + len.length + this.length);\n    }\n}\n","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import { withAlg as invalidKeyInput } from './invalid_key_input.js';\nimport isKeyLike, { types } from '../runtime/is_key_like.js';\nconst symmetricTypeCheck = (alg, key) => {\n    if (key instanceof Uint8Array)\n        return;\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, ...types, 'Uint8Array'));\n    }\n    if (key.type !== 'secret') {\n        throw new TypeError(`${types.join(' or ')} instances for symmetric algorithms must be of type \"secret\"`);\n    }\n};\nconst asymmetricTypeCheck = (alg, key, usage) => {\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, ...types));\n    }\n    if (key.type === 'secret') {\n        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithms must not be of type \"secret\"`);\n    }\n    if (usage === 'sign' && key.type === 'public') {\n        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm signing must be of type \"private\"`);\n    }\n    if (usage === 'decrypt' && key.type === 'public') {\n        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm decryption must be of type \"private\"`);\n    }\n    if (key.algorithm && usage === 'verify' && key.type === 'private') {\n        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm verifying must be of type \"public\"`);\n    }\n    if (key.algorithm && usage === 'encrypt' && key.type === 'private') {\n        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm encryption must be of type \"public\"`);\n    }\n};\nconst checkKeyType = (alg, key, usage) => {\n    const symmetric = alg.startsWith('HS') ||\n        alg === 'dir' ||\n        alg.startsWith('PBES2') ||\n        /^A\\d{3}(?:GCM)?KW$/.test(alg);\n    if (symmetric) {\n        symmetricTypeCheck(alg, key);\n    }\n    else {\n        asymmetricTypeCheck(alg, key, usage);\n    }\n};\nexport default checkKeyType;\n","import { JWEInvalid, JOSENotSupported } from '../util/errors.js';\nimport isKeyObject from './is_key_object.js';\nconst checkCekLength = (enc, cek) => {\n    let expected;\n    switch (enc) {\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            expected = parseInt(enc.slice(-3), 10);\n            break;\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            expected = parseInt(enc.slice(1, 4), 10);\n            break;\n        default:\n            throw new JOSENotSupported(`Content Encryption Algorithm ${enc} is not supported either by JOSE or your javascript runtime`);\n    }\n    if (cek instanceof Uint8Array) {\n        const actual = cek.byteLength << 3;\n        if (actual !== expected) {\n            throw new JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);\n        }\n        return;\n    }\n    if (isKeyObject(cek) && cek.type === 'secret') {\n        const actual = cek.symmetricKeySize << 3;\n        if (actual !== expected) {\n            throw new JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);\n        }\n        return;\n    }\n    throw new TypeError('Invalid Content Encryption Key type');\n};\nexport default checkCekLength;\n","import { ZodIssueCode } from \"../ZodError.js\";\nimport { util, ZodParsedType } from \"../helpers/util.js\";\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"bigint\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return { message };\n};\nexport default errorMap;\n","import { FlattenedSign } from '../flattened/sign.js';\nimport { JWSInvalid } from '../../util/errors.js';\nclass IndividualSignature {\n    constructor(sig, key, options) {\n        this.parent = sig;\n        this.key = key;\n        this.options = options;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this.protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this.protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    addSignature(...args) {\n        return this.parent.addSignature(...args);\n    }\n    sign(...args) {\n        return this.parent.sign(...args);\n    }\n    done() {\n        return this.parent;\n    }\n}\nexport class GeneralSign {\n    constructor(payload) {\n        this._signatures = [];\n        this._payload = payload;\n    }\n    addSignature(key, options) {\n        const signature = new IndividualSignature(this, key, options);\n        this._signatures.push(signature);\n        return signature;\n    }\n    async sign() {\n        if (!this._signatures.length) {\n            throw new JWSInvalid('at least one signature must be added');\n        }\n        const jws = {\n            signatures: [],\n            payload: '',\n        };\n        for (let i = 0; i < this._signatures.length; i++) {\n            const signature = this._signatures[i];\n            const flattened = new FlattenedSign(this._payload);\n            flattened.setProtectedHeader(signature.protectedHeader);\n            flattened.setUnprotectedHeader(signature.unprotectedHeader);\n            const { payload, ...rest } = await flattened.sign(signature.key, signature.options);\n            if (i === 0) {\n                jws.payload = payload;\n            }\n            else if (jws.payload !== payload) {\n                throw new JWSInvalid('inconsistent use of JWS Unencoded Payload (RFC7797)');\n            }\n            jws.signatures.push(rest);\n        }\n        return jws;\n    }\n}\n","import { getErrorMap } from \"../errors.js\";\nimport defaultErrorMap from \"../locales/en.js\";\nexport const makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    if (issueData.message !== undefined) {\n        return {\n            ...issueData,\n            path: fullPath,\n            message: issueData.message,\n        };\n    }\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage,\n    };\n};\nexport const EMPTY_PATH = [];\nexport function addIssueToContext(ctx, issueData) {\n    const overrideMap = getErrorMap();\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap, // contextual error map is first priority\n            ctx.schemaErrorMap, // then schema-bound map if available\n            overrideMap, // then global override map\n            overrideMap === defaultErrorMap ? undefined : defaultErrorMap, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nexport class ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n                key,\n                value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return INVALID;\n            if (value.status === \"aborted\")\n                return INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nexport const INVALID = Object.freeze({\n    status: \"aborted\",\n});\nexport const DIRTY = (value) => ({ status: \"dirty\", value });\nexport const OK = (value) => ({ status: \"valid\", value });\nexport const isAborted = (x) => x.status === \"aborted\";\nexport const isDirty = (x) => x.status === \"dirty\";\nexport const isValid = (x) => x.status === \"valid\";\nexport const isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n","import { JOSENotSupported } from '../util/errors.js';\nimport random from '../runtime/random.js';\nexport function bitLength(alg) {\n    switch (alg) {\n        case 'A128GCM':\n            return 128;\n        case 'A192GCM':\n            return 192;\n        case 'A256GCM':\n        case 'A128CBC-HS256':\n            return 256;\n        case 'A192CBC-HS384':\n            return 384;\n        case 'A256CBC-HS512':\n            return 512;\n        default:\n            throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);\n    }\n}\nexport default (alg) => random(new Uint8Array(bitLength(alg) >> 3));\n","import { JOSENotSupported } from '../util/errors.js';\nimport random from '../runtime/random.js';\nexport function bitLength(alg) {\n    switch (alg) {\n        case 'A128GCM':\n        case 'A128GCMKW':\n        case 'A192GCM':\n        case 'A192GCMKW':\n        case 'A256GCM':\n        case 'A256GCMKW':\n            return 96;\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            return 128;\n        default:\n            throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);\n    }\n}\nexport default (alg) => random(new Uint8Array(bitLength(alg) >> 3));\n","import webcrypto, { isCryptoKey } from './webcrypto.js';\nimport isKeyObject from './is_key_object.js';\nexport default (key) => isKeyObject(key) || isCryptoKey(key);\nconst types = ['KeyObject'];\nif (globalThis.CryptoKey || (webcrypto === null || webcrypto === void 0 ? void 0 : webcrypto.CryptoKey)) {\n    types.push('CryptoKey');\n}\nexport { types };\n","import { createHmac } from 'crypto';\nimport { concat, uint64be } from '../lib/buffer_utils.js';\nexport default function cbcTag(aad, iv, ciphertext, macSize, macKey, keySize) {\n    const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));\n    const hmac = createHmac(`sha${macSize}`, macKey);\n    hmac.update(macData);\n    return hmac.digest().slice(0, keySize >> 3);\n}\n","export let extraEntropy = false\n\n/** @internal */\nexport function setExtraEntropy(entropy: boolean) {\n  extraEntropy = entropy\n}\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/util/provider.ts","import type { Abi } from 'abitype'\n\nimport type { SendTransactionRequest } from '../../actions/wallet/sendTransaction.js'\nimport { writeContract } from '../../actions/wallet/writeContract.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { WalletActions } from '../../clients/decorators/wallet.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Account } from '../../types/account.js'\nimport {\n  type DeployContractParameters,\n  type DeployContractReturnType,\n  deployContract,\n} from '../actions/deployContract.js'\nimport {\n  type SendTransactionParameters,\n  type SendTransactionReturnType,\n  sendTransaction,\n} from '../actions/sendTransaction.js'\nimport {\n  type SignTransactionParameters,\n  type SignTransactionReturnType,\n  signTransaction,\n} from '../actions/signTransaction.js'\nimport type { ChainEIP712 } from '../types/chain.js'\n\nexport type Eip712WalletActions<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n> = {\n  /**\n   * Creates, signs, and sends a new transaction to the network.\n   *\n   * - Docs: https://viem.sh/docs/zksync/actions/sendTransaction\n   * - JSON-RPC Methods:\n   *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)\n   *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)\n   *\n   * @param client - Client to use\n   * @param parameters - {@link SendTransactionParameters}\n   * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link SendTransactionReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { zksync } from 'viem/chains'\n   * import { eip712WalletActions } from 'viem/zksync'\n   *\n   * const client = createWalletClient({\n   *   chain: zksync,\n   *   transport: custom(window.ethereum),\n   * }).extend(eip712WalletActions())\n   * const hash = await client.sendTransaction({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *   value: 1000000000000000000n,\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { zksync } from 'viem/chains'\n   * import { eip712WalletActions } from 'viem/zksync'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x'),\n   *   chain: zksync,\n   *   transport: http(),\n   * }).extend(eip712WalletActions())\n   * const hash = await client.sendTransaction({\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *   value: 1000000000000000000n,\n   * })\n   */\n  sendTransaction: <\n    const request extends SendTransactionRequest<chain, chainOverride>,\n    chainOverride extends ChainEIP712 | undefined = undefined,\n  >(\n    args: SendTransactionParameters<chain, account, chainOverride, request>,\n  ) => Promise<SendTransactionReturnType>\n  /**\n   * Signs a transaction.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/signTransaction\n   * - JSON-RPC Methods:\n   *   - JSON-RPC Accounts: [`eth_signTransaction`](https://ethereum.github.io/execution-apis/api-documentation/)\n   *   - Local Accounts: Signs locally. No JSON-RPC request.\n   *\n   * @param args - {@link SignTransactionParameters}\n   * @returns The signed serialized transaction. {@link SignTransactionReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { zksync } from 'viem/chains'\n   * import { eip712WalletActions } from 'viem/zksync'\n   *\n   * const client = createWalletClient({\n   *   chain: zksync,\n   *   transport: custom(window.ethereum),\n   * }).extend(eip712WalletActions())\n   * const signature = await client.signTransaction({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   to: '0x0000000000000000000000000000000000000000',\n   *   value: 1n,\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { zksync } from 'viem/chains'\n   * import { eip712WalletActions } from 'viem/zksync'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x'),\n   *   chain: zksync,\n   *   transport: custom(window.ethereum),\n   * }).extend(eip712WalletActions())\n   * const signature = await client.signTransaction({\n   *   to: '0x0000000000000000000000000000000000000000',\n   *   value: 1n,\n   * })\n   */\n  signTransaction: <chainOverride extends ChainEIP712 | undefined = undefined>(\n    args: SignTransactionParameters<chain, account, chainOverride>,\n  ) => Promise<SignTransactionReturnType>\n  /**\n   * Deploys a contract to the network, given bytecode and constructor arguments using EIP712 transaction.\n   *\n   * - Docs: https://viem.sh/docs/contract/deployContract\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_deploying-contracts\n   *\n   * @param args - {@link DeployContractParameters}\n   * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link DeployContractReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { zksync } from 'viem/chains'\n   * import { deployContract } from 'viem/contract'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x'),\n   *   chain: zksync,\n   *   transport: custom(provider),\n   * })\n   * const hash = await client.deployContract(client, {\n   *   abi: [],\n   *   account: '0x,\n   *   deploymentType: 'create',\n   *   bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',\n   *   factoryDeps: ['0x608060405260405161083e38038061083e833981016040819052610...'],\n   *   gasPerPubdata: 50000n\n   * })\n   */\n  deployContract: <\n    const abi extends Abi | readonly unknown[],\n    chainOverride extends ChainEIP712 | undefined,\n  >(\n    args: DeployContractParameters<\n      abi,\n      ChainEIP712 | undefined,\n      Account | undefined,\n      chainOverride\n    >,\n  ) => Promise<DeployContractReturnType>\n  /**\n   * Executes a write function on a contract.\n   *\n   * - Docs: https://viem.sh/docs/contract/writeContract\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts\n   *\n   * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms) is needed to be broadcast in order to change the state.\n   *\n   * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n   *\n   * __Warning: The `write` internally sends a transaction  it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract#usage) before you execute it.__\n   *\n   * @param client - Client to use\n   * @param parameters - {@link WriteContractParameters}\n   * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms#hash). {@link WriteContractReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom, parseAbi } from 'viem'\n   * import { zksync } from 'viem/chains'\n   * import { eip712WalletActions } from 'viem/zksync'\n   *\n   * const client = createWalletClient({\n   *   chain: zksync,\n   *   transport: custom(window.ethereum),\n   * }).extend(eip712WalletActions())\n   * const hash = await client.writeContract({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n   *   functionName: 'mint',\n   *   args: [69420],\n   * })\n   *\n   * @example\n   * // With Validation\n   * import { createWalletClient, http, parseAbi } from 'viem'\n   * import { zksync } from 'viem/chains'\n   * import { eip712WalletActions } from 'viem/zksync'\n   *\n   * const client = createWalletClient({\n   *   chain: zksync,\n   *   transport: http(),\n   * }).extend(eip712WalletActions())\n   * const { request } = await client.simulateContract({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n   *   functionName: 'mint',\n   *   args: [69420],\n   * }\n   * const hash = await client.writeContract(request)\n   */\n  writeContract: WalletActions<chain, account>['writeContract']\n}\n\nexport function eip712WalletActions() {\n  return <\n    transport extends Transport,\n    chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n    account extends Account | undefined = Account | undefined,\n  >(\n    client: Client<transport, chain, account>,\n  ): Eip712WalletActions<chain, account> => ({\n    sendTransaction: (args) => sendTransaction(client, args),\n    signTransaction: (args) => signTransaction(client, args),\n    deployContract: (args) => deployContract(client, args),\n    writeContract: (args) =>\n      writeContract(\n        Object.assign(client, {\n          sendTransaction: (args: any) => sendTransaction(client, args),\n        }),\n        args,\n      ),\n  })\n}\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/util/checkCrossOriginOpenerPolicy.ts","import { importJWK } from '../key/import.js';\nimport { JWKSInvalid, JOSENotSupported, JWKSNoMatchingKey, JWKSMultipleMatchingKeys, } from '../util/errors.js';\nimport isObject from '../lib/is_object.js';\nfunction getKtyFromAlg(alg) {\n    switch (typeof alg === 'string' && alg.slice(0, 2)) {\n        case 'RS':\n        case 'PS':\n            return 'RSA';\n        case 'ES':\n            return 'EC';\n        case 'Ed':\n            return 'OKP';\n        default:\n            throw new JOSENotSupported('Unsupported \"alg\" value for a JSON Web Key Set');\n    }\n}\nexport function isJWKSLike(jwks) {\n    return (jwks &&\n        typeof jwks === 'object' &&\n        Array.isArray(jwks.keys) &&\n        jwks.keys.every(isJWKLike));\n}\nfunction isJWKLike(key) {\n    return isObject(key);\n}\nfunction clone(obj) {\n    if (typeof structuredClone === 'function') {\n        return structuredClone(obj);\n    }\n    return JSON.parse(JSON.stringify(obj));\n}\nexport class LocalJWKSet {\n    constructor(jwks) {\n        this._cached = new WeakMap();\n        if (!isJWKSLike(jwks)) {\n            throw new JWKSInvalid('JSON Web Key Set malformed');\n        }\n        this._jwks = clone(jwks);\n    }\n    async getKey(protectedHeader, token) {\n        const { alg, kid } = { ...protectedHeader, ...token === null || token === void 0 ? void 0 : token.header };\n        const kty = getKtyFromAlg(alg);\n        const candidates = this._jwks.keys.filter((jwk) => {\n            let candidate = kty === jwk.kty;\n            if (candidate && typeof kid === 'string') {\n                candidate = kid === jwk.kid;\n            }\n            if (candidate && typeof jwk.alg === 'string') {\n                candidate = alg === jwk.alg;\n            }\n            if (candidate && typeof jwk.use === 'string') {\n                candidate = jwk.use === 'sig';\n            }\n            if (candidate && Array.isArray(jwk.key_ops)) {\n                candidate = jwk.key_ops.includes('verify');\n            }\n            if (candidate && alg === 'EdDSA') {\n                candidate = jwk.crv === 'Ed25519' || jwk.crv === 'Ed448';\n            }\n            if (candidate) {\n                switch (alg) {\n                    case 'ES256':\n                        candidate = jwk.crv === 'P-256';\n                        break;\n                    case 'ES256K':\n                        candidate = jwk.crv === 'secp256k1';\n                        break;\n                    case 'ES384':\n                        candidate = jwk.crv === 'P-384';\n                        break;\n                    case 'ES512':\n                        candidate = jwk.crv === 'P-521';\n                        break;\n                }\n            }\n            return candidate;\n        });\n        const { 0: jwk, length } = candidates;\n        if (length === 0) {\n            throw new JWKSNoMatchingKey();\n        }\n        else if (length !== 1) {\n            const error = new JWKSMultipleMatchingKeys();\n            const { _cached } = this;\n            error[Symbol.asyncIterator] = async function* () {\n                for (const jwk of candidates) {\n                    try {\n                        yield await importWithAlgCache(_cached, jwk, alg);\n                    }\n                    catch {\n                        continue;\n                    }\n                }\n            };\n            throw error;\n        }\n        return importWithAlgCache(this._cached, jwk, alg);\n    }\n}\nasync function importWithAlgCache(cache, jwk, alg) {\n    const cached = cache.get(jwk) || cache.set(jwk, {}).get(jwk);\n    if (cached[alg] === undefined) {\n        const key = await importJWK({ ...jwk, ext: true }, alg);\n        if (key instanceof Uint8Array || key.type !== 'public') {\n            throw new JWKSInvalid('JSON Web Key Set members must be public keys');\n        }\n        cached[alg] = key;\n    }\n    return cached[alg];\n}\nexport function createLocalJWKSet(jwks) {\n    const set = new LocalJWKSet(jwks);\n    return async function (protectedHeader, token) {\n        return set.getKey(protectedHeader, token);\n    };\n}\n","import fetchJwks from '../runtime/fetch_jwks.js';\nimport { JWKSInvalid, JWKSNoMatchingKey } from '../util/errors.js';\nimport { isJWKSLike, LocalJWKSet } from './local.js';\nfunction isCloudflareWorkers() {\n    return (typeof WebSocketPair !== 'undefined' ||\n        (typeof navigator !== 'undefined' && navigator.userAgent === 'Cloudflare-Workers') ||\n        (typeof EdgeRuntime !== 'undefined' && EdgeRuntime === 'vercel'));\n}\nclass RemoteJWKSet extends LocalJWKSet {\n    constructor(url, options) {\n        super({ keys: [] });\n        this._jwks = undefined;\n        if (!(url instanceof URL)) {\n            throw new TypeError('url must be an instance of URL');\n        }\n        this._url = new URL(url.href);\n        this._options = { agent: options === null || options === void 0 ? void 0 : options.agent, headers: options === null || options === void 0 ? void 0 : options.headers };\n        this._timeoutDuration =\n            typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === 'number' ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5000;\n        this._cooldownDuration =\n            typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === 'number' ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 30000;\n        this._cacheMaxAge = typeof (options === null || options === void 0 ? void 0 : options.cacheMaxAge) === 'number' ? options === null || options === void 0 ? void 0 : options.cacheMaxAge : 600000;\n    }\n    coolingDown() {\n        return typeof this._jwksTimestamp === 'number'\n            ? Date.now() < this._jwksTimestamp + this._cooldownDuration\n            : false;\n    }\n    fresh() {\n        return typeof this._jwksTimestamp === 'number'\n            ? Date.now() < this._jwksTimestamp + this._cacheMaxAge\n            : false;\n    }\n    async getKey(protectedHeader, token) {\n        if (!this._jwks || !this.fresh()) {\n            await this.reload();\n        }\n        try {\n            return await super.getKey(protectedHeader, token);\n        }\n        catch (err) {\n            if (err instanceof JWKSNoMatchingKey) {\n                if (this.coolingDown() === false) {\n                    await this.reload();\n                    return super.getKey(protectedHeader, token);\n                }\n            }\n            throw err;\n        }\n    }\n    async reload() {\n        if (this._pendingFetch && isCloudflareWorkers()) {\n            this._pendingFetch = undefined;\n        }\n        this._pendingFetch || (this._pendingFetch = fetchJwks(this._url, this._timeoutDuration, this._options)\n            .then((json) => {\n            if (!isJWKSLike(json)) {\n                throw new JWKSInvalid('JSON Web Key Set malformed');\n            }\n            this._jwks = { keys: json.keys };\n            this._jwksTimestamp = Date.now();\n            this._pendingFetch = undefined;\n        })\n            .catch((err) => {\n            this._pendingFetch = undefined;\n            throw err;\n        }));\n        await this._pendingFetch;\n    }\n}\nexport function createRemoteJWKSet(url, options) {\n    const set = new RemoteJWKSet(url, options);\n    return async function (protectedHeader, token) {\n        return set.getKey(protectedHeader, token);\n    };\n}\n","import { createDecipheriv, KeyObject } from 'crypto';\nimport checkIvLength from '../lib/check_iv_length.js';\nimport checkCekLength from './check_cek_length.js';\nimport { concat } from '../lib/buffer_utils.js';\nimport { JOSENotSupported, JWEDecryptionFailed } from '../util/errors.js';\nimport timingSafeEqual from './timing_safe_equal.js';\nimport cbcTag from './cbc_tag.js';\nimport { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport isKeyObject from './is_key_object.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport supported from './ciphers.js';\nimport { types } from './is_key_like.js';\nfunction cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {\n    const keySize = parseInt(enc.slice(1, 4), 10);\n    if (isKeyObject(cek)) {\n        cek = cek.export();\n    }\n    const encKey = cek.subarray(keySize >> 3);\n    const macKey = cek.subarray(0, keySize >> 3);\n    const macSize = parseInt(enc.slice(-3), 10);\n    const algorithm = `aes-${keySize}-cbc`;\n    if (!supported(algorithm)) {\n        throw new JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);\n    }\n    const expectedTag = cbcTag(aad, iv, ciphertext, macSize, macKey, keySize);\n    let macCheckPassed;\n    try {\n        macCheckPassed = timingSafeEqual(tag, expectedTag);\n    }\n    catch {\n    }\n    if (!macCheckPassed) {\n        throw new JWEDecryptionFailed();\n    }\n    let plaintext;\n    try {\n        const decipher = createDecipheriv(algorithm, encKey, iv);\n        plaintext = concat(decipher.update(ciphertext), decipher.final());\n    }\n    catch {\n    }\n    if (!plaintext) {\n        throw new JWEDecryptionFailed();\n    }\n    return plaintext;\n}\nfunction gcmDecrypt(enc, cek, ciphertext, iv, tag, aad) {\n    const keySize = parseInt(enc.slice(1, 4), 10);\n    const algorithm = `aes-${keySize}-gcm`;\n    if (!supported(algorithm)) {\n        throw new JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);\n    }\n    try {\n        const decipher = createDecipheriv(algorithm, cek, iv, { authTagLength: 16 });\n        decipher.setAuthTag(tag);\n        if (aad.byteLength) {\n            decipher.setAAD(aad, { plaintextLength: ciphertext.length });\n        }\n        const plaintext = decipher.update(ciphertext);\n        decipher.final();\n        return plaintext;\n    }\n    catch {\n        throw new JWEDecryptionFailed();\n    }\n}\nconst decrypt = (enc, cek, ciphertext, iv, tag, aad) => {\n    let key;\n    if (isCryptoKey(cek)) {\n        checkEncCryptoKey(cek, enc, 'decrypt');\n        key = KeyObject.from(cek);\n    }\n    else if (cek instanceof Uint8Array || isKeyObject(cek)) {\n        key = cek;\n    }\n    else {\n        throw new TypeError(invalidKeyInput(cek, ...types, 'Uint8Array'));\n    }\n    checkCekLength(enc, key);\n    checkIvLength(enc, iv);\n    switch (enc) {\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            return cbcDecrypt(enc, key, ciphertext, iv, tag, aad);\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            return gcmDecrypt(enc, key, ciphertext, iv, tag, aad);\n        default:\n            throw new JOSENotSupported('Unsupported JWE Content Encryption Algorithm');\n    }\n};\nexport default decrypt;\n","import { CompactEncrypt } from '../jwe/compact/encrypt.js';\nimport { encoder } from '../lib/buffer_utils.js';\nimport { ProduceJWT } from './produce.js';\nexport class EncryptJWT extends ProduceJWT {\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setKeyManagementParameters(parameters) {\n        if (this._keyManagementParameters) {\n            throw new TypeError('setKeyManagementParameters can only be called once');\n        }\n        this._keyManagementParameters = parameters;\n        return this;\n    }\n    setContentEncryptionKey(cek) {\n        if (this._cek) {\n            throw new TypeError('setContentEncryptionKey can only be called once');\n        }\n        this._cek = cek;\n        return this;\n    }\n    setInitializationVector(iv) {\n        if (this._iv) {\n            throw new TypeError('setInitializationVector can only be called once');\n        }\n        this._iv = iv;\n        return this;\n    }\n    replicateIssuerAsHeader() {\n        this._replicateIssuerAsHeader = true;\n        return this;\n    }\n    replicateSubjectAsHeader() {\n        this._replicateSubjectAsHeader = true;\n        return this;\n    }\n    replicateAudienceAsHeader() {\n        this._replicateAudienceAsHeader = true;\n        return this;\n    }\n    async encrypt(key, options) {\n        const enc = new CompactEncrypt(encoder.encode(JSON.stringify(this._payload)));\n        if (this._replicateIssuerAsHeader) {\n            this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss };\n        }\n        if (this._replicateSubjectAsHeader) {\n            this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub };\n        }\n        if (this._replicateAudienceAsHeader) {\n            this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud };\n        }\n        enc.setProtectedHeader(this._protectedHeader);\n        if (this._iv) {\n            enc.setInitializationVector(this._iv);\n        }\n        if (this._cek) {\n            enc.setContentEncryptionKey(this._cek);\n        }\n        if (this._keyManagementParameters) {\n            enc.setKeyManagementParameters(this._keyManagementParameters);\n        }\n        return enc.encrypt(key, options);\n    }\n}\n","import { importJWK } from '../key/import.js';\nimport isObject from '../lib/is_object.js';\nimport { JWSInvalid } from '../util/errors.js';\nexport async function EmbeddedJWK(protectedHeader, token) {\n    const joseHeader = {\n        ...protectedHeader,\n        ...token === null || token === void 0 ? void 0 : token.header,\n    };\n    if (!isObject(joseHeader.jwk)) {\n        throw new JWSInvalid('\"jwk\" (JSON Web Key) Header Parameter must be a JSON object');\n    }\n    const key = await importJWK({ ...joseHeader.jwk, ext: true }, joseHeader.alg, true);\n    if (key instanceof Uint8Array || key.type !== 'public') {\n        throw new JWSInvalid('\"jwk\" (JSON Web Key) Header Parameter must be a public key');\n    }\n    return key;\n}\n","import epoch from '../lib/epoch.js';\nimport isObject from '../lib/is_object.js';\nimport secs from '../lib/secs.js';\nexport class ProduceJWT {\n    constructor(payload) {\n        if (!isObject(payload)) {\n            throw new TypeError('JWT Claims Set MUST be an object');\n        }\n        this._payload = payload;\n    }\n    setIssuer(issuer) {\n        this._payload = { ...this._payload, iss: issuer };\n        return this;\n    }\n    setSubject(subject) {\n        this._payload = { ...this._payload, sub: subject };\n        return this;\n    }\n    setAudience(audience) {\n        this._payload = { ...this._payload, aud: audience };\n        return this;\n    }\n    setJti(jwtId) {\n        this._payload = { ...this._payload, jti: jwtId };\n        return this;\n    }\n    setNotBefore(input) {\n        if (typeof input === 'number') {\n            this._payload = { ...this._payload, nbf: input };\n        }\n        else {\n            this._payload = { ...this._payload, nbf: epoch(new Date()) + secs(input) };\n        }\n        return this;\n    }\n    setExpirationTime(input) {\n        if (typeof input === 'number') {\n            this._payload = { ...this._payload, exp: input };\n        }\n        else {\n            this._payload = { ...this._payload, exp: epoch(new Date()) + secs(input) };\n        }\n        return this;\n    }\n    setIssuedAt(input) {\n        if (typeof input === 'undefined') {\n            this._payload = { ...this._payload, iat: epoch(new Date()) };\n        }\n        else {\n            this._payload = { ...this._payload, iat: input };\n        }\n        return this;\n    }\n}\n","import { compactVerify } from '../jws/compact/verify.js';\nimport jwtPayload from '../lib/jwt_claims_set.js';\nimport { JWTInvalid } from '../util/errors.js';\nexport async function jwtVerify(jwt, key, options) {\n    var _a;\n    const verified = await compactVerify(jwt, key, options);\n    if (((_a = verified.protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes('b64')) && verified.protectedHeader.b64 === false) {\n        throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n    }\n    const payload = jwtPayload(verified.protectedHeader, verified.payload, options);\n    const result = { payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n","import { compactDecrypt } from '../jwe/compact/decrypt.js';\nimport jwtPayload from '../lib/jwt_claims_set.js';\nimport { JWTClaimValidationFailed } from '../util/errors.js';\nexport async function jwtDecrypt(jwt, key, options) {\n    const decrypted = await compactDecrypt(jwt, key, options);\n    const payload = jwtPayload(decrypted.protectedHeader, decrypted.plaintext, options);\n    const { protectedHeader } = decrypted;\n    if (protectedHeader.iss !== undefined && protectedHeader.iss !== payload.iss) {\n        throw new JWTClaimValidationFailed('replicated \"iss\" claim header parameter mismatch', 'iss', 'mismatch');\n    }\n    if (protectedHeader.sub !== undefined && protectedHeader.sub !== payload.sub) {\n        throw new JWTClaimValidationFailed('replicated \"sub\" claim header parameter mismatch', 'sub', 'mismatch');\n    }\n    if (protectedHeader.aud !== undefined &&\n        JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {\n        throw new JWTClaimValidationFailed('replicated \"aud\" claim header parameter mismatch', 'aud', 'mismatch');\n    }\n    const result = { payload, protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: decrypted.key };\n    }\n    return result;\n}\n","import { flattenedVerify } from '../flattened/verify.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { decoder } from '../../lib/buffer_utils.js';\nexport async function compactVerify(jws, key, options) {\n    if (jws instanceof Uint8Array) {\n        jws = decoder.decode(jws);\n    }\n    if (typeof jws !== 'string') {\n        throw new JWSInvalid('Compact JWS must be a string or Uint8Array');\n    }\n    const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split('.');\n    if (length !== 3) {\n        throw new JWSInvalid('Invalid Compact JWS');\n    }\n    const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);\n    const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n","import { flattenedVerify } from '../flattened/verify.js';\nimport { JWSInvalid, JWSSignatureVerificationFailed } from '../../util/errors.js';\nimport isObject from '../../lib/is_object.js';\nexport async function generalVerify(jws, key, options) {\n    if (!isObject(jws)) {\n        throw new JWSInvalid('General JWS must be an object');\n    }\n    if (!Array.isArray(jws.signatures) || !jws.signatures.every(isObject)) {\n        throw new JWSInvalid('JWS Signatures missing or incorrect type');\n    }\n    for (const signature of jws.signatures) {\n        try {\n            return await flattenedVerify({\n                header: signature.header,\n                payload: jws.payload,\n                protected: signature.protected,\n                signature: signature.signature,\n            }, key, options);\n        }\n        catch {\n        }\n    }\n    throw new JWSSignatureVerificationFailed();\n}\n","import { flattenedDecrypt } from '../flattened/decrypt.js';\nimport { JWEInvalid } from '../../util/errors.js';\nimport { decoder } from '../../lib/buffer_utils.js';\nexport async function compactDecrypt(jwe, key, options) {\n    if (jwe instanceof Uint8Array) {\n        jwe = decoder.decode(jwe);\n    }\n    if (typeof jwe !== 'string') {\n        throw new JWEInvalid('Compact JWE must be a string or Uint8Array');\n    }\n    const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag, length, } = jwe.split('.');\n    if (length !== 5) {\n        throw new JWEInvalid('Invalid Compact JWE');\n    }\n    const decrypted = await flattenedDecrypt({\n        ciphertext,\n        iv: (iv || undefined),\n        protected: protectedHeader || undefined,\n        tag: (tag || undefined),\n        encrypted_key: encryptedKey || undefined,\n    }, key, options);\n    const result = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: decrypted.key };\n    }\n    return result;\n}\n","import { flattenedDecrypt } from '../flattened/decrypt.js';\nimport { JWEDecryptionFailed, JWEInvalid } from '../../util/errors.js';\nimport isObject from '../../lib/is_object.js';\nexport async function generalDecrypt(jwe, key, options) {\n    if (!isObject(jwe)) {\n        throw new JWEInvalid('General JWE must be an object');\n    }\n    if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(isObject)) {\n        throw new JWEInvalid('JWE Recipients missing or incorrect type');\n    }\n    if (!jwe.recipients.length) {\n        throw new JWEInvalid('JWE Recipients has no members');\n    }\n    for (const recipient of jwe.recipients) {\n        try {\n            return await flattenedDecrypt({\n                aad: jwe.aad,\n                ciphertext: jwe.ciphertext,\n                encrypted_key: recipient.encrypted_key,\n                header: recipient.header,\n                iv: jwe.iv,\n                protected: jwe.protected,\n                tag: jwe.tag,\n                unprotected: jwe.unprotected,\n            }, key, options);\n        }\n        catch {\n        }\n    }\n    throw new JWEDecryptionFailed();\n}\n","import { toSPKI as exportPublic } from '../runtime/asn1.js';\nimport { toPKCS8 as exportPrivate } from '../runtime/asn1.js';\nimport keyToJWK from '../runtime/key_to_jwk.js';\nexport async function exportSPKI(key) {\n    return exportPublic(key);\n}\nexport async function exportPKCS8(key) {\n    return exportPrivate(key);\n}\nexport async function exportJWK(key) {\n    return keyToJWK(key);\n}\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/sign/walletlink/relay/ui/components/cssReset/cssReset.ts","import { BaseError } from '../../errors/base.js'\n\nexport type BytecodeLengthExceedsMaxSizeErrorType =\n  BytecodeLengthExceedsMaxSizeError & {\n    name: 'BytecodeLengthExceedsMaxSizeError'\n  }\n\nexport class BytecodeLengthExceedsMaxSizeError extends BaseError {\n  constructor({\n    givenLength,\n    maxBytecodeSize,\n  }: { givenLength: number; maxBytecodeSize: bigint }) {\n    super(\n      `Bytecode cannot be longer than ${maxBytecodeSize} bytes. Given length: ${givenLength}`,\n      { name: 'BytecodeLengthExceedsMaxSizeError' },\n    )\n  }\n}\n\nexport type BytecodeLengthInWordsMustBeOddErrorType =\n  BytecodeLengthInWordsMustBeOddError & {\n    name: 'BytecodeLengthInWordsMustBeOddError'\n  }\n\nexport class BytecodeLengthInWordsMustBeOddError extends BaseError {\n  constructor({ givenLengthInWords }: { givenLengthInWords: number }) {\n    super(\n      `Bytecode length in 32-byte words must be odd. Given length in words: ${givenLengthInWords}`,\n      { name: 'BytecodeLengthInWordsMustBeOddError' },\n    )\n  }\n}\n\nexport type BytecodeLengthMustBeDivisibleBy32ErrorType =\n  BytecodeLengthMustBeDivisibleBy32Error & {\n    name: 'BytecodeLengthMustBeDivisibleBy32Error'\n  }\n\nexport class BytecodeLengthMustBeDivisibleBy32Error extends BaseError {\n  constructor({ givenLength }: { givenLength: number }) {\n    super(\n      `The bytecode length in bytes must be divisible by 32. Given length: ${givenLength}`,\n      { name: 'BytecodeLengthMustBeDivisibleBy32Error' },\n    )\n  }\n}\n","import {\n  config\n} from \"./chunk-EMSAO3AI.mjs\";\n\n// src/types/shared/evm/erc20PermitABI.ts\nvar usdcABI = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"spender\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"value\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"Approval\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"authorizer\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"bytes32\",\n        name: \"nonce\",\n        type: \"bytes32\"\n      }\n    ],\n    name: \"AuthorizationCanceled\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"authorizer\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"bytes32\",\n        name: \"nonce\",\n        type: \"bytes32\"\n      }\n    ],\n    name: \"AuthorizationUsed\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"_account\",\n        type: \"address\"\n      }\n    ],\n    name: \"Blacklisted\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newBlacklister\",\n        type: \"address\"\n      }\n    ],\n    name: \"BlacklisterChanged\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"burner\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"Burn\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newMasterMinter\",\n        type: \"address\"\n      }\n    ],\n    name: \"MasterMinterChanged\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"minter\",\n        type: \"address\"\n      },\n      { indexed: true, internalType: \"address\", name: \"to\", type: \"address\" },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"Mint\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"minter\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"minterAllowedAmount\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"MinterConfigured\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"oldMinter\",\n        type: \"address\"\n      }\n    ],\n    name: \"MinterRemoved\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"previousOwner\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"newOwner\",\n        type: \"address\"\n      }\n    ],\n    name: \"OwnershipTransferred\",\n    type: \"event\"\n  },\n  { anonymous: false, inputs: [], name: \"Pause\", type: \"event\" },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newAddress\",\n        type: \"address\"\n      }\n    ],\n    name: \"PauserChanged\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newRescuer\",\n        type: \"address\"\n      }\n    ],\n    name: \"RescuerChanged\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      { indexed: true, internalType: \"address\", name: \"from\", type: \"address\" },\n      { indexed: true, internalType: \"address\", name: \"to\", type: \"address\" },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"value\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"Transfer\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"_account\",\n        type: \"address\"\n      }\n    ],\n    name: \"UnBlacklisted\",\n    type: \"event\"\n  },\n  { anonymous: false, inputs: [], name: \"Unpause\", type: \"event\" },\n  {\n    inputs: [],\n    name: \"CANCEL_AUTHORIZATION_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"DOMAIN_SEPARATOR\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"PERMIT_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"RECEIVE_WITH_AUTHORIZATION_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"TRANSFER_WITH_AUTHORIZATION_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"owner\", type: \"address\" },\n      { internalType: \"address\", name: \"spender\", type: \"address\" }\n    ],\n    name: \"allowance\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" }\n    ],\n    name: \"approve\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"authorizer\", type: \"address\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" }\n    ],\n    name: \"authorizationState\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n    name: \"balanceOf\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_account\", type: \"address\" }],\n    name: \"blacklist\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"blacklister\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"uint256\", name: \"_amount\", type: \"uint256\" }],\n    name: \"burn\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"authorizer\", type: \"address\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\n      { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\n      { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" }\n    ],\n    name: \"cancelAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"authorizer\", type: \"address\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" }\n    ],\n    name: \"cancelAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"minter\", type: \"address\" },\n      { internalType: \"uint256\", name: \"minterAllowedAmount\", type: \"uint256\" }\n    ],\n    name: \"configureMinter\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"currency\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"decimals\",\n    outputs: [{ internalType: \"uint8\", name: \"\", type: \"uint8\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"decrement\", type: \"uint256\" }\n    ],\n    name: \"decreaseAllowance\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"increment\", type: \"uint256\" }\n    ],\n    name: \"increaseAllowance\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"string\", name: \"tokenName\", type: \"string\" },\n      { internalType: \"string\", name: \"tokenSymbol\", type: \"string\" },\n      { internalType: \"string\", name: \"tokenCurrency\", type: \"string\" },\n      { internalType: \"uint8\", name: \"tokenDecimals\", type: \"uint8\" },\n      { internalType: \"address\", name: \"newMasterMinter\", type: \"address\" },\n      { internalType: \"address\", name: \"newPauser\", type: \"address\" },\n      { internalType: \"address\", name: \"newBlacklister\", type: \"address\" },\n      { internalType: \"address\", name: \"newOwner\", type: \"address\" }\n    ],\n    name: \"initialize\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"string\", name: \"newName\", type: \"string\" }],\n    name: \"initializeV2\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"lostAndFound\", type: \"address\" }],\n    name: \"initializeV2_1\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address[]\",\n        name: \"accountsToBlacklist\",\n        type: \"address[]\"\n      },\n      { internalType: \"string\", name: \"newSymbol\", type: \"string\" }\n    ],\n    name: \"initializeV2_2\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_account\", type: \"address\" }],\n    name: \"isBlacklisted\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n    name: \"isMinter\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"masterMinter\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"_to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"_amount\", type: \"uint256\" }\n    ],\n    name: \"mint\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"minter\", type: \"address\" }],\n    name: \"minterAllowance\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"name\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"owner\", type: \"address\" }],\n    name: \"nonces\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"owner\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"pause\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"paused\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"pauser\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"owner\", type: \"address\" },\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" }\n    ],\n    name: \"permit\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"owner\", type: \"address\" },\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\n      { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\n      { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\n      { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" }\n    ],\n    name: \"permit\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" }\n    ],\n    name: \"receiveWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\n      { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\n      { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" }\n    ],\n    name: \"receiveWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"minter\", type: \"address\" }],\n    name: \"removeMinter\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"contract IERC20\",\n        name: \"tokenContract\",\n        type: \"address\"\n      },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"amount\", type: \"uint256\" }\n    ],\n    name: \"rescueERC20\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"rescuer\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"symbol\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" }\n    ],\n    name: \"transfer\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" }\n    ],\n    name: \"transferFrom\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"newOwner\", type: \"address\" }],\n    name: \"transferOwnership\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" }\n    ],\n    name: \"transferWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\n      { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\n      { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" }\n    ],\n    name: \"transferWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_account\", type: \"address\" }],\n    name: \"unBlacklist\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"unpause\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_newBlacklister\", type: \"address\" }],\n    name: \"updateBlacklister\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_newMasterMinter\", type: \"address\" }],\n    name: \"updateMasterMinter\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_newPauser\", type: \"address\" }],\n    name: \"updatePauser\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"newRescuer\", type: \"address\" }],\n    name: \"updateRescuer\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"version\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"pure\",\n    type: \"function\"\n  }\n];\n\n// src/shared/evm/usdc.ts\nfunction getUsdcAddress(client) {\n  return config[client.chain.id.toString()].usdcAddress;\n}\nfunction getUsdcAddressForChain(chainId) {\n  return config[chainId.toString()].usdcAddress;\n}\nfunction getUsdcChainConfigForChain(chainId) {\n  return config[chainId.toString()];\n}\nvar versionCache = null;\nasync function getVersion(client) {\n  if (versionCache !== null) {\n    return versionCache;\n  }\n  const version = await client.readContract({\n    address: getUsdcAddress(client),\n    abi: usdcABI,\n    functionName: \"version\"\n  });\n  versionCache = version;\n  return versionCache;\n}\nasync function getUSDCBalance(client, address) {\n  const chainId = client.chain.id;\n  const usdc = getUsdcChainConfigForChain(chainId);\n  if (!usdc) {\n    return 0n;\n  }\n  const balance = await client.readContract({\n    address: usdc.usdcAddress,\n    abi: usdcABI,\n    functionName: \"balanceOf\",\n    args: [address]\n  });\n  return balance;\n}\n\n// src/shared/evm/erc20.ts\nasync function getERC20Balance(client, erc20Address, address) {\n  const balance = await client.readContract({\n    address: erc20Address,\n    abi: usdcABI,\n    functionName: \"balanceOf\",\n    args: [address]\n  });\n  return balance;\n}\n\nexport {\n  usdcABI,\n  getUsdcAddress,\n  getUsdcAddressForChain,\n  getUsdcChainConfigForChain,\n  getVersion,\n  getUSDCBalance,\n  getERC20Balance\n};\n//# sourceMappingURL=chunk-K4TZLEOT.mjs.map","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","/**\n * This project is a fork of [nickyout/fast-stable-stringify](https://github.com/nickyout/fast-stable-stringify)\n *\n * The most popular repository providing this feature is [substack's json-stable-stringify](https://www.npmjs.com/package/json-stable-stringify). The intent of this library is to provide a faster alternative for when performance is more important than features. It assumes you provide basic javascript values without circular references, and returns a non-indented string.\n *\n * Just like substack's, it:\n *\n * - handles all variations of all basic javascript values (number, string, boolean, array, object, null, Date, BigInt)\n * - handles undefined _and_ function in the same way as `JSON.stringify`\n * - **does not support ie8 (and below) with complete certainty**.\n *\n * Unlike substack's, it:\n *\n * - does not implement the 'replacer' or 'space' arguments of the JSON.stringify method\n * - does not check for circular references\n *\n * @example\n * ```js\n * import stringify from '@solana/fast-stable-stringify';\n * stringify({ d: 0, c: 1, a: 2, b: 3, e: 4 }); // '{\"a\":2,\"b\":3,\"c\":1,\"d\":0,\"e\":4}'\n * ```\n *\n * @packageDocumentation\n */\nconst objToString = Object.prototype.toString;\nconst objKeys =\n    Object.keys ||\n    function (obj) {\n        const keys = [];\n        for (const name in obj) {\n            keys.push(name);\n        }\n        return keys;\n    };\n\nfunction stringify(val: unknown, isArrayProp: boolean) {\n    let i, max, str, keys, key, propVal, toStr;\n    if (val === true) {\n        return 'true';\n    }\n    if (val === false) {\n        return 'false';\n    }\n    switch (typeof val) {\n        case 'object':\n            if (val === null) {\n                return null;\n            } else if ('toJSON' in val && typeof val.toJSON === 'function') {\n                return stringify(val.toJSON(), isArrayProp);\n            } else {\n                toStr = objToString.call(val);\n                if (toStr === '[object Array]') {\n                    str = '[';\n                    max = (val as unknown[]).length - 1;\n                    for (i = 0; i < max; i++) {\n                        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                        str += stringify((val as unknown[])[i], true) + ',';\n                    }\n                    if (max > -1) {\n                        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                        str += stringify((val as unknown[])[i], true);\n                    }\n                    return str + ']';\n                } else if (toStr === '[object Object]') {\n                    // only object is left\n                    keys = objKeys(val).sort();\n                    max = keys.length;\n                    str = '';\n                    i = 0;\n                    while (i < max) {\n                        key = keys[i];\n                        propVal = stringify((val as Record<typeof key, unknown>)[key], false);\n                        if (propVal !== undefined) {\n                            if (str) {\n                                str += ',';\n                            }\n                            // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                            str += JSON.stringify(key) + ':' + propVal;\n                        }\n                        i++;\n                    }\n                    return '{' + str + '}';\n                } else {\n                    return JSON.stringify(val);\n                }\n            }\n        case 'function':\n        case 'undefined':\n            return isArrayProp ? null : undefined;\n        case 'bigint':\n            return `${val.toString()}n`;\n        case 'string':\n            return JSON.stringify(val);\n        default:\n            return isFinite(val as number) ? val : null;\n    }\n}\n\nexport default function (\n    val:\n        | Function // eslint-disable-line @typescript-eslint/no-unsafe-function-type\n        | undefined,\n): undefined;\nexport default function (val: unknown): string;\nexport default function (val: unknown): string | undefined {\n    const returnVal = stringify(val, false);\n    if (returnVal !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        return '' + returnVal;\n    }\n}\n","/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { type IField, nLength, validateField } from './modular.ts';\nimport { bitLen, bitMask, validateObject } from './utils.ts';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n\nexport type AffinePoint<T> = {\n  x: T;\n  y: T;\n} & { z?: never; t?: never };\n\nexport interface Group<T extends Group<T>> {\n  double(): T;\n  negate(): T;\n  add(other: T): T;\n  subtract(other: T): T;\n  equals(other: T): boolean;\n  multiply(scalar: bigint): T;\n}\n\nexport type GroupConstructor<T> = {\n  BASE: T;\n  ZERO: T;\n};\nexport type Mapper<T> = (i: T[]) => T[];\n\nfunction constTimeNegate<T extends Group<T>>(condition: boolean, item: T): T {\n  const neg = item.negate();\n  return condition ? neg : item;\n}\n\nfunction validateW(W: number, bits: number) {\n  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n    throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\n\n/** Internal wNAF opts for specific W and scalarBits */\nexport type WOpts = {\n  windows: number;\n  windowSize: number;\n  mask: bigint;\n  maxNumber: number;\n  shiftBy: bigint;\n};\n\nfunction calcWOpts(W: number, scalarBits: number): WOpts {\n  validateW(W, scalarBits);\n  const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n  const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n  const maxNumber = 2 ** W; // W=8 256\n  const mask = bitMask(W); // W=8 255 == mask 0b11111111\n  const shiftBy = BigInt(W); // W=8 8\n  return { windows, windowSize, mask, maxNumber, shiftBy };\n}\n\nfunction calcOffsets(n: bigint, window: number, wOpts: WOpts) {\n  const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n  let wbits = Number(n & mask); // extract W bits.\n  let nextN = n >> shiftBy; // shift number by W bits.\n\n  // What actually happens here:\n  // const highestBit = Number(mask ^ (mask >> 1n));\n  // let wbits2 = wbits - 1; // skip zero\n  // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n\n  // split if bits > max: +224 => 256-32\n  if (wbits > windowSize) {\n    // we skip zero, which means instead of `>= size-1`, we do `> size`\n    wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n    nextN += _1n; // +256 (carry)\n  }\n  const offsetStart = window * windowSize;\n  const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n  const isZero = wbits === 0; // is current window slice a 0?\n  const isNeg = wbits < 0; // is current window slice negative?\n  const isNegF = window % 2 !== 0; // fake random statement for noise\n  const offsetF = offsetStart; // fake offset for noise\n  return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\n\nfunction validateMSMPoints(points: any[], c: any) {\n  if (!Array.isArray(points)) throw new Error('array expected');\n  points.forEach((p, i) => {\n    if (!(p instanceof c)) throw new Error('invalid point at index ' + i);\n  });\n}\nfunction validateMSMScalars(scalars: any[], field: any) {\n  if (!Array.isArray(scalars)) throw new Error('array of scalars expected');\n  scalars.forEach((s, i) => {\n    if (!field.isValid(s)) throw new Error('invalid scalar at index ' + i);\n  });\n}\n\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap<any, any[]>();\nconst pointWindowSizes = new WeakMap<any, number>();\n\nfunction getW(P: any): number {\n  return pointWindowSizes.get(P) || 1;\n}\n\nexport type IWNAF<T extends Group<T>> = {\n  constTimeNegate: <T extends Group<T>>(condition: boolean, item: T) => T;\n  hasPrecomputes(elm: T): boolean;\n  unsafeLadder(elm: T, n: bigint, p?: T): T;\n  precomputeWindow(elm: T, W: number): Group<T>[];\n  getPrecomputes(W: number, P: T, transform: Mapper<T>): T[];\n  wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T };\n  wNAFUnsafe(W: number, precomputes: T[], n: bigint, acc?: T): T;\n  wNAFCached(P: T, n: bigint, transform: Mapper<T>): { p: T; f: T };\n  wNAFCachedUnsafe(P: T, n: bigint, transform: Mapper<T>, prev?: T): T;\n  setWindowSize(P: T, W: number): void;\n};\n\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport function wNAF<T extends Group<T>>(c: GroupConstructor<T>, bits: number): IWNAF<T> {\n  return {\n    constTimeNegate,\n\n    hasPrecomputes(elm: T) {\n      return getW(elm) !== 1;\n    },\n\n    // non-const time multiplication ladder\n    unsafeLadder(elm: T, n: bigint, p = c.ZERO) {\n      let d: T = elm;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    },\n\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(1) * (Math.ceil( / ) + 1), where:\n     * -  is the window size\n     * -  is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param elm Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(elm: T, W: number): Group<T>[] {\n      const { windows, windowSize } = calcWOpts(W, bits);\n      const points: T[] = [];\n      let p: T = elm;\n      let base = p;\n      for (let window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        // i=1, bc we skip 0\n        for (let i = 1; i < windowSize; i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    },\n\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T } {\n      // Smaller version:\n      // https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n      // TODO: check the scalar is less than group order?\n      // wNAF behavior is undefined otherwise. But have to carefully remove\n      // other checks before wNAF. ORDER == bits here.\n      // Accumulators\n      let p = c.ZERO;\n      let f = c.BASE;\n      // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n      // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n      // there is negate now: it is possible that negated element from low value\n      // would be the same as high element, which will create carry into next window.\n      // It's not obvious how this can fail, but still worth investigating later.\n      const wo = calcWOpts(W, bits);\n      for (let window = 0; window < wo.windows; window++) {\n        // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n        const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n        n = nextN;\n        if (isZero) {\n          // bits are 0: add garbage to fake point\n          // Important part for const-time getPublicKey: add random \"noise\" point to f.\n          f = f.add(constTimeNegate(isNegF, precomputes[offsetF]));\n        } else {\n          // bits are 1: add to result point\n          p = p.add(constTimeNegate(isNeg, precomputes[offset]));\n        }\n      }\n      // Return both real and fake points: JIT won't eliminate f.\n      // At this point there is a way to F be infinity-point even if p is not,\n      // which makes it less const-time: around 1 bigint multiply.\n      return { p, f };\n    },\n\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */\n    wNAFUnsafe(W: number, precomputes: T[], n: bigint, acc: T = c.ZERO): T {\n      const wo = calcWOpts(W, bits);\n      for (let window = 0; window < wo.windows; window++) {\n        if (n === _0n) break; // Early-exit, skip 0 value\n        const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n        n = nextN;\n        if (isZero) {\n          // Window bits are 0: skip processing.\n          // Move to next window.\n          continue;\n        } else {\n          const item = precomputes[offset];\n          acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n        }\n      }\n      return acc;\n    },\n\n    getPrecomputes(W: number, P: T, transform: Mapper<T>): T[] {\n      // Calculate precomputes on a first run, reuse them after\n      let comp = pointPrecomputes.get(P);\n      if (!comp) {\n        comp = this.precomputeWindow(P, W) as T[];\n        if (W !== 1) pointPrecomputes.set(P, transform(comp));\n      }\n      return comp;\n    },\n\n    wNAFCached(P: T, n: bigint, transform: Mapper<T>): { p: T; f: T } {\n      const W = getW(P);\n      return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n    },\n\n    wNAFCachedUnsafe(P: T, n: bigint, transform: Mapper<T>, prev?: T): T {\n      const W = getW(P);\n      if (W === 1) return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n      return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n    },\n\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n\n    setWindowSize(P: T, W: number) {\n      validateW(W, bits);\n      pointWindowSizes.set(P, W);\n      pointPrecomputes.delete(P);\n    },\n  };\n}\n\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nexport function pippenger<T extends Group<T>>(\n  c: GroupConstructor<T>,\n  fieldN: IField<bigint>,\n  points: T[],\n  scalars: bigint[]\n): T {\n  // If we split scalars by some window (let's say 8 bits), every chunk will only\n  // take 256 buckets even if there are 4096 scalars, also re-uses double.\n  // TODO:\n  // - https://eprint.iacr.org/2024/750.pdf\n  // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n  // 0 is accepted in scalars\n  validateMSMPoints(points, c);\n  validateMSMScalars(scalars, fieldN);\n  const plength = points.length;\n  const slength = scalars.length;\n  if (plength !== slength) throw new Error('arrays of points and scalars must have equal length');\n  // if (plength === 0) throw new Error('array must be of length >= 2');\n  const zero = c.ZERO;\n  const wbits = bitLen(BigInt(plength));\n  let windowSize = 1; // bits\n  if (wbits > 12) windowSize = wbits - 3;\n  else if (wbits > 4) windowSize = wbits - 2;\n  else if (wbits > 0) windowSize = 2;\n  const MASK = bitMask(windowSize);\n  const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n  let sum = zero;\n  for (let i = lastBits; i >= 0; i -= windowSize) {\n    buckets.fill(zero);\n    for (let j = 0; j < slength; j++) {\n      const scalar = scalars[j];\n      const wbits = Number((scalar >> BigInt(i)) & MASK);\n      buckets[wbits] = buckets[wbits].add(points[j]);\n    }\n    let resI = zero; // not using this will do small speed-up, but will lose ct\n    // Skip first bucket, because it is zero\n    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n      sumI = sumI.add(buckets[j]);\n      resI = resI.add(sumI);\n    }\n    sum = sum.add(resI);\n    if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();\n  }\n  return sum as T;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe<T extends Group<T>>(\n  c: GroupConstructor<T>,\n  fieldN: IField<bigint>,\n  points: T[],\n  windowSize: number\n): (scalars: bigint[]) => T {\n  /**\n   * Performance Analysis of Window-based Precomputation\n   *\n   * Base Case (256-bit scalar, 8-bit window):\n   * - Standard precomputation requires:\n   *   - 31 additions per scalar  256 scalars = 7,936 ops\n   *   - Plus 255 summary additions = 8,191 total ops\n   *   Note: Summary additions can be optimized via accumulator\n   *\n   * Chunked Precomputation Analysis:\n   * - Using 32 chunks requires:\n   *   - 255 additions per chunk\n   *   - 256 doublings\n   *   - Total: (255  32) + 256 = 8,416 ops\n   *\n   * Memory Usage Comparison:\n   * Window Size | Standard Points | Chunked Points\n   * ------------|-----------------|---------------\n   *     4-bit   |     520         |      15\n   *     8-bit   |    4,224        |     255\n   *    10-bit   |   13,824        |   1,023\n   *    16-bit   |  557,056        |  65,535\n   *\n   * Key Advantages:\n   * 1. Enables larger window sizes due to reduced memory overhead\n   * 2. More efficient for smaller scalar counts:\n   *    - 16 chunks: (16  255) + 256 = 4,336 ops\n   *    - ~2x faster than standard 8,191 ops\n   *\n   * Limitations:\n   * - Not suitable for plain precomputes (requires 256 constant doublings)\n   * - Performance degrades with larger scalar counts:\n   *   - Optimal for ~256 scalars\n   *   - Less efficient for 4096+ scalars (Pippenger preferred)\n   */\n  validateW(windowSize, fieldN.BITS);\n  validateMSMPoints(points, c);\n  const zero = c.ZERO;\n  const tableSize = 2 ** windowSize - 1; // table size (without zero)\n  const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n  const MASK = bitMask(windowSize);\n  const tables = points.map((p: T) => {\n    const res = [];\n    for (let i = 0, acc = p; i < tableSize; i++) {\n      res.push(acc);\n      acc = acc.add(p);\n    }\n    return res;\n  });\n  return (scalars: bigint[]): T => {\n    validateMSMScalars(scalars, fieldN);\n    if (scalars.length > points.length)\n      throw new Error('array of scalars must be smaller than array of points');\n    let res = zero;\n    for (let i = 0; i < chunks; i++) {\n      // No need to double if accumulator is still zero.\n      if (res !== zero) for (let j = 0; j < windowSize; j++) res = res.double();\n      const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n      for (let j = 0; j < scalars.length; j++) {\n        const n = scalars[j];\n        const curr = Number((n >> shiftBy) & MASK);\n        if (!curr) continue; // skip zero scalars chunks\n        res = res.add(tables[j][curr - 1]);\n      }\n    }\n    return res;\n  };\n}\n\n/**\n * Generic BasicCurve interface: works even for polynomial fields (BLS): P, n, h would be ok.\n * Though generator can be different (Fp2 / Fp6 for BLS).\n */\nexport type BasicCurve<T> = {\n  Fp: IField<T>; // Field over which we'll do calculations (Fp)\n  n: bigint; // Curve order, total count of valid points in the field\n  nBitLength?: number; // bit length of curve order\n  nByteLength?: number; // byte length of curve order\n  h: bigint; // cofactor. we can assign default=1, but users will just ignore it w/o validation\n  hEff?: bigint; // Number to multiply to clear cofactor\n  Gx: T; // base point X coordinate\n  Gy: T; // base point Y coordinate\n  allowInfinityPoint?: boolean; // bls12-381 requires it. ZERO point is valid, but invalid pubkey\n};\n\nexport function validateBasic<FP, T>(\n  curve: BasicCurve<FP> & T\n): Readonly<\n  {\n    readonly nBitLength: number;\n    readonly nByteLength: number;\n  } & BasicCurve<FP> &\n    T & {\n      p: bigint;\n    }\n> {\n  validateField(curve.Fp);\n  validateObject(\n    curve,\n    {\n      n: 'bigint',\n      h: 'bigint',\n      Gx: 'field',\n      Gy: 'field',\n    },\n    {\n      nBitLength: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n    }\n  );\n  // Set defaults\n  return Object.freeze({\n    ...nLength(curve.n, curve.nBitLength),\n    ...curve,\n    ...{ p: curve.Fp.ORDER },\n  } as const);\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type {\n  AuthorizationRequest,\n  SignedAuthorization,\n} from '../../types/authorization.js'\nimport type { Hex, Signature } from '../../types/misc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type HashAuthorizationErrorType,\n  hashAuthorization,\n} from '../../utils/authorization/hashAuthorization.js'\nimport {\n  type SignErrorType,\n  type SignParameters,\n  type SignReturnType,\n  sign,\n} from './sign.js'\n\ntype To = 'object' | 'bytes' | 'hex'\n\nexport type SignAuthorizationParameters<to extends To = 'object'> =\n  AuthorizationRequest & {\n    /** The private key to sign with. */\n    privateKey: Hex\n    to?: SignParameters<to>['to'] | undefined\n  }\n\nexport type SignAuthorizationReturnType<to extends To = 'object'> = Prettify<\n  to extends 'object' ? SignedAuthorization : SignReturnType<to>\n>\n\nexport type SignAuthorizationErrorType =\n  | SignErrorType\n  | HashAuthorizationErrorType\n  | ErrorType\n\n/**\n * Signs an Authorization hash in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n */\nexport async function signAuthorization<to extends To = 'object'>(\n  parameters: SignAuthorizationParameters<to>,\n): Promise<SignAuthorizationReturnType<to>> {\n  const { chainId, nonce, privateKey, to = 'object' } = parameters\n  const address = parameters.contractAddress ?? parameters.address\n  const signature = await sign({\n    hash: hashAuthorization({ address, chainId, nonce }),\n    privateKey,\n    to,\n  })\n  if (to === 'object')\n    return {\n      address,\n      chainId,\n      nonce,\n      ...(signature as Signature),\n    } as any\n  return signature as any\n}\n","import encrypt from '../runtime/encrypt.js';\nimport decrypt from '../runtime/decrypt.js';\nimport generateIv from './iv.js';\nimport { encode as base64url } from '../runtime/base64url.js';\nexport async function wrap(alg, key, cek, iv) {\n    const jweAlgorithm = alg.slice(0, 7);\n    iv || (iv = generateIv(jweAlgorithm));\n    const { ciphertext: encryptedKey, tag } = await encrypt(jweAlgorithm, cek, key, iv, new Uint8Array(0));\n    return { encryptedKey, iv: base64url(iv), tag: base64url(tag) };\n}\nexport async function unwrap(alg, key, encryptedKey, iv, tag) {\n    const jweAlgorithm = alg.slice(0, 7);\n    return decrypt(jweAlgorithm, key, encryptedKey, iv, tag, new Uint8Array(0));\n}\n","import { CompactSign } from '../jws/compact/sign.js';\nimport { JWTInvalid } from '../util/errors.js';\nimport { encoder } from '../lib/buffer_utils.js';\nimport { ProduceJWT } from './produce.js';\nexport class SignJWT extends ProduceJWT {\n    setProtectedHeader(protectedHeader) {\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        var _a;\n        const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));\n        sig.setProtectedHeader(this._protectedHeader);\n        if (Array.isArray((_a = this._protectedHeader) === null || _a === void 0 ? void 0 : _a.crit) &&\n            this._protectedHeader.crit.includes('b64') &&\n            this._protectedHeader.b64 === false) {\n            throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n        }\n        return sig.sign(key, options);\n    }\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n} from '@solana/kit';\n\nexport enum AccountState {\n  Uninitialized,\n  Initialized,\n  Frozen,\n}\n\nexport type AccountStateArgs = AccountState;\n\nexport function getAccountStateEncoder(): FixedSizeEncoder<AccountStateArgs> {\n  return getEnumEncoder(AccountState);\n}\n\nexport function getAccountStateDecoder(): FixedSizeDecoder<AccountState> {\n  return getEnumDecoder(AccountState);\n}\n\nexport function getAccountStateCodec(): FixedSizeCodec<\n  AccountStateArgs,\n  AccountState\n> {\n  return combineCodec(getAccountStateEncoder(), getAccountStateDecoder());\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  TransactionSerializable,\n  TransactionSerialized,\n} from '../../types/transaction.js'\nimport {\n  type Keccak256ErrorType,\n  keccak256,\n} from '../../utils/hash/keccak256.js'\nimport type { GetTransactionType } from '../../utils/transaction/getTransactionType.js'\nimport {\n  type SerializeTransactionFn,\n  serializeTransaction,\n} from '../../utils/transaction/serializeTransaction.js'\n\nimport { type SignErrorType, sign } from './sign.js'\n\nexport type SignTransactionParameters<\n  serializer extends\n    SerializeTransactionFn<TransactionSerializable> = SerializeTransactionFn<TransactionSerializable>,\n  transaction extends Parameters<serializer>[0] = Parameters<serializer>[0],\n> = {\n  privateKey: Hex\n  transaction: transaction\n  serializer?: serializer | undefined\n}\n\nexport type SignTransactionReturnType<\n  serializer extends\n    SerializeTransactionFn<TransactionSerializable> = SerializeTransactionFn<TransactionSerializable>,\n  transaction extends Parameters<serializer>[0] = Parameters<serializer>[0],\n> = TransactionSerialized<GetTransactionType<transaction>>\n\nexport type SignTransactionErrorType =\n  | Keccak256ErrorType\n  | SignErrorType\n  | ErrorType\n\nexport async function signTransaction<\n  serializer extends\n    SerializeTransactionFn<TransactionSerializable> = SerializeTransactionFn<TransactionSerializable>,\n  transaction extends Parameters<serializer>[0] = Parameters<serializer>[0],\n>(\n  parameters: SignTransactionParameters<serializer, transaction>,\n): Promise<SignTransactionReturnType<serializer, transaction>> {\n  const {\n    privateKey,\n    transaction,\n    serializer = serializeTransaction,\n  } = parameters\n\n  const signableTransaction = (() => {\n    // For EIP-4844 Transactions, we want to sign the transaction payload body (tx_payload_body) without the sidecars (ie. without the network wrapper).\n    // See: https://github.com/ethereum/EIPs/blob/e00f4daa66bd56e2dbd5f1d36d09fd613811a48b/EIPS/eip-4844.md#networking\n    if (transaction.type === 'eip4844')\n      return {\n        ...transaction,\n        sidecars: false,\n      }\n    return transaction\n  })()\n\n  const signature = await sign({\n    hash: keccak256(await serializer(signableTransaction)),\n    privateKey,\n  })\n  return (await serializer(\n    transaction,\n    signature,\n  )) as SignTransactionReturnType<serializer, transaction>\n}\n","import type { EIP1193Provider } from './register.js'\nimport type {\n  EIP6963AnnounceProviderEvent,\n  EIP6963ProviderDetail,\n} from './types.js'\n\n////////////////////////////////////////////////////////////////////////////\n// Announce Provider\n\nexport type AnnounceProviderParameters = EIP6963ProviderDetail<\n  EIP1193Provider,\n  string\n>\nexport type AnnounceProviderReturnType = () => void\n\n/**\n * Announces an EIP-1193 Provider.\n */\nexport function announceProvider(\n  detail: AnnounceProviderParameters,\n): AnnounceProviderReturnType {\n  const event: CustomEvent<EIP6963ProviderDetail> = new CustomEvent(\n    'eip6963:announceProvider',\n    { detail: Object.freeze(detail) },\n  )\n\n  window.dispatchEvent(event)\n\n  const handler = () => window.dispatchEvent(event)\n  window.addEventListener('eip6963:requestProvider', handler)\n  return () => window.removeEventListener('eip6963:requestProvider', handler)\n}\n\n////////////////////////////////////////////////////////////////////////////\n// Request Providers\n\nexport type RequestProvidersParameters = (\n  providerDetail: EIP6963ProviderDetail,\n) => void\nexport type RequestProvidersReturnType = (() => void) | undefined\n\n/**\n * Watches for EIP-1193 Providers to be announced.\n */\nexport function requestProviders(\n  listener: RequestProvidersParameters,\n): RequestProvidersReturnType {\n  if (typeof window === 'undefined') return\n  const handler = (event: EIP6963AnnounceProviderEvent) =>\n    listener(event.detail)\n\n  window.addEventListener('eip6963:announceProvider', handler)\n\n  window.dispatchEvent(new CustomEvent('eip6963:requestProvider'))\n\n  return () => window.removeEventListener('eip6963:announceProvider', handler)\n}\n","import { ZodError, ZodIssueCode, } from \"./ZodError.js\";\nimport { defaultErrorMap, getErrorMap } from \"./errors.js\";\nimport { errorUtil } from \"./helpers/errorUtil.js\";\nimport { DIRTY, INVALID, OK, ParseStatus, addIssueToContext, isAborted, isAsync, isDirty, isValid, makeIssue, } from \"./helpers/parseUtil.js\";\nimport { util, ZodParsedType, getParsedType } from \"./helpers/util.js\";\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (Array.isArray(this._key)) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if (isValid(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        const { message } = params;\n        if (iss.code === \"invalid_enum_value\") {\n            return { message: message ?? ctx.defaultError };\n        }\n        if (typeof ctx.data === \"undefined\") {\n            return { message: message ?? required_error ?? ctx.defaultError };\n        }\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        return { message: message ?? invalid_type_error ?? ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nexport class ZodType {\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: params?.async ?? false,\n                contextualErrorMap: params?.errorMap,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    \"~validate\"(data) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: !!this[\"~standard\"].async,\n            },\n            path: [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        if (!this[\"~standard\"].async) {\n            try {\n                const result = this._parseSync({ data, path: [], parent: ctx });\n                return isValid(result)\n                    ? {\n                        value: result.value,\n                    }\n                    : {\n                        issues: ctx.common.issues,\n                    };\n            }\n            catch (err) {\n                if (err?.message?.toLowerCase()?.includes(\"encountered\")) {\n                    this[\"~standard\"].async = true;\n                }\n                ctx.common = {\n                    issues: [],\n                    async: true,\n                };\n            }\n        }\n        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result)\n            ? {\n                value: result.value,\n            }\n            : {\n                issues: ctx.common.issues,\n            });\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params?.errorMap,\n                async: true,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n        this[\"~standard\"] = {\n            version: 1,\n            vendor: \"zod\",\n            validate: (data) => this[\"~validate\"](data),\n        };\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[0-9a-z]+$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\nconst jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nconst durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\n// faster, simpler, safer\nconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nconst ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\n// const ipv6Regex =\n// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nconst ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nconst ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n// https://base64.guru/standards/base64url\nconst base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\n// simple\n// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\n// no leap year validation\n// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\n// with leap year validation\nconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n    let secondsRegexSource = `[0-5]\\\\d`;\n    if (args.precision) {\n        secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n    }\n    else if (args.precision == null) {\n        secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n    }\n    const secondsQuantifier = args.precision ? \"+\" : \"?\"; // require seconds if precision is nonzero\n    return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n    return new RegExp(`^${timeRegexSource(args)}$`);\n}\n// Adapted from https://stackoverflow.com/a/3143231\nexport function datetimeRegex(args) {\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n    const opts = [];\n    opts.push(args.local ? `Z?` : `Z`);\n    if (args.offset)\n        opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n    regex = `${regex}(${opts.join(\"|\")})`;\n    return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nfunction isValidJWT(jwt, alg) {\n    if (!jwtRegex.test(jwt))\n        return false;\n    try {\n        const [header] = jwt.split(\".\");\n        if (!header)\n            return false;\n        // Convert base64url to base64\n        const base64 = header\n            .replace(/-/g, \"+\")\n            .replace(/_/g, \"/\")\n            .padEnd(header.length + ((4 - (header.length % 4)) % 4), \"=\");\n        const decoded = JSON.parse(atob(base64));\n        if (typeof decoded !== \"object\" || decoded === null)\n            return false;\n        if (\"typ\" in decoded && decoded?.typ !== \"JWT\")\n            return false;\n        if (!decoded.alg)\n            return false;\n        if (alg && decoded.alg !== alg)\n            return false;\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nfunction isValidCidr(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nexport class ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"nanoid\") {\n                if (!nanoidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"nanoid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                }\n                catch {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"date\") {\n                const regex = dateRegex;\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"date\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"time\") {\n                const regex = timeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"time\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"duration\") {\n                if (!durationRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"duration\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"jwt\") {\n                if (!isValidJWT(input.data, check.alg)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"jwt\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cidr\") {\n                if (!isValidCidr(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cidr\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64\") {\n                if (!base64Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64url\") {\n                if (!base64urlRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n    }\n    nanoid(message) {\n        return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n    }\n    base64(message) {\n        return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\n    }\n    base64url(message) {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return this._addCheck({\n            kind: \"base64url\",\n            ...errorUtil.errToObj(message),\n        });\n    }\n    jwt(options) {\n        return this._addCheck({ kind: \"jwt\", ...errorUtil.errToObj(options) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n    }\n    cidr(options) {\n        return this._addCheck({ kind: \"cidr\", ...errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                local: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            offset: options?.offset ?? false,\n            local: options?.local ?? false,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    date(message) {\n        return this._addCheck({ kind: \"date\", message });\n    }\n    time(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"time\",\n                precision: null,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"time\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    duration(message) {\n        return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options?.position,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    /**\n     * Equivalent to `.min(1)`\n     */\n    nonempty(message) {\n        return this.min(1, errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isDate() {\n        return !!this._def.checks.find((ch) => ch.kind === \"date\");\n    }\n    get isTime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"time\");\n    }\n    get isDuration() {\n        return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isNANOID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get isCIDR() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\n    }\n    get isBase64() {\n        return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n    }\n    get isBase64url() {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params) => {\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / 10 ** decCount;\n}\nexport class ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" || (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null;\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            try {\n                input.data = BigInt(input.data);\n            }\n            catch {\n                return this._getInvalidInput(input);\n            }\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            return this._getInvalidInput(input);\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _getInvalidInput(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.bigint,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params) => {\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (Number.isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: params?.coerce || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nexport class ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        this._cached = { shape, keys };\n        return this._cached;\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") {\n            }\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    syncPairs.push({\n                        key,\n                        value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: errorUtil.errToObj(message).message ?? defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(mask)) {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return util.objectValues(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else if (type instanceof ZodOptional) {\n        return [undefined, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodNullable) {\n        return [null, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodBranded) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodReadonly) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodCatch) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else {\n        return [];\n    }\n};\nexport class ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues.length) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nexport class ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types,\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\n// type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];\nexport class ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nexport class ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(async function (...args) {\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(function (...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args ? args : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nexport class ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nexport class ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(this._def.values);\n        }\n        if (!this._cache.has(input.data)) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values, newDef = this._def) {\n        return ZodEnum.create(values, {\n            ...this._def,\n            ...newDef,\n        });\n    }\n    exclude(values, newDef = this._def) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n            ...this._def,\n            ...newDef,\n        });\n    }\n}\nZodEnum.create = createZodEnum;\nexport class ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(util.getValidEnumValues(this._def.values));\n        }\n        if (!this._cache.has(input.data)) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n        return OK(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg) => {\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then(async (processed) => {\n                    if (status.value === \"aborted\")\n                        return INVALID;\n                    const result = await this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                    if (result.status === \"aborted\")\n                        return INVALID;\n                    if (result.status === \"dirty\")\n                        return DIRTY(result.value);\n                    if (status.value === \"dirty\")\n                        return DIRTY(result.value);\n                    return result;\n                });\n            }\n            else {\n                if (status.value === \"aborted\")\n                    return INVALID;\n                const result = this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (result.status === \"aborted\")\n                    return INVALID;\n                if (result.status === \"dirty\")\n                    return DIRTY(result.value);\n                if (status.value === \"dirty\")\n                    return DIRTY(result.value);\n                return result;\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!isValid(base))\n                    return INVALID;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n                    if (!isValid(base))\n                        return INVALID;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n                        status: status.value,\n                        value: result,\n                    }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nexport { ZodEffects as ZodTransformer };\nexport class ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\" ? params.default : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if (isAsync(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nexport const BRAND = Symbol(\"zod_brand\");\nexport class ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nexport class ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nexport class ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        const freeze = (data) => {\n            if (isValid(data)) {\n                data.value = Object.freeze(data.value);\n            }\n            return data;\n        };\n        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodReadonly.create = (type, params) => {\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params),\n    });\n};\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      z.custom      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nfunction cleanParams(params, data) {\n    const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\n    const p2 = typeof p === \"string\" ? { message: p } : p;\n    return p2;\n}\nexport function custom(check, _params = {}, \n/**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            const r = check(data);\n            if (r instanceof Promise) {\n                return r.then((r) => {\n                    if (!r) {\n                        const params = cleanParams(_params, data);\n                        const _fatal = params.fatal ?? fatal ?? true;\n                        ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n                    }\n                });\n            }\n            if (!r) {\n                const params = cleanParams(_params, data);\n                const _fatal = params.fatal ?? fatal ?? true;\n                ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n            }\n            return;\n        });\n    return ZodAny.create();\n}\nexport { ZodType as Schema, ZodType as ZodSchema };\nexport const late = {\n    object: ZodObject.lazycreate,\n};\nexport var ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\n// requires TS 4.4+\nclass Class {\n    constructor(..._) { }\n}\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\nexport const coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nexport { anyType as any, arrayType as array, bigIntType as bigint, booleanType as boolean, dateType as date, discriminatedUnionType as discriminatedUnion, effectsType as effect, enumType as enum, functionType as function, instanceOfType as instanceof, intersectionType as intersection, lazyType as lazy, literalType as literal, mapType as map, nanType as nan, nativeEnumType as nativeEnum, neverType as never, nullType as null, nullableType as nullable, numberType as number, objectType as object, oboolean, onumber, optionalType as optional, ostring, pipelineType as pipeline, preprocessType as preprocess, promiseType as promise, recordType as record, setType as set, strictObjectType as strictObject, stringType as string, symbolType as symbol, effectsType as transformer, tupleType as tuple, undefinedType as undefined, unionType as union, unknownType as unknown, voidType as void, };\nexport const NEVER = INVALID;\n","import { createSecretKey, generateKeyPair as generateKeyPairCb } from 'crypto';\nimport { promisify } from 'util';\nimport random from './random.js';\nimport { setModulusLength } from './check_modulus_length.js';\nimport { JOSENotSupported } from '../util/errors.js';\nconst generate = promisify(generateKeyPairCb);\nexport async function generateSecret(alg, options) {\n    let length;\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512':\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            length = parseInt(alg.slice(-3), 10);\n            break;\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW':\n        case 'A128GCMKW':\n        case 'A192GCMKW':\n        case 'A256GCMKW':\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            length = parseInt(alg.slice(1, 4), 10);\n            break;\n        default:\n            throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n    }\n    return createSecretKey(random(new Uint8Array(length >> 3)));\n}\nexport async function generateKeyPair(alg, options) {\n    var _a, _b;\n    switch (alg) {\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n        case 'RSA1_5': {\n            const modulusLength = (_a = options === null || options === void 0 ? void 0 : options.modulusLength) !== null && _a !== void 0 ? _a : 2048;\n            if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n                throw new JOSENotSupported('Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used');\n            }\n            const keypair = await generate('rsa', {\n                modulusLength,\n                publicExponent: 0x10001,\n            });\n            setModulusLength(keypair.privateKey, modulusLength);\n            setModulusLength(keypair.publicKey, modulusLength);\n            return keypair;\n        }\n        case 'ES256':\n            return generate('ec', { namedCurve: 'P-256' });\n        case 'ES256K':\n            return generate('ec', { namedCurve: 'secp256k1' });\n        case 'ES384':\n            return generate('ec', { namedCurve: 'P-384' });\n        case 'ES512':\n            return generate('ec', { namedCurve: 'P-521' });\n        case 'EdDSA': {\n            switch (options === null || options === void 0 ? void 0 : options.crv) {\n                case undefined:\n                case 'Ed25519':\n                    return generate('ed25519');\n                case 'Ed448':\n                    return generate('ed448');\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported crv option provided, supported values are Ed25519 and Ed448');\n            }\n        }\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW':\n            const crv = (_b = options === null || options === void 0 ? void 0 : options.crv) !== null && _b !== void 0 ? _b : 'P-256';\n            switch (crv) {\n                case undefined:\n                case 'P-256':\n                case 'P-384':\n                case 'P-521':\n                    return generate('ec', { namedCurve: crv });\n                case 'X25519':\n                    return generate('x25519');\n                case 'X448':\n                    return generate('x448');\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448');\n            }\n        default:\n            throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n    }\n}\n","import { constants } from 'crypto';\nimport getNamedCurve from './get_named_curve.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport checkModulusLength from './check_modulus_length.js';\nimport { rsaPssParams } from './flags.js';\nconst PSS = {\n    padding: constants.RSA_PKCS1_PSS_PADDING,\n    saltLength: constants.RSA_PSS_SALTLEN_DIGEST,\n};\nconst ecCurveAlgMap = new Map([\n    ['ES256', 'P-256'],\n    ['ES256K', 'secp256k1'],\n    ['ES384', 'P-384'],\n    ['ES512', 'P-521'],\n]);\nexport default function keyForCrypto(alg, key) {\n    switch (alg) {\n        case 'EdDSA':\n            if (!['ed25519', 'ed448'].includes(key.asymmetricKeyType)) {\n                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be ed25519 or ed448');\n            }\n            return key;\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            if (key.asymmetricKeyType !== 'rsa') {\n                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa');\n            }\n            checkModulusLength(key, alg);\n            return key;\n        case rsaPssParams && 'PS256':\n        case rsaPssParams && 'PS384':\n        case rsaPssParams && 'PS512':\n            if (key.asymmetricKeyType === 'rsa-pss') {\n                const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;\n                const length = parseInt(alg.slice(-3), 10);\n                if (hashAlgorithm !== undefined &&\n                    (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm)) {\n                    throw new TypeError(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of \"alg\" ${alg}`);\n                }\n                if (saltLength !== undefined && saltLength > length >> 3) {\n                    throw new TypeError(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of \"alg\" ${alg}`);\n                }\n            }\n            else if (key.asymmetricKeyType !== 'rsa') {\n                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa or rsa-pss');\n            }\n            checkModulusLength(key, alg);\n            return { key, ...PSS };\n        case !rsaPssParams && 'PS256':\n        case !rsaPssParams && 'PS384':\n        case !rsaPssParams && 'PS512':\n            if (key.asymmetricKeyType !== 'rsa') {\n                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa');\n            }\n            checkModulusLength(key, alg);\n            return { key, ...PSS };\n        case 'ES256':\n        case 'ES256K':\n        case 'ES384':\n        case 'ES512': {\n            if (key.asymmetricKeyType !== 'ec') {\n                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be ec');\n            }\n            const actual = getNamedCurve(key);\n            const expected = ecCurveAlgMap.get(alg);\n            if (actual !== expected) {\n                throw new TypeError(`Invalid key curve for the algorithm, its curve must be ${expected}, got ${actual}`);\n            }\n            return { dsaEncoding: 'ieee-p1363', key };\n        }\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n","import { JWTClaimValidationFailed, JWTExpired, JWTInvalid } from '../util/errors.js';\nimport { decoder } from './buffer_utils.js';\nimport epoch from './epoch.js';\nimport secs from './secs.js';\nimport isObject from './is_object.js';\nconst normalizeTyp = (value) => value.toLowerCase().replace(/^application\\//, '');\nconst checkAudiencePresence = (audPayload, audOption) => {\n    if (typeof audPayload === 'string') {\n        return audOption.includes(audPayload);\n    }\n    if (Array.isArray(audPayload)) {\n        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));\n    }\n    return false;\n};\nexport default (protectedHeader, encodedPayload, options = {}) => {\n    const { typ } = options;\n    if (typ &&\n        (typeof protectedHeader.typ !== 'string' ||\n            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {\n        throw new JWTClaimValidationFailed('unexpected \"typ\" JWT header value', 'typ', 'check_failed');\n    }\n    let payload;\n    try {\n        payload = JSON.parse(decoder.decode(encodedPayload));\n    }\n    catch {\n    }\n    if (!isObject(payload)) {\n        throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');\n    }\n    const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;\n    if (maxTokenAge !== undefined)\n        requiredClaims.push('iat');\n    if (audience !== undefined)\n        requiredClaims.push('aud');\n    if (subject !== undefined)\n        requiredClaims.push('sub');\n    if (issuer !== undefined)\n        requiredClaims.push('iss');\n    for (const claim of new Set(requiredClaims.reverse())) {\n        if (!(claim in payload)) {\n            throw new JWTClaimValidationFailed(`missing required \"${claim}\" claim`, claim, 'missing');\n        }\n    }\n    if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {\n        throw new JWTClaimValidationFailed('unexpected \"iss\" claim value', 'iss', 'check_failed');\n    }\n    if (subject && payload.sub !== subject) {\n        throw new JWTClaimValidationFailed('unexpected \"sub\" claim value', 'sub', 'check_failed');\n    }\n    if (audience &&\n        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n        throw new JWTClaimValidationFailed('unexpected \"aud\" claim value', 'aud', 'check_failed');\n    }\n    let tolerance;\n    switch (typeof options.clockTolerance) {\n        case 'string':\n            tolerance = secs(options.clockTolerance);\n            break;\n        case 'number':\n            tolerance = options.clockTolerance;\n            break;\n        case 'undefined':\n            tolerance = 0;\n            break;\n        default:\n            throw new TypeError('Invalid clockTolerance option type');\n    }\n    const { currentDate } = options;\n    const now = epoch(currentDate || new Date());\n    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== 'number') {\n        throw new JWTClaimValidationFailed('\"iat\" claim must be a number', 'iat', 'invalid');\n    }\n    if (payload.nbf !== undefined) {\n        if (typeof payload.nbf !== 'number') {\n            throw new JWTClaimValidationFailed('\"nbf\" claim must be a number', 'nbf', 'invalid');\n        }\n        if (payload.nbf > now + tolerance) {\n            throw new JWTClaimValidationFailed('\"nbf\" claim timestamp check failed', 'nbf', 'check_failed');\n        }\n    }\n    if (payload.exp !== undefined) {\n        if (typeof payload.exp !== 'number') {\n            throw new JWTClaimValidationFailed('\"exp\" claim must be a number', 'exp', 'invalid');\n        }\n        if (payload.exp <= now - tolerance) {\n            throw new JWTExpired('\"exp\" claim timestamp check failed', 'exp', 'check_failed');\n        }\n    }\n    if (maxTokenAge) {\n        const age = now - payload.iat;\n        const max = typeof maxTokenAge === 'number' ? maxTokenAge : secs(maxTokenAge);\n        if (age - tolerance > max) {\n            throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', 'iat', 'check_failed');\n        }\n        if (age < 0 - tolerance) {\n            throw new JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');\n        }\n    }\n    return payload;\n};\n","import { decode as decodeBase64URL } from '../runtime/base64url.js';\nimport { fromSPKI, fromPKCS8, fromX509 } from '../runtime/asn1.js';\nimport asKeyObject from '../runtime/jwk_to_key.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport isObject from '../lib/is_object.js';\nexport async function importSPKI(spki, alg, options) {\n    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {\n        throw new TypeError('\"spki\" must be SPKI formatted string');\n    }\n    return fromSPKI(spki, alg, options);\n}\nexport async function importX509(x509, alg, options) {\n    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) {\n        throw new TypeError('\"x509\" must be X.509 formatted string');\n    }\n    return fromX509(x509, alg, options);\n}\nexport async function importPKCS8(pkcs8, alg, options) {\n    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {\n        throw new TypeError('\"pkcs8\" must be PKCS#8 formatted string');\n    }\n    return fromPKCS8(pkcs8, alg, options);\n}\nexport async function importJWK(jwk, alg, octAsKeyObject) {\n    var _a;\n    if (!isObject(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    alg || (alg = jwk.alg);\n    switch (jwk.kty) {\n        case 'oct':\n            if (typeof jwk.k !== 'string' || !jwk.k) {\n                throw new TypeError('missing \"k\" (Key Value) Parameter value');\n            }\n            octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : (octAsKeyObject = jwk.ext !== true);\n            if (octAsKeyObject) {\n                return asKeyObject({ ...jwk, alg, ext: (_a = jwk.ext) !== null && _a !== void 0 ? _a : false });\n            }\n            return decodeBase64URL(jwk.k);\n        case 'RSA':\n            if (jwk.oth !== undefined) {\n                throw new JOSENotSupported('RSA JWK \"oth\" (Other Primes Info) Parameter value is not supported');\n            }\n        case 'EC':\n        case 'OKP':\n            return asKeyObject({ ...jwk, alg });\n        default:\n            throw new JOSENotSupported('Unsupported \"kty\" (Key Type) Parameter value');\n    }\n}\n","import * as base64url from '../runtime/base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport { JWTInvalid } from '../util/errors.js';\nimport jwtPayload from '../lib/jwt_claims_set.js';\nimport { ProduceJWT } from './produce.js';\nexport class UnsecuredJWT extends ProduceJWT {\n    encode() {\n        const header = base64url.encode(JSON.stringify({ alg: 'none' }));\n        const payload = base64url.encode(JSON.stringify(this._payload));\n        return `${header}.${payload}.`;\n    }\n    static decode(jwt, options) {\n        if (typeof jwt !== 'string') {\n            throw new JWTInvalid('Unsecured JWT must be a string');\n        }\n        const { 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split('.');\n        if (length !== 3 || signature !== '') {\n            throw new JWTInvalid('Invalid Unsecured JWT');\n        }\n        let header;\n        try {\n            header = JSON.parse(decoder.decode(base64url.decode(encodedHeader)));\n            if (header.alg !== 'none')\n                throw new Error();\n        }\n        catch {\n            throw new JWTInvalid('Invalid Unsecured JWT');\n        }\n        const payload = jwtPayload(header, base64url.decode(encodedPayload), options);\n        return { payload, header };\n    }\n}\n","import { KeyObject, createSecretKey } from 'crypto';\nimport { isCryptoKey } from './webcrypto.js';\nimport { checkSigCryptoKey } from '../lib/crypto_key.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nexport default function getSignVerifyKey(alg, key, usage) {\n    if (key instanceof Uint8Array) {\n        if (!alg.startsWith('HS')) {\n            throw new TypeError(invalidKeyInput(key, ...types));\n        }\n        return createSecretKey(key);\n    }\n    if (key instanceof KeyObject) {\n        return key;\n    }\n    if (isCryptoKey(key)) {\n        checkSigCryptoKey(key, alg, usage);\n        return KeyObject.from(key);\n    }\n    throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));\n}\n","import { SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD, SolanaError } from '@solana/errors';\nimport { Callable, Flatten, OverloadImplementations, UnionToIntersection } from '@solana/rpc-spec-types';\n\nimport { RpcApi, RpcPlan } from './rpc-api';\nimport { RpcTransport } from './rpc-transport';\n\nexport type RpcConfig<TRpcMethods, TRpcTransport extends RpcTransport> = Readonly<{\n    api: RpcApi<TRpcMethods>;\n    transport: TRpcTransport;\n}>;\n\n/**\n * An object that exposes all of the functions described by `TRpcMethods`.\n *\n * Calling each method returns a {@link PendingRpcRequest | PendingRpcRequest<TResponse>} where\n * `TResponse` is that method's response type.\n */\nexport type Rpc<TRpcMethods> = {\n    [TMethodName in keyof TRpcMethods]: PendingRpcRequestBuilder<OverloadImplementations<TRpcMethods, TMethodName>>;\n};\n\n/**\n * Pending requests are the result of calling a supported method on a {@link Rpc} object. They\n * encapsulate all of the information necessary to make the request without actually making it.\n *\n * Calling the {@link PendingRpcRequest.send | `send(options)`} method on a\n * {@link PendingRpcRequest | PendingRpcRequest<TResponse>} will trigger the request and return a\n * promise for `TResponse`.\n */\nexport type PendingRpcRequest<TResponse> = {\n    send(options?: RpcSendOptions): Promise<TResponse>;\n};\n\nexport type RpcSendOptions = Readonly<{\n    /**\n     * An optional signal that you can supply when triggering a {@link PendingRpcRequest} that you\n     * might later need to abort.\n     */\n    abortSignal?: AbortSignal;\n}>;\n\ntype PendingRpcRequestBuilder<TMethodImplementations> = UnionToIntersection<\n    Flatten<{\n        [P in keyof TMethodImplementations]: PendingRpcRequestReturnTypeMapper<TMethodImplementations[P]>;\n    }>\n>;\n\ntype PendingRpcRequestReturnTypeMapper<TMethodImplementation> =\n    // Check that this property of the TRpcMethods interface is, in fact, a function.\n    TMethodImplementation extends Callable\n        ? (...args: Parameters<TMethodImplementation>) => PendingRpcRequest<ReturnType<TMethodImplementation>>\n        : never;\n\n/**\n * Creates a {@link Rpc} instance given a {@link RpcApi | RpcApi<TRpcMethods>} and a\n * {@link RpcTransport} capable of fulfilling them.\n */\nexport function createRpc<TRpcMethods, TRpcTransport extends RpcTransport>(\n    rpcConfig: RpcConfig<TRpcMethods, TRpcTransport>,\n): Rpc<TRpcMethods> {\n    return makeProxy(rpcConfig);\n}\n\nfunction makeProxy<TRpcMethods, TRpcTransport extends RpcTransport>(\n    rpcConfig: RpcConfig<TRpcMethods, TRpcTransport>,\n): Rpc<TRpcMethods> {\n    return new Proxy(rpcConfig.api, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get(target, p, receiver) {\n            if (p === 'then') {\n                return undefined;\n            }\n            return function (...rawParams: unknown[]) {\n                const methodName = p.toString();\n                const getApiPlan = Reflect.get(target, methodName, receiver);\n                if (!getApiPlan) {\n                    throw new SolanaError(SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD, {\n                        method: methodName,\n                        params: rawParams,\n                    });\n                }\n                const apiPlan = getApiPlan(...rawParams);\n                return createPendingRpcRequest(rpcConfig, apiPlan);\n            };\n        },\n    }) as Rpc<TRpcMethods>;\n}\n\nfunction createPendingRpcRequest<TRpcMethods, TRpcTransport extends RpcTransport, TResponse>(\n    { transport }: RpcConfig<TRpcMethods, TRpcTransport>,\n    plan: RpcPlan<TResponse>,\n): PendingRpcRequest<TResponse> {\n    return {\n        async send(options?: RpcSendOptions): Promise<TResponse> {\n            return await plan.execute({ signal: options?.abortSignal, transport });\n        },\n    };\n}\n","import type { Rdns } from './register.js'\nimport type { EIP6963ProviderDetail } from './types.js'\nimport { requestProviders } from './utils.js'\n\nexport type Listener = (\n  providerDetails: readonly EIP6963ProviderDetail[],\n  meta?:\n    | {\n        added?: readonly EIP6963ProviderDetail[] | undefined\n        removed?: readonly EIP6963ProviderDetail[] | undefined\n      }\n    | undefined,\n) => void\n\nexport type Store = {\n  /**\n   * Clears the store, including all provider details.\n   */\n  clear(): void\n  /**\n   * Destroys the store, including all provider details and listeners.\n   */\n  destroy(): void\n  /**\n   * Finds a provider detail by its RDNS (Reverse Domain Name Identifier).\n   */\n  findProvider(args: { rdns: Rdns }): EIP6963ProviderDetail | undefined\n  /**\n   * Returns all provider details that have been emitted.\n   */\n  getProviders(): readonly EIP6963ProviderDetail[]\n  /**\n   * Resets the store, and emits an event to request provider details.\n   */\n  reset(): void\n  /**\n   * Subscribes to emitted provider details.\n   */\n  subscribe(\n    listener: Listener,\n    args?: { emitImmediately?: boolean | undefined } | undefined,\n  ): () => void\n\n  /**\n   * @internal\n   * Current state of listening listeners.\n   */\n  _listeners(): Set<Listener>\n}\n\nexport function createStore(): Store {\n  const listeners: Set<Listener> = new Set()\n  let providerDetails: readonly EIP6963ProviderDetail[] = []\n\n  const request = () =>\n    requestProviders((providerDetail) => {\n      if (\n        providerDetails.some(\n          ({ info }) => info.uuid === providerDetail.info.uuid,\n        )\n      )\n        return\n\n      providerDetails = [...providerDetails, providerDetail]\n      listeners.forEach((listener) =>\n        listener(providerDetails, { added: [providerDetail] }),\n      )\n    })\n  let unwatch = request()\n\n  return {\n    _listeners() {\n      return listeners\n    },\n    clear() {\n      listeners.forEach((listener) =>\n        listener([], { removed: [...providerDetails] }),\n      )\n      providerDetails = []\n    },\n    destroy() {\n      this.clear()\n      listeners.clear()\n      unwatch?.()\n    },\n    findProvider({ rdns }) {\n      return providerDetails.find(\n        (providerDetail) => providerDetail.info.rdns === rdns,\n      )\n    },\n    getProviders() {\n      return providerDetails\n    },\n    reset() {\n      this.clear()\n      unwatch?.()\n      unwatch = request()\n    },\n    subscribe(listener, { emitImmediately } = {}) {\n      listeners.add(listener)\n      if (emitImmediately) listener(providerDetails, { added: providerDetails })\n      return () => listeners.delete(listener)\n    },\n  }\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU8Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedRequestHeapFrameInstruction,\n  type ParsedRequestUnitsInstruction,\n  type ParsedSetComputeUnitLimitInstruction,\n  type ParsedSetComputeUnitPriceInstruction,\n  type ParsedSetLoadedAccountsDataSizeLimitInstruction,\n} from '../instructions';\n\nexport const COMPUTE_BUDGET_PROGRAM_ADDRESS =\n  'ComputeBudget111111111111111111111111111111' as Address<'ComputeBudget111111111111111111111111111111'>;\n\nexport enum ComputeBudgetInstruction {\n  RequestUnits,\n  RequestHeapFrame,\n  SetComputeUnitLimit,\n  SetComputeUnitPrice,\n  SetLoadedAccountsDataSizeLimit,\n}\n\nexport function identifyComputeBudgetInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): ComputeBudgetInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU8Encoder().encode(0), 0)) {\n    return ComputeBudgetInstruction.RequestUnits;\n  }\n  if (containsBytes(data, getU8Encoder().encode(1), 0)) {\n    return ComputeBudgetInstruction.RequestHeapFrame;\n  }\n  if (containsBytes(data, getU8Encoder().encode(2), 0)) {\n    return ComputeBudgetInstruction.SetComputeUnitLimit;\n  }\n  if (containsBytes(data, getU8Encoder().encode(3), 0)) {\n    return ComputeBudgetInstruction.SetComputeUnitPrice;\n  }\n  if (containsBytes(data, getU8Encoder().encode(4), 0)) {\n    return ComputeBudgetInstruction.SetLoadedAccountsDataSizeLimit;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a computeBudget instruction.'\n  );\n}\n\nexport type ParsedComputeBudgetInstruction<\n  TProgram extends string = 'ComputeBudget111111111111111111111111111111',\n> =\n  | ({\n      instructionType: ComputeBudgetInstruction.RequestUnits;\n    } & ParsedRequestUnitsInstruction<TProgram>)\n  | ({\n      instructionType: ComputeBudgetInstruction.RequestHeapFrame;\n    } & ParsedRequestHeapFrameInstruction<TProgram>)\n  | ({\n      instructionType: ComputeBudgetInstruction.SetComputeUnitLimit;\n    } & ParsedSetComputeUnitLimitInstruction<TProgram>)\n  | ({\n      instructionType: ComputeBudgetInstruction.SetComputeUnitPrice;\n    } & ParsedSetComputeUnitPriceInstruction<TProgram>)\n  | ({\n      instructionType: ComputeBudgetInstruction.SetLoadedAccountsDataSizeLimit;\n    } & ParsedSetLoadedAccountsDataSizeLimitInstruction<TProgram>);\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/core/error/errors.ts","import { createPrivateKey, createPublicKey, KeyObject } from 'crypto';\nimport { Buffer } from 'buffer';\nimport { isCryptoKey } from './webcrypto.js';\nimport isKeyObject from './is_key_object.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nconst genericExport = (keyType, keyFormat, key) => {\n    let keyObject;\n    if (isCryptoKey(key)) {\n        if (!key.extractable) {\n            throw new TypeError('CryptoKey is not extractable');\n        }\n        keyObject = KeyObject.from(key);\n    }\n    else if (isKeyObject(key)) {\n        keyObject = key;\n    }\n    else {\n        throw new TypeError(invalidKeyInput(key, ...types));\n    }\n    if (keyObject.type !== keyType) {\n        throw new TypeError(`key is not a ${keyType} key`);\n    }\n    return keyObject.export({ format: 'pem', type: keyFormat });\n};\nexport const toSPKI = (key) => {\n    return genericExport('public', 'spki', key);\n};\nexport const toPKCS8 = (key) => {\n    return genericExport('private', 'pkcs8', key);\n};\nexport const fromPKCS8 = (pem) => createPrivateKey({\n    key: Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\\s)/g, ''), 'base64'),\n    type: 'pkcs8',\n    format: 'der',\n});\nexport const fromSPKI = (pem) => createPublicKey({\n    key: Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\\s)/g, ''), 'base64'),\n    type: 'spki',\n    format: 'der',\n});\nexport const fromX509 = (pem) => createPublicKey({\n    key: pem,\n    type: 'spki',\n    format: 'pem',\n});\n","import * as crypto from 'crypto';\nimport { promisify } from 'util';\nimport nodeDigest from './dsa_digest.js';\nimport hmacDigest from './hmac_digest.js';\nimport nodeKey from './node_key.js';\nimport getSignKey from './get_sign_verify_key.js';\nlet oneShotSign;\nif (crypto.sign.length > 3) {\n    oneShotSign = promisify(crypto.sign);\n}\nelse {\n    oneShotSign = crypto.sign;\n}\nconst sign = async (alg, key, data) => {\n    const keyObject = getSignKey(alg, key, 'sign');\n    if (alg.startsWith('HS')) {\n        const hmac = crypto.createHmac(hmacDigest(alg), keyObject);\n        hmac.update(data);\n        return hmac.digest();\n    }\n    return oneShotSign(nodeDigest(alg), data, nodeKey(alg, keyObject));\n};\nexport default sign;\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/sign/walletlink/relay/connection/WalletLinkWebSocket.ts","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/sign/walletlink/relay/ui/components/util.ts","import { InvalidAddressError } from '../errors/address.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { ChainSerializers } from '../types/chain.js'\nimport type { Hex, Signature } from '../types/misc.js'\nimport type { TransactionSerializable } from '../types/transaction.js'\nimport type { RequiredBy } from '../types/utils.js'\nimport { isAddress } from '../utils/address/isAddress.js'\nimport { concatHex } from '../utils/data/concat.js'\nimport { toHex } from '../utils/encoding/toHex.js'\nimport { toRlp } from '../utils/encoding/toRlp.js'\nimport {\n  type SerializeTransactionErrorType as SerializeTransactionErrorType_,\n  serializeTransaction as serializeTransaction_,\n} from '../utils/transaction/serializeTransaction.js'\nimport type {\n  OpStackTransactionSerializable,\n  TransactionSerializableDeposit,\n  TransactionSerializedDeposit,\n} from './types/transaction.js'\n\nexport type SerializeTransactionReturnType = ReturnType<\n  typeof serializeTransaction\n>\n\nexport type SerializeTransactionErrorType =\n  | SerializeTransactionErrorType_\n  | ErrorType\n\nexport function serializeTransaction(\n  transaction: OpStackTransactionSerializable,\n  signature?: Signature,\n) {\n  if (isDeposit(transaction)) return serializeTransactionDeposit(transaction)\n  return serializeTransaction_(\n    transaction as TransactionSerializable,\n    signature,\n  )\n}\n\nexport const serializers = {\n  transaction: serializeTransaction,\n} as const satisfies ChainSerializers\n\n//////////////////////////////////////////////////////////////////////////////\n// Serializers\n\nexport type SerializeTransactionDepositReturnType = TransactionSerializedDeposit\n\nfunction serializeTransactionDeposit(\n  transaction: TransactionSerializableDeposit,\n): SerializeTransactionDepositReturnType {\n  assertTransactionDeposit(transaction)\n\n  const { sourceHash, data, from, gas, isSystemTx, mint, to, value } =\n    transaction\n\n  const serializedTransaction: Hex[] = [\n    sourceHash,\n    from,\n    to ?? '0x',\n    mint ? toHex(mint) : '0x',\n    value ? toHex(value) : '0x',\n    gas ? toHex(gas) : '0x',\n    isSystemTx ? '0x1' : '0x',\n    data ?? '0x',\n  ]\n\n  return concatHex([\n    '0x7e',\n    toRlp(serializedTransaction),\n  ]) as SerializeTransactionDepositReturnType\n}\n\nfunction isDeposit(\n  transaction: OpStackTransactionSerializable,\n): transaction is RequiredBy<TransactionSerializableDeposit, 'type'> {\n  if (transaction.type === 'deposit') return true\n  if (typeof transaction.sourceHash !== 'undefined') return true\n  return false\n}\n\nexport function assertTransactionDeposit(\n  transaction: TransactionSerializableDeposit,\n) {\n  const { from, to } = transaction\n  if (from && !isAddress(from)) throw new InvalidAddressError({ address: from })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n}\n","/**\n * This package contains types that describe the [methods](https://solana.com/docs/rpc/http) of the\n * Solana JSON RPC API, and utilities for creating a {@link RpcApi} implementation with sensible\n * defaults. It can be used standalone, but it is also exported as part of Kit\n * [`@solana/kit`](https://github.com/anza-xyz/kit/tree/main/packages/kit).\n *\n * @example\n * Each RPC method is described in terms of a TypeScript type of the following form:\n *\n * ```ts\n * type ExampleApi = {\n *     getSomething(address: Address): Something;\n * };\n * ```\n *\n * A {@link RpcApi} that implements `ExampleApi` will ultimately expose its defined methods on any\n * {@link Rpc} that uses it.\n *\n * ```ts\n * const rpc: Rpc<ExampleApi> = createExampleRpc(/* ... *\\/);\n * const something: Something = await rpc.getSomething(address('95DpK3y3GF7U8s1k4EvZ7xqyeCkhsHeZaE97iZpHUGMN')).send();\n * ```\n *\n * @packageDocumentation\n */\nimport { createJsonRpcApi, RpcApi } from '@solana/rpc-spec';\nimport {\n    AllowedNumericKeypaths,\n    getDefaultRequestTransformerForSolanaRpc,\n    getDefaultResponseTransformerForSolanaRpc,\n    innerInstructionsConfigs,\n    jsonParsedAccountsConfigs,\n    jsonParsedTokenAccountsConfigs,\n    KEYPATH_WILDCARD,\n    messageConfig,\n    RequestTransformerConfig,\n} from '@solana/rpc-transformers';\n\nimport { GetAccountInfoApi } from './getAccountInfo';\nimport { GetBalanceApi } from './getBalance';\nimport { GetBlockApi } from './getBlock';\nimport { GetBlockCommitmentApi } from './getBlockCommitment';\nimport { GetBlockHeightApi } from './getBlockHeight';\nimport { GetBlockProductionApi } from './getBlockProduction';\nimport { GetBlocksApi } from './getBlocks';\nimport { GetBlocksWithLimitApi } from './getBlocksWithLimit';\nimport { GetBlockTimeApi } from './getBlockTime';\nimport { GetClusterNodesApi } from './getClusterNodes';\nimport { GetEpochInfoApi } from './getEpochInfo';\nimport { GetEpochScheduleApi } from './getEpochSchedule';\nimport { GetFeeForMessageApi } from './getFeeForMessage';\nimport { GetFirstAvailableBlockApi } from './getFirstAvailableBlock';\nimport { GetGenesisHashApi } from './getGenesisHash';\nimport { GetHealthApi } from './getHealth';\nimport { GetHighestSnapshotSlotApi } from './getHighestSnapshotSlot';\nimport { GetIdentityApi } from './getIdentity';\nimport { GetInflationGovernorApi } from './getInflationGovernor';\nimport { GetInflationRateApi } from './getInflationRate';\nimport { GetInflationRewardApi } from './getInflationReward';\nimport { GetLargestAccountsApi } from './getLargestAccounts';\nimport { GetLatestBlockhashApi } from './getLatestBlockhash';\nimport { GetLeaderScheduleApi } from './getLeaderSchedule';\nimport { GetMaxRetransmitSlotApi } from './getMaxRetransmitSlot';\nimport { GetMaxShredInsertSlotApi } from './getMaxShredInsertSlot';\nimport { GetMinimumBalanceForRentExemptionApi } from './getMinimumBalanceForRentExemption';\nimport { GetMultipleAccountsApi } from './getMultipleAccounts';\nimport { GetProgramAccountsApi } from './getProgramAccounts';\nimport { GetRecentPerformanceSamplesApi } from './getRecentPerformanceSamples';\nimport { GetRecentPrioritizationFeesApi } from './getRecentPrioritizationFees';\nimport { GetSignaturesForAddressApi } from './getSignaturesForAddress';\nimport { GetSignatureStatusesApi } from './getSignatureStatuses';\nimport { GetSlotApi } from './getSlot';\nimport { GetSlotLeaderApi } from './getSlotLeader';\nimport { GetSlotLeadersApi } from './getSlotLeaders';\nimport { GetStakeMinimumDelegationApi } from './getStakeMinimumDelegation';\nimport { GetSupplyApi } from './getSupply';\nimport { GetTokenAccountBalanceApi } from './getTokenAccountBalance';\nimport { GetTokenAccountsByDelegateApi } from './getTokenAccountsByDelegate';\nimport { GetTokenAccountsByOwnerApi } from './getTokenAccountsByOwner';\nimport { GetTokenLargestAccountsApi } from './getTokenLargestAccounts';\nimport { GetTokenSupplyApi } from './getTokenSupply';\nimport { GetTransactionApi } from './getTransaction';\nimport { GetTransactionCountApi } from './getTransactionCount';\nimport { GetVersionApi } from './getVersion';\nimport { GetVoteAccountsApi } from './getVoteAccounts';\nimport { IsBlockhashValidApi } from './isBlockhashValid';\nimport { MinimumLedgerSlotApi } from './minimumLedgerSlot';\nimport { RequestAirdropApi } from './requestAirdrop';\nimport { SendTransactionApi } from './sendTransaction';\nimport { SimulateTransactionApi } from './simulateTransaction';\n\ntype SolanaRpcApiForAllClusters = GetAccountInfoApi &\n    GetBalanceApi &\n    GetBlockApi &\n    GetBlockCommitmentApi &\n    GetBlockHeightApi &\n    GetBlockProductionApi &\n    GetBlocksApi &\n    GetBlocksWithLimitApi &\n    GetBlockTimeApi &\n    GetClusterNodesApi &\n    GetEpochInfoApi &\n    GetEpochScheduleApi &\n    GetFeeForMessageApi &\n    GetFirstAvailableBlockApi &\n    GetGenesisHashApi &\n    GetHealthApi &\n    GetHighestSnapshotSlotApi &\n    GetIdentityApi &\n    GetInflationGovernorApi &\n    GetInflationRateApi &\n    GetInflationRewardApi &\n    GetLargestAccountsApi &\n    GetLatestBlockhashApi &\n    GetLeaderScheduleApi &\n    GetMaxRetransmitSlotApi &\n    GetMaxShredInsertSlotApi &\n    GetMinimumBalanceForRentExemptionApi &\n    GetMultipleAccountsApi &\n    GetProgramAccountsApi &\n    GetRecentPerformanceSamplesApi &\n    GetRecentPrioritizationFeesApi &\n    GetSignaturesForAddressApi &\n    GetSignatureStatusesApi &\n    GetSlotApi &\n    GetSlotLeaderApi &\n    GetSlotLeadersApi &\n    GetStakeMinimumDelegationApi &\n    GetSupplyApi &\n    GetTokenAccountBalanceApi &\n    GetTokenAccountsByDelegateApi &\n    GetTokenAccountsByOwnerApi &\n    GetTokenLargestAccountsApi &\n    GetTokenSupplyApi &\n    GetTransactionApi &\n    GetTransactionCountApi &\n    GetVersionApi &\n    GetVoteAccountsApi &\n    IsBlockhashValidApi &\n    MinimumLedgerSlotApi &\n    SendTransactionApi &\n    SimulateTransactionApi;\ntype SolanaRpcApiForTestClusters = RequestAirdropApi & SolanaRpcApiForAllClusters;\n/**\n * Represents the RPC methods available on test clusters.\n *\n * For instance, the test clusters support the {@link RequestAirdropApi} while mainnet does not.\n */\nexport type SolanaRpcApi = SolanaRpcApiForTestClusters;\n/**\n * Represents the RPC methods available on the devnet cluster.\n *\n * For instance, the devnet cluster supports the {@link RequestAirdropApi} while mainnet does not.\n */\nexport type SolanaRpcApiDevnet = SolanaRpcApiForTestClusters;\n/**\n * Represents the RPC methods available on the testnet cluster.\n *\n * For instance, the testnet cluster supports the {@link RequestAirdropApi} while mainnet does not.\n */\nexport type SolanaRpcApiTestnet = SolanaRpcApiForTestClusters;\n/**\n * Represents the RPC methods available on the mainnet cluster.\n *\n * For instance, the mainnet cluster does not support the {@link RequestAirdropApi} whereas test\n * clusters do.\n */\nexport type SolanaRpcApiMainnet = SolanaRpcApiForAllClusters;\n\nexport type {\n    GetAccountInfoApi,\n    GetBalanceApi,\n    GetBlockApi,\n    GetBlockCommitmentApi,\n    GetBlockHeightApi,\n    GetBlockProductionApi,\n    GetBlocksApi,\n    GetBlocksWithLimitApi,\n    GetBlockTimeApi,\n    GetClusterNodesApi,\n    GetEpochInfoApi,\n    GetEpochScheduleApi,\n    GetFeeForMessageApi,\n    GetFirstAvailableBlockApi,\n    GetGenesisHashApi,\n    GetHealthApi,\n    GetHighestSnapshotSlotApi,\n    GetIdentityApi,\n    GetInflationGovernorApi,\n    GetInflationRateApi,\n    GetInflationRewardApi,\n    GetLargestAccountsApi,\n    GetLatestBlockhashApi,\n    GetLeaderScheduleApi,\n    GetMaxRetransmitSlotApi,\n    GetMaxShredInsertSlotApi,\n    GetMinimumBalanceForRentExemptionApi,\n    GetMultipleAccountsApi,\n    GetProgramAccountsApi,\n    GetRecentPerformanceSamplesApi,\n    GetRecentPrioritizationFeesApi,\n    GetSignaturesForAddressApi,\n    GetSignatureStatusesApi,\n    GetSlotApi,\n    GetSlotLeaderApi,\n    GetSlotLeadersApi,\n    GetStakeMinimumDelegationApi,\n    GetSupplyApi,\n    GetTokenAccountBalanceApi,\n    GetTokenAccountsByDelegateApi,\n    GetTokenAccountsByOwnerApi,\n    GetTokenLargestAccountsApi,\n    GetTokenSupplyApi,\n    GetTransactionApi,\n    GetTransactionCountApi,\n    GetVersionApi,\n    GetVoteAccountsApi,\n    IsBlockhashValidApi,\n    MinimumLedgerSlotApi,\n    RequestAirdropApi,\n    SendTransactionApi,\n    SimulateTransactionApi,\n};\n\ntype Config = RequestTransformerConfig;\n\n/**\n * Creates a {@link RpcApi} implementation of the Solana JSON RPC API with some default behaviours.\n *\n * The default behaviours include:\n * - A transform that converts `bigint` inputs to `number` for compatibility with version 1.0 of the\n *   Solana JSON RPC.\n * - A transform that calls the config's {@link Config.onIntegerOverflow | onIntegerOverflow}\n *   handler whenever a `bigint` input would overflow a JavaScript IEEE 754 number. See\n *   [this](https://github.com/solana-labs/solana-web3.js/issues/1116) GitHub issue for more\n *   information.\n * - A transform that applies a default commitment wherever not specified\n */\nexport function createSolanaRpcApi<\n    // eslint-disable-next-line @typescript-eslint/no-duplicate-type-constituents\n    TRpcMethods extends SolanaRpcApi | SolanaRpcApiDevnet | SolanaRpcApiMainnet | SolanaRpcApiTestnet = SolanaRpcApi,\n>(config?: Config): RpcApi<TRpcMethods> {\n    return createJsonRpcApi<TRpcMethods>({\n        requestTransformer: getDefaultRequestTransformerForSolanaRpc(config),\n        responseTransformer: getDefaultResponseTransformerForSolanaRpc({\n            allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n        }),\n    });\n}\n\nlet memoizedKeypaths: AllowedNumericKeypaths<RpcApi<SolanaRpcApi>>;\n\n/**\n * These are keypaths at the end of which you will find a numeric value that should *not* be upcast\n * to a `bigint`. These are values that are legitimately defined as `u8` or `usize` on the backend.\n */\nfunction getAllowedNumericKeypaths(): AllowedNumericKeypaths<RpcApi<SolanaRpcApi>> {\n    if (!memoizedKeypaths) {\n        memoizedKeypaths = {\n            getAccountInfo: jsonParsedAccountsConfigs.map(c => ['value', ...c]),\n            getBlock: [\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'preTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'preTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'postTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'postTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                ...innerInstructionsConfigs.map(c => [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    ...c,\n                ]),\n                ...messageConfig.map(c => ['transactions', KEYPATH_WILDCARD, 'transaction', 'message', ...c] as const),\n                ['rewards', KEYPATH_WILDCARD, 'commission'],\n            ],\n            getClusterNodes: [\n                [KEYPATH_WILDCARD, 'featureSet'],\n                [KEYPATH_WILDCARD, 'shredVersion'],\n            ],\n            getInflationGovernor: [['initial'], ['foundation'], ['foundationTerm'], ['taper'], ['terminal']],\n            getInflationRate: [['foundation'], ['total'], ['validator']],\n            getInflationReward: [[KEYPATH_WILDCARD, 'commission']],\n            getMultipleAccounts: jsonParsedAccountsConfigs.map(c => ['value', KEYPATH_WILDCARD, ...c]),\n            getProgramAccounts: jsonParsedAccountsConfigs.flatMap(c => [\n                ['value', KEYPATH_WILDCARD, 'account', ...c],\n                [KEYPATH_WILDCARD, 'account', ...c],\n            ]),\n            getRecentPerformanceSamples: [[KEYPATH_WILDCARD, 'samplePeriodSecs']],\n            getTokenAccountBalance: [\n                ['value', 'decimals'],\n                ['value', 'uiAmount'],\n            ],\n            getTokenAccountsByDelegate: jsonParsedTokenAccountsConfigs.map(c => [\n                'value',\n                KEYPATH_WILDCARD,\n                'account',\n                ...c,\n            ]),\n            getTokenAccountsByOwner: jsonParsedTokenAccountsConfigs.map(c => [\n                'value',\n                KEYPATH_WILDCARD,\n                'account',\n                ...c,\n            ]),\n            getTokenLargestAccounts: [\n                ['value', KEYPATH_WILDCARD, 'decimals'],\n                ['value', KEYPATH_WILDCARD, 'uiAmount'],\n            ],\n            getTokenSupply: [\n                ['value', 'decimals'],\n                ['value', 'uiAmount'],\n            ],\n            getTransaction: [\n                ['meta', 'preTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                ['meta', 'preTokenBalances', KEYPATH_WILDCARD, 'uiTokenAmount', 'decimals'],\n                ['meta', 'postTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                ['meta', 'postTokenBalances', KEYPATH_WILDCARD, 'uiTokenAmount', 'decimals'],\n                ['meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                ...innerInstructionsConfigs.map(c => ['meta', 'innerInstructions', KEYPATH_WILDCARD, ...c]),\n                ...messageConfig.map(c => ['transaction', 'message', ...c] as const),\n            ],\n            getVersion: [['feature-set']],\n            getVoteAccounts: [\n                ['current', KEYPATH_WILDCARD, 'commission'],\n                ['delinquent', KEYPATH_WILDCARD, 'commission'],\n            ],\n            simulateTransaction: [\n                ['value', 'loadedAccountsDataSize'],\n                ...jsonParsedAccountsConfigs.map(c => ['value', 'accounts', KEYPATH_WILDCARD, ...c]),\n                ...innerInstructionsConfigs.map(c => ['value', 'innerInstructions', KEYPATH_WILDCARD, ...c]),\n            ],\n        };\n    }\n    return memoizedKeypaths;\n}\n","import type { Signature } from '../index.js'\nimport type { ChainSerializers } from '../types/chain.js'\nimport type { TransactionSerializable } from '../types/transaction.js'\nimport { concatHex } from '../utils/data/concat.js'\nimport { toHex } from '../utils/encoding/toHex.js'\nimport { toRlp } from '../utils/encoding/toRlp.js'\nimport { serializeTransaction as serializeTransaction_ } from '../utils/transaction/serializeTransaction.js'\nimport { gasPerPubdataDefault } from './constants/number.js'\nimport type {\n  ZksyncTransactionSerializable,\n  ZksyncTransactionSerializableEIP712,\n  ZksyncTransactionSerializedEIP712,\n} from './types/transaction.js'\nimport { assertEip712Transaction } from './utils/assertEip712Transaction.js'\nimport { isEIP712Transaction } from './utils/isEip712Transaction.js'\n\nexport function serializeTransaction(\n  transaction: ZksyncTransactionSerializable,\n  signature?: Signature | undefined,\n) {\n  if (isEIP712Transaction(transaction))\n    return serializeTransactionEIP712(\n      transaction as ZksyncTransactionSerializableEIP712,\n    )\n  return serializeTransaction_(\n    transaction as TransactionSerializable,\n    signature,\n  )\n}\n\nexport const serializers = {\n  transaction: serializeTransaction,\n} as const satisfies ChainSerializers\n\ntype SerializeTransactionEIP712ReturnType = ZksyncTransactionSerializedEIP712\n\nfunction serializeTransactionEIP712(\n  transaction: ZksyncTransactionSerializableEIP712,\n): SerializeTransactionEIP712ReturnType {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    customSignature,\n    factoryDeps,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n  } = transaction\n\n  assertEip712Transaction(transaction)\n\n  const serializedTransaction = [\n    nonce ? toHex(nonce) : '0x',\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? toHex(maxFeePerGas) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    toHex(chainId),\n    toHex(''),\n    toHex(''),\n    toHex(chainId),\n    from ?? '0x',\n    gasPerPubdata ? toHex(gasPerPubdata) : toHex(gasPerPubdataDefault),\n    factoryDeps ?? [],\n    customSignature ?? '0x', // EIP712 signature\n    paymaster && paymasterInput ? [paymaster, paymasterInput] : [],\n  ]\n\n  return concatHex([\n    '0x71',\n    toRlp(serializedTransaction),\n  ]) as SerializeTransactionEIP712ReturnType\n}\n","import type { Chain } from '../types/chain.js'\n\n/**\n * Predeploy contracts for OP Stack.\n * @see https://github.com/ethereum-optimism/optimism/blob/develop/specs/predeploys.md\n */\nexport const contracts = {\n  gasPriceOracle: { address: '0x420000000000000000000000000000000000000F' },\n  l1Block: { address: '0x4200000000000000000000000000000000000015' },\n  l2CrossDomainMessenger: {\n    address: '0x4200000000000000000000000000000000000007',\n  },\n  l2Erc721Bridge: { address: '0x4200000000000000000000000000000000000014' },\n  l2StandardBridge: { address: '0x4200000000000000000000000000000000000010' },\n  l2ToL1MessagePasser: {\n    address: '0x4200000000000000000000000000000000000016',\n  },\n} as const satisfies Chain['contracts']\n","class LogListNode {\n  private nodeValue: string;\n  private sizeInBytes: number;\n  public next: LogListNode | null;\n\n  constructor(value: string) {\n    this.nodeValue = value;\n    this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length;\n    this.next = null;\n  }\n\n  public get value() {\n    return this.nodeValue;\n  }\n\n  public get size() {\n    return this.sizeInBytes;\n  }\n}\n\nexport default class LogLinkedList {\n  private lengthInNodes: number;\n  private sizeInBytes: number;\n  private head: LogListNode | null;\n  private tail: LogListNode | null;\n  private maxSizeInBytes: number;\n\n  constructor(maxSizeInBytes: number) {\n    this.head = null;\n    this.tail = null;\n    this.lengthInNodes = 0;\n    this.maxSizeInBytes = maxSizeInBytes;\n    this.sizeInBytes = 0;\n  }\n\n  public append(value: string): void {\n    const newNode = new LogListNode(value);\n\n    if (newNode.size > this.maxSizeInBytes) {\n      throw new Error(\n        `[LinkedList] Value too big to insert into list: ${value} with size ${newNode.size}`,\n      );\n    }\n\n    while (this.size + newNode.size > this.maxSizeInBytes) {\n      this.shift();\n    }\n\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n    } else {\n      if (this.tail) {\n        this.tail.next = newNode;\n      }\n      this.tail = newNode;\n    }\n    this.lengthInNodes++;\n    this.sizeInBytes += newNode.size;\n  }\n\n  public shift(): void {\n    if (!this.head) {\n      return;\n    }\n\n    const removedNode = this.head;\n    this.head = this.head.next;\n\n    if (!this.head) {\n      this.tail = null;\n    }\n\n    this.lengthInNodes--;\n    this.sizeInBytes -= removedNode.size;\n  }\n\n  public toArray(): string[] {\n    const array: string[] = [];\n    let currentNode = this.head;\n    while (currentNode !== null) {\n      array.push(currentNode.value);\n      currentNode = currentNode.next;\n    }\n    return array;\n  }\n\n  public get length() {\n    return this.lengthInNodes;\n  }\n\n  public get size() {\n    return this.sizeInBytes;\n  }\n\n  public toOrderedArray() {\n    return Array.from(this);\n  }\n\n  [Symbol.iterator](): Iterator<string> {\n    let node = this.head;\n\n    const next = (): IteratorResult<string> => {\n      if (!node) {\n        return { done: true, value: null };\n      }\n\n      const value = node.value;\n      node = node.next;\n\n      return { done: false, value };\n    };\n\n    return { next };\n  }\n}\n","class LogListNode {\n  private nodeValue: string;\n  private sizeInBytes: number;\n  public next: LogListNode | null;\n\n  constructor(value: string) {\n    this.nodeValue = value;\n    this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length;\n    this.next = null;\n  }\n\n  public get value() {\n    return this.nodeValue;\n  }\n\n  public get size() {\n    return this.sizeInBytes;\n  }\n}\n\nexport default class LogLinkedList {\n  private lengthInNodes: number;\n  private sizeInBytes: number;\n  private head: LogListNode | null;\n  private tail: LogListNode | null;\n  private maxSizeInBytes: number;\n\n  constructor(maxSizeInBytes: number) {\n    this.head = null;\n    this.tail = null;\n    this.lengthInNodes = 0;\n    this.maxSizeInBytes = maxSizeInBytes;\n    this.sizeInBytes = 0;\n  }\n\n  public append(value: string): void {\n    const newNode = new LogListNode(value);\n\n    if (newNode.size > this.maxSizeInBytes) {\n      throw new Error(\n        `[LinkedList] Value too big to insert into list: ${value} with size ${newNode.size}`,\n      );\n    }\n\n    while (this.size + newNode.size > this.maxSizeInBytes) {\n      this.shift();\n    }\n\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n    } else {\n      if (this.tail) {\n        this.tail.next = newNode;\n      }\n      this.tail = newNode;\n    }\n    this.lengthInNodes++;\n    this.sizeInBytes += newNode.size;\n  }\n\n  public shift(): void {\n    if (!this.head) {\n      return;\n    }\n\n    const removedNode = this.head;\n    this.head = this.head.next;\n\n    if (!this.head) {\n      this.tail = null;\n    }\n\n    this.lengthInNodes--;\n    this.sizeInBytes -= removedNode.size;\n  }\n\n  public toArray(): string[] {\n    const array: string[] = [];\n    let currentNode = this.head;\n    while (currentNode !== null) {\n      array.push(currentNode.value);\n      currentNode = currentNode.next;\n    }\n    return array;\n  }\n\n  public get length() {\n    return this.lengthInNodes;\n  }\n\n  public get size() {\n    return this.sizeInBytes;\n  }\n\n  public toOrderedArray() {\n    return Array.from(this);\n  }\n\n  [Symbol.iterator](): Iterator<string> {\n    let node = this.head;\n\n    const next = (): IteratorResult<string> => {\n      if (!node) {\n        return { done: true, value: null };\n      }\n\n      const value = node.value;\n      node = node.next;\n\n      return { done: false, value };\n    };\n\n    return { next };\n  }\n}\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/sign/walletlink/relay/ui/components/Snackbar/Snackbar.tsx","import { FlattenedEncrypt, unprotected } from '../flattened/encrypt.js';\nimport { JWEInvalid } from '../../util/errors.js';\nimport generateCek from '../../lib/cek.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { encode as base64url } from '../../runtime/base64url.js';\nimport validateCrit from '../../lib/validate_crit.js';\nclass IndividualRecipient {\n    constructor(enc, key, options) {\n        this.parent = enc;\n        this.key = key;\n        this.options = options;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    addRecipient(...args) {\n        return this.parent.addRecipient(...args);\n    }\n    encrypt(...args) {\n        return this.parent.encrypt(...args);\n    }\n    done() {\n        return this.parent;\n    }\n}\nexport class GeneralEncrypt {\n    constructor(plaintext) {\n        this._recipients = [];\n        this._plaintext = plaintext;\n    }\n    addRecipient(key, options) {\n        const recipient = new IndividualRecipient(this, key, { crit: options === null || options === void 0 ? void 0 : options.crit });\n        this._recipients.push(recipient);\n        return recipient;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this._aad = aad;\n        return this;\n    }\n    async encrypt(options) {\n        var _a, _b, _c;\n        if (!this._recipients.length) {\n            throw new JWEInvalid('at least one recipient must be added');\n        }\n        options = { deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw };\n        if (this._recipients.length === 1) {\n            const [recipient] = this._recipients;\n            const flattened = await new FlattenedEncrypt(this._plaintext)\n                .setAdditionalAuthenticatedData(this._aad)\n                .setProtectedHeader(this._protectedHeader)\n                .setSharedUnprotectedHeader(this._unprotectedHeader)\n                .setUnprotectedHeader(recipient.unprotectedHeader)\n                .encrypt(recipient.key, { ...recipient.options, ...options });\n            let jwe = {\n                ciphertext: flattened.ciphertext,\n                iv: flattened.iv,\n                recipients: [{}],\n                tag: flattened.tag,\n            };\n            if (flattened.aad)\n                jwe.aad = flattened.aad;\n            if (flattened.protected)\n                jwe.protected = flattened.protected;\n            if (flattened.unprotected)\n                jwe.unprotected = flattened.unprotected;\n            if (flattened.encrypted_key)\n                jwe.recipients[0].encrypted_key = flattened.encrypted_key;\n            if (flattened.header)\n                jwe.recipients[0].header = flattened.header;\n            return jwe;\n        }\n        let enc;\n        for (let i = 0; i < this._recipients.length; i++) {\n            const recipient = this._recipients[i];\n            if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {\n                throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n            }\n            const joseHeader = {\n                ...this._protectedHeader,\n                ...this._unprotectedHeader,\n                ...recipient.unprotectedHeader,\n            };\n            const { alg } = joseHeader;\n            if (typeof alg !== 'string' || !alg) {\n                throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n            }\n            if (alg === 'dir' || alg === 'ECDH-ES') {\n                throw new JWEInvalid('\"dir\" and \"ECDH-ES\" alg may only be used with a single recipient');\n            }\n            if (typeof joseHeader.enc !== 'string' || !joseHeader.enc) {\n                throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n            }\n            if (!enc) {\n                enc = joseHeader.enc;\n            }\n            else if (enc !== joseHeader.enc) {\n                throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter must be the same for all recipients');\n            }\n            validateCrit(JWEInvalid, new Map(), recipient.options.crit, this._protectedHeader, joseHeader);\n            if (joseHeader.zip !== undefined) {\n                if (!this._protectedHeader || !this._protectedHeader.zip) {\n                    throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n                }\n            }\n        }\n        const cek = generateCek(enc);\n        let jwe = {\n            ciphertext: '',\n            iv: '',\n            recipients: [],\n            tag: '',\n        };\n        for (let i = 0; i < this._recipients.length; i++) {\n            const recipient = this._recipients[i];\n            const target = {};\n            jwe.recipients.push(target);\n            const joseHeader = {\n                ...this._protectedHeader,\n                ...this._unprotectedHeader,\n                ...recipient.unprotectedHeader,\n            };\n            const p2c = joseHeader.alg.startsWith('PBES2') ? 2048 + i : undefined;\n            if (i === 0) {\n                const flattened = await new FlattenedEncrypt(this._plaintext)\n                    .setAdditionalAuthenticatedData(this._aad)\n                    .setContentEncryptionKey(cek)\n                    .setProtectedHeader(this._protectedHeader)\n                    .setSharedUnprotectedHeader(this._unprotectedHeader)\n                    .setUnprotectedHeader(recipient.unprotectedHeader)\n                    .setKeyManagementParameters({ p2c })\n                    .encrypt(recipient.key, {\n                    ...recipient.options,\n                    ...options,\n                    [unprotected]: true,\n                });\n                jwe.ciphertext = flattened.ciphertext;\n                jwe.iv = flattened.iv;\n                jwe.tag = flattened.tag;\n                if (flattened.aad)\n                    jwe.aad = flattened.aad;\n                if (flattened.protected)\n                    jwe.protected = flattened.protected;\n                if (flattened.unprotected)\n                    jwe.unprotected = flattened.unprotected;\n                target.encrypted_key = flattened.encrypted_key;\n                if (flattened.header)\n                    target.header = flattened.header;\n                continue;\n            }\n            const { encryptedKey, parameters } = await encryptKeyManagement(((_a = recipient.unprotectedHeader) === null || _a === void 0 ? void 0 : _a.alg) ||\n                ((_b = this._protectedHeader) === null || _b === void 0 ? void 0 : _b.alg) ||\n                ((_c = this._unprotectedHeader) === null || _c === void 0 ? void 0 : _c.alg), enc, recipient.key, cek, { p2c });\n            target.encrypted_key = base64url(encryptedKey);\n            if (recipient.unprotectedHeader || parameters)\n                target.header = { ...recipient.unprotectedHeader, ...parameters };\n        }\n        return jwe;\n    }\n}\n","import * as crypto from 'crypto';\nimport { promisify } from 'util';\nimport nodeDigest from './dsa_digest.js';\nimport nodeKey from './node_key.js';\nimport sign from './sign.js';\nimport getVerifyKey from './get_sign_verify_key.js';\nimport { oneShotCallback } from './flags.js';\nlet oneShotVerify;\nif (crypto.verify.length > 4 && oneShotCallback) {\n    oneShotVerify = promisify(crypto.verify);\n}\nelse {\n    oneShotVerify = crypto.verify;\n}\nconst verify = async (alg, key, signature, data) => {\n    const keyObject = getVerifyKey(alg, key, 'verify');\n    if (alg.startsWith('HS')) {\n        const expected = await sign(alg, keyObject, data);\n        const actual = signature;\n        try {\n            return crypto.timingSafeEqual(actual, expected);\n        }\n        catch {\n            return false;\n        }\n    }\n    const algorithm = nodeDigest(alg);\n    const keyInput = nodeKey(alg, keyObject);\n    try {\n        return await oneShotVerify(algorithm, data, keyInput, signature);\n    }\n    catch {\n        return false;\n    }\n};\nexport default verify;\n","import { Buffer } from 'buffer';\nimport { createPublicKey, KeyObject } from 'crypto';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { isCryptoKey } from './webcrypto.js';\nimport isKeyObject from './is_key_object.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nconst p256 = Buffer.from([42, 134, 72, 206, 61, 3, 1, 7]);\nconst p384 = Buffer.from([43, 129, 4, 0, 34]);\nconst p521 = Buffer.from([43, 129, 4, 0, 35]);\nconst secp256k1 = Buffer.from([43, 129, 4, 0, 10]);\nexport const weakMap = new WeakMap();\nconst namedCurveToJOSE = (namedCurve) => {\n    switch (namedCurve) {\n        case 'prime256v1':\n            return 'P-256';\n        case 'secp384r1':\n            return 'P-384';\n        case 'secp521r1':\n            return 'P-521';\n        case 'secp256k1':\n            return 'secp256k1';\n        default:\n            throw new JOSENotSupported('Unsupported key curve for this operation');\n    }\n};\nconst getNamedCurve = (kee, raw) => {\n    var _a;\n    let key;\n    if (isCryptoKey(kee)) {\n        key = KeyObject.from(kee);\n    }\n    else if (isKeyObject(kee)) {\n        key = kee;\n    }\n    else {\n        throw new TypeError(invalidKeyInput(kee, ...types));\n    }\n    if (key.type === 'secret') {\n        throw new TypeError('only \"private\" or \"public\" type keys can be used for this operation');\n    }\n    switch (key.asymmetricKeyType) {\n        case 'ed25519':\n        case 'ed448':\n            return `Ed${key.asymmetricKeyType.slice(2)}`;\n        case 'x25519':\n        case 'x448':\n            return `X${key.asymmetricKeyType.slice(1)}`;\n        case 'ec': {\n            if (weakMap.has(key)) {\n                return weakMap.get(key);\n            }\n            let namedCurve = (_a = key.asymmetricKeyDetails) === null || _a === void 0 ? void 0 : _a.namedCurve;\n            if (!namedCurve && key.type === 'private') {\n                namedCurve = getNamedCurve(createPublicKey(key), true);\n            }\n            else if (!namedCurve) {\n                const buf = key.export({ format: 'der', type: 'spki' });\n                const i = buf[1] < 128 ? 14 : 15;\n                const len = buf[i];\n                const curveOid = buf.slice(i + 1, i + 1 + len);\n                if (curveOid.equals(p256)) {\n                    namedCurve = 'prime256v1';\n                }\n                else if (curveOid.equals(p384)) {\n                    namedCurve = 'secp384r1';\n                }\n                else if (curveOid.equals(p521)) {\n                    namedCurve = 'secp521r1';\n                }\n                else if (curveOid.equals(secp256k1)) {\n                    namedCurve = 'secp256k1';\n                }\n                else {\n                    throw new JOSENotSupported('Unsupported key curve for this operation');\n                }\n            }\n            if (raw)\n                return namedCurve;\n            const curve = namedCurveToJOSE(namedCurve);\n            weakMap.set(key, curve);\n            return curve;\n        }\n        default:\n            throw new TypeError('Invalid asymmetric key type for this operation');\n    }\n};\nexport function setCurve(keyObject, curve) {\n    weakMap.set(keyObject, curve);\n}\nexport default getNamedCurve;\n","import { KeyObject, publicEncrypt, constants, privateDecrypt } from 'crypto';\nimport checkModulusLength from './check_modulus_length.js';\nimport { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport isKeyObject from './is_key_object.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nconst checkKey = (key, alg) => {\n    if (key.asymmetricKeyType !== 'rsa') {\n        throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa');\n    }\n    checkModulusLength(key, alg);\n};\nconst resolvePadding = (alg) => {\n    switch (alg) {\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            return constants.RSA_PKCS1_OAEP_PADDING;\n        case 'RSA1_5':\n            return constants.RSA_PKCS1_PADDING;\n        default:\n            return undefined;\n    }\n};\nconst resolveOaepHash = (alg) => {\n    switch (alg) {\n        case 'RSA-OAEP':\n            return 'sha1';\n        case 'RSA-OAEP-256':\n            return 'sha256';\n        case 'RSA-OAEP-384':\n            return 'sha384';\n        case 'RSA-OAEP-512':\n            return 'sha512';\n        default:\n            return undefined;\n    }\n};\nfunction ensureKeyObject(key, alg, ...usages) {\n    if (isKeyObject(key)) {\n        return key;\n    }\n    if (isCryptoKey(key)) {\n        checkEncCryptoKey(key, alg, ...usages);\n        return KeyObject.from(key);\n    }\n    throw new TypeError(invalidKeyInput(key, ...types));\n}\nexport const encrypt = (alg, key, cek) => {\n    const padding = resolvePadding(alg);\n    const oaepHash = resolveOaepHash(alg);\n    const keyObject = ensureKeyObject(key, alg, 'wrapKey', 'encrypt');\n    checkKey(keyObject, alg);\n    return publicEncrypt({ key: keyObject, oaepHash, padding }, cek);\n};\nexport const decrypt = (alg, key, encryptedKey) => {\n    const padding = resolvePadding(alg);\n    const oaepHash = resolveOaepHash(alg);\n    const keyObject = ensureKeyObject(key, alg, 'unwrapKey', 'decrypt');\n    checkKey(keyObject, alg);\n    return privateDecrypt({ key: keyObject, oaepHash, padding }, encryptedKey);\n};\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/sign/walletlink/relay/connection/WalletLinkConnection.ts","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/sign/util.ts","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/createCoinbaseWalletSDK.ts","import type { ErrorType } from '../../errors/utils.js'\nimport type { ExactPartial } from '../../types/utils.js'\nimport {\n  type AssertRequestErrorType,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\nimport type { zksync } from '../../zksync/chains.js'\nimport type { SendTransactionParameters } from '../actions/sendTransaction.js'\nimport {\n  InvalidEip712TransactionError,\n  type InvalidEip712TransactionErrorType,\n} from '../errors/transaction.js'\nimport { isEIP712Transaction } from './isEip712Transaction.js'\n\nexport type AssertEip712RequestParameters = ExactPartial<\n  SendTransactionParameters<typeof zksync>\n>\n\n/** @internal */\nexport type AssertEip712RequestErrorType =\n  | InvalidEip712TransactionErrorType\n  | AssertRequestErrorType\n  | ErrorType\n\nexport function assertEip712Request(args: AssertEip712RequestParameters) {\n  if (!isEIP712Transaction(args as any))\n    throw new InvalidEip712TransactionError()\n  assertRequest(args as any)\n}\n","import { encode as base64url } from '../../runtime/base64url.js';\nimport sign from '../../runtime/sign.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport class FlattenedSign {\n    constructor(payload) {\n        if (!(payload instanceof Uint8Array)) {\n            throw new TypeError('payload must be an instance of Uint8Array');\n        }\n        this._payload = payload;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader) {\n            throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n        }\n        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader)) {\n            throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n        };\n        const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n        let b64 = true;\n        if (extensions.has('b64')) {\n            b64 = this._protectedHeader.b64;\n            if (typeof b64 !== 'boolean') {\n                throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n            }\n        }\n        const { alg } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        checkKeyType(alg, key, 'sign');\n        let payload = this._payload;\n        if (b64) {\n            payload = encoder.encode(base64url(payload));\n        }\n        let protectedHeader;\n        if (this._protectedHeader) {\n            protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        const data = concat(protectedHeader, encoder.encode('.'), payload);\n        const signature = await sign(alg, key, data);\n        const jws = {\n            signature: base64url(signature),\n            payload: '',\n        };\n        if (b64) {\n            jws.payload = decoder.decode(payload);\n        }\n        if (this._unprotectedHeader) {\n            jws.header = this._unprotectedHeader;\n        }\n        if (this._protectedHeader) {\n            jws.protected = decoder.decode(protectedHeader);\n        }\n        return jws;\n    }\n}\n","import type { ExactPartial, OneOf } from '../../types/utils.js'\nimport type {\n  ZksyncTransactionRequest,\n  ZksyncTransactionSerializable,\n} from '../types/transaction.js'\n\nexport function isEIP712Transaction(\n  transaction: ExactPartial<\n    OneOf<ZksyncTransactionRequest | ZksyncTransactionSerializable>\n  >,\n) {\n  if (transaction.type === 'eip712') return true\n  if (\n    ('customSignature' in transaction && transaction.customSignature) ||\n    ('paymaster' in transaction && transaction.paymaster) ||\n    ('paymasterInput' in transaction && transaction.paymasterInput) ||\n    ('gasPerPubdata' in transaction &&\n      typeof transaction.gasPerPubdata === 'bigint') ||\n    ('factoryDeps' in transaction && transaction.factoryDeps)\n  )\n    return true\n  return false\n}\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/util/cipher.ts","import { equalBytes } from '@noble/curves/abstract/utils'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as internal_bytes from './internal/bytes.js'\nimport * as internal from './internal/hex.js'\nimport * as Json from './Json.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\n/** Root type for a Hex string. */\nexport type Hex = `0x${string}`\n\n/**\n * Asserts if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('abc')\n * // @error: InvalidHexValueTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid hex type.\n * // @error: Hex types must be represented as `\"0x\\${string}\"`.\n * ```\n *\n * @param value - The value to assert.\n * @param options - Options.\n */\nexport function assert(\n  value: unknown,\n  options: assert.Options = {},\n): asserts value is Hex {\n  const { strict = false } = options\n  if (!value) throw new InvalidHexTypeError(value)\n  if (typeof value !== 'string') throw new InvalidHexTypeError(value)\n  if (strict) {\n    if (!/^0x[0-9a-fA-F]*$/.test(value)) throw new InvalidHexValueError(value)\n  }\n  if (!value.startsWith('0x')) throw new InvalidHexValueError(value)\n}\n\nexport declare namespace assert {\n  type Options = {\n    /** Checks if the {@link ox#Hex.Hex} value contains invalid hexadecimal characters. @default false */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType =\n    | InvalidHexTypeError\n    | InvalidHexValueError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Concatenates two or more {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.concat('0x123', '0x456')\n * // @log: '0x123456'\n * ```\n *\n * @param values - The {@link ox#Hex.Hex} values to concatenate.\n * @returns The concatenated {@link ox#Hex.Hex} value.\n */\nexport function concat(...values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce((acc, x) => acc + x.replace('0x', ''), '')}`\n}\n\nexport declare namespace concat {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates a {@link ox#Hex.Hex} value from a hex string or {@link ox#Bytes.Bytes} value.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Hex.fromBoolean`\n *\n * - `Hex.fromString`\n *\n * - `Hex.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.from('0x48656c6c6f20576f726c6421')\n * // @log: '0x48656c6c6f20576f726c6421'\n *\n * Hex.from(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function from(value: Hex | Bytes.Bytes | readonly number[]): Hex {\n  if (value instanceof Uint8Array) return fromBytes(value)\n  if (Array.isArray(value)) return fromBytes(new Uint8Array(value))\n  return value as never\n}\n\nexport declare namespace from {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a boolean into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * Hex.fromBoolean(false)\n * // @log: '0x0'\n *\n * Hex.fromBoolean(true, { size: 32 })\n * // @log: '0x0000000000000000000000000000000000000000000000000000000000000001'\n * ```\n *\n * @param value - The boolean value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBoolean(\n  value: boolean,\n  options: fromBoolean.Options = {},\n): Hex {\n  const hex: Hex = `0x${Number(value)}`\n  if (typeof options.size === 'number') {\n    internal.assertSize(hex, options.size)\n    return padLeft(hex, options.size)\n  }\n  return hex\n}\n\nexport declare namespace fromBoolean {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.fromBytes(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBytes(\n  value: Bytes.Bytes,\n  options: fromBytes.Options = {},\n): Hex {\n  let string = ''\n  for (let i = 0; i < value.length; i++) string += hexes[value[i]!]\n  const hex = `0x${string}` as const\n\n  if (typeof options.size === 'number') {\n    internal.assertSize(hex, options.size)\n    return padRight(hex, options.size)\n  }\n  return hex\n}\n\nexport declare namespace fromBytes {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | padRight.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a number or bigint into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420)\n * // @log: '0x1a4'\n *\n * Hex.fromNumber(420, { size: 32 })\n * // @log: '0x00000000000000000000000000000000000000000000000000000000000001a4'\n * ```\n *\n * @param value - The number or bigint value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromNumber(\n  value: number | bigint,\n  options: fromNumber.Options = {},\n): Hex {\n  const { signed, size } = options\n\n  const value_ = BigInt(value)\n\n  let maxValue: bigint | number | undefined\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value_ > maxValue) || value_ < minValue) {\n    const suffix = typeof value === 'bigint' ? 'n' : ''\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value}${suffix}`,\n    })\n  }\n\n  const stringValue = (\n    signed && value_ < 0 ? (1n << BigInt(size * 8)) + BigInt(value_) : value_\n  ).toString(16)\n\n  const hex = `0x${stringValue}` as Hex\n  if (size) return padLeft(hex, size) as Hex\n  return hex\n}\n\nexport declare namespace fromNumber {\n  type Options =\n    | {\n        /** Whether or not the number of a signed representation. */\n        signed?: boolean | undefined\n        /** The size (in bytes) of the output hex value. */\n        size: number\n      }\n    | {\n        signed?: undefined\n        /** The size (in bytes) of the output hex value. */\n        size?: number | undefined\n      }\n\n  type ErrorType =\n    | IntegerOutOfRangeError\n    | padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a string into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n * Hex.fromString('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * Hex.fromString('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n * ```\n *\n * @param value - The string value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromString(\n  value: string,\n  options: fromString.Options = {},\n): Hex {\n  return fromBytes(encoder.encode(value), options)\n}\n\nexport declare namespace fromString {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Checks if two {@link ox#Hex.Hex} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.isEqual('0xdeadbeef', '0xdeadbeef')\n * // @log: true\n *\n * Hex.isEqual('0xda', '0xba')\n * // @log: false\n * ```\n *\n * @param hexA - The first {@link ox#Hex.Hex} value.\n * @param hexB - The second {@link ox#Hex.Hex} value.\n * @returns `true` if the two {@link ox#Hex.Hex} values are equal, `false` otherwise.\n */\nexport function isEqual(hexA: Hex, hexB: Hex) {\n  return equalBytes(Bytes.fromHex(hexA), Bytes.fromHex(hexB))\n}\n\nexport declare namespace isEqual {\n  type ErrorType = Bytes.fromHex.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Pads a {@link ox#Hex.Hex} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1234', 4)\n * // @log: '0x00001234'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padLeft(\n  value: Hex,\n  size?: number | undefined,\n): padLeft.ReturnType {\n  return internal.pad(value, { dir: 'left', size })\n}\n\nexport declare namespace padLeft {\n  type ReturnType = Hex\n  type ErrorType = internal.pad.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Pads a {@link ox#Hex.Hex} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts\n * import { Hex } from 'ox'\n *\n * Hex.padRight('0x1234', 4)\n * // @log: '0x12340000'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padRight(\n  value: Hex,\n  size?: number | undefined,\n): padRight.ReturnType {\n  return internal.pad(value, { dir: 'right', size })\n}\n\nexport declare namespace padRight {\n  type ReturnType = Hex\n  type ErrorType = internal.pad.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Generates a random {@link ox#Hex.Hex} value of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const hex = Hex.random(32)\n * // @log: '0x...'\n * ```\n *\n * @returns Random {@link ox#Hex.Hex} value.\n */\nexport function random(length: number): Hex {\n  return fromBytes(Bytes.random(length))\n}\n\nexport declare namespace random {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 1, 4)\n * // @log: '0x234567'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to slice.\n * @param start - The start offset (in bytes).\n * @param end - The end offset (in bytes).\n * @param options - Options.\n * @returns The sliced {@link ox#Hex.Hex} value.\n */\nexport function slice(\n  value: Hex,\n  start?: number | undefined,\n  end?: number | undefined,\n  options: slice.Options = {},\n): Hex {\n  const { strict } = options\n  internal.assertStartOffset(value, start)\n  const value_ = `0x${value\n    .replace('0x', '')\n    .slice((start ?? 0) * 2, (end ?? value.length) * 2)}` as const\n  if (strict) internal.assertEndOffset(value_, start, end)\n  return value_\n}\n\nexport declare namespace slice {\n  type Options = {\n    /** Asserts that the sliced value is the same size as the given start/end offsets. */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType =\n    | internal.assertStartOffset.ErrorType\n    | internal.assertEndOffset.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Retrieves the size of a {@link ox#Hex.Hex} value (in bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.size('0xdeadbeef')\n * // @log: 4\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to get the size of.\n * @returns The size of the {@link ox#Hex.Hex} value (in bytes).\n */\nexport function size(value: Hex): number {\n  return Math.ceil((value.length - 2) / 2)\n}\n\nexport declare namespace size {\n  export type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Trims leading zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimLeft('0x00000000deadbeef')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimLeft(value: Hex): trimLeft.ReturnType {\n  return internal.trim(value, { dir: 'left' })\n}\n\nexport declare namespace trimLeft {\n  type ReturnType = Hex\n\n  type ErrorType = internal.trim.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Trims trailing zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimRight('0xdeadbeef00000000')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimRight(value: Hex): trimRight.ReturnType {\n  return internal.trim(value, { dir: 'right' })\n}\n\nexport declare namespace trimRight {\n  type ReturnType = Hex\n\n  type ErrorType = internal.trim.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a BigInt.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBigInt('0x1a4')\n * // @log: 420n\n *\n * Hex.toBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420n\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded BigInt.\n */\nexport function toBigInt(hex: Hex, options: toBigInt.Options = {}): bigint {\n  const { signed } = options\n\n  if (options.size) internal.assertSize(hex, options.size)\n\n  const value = BigInt(hex)\n  if (!signed) return value\n\n  const size = (hex.length - 2) / 2\n\n  const max_unsigned = (1n << (BigInt(size) * 8n)) - 1n\n  const max_signed = max_unsigned >> 1n\n\n  if (value <= max_signed) return value\n  return value - max_unsigned - 1n\n}\n\nexport declare namespace toBigInt {\n  type Options = {\n    /** Whether or not the number of a signed representation. */\n    signed?: boolean | undefined\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = internal.assertSize.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0x01')\n * // @log: true\n *\n * Hex.toBoolean('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // @log: true\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded boolean.\n */\nexport function toBoolean(hex: Hex, options: toBoolean.Options = {}): boolean {\n  if (options.size) internal.assertSize(hex, options.size)\n  const hex_ = trimLeft(hex)\n  if (hex_ === '0x') return false\n  if (hex_ === '0x1') return true\n  throw new InvalidHexBooleanError(hex)\n}\n\nexport declare namespace toBoolean {\n  type Options = {\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | trimLeft.ErrorType\n    | InvalidHexBooleanError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const data = Hex.toBytes('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded {@link ox#Bytes.Bytes}.\n */\nexport function toBytes(hex: Hex, options: toBytes.Options = {}): Bytes.Bytes {\n  return Bytes.fromHex(hex, options)\n}\n\nexport declare namespace toBytes {\n  type Options = {\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = Bytes.fromHex.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a number.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toNumber('0x1a4')\n * // @log: 420\n *\n * Hex.toNumber('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded number.\n */\nexport function toNumber(hex: Hex, options: toNumber.Options = {}): number {\n  const { signed, size } = options\n  if (!signed && !size) return Number(hex)\n  return Number(toBigInt(hex, options))\n}\n\nexport declare namespace toNumber {\n  type Options = toBigInt.Options\n\n  type ErrorType = toBigInt.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a string.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello world!'\n *\n * Hex.toString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // @log: 'Hello world'\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded string.\n */\nexport function toString(hex: Hex, options: toString.Options = {}): string {\n  const { size } = options\n\n  let bytes = Bytes.fromHex(hex)\n  if (size) {\n    internal_bytes.assertSize(bytes, size)\n    bytes = Bytes.trimRight(bytes)\n  }\n  return new TextDecoder().decode(bytes)\n}\n\nexport declare namespace toString {\n  type Options = {\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal_bytes.assertSize.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Bytes.trimRight.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.validate('0xdeadbeef')\n * // @log: true\n *\n * Hex.validate(Bytes.from([1, 2, 3]))\n * // @log: false\n * ```\n *\n * @param value - The value to check.\n * @param options - Options.\n * @returns `true` if the value is a {@link ox#Hex.Hex}, `false` otherwise.\n */\nexport function validate(\n  value: unknown,\n  options: validate.Options = {},\n): value is Hex {\n  const { strict = false } = options\n  try {\n    assert(value, { strict })\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /** Checks if the {@link ox#Hex.Hex} value contains invalid hexadecimal characters. @default false */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Thrown when the provided integer is out of range, and cannot be represented as a hex value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420182738912731283712937129)\n * // @error: Hex.IntegerOutOfRangeError: Number \\`4.2018273891273126e+26\\` is not in safe unsigned integer range (`0` to `9007199254740991`)\n * ```\n */\nexport class IntegerOutOfRangeError extends Errors.BaseError {\n  override readonly name = 'Hex.IntegerOutOfRangeError'\n\n  constructor({\n    max,\n    min,\n    signed,\n    size,\n    value,\n  }: {\n    max?: string | undefined\n    min: string\n    signed?: boolean | undefined\n    size?: number | undefined\n    value: string\n  }) {\n    super(\n      `Number \\`${value}\\` is not in safe${\n        size ? ` ${size * 8}-bit` : ''\n      }${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`,\n    )\n  }\n}\n\n/**\n * Thrown when the provided hex value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0xa')\n * // @error: Hex.InvalidHexBooleanError: Hex value `\"0xa\"` is not a valid boolean.\n * // @error: The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).\n * ```\n */\nexport class InvalidHexBooleanError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidHexBooleanError'\n\n  constructor(hex: Hex) {\n    super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n      metaMessages: [\n        'The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).',\n      ],\n    })\n  }\n}\n\n/**\n * Thrown when the provided value is not a valid hex type.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert(1)\n * // @error: Hex.InvalidHexTypeError: Value `1` of type `number` is an invalid hex type.\n * ```\n */\nexport class InvalidHexTypeError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidHexTypeError'\n\n  constructor(value: unknown) {\n    super(\n      `Value \\`${typeof value === 'object' ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`,\n      {\n        metaMessages: ['Hex types must be represented as `\"0x${string}\"`.'],\n      },\n    )\n  }\n}\n\n/**\n * Thrown when the provided hex value is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('0x0123456789abcdefg')\n * // @error: Hex.InvalidHexValueError: Value `0x0123456789abcdefg` is an invalid hex value.\n * // @error: Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).\n * ```\n */\nexport class InvalidHexValueError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidHexValueError'\n\n  constructor(value: unknown) {\n    super(`Value \\`${value}\\` is an invalid hex value.`, {\n      metaMessages: [\n        'Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).',\n      ],\n    })\n  }\n}\n\n/**\n * Thrown when the provided hex value is an odd length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromHex('0xabcde')\n * // @error: Hex.InvalidLengthError: Hex value `\"0xabcde\"` is an odd length (5 nibbles).\n * ```\n */\nexport class InvalidLengthError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidLengthError'\n\n  constructor(value: Hex) {\n    super(\n      `Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`,\n      {\n        metaMessages: ['It must be an even length.'],\n      },\n    )\n  }\n}\n\n/**\n * Thrown when the size of the value exceeds the expected max size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromString('Hello World!', { size: 8 })\n * // @error: Hex.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nexport class SizeOverflowError extends Errors.BaseError {\n  override readonly name = 'Hex.SizeOverflowError'\n\n  constructor({ givenSize, maxSize }: { givenSize: number; maxSize: number }) {\n    super(\n      `Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`,\n    )\n  }\n}\n\n/**\n * Thrown when the slice offset exceeds the bounds of the value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 6)\n * // @error: Hex.SliceOffsetOutOfBoundsError: Slice starting at offset `6` is out-of-bounds (size: `5`).\n * ```\n */\nexport class SliceOffsetOutOfBoundsError extends Errors.BaseError {\n  override readonly name = 'Hex.SliceOffsetOutOfBoundsError'\n\n  constructor({\n    offset,\n    position,\n    size,\n  }: { offset: number; position: 'start' | 'end'; size: number }) {\n    super(\n      `Slice ${\n        position === 'start' ? 'starting' : 'ending'\n      } at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`,\n    )\n  }\n}\n\n/**\n * Thrown when the size of the value exceeds the pad size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1a4e12a45a21323123aaa87a897a897a898a6567a578a867a98778a667a85a875a87a6a787a65a675a6a9', 32)\n * // @error: Hex.SizeExceedsPaddingSizeError: Hex size (`43`) exceeds padding size (`32`).\n * ```\n */\nexport class SizeExceedsPaddingSizeError extends Errors.BaseError {\n  override readonly name = 'Hex.SizeExceedsPaddingSizeError'\n\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'Hex' | 'Bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`,\n    )\n  }\n}\n","import { Buffer } from 'buffer';\nimport { createPrivateKey, createPublicKey, createSecretKey } from 'crypto';\nimport { decode as base64url } from './base64url.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { setCurve } from './get_named_curve.js';\nimport { setModulusLength } from './check_modulus_length.js';\nimport Asn1SequenceEncoder from './asn1_sequence_encoder.js';\nimport { jwkImport } from './flags.js';\nconst parse = (jwk) => {\n    if (jwkImport && jwk.kty !== 'oct') {\n        return jwk.d\n            ? createPrivateKey({ format: 'jwk', key: jwk })\n            : createPublicKey({ format: 'jwk', key: jwk });\n    }\n    switch (jwk.kty) {\n        case 'oct': {\n            return createSecretKey(base64url(jwk.k));\n        }\n        case 'RSA': {\n            const enc = new Asn1SequenceEncoder();\n            const isPrivate = jwk.d !== undefined;\n            const modulus = Buffer.from(jwk.n, 'base64');\n            const exponent = Buffer.from(jwk.e, 'base64');\n            if (isPrivate) {\n                enc.zero();\n                enc.unsignedInteger(modulus);\n                enc.unsignedInteger(exponent);\n                enc.unsignedInteger(Buffer.from(jwk.d, 'base64'));\n                enc.unsignedInteger(Buffer.from(jwk.p, 'base64'));\n                enc.unsignedInteger(Buffer.from(jwk.q, 'base64'));\n                enc.unsignedInteger(Buffer.from(jwk.dp, 'base64'));\n                enc.unsignedInteger(Buffer.from(jwk.dq, 'base64'));\n                enc.unsignedInteger(Buffer.from(jwk.qi, 'base64'));\n            }\n            else {\n                enc.unsignedInteger(modulus);\n                enc.unsignedInteger(exponent);\n            }\n            const der = enc.end();\n            const createInput = {\n                key: der,\n                format: 'der',\n                type: 'pkcs1',\n            };\n            const keyObject = isPrivate ? createPrivateKey(createInput) : createPublicKey(createInput);\n            setModulusLength(keyObject, modulus.length << 3);\n            return keyObject;\n        }\n        case 'EC': {\n            const enc = new Asn1SequenceEncoder();\n            const isPrivate = jwk.d !== undefined;\n            const pub = Buffer.concat([\n                Buffer.alloc(1, 4),\n                Buffer.from(jwk.x, 'base64'),\n                Buffer.from(jwk.y, 'base64'),\n            ]);\n            if (isPrivate) {\n                enc.zero();\n                const enc$1 = new Asn1SequenceEncoder();\n                enc$1.oidFor('ecPublicKey');\n                enc$1.oidFor(jwk.crv);\n                enc.add(enc$1.end());\n                const enc$2 = new Asn1SequenceEncoder();\n                enc$2.one();\n                enc$2.octStr(Buffer.from(jwk.d, 'base64'));\n                const enc$3 = new Asn1SequenceEncoder();\n                enc$3.bitStr(pub);\n                const f2 = enc$3.end(Buffer.from([0xa1]));\n                enc$2.add(f2);\n                const f = enc$2.end();\n                const enc$4 = new Asn1SequenceEncoder();\n                enc$4.add(f);\n                const f3 = enc$4.end(Buffer.from([0x04]));\n                enc.add(f3);\n                const der = enc.end();\n                const keyObject = createPrivateKey({ key: der, format: 'der', type: 'pkcs8' });\n                setCurve(keyObject, jwk.crv);\n                return keyObject;\n            }\n            const enc$1 = new Asn1SequenceEncoder();\n            enc$1.oidFor('ecPublicKey');\n            enc$1.oidFor(jwk.crv);\n            enc.add(enc$1.end());\n            enc.bitStr(pub);\n            const der = enc.end();\n            const keyObject = createPublicKey({ key: der, format: 'der', type: 'spki' });\n            setCurve(keyObject, jwk.crv);\n            return keyObject;\n        }\n        case 'OKP': {\n            const enc = new Asn1SequenceEncoder();\n            const isPrivate = jwk.d !== undefined;\n            if (isPrivate) {\n                enc.zero();\n                const enc$1 = new Asn1SequenceEncoder();\n                enc$1.oidFor(jwk.crv);\n                enc.add(enc$1.end());\n                const enc$2 = new Asn1SequenceEncoder();\n                enc$2.octStr(Buffer.from(jwk.d, 'base64'));\n                const f = enc$2.end(Buffer.from([0x04]));\n                enc.add(f);\n                const der = enc.end();\n                return createPrivateKey({ key: der, format: 'der', type: 'pkcs8' });\n            }\n            const enc$1 = new Asn1SequenceEncoder();\n            enc$1.oidFor(jwk.crv);\n            enc.add(enc$1.end());\n            enc.bitStr(Buffer.from(jwk.x, 'base64'));\n            const der = enc.end();\n            return createPublicKey({ key: der, format: 'der', type: 'spki' });\n        }\n        default:\n            throw new JOSENotSupported('Invalid or unsupported JWK \"kty\" (Key Type) Parameter value');\n    }\n};\nexport default parse;\n","import { contracts } from './contracts.js'\nimport { formatters } from './formatters.js'\nimport { serializers } from './serializers.js'\n\nexport const chainConfig = {\n  blockTime: 2_000,\n  contracts,\n  formatters,\n  serializers,\n} as const\n","import { setMaxListeners } from 'node:events';\n\nexport const AbortController = class extends globalThis.AbortController {\n    constructor(...args: ConstructorParameters<typeof globalThis.AbortController>) {\n        super(...args);\n        setMaxListeners(Number.MAX_SAFE_INTEGER, this.signal);\n    }\n};\n\nexport const EventTarget = class extends globalThis.EventTarget {\n    constructor(...args: ConstructorParameters<typeof globalThis.EventTarget>) {\n        super(...args);\n        setMaxListeners(Number.MAX_SAFE_INTEGER, this);\n    }\n};\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/core/type/index.ts","import type * as Errors from '../Errors.js'\nimport * as Hex from '../Hex.js'\n\n/** @internal */\nexport function assertSize(hex: Hex.Hex, size_: number): void {\n  if (Hex.size(hex) > size_)\n    throw new Hex.SizeOverflowError({\n      givenSize: Hex.size(hex),\n      maxSize: size_,\n    })\n}\n\n/** @internal */\nexport declare namespace assertSize {\n  type ErrorType =\n    | Hex.size.ErrorType\n    | Hex.SizeOverflowError\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function assertStartOffset(value: Hex.Hex, start?: number | undefined) {\n  if (typeof start === 'number' && start > 0 && start > Hex.size(value) - 1)\n    throw new Hex.SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: 'start',\n      size: Hex.size(value),\n    })\n}\n\nexport declare namespace assertStartOffset {\n  type ErrorType =\n    | Hex.SliceOffsetOutOfBoundsError\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function assertEndOffset(\n  value: Hex.Hex,\n  start?: number | undefined,\n  end?: number | undefined,\n) {\n  if (\n    typeof start === 'number' &&\n    typeof end === 'number' &&\n    Hex.size(value) !== end - start\n  ) {\n    throw new Hex.SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: Hex.size(value),\n    })\n  }\n}\n\nexport declare namespace assertEndOffset {\n  type ErrorType =\n    | Hex.SliceOffsetOutOfBoundsError\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function pad(hex_: Hex.Hex, options: pad.Options = {}) {\n  const { dir, size = 32 } = options\n\n  if (size === 0) return hex_\n\n  const hex = hex_.replace('0x', '')\n  if (hex.length > size * 2)\n    throw new Hex.SizeExceedsPaddingSizeError({\n      size: Math.ceil(hex.length / 2),\n      targetSize: size,\n      type: 'Hex',\n    })\n\n  return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}` as Hex.Hex\n}\n\n/** @internal */\nexport declare namespace pad {\n  type Options = {\n    dir?: 'left' | 'right' | undefined\n    size?: number | undefined\n  }\n  type ErrorType = Hex.SizeExceedsPaddingSizeError | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function trim(\n  value: Hex.Hex,\n  options: trim.Options = {},\n): trim.ReturnType {\n  const { dir = 'left' } = options\n\n  let data = value.replace('0x', '')\n\n  let sliceLength = 0\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === 'left' ? i : data.length - i - 1]!.toString() === '0')\n      sliceLength++\n    else break\n  }\n  data =\n    dir === 'left'\n      ? data.slice(sliceLength)\n      : data.slice(0, data.length - sliceLength)\n\n  if (data === '0') return '0x'\n  if (dir === 'right' && data.length % 2 === 1) return `0x${data}0`\n  return `0x${data}` as trim.ReturnType\n}\n\n/** @internal */\nexport declare namespace trim {\n  type Options = {\n    dir?: 'left' | 'right' | undefined\n  }\n\n  type ReturnType = Hex.Hex\n\n  type ErrorType = Errors.GlobalErrorType\n}\n","import * as Bytes from '../Bytes.js'\nimport type * as Errors from '../Errors.js'\n\n/** @internal */\nexport function assertSize(bytes: Bytes.Bytes, size_: number): void {\n  if (Bytes.size(bytes) > size_)\n    throw new Bytes.SizeOverflowError({\n      givenSize: Bytes.size(bytes),\n      maxSize: size_,\n    })\n}\n\n/** @internal */\nexport declare namespace assertSize {\n  type ErrorType =\n    | Bytes.size.ErrorType\n    | Bytes.SizeOverflowError\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function assertStartOffset(\n  value: Bytes.Bytes,\n  start?: number | undefined,\n) {\n  if (typeof start === 'number' && start > 0 && start > Bytes.size(value) - 1)\n    throw new Bytes.SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: 'start',\n      size: Bytes.size(value),\n    })\n}\n\nexport declare namespace assertStartOffset {\n  export type ErrorType =\n    | Bytes.SliceOffsetOutOfBoundsError\n    | Bytes.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function assertEndOffset(\n  value: Bytes.Bytes,\n  start?: number | undefined,\n  end?: number | undefined,\n) {\n  if (\n    typeof start === 'number' &&\n    typeof end === 'number' &&\n    Bytes.size(value) !== end - start\n  ) {\n    throw new Bytes.SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: Bytes.size(value),\n    })\n  }\n}\n\n/** @internal */\nexport declare namespace assertEndOffset {\n  type ErrorType =\n    | Bytes.SliceOffsetOutOfBoundsError\n    | Bytes.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport const charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102,\n} as const\n\n/** @internal */\nexport function charCodeToBase16(char: number) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n    return char - charCodeMap.zero\n  if (char >= charCodeMap.A && char <= charCodeMap.F)\n    return char - (charCodeMap.A - 10)\n  if (char >= charCodeMap.a && char <= charCodeMap.f)\n    return char - (charCodeMap.a - 10)\n  return undefined\n}\n\n/** @internal */\nexport function pad(bytes: Bytes.Bytes, options: pad.Options = {}) {\n  const { dir, size = 32 } = options\n  if (size === 0) return bytes\n  if (bytes.length > size)\n    throw new Bytes.SizeExceedsPaddingSizeError({\n      size: bytes.length,\n      targetSize: size,\n      type: 'Bytes',\n    })\n  const paddedBytes = new Uint8Array(size)\n  for (let i = 0; i < size; i++) {\n    const padEnd = dir === 'right'\n    paddedBytes[padEnd ? i : size - i - 1] =\n      bytes[padEnd ? i : bytes.length - i - 1]!\n  }\n  return paddedBytes\n}\n\n/** @internal */\nexport declare namespace pad {\n  type Options = {\n    dir?: 'left' | 'right' | undefined\n    size?: number | undefined\n  }\n\n  type ReturnType = Bytes.Bytes\n\n  type ErrorType = Bytes.SizeExceedsPaddingSizeError | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function trim(\n  value: Bytes.Bytes,\n  options: trim.Options = {},\n): trim.ReturnType {\n  const { dir = 'left' } = options\n\n  let data = value\n\n  let sliceLength = 0\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === 'left' ? i : data.length - i - 1]!.toString() === '0')\n      sliceLength++\n    else break\n  }\n  data =\n    dir === 'left'\n      ? data.slice(sliceLength)\n      : data.slice(0, data.length - sliceLength)\n\n  return data as trim.ReturnType\n}\n\n/** @internal */\nexport declare namespace trim {\n  type Options = {\n    dir?: 'left' | 'right' | undefined\n  }\n\n  type ReturnType = Bytes.Bytes\n\n  type ErrorType = Errors.GlobalErrorType\n}\n","import { version } from '../version.js'\n\n/** @internal */\nexport function getUrl(url: string) {\n  return url\n}\n\n/** @internal */\nexport function getVersion() {\n  return version\n}\n\n/** @internal */\nexport function prettyPrint(args: unknown) {\n  if (!args) return ''\n  const entries = Object.entries(args)\n    .map(([key, value]) => {\n      if (value === undefined || value === false) return null\n      return [key, value]\n    })\n    .filter(Boolean) as [string, string][]\n  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0)\n  return entries\n    .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n    .join('\\n')\n}\n","import { SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN, SolanaError } from '@solana/errors';\nimport { Callable, Flatten, OverloadImplementations, UnionToIntersection } from '@solana/rpc-spec-types';\nimport { createAsyncIterableFromDataPublisher } from '@solana/subscribable';\n\nimport { RpcSubscriptionsApi, RpcSubscriptionsPlan } from './rpc-subscriptions-api';\nimport { PendingRpcSubscriptionsRequest, RpcSubscribeOptions } from './rpc-subscriptions-request';\nimport { RpcSubscriptionsTransport } from './rpc-subscriptions-transport';\n\nexport type RpcSubscriptionsConfig<TRpcMethods> = Readonly<{\n    api: RpcSubscriptionsApi<TRpcMethods>;\n    transport: RpcSubscriptionsTransport;\n}>;\n\n/**\n * An object that exposes all of the functions described by `TRpcSubscriptionsMethods`.\n *\n * Calling each method returns a\n * {@link PendingRpcSubscriptionsRequest | PendingRpcSubscriptionsRequest<TNotification>} where\n * `TNotification` is that method's notification type.\n */\nexport type RpcSubscriptions<TRpcSubscriptionsMethods> = {\n    [TMethodName in keyof TRpcSubscriptionsMethods]: PendingRpcSubscriptionsRequestBuilder<\n        OverloadImplementations<TRpcSubscriptionsMethods, TMethodName>\n    >;\n};\n\ntype PendingRpcSubscriptionsRequestBuilder<TSubscriptionMethodImplementations> = UnionToIntersection<\n    Flatten<{\n        [P in keyof TSubscriptionMethodImplementations]: PendingRpcSubscriptionsRequestReturnTypeMapper<\n            TSubscriptionMethodImplementations[P]\n        >;\n    }>\n>;\n\ntype PendingRpcSubscriptionsRequestReturnTypeMapper<TSubscriptionMethodImplementation> =\n    // Check that this property of the TRpcSubscriptionMethods interface is, in fact, a function.\n    TSubscriptionMethodImplementation extends Callable\n        ? (\n              ...args: Parameters<TSubscriptionMethodImplementation>\n          ) => PendingRpcSubscriptionsRequest<ReturnType<TSubscriptionMethodImplementation>>\n        : never;\n\n/**\n * Creates a {@link RpcSubscriptions} instance given a\n * {@link RpcSubscriptionsApi | RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>} and a\n * {@link RpcSubscriptionsTransport} capable of fulfilling them.\n */\nexport function createSubscriptionRpc<TRpcSubscriptionsApiMethods>(\n    rpcConfig: RpcSubscriptionsConfig<TRpcSubscriptionsApiMethods>,\n): RpcSubscriptions<TRpcSubscriptionsApiMethods> {\n    return new Proxy(rpcConfig.api, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get(target, p, receiver) {\n            if (p === 'then') {\n                return undefined;\n            }\n            return function (...rawParams: unknown[]) {\n                const notificationName = p.toString();\n                const createRpcSubscriptionPlan = Reflect.get(target, notificationName, receiver);\n                if (!createRpcSubscriptionPlan) {\n                    throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN, {\n                        notificationName,\n                    });\n                }\n                const subscriptionPlan = createRpcSubscriptionPlan(...rawParams);\n                return createPendingRpcSubscription(rpcConfig.transport, subscriptionPlan);\n            };\n        },\n    }) as RpcSubscriptions<TRpcSubscriptionsApiMethods>;\n}\n\nfunction createPendingRpcSubscription<TNotification>(\n    transport: RpcSubscriptionsTransport,\n    subscriptionsPlan: RpcSubscriptionsPlan<TNotification>,\n): PendingRpcSubscriptionsRequest<TNotification> {\n    return {\n        async subscribe({ abortSignal }: RpcSubscribeOptions): Promise<AsyncIterable<TNotification>> {\n            const notificationsDataPublisher = await transport({\n                signal: abortSignal,\n                ...subscriptionsPlan,\n            });\n            return createAsyncIterableFromDataPublisher<TNotification>({\n                abortSignal,\n                dataChannelName: 'notification',\n                dataPublisher: notificationsDataPublisher,\n                errorChannelName: 'error',\n            });\n        },\n    };\n}\n","import type { TypedData } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport {\n  type HashTypedDataErrorType,\n  hashTypedData,\n} from '../../utils/signature/hashTypedData.js'\nimport { type SignErrorType, sign } from './sign.js'\n\nexport type SignTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType> & {\n  /** The private key to sign with. */\n  privateKey: Hex\n}\n\nexport type SignTypedDataReturnType = Hex\n\nexport type SignTypedDataErrorType =\n  | HashTypedDataErrorType\n  | SignErrorType\n  | ErrorType\n\n/**\n * @description Signs typed data and calculates an Ethereum-specific signature in [https://eips.ethereum.org/EIPS/eip-712](https://eips.ethereum.org/EIPS/eip-712):\n * `sign(keccak256(\"\\x19\\x01\"  domainSeparator  hashStruct(message)))`.\n *\n * @returns The signature.\n */\nexport async function signTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: SignTypedDataParameters<typedData, primaryType>,\n): Promise<SignTypedDataReturnType> {\n  const { privateKey, ...typedData } =\n    parameters as unknown as SignTypedDataParameters\n  return await sign({\n    hash: hashTypedData(typedData),\n    privateKey,\n    to: 'hex',\n  })\n}\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/sign/walletlink/relay/RelayEventManager.ts","/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { anumber } from '@noble/hashes/utils';\nimport {\n  bitMask,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  ensureBytes,\n  numberToBytesBE,\n  numberToBytesLE,\n  validateObject,\n} from './utils.ts';\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * TODO: remove.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  return FpPow(Field(modulo), num, power);\n}\n\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n) throw new Error('invert: expected non-zero number');\n  if (modulo <= _0n) throw new Error('invert: expected positive modulus, got ' + modulo);\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4<T>(Fp: IField<T>, n: T) {\n  const p1div4 = (Fp.ORDER + _1n) / _4n;\n  const root = Fp.pow(n, p1div4);\n  // Throw if root^2 != n\n  if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n  return root;\n}\n\nfunction sqrt5mod8<T>(Fp: IField<T>, n: T) {\n  const p5div8 = (Fp.ORDER - _5n) / _8n;\n  const n2 = Fp.mul(n, _2n);\n  const v = Fp.pow(n2, p5div8);\n  const nv = Fp.mul(n, v);\n  const i = Fp.mul(Fp.mul(nv, _2n), v);\n  const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n  if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n  return root;\n}\n\n// TODO: Commented-out for now. Provide test vectors.\n// Tonelli is too slow for extension fields Fp2.\n// That means we can't use sqrt (c1, c2...) even for initialization constants.\n// if (P % _16n === _9n) return sqrt9mod16;\n// // prettier-ignore\n// function sqrt9mod16<T>(Fp: IField<T>, n: T, p7div16?: bigint) {\n//   if (p7div16 === undefined) p7div16 = (Fp.ORDER + BigInt(7)) / _16n;\n//   const c1 = Fp.sqrt(Fp.neg(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n//   const c2 = Fp.sqrt(c1);             //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n//   const c3 = Fp.sqrt(Fp.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n//   const c4 = p7div16;                 //  4. c4 = (q + 7) / 16        # Integer arithmetic\n//   let tv1 = Fp.pow(n, c4);            //  1. tv1 = x^c4\n//   let tv2 = Fp.mul(c1, tv1);          //  2. tv2 = c1 * tv1\n//   const tv3 = Fp.mul(c2, tv1);        //  3. tv3 = c2 * tv1\n//   let tv4 = Fp.mul(c3, tv1);          //  4. tv4 = c3 * tv1\n//   const e1 = Fp.eql(Fp.sqr(tv2), n);  //  5.  e1 = (tv2^2) == x\n//   const e2 = Fp.eql(Fp.sqr(tv3), n);  //  6.  e2 = (tv3^2) == x\n//   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n//   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n//   const e3 = Fp.eql(Fp.sqr(tv2), n);  //  9.  e3 = (tv2^2) == x\n//   return Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3) # Select the sqrt from tv1 and tv2\n// }\n\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // Initialization (precomputation).\n  if (P < BigInt(3)) throw new Error('sqrt is not defined for small field');\n  // Factor P - 1 = Q * 2^S, where Q is odd\n  let Q = P - _1n;\n  let S = 0;\n  while (Q % _2n === _0n) {\n    Q /= _2n;\n    S++;\n  }\n\n  // Find the first quadratic non-residue Z >= 2\n  let Z = _2n;\n  const _Fp = Field(P);\n  while (FpLegendre(_Fp, Z) === 1) {\n    // Basic primality test for P. After x iterations, chance of\n    // not finding quadratic non-residue is 2^x, so 2^1000.\n    if (Z++ > 1000) throw new Error('Cannot find square root: probably non-prime P');\n  }\n  // Fast-path; usually done before Z, but we do \"primality test\".\n  if (S === 1) return sqrt3mod4;\n\n  // Slow-path\n  // TODO: test on Fp2 and others\n  let cc = _Fp.pow(Z, Q); // c = z^Q\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    if (Fp.is0(n)) return n;\n    // Check if n is a quadratic residue using Legendre symbol\n    if (FpLegendre(Fp, n) !== 1) throw new Error('Cannot find square root');\n\n    // Initialize variables for the main loop\n    let M = S;\n    let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n    let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n    let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n\n    // Main loop\n    // while t != 1\n    while (!Fp.eql(t, Fp.ONE)) {\n      if (Fp.is0(t)) return Fp.ZERO; // if t=0 return R=0\n      let i = 1;\n\n      // Find the smallest i >= 1 such that t^(2^i)  1 (mod P)\n      let t_tmp = Fp.sqr(t); // t^(2^1)\n      while (!Fp.eql(t_tmp, Fp.ONE)) {\n        i++;\n        t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n        if (i === M) throw new Error('Cannot find square root');\n      }\n\n      // Calculate the exponent for b: 2^(M - i - 1)\n      const exponent = _1n << BigInt(M - i - 1); // bigint is important\n      const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n\n      // Update variables\n      M = i;\n      c = Fp.sqr(b); // c = b^2\n      t = Fp.mul(t, c); // t = (t * b^2)\n      R = Fp.mul(R, b); // R = R*b\n    }\n    return R;\n  };\n}\n\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P  3 (mod 4)\n * 2. P  5 (mod 8)\n * 3. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // P  3 (mod 4) => n = n^((P+1)/4)\n  if (P % _4n === _3n) return sqrt3mod4;\n  // P  5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n  if (P % _8n === _5n) return sqrt5mod8;\n  // P  9 (mod 16) not implemented, see above\n  // Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint): boolean =>\n  (mod(num, modulo) & _1n) === _1n;\n\n/** Field is not always over prime: for example, Fp2 has ORDER(q)=p^m. */\nexport interface IField<T> {\n  ORDER: bigint;\n  isLE: boolean;\n  BYTES: number;\n  BITS: number;\n  MASK: bigint;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  // legendre?(num: T): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>): IField<T> {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'isSafeInteger',\n    BITS: 'isSafeInteger',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  return validateObject(field, opts);\n}\n\n// Generic field functions\n\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow<T>(Fp: IField<T>, num: T, power: bigint): T {\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (power === _0n) return Fp.ONE;\n  if (power === _1n) return num;\n  let p = Fp.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = Fp.mul(p, d);\n    d = Fp.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nexport function FpInvertBatch<T>(Fp: IField<T>, nums: T[], passZero = false): T[] {\n  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n  // Walk from first to last, multiply them by each other MOD p\n  const multipliedAcc = nums.reduce((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = acc;\n    return Fp.mul(acc, num);\n  }, Fp.ONE);\n  // Invert last element\n  const invertedAcc = Fp.inv(multipliedAcc);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = Fp.mul(acc, inverted[i]);\n    return Fp.mul(acc, num);\n  }, invertedAcc);\n  return inverted;\n}\n\n// TODO: remove\nexport function FpDiv<T>(Fp: IField<T>, lhs: T, rhs: T | bigint): T {\n  return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p)  1    if a is a square (mod p), quadratic residue\n * * (a | p)  -1   if a is not a square (mod p), quadratic non residue\n * * (a | p)  0    if a  0 (mod p)\n */\nexport function FpLegendre<T>(Fp: IField<T>, n: T): -1 | 0 | 1 {\n  // We can use 3rd argument as optional cache of this value\n  // but seems unneeded for now. The operation is very fast.\n  const p1mod2 = (Fp.ORDER - _1n) / _2n;\n  const powered = Fp.pow(n, p1mod2);\n  const yes = Fp.eql(powered, Fp.ONE);\n  const zero = Fp.eql(powered, Fp.ZERO);\n  const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n  if (!yes && !zero && !no) throw new Error('invalid Legendre symbol result');\n  return yes ? 1 : zero ? 0 : -1;\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(Fp: IField<T>, n: T): boolean {\n  const l = FpLegendre(Fp, n);\n  return l === 1;\n}\n\n// CURVE.n lengths\nexport function nLength(\n  n: bigint,\n  nBitLength?: number\n): {\n  nBitLength: number;\n  nByteLength: number;\n} {\n  // Bit size, byte size of CURVE.n\n  if (nBitLength !== undefined) anumber(nBitLength);\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(\n  ORDER: bigint,\n  bitLen?: number,\n  isLE = false,\n  redef: Partial<IField<bigint>> = {}\n): Readonly<FpField> {\n  if (ORDER <= _0n) throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n  if (BYTES > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n  let sqrtP: ReturnType<typeof FpSqrt>; // cached sqrtP\n  const f: Readonly<FpField> = Object.freeze({\n    ORDER,\n    isLE,\n    BITS,\n    BYTES,\n    MASK: bitMask(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    create: (num) => mod(num, ORDER),\n    isValid: (num) => {\n      if (typeof num !== 'bigint')\n        throw new Error('invalid field element: expected bigint, got ' + typeof num);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: (num) => num === _0n,\n    isOdd: (num) => (num & _1n) === _1n,\n    neg: (num) => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n\n    sqr: (num) => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n\n    // Same as above, but doesn't normalize\n    sqrN: (num) => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n\n    inv: (num) => invert(num, ORDER),\n    sqrt:\n      redef.sqrt ||\n      ((n) => {\n        if (!sqrtP) sqrtP = FpSqrt(ORDER);\n        return sqrtP(f, n);\n      }),\n    toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n    fromBytes: (bytes) => {\n      if (bytes.length !== BYTES)\n        throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n    },\n    // TODO: we don't need it here, move out to separate fn\n    invertBatch: (lst) => FpInvertBatch(f, lst),\n    // We can't move this out because Fp6, Fp12 implement it\n    // and it's unclear what to return in there.\n    cmov: (a, b, c) => (c ? b : a),\n  } as FpField);\n  return Object.freeze(f);\n}\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nexport function hashToPrivateScalar(\n  hash: string | Uint8Array,\n  groupOrder: bigint,\n  isLE = false\n): bigint {\n  hash = ensureBytes('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n    throw new Error(\n      'hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen\n    );\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder: bigint): number {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder: bigint): number {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024)\n    throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n  const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/util/validatePreferences.ts","import { chainConfig } from '../../op-stack/chainConfig.js'\nimport { defineChain } from '../../utils/chain/defineChain.js'\n\nconst sourceId = 11_155_111 // sepolia\n\nexport const baseSepolia = /*#__PURE__*/ defineChain({\n  ...chainConfig,\n  id: 84532,\n  network: 'base-sepolia',\n  name: 'Base Sepolia',\n  nativeCurrency: { name: 'Sepolia Ether', symbol: 'ETH', decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: ['https://sepolia.base.org'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Basescan',\n      url: 'https://sepolia.basescan.org',\n      apiUrl: 'https://api-sepolia.basescan.org/api',\n    },\n  },\n  contracts: {\n    ...chainConfig.contracts,\n    disputeGameFactory: {\n      [sourceId]: {\n        address: '0xd6E6dBf4F7EA0ac412fD8b65ED297e64BB7a06E1',\n      },\n    },\n    l2OutputOracle: {\n      [sourceId]: {\n        address: '0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254',\n      },\n    },\n    portal: {\n      [sourceId]: {\n        address: '0x49f53e41452c74589e85ca1677426ba426459e85',\n        blockCreated: 4446677,\n      },\n    },\n    l1StandardBridge: {\n      [sourceId]: {\n        address: '0xfd0Bf71F60660E2f608ed56e1659C450eB113120',\n        blockCreated: 4446677,\n      },\n    },\n    multicall3: {\n      address: '0xca11bde05977b3631167028862be2a173976ca11',\n      blockCreated: 1059647,\n    },\n  },\n  testnet: true,\n  sourceId,\n})\n\nexport const baseSepoliaPreconf = /*#__PURE__*/ defineChain({\n  ...baseSepolia,\n  experimental_preconfirmationTime: 200,\n  rpcUrls: {\n    default: {\n      http: ['https://sepolia-preconf.base.org'],\n    },\n  },\n})\n","import { SignClientTypes } from \"@walletconnect/types\";\n\nexport const SIGN_CLIENT_PROTOCOL = \"wc\";\nexport const SIGN_CLIENT_VERSION = 2;\nexport const SIGN_CLIENT_CONTEXT = \"client\";\n\nexport const SIGN_CLIENT_STORAGE_PREFIX = `${SIGN_CLIENT_PROTOCOL}@${SIGN_CLIENT_VERSION}:${SIGN_CLIENT_CONTEXT}:`;\n\nexport const SIGN_CLIENT_DEFAULT = {\n  name: SIGN_CLIENT_CONTEXT,\n  logger: \"error\",\n  controller: false,\n  relayUrl: \"wss://relay.walletconnect.org\",\n};\n\nexport const SIGN_CLIENT_EVENTS: Record<SignClientTypes.Event, SignClientTypes.Event> = {\n  session_proposal: \"session_proposal\",\n  session_update: \"session_update\",\n  session_extend: \"session_extend\",\n  session_ping: \"session_ping\",\n  session_delete: \"session_delete\",\n  session_expire: \"session_expire\",\n  session_request: \"session_request\",\n  session_request_sent: \"session_request_sent\",\n  session_event: \"session_event\",\n  proposal_expire: \"proposal_expire\",\n  session_authenticate: \"session_authenticate\",\n  session_request_expire: \"session_request_expire\",\n  session_connect: \"session_connect\",\n};\n\nexport const SIGN_CLIENT_STORAGE_OPTIONS = {\n  database: \":memory:\",\n};\n\nexport const WALLETCONNECT_DEEPLINK_CHOICE = \"WALLETCONNECT_DEEPLINK_CHOICE\";\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/createCoinbaseWalletProvider.ts","import { BaseError } from '../../errors/base.js'\n\nexport type InvalidEip712TransactionErrorType =\n  InvalidEip712TransactionError & {\n    name: 'InvalidEip712TransactionError'\n  }\nexport class InvalidEip712TransactionError extends BaseError {\n  constructor() {\n    super(\n      [\n        'Transaction is not an EIP712 transaction.',\n        '',\n        'Transaction must:',\n        '  - include `type: \"eip712\"`',\n        '  - include one of the following: `customSignature`, `paymaster`, `paymasterInput`, `gasPerPubdata`, `factoryDeps`',\n      ].join('\\n'),\n      { name: 'InvalidEip712TransactionError' },\n    )\n  }\n}\n","import { MAX_LOG_SIZE_IN_BYTES_DEFAULT } from \"./constants\";\nimport type { LoggerOptions } from \"pino\";\nimport { levels } from \"pino\";\nimport LinkedList from \"./linkedList\";\nimport { safeJsonStringify } from \"@walletconnect/safe-json\";\n\nexport default class BaseChunkLogger {\n  private logs: LinkedList;\n  private level: LoggerOptions[\"level\"];\n  private levelValue: number;\n\n  private MAX_LOG_SIZE_IN_BYTES: number;\n\n  public constructor(\n    level: LoggerOptions[\"level\"],\n    MAX_LOG_SIZE_IN_BYTES: number = MAX_LOG_SIZE_IN_BYTES_DEFAULT,\n  ) {\n    this.level = level ?? \"error\";\n    this.levelValue = levels.values[this.level];\n\n    this.MAX_LOG_SIZE_IN_BYTES = MAX_LOG_SIZE_IN_BYTES;\n    this.logs = new LinkedList(this.MAX_LOG_SIZE_IN_BYTES);\n  }\n\n  public forwardToConsole(chunk: any, level: number) {\n    if (level === levels.values.error) {\n      // eslint-disable-next-line no-console\n      console.error(chunk);\n    } else if (level === levels.values.warn) {\n      // eslint-disable-next-line no-console\n      console.warn(chunk);\n    } else if (level === levels.values.debug) {\n      // eslint-disable-next-line no-console\n      console.debug(chunk);\n    } else if (level === levels.values.trace) {\n      // eslint-disable-next-line no-console\n      console.trace(chunk);\n    } else {\n      // eslint-disable-next-line no-console\n      console.log(chunk);\n    }\n  }\n\n  public appendToLogs(chunk: any) {\n    this.logs.append(\n      safeJsonStringify({\n        timestamp: new Date().toISOString(),\n        log: chunk,\n      }),\n    );\n\n    // Based on https://github.com/pinojs/pino/blob/master/lib/constants.js\n    const level = typeof chunk === \"string\" ? JSON.parse(chunk).level : chunk.level;\n    if (level >= this.levelValue) {\n      this.forwardToConsole(chunk, level);\n    }\n  }\n\n  public getLogs() {\n    return this.logs;\n  }\n\n  public clearLogs() {\n    this.logs = new LinkedList(this.MAX_LOG_SIZE_IN_BYTES);\n  }\n\n  public getLogArray() {\n    return Array.from(this.logs);\n  }\n\n  public logsToBlob(extraMetadata: Record<string, string>) {\n    const logArray = this.getLogArray();\n    logArray.push(safeJsonStringify({ extraMetadata }));\n    const blob = new Blob(logArray, { type: \"application/json\" });\n    return blob;\n  }\n}\n","import { MAX_LOG_SIZE_IN_BYTES_DEFAULT } from \"./constants\";\nimport type { LoggerOptions } from \"pino\";\nimport { levels } from \"pino\";\nimport LinkedList from \"./linkedList\";\nimport { safeJsonStringify } from \"@walletconnect/safe-json\";\n\nexport default class BaseChunkLogger {\n  private logs: LinkedList;\n  private level: LoggerOptions[\"level\"];\n  private levelValue: number;\n\n  private MAX_LOG_SIZE_IN_BYTES: number;\n\n  public constructor(\n    level: LoggerOptions[\"level\"],\n    MAX_LOG_SIZE_IN_BYTES: number = MAX_LOG_SIZE_IN_BYTES_DEFAULT,\n  ) {\n    this.level = level ?? \"error\";\n    this.levelValue = levels.values[this.level];\n\n    this.MAX_LOG_SIZE_IN_BYTES = MAX_LOG_SIZE_IN_BYTES;\n    this.logs = new LinkedList(this.MAX_LOG_SIZE_IN_BYTES);\n  }\n\n  public forwardToConsole(chunk: any, level: number) {\n    if (level === levels.values.error) {\n      // eslint-disable-next-line no-console\n      console.error(chunk);\n    } else if (level === levels.values.warn) {\n      // eslint-disable-next-line no-console\n      console.warn(chunk);\n    } else if (level === levels.values.debug) {\n      // eslint-disable-next-line no-console\n      console.debug(chunk);\n    } else if (level === levels.values.trace) {\n      // eslint-disable-next-line no-console\n      console.trace(chunk);\n    } else {\n      // eslint-disable-next-line no-console\n      console.log(chunk);\n    }\n  }\n\n  public appendToLogs(chunk: any) {\n    this.logs.append(\n      safeJsonStringify({\n        timestamp: new Date().toISOString(),\n        log: chunk,\n      }),\n    );\n\n    // Based on https://github.com/pinojs/pino/blob/master/lib/constants.js\n    const level = typeof chunk === \"string\" ? JSON.parse(chunk).level : chunk.level;\n    if (level >= this.levelValue) {\n      this.forwardToConsole(chunk, level);\n    }\n  }\n\n  public getLogs() {\n    return this.logs;\n  }\n\n  public clearLogs() {\n    this.logs = new LinkedList(this.MAX_LOG_SIZE_IN_BYTES);\n  }\n\n  public getLogArray() {\n    return Array.from(this.logs);\n  }\n\n  public logsToBlob(extraMetadata: Record<string, string>) {\n    const logArray = this.getLogArray();\n    logArray.push(safeJsonStringify({ extraMetadata }));\n    const blob = new Blob(logArray, { type: \"application/json\" });\n    return blob;\n  }\n}\n","import { encode as base64url } from '../../runtime/base64url.js';\nimport encrypt from '../../runtime/encrypt.js';\nimport { deflate } from '../../runtime/zlib.js';\nimport generateIv from '../../lib/iv.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { JOSENotSupported, JWEInvalid } from '../../util/errors.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport const unprotected = Symbol();\nexport class FlattenedEncrypt {\n    constructor(plaintext) {\n        if (!(plaintext instanceof Uint8Array)) {\n            throw new TypeError('plaintext must be an instance of Uint8Array');\n        }\n        this._plaintext = plaintext;\n    }\n    setKeyManagementParameters(parameters) {\n        if (this._keyManagementParameters) {\n            throw new TypeError('setKeyManagementParameters can only be called once');\n        }\n        this._keyManagementParameters = parameters;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this._sharedUnprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this._sharedUnprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this._aad = aad;\n        return this;\n    }\n    setContentEncryptionKey(cek) {\n        if (this._cek) {\n            throw new TypeError('setContentEncryptionKey can only be called once');\n        }\n        this._cek = cek;\n        return this;\n    }\n    setInitializationVector(iv) {\n        if (this._iv) {\n            throw new TypeError('setInitializationVector can only be called once');\n        }\n        this._iv = iv;\n        return this;\n    }\n    async encrypt(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {\n            throw new JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');\n        }\n        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {\n            throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n            ...this._sharedUnprotectedHeader,\n        };\n        validateCrit(JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n        if (joseHeader.zip !== undefined) {\n            if (!this._protectedHeader || !this._protectedHeader.zip) {\n                throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n            }\n            if (joseHeader.zip !== 'DEF') {\n                throw new JOSENotSupported('Unsupported JWE \"zip\" (Compression Algorithm) Header Parameter value');\n            }\n        }\n        const { alg, enc } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        if (typeof enc !== 'string' || !enc) {\n            throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n        }\n        let encryptedKey;\n        if (alg === 'dir') {\n            if (this._cek) {\n                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Encryption');\n            }\n        }\n        else if (alg === 'ECDH-ES') {\n            if (this._cek) {\n                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Key Agreement');\n            }\n        }\n        let cek;\n        {\n            let parameters;\n            ({ cek, encryptedKey, parameters } = await encryptKeyManagement(alg, enc, key, this._cek, this._keyManagementParameters));\n            if (parameters) {\n                if (options && unprotected in options) {\n                    if (!this._unprotectedHeader) {\n                        this.setUnprotectedHeader(parameters);\n                    }\n                    else {\n                        this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };\n                    }\n                }\n                else {\n                    if (!this._protectedHeader) {\n                        this.setProtectedHeader(parameters);\n                    }\n                    else {\n                        this._protectedHeader = { ...this._protectedHeader, ...parameters };\n                    }\n                }\n            }\n        }\n        this._iv || (this._iv = generateIv(enc));\n        let additionalData;\n        let protectedHeader;\n        let aadMember;\n        if (this._protectedHeader) {\n            protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        if (this._aad) {\n            aadMember = base64url(this._aad);\n            additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(aadMember));\n        }\n        else {\n            additionalData = protectedHeader;\n        }\n        let ciphertext;\n        let tag;\n        if (joseHeader.zip === 'DEF') {\n            const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || deflate)(this._plaintext);\n            ({ ciphertext, tag } = await encrypt(enc, deflated, cek, this._iv, additionalData));\n        }\n        else {\n            ;\n            ({ ciphertext, tag } = await encrypt(enc, this._plaintext, cek, this._iv, additionalData));\n        }\n        const jwe = {\n            ciphertext: base64url(ciphertext),\n            iv: base64url(this._iv),\n            tag: base64url(tag),\n        };\n        if (encryptedKey) {\n            jwe.encrypted_key = base64url(encryptedKey);\n        }\n        if (aadMember) {\n            jwe.aad = aadMember;\n        }\n        if (this._protectedHeader) {\n            jwe.protected = decoder.decode(protectedHeader);\n        }\n        if (this._sharedUnprotectedHeader) {\n            jwe.unprotected = this._sharedUnprotectedHeader;\n        }\n        if (this._unprotectedHeader) {\n            jwe.header = this._unprotectedHeader;\n        }\n        return jwe;\n    }\n}\n","import { decode as base64url } from '../../runtime/base64url.js';\nimport verify from '../../runtime/verify.js';\nimport { JOSEAlgNotAllowed, JWSInvalid, JWSSignatureVerificationFailed } from '../../util/errors.js';\nimport { concat, encoder, decoder } from '../../lib/buffer_utils.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport isObject from '../../lib/is_object.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nimport validateAlgorithms from '../../lib/validate_algorithms.js';\nexport async function flattenedVerify(jws, key, options) {\n    var _a;\n    if (!isObject(jws)) {\n        throw new JWSInvalid('Flattened JWS must be an object');\n    }\n    if (jws.protected === undefined && jws.header === undefined) {\n        throw new JWSInvalid('Flattened JWS must have either of the \"protected\" or \"header\" members');\n    }\n    if (jws.protected !== undefined && typeof jws.protected !== 'string') {\n        throw new JWSInvalid('JWS Protected Header incorrect type');\n    }\n    if (jws.payload === undefined) {\n        throw new JWSInvalid('JWS Payload missing');\n    }\n    if (typeof jws.signature !== 'string') {\n        throw new JWSInvalid('JWS Signature missing or incorrect type');\n    }\n    if (jws.header !== undefined && !isObject(jws.header)) {\n        throw new JWSInvalid('JWS Unprotected Header incorrect type');\n    }\n    let parsedProt = {};\n    if (jws.protected) {\n        try {\n            const protectedHeader = base64url(jws.protected);\n            parsedProt = JSON.parse(decoder.decode(protectedHeader));\n        }\n        catch {\n            throw new JWSInvalid('JWS Protected Header is invalid');\n        }\n    }\n    if (!isDisjoint(parsedProt, jws.header)) {\n        throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jws.header,\n    };\n    const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);\n    let b64 = true;\n    if (extensions.has('b64')) {\n        b64 = parsedProt.b64;\n        if (typeof b64 !== 'boolean') {\n            throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n        }\n    }\n    const { alg } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n    const algorithms = options && validateAlgorithms('algorithms', options.algorithms);\n    if (algorithms && !algorithms.has(alg)) {\n        throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter not allowed');\n    }\n    if (b64) {\n        if (typeof jws.payload !== 'string') {\n            throw new JWSInvalid('JWS Payload must be a string');\n        }\n    }\n    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {\n        throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');\n    }\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jws);\n        resolvedKey = true;\n    }\n    checkKeyType(alg, key, 'verify');\n    const data = concat(encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);\n    let signature;\n    try {\n        signature = base64url(jws.signature);\n    }\n    catch {\n        throw new JWSInvalid('Failed to base64url decode the signature');\n    }\n    const verified = await verify(alg, key, signature, data);\n    if (!verified) {\n        throw new JWSSignatureVerificationFailed();\n    }\n    let payload;\n    if (b64) {\n        try {\n            payload = base64url(jws.payload);\n        }\n        catch {\n            throw new JWSInvalid('Failed to base64url decode the payload');\n        }\n    }\n    else if (typeof jws.payload === 'string') {\n        payload = encoder.encode(jws.payload);\n    }\n    else {\n        payload = jws.payload;\n    }\n    const result = { payload };\n    if (jws.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jws.header !== undefined) {\n        result.unprotectedHeader = jws.header;\n    }\n    if (resolvedKey) {\n        return { ...result, key };\n    }\n    return result;\n}\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/sign/walletlink/relay/connection/WalletLinkHTTP.ts","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex, SignableMessage } from '../../types/misc.js'\nimport {\n  type HashMessageErrorType,\n  hashMessage,\n} from '../../utils/signature/hashMessage.js'\n\nimport { type SignErrorType, sign } from './sign.js'\n\nexport type SignMessageParameters = {\n  /** The message to sign. */\n  message: SignableMessage\n  /** The private key to sign with. */\n  privateKey: Hex\n}\n\nexport type SignMessageReturnType = Hex\n\nexport type SignMessageErrorType =\n  | SignErrorType\n  | HashMessageErrorType\n  | ErrorType\n\n/**\n * @description Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191):\n * `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`.\n *\n * @returns The signature.\n */\nexport async function signMessage({\n  message,\n  privateKey,\n}: SignMessageParameters): Promise<SignMessageReturnType> {\n  return await sign({ hash: hashMessage(message), privateKey, to: 'hex' })\n}\n","export const contractDeployerAddress =\n  '0x0000000000000000000000000000000000008006' as const\n\nexport const contract2FactoryAddress =\n  '0x0000000000000000000000000000000000010000' as const\n\n/** The address of the L1 `ETH` token. */\nexport const legacyEthAddress =\n  '0x0000000000000000000000000000000000000000' as const\n\nexport const ethAddressInContracts =\n  '0x0000000000000000000000000000000000000001' as const\n\n/** The address of the base token. */\nexport const l2BaseTokenAddress =\n  '0x000000000000000000000000000000000000800a' as const\n\nexport const l1MessengerAddress =\n  '0x0000000000000000000000000000000000008008' as const\n\nexport const l1ToL2AliasOffset =\n  '0x1111000000000000000000000000000000001111' as const\n\nexport const l2AssetRouterAddress =\n  '0x0000000000000000000000000000000000010003' as const\n\nexport const l2NativeTokenVaultAddress =\n  '0x0000000000000000000000000000000000010004' as const\n\nexport const bootloaderFormalAddress =\n  '0x0000000000000000000000000000000000008001' as const\n\nexport const addressModulo = 2n ** 160n\n","import { KeyObject, createPublicKey } from 'crypto';\nimport { encode as base64url } from './base64url.js';\nimport Asn1SequenceDecoder from './asn1_sequence_decoder.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport getNamedCurve from './get_named_curve.js';\nimport { isCryptoKey } from './webcrypto.js';\nimport isKeyObject from './is_key_object.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nimport { jwkExport } from './flags.js';\nconst keyToJWK = (key) => {\n    let keyObject;\n    if (isCryptoKey(key)) {\n        if (!key.extractable) {\n            throw new TypeError('CryptoKey is not extractable');\n        }\n        keyObject = KeyObject.from(key);\n    }\n    else if (isKeyObject(key)) {\n        keyObject = key;\n    }\n    else if (key instanceof Uint8Array) {\n        return {\n            kty: 'oct',\n            k: base64url(key),\n        };\n    }\n    else {\n        throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));\n    }\n    if (jwkExport) {\n        if (keyObject.type !== 'secret' &&\n            !['rsa', 'ec', 'ed25519', 'x25519', 'ed448', 'x448'].includes(keyObject.asymmetricKeyType)) {\n            throw new JOSENotSupported('Unsupported key asymmetricKeyType');\n        }\n        return keyObject.export({ format: 'jwk' });\n    }\n    switch (keyObject.type) {\n        case 'secret':\n            return {\n                kty: 'oct',\n                k: base64url(keyObject.export()),\n            };\n        case 'private':\n        case 'public': {\n            switch (keyObject.asymmetricKeyType) {\n                case 'rsa': {\n                    const der = keyObject.export({ format: 'der', type: 'pkcs1' });\n                    const dec = new Asn1SequenceDecoder(der);\n                    if (keyObject.type === 'private') {\n                        dec.unsignedInteger();\n                    }\n                    const n = base64url(dec.unsignedInteger());\n                    const e = base64url(dec.unsignedInteger());\n                    let jwk;\n                    if (keyObject.type === 'private') {\n                        jwk = {\n                            d: base64url(dec.unsignedInteger()),\n                            p: base64url(dec.unsignedInteger()),\n                            q: base64url(dec.unsignedInteger()),\n                            dp: base64url(dec.unsignedInteger()),\n                            dq: base64url(dec.unsignedInteger()),\n                            qi: base64url(dec.unsignedInteger()),\n                        };\n                    }\n                    dec.end();\n                    return { kty: 'RSA', n, e, ...jwk };\n                }\n                case 'ec': {\n                    const crv = getNamedCurve(keyObject);\n                    let len;\n                    let offset;\n                    let correction;\n                    switch (crv) {\n                        case 'secp256k1':\n                            len = 64;\n                            offset = 31 + 2;\n                            correction = -1;\n                            break;\n                        case 'P-256':\n                            len = 64;\n                            offset = 34 + 2;\n                            correction = -1;\n                            break;\n                        case 'P-384':\n                            len = 96;\n                            offset = 33 + 2;\n                            correction = -3;\n                            break;\n                        case 'P-521':\n                            len = 132;\n                            offset = 33 + 2;\n                            correction = -3;\n                            break;\n                        default:\n                            throw new JOSENotSupported('Unsupported curve');\n                    }\n                    if (keyObject.type === 'public') {\n                        const der = keyObject.export({ type: 'spki', format: 'der' });\n                        return {\n                            kty: 'EC',\n                            crv,\n                            x: base64url(der.subarray(-len, -len / 2)),\n                            y: base64url(der.subarray(-len / 2)),\n                        };\n                    }\n                    const der = keyObject.export({ type: 'pkcs8', format: 'der' });\n                    if (der.length < 100) {\n                        offset += correction;\n                    }\n                    return {\n                        ...keyToJWK(createPublicKey(keyObject)),\n                        d: base64url(der.subarray(offset, offset + len / 2)),\n                    };\n                }\n                case 'ed25519':\n                case 'x25519': {\n                    const crv = getNamedCurve(keyObject);\n                    if (keyObject.type === 'public') {\n                        const der = keyObject.export({ type: 'spki', format: 'der' });\n                        return {\n                            kty: 'OKP',\n                            crv,\n                            x: base64url(der.subarray(-32)),\n                        };\n                    }\n                    const der = keyObject.export({ type: 'pkcs8', format: 'der' });\n                    return {\n                        ...keyToJWK(createPublicKey(keyObject)),\n                        d: base64url(der.subarray(-32)),\n                    };\n                }\n                case 'ed448':\n                case 'x448': {\n                    const crv = getNamedCurve(keyObject);\n                    if (keyObject.type === 'public') {\n                        const der = keyObject.export({ type: 'spki', format: 'der' });\n                        return {\n                            kty: 'OKP',\n                            crv,\n                            x: base64url(der.subarray(crv === 'Ed448' ? -57 : -56)),\n                        };\n                    }\n                    const der = keyObject.export({ type: 'pkcs8', format: 'der' });\n                    return {\n                        ...keyToJWK(createPublicKey(keyObject)),\n                        d: base64url(der.subarray(crv === 'Ed448' ? -57 : -56)),\n                    };\n                }\n                default:\n                    throw new JOSENotSupported('Unsupported key asymmetricKeyType');\n            }\n        }\n        default:\n            throw new JOSENotSupported('Unsupported key type');\n    }\n};\nexport default keyToJWK;\n","import { wrap as aesKw } from '../runtime/aeskw.js';\nimport * as ECDH from '../runtime/ecdhes.js';\nimport { encrypt as pbes2Kw } from '../runtime/pbes2kw.js';\nimport { encrypt as rsaEs } from '../runtime/rsaes.js';\nimport { encode as base64url } from '../runtime/base64url.js';\nimport generateCek, { bitLength as cekLength } from '../lib/cek.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { exportJWK } from '../key/export.js';\nimport checkKeyType from './check_key_type.js';\nimport { wrap as aesGcmKw } from './aesgcmkw.js';\nasync function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {\n    let encryptedKey;\n    let parameters;\n    let cek;\n    checkKeyType(alg, key, 'encrypt');\n    switch (alg) {\n        case 'dir': {\n            cek = key;\n            break;\n        }\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            if (!ECDH.ecdhAllowed(key)) {\n                throw new JOSENotSupported('ECDH with the provided key is not allowed or not supported by your javascript runtime');\n            }\n            const { apu, apv } = providedParameters;\n            let { epk: ephemeralKey } = providedParameters;\n            ephemeralKey || (ephemeralKey = (await ECDH.generateEpk(key)).privateKey);\n            const { x, y, crv, kty } = await exportJWK(ephemeralKey);\n            const sharedSecret = await ECDH.deriveKey(key, ephemeralKey, alg === 'ECDH-ES' ? enc : alg, alg === 'ECDH-ES' ? cekLength(enc) : parseInt(alg.slice(-5, -2), 10), apu, apv);\n            parameters = { epk: { x, crv, kty } };\n            if (kty === 'EC')\n                parameters.epk.y = y;\n            if (apu)\n                parameters.apu = base64url(apu);\n            if (apv)\n                parameters.apv = base64url(apv);\n            if (alg === 'ECDH-ES') {\n                cek = sharedSecret;\n                break;\n            }\n            cek = providedCek || generateCek(enc);\n            const kwAlg = alg.slice(-6);\n            encryptedKey = await aesKw(kwAlg, sharedSecret, cek);\n            break;\n        }\n        case 'RSA1_5':\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            cek = providedCek || generateCek(enc);\n            encryptedKey = await rsaEs(alg, key, cek);\n            break;\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW': {\n            cek = providedCek || generateCek(enc);\n            const { p2c, p2s } = providedParameters;\n            ({ encryptedKey, ...parameters } = await pbes2Kw(alg, key, cek, p2c, p2s));\n            break;\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            cek = providedCek || generateCek(enc);\n            encryptedKey = await aesKw(alg, key, cek);\n            break;\n        }\n        case 'A128GCMKW':\n        case 'A192GCMKW':\n        case 'A256GCMKW': {\n            cek = providedCek || generateCek(enc);\n            const { iv } = providedParameters;\n            ({ encryptedKey, ...parameters } = await aesGcmKw(alg, key, cek, iv));\n            break;\n        }\n        default: {\n            throw new JOSENotSupported('Invalid or unsupported \"alg\" (JWE Algorithm) header value');\n        }\n    }\n    return { cek, encryptedKey, parameters };\n}\nexport default encryptKeyManagement;\n","import { diffieHellman, generateKeyPair as generateKeyPairCb, KeyObject } from 'crypto';\nimport { promisify } from 'util';\nimport getNamedCurve from './get_named_curve.js';\nimport { encoder, concat, uint32be, lengthAndInput, concatKdf } from '../lib/buffer_utils.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport isKeyObject from './is_key_object.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nconst generateKeyPair = promisify(generateKeyPairCb);\nexport async function deriveKey(publicKee, privateKee, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {\n    let publicKey;\n    if (isCryptoKey(publicKee)) {\n        checkEncCryptoKey(publicKee, 'ECDH');\n        publicKey = KeyObject.from(publicKee);\n    }\n    else if (isKeyObject(publicKee)) {\n        publicKey = publicKee;\n    }\n    else {\n        throw new TypeError(invalidKeyInput(publicKee, ...types));\n    }\n    let privateKey;\n    if (isCryptoKey(privateKee)) {\n        checkEncCryptoKey(privateKee, 'ECDH', 'deriveBits');\n        privateKey = KeyObject.from(privateKee);\n    }\n    else if (isKeyObject(privateKee)) {\n        privateKey = privateKee;\n    }\n    else {\n        throw new TypeError(invalidKeyInput(privateKee, ...types));\n    }\n    const value = concat(lengthAndInput(encoder.encode(algorithm)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLength));\n    const sharedSecret = diffieHellman({ privateKey, publicKey });\n    return concatKdf(sharedSecret, keyLength, value);\n}\nexport async function generateEpk(kee) {\n    let key;\n    if (isCryptoKey(kee)) {\n        key = KeyObject.from(kee);\n    }\n    else if (isKeyObject(kee)) {\n        key = kee;\n    }\n    else {\n        throw new TypeError(invalidKeyInput(kee, ...types));\n    }\n    switch (key.asymmetricKeyType) {\n        case 'x25519':\n            return generateKeyPair('x25519');\n        case 'x448': {\n            return generateKeyPair('x448');\n        }\n        case 'ec': {\n            const namedCurve = getNamedCurve(key);\n            return generateKeyPair('ec', { namedCurve });\n        }\n        default:\n            throw new JOSENotSupported('Invalid or unsupported EPK');\n    }\n}\nexport const ecdhAllowed = (key) => ['P-256', 'P-384', 'P-521', 'X25519', 'X448'].includes(getNamedCurve(key));\n","import type { Abi } from 'abitype'\n\nimport { zeroHash } from '../../../constants/bytes.js'\nimport {\n  AbiConstructorNotFoundError,\n  AbiConstructorParamsNotFoundError,\n} from '../../../errors/abi.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { ContractConstructorArgs } from '../../../types/contract.js'\nimport type { Hash, Hex } from '../../../types/misc.js'\nimport { encodeAbiParameters } from '../../../utils/abi/encodeAbiParameters.js'\nimport type {\n  EncodeDeployDataParameters as EncodeDeployDataParameters_,\n  EncodeDeployDataReturnType,\n} from '../../../utils/abi/encodeDeployData.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../../utils/abi/encodeFunctionData.js'\nimport { toHex } from '../../../utils/encoding/toHex.js'\nimport { contractDeployerAbi } from '../../constants/abis.js'\nimport { accountAbstractionVersion1 } from '../../constants/contract.js'\nimport type { ContractDeploymentType } from '../../types/contract.js'\nimport { type HashBytecodeErrorType, hashBytecode } from '../hashBytecode.js'\n\nconst docsPath = '/docs/contract/encodeDeployData'\n\n/** @internal */\nexport type EncodeDeployDataParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  hasConstructor = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [Extract<abi[number], { type: 'constructor' }>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractConstructorArgs<abi>,\n> = EncodeDeployDataParameters_<abi, hasConstructor, allArgs> & {\n  deploymentType?: ContractDeploymentType | undefined\n  salt?: Hash | undefined\n}\n\nexport type EncodeDeployDataErrorType =\n  | EncodeFunctionDataErrorType\n  | HashBytecodeErrorType\n  | ErrorType\n\nexport function encodeDeployData<const abi extends Abi | readonly unknown[]>(\n  parameters: EncodeDeployDataParameters<abi>,\n): EncodeDeployDataReturnType {\n  const { abi, args, bytecode, deploymentType, salt } =\n    parameters as EncodeDeployDataParameters\n\n  if (!args || args.length === 0) {\n    const { functionName, argsContractDeployer } = getDeploymentDetails(\n      deploymentType,\n      salt ?? zeroHash,\n      toHex(hashBytecode(bytecode)),\n      '0x',\n    )\n    return encodeFunctionData({\n      abi: contractDeployerAbi,\n      functionName,\n      args: argsContractDeployer,\n    })\n  }\n\n  const description = abi.find((x) => 'type' in x && x.type === 'constructor')\n  if (!description) throw new AbiConstructorNotFoundError({ docsPath })\n  if (!('inputs' in description))\n    throw new AbiConstructorParamsNotFoundError({ docsPath })\n  if (!description.inputs || description.inputs.length === 0)\n    throw new AbiConstructorParamsNotFoundError({ docsPath })\n\n  const data = encodeAbiParameters(description.inputs, args)\n  const { functionName, argsContractDeployer } = getDeploymentDetails(\n    deploymentType,\n    salt ?? zeroHash,\n    toHex(hashBytecode(bytecode)),\n    data,\n  )\n\n  return encodeFunctionData({\n    abi: contractDeployerAbi,\n    functionName,\n    args: argsContractDeployer,\n  })\n}\n\nfunction getDeploymentDetails(\n  deploymentType: ContractDeploymentType,\n  salt: Hash,\n  bytecodeHash: Hex,\n  data: Hex,\n): {\n  functionName: string\n  argsContractDeployer: readonly unknown[]\n} {\n  const contractDeploymentArgs = [salt, bytecodeHash, data]\n\n  const deploymentOptions = {\n    create: {\n      functionName: 'create',\n      argsContractDeployer: contractDeploymentArgs,\n    },\n    create2: {\n      functionName: 'create2',\n      argsContractDeployer: contractDeploymentArgs,\n    },\n    createAccount: {\n      functionName: 'createAccount',\n      argsContractDeployer: [\n        ...contractDeploymentArgs,\n        accountAbstractionVersion1,\n      ],\n    },\n    create2Account: {\n      functionName: 'create2Account',\n      argsContractDeployer: [\n        ...contractDeploymentArgs,\n        accountAbstractionVersion1,\n      ],\n    },\n  }\n\n  const deploymentKey = deploymentType || 'create'\n  return deploymentOptions[deploymentKey]\n}\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/core/type/util.ts","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/sign/walletlink/WalletLinkSigner.ts","export const HISTORY_EVENTS = {\n  created: \"history_created\",\n  updated: \"history_updated\",\n  deleted: \"history_deleted\",\n  sync: \"history_sync\",\n};\n\nexport const HISTORY_CONTEXT = \"history\";\n\nexport const HISTORY_STORAGE_VERSION = \"0.3\";\n","import { unwrap as aesKw } from '../runtime/aeskw.js';\nimport * as ECDH from '../runtime/ecdhes.js';\nimport { decrypt as pbes2Kw } from '../runtime/pbes2kw.js';\nimport { decrypt as rsaEs } from '../runtime/rsaes.js';\nimport { decode as base64url } from '../runtime/base64url.js';\nimport { JOSENotSupported, JWEInvalid } from '../util/errors.js';\nimport { bitLength as cekLength } from '../lib/cek.js';\nimport { importJWK } from '../key/import.js';\nimport checkKeyType from './check_key_type.js';\nimport isObject from './is_object.js';\nimport { unwrap as aesGcmKw } from './aesgcmkw.js';\nasync function decryptKeyManagement(alg, key, encryptedKey, joseHeader, options) {\n    checkKeyType(alg, key, 'decrypt');\n    switch (alg) {\n        case 'dir': {\n            if (encryptedKey !== undefined)\n                throw new JWEInvalid('Encountered unexpected JWE Encrypted Key');\n            return key;\n        }\n        case 'ECDH-ES':\n            if (encryptedKey !== undefined)\n                throw new JWEInvalid('Encountered unexpected JWE Encrypted Key');\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            if (!isObject(joseHeader.epk))\n                throw new JWEInvalid(`JOSE Header \"epk\" (Ephemeral Public Key) missing or invalid`);\n            if (!ECDH.ecdhAllowed(key))\n                throw new JOSENotSupported('ECDH with the provided key is not allowed or not supported by your javascript runtime');\n            const epk = await importJWK(joseHeader.epk, alg);\n            let partyUInfo;\n            let partyVInfo;\n            if (joseHeader.apu !== undefined) {\n                if (typeof joseHeader.apu !== 'string')\n                    throw new JWEInvalid(`JOSE Header \"apu\" (Agreement PartyUInfo) invalid`);\n                try {\n                    partyUInfo = base64url(joseHeader.apu);\n                }\n                catch {\n                    throw new JWEInvalid('Failed to base64url decode the apu');\n                }\n            }\n            if (joseHeader.apv !== undefined) {\n                if (typeof joseHeader.apv !== 'string')\n                    throw new JWEInvalid(`JOSE Header \"apv\" (Agreement PartyVInfo) invalid`);\n                try {\n                    partyVInfo = base64url(joseHeader.apv);\n                }\n                catch {\n                    throw new JWEInvalid('Failed to base64url decode the apv');\n                }\n            }\n            const sharedSecret = await ECDH.deriveKey(epk, key, alg === 'ECDH-ES' ? joseHeader.enc : alg, alg === 'ECDH-ES' ? cekLength(joseHeader.enc) : parseInt(alg.slice(-5, -2), 10), partyUInfo, partyVInfo);\n            if (alg === 'ECDH-ES')\n                return sharedSecret;\n            if (encryptedKey === undefined)\n                throw new JWEInvalid('JWE Encrypted Key missing');\n            return aesKw(alg.slice(-6), sharedSecret, encryptedKey);\n        }\n        case 'RSA1_5':\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            if (encryptedKey === undefined)\n                throw new JWEInvalid('JWE Encrypted Key missing');\n            return rsaEs(alg, key, encryptedKey);\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW': {\n            if (encryptedKey === undefined)\n                throw new JWEInvalid('JWE Encrypted Key missing');\n            if (typeof joseHeader.p2c !== 'number')\n                throw new JWEInvalid(`JOSE Header \"p2c\" (PBES2 Count) missing or invalid`);\n            const p2cLimit = (options === null || options === void 0 ? void 0 : options.maxPBES2Count) || 10000;\n            if (joseHeader.p2c > p2cLimit)\n                throw new JWEInvalid(`JOSE Header \"p2c\" (PBES2 Count) out is of acceptable bounds`);\n            if (typeof joseHeader.p2s !== 'string')\n                throw new JWEInvalid(`JOSE Header \"p2s\" (PBES2 Salt) missing or invalid`);\n            let p2s;\n            try {\n                p2s = base64url(joseHeader.p2s);\n            }\n            catch {\n                throw new JWEInvalid('Failed to base64url decode the p2s');\n            }\n            return pbes2Kw(alg, key, encryptedKey, joseHeader.p2c, p2s);\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            if (encryptedKey === undefined)\n                throw new JWEInvalid('JWE Encrypted Key missing');\n            return aesKw(alg, key, encryptedKey);\n        }\n        case 'A128GCMKW':\n        case 'A192GCMKW':\n        case 'A256GCMKW': {\n            if (encryptedKey === undefined)\n                throw new JWEInvalid('JWE Encrypted Key missing');\n            if (typeof joseHeader.iv !== 'string')\n                throw new JWEInvalid(`JOSE Header \"iv\" (Initialization Vector) missing or invalid`);\n            if (typeof joseHeader.tag !== 'string')\n                throw new JWEInvalid(`JOSE Header \"tag\" (Authentication Tag) missing or invalid`);\n            let iv;\n            try {\n                iv = base64url(joseHeader.iv);\n            }\n            catch {\n                throw new JWEInvalid('Failed to base64url decode the iv');\n            }\n            let tag;\n            try {\n                tag = base64url(joseHeader.tag);\n            }\n            catch {\n                throw new JWEInvalid('Failed to base64url decode the tag');\n            }\n            return aesGcmKw(alg, key, encryptedKey, iv, tag);\n        }\n        default: {\n            throw new JOSENotSupported('Invalid or unsupported \"alg\" (JWE Algorithm) header value');\n        }\n    }\n}\nexport default decryptKeyManagement;\n","import {\n  getUsdcChainConfigForChain,\n  usdcABI\n} from \"./chunk-K4TZLEOT.mjs\";\nimport {\n  __export,\n  config\n} from \"./chunk-EMSAO3AI.mjs\";\n\n// src/types/shared/money.ts\nimport { z } from \"zod\";\nvar moneySchema = z.union([z.string().transform((x) => x.replace(/[^0-9.-]+/g, \"\")), z.number()]).pipe(z.coerce.number().min(1e-4).max(999999999));\n\n// src/types/shared/network.ts\nimport { z as z2 } from \"zod\";\nvar NetworkSchema = z2.enum([\n  \"abstract\",\n  \"abstract-testnet\",\n  \"base-sepolia\",\n  \"base\",\n  \"avalanche-fuji\",\n  \"avalanche\",\n  \"iotex\",\n  \"solana-devnet\",\n  \"solana\",\n  \"sei\",\n  \"sei-testnet\",\n  \"polygon\",\n  \"polygon-amoy\",\n  \"peaq\",\n  \"story\",\n  \"educhain\",\n  \"skale-base-sepolia\"\n]);\nvar SupportedEVMNetworks = [\n  \"abstract\",\n  \"abstract-testnet\",\n  \"base-sepolia\",\n  \"base\",\n  \"avalanche-fuji\",\n  \"avalanche\",\n  \"iotex\",\n  \"sei\",\n  \"sei-testnet\",\n  \"polygon\",\n  \"polygon-amoy\",\n  \"peaq\",\n  \"story\",\n  \"educhain\",\n  \"skale-base-sepolia\"\n];\nvar EvmNetworkToChainId = /* @__PURE__ */ new Map([\n  [\"abstract\", 2741],\n  [\"abstract-testnet\", 11124],\n  [\"base-sepolia\", 84532],\n  [\"base\", 8453],\n  [\"avalanche-fuji\", 43113],\n  [\"avalanche\", 43114],\n  [\"iotex\", 4689],\n  [\"sei\", 1329],\n  [\"sei-testnet\", 1328],\n  [\"polygon\", 137],\n  [\"polygon-amoy\", 80002],\n  [\"peaq\", 3338],\n  [\"story\", 1514],\n  [\"educhain\", 41923],\n  [\"skale-base-sepolia\", 324705682]\n]);\nvar SupportedSVMNetworks = [\"solana-devnet\", \"solana\"];\nvar SvmNetworkToChainId = /* @__PURE__ */ new Map([\n  [\"solana-devnet\", 103],\n  [\"solana\", 101]\n]);\nvar ChainIdToNetwork = Object.fromEntries(\n  [...SupportedEVMNetworks, ...SupportedSVMNetworks].map((network) => [\n    EvmNetworkToChainId.get(network),\n    network\n  ])\n);\n\n// src/types/shared/evm/wallet.ts\nimport { createPublicClient, createWalletClient, http, publicActions } from \"viem\";\nimport {\n  baseSepolia,\n  avalancheFuji,\n  base,\n  sei,\n  seiTestnet,\n  polygon,\n  polygonAmoy,\n  peaq,\n  avalanche,\n  iotexTestnet,\n  iotex,\n  abstract,\n  abstractTestnet,\n  story,\n  eduChain\n} from \"viem/chains\";\n\n// src/types/shared/custom-chains/eip155-324705682.ts\nvar skaleBaseSepolia = {\n  id: 324705682,\n  name: \"SKALE Base Sepolia\",\n  nativeCurrency: {\n    name: \"Credits\",\n    symbol: \"CREDITS\",\n    decimals: 18\n  },\n  rpcUrls: {\n    default: {\n      http: [\"https://base-sepolia-testnet.skalenodes.com/v1/jubilant-horrible-ancha\"]\n    }\n  },\n  blockExplorers: {\n    default: {\n      name: \"Blockscout\",\n      url: \"https://base-sepolia-testnet-explorer.skalenodes.com\",\n      apiUrl: \"https://base-sepolia-testnet-explorer.skalenodes.com/api\"\n    }\n  }\n};\n\n// src/types/shared/evm/wallet.ts\nimport { privateKeyToAccount } from \"viem/accounts\";\nimport { eip712WalletActions } from \"viem/zksync\";\nfunction createConnectedClient(network) {\n  const chain = getChainFromNetwork(network);\n  return createPublicClient({\n    chain,\n    transport: http()\n  }).extend(publicActions);\n}\nfunction createClientSepolia() {\n  return createConnectedClient(\"base-sepolia\");\n}\nfunction createClientAvalancheFuji() {\n  return createConnectedClient(\"avalanche-fuji\");\n}\nfunction createSigner(network, privateKey) {\n  const chain = getChainFromNetwork(network);\n  const walletClient = createWalletClient({\n    chain,\n    transport: http(),\n    account: privateKeyToAccount(privateKey)\n  });\n  if (isZkStackChain(chain)) {\n    return walletClient.extend(publicActions).extend(eip712WalletActions());\n  }\n  return walletClient.extend(publicActions);\n}\nfunction createSignerSepolia(privateKey) {\n  return createSigner(\"base-sepolia\", privateKey);\n}\nfunction createSignerAvalancheFuji(privateKey) {\n  return createSigner(\"avalanche-fuji\", privateKey);\n}\nfunction isSignerWallet(wallet) {\n  return typeof wallet === \"object\" && wallet !== null && \"chain\" in wallet && \"transport\" in wallet;\n}\nfunction isAccount(wallet) {\n  const w = wallet;\n  return typeof wallet === \"object\" && wallet !== null && typeof w.address === \"string\" && typeof w.type === \"string\" && // Check for essential signing capabilities\n  typeof w.sign === \"function\" && typeof w.signMessage === \"function\" && typeof w.signTypedData === \"function\" && // Check for transaction signing (required by LocalAccount)\n  typeof w.signTransaction === \"function\";\n}\nfunction getChainFromNetwork(network) {\n  if (!network) {\n    throw new Error(\"NETWORK environment variable is not set\");\n  }\n  switch (network) {\n    case \"abstract\":\n      return abstract;\n    case \"abstract-testnet\":\n      return abstractTestnet;\n    case \"base\":\n      return base;\n    case \"base-sepolia\":\n      return baseSepolia;\n    case \"avalanche\":\n      return avalanche;\n    case \"avalanche-fuji\":\n      return avalancheFuji;\n    case \"sei\":\n      return sei;\n    case \"sei-testnet\":\n      return seiTestnet;\n    case \"polygon\":\n      return polygon;\n    case \"polygon-amoy\":\n      return polygonAmoy;\n    case \"peaq\":\n      return peaq;\n    case \"story\":\n      return story;\n    case \"educhain\":\n      return eduChain;\n    case \"iotex\":\n      return iotex;\n    case \"iotex-testnet\":\n      return iotexTestnet;\n    case \"skale-base-sepolia\":\n      return skaleBaseSepolia;\n    default:\n      throw new Error(`Unsupported network: ${network}`);\n  }\n}\nvar ZKSTACK_CHAIN_IDS = /* @__PURE__ */ new Set([\n  2741,\n  // Abstract Mainnet\n  11124\n  // Abstract Sepolia Testnet\n]);\nfunction isZkStackChain(chain) {\n  return ZKSTACK_CHAIN_IDS.has(chain.id);\n}\n\n// src/shared/svm/wallet.ts\nimport {\n  createKeyPairSignerFromBytes,\n  createKeyPairSignerFromPrivateKeyBytes,\n  isTransactionSigner\n} from \"@solana/kit\";\nimport { base58 } from \"@scure/base\";\n\n// src/shared/svm/rpc.ts\nimport {\n  createSolanaRpc,\n  devnet,\n  mainnet,\n  createSolanaRpcSubscriptions\n} from \"@solana/kit\";\nvar DEVNET_RPC_URL = \"https://api.devnet.solana.com\";\nvar MAINNET_RPC_URL = \"https://api.mainnet-beta.solana.com\";\nvar DEVNET_WS_URL = \"wss://api.devnet.solana.com\";\nvar MAINNET_WS_URL = \"wss://api.mainnet-beta.solana.com\";\nfunction createDevnetRpcClient(url) {\n  return createSolanaRpc(\n    url ? devnet(url) : devnet(DEVNET_RPC_URL)\n  );\n}\nfunction createMainnetRpcClient(url) {\n  return createSolanaRpc(\n    url ? mainnet(url) : mainnet(MAINNET_RPC_URL)\n  );\n}\nfunction getRpcClient(network, url) {\n  if (network === \"solana-devnet\") {\n    return createDevnetRpcClient(url);\n  } else if (network === \"solana\") {\n    return createMainnetRpcClient(url);\n  } else {\n    throw new Error(\"Invalid network\");\n  }\n}\nfunction getRpcSubscriptions(network, url) {\n  if (network === \"solana-devnet\") {\n    return createSolanaRpcSubscriptions(devnet(url ? httpToWs(url) : DEVNET_WS_URL));\n  } else if (network === \"solana\") {\n    return createSolanaRpcSubscriptions(mainnet(url ? httpToWs(url) : MAINNET_WS_URL));\n  } else {\n    throw new Error(\"Invalid network\");\n  }\n}\nfunction httpToWs(url) {\n  if (url.startsWith(\"http\")) {\n    return url.replace(\"http\", \"ws\");\n  }\n  return url;\n}\n\n// src/shared/svm/wallet.ts\nfunction createSvmConnectedClient(network) {\n  if (!SupportedSVMNetworks.find((n) => n === network)) {\n    throw new Error(`Unsupported SVM network: ${network}`);\n  }\n  return getRpcClient(network);\n}\nasync function createSignerFromBase58(privateKey) {\n  const bytes = base58.decode(privateKey);\n  if (bytes.length === 64) {\n    return await createKeyPairSignerFromBytes(bytes);\n  }\n  if (bytes.length === 32) {\n    return await createKeyPairSignerFromPrivateKeyBytes(bytes);\n  }\n  throw new Error(`Unexpected key length: ${bytes.length}. Expected 32 or 64 bytes.`);\n}\nfunction isSignerWallet2(wallet) {\n  return typeof wallet === \"object\" && wallet !== null && isTransactionSigner(wallet);\n}\n\n// src/types/shared/wallet.ts\nfunction createConnectedClient2(network) {\n  if (SupportedEVMNetworks.find((n) => n === network)) {\n    return createConnectedClient(network);\n  }\n  if (SupportedSVMNetworks.find((n) => n === network)) {\n    return createSvmConnectedClient(network);\n  }\n  throw new Error(`Unsupported network: ${network}`);\n}\nfunction createSigner2(network, privateKey) {\n  if (SupportedEVMNetworks.find((n) => n === network)) {\n    return Promise.resolve(createSigner(network, privateKey));\n  }\n  if (SupportedSVMNetworks.find((n) => n === network)) {\n    return createSignerFromBase58(privateKey);\n  }\n  throw new Error(`Unsupported network: ${network}`);\n}\nfunction isEvmSignerWallet(wallet) {\n  return isSignerWallet(wallet) || isAccount(wallet);\n}\nfunction isSvmSignerWallet(wallet) {\n  return isSignerWallet2(wallet);\n}\nfunction isMultiNetworkSigner(wallet) {\n  return \"evm\" in wallet && \"svm\" in wallet;\n}\n\n// src/types/shared/evm/index.ts\nvar evm_exports = {};\n__export(evm_exports, {\n  authorizationPrimaryType: () => authorizationPrimaryType,\n  authorizationTypes: () => authorizationTypes,\n  config: () => config,\n  createClientAvalancheFuji: () => createClientAvalancheFuji,\n  createClientSepolia: () => createClientSepolia,\n  createConnectedClient: () => createConnectedClient,\n  createSigner: () => createSigner,\n  createSignerAvalancheFuji: () => createSignerAvalancheFuji,\n  createSignerSepolia: () => createSignerSepolia,\n  getChainFromNetwork: () => getChainFromNetwork,\n  isAccount: () => isAccount,\n  isSignerWallet: () => isSignerWallet,\n  isZkStackChain: () => isZkStackChain,\n  usdcABI: () => usdcABI\n});\n\n// src/types/shared/evm/eip3009.ts\nvar authorizationTypes = {\n  TransferWithAuthorization: [\n    { name: \"from\", type: \"address\" },\n    { name: \"to\", type: \"address\" },\n    { name: \"value\", type: \"uint256\" },\n    { name: \"validAfter\", type: \"uint256\" },\n    { name: \"validBefore\", type: \"uint256\" },\n    { name: \"nonce\", type: \"bytes32\" }\n  ]\n};\nvar authorizationPrimaryType = \"TransferWithAuthorization\";\n\n// src/types/shared/svm/index.ts\nvar svm_exports = {};\n__export(svm_exports, {\n  SvmAddressRegex: () => SvmAddressRegex\n});\n\n// src/types/shared/svm/regex.ts\nvar SvmAddressRegex = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/;\n\n// src/types/verify/x402Specs.ts\nimport { z as z3 } from \"zod\";\n\n// src/shared/base64.ts\nvar Base64EncodedRegex = /^[A-Za-z0-9+/]*={0,2}$/;\nfunction safeBase64Encode(data) {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    return globalThis.btoa(data);\n  }\n  return Buffer.from(data).toString(\"base64\");\n}\nfunction safeBase64Decode(data) {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.atob === \"function\") {\n    return globalThis.atob(data);\n  }\n  return Buffer.from(data, \"base64\").toString(\"utf-8\");\n}\n\n// src/types/verify/x402Specs.ts\nvar EvmMaxAtomicUnits = 18;\nvar EvmAddressRegex = /^0x[0-9a-fA-F]{40}$/;\nvar MixedAddressRegex = /^0x[a-fA-F0-9]{40}|[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$/;\nvar HexEncoded64ByteRegex = /^0x[0-9a-fA-F]{64}$/;\nvar EvmSignatureRegex = /^0x[0-9a-fA-F]+$/;\nvar schemes = [\"exact\"];\nvar x402Versions = [1];\nvar ErrorReasons = [\n  \"insufficient_funds\",\n  \"invalid_exact_evm_payload_authorization_valid_after\",\n  \"invalid_exact_evm_payload_authorization_valid_before\",\n  \"invalid_exact_evm_payload_authorization_value\",\n  \"invalid_exact_evm_payload_signature\",\n  \"invalid_exact_evm_payload_undeployed_smart_wallet\",\n  \"invalid_exact_evm_payload_recipient_mismatch\",\n  \"invalid_exact_svm_payload_transaction\",\n  \"invalid_exact_svm_payload_transaction_amount_mismatch\",\n  \"invalid_exact_svm_payload_transaction_create_ata_instruction\",\n  \"invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_payee\",\n  \"invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_asset\",\n  \"invalid_exact_svm_payload_transaction_instructions\",\n  \"invalid_exact_svm_payload_transaction_instructions_length\",\n  \"invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction\",\n  \"invalid_exact_svm_payload_transaction_instructions_compute_price_instruction\",\n  \"invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high\",\n  \"invalid_exact_svm_payload_transaction_instruction_not_spl_token_transfer_checked\",\n  \"invalid_exact_svm_payload_transaction_instruction_not_token_2022_transfer_checked\",\n  \"invalid_exact_svm_payload_transaction_fee_payer_included_in_instruction_accounts\",\n  \"invalid_exact_svm_payload_transaction_fee_payer_transferring_funds\",\n  \"invalid_exact_svm_payload_transaction_not_a_transfer_instruction\",\n  \"invalid_exact_svm_payload_transaction_receiver_ata_not_found\",\n  \"invalid_exact_svm_payload_transaction_sender_ata_not_found\",\n  \"invalid_exact_svm_payload_transaction_simulation_failed\",\n  \"invalid_exact_svm_payload_transaction_transfer_to_incorrect_ata\",\n  \"invalid_network\",\n  \"invalid_payload\",\n  \"invalid_payment_requirements\",\n  \"invalid_scheme\",\n  \"invalid_payment\",\n  \"payment_expired\",\n  \"unsupported_scheme\",\n  \"invalid_x402_version\",\n  \"invalid_transaction_state\",\n  \"invalid_x402_version\",\n  \"settle_exact_svm_block_height_exceeded\",\n  \"settle_exact_svm_transaction_confirmation_timed_out\",\n  \"unsupported_scheme\",\n  \"unexpected_settle_error\",\n  \"unexpected_verify_error\"\n];\nvar isInteger = (value) => Number.isInteger(Number(value)) && Number(value) >= 0;\nvar hasMaxLength = (maxLength) => (value) => value.length <= maxLength;\nvar EvmOrSvmAddress = z3.string().regex(EvmAddressRegex).or(z3.string().regex(SvmAddressRegex));\nvar mixedAddressOrSvmAddress = z3.string().regex(MixedAddressRegex).or(z3.string().regex(SvmAddressRegex));\nvar PaymentRequirementsSchema = z3.object({\n  scheme: z3.enum(schemes),\n  network: NetworkSchema,\n  maxAmountRequired: z3.string().refine(isInteger),\n  resource: z3.string().url(),\n  description: z3.string(),\n  mimeType: z3.string(),\n  outputSchema: z3.record(z3.any()).optional(),\n  payTo: EvmOrSvmAddress,\n  maxTimeoutSeconds: z3.number().int(),\n  asset: mixedAddressOrSvmAddress,\n  extra: z3.record(z3.any()).optional()\n});\nvar ExactEvmPayloadAuthorizationSchema = z3.object({\n  from: z3.string().regex(EvmAddressRegex),\n  to: z3.string().regex(EvmAddressRegex),\n  value: z3.string().refine(isInteger).refine(hasMaxLength(EvmMaxAtomicUnits)),\n  validAfter: z3.string().refine(isInteger),\n  validBefore: z3.string().refine(isInteger),\n  nonce: z3.string().regex(HexEncoded64ByteRegex)\n});\nvar ExactEvmPayloadSchema = z3.object({\n  signature: z3.string().regex(EvmSignatureRegex),\n  authorization: ExactEvmPayloadAuthorizationSchema\n});\nvar ExactSvmPayloadSchema = z3.object({\n  transaction: z3.string().regex(Base64EncodedRegex)\n});\nvar PaymentPayloadSchema = z3.object({\n  x402Version: z3.number().refine((val) => x402Versions.includes(val)),\n  scheme: z3.enum(schemes),\n  network: NetworkSchema,\n  payload: z3.union([ExactEvmPayloadSchema, ExactSvmPayloadSchema])\n});\nvar x402ResponseSchema = z3.object({\n  x402Version: z3.number().refine((val) => x402Versions.includes(val)),\n  error: z3.enum(ErrorReasons).optional(),\n  accepts: z3.array(PaymentRequirementsSchema).optional(),\n  payer: z3.string().regex(MixedAddressRegex).optional()\n});\nvar HTTPVerbsSchema = z3.enum([\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\", \"HEAD\"]);\nvar HTTPRequestStructureSchema = z3.object({\n  type: z3.literal(\"http\"),\n  method: HTTPVerbsSchema,\n  queryParams: z3.record(z3.string(), z3.string()).optional(),\n  bodyType: z3.enum([\"json\", \"form-data\", \"multipart-form-data\", \"text\", \"binary\"]).optional(),\n  bodyFields: z3.record(z3.string(), z3.any()).optional(),\n  headerFields: z3.record(z3.string(), z3.any()).optional()\n});\nvar RequestStructureSchema = z3.discriminatedUnion(\"type\", [\n  HTTPRequestStructureSchema\n  // MCPRequestStructureSchema,\n  // OpenAPIRequestStructureSchema,\n]);\nvar DiscoveredResourceSchema = z3.object({\n  resource: z3.string(),\n  type: z3.enum([\"http\"]),\n  x402Version: z3.number().refine((val) => x402Versions.includes(val)),\n  accepts: z3.array(PaymentRequirementsSchema),\n  lastUpdated: z3.date(),\n  metadata: z3.record(z3.any()).optional()\n});\nvar SettleRequestSchema = z3.object({\n  paymentPayload: PaymentPayloadSchema,\n  paymentRequirements: PaymentRequirementsSchema\n});\nvar VerifyRequestSchema = z3.object({\n  paymentPayload: PaymentPayloadSchema,\n  paymentRequirements: PaymentRequirementsSchema\n});\nvar VerifyResponseSchema = z3.object({\n  isValid: z3.boolean(),\n  invalidReason: z3.enum(ErrorReasons).optional(),\n  payer: EvmOrSvmAddress.optional()\n});\nvar SettleResponseSchema = z3.object({\n  success: z3.boolean(),\n  errorReason: z3.enum(ErrorReasons).optional(),\n  payer: EvmOrSvmAddress.optional(),\n  transaction: z3.string().regex(MixedAddressRegex),\n  network: NetworkSchema\n});\nvar ListDiscoveryResourcesRequestSchema = z3.object({\n  type: z3.string().optional(),\n  limit: z3.number().optional(),\n  offset: z3.number().optional()\n});\nvar ListDiscoveryResourcesResponseSchema = z3.object({\n  x402Version: z3.number().refine((val) => x402Versions.includes(val)),\n  items: z3.array(DiscoveredResourceSchema),\n  pagination: z3.object({\n    limit: z3.number(),\n    offset: z3.number(),\n    total: z3.number()\n  })\n});\nvar SupportedPaymentKindSchema = z3.object({\n  x402Version: z3.number().refine((val) => x402Versions.includes(val)),\n  scheme: z3.enum(schemes),\n  network: NetworkSchema,\n  extra: z3.record(z3.any()).optional()\n});\nvar SupportedPaymentKindsResponseSchema = z3.object({\n  kinds: z3.array(SupportedPaymentKindSchema)\n});\n\n// src/types/verify/facilitator.ts\nimport { z as z4 } from \"zod\";\n\n// src/shared/json.ts\nfunction toJsonSafe(data) {\n  if (typeof data !== \"object\") {\n    throw new Error(\"Data is not an object\");\n  }\n  function convert(value) {\n    if (value !== null && typeof value === \"object\" && !Array.isArray(value)) {\n      return Object.fromEntries(Object.entries(value).map(([key, val]) => [key, convert(val)]));\n    }\n    if (Array.isArray(value)) {\n      return value.map(convert);\n    }\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    return value;\n  }\n  return convert(data);\n}\n\n// src/shared/network.ts\nfunction getNetworkId(network) {\n  if (EvmNetworkToChainId.has(network)) {\n    return EvmNetworkToChainId.get(network);\n  }\n  if (SvmNetworkToChainId.has(network)) {\n    return SvmNetworkToChainId.get(network);\n  }\n  throw new Error(`Unsupported network: ${network}`);\n}\n\n// src/shared/middleware.ts\nfunction computeRoutePatterns(routes) {\n  const normalizedRoutes = Object.fromEntries(\n    Object.entries(routes).map(([pattern, value]) => [\n      pattern,\n      typeof value === \"string\" || typeof value === \"number\" ? { price: value, network: \"base-sepolia\" } : value\n    ])\n  );\n  return Object.entries(normalizedRoutes).map(([pattern, routeConfig]) => {\n    const [verb, path] = pattern.includes(\" \") ? pattern.split(/\\s+/) : [\"*\", pattern];\n    if (!path) {\n      throw new Error(`Invalid route pattern: ${pattern}`);\n    }\n    return {\n      verb: verb.toUpperCase(),\n      pattern: new RegExp(\n        `^${path.replace(/[$()+.?^{|}]/g, \"\\\\$&\").replace(/\\*/g, \".*?\").replace(/\\[([^\\]]+)\\]/g, \"[^/]+\").replace(/\\//g, \"\\\\/\")}$`,\n        \"i\"\n      ),\n      config: routeConfig\n    };\n  });\n}\nfunction findMatchingRoute(routePatterns, path, method) {\n  let normalizedPath;\n  try {\n    const pathWithoutQuery = path.split(/[?#]/)[0];\n    const decodedPath = decodeURIComponent(pathWithoutQuery);\n    normalizedPath = decodedPath.replace(/\\\\/g, \"/\").replace(/\\/+/g, \"/\").replace(/(.+?)\\/+$/, \"$1\");\n  } catch {\n    return void 0;\n  }\n  const matchingRoutes = routePatterns.filter(({ pattern, verb }) => {\n    const matchesPath = pattern.test(normalizedPath);\n    const upperMethod = method.toUpperCase();\n    const matchesVerb = verb === \"*\" || upperMethod === verb;\n    const result = matchesPath && matchesVerb;\n    return result;\n  });\n  if (matchingRoutes.length === 0) {\n    return void 0;\n  }\n  const matchingRoute = matchingRoutes.reduce(\n    (a, b) => b.pattern.source.length > a.pattern.source.length ? b : a\n  );\n  return matchingRoute;\n}\nfunction getDefaultAsset(network) {\n  const chainId = getNetworkId(network);\n  const usdc = getUsdcChainConfigForChain(chainId);\n  if (!usdc) {\n    throw new Error(`Unable to get default asset on ${network}`);\n  }\n  return {\n    address: usdc.usdcAddress,\n    decimals: 6,\n    eip712: {\n      name: usdc.usdcName,\n      version: \"2\"\n    }\n  };\n}\nfunction processPriceToAtomicAmount(price, network) {\n  let maxAmountRequired;\n  let asset;\n  if (typeof price === \"string\" || typeof price === \"number\") {\n    const parsedAmount = moneySchema.safeParse(price);\n    if (!parsedAmount.success) {\n      return {\n        error: `Invalid price (price: ${price}). Must be in the form \"$3.10\", 0.10, \"0.001\", ${parsedAmount.error}`\n      };\n    }\n    const parsedUsdAmount = parsedAmount.data;\n    asset = getDefaultAsset(network);\n    maxAmountRequired = (parsedUsdAmount * 10 ** asset.decimals).toString();\n  } else {\n    maxAmountRequired = price.amount;\n    asset = price.asset;\n  }\n  return {\n    maxAmountRequired,\n    asset\n  };\n}\nfunction findMatchingPaymentRequirements(paymentRequirements, payment) {\n  return paymentRequirements.find(\n    (value) => value.scheme === payment.scheme && value.network === payment.network\n  );\n}\nfunction decodeXPaymentResponse(header) {\n  const decoded = safeBase64Decode(header);\n  return JSON.parse(decoded);\n}\n\n// src/shared/svm/index.ts\nvar svm_exports2 = {};\n__export(svm_exports2, {\n  createDevnetRpcClient: () => createDevnetRpcClient,\n  createMainnetRpcClient: () => createMainnetRpcClient,\n  createSignerFromBase58: () => createSignerFromBase58,\n  createSvmConnectedClient: () => createSvmConnectedClient,\n  decodeTransactionFromPayload: () => decodeTransactionFromPayload,\n  getRpcClient: () => getRpcClient,\n  getRpcSubscriptions: () => getRpcSubscriptions,\n  getTokenPayerFromTransaction: () => getTokenPayerFromTransaction,\n  isSignerWallet: () => isSignerWallet2,\n  signAndSimulateTransaction: () => signAndSimulateTransaction,\n  signTransactionWithSigner: () => signTransactionWithSigner\n});\n\n// src/shared/svm/transaction.ts\nimport {\n  getBase64EncodedWireTransaction,\n  getBase64Encoder,\n  getTransactionDecoder,\n  getCompiledTransactionMessageDecoder,\n  isTransactionModifyingSigner,\n  isTransactionPartialSigner\n} from \"@solana/kit\";\nimport { TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\nimport { TOKEN_2022_PROGRAM_ADDRESS } from \"@solana-program/token-2022\";\nfunction decodeTransactionFromPayload(svmPayload) {\n  try {\n    const base64Encoder = getBase64Encoder();\n    const transactionBytes = base64Encoder.encode(svmPayload.transaction);\n    const transactionDecoder = getTransactionDecoder();\n    return transactionDecoder.decode(transactionBytes);\n  } catch (error) {\n    console.error(\"error\", error);\n    throw new Error(\"invalid_exact_svm_payload_transaction\");\n  }\n}\nfunction getTokenPayerFromTransaction(transaction) {\n  const compiled = getCompiledTransactionMessageDecoder().decode(\n    transaction.messageBytes\n  );\n  const staticAccounts = compiled.staticAccounts ?? [];\n  const instructions = compiled.instructions ?? [];\n  for (const ix of instructions) {\n    const programIndex = ix.programAddressIndex;\n    const programAddress = staticAccounts[programIndex].toString();\n    if (programAddress === TOKEN_PROGRAM_ADDRESS.toString() || programAddress === TOKEN_2022_PROGRAM_ADDRESS.toString()) {\n      const accountIndices = ix.accountIndices ?? [];\n      if (accountIndices.length >= 4) {\n        const ownerIndex = accountIndices[3];\n        const ownerAddress = staticAccounts[ownerIndex].toString();\n        if (ownerAddress) return ownerAddress;\n      }\n    }\n  }\n  return \"\";\n}\nasync function signAndSimulateTransaction(signer, transaction, rpc) {\n  const signedTransaction = await signTransactionWithSigner(signer, transaction);\n  const base64EncodedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n  const simulateTxConfig = {\n    sigVerify: true,\n    replaceRecentBlockhash: false,\n    commitment: \"confirmed\",\n    encoding: \"base64\",\n    accounts: void 0,\n    innerInstructions: void 0,\n    minContextSlot: void 0\n  };\n  const simulateResult = await rpc.simulateTransaction(base64EncodedTransaction, simulateTxConfig).send();\n  return simulateResult;\n}\nasync function signTransactionWithSigner(signer, transaction) {\n  if (isTransactionModifyingSigner(signer)) {\n    const [modifiedTransaction] = await signer.modifyAndSignTransactions([transaction]);\n    if (!modifiedTransaction) {\n      throw new Error(\"transaction_signer_failed_to_return_transaction\");\n    }\n    return modifiedTransaction;\n  }\n  if (isTransactionPartialSigner(signer)) {\n    const [signatures] = await signer.signTransactions([\n      transaction\n    ]);\n    if (!signatures) {\n      throw new Error(\"transaction_signer_failed_to_return_signatures\");\n    }\n    return mergeTransactionSignatures(transaction, signatures);\n  }\n  throw new Error(\"transaction_signer_must_support_offline_signing\");\n}\nfunction mergeTransactionSignatures(transaction, signatures) {\n  return Object.freeze({\n    ...transaction,\n    signatures: Object.freeze({\n      ...transaction.signatures,\n      ...signatures\n    })\n  });\n}\n\n// src/types/verify/facilitator.ts\nvar facilitatorRequestSchema = z4.object({\n  paymentHeader: z4.string(),\n  paymentRequirements: PaymentRequirementsSchema\n});\nfunction settleResponseHeader(response) {\n  return safeBase64Encode(JSON.stringify(response));\n}\nfunction settleResponseFromHeader(header) {\n  const decoded = safeBase64Decode(header);\n  return JSON.parse(decoded);\n}\n\nexport {\n  authorizationTypes,\n  isSignerWallet,\n  isAccount,\n  evm_exports,\n  toJsonSafe,\n  Base64EncodedRegex,\n  safeBase64Encode,\n  safeBase64Decode,\n  moneySchema,\n  NetworkSchema,\n  SupportedEVMNetworks,\n  EvmNetworkToChainId,\n  SupportedSVMNetworks,\n  SvmNetworkToChainId,\n  ChainIdToNetwork,\n  getRpcClient,\n  getRpcSubscriptions,\n  createConnectedClient2 as createConnectedClient,\n  createSigner2 as createSigner,\n  isEvmSignerWallet,\n  isSvmSignerWallet,\n  isMultiNetworkSigner,\n  svm_exports,\n  getNetworkId,\n  schemes,\n  x402Versions,\n  ErrorReasons,\n  PaymentRequirementsSchema,\n  ExactEvmPayloadAuthorizationSchema,\n  ExactEvmPayloadSchema,\n  ExactSvmPayloadSchema,\n  PaymentPayloadSchema,\n  x402ResponseSchema,\n  HTTPRequestStructureSchema,\n  RequestStructureSchema,\n  DiscoveredResourceSchema,\n  SettleRequestSchema,\n  VerifyRequestSchema,\n  VerifyResponseSchema,\n  SettleResponseSchema,\n  ListDiscoveryResourcesRequestSchema,\n  ListDiscoveryResourcesResponseSchema,\n  SupportedPaymentKindSchema,\n  SupportedPaymentKindsResponseSchema,\n  facilitatorRequestSchema,\n  settleResponseHeader,\n  settleResponseFromHeader,\n  computeRoutePatterns,\n  findMatchingRoute,\n  getDefaultAsset,\n  processPriceToAtomicAmount,\n  findMatchingPaymentRequirements,\n  decodeXPaymentResponse,\n  decodeTransactionFromPayload,\n  getTokenPayerFromTransaction,\n  signAndSimulateTransaction,\n  signTransactionWithSigner,\n  svm_exports2\n};\n//# sourceMappingURL=chunk-3EQVFRKV.mjs.map","export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n\nexport const maxInt8 = 2n ** (8n - 1n) - 1n\nexport const maxInt16 = 2n ** (16n - 1n) - 1n\nexport const maxInt24 = 2n ** (24n - 1n) - 1n\nexport const maxInt32 = 2n ** (32n - 1n) - 1n\nexport const maxInt40 = 2n ** (40n - 1n) - 1n\nexport const maxInt48 = 2n ** (48n - 1n) - 1n\nexport const maxInt56 = 2n ** (56n - 1n) - 1n\nexport const maxInt64 = 2n ** (64n - 1n) - 1n\nexport const maxInt72 = 2n ** (72n - 1n) - 1n\nexport const maxInt80 = 2n ** (80n - 1n) - 1n\nexport const maxInt88 = 2n ** (88n - 1n) - 1n\nexport const maxInt96 = 2n ** (96n - 1n) - 1n\nexport const maxInt104 = 2n ** (104n - 1n) - 1n\nexport const maxInt112 = 2n ** (112n - 1n) - 1n\nexport const maxInt120 = 2n ** (120n - 1n) - 1n\nexport const maxInt128 = 2n ** (128n - 1n) - 1n\nexport const maxInt136 = 2n ** (136n - 1n) - 1n\nexport const maxInt144 = 2n ** (144n - 1n) - 1n\nexport const maxInt152 = 2n ** (152n - 1n) - 1n\nexport const maxInt160 = 2n ** (160n - 1n) - 1n\nexport const maxInt168 = 2n ** (168n - 1n) - 1n\nexport const maxInt176 = 2n ** (176n - 1n) - 1n\nexport const maxInt184 = 2n ** (184n - 1n) - 1n\nexport const maxInt192 = 2n ** (192n - 1n) - 1n\nexport const maxInt200 = 2n ** (200n - 1n) - 1n\nexport const maxInt208 = 2n ** (208n - 1n) - 1n\nexport const maxInt216 = 2n ** (216n - 1n) - 1n\nexport const maxInt224 = 2n ** (224n - 1n) - 1n\nexport const maxInt232 = 2n ** (232n - 1n) - 1n\nexport const maxInt240 = 2n ** (240n - 1n) - 1n\nexport const maxInt248 = 2n ** (248n - 1n) - 1n\nexport const maxInt256 = 2n ** (256n - 1n) - 1n\n\nexport const minInt8 = -(2n ** (8n - 1n))\nexport const minInt16 = -(2n ** (16n - 1n))\nexport const minInt24 = -(2n ** (24n - 1n))\nexport const minInt32 = -(2n ** (32n - 1n))\nexport const minInt40 = -(2n ** (40n - 1n))\nexport const minInt48 = -(2n ** (48n - 1n))\nexport const minInt56 = -(2n ** (56n - 1n))\nexport const minInt64 = -(2n ** (64n - 1n))\nexport const minInt72 = -(2n ** (72n - 1n))\nexport const minInt80 = -(2n ** (80n - 1n))\nexport const minInt88 = -(2n ** (88n - 1n))\nexport const minInt96 = -(2n ** (96n - 1n))\nexport const minInt104 = -(2n ** (104n - 1n))\nexport const minInt112 = -(2n ** (112n - 1n))\nexport const minInt120 = -(2n ** (120n - 1n))\nexport const minInt128 = -(2n ** (128n - 1n))\nexport const minInt136 = -(2n ** (136n - 1n))\nexport const minInt144 = -(2n ** (144n - 1n))\nexport const minInt152 = -(2n ** (152n - 1n))\nexport const minInt160 = -(2n ** (160n - 1n))\nexport const minInt168 = -(2n ** (168n - 1n))\nexport const minInt176 = -(2n ** (176n - 1n))\nexport const minInt184 = -(2n ** (184n - 1n))\nexport const minInt192 = -(2n ** (192n - 1n))\nexport const minInt200 = -(2n ** (200n - 1n))\nexport const minInt208 = -(2n ** (208n - 1n))\nexport const minInt216 = -(2n ** (216n - 1n))\nexport const minInt224 = -(2n ** (224n - 1n))\nexport const minInt232 = -(2n ** (232n - 1n))\nexport const minInt240 = -(2n ** (240n - 1n))\nexport const minInt248 = -(2n ** (248n - 1n))\nexport const minInt256 = -(2n ** (256n - 1n))\n\nexport const maxUint8 = 2n ** 8n - 1n\nexport const maxUint16 = 2n ** 16n - 1n\nexport const maxUint24 = 2n ** 24n - 1n\nexport const maxUint32 = 2n ** 32n - 1n\nexport const maxUint40 = 2n ** 40n - 1n\nexport const maxUint48 = 2n ** 48n - 1n\nexport const maxUint56 = 2n ** 56n - 1n\nexport const maxUint64 = 2n ** 64n - 1n\nexport const maxUint72 = 2n ** 72n - 1n\nexport const maxUint80 = 2n ** 80n - 1n\nexport const maxUint88 = 2n ** 88n - 1n\nexport const maxUint96 = 2n ** 96n - 1n\nexport const maxUint104 = 2n ** 104n - 1n\nexport const maxUint112 = 2n ** 112n - 1n\nexport const maxUint120 = 2n ** 120n - 1n\nexport const maxUint128 = 2n ** 128n - 1n\nexport const maxUint136 = 2n ** 136n - 1n\nexport const maxUint144 = 2n ** 144n - 1n\nexport const maxUint152 = 2n ** 152n - 1n\nexport const maxUint160 = 2n ** 160n - 1n\nexport const maxUint168 = 2n ** 168n - 1n\nexport const maxUint176 = 2n ** 176n - 1n\nexport const maxUint184 = 2n ** 184n - 1n\nexport const maxUint192 = 2n ** 192n - 1n\nexport const maxUint200 = 2n ** 200n - 1n\nexport const maxUint208 = 2n ** 208n - 1n\nexport const maxUint216 = 2n ** 216n - 1n\nexport const maxUint224 = 2n ** 224n - 1n\nexport const maxUint232 = 2n ** 232n - 1n\nexport const maxUint240 = 2n ** 240n - 1n\nexport const maxUint248 = 2n ** 248n - 1n\nexport const maxUint256 = 2n ** 256n - 1n\n","import { safeCaptureStackTrace, SOLANA_ERROR__RPC__INTEGER_OVERFLOW, SolanaError } from '@solana/errors';\nimport type { KeyPath } from '@solana/rpc-transformers';\n\nexport function createSolanaJsonRpcIntegerOverflowError(\n    methodName: string,\n    keyPath: KeyPath,\n    value: bigint,\n): SolanaError<typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW> {\n    let argumentLabel = '';\n    if (typeof keyPath[0] === 'number') {\n        const argPosition = keyPath[0] + 1;\n        const lastDigit = argPosition % 10;\n        const lastTwoDigits = argPosition % 100;\n        if (lastDigit == 1 && lastTwoDigits != 11) {\n            argumentLabel = argPosition + 'st';\n        } else if (lastDigit == 2 && lastTwoDigits != 12) {\n            argumentLabel = argPosition + 'nd';\n        } else if (lastDigit == 3 && lastTwoDigits != 13) {\n            argumentLabel = argPosition + 'rd';\n        } else {\n            argumentLabel = argPosition + 'th';\n        }\n    } else {\n        argumentLabel = `\\`${keyPath[0].toString()}\\``;\n    }\n    const path =\n        keyPath.length > 1\n            ? keyPath\n                  .slice(1)\n                  .map(pathPart => (typeof pathPart === 'number' ? `[${pathPart}]` : pathPart))\n                  .join('.')\n            : undefined;\n    const error = new SolanaError(SOLANA_ERROR__RPC__INTEGER_OVERFLOW, {\n        argumentLabel,\n        keyPath: keyPath as readonly (number | string | symbol)[],\n        methodName,\n        optionalPathLabel: path ? ` at path \\`${path}\\`` : '',\n        value,\n        ...(path !== undefined ? { path } : undefined),\n    });\n    safeCaptureStackTrace(error, createSolanaJsonRpcIntegerOverflowError);\n    return error;\n}\n","import { createCipheriv, KeyObject } from 'crypto';\nimport checkIvLength from '../lib/check_iv_length.js';\nimport checkCekLength from './check_cek_length.js';\nimport { concat } from '../lib/buffer_utils.js';\nimport cbcTag from './cbc_tag.js';\nimport { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport isKeyObject from './is_key_object.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport supported from './ciphers.js';\nimport { types } from './is_key_like.js';\nfunction cbcEncrypt(enc, plaintext, cek, iv, aad) {\n    const keySize = parseInt(enc.slice(1, 4), 10);\n    if (isKeyObject(cek)) {\n        cek = cek.export();\n    }\n    const encKey = cek.subarray(keySize >> 3);\n    const macKey = cek.subarray(0, keySize >> 3);\n    const algorithm = `aes-${keySize}-cbc`;\n    if (!supported(algorithm)) {\n        throw new JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);\n    }\n    const cipher = createCipheriv(algorithm, encKey, iv);\n    const ciphertext = concat(cipher.update(plaintext), cipher.final());\n    const macSize = parseInt(enc.slice(-3), 10);\n    const tag = cbcTag(aad, iv, ciphertext, macSize, macKey, keySize);\n    return { ciphertext, tag };\n}\nfunction gcmEncrypt(enc, plaintext, cek, iv, aad) {\n    const keySize = parseInt(enc.slice(1, 4), 10);\n    const algorithm = `aes-${keySize}-gcm`;\n    if (!supported(algorithm)) {\n        throw new JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);\n    }\n    const cipher = createCipheriv(algorithm, cek, iv, { authTagLength: 16 });\n    if (aad.byteLength) {\n        cipher.setAAD(aad, { plaintextLength: plaintext.length });\n    }\n    const ciphertext = cipher.update(plaintext);\n    cipher.final();\n    const tag = cipher.getAuthTag();\n    return { ciphertext, tag };\n}\nconst encrypt = (enc, plaintext, cek, iv, aad) => {\n    let key;\n    if (isCryptoKey(cek)) {\n        checkEncCryptoKey(cek, enc, 'encrypt');\n        key = KeyObject.from(cek);\n    }\n    else if (cek instanceof Uint8Array || isKeyObject(cek)) {\n        key = cek;\n    }\n    else {\n        throw new TypeError(invalidKeyInput(cek, ...types, 'Uint8Array'));\n    }\n    checkCekLength(enc, key);\n    checkIvLength(enc, iv);\n    switch (enc) {\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            return cbcEncrypt(enc, plaintext, key, iv, aad);\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            return gcmEncrypt(enc, plaintext, key, iv, aad);\n        default:\n            throw new JOSENotSupported('Unsupported JWE Content Encryption Algorithm');\n    }\n};\nexport default encrypt;\n","import { promisify } from 'util';\nimport { KeyObject, pbkdf2 as pbkdf2cb } from 'crypto';\nimport random from './random.js';\nimport { p2s as concatSalt } from '../lib/buffer_utils.js';\nimport { encode as base64url } from './base64url.js';\nimport { wrap, unwrap } from './aeskw.js';\nimport checkP2s from '../lib/check_p2s.js';\nimport { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport isKeyObject from './is_key_object.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nconst pbkdf2 = promisify(pbkdf2cb);\nfunction getPassword(key, alg) {\n    if (isKeyObject(key)) {\n        return key.export();\n    }\n    if (key instanceof Uint8Array) {\n        return key;\n    }\n    if (isCryptoKey(key)) {\n        checkEncCryptoKey(key, alg, 'deriveBits', 'deriveKey');\n        return KeyObject.from(key).export();\n    }\n    throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));\n}\nexport const encrypt = async (alg, key, cek, p2c = 2048, p2s = random(new Uint8Array(16))) => {\n    checkP2s(p2s);\n    const salt = concatSalt(alg, p2s);\n    const keylen = parseInt(alg.slice(13, 16), 10) >> 3;\n    const password = getPassword(key, alg);\n    const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.slice(8, 11)}`);\n    const encryptedKey = await wrap(alg.slice(-6), derivedKey, cek);\n    return { encryptedKey, p2c, p2s: base64url(p2s) };\n};\nexport const decrypt = async (alg, key, encryptedKey, p2c, p2s) => {\n    checkP2s(p2s);\n    const salt = concatSalt(alg, p2s);\n    const keylen = parseInt(alg.slice(13, 16), 10) >> 3;\n    const password = getPassword(key, alg);\n    const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.slice(8, 11)}`);\n    return unwrap(alg.slice(-6), derivedKey, encryptedKey);\n};\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/core/communicator/Communicator.ts","/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\nexport function abytes(item: unknown): void {\n  if (!isBytes(item)) throw new Error('Uint8Array expected');\n}\n\nexport function abool(title: string, value: boolean): void {\n  if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);\n}\n\n// Used in weierstrass, der\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? '0' + hex : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean =\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function';\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  abytes(bytes);\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n    }\n  } else if (isBytes(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(title + ' must be hex string or Uint8Array');\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n  return res;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n// Is positive bigint\nconst isPosBig = (n: bigint) => typeof n === 'bigint' && _0n <= n;\n\nexport function inRange(n: bigint, min: bigint, max: bigint): boolean {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title: string, n: bigint, min: bigint, max: bigint): void {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max))\n    throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n: bigint): number {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number): bigint {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n: bigint, pos: number, value: boolean): bigint {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number): bigint => (_1n << BigInt(n)) - _1n;\n\n// DRBG\n\nconst u8n = (len: number) => new Uint8Array(len); // creates Uint8Array\nconst u8fr = (arr: ArrayLike<number>) => Uint8Array.from(arr); // another shortcut\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n(0)) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any): boolean => typeof val === 'bigint',\n  function: (val: any): boolean => typeof val === 'function',\n  boolean: (val: any): boolean => typeof val === 'boolean',\n  string: (val: any): boolean => typeof val === 'string',\n  stringOrUint8Array: (val: any): boolean => typeof val === 'string' || isBytes(val),\n  isSafeInteger: (val: any): boolean => Number.isSafeInteger(val),\n  array: (val: any): boolean => Array.isArray(val),\n  field: (val: any, object: any): any => (object as any).Fp.isValid(val),\n  hash: (val: any): boolean => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n): T {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error('invalid validator function');\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        'param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n\n/**\n * throws not implemented error\n */\nexport const notImplemented = (): never => {\n  throw new Error('not implemented');\n};\n\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized<T extends object, R, O extends any[]>(\n  fn: (arg: T, ...args: O) => R\n): (arg: T, ...args: O) => R {\n  const map = new WeakMap<T, R>();\n  return (arg: T, ...args: O): R => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}\n","import type { ChainFormatters } from '../types/chain.js'\nimport { hexToBigInt, hexToNumber } from '../utils/encoding/fromHex.js'\nimport { hexToBytes } from '../utils/encoding/toBytes.js'\nimport { toHex } from '../utils/encoding/toHex.js'\nimport { defineBlock } from '../utils/formatters/block.js'\nimport { formatLog } from '../utils/formatters/log.js'\nimport { defineTransaction } from '../utils/formatters/transaction.js'\nimport { defineTransactionReceipt } from '../utils/formatters/transactionReceipt.js'\nimport { defineTransactionRequest } from '../utils/formatters/transactionRequest.js'\nimport { gasPerPubdataDefault } from './constants/number.js'\nimport type { ZksyncBlock, ZksyncRpcBlock } from './types/block.js'\nimport type { ZksyncL2ToL1Log, ZksyncLog } from './types/log.js'\nimport type {\n  ZksyncRpcTransaction,\n  ZksyncRpcTransactionReceipt,\n  ZksyncRpcTransactionRequest,\n  ZksyncTransaction,\n  ZksyncTransactionReceipt,\n  ZksyncTransactionRequest,\n} from './types/transaction.js'\n\nexport const formatters = {\n  block: /*#__PURE__*/ defineBlock({\n    format(args: ZksyncRpcBlock): ZksyncBlock {\n      const transactions = args.transactions?.map((transaction) => {\n        if (typeof transaction === 'string') return transaction\n        const formatted = formatters.transaction?.format(\n          transaction as ZksyncRpcTransaction,\n        ) as ZksyncTransaction\n        if (formatted.typeHex === '0x71') formatted.type = 'eip712'\n        else if (formatted.typeHex === '0xff') formatted.type = 'priority'\n        return formatted\n      })\n      return {\n        l1BatchNumber: args.l1BatchNumber\n          ? hexToBigInt(args.l1BatchNumber)\n          : null,\n        l1BatchTimestamp: args.l1BatchTimestamp\n          ? hexToBigInt(args.l1BatchTimestamp)\n          : null,\n        transactions,\n      } as ZksyncBlock\n    },\n  }),\n  transaction: /*#__PURE__*/ defineTransaction({\n    format(args: ZksyncRpcTransaction): ZksyncTransaction {\n      const transaction = {} as ZksyncTransaction\n      if (args.type === '0x71') transaction.type = 'eip712'\n      else if (args.type === '0xff') transaction.type = 'priority'\n      return {\n        ...transaction,\n        l1BatchNumber: args.l1BatchNumber\n          ? hexToBigInt(args.l1BatchNumber)\n          : null,\n        l1BatchTxIndex: args.l1BatchTxIndex\n          ? hexToBigInt(args.l1BatchTxIndex)\n          : null,\n      } as ZksyncTransaction\n    },\n  }),\n  transactionReceipt: /*#__PURE__*/ defineTransactionReceipt({\n    format(args: ZksyncRpcTransactionReceipt): ZksyncTransactionReceipt {\n      return {\n        l1BatchNumber: args.l1BatchNumber\n          ? hexToBigInt(args.l1BatchNumber)\n          : null,\n        l1BatchTxIndex: args.l1BatchTxIndex\n          ? hexToBigInt(args.l1BatchTxIndex)\n          : null,\n        logs: args.logs.map((log) => {\n          return {\n            ...formatLog(log),\n            l1BatchNumber: log.l1BatchNumber\n              ? hexToBigInt(log.l1BatchNumber)\n              : null,\n            transactionLogIndex: hexToNumber(log.transactionLogIndex),\n            logType: log.logType,\n          }\n        }) as ZksyncLog[],\n        l2ToL1Logs: args.l2ToL1Logs.map((l2ToL1Log) => {\n          return {\n            blockNumber: hexToBigInt(l2ToL1Log.blockHash),\n            blockHash: l2ToL1Log.blockHash,\n            l1BatchNumber: l2ToL1Log.l1BatchNumber\n              ? hexToBigInt(l2ToL1Log.l1BatchNumber)\n              : null,\n            transactionIndex: hexToBigInt(l2ToL1Log.transactionIndex),\n            shardId: hexToBigInt(l2ToL1Log.shardId),\n            isService: l2ToL1Log.isService,\n            sender: l2ToL1Log.sender,\n            key: l2ToL1Log.key,\n            value: l2ToL1Log.value,\n            transactionHash: l2ToL1Log.transactionHash,\n            logIndex: hexToBigInt(l2ToL1Log.logIndex),\n          }\n        }) as ZksyncL2ToL1Log[],\n      } as ZksyncTransactionReceipt\n    },\n  }),\n  transactionRequest: /*#__PURE__*/ defineTransactionRequest({\n    exclude: [\n      'customSignature',\n      'factoryDeps',\n      'gasPerPubdata',\n      'paymaster',\n      'paymasterInput',\n    ],\n    format(args: ZksyncTransactionRequest): ZksyncRpcTransactionRequest {\n      if (\n        args.gasPerPubdata ||\n        (args.paymaster && args.paymasterInput) ||\n        args.factoryDeps ||\n        args.customSignature\n      )\n        return {\n          eip712Meta: {\n            ...(args.gasPerPubdata\n              ? { gasPerPubdata: toHex(args.gasPerPubdata) }\n              : { gasPerPubdata: toHex(gasPerPubdataDefault) }),\n            ...(args.paymaster && args.paymasterInput\n              ? {\n                  paymasterParams: {\n                    paymaster: args.paymaster,\n                    paymasterInput: Array.from(hexToBytes(args.paymasterInput)),\n                  },\n                }\n              : {}),\n            ...(args.factoryDeps\n              ? {\n                  factoryDeps: args.factoryDeps.map((dep) =>\n                    Array.from(hexToBytes(dep)),\n                  ),\n                }\n              : {}),\n            ...(args.customSignature\n              ? {\n                  customSignature: Array.from(hexToBytes(args.customSignature)),\n                }\n              : {}),\n          },\n          type: '0x71',\n        } as unknown as ZksyncRpcTransactionRequest\n      return {} as ZksyncRpcTransactionRequest\n    },\n  }),\n} as const satisfies ChainFormatters\n","/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { concatBytes, randomBytes } from '@noble/hashes/utils';\nimport type { CHash } from './abstract/utils.ts';\nimport { type CurveFn, type CurveType, weierstrass } from './abstract/weierstrass.ts';\n\n/** connects noble-curves to noble-hashes */\nexport function getHash(hash: CHash): {\n  hash: CHash;\n  hmac: (key: Uint8Array, ...msgs: Uint8Array[]) => Uint8Array;\n  randomBytes: typeof randomBytes;\n} {\n  return {\n    hash,\n    hmac: (key: Uint8Array, ...msgs: Uint8Array[]) => hmac(hash, key, concatBytes(...msgs)),\n    randomBytes,\n  };\n}\n/** Same API as @noble/hashes, with ability to create curve with custom hash */\nexport type CurveDef = Readonly<Omit<CurveType, 'hash' | 'hmac' | 'randomBytes'>>;\nexport type CurveFnWithCreate = CurveFn & { create: (hash: CHash) => CurveFn };\n\nexport function createCurve(curveDef: CurveDef, defHash: CHash): CurveFnWithCreate {\n  const create = (hash: CHash): CurveFn => weierstrass({ ...curveDef, ...getHash(hash) });\n  return { ...create(defHash), create };\n}\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/sign/walletlink/relay/type/WalletLinkSession.ts","import { MAX_LOG_SIZE_IN_BYTES_DEFAULT } from \"./constants\";\nimport type { DestinationStream, LoggerOptions } from \"pino\";\nimport BaseChunkLogger from \"./baseChunkLogger\";\n\nexport default class ServerChunkLogger implements DestinationStream {\n  private baseChunkLogger: BaseChunkLogger;\n\n  public constructor(\n    level: LoggerOptions[\"level\"],\n    MAX_LOG_SIZE_IN_BYTES: number = MAX_LOG_SIZE_IN_BYTES_DEFAULT,\n  ) {\n    this.baseChunkLogger = new BaseChunkLogger(level, MAX_LOG_SIZE_IN_BYTES);\n  }\n\n  public write(chunk: any): void {\n    this.baseChunkLogger.appendToLogs(chunk);\n  }\n\n  public getLogs() {\n    return this.baseChunkLogger.getLogs();\n  }\n\n  public clearLogs() {\n    this.baseChunkLogger.clearLogs();\n  }\n\n  public getLogArray() {\n    return this.baseChunkLogger.getLogArray();\n  }\n\n  public logsToBlob(extraMetadata: Record<string, string>) {\n    return this.baseChunkLogger.logsToBlob(extraMetadata);\n  }\n}\n","import { MAX_LOG_SIZE_IN_BYTES_DEFAULT } from \"./constants\";\nimport type { DestinationStream, LoggerOptions } from \"pino\";\nimport BaseChunkLogger from \"./baseChunkLogger\";\n\nexport default class ServerChunkLogger implements DestinationStream {\n  private baseChunkLogger: BaseChunkLogger;\n\n  public constructor(\n    level: LoggerOptions[\"level\"],\n    MAX_LOG_SIZE_IN_BYTES: number = MAX_LOG_SIZE_IN_BYTES_DEFAULT,\n  ) {\n    this.baseChunkLogger = new BaseChunkLogger(level, MAX_LOG_SIZE_IN_BYTES);\n  }\n\n  public write(chunk: any): void {\n    this.baseChunkLogger.appendToLogs(chunk);\n  }\n\n  public getLogs() {\n    return this.baseChunkLogger.getLogs();\n  }\n\n  public clearLogs() {\n    this.baseChunkLogger.clearLogs();\n  }\n\n  public getLogArray() {\n    return this.baseChunkLogger.getLogArray();\n  }\n\n  public logsToBlob(extraMetadata: Record<string, string>) {\n    return this.baseChunkLogger.logsToBlob(extraMetadata);\n  }\n}\n","function getSymbols(object) {\n    return Object.getOwnPropertySymbols(object).filter(symbol => Object.prototype.propertyIsEnumerable.call(object, symbol));\n}\n\nexport { getSymbols };\n","import { SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, SolanaError } from '@solana/errors';\n\nexport type AllowedHttpRequestHeaders = Readonly<\n    {\n        // Someone can still sneak a forbidden header past Typescript if they do something like\n        // fOo-BaR, but at that point they deserve the runtime failure.\n        [K in DisallowedHeaders | ForbiddenHeaders as\n            | Capitalize<Lowercase<K>> // `Foo-bar`\n            | K // `Foo-Bar`\n            | Lowercase<K> // `foo-bar`\n            | Uncapitalize<K> // `foo-Bar`\n            // `FOO-BAR`\n            | Uppercase<K>]?: never;\n    } & { [headerName: string]: string }\n>;\n// These are headers that we simply don't allow the developer to override because they're\n// fundamental to the operation of the JSON-RPC transport.\ntype DisallowedHeaders = 'Accept' | 'Content-Length' | 'Content-Type' | 'Solana-Client';\ntype ForbiddenHeaders =\n    | 'Accept-Charset'\n    // Though technically forbidden in non-Node environments, we don't have a way to target\n    // TypeScript types depending on which platform you are authoring for. `Accept-Encoding` is\n    // therefore omitted from the forbidden headers type, but is still a runtime error in dev mode\n    // when supplied in a non-Node context.\n    // | 'Accept-Encoding'\n    | 'Access-Control-Request-Headers'\n    | 'Access-Control-Request-Method'\n    | 'Connection'\n    | 'Content-Length'\n    | 'Cookie'\n    | 'Date'\n    | 'DNT'\n    | 'Expect'\n    | 'Host'\n    | 'Keep-Alive'\n    // Similar to `Accept-Encoding`, we don't have a way to target TypeScript types depending on\n    // which platform you are authoring for. `Origin` is therefore omitted from the forbidden\n    // headers type, but is still a runtime error in dev mode when supplied in a browser context.\n    // | 'Origin'\n    | 'Permissions-Policy'\n    | 'Referer'\n    | 'TE'\n    | 'Trailer'\n    | 'Transfer-Encoding'\n    | 'Upgrade'\n    | 'Via'\n    | `Proxy-${string}`\n    | `Sec-${string}`;\n\n// These are headers which are fundamental to the JSON-RPC transport, and must not be modified.\nconst DISALLOWED_HEADERS: Record<string, boolean> = {\n    accept: true,\n    'content-length': true,\n    'content-type': true,\n};\n// https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\nconst FORBIDDEN_HEADERS: Record<string, boolean> = /* @__PURE__ */ Object.assign(\n    {\n        'accept-charset': true,\n        'access-control-request-headers': true,\n        'access-control-request-method': true,\n        connection: true,\n        'content-length': true,\n        cookie: true,\n        date: true,\n        dnt: true,\n        expect: true,\n        host: true,\n        'keep-alive': true,\n        'permissions-policy': true,\n        // Prefix matching is implemented in code, below.\n        // 'proxy-': true,\n        // 'sec-': true,\n        referer: true,\n        te: true,\n        trailer: true,\n        'transfer-encoding': true,\n        upgrade: true,\n        via: true,\n    },\n    __NODEJS__ ? undefined : { 'accept-encoding': true },\n    __BROWSER__ ? { origin: true } : undefined,\n);\n\nexport function assertIsAllowedHttpRequestHeaders(\n    headers: Record<string, string>,\n): asserts headers is AllowedHttpRequestHeaders {\n    const badHeaders = Object.keys(headers).filter(headerName => {\n        const lowercaseHeaderName = headerName.toLowerCase();\n        return (\n            DISALLOWED_HEADERS[headerName.toLowerCase()] === true ||\n            FORBIDDEN_HEADERS[headerName.toLowerCase()] === true ||\n            lowercaseHeaderName.startsWith('proxy-') ||\n            lowercaseHeaderName.startsWith('sec-')\n        );\n    });\n    if (badHeaders.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, {\n            headers: badHeaders,\n        });\n    }\n}\n\n// Lowercasing header names makes it easier to override user-supplied headers, such as those defined\n// in the `DisallowedHeaders` type.\nexport function normalizeHeaders<T extends Record<string, string>>(\n    headers: T,\n): { [K in string & keyof T as Lowercase<K>]: T[K] } {\n    const out: Record<string, string> = {};\n    for (const headerName in headers) {\n        out[headerName.toLowerCase()] = headers[headerName];\n    }\n    return out as { [K in string & keyof T as Lowercase<K>]: T[K] };\n}\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/core/error/utils.ts","/* [ContractDeployer](https://github.com/matter-labs/era-system-contracts/blob/main/contracts/ContractDeployer.sol) */\nexport const contractDeployerAbi = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'accountAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'enum IContractDeployer.AccountNonceOrdering',\n        name: 'nonceOrdering',\n        type: 'uint8',\n      },\n    ],\n    name: 'AccountNonceOrderingUpdated',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'accountAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'enum IContractDeployer.AccountAbstractionVersion',\n        name: 'aaVersion',\n        type: 'uint8',\n      },\n    ],\n    name: 'AccountVersionUpdated',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'deployerAddress',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'bytecodeHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'contractAddress',\n        type: 'address',\n      },\n    ],\n    name: 'ContractDeployed',\n    type: 'event',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'bytes32',\n        name: '_salt',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'bytes32',\n        name: '_bytecodeHash',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'bytes',\n        name: '_input',\n        type: 'bytes',\n      },\n    ],\n    name: 'create',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'bytes32',\n        name: '_salt',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'bytes32',\n        name: '_bytecodeHash',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'bytes',\n        name: '_input',\n        type: 'bytes',\n      },\n    ],\n    name: 'create2',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'bytes32',\n        name: '_salt',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'bytes32',\n        name: '_bytecodeHash',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'bytes',\n        name: '_input',\n        type: 'bytes',\n      },\n      {\n        internalType: 'enum IContractDeployer.AccountAbstractionVersion',\n        name: '_aaVersion',\n        type: 'uint8',\n      },\n    ],\n    name: 'create2Account',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'bytes32',\n        name: '',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'bytes32',\n        name: '_bytecodeHash',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'bytes',\n        name: '_input',\n        type: 'bytes',\n      },\n      {\n        internalType: 'enum IContractDeployer.AccountAbstractionVersion',\n        name: '_aaVersion',\n        type: 'uint8',\n      },\n    ],\n    name: 'createAccount',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_address',\n        type: 'address',\n      },\n    ],\n    name: 'extendedAccountVersion',\n    outputs: [\n      {\n        internalType: 'enum IContractDeployer.AccountAbstractionVersion',\n        name: '',\n        type: 'uint8',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'bytes32',\n        name: '_keccak256BytecodeHash',\n        type: 'bytes32',\n      },\n    ],\n    name: 'forceDeployKeccak256',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'bytes32',\n            name: 'bytecodeHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'address',\n            name: 'newAddress',\n            type: 'address',\n          },\n          {\n            internalType: 'bool',\n            name: 'callConstructor',\n            type: 'bool',\n          },\n          {\n            internalType: 'uint256',\n            name: 'value',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes',\n            name: 'input',\n            type: 'bytes',\n          },\n        ],\n        internalType: 'struct ContractDeployer.ForceDeployment',\n        name: '_deployment',\n        type: 'tuple',\n      },\n      {\n        internalType: 'address',\n        name: '_sender',\n        type: 'address',\n      },\n    ],\n    name: 'forceDeployOnAddress',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'bytes32',\n            name: 'bytecodeHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'address',\n            name: 'newAddress',\n            type: 'address',\n          },\n          {\n            internalType: 'bool',\n            name: 'callConstructor',\n            type: 'bool',\n          },\n          {\n            internalType: 'uint256',\n            name: 'value',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes',\n            name: 'input',\n            type: 'bytes',\n          },\n        ],\n        internalType: 'struct ContractDeployer.ForceDeployment[]',\n        name: '_deployments',\n        type: 'tuple[]',\n      },\n    ],\n    name: 'forceDeployOnAddresses',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_address',\n        type: 'address',\n      },\n    ],\n    name: 'getAccountInfo',\n    outputs: [\n      {\n        components: [\n          {\n            internalType: 'enum IContractDeployer.AccountAbstractionVersion',\n            name: 'supportedAAVersion',\n            type: 'uint8',\n          },\n          {\n            internalType: 'enum IContractDeployer.AccountNonceOrdering',\n            name: 'nonceOrdering',\n            type: 'uint8',\n          },\n        ],\n        internalType: 'struct IContractDeployer.AccountInfo',\n        name: 'info',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_sender',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: '_senderNonce',\n        type: 'uint256',\n      },\n    ],\n    name: 'getNewAddressCreate',\n    outputs: [\n      {\n        internalType: 'address',\n        name: 'newAddress',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'pure',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_sender',\n        type: 'address',\n      },\n      {\n        internalType: 'bytes32',\n        name: '_bytecodeHash',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'bytes32',\n        name: '_salt',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'bytes',\n        name: '_input',\n        type: 'bytes',\n      },\n    ],\n    name: 'getNewAddressCreate2',\n    outputs: [\n      {\n        internalType: 'address',\n        name: 'newAddress',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'enum IContractDeployer.AccountAbstractionVersion',\n        name: '_version',\n        type: 'uint8',\n      },\n    ],\n    name: 'updateAccountVersion',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'enum IContractDeployer.AccountNonceOrdering',\n        name: '_nonceOrdering',\n        type: 'uint8',\n      },\n    ],\n    name: 'updateNonceOrdering',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n]\n\nexport const paymasterAbi = [\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_token',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: '_minAllowance',\n        type: 'uint256',\n      },\n      {\n        internalType: 'bytes',\n        name: '_innerInput',\n        type: 'bytes',\n      },\n    ],\n    name: 'approvalBased',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'bytes',\n        name: 'input',\n        type: 'bytes',\n      },\n    ],\n    name: 'general',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n]\n\nexport const l2SharedBridgeAbi = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'l1Sender',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'l2Receiver',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'l2Token',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'FinalizeDeposit',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'l2Sender',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'l1Receiver',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'l2Token',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'WithdrawalInitiated',\n    type: 'event',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_l1Sender',\n        type: 'address',\n      },\n      {\n        internalType: 'address',\n        name: '_l2Receiver',\n        type: 'address',\n      },\n      {\n        internalType: 'address',\n        name: '_l1Token',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: '_amount',\n        type: 'uint256',\n      },\n      {\n        internalType: 'bytes',\n        name: '_data',\n        type: 'bytes',\n      },\n    ],\n    name: 'finalizeDeposit',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'l1Bridge',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'l1SharedBridge',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_l2Token',\n        type: 'address',\n      },\n    ],\n    name: 'l1TokenAddress',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_l1Token',\n        type: 'address',\n      },\n    ],\n    name: 'l2TokenAddress',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_l1Receiver',\n        type: 'address',\n      },\n      {\n        internalType: 'address',\n        name: '_l2Token',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: '_amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'withdraw',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n] as const\n\nexport const l1SharedBridgeAbi = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'uint256',\n        name: 'chainId',\n        type: 'uint256',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'from',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'l1Token',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'BridgehubDepositBaseTokenInitiated',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'uint256',\n        name: 'chainId',\n        type: 'uint256',\n      },\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'txDataHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'l2DepositTxHash',\n        type: 'bytes32',\n      },\n    ],\n    name: 'BridgehubDepositFinalized',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'uint256',\n        name: 'chainId',\n        type: 'uint256',\n      },\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'txDataHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'from',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'to',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'l1Token',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'BridgehubDepositInitiated',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'uint256',\n        name: 'chainId',\n        type: 'uint256',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'to',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'l1Token',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'ClaimedFailedDepositSharedBridge',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'uint256',\n        name: 'chainId',\n        type: 'uint256',\n      },\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'l2DepositTxHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'from',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'to',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'l1Token',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'LegacyDepositInitiated',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'uint256',\n        name: 'chainId',\n        type: 'uint256',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'to',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'l1Token',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'WithdrawalFinalizedSharedBridge',\n    type: 'event',\n  },\n  {\n    inputs: [],\n    name: 'BRIDGE_HUB',\n    outputs: [\n      {\n        internalType: 'contract IBridgehub',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'L1_WETH_TOKEN',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_chainId',\n        type: 'uint256',\n      },\n      {\n        internalType: 'bytes32',\n        name: '_txDataHash',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'bytes32',\n        name: '_txHash',\n        type: 'bytes32',\n      },\n    ],\n    name: 'bridgehubConfirmL2Transaction',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_chainId',\n        type: 'uint256',\n      },\n      {\n        internalType: 'address',\n        name: '_prevMsgSender',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2Value',\n        type: 'uint256',\n      },\n      {\n        internalType: 'bytes',\n        name: '_data',\n        type: 'bytes',\n      },\n    ],\n    name: 'bridgehubDeposit',\n    outputs: [\n      {\n        components: [\n          {\n            internalType: 'bytes32',\n            name: 'magicValue',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'address',\n            name: 'l2Contract',\n            type: 'address',\n          },\n          {\n            internalType: 'bytes',\n            name: 'l2Calldata',\n            type: 'bytes',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'factoryDeps',\n            type: 'bytes[]',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'txDataHash',\n            type: 'bytes32',\n          },\n        ],\n        internalType: 'struct L2TransactionRequestTwoBridgesInner',\n        name: 'request',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_chainId',\n        type: 'uint256',\n      },\n      {\n        internalType: 'address',\n        name: '_prevMsgSender',\n        type: 'address',\n      },\n      {\n        internalType: 'address',\n        name: '_l1Token',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: '_amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'bridgehubDepositBaseToken',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_chainId',\n        type: 'uint256',\n      },\n      {\n        internalType: 'address',\n        name: '_depositSender',\n        type: 'address',\n      },\n      {\n        internalType: 'address',\n        name: '_l1Token',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: '_amount',\n        type: 'uint256',\n      },\n      {\n        internalType: 'bytes32',\n        name: '_l2TxHash',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2BatchNumber',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2MessageIndex',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint16',\n        name: '_l2TxNumberInBatch',\n        type: 'uint16',\n      },\n      {\n        internalType: 'bytes32[]',\n        name: '_merkleProof',\n        type: 'bytes32[]',\n      },\n    ],\n    name: 'claimFailedDeposit',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_depositSender',\n        type: 'address',\n      },\n      {\n        internalType: 'address',\n        name: '_l1Token',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: '_amount',\n        type: 'uint256',\n      },\n      {\n        internalType: 'bytes32',\n        name: '_l2TxHash',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2BatchNumber',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2MessageIndex',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint16',\n        name: '_l2TxNumberInBatch',\n        type: 'uint16',\n      },\n      {\n        internalType: 'bytes32[]',\n        name: '_merkleProof',\n        type: 'bytes32[]',\n      },\n    ],\n    name: 'claimFailedDepositLegacyErc20Bridge',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_chainId',\n        type: 'uint256',\n      },\n      {\n        internalType: 'bytes32',\n        name: '_l2TxHash',\n        type: 'bytes32',\n      },\n    ],\n    name: 'depositHappened',\n    outputs: [\n      {\n        internalType: 'bytes32',\n        name: '',\n        type: 'bytes32',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_msgSender',\n        type: 'address',\n      },\n      {\n        internalType: 'address',\n        name: '_l2Receiver',\n        type: 'address',\n      },\n      {\n        internalType: 'address',\n        name: '_l1Token',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: '_amount',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2TxGasLimit',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2TxGasPerPubdataByte',\n        type: 'uint256',\n      },\n      {\n        internalType: 'address',\n        name: '_refundRecipient',\n        type: 'address',\n      },\n    ],\n    name: 'depositLegacyErc20Bridge',\n    outputs: [\n      {\n        internalType: 'bytes32',\n        name: 'txHash',\n        type: 'bytes32',\n      },\n    ],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_chainId',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2BatchNumber',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2MessageIndex',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint16',\n        name: '_l2TxNumberInBatch',\n        type: 'uint16',\n      },\n      {\n        internalType: 'bytes',\n        name: '_message',\n        type: 'bytes',\n      },\n      {\n        internalType: 'bytes32[]',\n        name: '_merkleProof',\n        type: 'bytes32[]',\n      },\n    ],\n    name: 'finalizeWithdrawal',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_l2BatchNumber',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2MessageIndex',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint16',\n        name: '_l2TxNumberInBatch',\n        type: 'uint16',\n      },\n      {\n        internalType: 'bytes',\n        name: '_message',\n        type: 'bytes',\n      },\n      {\n        internalType: 'bytes32[]',\n        name: '_merkleProof',\n        type: 'bytes32[]',\n      },\n    ],\n    name: 'finalizeWithdrawalLegacyErc20Bridge',\n    outputs: [\n      {\n        internalType: 'address',\n        name: 'l1Receiver',\n        type: 'address',\n      },\n      {\n        internalType: 'address',\n        name: 'l1Token',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_chainId',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2BatchNumber',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2MessageIndex',\n        type: 'uint256',\n      },\n    ],\n    name: 'isWithdrawalFinalized',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: '',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_chainId',\n        type: 'uint256',\n      },\n    ],\n    name: 'l2BridgeAddress',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'legacyBridge',\n    outputs: [\n      {\n        internalType: 'contract IL1ERC20Bridge',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_chainId',\n        type: 'uint256',\n      },\n    ],\n    name: 'receiveEth',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_eraLegacyBridgeLastDepositBatch',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_eraLegacyBridgeLastDepositTxNumber',\n        type: 'uint256',\n      },\n    ],\n    name: 'setEraLegacyBridgeLastDepositTime',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_eraPostDiamondUpgradeFirstBatch',\n        type: 'uint256',\n      },\n    ],\n    name: 'setEraPostDiamondUpgradeFirstBatch',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_eraPostLegacyBridgeUpgradeFirstBatch',\n        type: 'uint256',\n      },\n    ],\n    name: 'setEraPostLegacyBridgeUpgradeFirstBatch',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n] as const\n\nexport const ethTokenAbi = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'Mint',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'from',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'to',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'value',\n        type: 'uint256',\n      },\n    ],\n    name: 'Transfer',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: '_l2Sender',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: '_l1Receiver',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: '_amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'Withdrawal',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: '_l2Sender',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: '_l1Receiver',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: '_amount',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'bytes',\n        name: '_additionalData',\n        type: 'bytes',\n      },\n    ],\n    name: 'WithdrawalWithMessage',\n    type: 'event',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    name: 'balanceOf',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'decimals',\n    outputs: [\n      {\n        internalType: 'uint8',\n        name: '',\n        type: 'uint8',\n      },\n    ],\n    stateMutability: 'pure',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_account',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: '_amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'mint',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'name',\n    outputs: [\n      {\n        internalType: 'string',\n        name: '',\n        type: 'string',\n      },\n    ],\n    stateMutability: 'pure',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'symbol',\n    outputs: [\n      {\n        internalType: 'string',\n        name: '',\n        type: 'string',\n      },\n    ],\n    stateMutability: 'pure',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'totalSupply',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_from',\n        type: 'address',\n      },\n      {\n        internalType: 'address',\n        name: '_to',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: '_amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'transferFromTo',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_l1Receiver',\n        type: 'address',\n      },\n    ],\n    name: 'withdraw',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_l1Receiver',\n        type: 'address',\n      },\n      {\n        internalType: 'bytes',\n        name: '_additionalData',\n        type: 'bytes',\n      },\n    ],\n    name: 'withdrawWithMessage',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n] as const\n\nexport const bridgehubAbi = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'oldAdmin',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'newAdmin',\n        type: 'address',\n      },\n    ],\n    name: 'NewAdmin',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'uint256',\n        name: 'chainId',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'stateTransitionManager',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'chainGovernance',\n        type: 'address',\n      },\n    ],\n    name: 'NewChain',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'oldPendingAdmin',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'newPendingAdmin',\n        type: 'address',\n      },\n    ],\n    name: 'NewPendingAdmin',\n    type: 'event',\n  },\n  {\n    inputs: [],\n    name: 'acceptAdmin',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_stateTransitionManager',\n        type: 'address',\n      },\n    ],\n    name: 'addStateTransitionManager',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_token',\n        type: 'address',\n      },\n    ],\n    name: 'addToken',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_chainId',\n        type: 'uint256',\n      },\n    ],\n    name: 'baseToken',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_chainId',\n        type: 'uint256',\n      },\n      {\n        internalType: 'address',\n        name: '_stateTransitionManager',\n        type: 'address',\n      },\n      {\n        internalType: 'address',\n        name: '_baseToken',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: '_salt',\n        type: 'uint256',\n      },\n      {\n        internalType: 'address',\n        name: '_admin',\n        type: 'address',\n      },\n      {\n        internalType: 'bytes',\n        name: '_initData',\n        type: 'bytes',\n      },\n    ],\n    name: 'createNewChain',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: 'chainId',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_chainId',\n        type: 'uint256',\n      },\n    ],\n    name: 'getHyperchain',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_chainId',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_gasPrice',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2GasLimit',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2GasPerPubdataByteLimit',\n        type: 'uint256',\n      },\n    ],\n    name: 'l2TransactionBaseCost',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_chainId',\n        type: 'uint256',\n      },\n      {\n        internalType: 'bytes32',\n        name: '_l2TxHash',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2BatchNumber',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2MessageIndex',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint16',\n        name: '_l2TxNumberInBatch',\n        type: 'uint16',\n      },\n      {\n        internalType: 'bytes32[]',\n        name: '_merkleProof',\n        type: 'bytes32[]',\n      },\n      {\n        internalType: 'enum TxStatus',\n        name: '_status',\n        type: 'uint8',\n      },\n    ],\n    name: 'proveL1ToL2TransactionStatus',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: '',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_chainId',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_batchNumber',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_index',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'l2ShardId',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bool',\n            name: 'isService',\n            type: 'bool',\n          },\n          {\n            internalType: 'uint16',\n            name: 'txNumberInBatch',\n            type: 'uint16',\n          },\n          {\n            internalType: 'address',\n            name: 'sender',\n            type: 'address',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'key',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'value',\n            type: 'bytes32',\n          },\n        ],\n        internalType: 'struct L2Log',\n        name: '_log',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes32[]',\n        name: '_proof',\n        type: 'bytes32[]',\n      },\n    ],\n    name: 'proveL2LogInclusion',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: '',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_chainId',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_batchNumber',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_index',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint16',\n            name: 'txNumberInBatch',\n            type: 'uint16',\n          },\n          {\n            internalType: 'address',\n            name: 'sender',\n            type: 'address',\n          },\n          {\n            internalType: 'bytes',\n            name: 'data',\n            type: 'bytes',\n          },\n        ],\n        internalType: 'struct L2Message',\n        name: '_message',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes32[]',\n        name: '_proof',\n        type: 'bytes32[]',\n      },\n    ],\n    name: 'proveL2MessageInclusion',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: '',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_stateTransitionManager',\n        type: 'address',\n      },\n    ],\n    name: 'removeStateTransitionManager',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint256',\n            name: 'chainId',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint256',\n            name: 'mintValue',\n            type: 'uint256',\n          },\n          {\n            internalType: 'address',\n            name: 'l2Contract',\n            type: 'address',\n          },\n          {\n            internalType: 'uint256',\n            name: 'l2Value',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes',\n            name: 'l2Calldata',\n            type: 'bytes',\n          },\n          {\n            internalType: 'uint256',\n            name: 'l2GasLimit',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint256',\n            name: 'l2GasPerPubdataByteLimit',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'factoryDeps',\n            type: 'bytes[]',\n          },\n          {\n            internalType: 'address',\n            name: 'refundRecipient',\n            type: 'address',\n          },\n        ],\n        internalType: 'struct L2TransactionRequestDirect',\n        name: '_request',\n        type: 'tuple',\n      },\n    ],\n    name: 'requestL2TransactionDirect',\n    outputs: [\n      {\n        internalType: 'bytes32',\n        name: 'canonicalTxHash',\n        type: 'bytes32',\n      },\n    ],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint256',\n            name: 'chainId',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint256',\n            name: 'mintValue',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint256',\n            name: 'l2Value',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint256',\n            name: 'l2GasLimit',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint256',\n            name: 'l2GasPerPubdataByteLimit',\n            type: 'uint256',\n          },\n          {\n            internalType: 'address',\n            name: 'refundRecipient',\n            type: 'address',\n          },\n          {\n            internalType: 'address',\n            name: 'secondBridgeAddress',\n            type: 'address',\n          },\n          {\n            internalType: 'uint256',\n            name: 'secondBridgeValue',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes',\n            name: 'secondBridgeCalldata',\n            type: 'bytes',\n          },\n        ],\n        internalType: 'struct L2TransactionRequestTwoBridgesOuter',\n        name: '_request',\n        type: 'tuple',\n      },\n    ],\n    name: 'requestL2TransactionTwoBridges',\n    outputs: [\n      {\n        internalType: 'bytes32',\n        name: 'canonicalTxHash',\n        type: 'bytes32',\n      },\n    ],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_newPendingAdmin',\n        type: 'address',\n      },\n    ],\n    name: 'setPendingAdmin',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_sharedBridge',\n        type: 'address',\n      },\n    ],\n    name: 'setSharedBridge',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'sharedBridge',\n    outputs: [\n      {\n        internalType: 'contract IL1SharedBridge',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_chainId',\n        type: 'uint256',\n      },\n    ],\n    name: 'stateTransitionManager',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_stateTransitionManager',\n        type: 'address',\n      },\n    ],\n    name: 'stateTransitionManagerIsRegistered',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: '',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_baseToken',\n        type: 'address',\n      },\n    ],\n    name: 'tokenIsRegistered',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: '',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n] as const\n\nexport const zksyncAbi = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'uint256',\n        name: 'batchNumber',\n        type: 'uint256',\n      },\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'batchHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'commitment',\n        type: 'bytes32',\n      },\n    ],\n    name: 'BlockCommit',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'uint256',\n        name: 'batchNumber',\n        type: 'uint256',\n      },\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'batchHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'commitment',\n        type: 'bytes32',\n      },\n    ],\n    name: 'BlockExecution',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'totalBatchesCommitted',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'totalBatchesVerified',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'totalBatchesExecuted',\n        type: 'uint256',\n      },\n    ],\n    name: 'BlocksRevert',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'uint256',\n        name: 'previousLastVerifiedBatch',\n        type: 'uint256',\n      },\n      {\n        indexed: true,\n        internalType: 'uint256',\n        name: 'currentLastVerifiedBatch',\n        type: 'uint256',\n      },\n    ],\n    name: 'BlocksVerification',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              {\n                internalType: 'address',\n                name: 'facet',\n                type: 'address',\n              },\n              {\n                internalType: 'enum Diamond.Action',\n                name: 'action',\n                type: 'uint8',\n              },\n              {\n                internalType: 'bool',\n                name: 'isFreezable',\n                type: 'bool',\n              },\n              {\n                internalType: 'bytes4[]',\n                name: 'selectors',\n                type: 'bytes4[]',\n              },\n            ],\n            internalType: 'struct Diamond.FacetCut[]',\n            name: 'facetCuts',\n            type: 'tuple[]',\n          },\n          {\n            internalType: 'address',\n            name: 'initAddress',\n            type: 'address',\n          },\n          {\n            internalType: 'bytes',\n            name: 'initCalldata',\n            type: 'bytes',\n          },\n        ],\n        indexed: false,\n        internalType: 'struct Diamond.DiamondCutData',\n        name: 'diamondCut',\n        type: 'tuple',\n      },\n    ],\n    name: 'ExecuteUpgrade',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [],\n    name: 'Freeze',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: 'bool',\n        name: 'isPorterAvailable',\n        type: 'bool',\n      },\n    ],\n    name: 'IsPorterAvailableStatusUpdate',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'oldAdmin',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'newAdmin',\n        type: 'address',\n      },\n    ],\n    name: 'NewAdmin',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: 'uint128',\n        name: 'oldNominator',\n        type: 'uint128',\n      },\n      {\n        indexed: false,\n        internalType: 'uint128',\n        name: 'oldDenominator',\n        type: 'uint128',\n      },\n      {\n        indexed: false,\n        internalType: 'uint128',\n        name: 'newNominator',\n        type: 'uint128',\n      },\n      {\n        indexed: false,\n        internalType: 'uint128',\n        name: 'newDenominator',\n        type: 'uint128',\n      },\n    ],\n    name: 'NewBaseTokenMultiplier',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'enum PubdataPricingMode',\n            name: 'pubdataPricingMode',\n            type: 'uint8',\n          },\n          {\n            internalType: 'uint32',\n            name: 'batchOverheadL1Gas',\n            type: 'uint32',\n          },\n          {\n            internalType: 'uint32',\n            name: 'maxPubdataPerBatch',\n            type: 'uint32',\n          },\n          {\n            internalType: 'uint32',\n            name: 'maxL2GasPerBatch',\n            type: 'uint32',\n          },\n          {\n            internalType: 'uint32',\n            name: 'priorityTxMaxPubdata',\n            type: 'uint32',\n          },\n          {\n            internalType: 'uint64',\n            name: 'minimalL2GasPrice',\n            type: 'uint64',\n          },\n        ],\n        indexed: false,\n        internalType: 'struct FeeParams',\n        name: 'oldFeeParams',\n        type: 'tuple',\n      },\n      {\n        components: [\n          {\n            internalType: 'enum PubdataPricingMode',\n            name: 'pubdataPricingMode',\n            type: 'uint8',\n          },\n          {\n            internalType: 'uint32',\n            name: 'batchOverheadL1Gas',\n            type: 'uint32',\n          },\n          {\n            internalType: 'uint32',\n            name: 'maxPubdataPerBatch',\n            type: 'uint32',\n          },\n          {\n            internalType: 'uint32',\n            name: 'maxL2GasPerBatch',\n            type: 'uint32',\n          },\n          {\n            internalType: 'uint32',\n            name: 'priorityTxMaxPubdata',\n            type: 'uint32',\n          },\n          {\n            internalType: 'uint64',\n            name: 'minimalL2GasPrice',\n            type: 'uint64',\n          },\n        ],\n        indexed: false,\n        internalType: 'struct FeeParams',\n        name: 'newFeeParams',\n        type: 'tuple',\n      },\n    ],\n    name: 'NewFeeParams',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'oldPendingAdmin',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'newPendingAdmin',\n        type: 'address',\n      },\n    ],\n    name: 'NewPendingAdmin',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'txId',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'bytes32',\n        name: 'txHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: false,\n        internalType: 'uint64',\n        name: 'expirationTimestamp',\n        type: 'uint64',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint256',\n            name: 'txType',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint256',\n            name: 'from',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint256',\n            name: 'to',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint256',\n            name: 'gasLimit',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint256',\n            name: 'gasPerPubdataByteLimit',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint256',\n            name: 'maxFeePerGas',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint256',\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint256',\n            name: 'paymaster',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint256',\n            name: 'nonce',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint256',\n            name: 'value',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint256[4]',\n            name: 'reserved',\n            type: 'uint256[4]',\n          },\n          {\n            internalType: 'bytes',\n            name: 'data',\n            type: 'bytes',\n          },\n          {\n            internalType: 'bytes',\n            name: 'signature',\n            type: 'bytes',\n          },\n          {\n            internalType: 'uint256[]',\n            name: 'factoryDeps',\n            type: 'uint256[]',\n          },\n          {\n            internalType: 'bytes',\n            name: 'paymasterInput',\n            type: 'bytes',\n          },\n          {\n            internalType: 'bytes',\n            name: 'reservedDynamic',\n            type: 'bytes',\n          },\n        ],\n        indexed: false,\n        internalType: 'struct L2CanonicalTransaction',\n        name: 'transaction',\n        type: 'tuple',\n      },\n      {\n        indexed: false,\n        internalType: 'bytes[]',\n        name: 'factoryDeps',\n        type: 'bytes[]',\n      },\n    ],\n    name: 'NewPriorityRequest',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'oldPriorityTxMaxGasLimit',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'newPriorityTxMaxGasLimit',\n        type: 'uint256',\n      },\n    ],\n    name: 'NewPriorityTxMaxGasLimit',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'oldTransactionFilterer',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'newTransactionFilterer',\n        type: 'address',\n      },\n    ],\n    name: 'NewTransactionFilterer',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              {\n                internalType: 'address',\n                name: 'facet',\n                type: 'address',\n              },\n              {\n                internalType: 'enum Diamond.Action',\n                name: 'action',\n                type: 'uint8',\n              },\n              {\n                internalType: 'bool',\n                name: 'isFreezable',\n                type: 'bool',\n              },\n              {\n                internalType: 'bytes4[]',\n                name: 'selectors',\n                type: 'bytes4[]',\n              },\n            ],\n            internalType: 'struct Diamond.FacetCut[]',\n            name: 'facetCuts',\n            type: 'tuple[]',\n          },\n          {\n            internalType: 'address',\n            name: 'initAddress',\n            type: 'address',\n          },\n          {\n            internalType: 'bytes',\n            name: 'initCalldata',\n            type: 'bytes',\n          },\n        ],\n        indexed: false,\n        internalType: 'struct Diamond.DiamondCutData',\n        name: 'diamondCut',\n        type: 'tuple',\n      },\n      {\n        indexed: true,\n        internalType: 'uint256',\n        name: 'proposalId',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'bytes32',\n        name: 'proposalSalt',\n        type: 'bytes32',\n      },\n    ],\n    name: 'ProposeTransparentUpgrade',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [],\n    name: 'Unfreeze',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'validatorAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'bool',\n        name: 'isActive',\n        type: 'bool',\n      },\n    ],\n    name: 'ValidatorStatusUpdate',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: 'enum PubdataPricingMode',\n        name: 'validiumMode',\n        type: 'uint8',\n      },\n    ],\n    name: 'ValidiumModeStatusUpdate',\n    type: 'event',\n  },\n  {\n    inputs: [],\n    name: 'acceptAdmin',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'baseTokenGasPriceMultiplierDenominator',\n    outputs: [\n      {\n        internalType: 'uint128',\n        name: '',\n        type: 'uint128',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'baseTokenGasPriceMultiplierNominator',\n    outputs: [\n      {\n        internalType: 'uint128',\n        name: '',\n        type: 'uint128',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'address',\n            name: 'sender',\n            type: 'address',\n          },\n          {\n            internalType: 'address',\n            name: 'contractL2',\n            type: 'address',\n          },\n          {\n            internalType: 'uint256',\n            name: 'mintValue',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint256',\n            name: 'l2Value',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes',\n            name: 'l2Calldata',\n            type: 'bytes',\n          },\n          {\n            internalType: 'uint256',\n            name: 'l2GasLimit',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint256',\n            name: 'l2GasPerPubdataByteLimit',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes[]',\n            name: 'factoryDeps',\n            type: 'bytes[]',\n          },\n          {\n            internalType: 'address',\n            name: 'refundRecipient',\n            type: 'address',\n          },\n        ],\n        internalType: 'struct BridgehubL2TransactionRequest',\n        name: '_request',\n        type: 'tuple',\n      },\n    ],\n    name: 'bridgehubRequestL2Transaction',\n    outputs: [\n      {\n        internalType: 'bytes32',\n        name: 'canonicalTxHash',\n        type: 'bytes32',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'enum PubdataPricingMode',\n            name: 'pubdataPricingMode',\n            type: 'uint8',\n          },\n          {\n            internalType: 'uint32',\n            name: 'batchOverheadL1Gas',\n            type: 'uint32',\n          },\n          {\n            internalType: 'uint32',\n            name: 'maxPubdataPerBatch',\n            type: 'uint32',\n          },\n          {\n            internalType: 'uint32',\n            name: 'maxL2GasPerBatch',\n            type: 'uint32',\n          },\n          {\n            internalType: 'uint32',\n            name: 'priorityTxMaxPubdata',\n            type: 'uint32',\n          },\n          {\n            internalType: 'uint64',\n            name: 'minimalL2GasPrice',\n            type: 'uint64',\n          },\n        ],\n        internalType: 'struct FeeParams',\n        name: '_newFeeParams',\n        type: 'tuple',\n      },\n    ],\n    name: 'changeFeeParams',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'batchNumber',\n            type: 'uint64',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'batchHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint64',\n            name: 'indexRepeatedStorageChanges',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint256',\n            name: 'numberOfLayer1Txs',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'priorityOperationsHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'l2LogsTreeRoot',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'timestamp',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'commitment',\n            type: 'bytes32',\n          },\n        ],\n        internalType: 'struct IExecutor.StoredBatchInfo',\n        name: '_lastCommittedBatchData',\n        type: 'tuple',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'batchNumber',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'timestamp',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'indexRepeatedStorageChanges',\n            type: 'uint64',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'newStateRoot',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'numberOfLayer1Txs',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'priorityOperationsHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'bootloaderHeapInitialContentsHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'eventsQueueStateHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes',\n            name: 'systemLogs',\n            type: 'bytes',\n          },\n          {\n            internalType: 'bytes',\n            name: 'pubdataCommitments',\n            type: 'bytes',\n          },\n        ],\n        internalType: 'struct IExecutor.CommitBatchInfo[]',\n        name: '_newBatchesData',\n        type: 'tuple[]',\n      },\n    ],\n    name: 'commitBatches',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_chainId',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'batchNumber',\n            type: 'uint64',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'batchHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint64',\n            name: 'indexRepeatedStorageChanges',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint256',\n            name: 'numberOfLayer1Txs',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'priorityOperationsHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'l2LogsTreeRoot',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'timestamp',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'commitment',\n            type: 'bytes32',\n          },\n        ],\n        internalType: 'struct IExecutor.StoredBatchInfo',\n        name: '_lastCommittedBatchData',\n        type: 'tuple',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'batchNumber',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'timestamp',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint64',\n            name: 'indexRepeatedStorageChanges',\n            type: 'uint64',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'newStateRoot',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'numberOfLayer1Txs',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'priorityOperationsHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'bootloaderHeapInitialContentsHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'eventsQueueStateHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes',\n            name: 'systemLogs',\n            type: 'bytes',\n          },\n          {\n            internalType: 'bytes',\n            name: 'pubdataCommitments',\n            type: 'bytes',\n          },\n        ],\n        internalType: 'struct IExecutor.CommitBatchInfo[]',\n        name: '_newBatchesData',\n        type: 'tuple[]',\n      },\n    ],\n    name: 'commitBatchesSharedBridge',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'batchNumber',\n            type: 'uint64',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'batchHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint64',\n            name: 'indexRepeatedStorageChanges',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint256',\n            name: 'numberOfLayer1Txs',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'priorityOperationsHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'l2LogsTreeRoot',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'timestamp',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'commitment',\n            type: 'bytes32',\n          },\n        ],\n        internalType: 'struct IExecutor.StoredBatchInfo[]',\n        name: '_batchesData',\n        type: 'tuple[]',\n      },\n    ],\n    name: 'executeBatches',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_chainId',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'batchNumber',\n            type: 'uint64',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'batchHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint64',\n            name: 'indexRepeatedStorageChanges',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint256',\n            name: 'numberOfLayer1Txs',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'priorityOperationsHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'l2LogsTreeRoot',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'timestamp',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'commitment',\n            type: 'bytes32',\n          },\n        ],\n        internalType: 'struct IExecutor.StoredBatchInfo[]',\n        name: '_batchesData',\n        type: 'tuple[]',\n      },\n    ],\n    name: 'executeBatchesSharedBridge',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              {\n                internalType: 'address',\n                name: 'facet',\n                type: 'address',\n              },\n              {\n                internalType: 'enum Diamond.Action',\n                name: 'action',\n                type: 'uint8',\n              },\n              {\n                internalType: 'bool',\n                name: 'isFreezable',\n                type: 'bool',\n              },\n              {\n                internalType: 'bytes4[]',\n                name: 'selectors',\n                type: 'bytes4[]',\n              },\n            ],\n            internalType: 'struct Diamond.FacetCut[]',\n            name: 'facetCuts',\n            type: 'tuple[]',\n          },\n          {\n            internalType: 'address',\n            name: 'initAddress',\n            type: 'address',\n          },\n          {\n            internalType: 'bytes',\n            name: 'initCalldata',\n            type: 'bytes',\n          },\n        ],\n        internalType: 'struct Diamond.DiamondCutData',\n        name: '_diamondCut',\n        type: 'tuple',\n      },\n    ],\n    name: 'executeUpgrade',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'bytes4',\n        name: '_selector',\n        type: 'bytes4',\n      },\n    ],\n    name: 'facetAddress',\n    outputs: [\n      {\n        internalType: 'address',\n        name: 'facet',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'facetAddresses',\n    outputs: [\n      {\n        internalType: 'address[]',\n        name: 'facets',\n        type: 'address[]',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_facet',\n        type: 'address',\n      },\n    ],\n    name: 'facetFunctionSelectors',\n    outputs: [\n      {\n        internalType: 'bytes4[]',\n        name: '',\n        type: 'bytes4[]',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'facets',\n    outputs: [\n      {\n        components: [\n          {\n            internalType: 'address',\n            name: 'addr',\n            type: 'address',\n          },\n          {\n            internalType: 'bytes4[]',\n            name: 'selectors',\n            type: 'bytes4[]',\n          },\n        ],\n        internalType: 'struct IGetters.Facet[]',\n        name: '',\n        type: 'tuple[]',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_l2BatchNumber',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2MessageIndex',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint16',\n        name: '_l2TxNumberInBatch',\n        type: 'uint16',\n      },\n      {\n        internalType: 'bytes',\n        name: '_message',\n        type: 'bytes',\n      },\n      {\n        internalType: 'bytes32[]',\n        name: '_merkleProof',\n        type: 'bytes32[]',\n      },\n    ],\n    name: 'finalizeEthWithdrawal',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'freezeDiamond',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getAdmin',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getBaseToken',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getBaseTokenBridge',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getBridgehub',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getFirstUnprocessedPriorityTx',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getL2BootloaderBytecodeHash',\n    outputs: [\n      {\n        internalType: 'bytes32',\n        name: '',\n        type: 'bytes32',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getL2DefaultAccountBytecodeHash',\n    outputs: [\n      {\n        internalType: 'bytes32',\n        name: '',\n        type: 'bytes32',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getL2SystemContractsUpgradeBatchNumber',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getL2SystemContractsUpgradeTxHash',\n    outputs: [\n      {\n        internalType: 'bytes32',\n        name: '',\n        type: 'bytes32',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getName',\n    outputs: [\n      {\n        internalType: 'string',\n        name: '',\n        type: 'string',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getPendingAdmin',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getPriorityQueueSize',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getPriorityTxMaxGasLimit',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getProtocolVersion',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getPubdataPricingMode',\n    outputs: [\n      {\n        internalType: 'enum PubdataPricingMode',\n        name: '',\n        type: 'uint8',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getSemverProtocolVersion',\n    outputs: [\n      {\n        internalType: 'uint32',\n        name: '',\n        type: 'uint32',\n      },\n      {\n        internalType: 'uint32',\n        name: '',\n        type: 'uint32',\n      },\n      {\n        internalType: 'uint32',\n        name: '',\n        type: 'uint32',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getStateTransitionManager',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getTotalBatchesCommitted',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getTotalBatchesExecuted',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getTotalBatchesVerified',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getTotalPriorityTxs',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getVerifier',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getVerifierParams',\n    outputs: [\n      {\n        components: [\n          {\n            internalType: 'bytes32',\n            name: 'recursionNodeLevelVkHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'recursionLeafLevelVkHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'recursionCircuitsSetVksHash',\n            type: 'bytes32',\n          },\n        ],\n        internalType: 'struct VerifierParams',\n        name: '',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'isDiamondStorageFrozen',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: '',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_l2BatchNumber',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2MessageIndex',\n        type: 'uint256',\n      },\n    ],\n    name: 'isEthWithdrawalFinalized',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: '',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_facet',\n        type: 'address',\n      },\n    ],\n    name: 'isFacetFreezable',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: 'isFreezable',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'bytes4',\n        name: '_selector',\n        type: 'bytes4',\n      },\n    ],\n    name: 'isFunctionFreezable',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: '',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_address',\n        type: 'address',\n      },\n    ],\n    name: 'isValidator',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: '',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_batchNumber',\n        type: 'uint256',\n      },\n    ],\n    name: 'l2LogsRootHash',\n    outputs: [\n      {\n        internalType: 'bytes32',\n        name: 'merkleRoot',\n        type: 'bytes32',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_gasPrice',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2GasLimit',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2GasPerPubdataByteLimit',\n        type: 'uint256',\n      },\n    ],\n    name: 'l2TransactionBaseCost',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'priorityQueueFrontOperation',\n    outputs: [\n      {\n        components: [\n          {\n            internalType: 'bytes32',\n            name: 'canonicalTxHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint64',\n            name: 'expirationTimestamp',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint192',\n            name: 'layer2Tip',\n            type: 'uint192',\n          },\n        ],\n        internalType: 'struct PriorityOperation',\n        name: '',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'batchNumber',\n            type: 'uint64',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'batchHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint64',\n            name: 'indexRepeatedStorageChanges',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint256',\n            name: 'numberOfLayer1Txs',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'priorityOperationsHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'l2LogsTreeRoot',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'timestamp',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'commitment',\n            type: 'bytes32',\n          },\n        ],\n        internalType: 'struct IExecutor.StoredBatchInfo',\n        name: '_prevBatch',\n        type: 'tuple',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'batchNumber',\n            type: 'uint64',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'batchHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint64',\n            name: 'indexRepeatedStorageChanges',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint256',\n            name: 'numberOfLayer1Txs',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'priorityOperationsHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'l2LogsTreeRoot',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'timestamp',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'commitment',\n            type: 'bytes32',\n          },\n        ],\n        internalType: 'struct IExecutor.StoredBatchInfo[]',\n        name: '_committedBatches',\n        type: 'tuple[]',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint256[]',\n            name: 'recursiveAggregationInput',\n            type: 'uint256[]',\n          },\n          {\n            internalType: 'uint256[]',\n            name: 'serializedProof',\n            type: 'uint256[]',\n          },\n        ],\n        internalType: 'struct IExecutor.ProofInput',\n        name: '_proof',\n        type: 'tuple',\n      },\n    ],\n    name: 'proveBatches',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_chainId',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'batchNumber',\n            type: 'uint64',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'batchHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint64',\n            name: 'indexRepeatedStorageChanges',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint256',\n            name: 'numberOfLayer1Txs',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'priorityOperationsHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'l2LogsTreeRoot',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'timestamp',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'commitment',\n            type: 'bytes32',\n          },\n        ],\n        internalType: 'struct IExecutor.StoredBatchInfo',\n        name: '_prevBatch',\n        type: 'tuple',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint64',\n            name: 'batchNumber',\n            type: 'uint64',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'batchHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint64',\n            name: 'indexRepeatedStorageChanges',\n            type: 'uint64',\n          },\n          {\n            internalType: 'uint256',\n            name: 'numberOfLayer1Txs',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'priorityOperationsHash',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'l2LogsTreeRoot',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'timestamp',\n            type: 'uint256',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'commitment',\n            type: 'bytes32',\n          },\n        ],\n        internalType: 'struct IExecutor.StoredBatchInfo[]',\n        name: '_committedBatches',\n        type: 'tuple[]',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint256[]',\n            name: 'recursiveAggregationInput',\n            type: 'uint256[]',\n          },\n          {\n            internalType: 'uint256[]',\n            name: 'serializedProof',\n            type: 'uint256[]',\n          },\n        ],\n        internalType: 'struct IExecutor.ProofInput',\n        name: '_proof',\n        type: 'tuple',\n      },\n    ],\n    name: 'proveBatchesSharedBridge',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'bytes32',\n        name: '_l2TxHash',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2BatchNumber',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2MessageIndex',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint16',\n        name: '_l2TxNumberInBatch',\n        type: 'uint16',\n      },\n      {\n        internalType: 'bytes32[]',\n        name: '_merkleProof',\n        type: 'bytes32[]',\n      },\n      {\n        internalType: 'enum TxStatus',\n        name: '_status',\n        type: 'uint8',\n      },\n    ],\n    name: 'proveL1ToL2TransactionStatus',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: '',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_batchNumber',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_index',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint8',\n            name: 'l2ShardId',\n            type: 'uint8',\n          },\n          {\n            internalType: 'bool',\n            name: 'isService',\n            type: 'bool',\n          },\n          {\n            internalType: 'uint16',\n            name: 'txNumberInBatch',\n            type: 'uint16',\n          },\n          {\n            internalType: 'address',\n            name: 'sender',\n            type: 'address',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'key',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'value',\n            type: 'bytes32',\n          },\n        ],\n        internalType: 'struct L2Log',\n        name: '_log',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes32[]',\n        name: '_proof',\n        type: 'bytes32[]',\n      },\n    ],\n    name: 'proveL2LogInclusion',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: '',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_batchNumber',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_index',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            internalType: 'uint16',\n            name: 'txNumberInBatch',\n            type: 'uint16',\n          },\n          {\n            internalType: 'address',\n            name: 'sender',\n            type: 'address',\n          },\n          {\n            internalType: 'bytes',\n            name: 'data',\n            type: 'bytes',\n          },\n        ],\n        internalType: 'struct L2Message',\n        name: '_message',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes32[]',\n        name: '_proof',\n        type: 'bytes32[]',\n      },\n    ],\n    name: 'proveL2MessageInclusion',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: '',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_contractL2',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2Value',\n        type: 'uint256',\n      },\n      {\n        internalType: 'bytes',\n        name: '_calldata',\n        type: 'bytes',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2GasLimit',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_l2GasPerPubdataByteLimit',\n        type: 'uint256',\n      },\n      {\n        internalType: 'bytes[]',\n        name: '_factoryDeps',\n        type: 'bytes[]',\n      },\n      {\n        internalType: 'address',\n        name: '_refundRecipient',\n        type: 'address',\n      },\n    ],\n    name: 'requestL2Transaction',\n    outputs: [\n      {\n        internalType: 'bytes32',\n        name: 'canonicalTxHash',\n        type: 'bytes32',\n      },\n    ],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_newLastBatch',\n        type: 'uint256',\n      },\n    ],\n    name: 'revertBatches',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_chainId',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: '_newLastBatch',\n        type: 'uint256',\n      },\n    ],\n    name: 'revertBatchesSharedBridge',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_newPendingAdmin',\n        type: 'address',\n      },\n    ],\n    name: 'setPendingAdmin',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'bool',\n        name: '_zkPorterIsAvailable',\n        type: 'bool',\n      },\n    ],\n    name: 'setPorterAvailability',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_newPriorityTxMaxGasLimit',\n        type: 'uint256',\n      },\n    ],\n    name: 'setPriorityTxMaxGasLimit',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'enum PubdataPricingMode',\n        name: '_pricingMode',\n        type: 'uint8',\n      },\n    ],\n    name: 'setPubdataPricingMode',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint128',\n        name: '_nominator',\n        type: 'uint128',\n      },\n      {\n        internalType: 'uint128',\n        name: '_denominator',\n        type: 'uint128',\n      },\n    ],\n    name: 'setTokenMultiplier',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_transactionFilterer',\n        type: 'address',\n      },\n    ],\n    name: 'setTransactionFilterer',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_validator',\n        type: 'address',\n      },\n      {\n        internalType: 'bool',\n        name: '_active',\n        type: 'bool',\n      },\n    ],\n    name: 'setValidator',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_batchNumber',\n        type: 'uint256',\n      },\n    ],\n    name: 'storedBatchHash',\n    outputs: [\n      {\n        internalType: 'bytes32',\n        name: '',\n        type: 'bytes32',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'transferEthToSharedBridge',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'unfreezeDiamond',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_protocolVersion',\n        type: 'uint256',\n      },\n      {\n        components: [\n          {\n            components: [\n              {\n                internalType: 'address',\n                name: 'facet',\n                type: 'address',\n              },\n              {\n                internalType: 'enum Diamond.Action',\n                name: 'action',\n                type: 'uint8',\n              },\n              {\n                internalType: 'bool',\n                name: 'isFreezable',\n                type: 'bool',\n              },\n              {\n                internalType: 'bytes4[]',\n                name: 'selectors',\n                type: 'bytes4[]',\n              },\n            ],\n            internalType: 'struct Diamond.FacetCut[]',\n            name: 'facetCuts',\n            type: 'tuple[]',\n          },\n          {\n            internalType: 'address',\n            name: 'initAddress',\n            type: 'address',\n          },\n          {\n            internalType: 'bytes',\n            name: 'initCalldata',\n            type: 'bytes',\n          },\n        ],\n        internalType: 'struct Diamond.DiamondCutData',\n        name: '_cutData',\n        type: 'tuple',\n      },\n    ],\n    name: 'upgradeChainFromVersion',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n] as const\n","import {\n    createRpcSubscriptionsApi,\n    executeRpcPubSubSubscriptionPlan,\n    RpcSubscriptionsApi,\n    RpcSubscriptionsApiMethods,\n} from '@solana/rpc-subscriptions-spec';\nimport {\n    AllowedNumericKeypaths,\n    getDefaultRequestTransformerForSolanaRpc,\n    getDefaultResponseTransformerForSolanaRpcSubscriptions,\n    jsonParsedAccountsConfigs,\n    KEYPATH_WILDCARD,\n    RequestTransformerConfig,\n} from '@solana/rpc-transformers';\n\nimport { AccountNotificationsApi } from './account-notifications';\nimport { BlockNotificationsApi } from './block-notifications';\nimport { LogsNotificationsApi } from './logs-notifications';\nimport { ProgramNotificationsApi } from './program-notifications';\nimport { RootNotificationsApi } from './root-notifications';\nimport { SignatureNotificationsApi } from './signature-notifications';\nimport { SlotNotificationsApi } from './slot-notifications';\nimport { SlotsUpdatesNotificationsApi } from './slots-updates-notifications';\nimport { VoteNotificationsApi } from './vote-notifications';\n\nexport type SolanaRpcSubscriptionsApi = AccountNotificationsApi &\n    LogsNotificationsApi &\n    ProgramNotificationsApi &\n    RootNotificationsApi &\n    SignatureNotificationsApi &\n    SlotNotificationsApi;\nexport type SolanaRpcSubscriptionsApiUnstable = BlockNotificationsApi &\n    SlotsUpdatesNotificationsApi &\n    VoteNotificationsApi;\n\nexport type {\n    AccountNotificationsApi,\n    BlockNotificationsApi,\n    LogsNotificationsApi,\n    ProgramNotificationsApi,\n    RootNotificationsApi,\n    SignatureNotificationsApi,\n    SlotNotificationsApi,\n    SlotsUpdatesNotificationsApi,\n    VoteNotificationsApi,\n};\n\ntype Config = RequestTransformerConfig;\n\nfunction createSolanaRpcSubscriptionsApi_INTERNAL<TApi extends RpcSubscriptionsApiMethods>(\n    config?: Config,\n): RpcSubscriptionsApi<TApi> {\n    const requestTransformer = getDefaultRequestTransformerForSolanaRpc(config);\n    const responseTransformer = getDefaultResponseTransformerForSolanaRpcSubscriptions({\n        allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n    });\n    return createRpcSubscriptionsApi<TApi>({\n        planExecutor({ request, ...rest }) {\n            return executeRpcPubSubSubscriptionPlan({\n                ...rest,\n                responseTransformer,\n                subscribeRequest: { ...request, methodName: request.methodName.replace(/Notifications$/, 'Subscribe') },\n                unsubscribeMethodName: request.methodName.replace(/Notifications$/, 'Unsubscribe'),\n            });\n        },\n        requestTransformer,\n    });\n}\n\nexport function createSolanaRpcSubscriptionsApi<TApi extends RpcSubscriptionsApiMethods = SolanaRpcSubscriptionsApi>(\n    config?: Config,\n): RpcSubscriptionsApi<TApi> {\n    return createSolanaRpcSubscriptionsApi_INTERNAL<TApi>(config);\n}\n\nexport function createSolanaRpcSubscriptionsApi_UNSTABLE(config?: Config) {\n    return createSolanaRpcSubscriptionsApi_INTERNAL<SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>(\n        config,\n    );\n}\n\nlet memoizedKeypaths: AllowedNumericKeypaths<\n    RpcSubscriptionsApi<SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>\n>;\n\n/**\n * These are keypaths at the end of which you will find a numeric value that should *not* be upcast\n * to a `bigint`. These are values that are legitimately defined as `u8` or `usize` on the backend.\n */\nfunction getAllowedNumericKeypaths(): AllowedNumericKeypaths<\n    RpcSubscriptionsApi<SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>\n> {\n    if (!memoizedKeypaths) {\n        memoizedKeypaths = {\n            accountNotifications: jsonParsedAccountsConfigs.map(c => ['value', ...c]),\n            blockNotifications: [\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'preTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'accountIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'preTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'postTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'accountIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'postTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['value', 'block', 'transactions', KEYPATH_WILDCARD, 'meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    'index',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'programIdIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'accounts',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'addressTableLookups',\n                    KEYPATH_WILDCARD,\n                    'writableIndexes',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'addressTableLookups',\n                    KEYPATH_WILDCARD,\n                    'readonlyIndexes',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'programIdIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'accounts',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'header',\n                    'numReadonlySignedAccounts',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'header',\n                    'numReadonlyUnsignedAccounts',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'header',\n                    'numRequiredSignatures',\n                ],\n                ['value', 'block', 'rewards', KEYPATH_WILDCARD, 'commission'],\n            ],\n            programNotifications: jsonParsedAccountsConfigs.flatMap(c => [\n                ['value', KEYPATH_WILDCARD, 'account', ...c],\n                [KEYPATH_WILDCARD, 'account', ...c],\n            ]),\n        };\n    }\n    return memoizedKeypaths;\n}\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/sign/walletlink/relay/WalletLinkRelay.ts","import type { AppKitOptions, CaipNetwork, CaipNetworkId } from \"@reown/appkit\";\nimport type { WalletConnectModalConfig, Assign, ChainFormatters, Prettify } from \"./types.js\";\nimport type { AppKitNetwork } from \"@reown/appkit/networks\";\nimport type { EthereumProviderOptions } from \"./EthereumProvider.js\";\n\nfunction convertThemeVariables(\n  wcmTheme?: WalletConnectModalConfig[\"themeVariables\"],\n): AppKitOptions[\"themeVariables\"] | undefined {\n  if (!wcmTheme) return undefined;\n\n  return {\n    \"--w3m-font-family\": wcmTheme[\"--wcm-font-family\"],\n    \"--w3m-accent\": wcmTheme[\"--wcm-accent-color\"],\n    \"--w3m-color-mix\": wcmTheme[\"--wcm-background-color\"],\n    \"--w3m-z-index\": wcmTheme[\"--wcm-z-index\"] ? Number(wcmTheme[\"--wcm-z-index\"]) : undefined,\n\n    \"--w3m-qr-color\": wcmTheme[\"--wcm-accent-color\"],\n\n    \"--w3m-font-size-master\": wcmTheme[\"--wcm-text-medium-regular-size\"],\n    \"--w3m-border-radius-master\": wcmTheme[\"--wcm-container-border-radius\"],\n    \"--w3m-color-mix-strength\": 0,\n  };\n}\n\nconst mapCaipIdToAppKitCaipNetwork = (caipId: CaipNetworkId): CaipNetwork => {\n  const [namespace, chainId] = caipId.split(\":\");\n  const chain = defineChain({\n    id: chainId,\n    caipNetworkId: caipId,\n    chainNamespace: namespace as CaipNetwork[\"chainNamespace\"],\n    name: \"\",\n    nativeCurrency: {\n      name: \"\",\n      symbol: \"\",\n      decimals: 8,\n    },\n    rpcUrls: {\n      default: { http: [\"https://rpc.walletconnect.org/v1\"] },\n    },\n  });\n\n  return chain as CaipNetwork;\n};\n\nexport function convertWCMToAppKitOptions(\n  wcmConfig: WalletConnectModalConfig & { metadata?: EthereumProviderOptions[\"metadata\"] },\n): AppKitOptions {\n  // Convert chains toCaipNetwork format\n  const networks: CaipNetwork[] = (wcmConfig.chains as CaipNetworkId[])\n    ?.map(mapCaipIdToAppKitCaipNetwork)\n    .filter(Boolean);\n\n  // Ensure at least one network is present\n  if (networks.length === 0) {\n    throw new Error(\"At least one chain must be specified\");\n  }\n\n  const defaultNetwork = networks.find((network) => network.id === wcmConfig.defaultChain?.id);\n  const appKitOptions: AppKitOptions = {\n    projectId: wcmConfig.projectId,\n    networks: networks as [AppKitNetwork, ...AppKitNetwork[]],\n    themeMode: wcmConfig.themeMode,\n    themeVariables: convertThemeVariables(wcmConfig.themeVariables),\n    chainImages: wcmConfig.chainImages,\n    connectorImages: wcmConfig.walletImages,\n    defaultNetwork,\n    metadata: {\n      ...wcmConfig.metadata,\n      name: wcmConfig.metadata?.name || \"WalletConnect\",\n      description: wcmConfig.metadata?.description || \"Connect to WalletConnect-compatible wallets\",\n      url: wcmConfig.metadata?.url || \"https://walletconnect.org\",\n      icons: wcmConfig.metadata?.icons || [\"https://walletconnect.org/walletconnect-logo.png\"],\n    },\n    showWallets: true,\n    // Explorer options mapping\n    featuredWalletIds:\n      wcmConfig.explorerRecommendedWalletIds === \"NONE\"\n        ? []\n        : Array.isArray(wcmConfig.explorerRecommendedWalletIds)\n          ? wcmConfig.explorerRecommendedWalletIds\n          : [],\n\n    excludeWalletIds:\n      wcmConfig.explorerExcludedWalletIds === \"ALL\"\n        ? []\n        : Array.isArray(wcmConfig.explorerExcludedWalletIds)\n          ? wcmConfig.explorerExcludedWalletIds\n          : [],\n\n    // Additional AppKit-specific options that don't have direct WCM equivalents\n    enableEIP6963: false, // Disable 6963 by default\n    enableInjected: false, // Disable injected by default\n    enableCoinbase: true, // Default to true\n    enableWalletConnect: true, // Default to true,\n    features: {\n      email: false,\n      socials: false,\n    },\n  };\n\n  // Add mobile and desktop wallets as custom wallets if provided\n  if (wcmConfig.mobileWallets?.length || wcmConfig.desktopWallets?.length) {\n    const customWallets = [\n      ...(wcmConfig.mobileWallets || []).map((wallet) => ({\n        id: wallet.id,\n        name: wallet.name,\n        links: wallet.links,\n      })),\n      ...(wcmConfig.desktopWallets || []).map((wallet) => ({\n        id: wallet.id,\n        name: wallet.name,\n        links: {\n          native: wallet.links.native,\n          universal: wallet.links.universal,\n        },\n      })),\n    ];\n\n    const allWallets = [\n      ...(appKitOptions.featuredWalletIds || []),\n      ...(appKitOptions.excludeWalletIds || []),\n    ];\n\n    // Only add a custom wallet if it's not on the other lists\n    const uniqueCustomWallets = customWallets.filter((wallet) => !allWallets.includes(wallet.id));\n\n    if (uniqueCustomWallets.length) {\n      appKitOptions.customWallets = uniqueCustomWallets;\n    }\n  }\n\n  return appKitOptions;\n}\n\nexport function defineChain<\n  formatters extends ChainFormatters,\n  const chain extends CaipNetwork<formatters>,\n>(chain: chain): Prettify<Assign<CaipNetwork<undefined>, chain>> {\n  return {\n    formatters: undefined,\n    fees: undefined,\n    serializers: undefined,\n    ...chain,\n  } as Assign<CaipNetwork<undefined>, chain>;\n}\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/sign/walletlink/relay/connection/WalletLinkCipher.ts","import { safeCaptureStackTrace, SOLANA_ERROR__RPC__INTEGER_OVERFLOW, SolanaError } from '@solana/errors';\nimport type { KeyPath } from '@solana/rpc-transformers';\n\nexport function createSolanaJsonRpcIntegerOverflowError(\n    methodName: string,\n    keyPath: KeyPath,\n    value: bigint,\n): SolanaError<typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW> {\n    let argumentLabel = '';\n    if (typeof keyPath[0] === 'number') {\n        const argPosition = keyPath[0] + 1;\n        const lastDigit = argPosition % 10;\n        const lastTwoDigits = argPosition % 100;\n        if (lastDigit == 1 && lastTwoDigits != 11) {\n            argumentLabel = argPosition + 'st';\n        } else if (lastDigit == 2 && lastTwoDigits != 12) {\n            argumentLabel = argPosition + 'nd';\n        } else if (lastDigit == 3 && lastTwoDigits != 13) {\n            argumentLabel = argPosition + 'rd';\n        } else {\n            argumentLabel = argPosition + 'th';\n        }\n    } else {\n        argumentLabel = `\\`${keyPath[0].toString()}\\``;\n    }\n    const path =\n        keyPath.length > 1\n            ? keyPath\n                  .slice(1)\n                  .map(pathPart => (typeof pathPart === 'number' ? `[${pathPart}]` : pathPart))\n                  .join('.')\n            : undefined;\n    const error = new SolanaError(SOLANA_ERROR__RPC__INTEGER_OVERFLOW, {\n        argumentLabel,\n        keyPath: keyPath as readonly (number | string | symbol)[],\n        methodName,\n        optionalPathLabel: path ? ` at path \\`${path}\\`` : '',\n        value,\n        ...(path !== undefined ? { path } : undefined),\n    });\n    safeCaptureStackTrace(error, createSolanaJsonRpcIntegerOverflowError);\n    return error;\n}\n","import type * as Address from './Address.js'\nimport { LruMap } from './internal/lru.js'\n\nconst caches = {\n  checksum: /*#__PURE__*/ new LruMap<Address.Address>(8192),\n}\n\nexport const checksum = caches.checksum\n\n/**\n * Clears all global caches.\n *\n * @example\n * ```ts\n * import { Caches } from 'ox'\n * Caches.clear()\n * ```\n */\nexport function clear() {\n  for (const cache of Object.values(caches)) cache.clear()\n}\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/core/storage/ScopedLocalStorage.ts","import {\n  PaymentPayloadSchema,\n  SupportedEVMNetworks,\n  SupportedSVMNetworks,\n  authorizationTypes,\n  getNetworkId,\n  getRpcClient,\n  isAccount,\n  isSignerWallet,\n  safeBase64Decode,\n  safeBase64Encode\n} from \"./chunk-3EQVFRKV.mjs\";\nimport {\n  __require\n} from \"./chunk-EMSAO3AI.mjs\";\n\n// src/schemes/exact/evm/utils/paymentUtils.ts\nfunction encodePayment(payment) {\n  let safe;\n  if (SupportedEVMNetworks.includes(payment.network)) {\n    const evmPayload = payment.payload;\n    safe = {\n      ...payment,\n      payload: {\n        ...evmPayload,\n        authorization: Object.fromEntries(\n          Object.entries(evmPayload.authorization).map(([key, value]) => [\n            key,\n            typeof value === \"bigint\" ? value.toString() : value\n          ])\n        )\n      }\n    };\n    return safeBase64Encode(JSON.stringify(safe));\n  }\n  if (SupportedSVMNetworks.includes(payment.network)) {\n    safe = { ...payment, payload: payment.payload };\n    return safeBase64Encode(JSON.stringify(safe));\n  }\n  throw new Error(\"Invalid network\");\n}\nfunction decodePayment(payment) {\n  const decoded = safeBase64Decode(payment);\n  const parsed = JSON.parse(decoded);\n  let obj;\n  if (SupportedEVMNetworks.includes(parsed.network)) {\n    obj = {\n      ...parsed,\n      payload: parsed.payload\n    };\n  } else if (SupportedSVMNetworks.includes(parsed.network)) {\n    obj = {\n      ...parsed,\n      payload: parsed.payload\n    };\n  } else {\n    throw new Error(\"Invalid network\");\n  }\n  const validated = PaymentPayloadSchema.parse(obj);\n  return validated;\n}\n\n// src/schemes/exact/evm/sign.ts\nimport { getAddress, toHex } from \"viem\";\nasync function signAuthorization(walletClient, { from, to, value, validAfter, validBefore, nonce }, { asset, network, extra }) {\n  const chainId = getNetworkId(network);\n  const name = extra?.name;\n  const version = extra?.version;\n  const data = {\n    types: authorizationTypes,\n    domain: {\n      name,\n      version,\n      chainId,\n      verifyingContract: getAddress(asset)\n    },\n    primaryType: \"TransferWithAuthorization\",\n    message: {\n      from: getAddress(from),\n      to: getAddress(to),\n      value,\n      validAfter,\n      validBefore,\n      nonce\n    }\n  };\n  if (isSignerWallet(walletClient)) {\n    const signature = await walletClient.signTypedData(data);\n    return {\n      signature\n    };\n  } else if (isAccount(walletClient) && walletClient.signTypedData) {\n    const signature = await walletClient.signTypedData(data);\n    return {\n      signature\n    };\n  } else {\n    throw new Error(\"Invalid wallet client provided does not support signTypedData\");\n  }\n}\nfunction createNonce() {\n  const cryptoObj = typeof globalThis.crypto !== \"undefined\" && typeof globalThis.crypto.getRandomValues === \"function\" ? globalThis.crypto : (\n    // Dynamic require is needed to support node.js\n    // eslint-disable-next-line @typescript-eslint/no-require-imports\n    __require(\"crypto\").webcrypto\n  );\n  return toHex(cryptoObj.getRandomValues(new Uint8Array(32)));\n}\n\n// src/schemes/exact/evm/client.ts\nfunction preparePaymentHeader(from, x402Version, paymentRequirements) {\n  const nonce = createNonce();\n  const validAfter = BigInt(\n    Math.floor(Date.now() / 1e3) - 600\n    // 10 minutes before\n  ).toString();\n  const validBefore = BigInt(\n    Math.floor(Date.now() / 1e3 + paymentRequirements.maxTimeoutSeconds)\n  ).toString();\n  return {\n    x402Version,\n    scheme: paymentRequirements.scheme,\n    network: paymentRequirements.network,\n    payload: {\n      signature: void 0,\n      authorization: {\n        from,\n        to: paymentRequirements.payTo,\n        value: paymentRequirements.maxAmountRequired,\n        validAfter: validAfter.toString(),\n        validBefore: validBefore.toString(),\n        nonce\n      }\n    }\n  };\n}\nasync function signPaymentHeader(client, paymentRequirements, unsignedPaymentHeader) {\n  const { signature } = await signAuthorization(\n    client,\n    unsignedPaymentHeader.payload.authorization,\n    paymentRequirements\n  );\n  return {\n    ...unsignedPaymentHeader,\n    payload: {\n      ...unsignedPaymentHeader.payload,\n      signature\n    }\n  };\n}\nasync function createPayment(client, x402Version, paymentRequirements) {\n  const from = isSignerWallet(client) ? client.account.address : client.address;\n  const unsignedPaymentHeader = preparePaymentHeader(from, x402Version, paymentRequirements);\n  return signPaymentHeader(client, paymentRequirements, unsignedPaymentHeader);\n}\nasync function createPaymentHeader(client, x402Version, paymentRequirements) {\n  const payment = await createPayment(client, x402Version, paymentRequirements);\n  return encodePayment(payment);\n}\n\n// src/schemes/exact/svm/client.ts\nimport {\n  pipe,\n  createTransactionMessage,\n  setTransactionMessageFeePayer,\n  setTransactionMessageLifetimeUsingBlockhash,\n  appendTransactionMessageInstructions,\n  partiallySignTransactionMessageWithSigners,\n  prependTransactionMessageInstruction,\n  getBase64EncodedWireTransaction\n} from \"@solana/kit\";\nimport {\n  fetchMint,\n  findAssociatedTokenPda,\n  getTransferCheckedInstruction,\n  TOKEN_2022_PROGRAM_ADDRESS\n} from \"@solana-program/token-2022\";\nimport { TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\nimport {\n  estimateComputeUnitLimitFactory,\n  getSetComputeUnitLimitInstruction,\n  setTransactionMessageComputeUnitPrice\n} from \"@solana-program/compute-budget\";\nasync function createPaymentHeader2(client, x402Version, paymentRequirements, config) {\n  const paymentPayload = await createAndSignPayment(\n    client,\n    x402Version,\n    paymentRequirements,\n    config\n  );\n  return encodePayment(paymentPayload);\n}\nasync function createAndSignPayment(client, x402Version, paymentRequirements, config) {\n  const transactionMessage = await createTransferTransactionMessage(\n    client,\n    paymentRequirements,\n    config\n  );\n  const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage);\n  const base64EncodedWireTransaction = getBase64EncodedWireTransaction(signedTransaction);\n  return {\n    scheme: paymentRequirements.scheme,\n    network: paymentRequirements.network,\n    x402Version,\n    payload: {\n      transaction: base64EncodedWireTransaction\n    }\n  };\n}\nasync function createTransferTransactionMessage(client, paymentRequirements, config) {\n  const rpc = getRpcClient(paymentRequirements.network, config?.svmConfig?.rpcUrl);\n  const transferInstructions = await createTransferInstructions(\n    client,\n    paymentRequirements,\n    config\n  );\n  const feePayer = paymentRequirements.extra?.feePayer;\n  const txToSimulate = pipe(\n    createTransactionMessage({ version: 0 }),\n    (tx2) => setTransactionMessageComputeUnitPrice(1, tx2),\n    // 1 microlamport priority fee\n    (tx2) => setTransactionMessageFeePayer(feePayer, tx2),\n    (tx2) => appendTransactionMessageInstructions(transferInstructions, tx2)\n  );\n  const estimateComputeUnitLimit = estimateComputeUnitLimitFactory({ rpc });\n  const estimatedUnits = await estimateComputeUnitLimit(txToSimulate);\n  const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n  const tx = pipe(\n    txToSimulate,\n    (tx2) => prependTransactionMessageInstruction(\n      getSetComputeUnitLimitInstruction({ units: estimatedUnits }),\n      tx2\n    ),\n    (tx2) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx2)\n  );\n  return tx;\n}\nasync function createTransferInstructions(client, paymentRequirements, config) {\n  const { asset, maxAmountRequired: amount, payTo } = paymentRequirements;\n  const rpc = getRpcClient(paymentRequirements.network, config?.svmConfig?.rpcUrl);\n  const tokenMint = await fetchMint(rpc, asset);\n  const tokenProgramAddress = tokenMint.programAddress;\n  if (tokenProgramAddress.toString() !== TOKEN_PROGRAM_ADDRESS.toString() && tokenProgramAddress.toString() !== TOKEN_2022_PROGRAM_ADDRESS.toString()) {\n    throw new Error(\"Asset was not created by a known token program\");\n  }\n  const [sourceATA] = await findAssociatedTokenPda({\n    mint: asset,\n    owner: client.address,\n    tokenProgram: tokenProgramAddress\n  });\n  const [destinationATA] = await findAssociatedTokenPda({\n    mint: asset,\n    owner: payTo,\n    tokenProgram: tokenProgramAddress\n  });\n  const transferIx = getTransferCheckedInstruction(\n    {\n      source: sourceATA,\n      mint: asset,\n      destination: destinationATA,\n      authority: client,\n      amount: BigInt(amount),\n      decimals: tokenMint.data.decimals\n    },\n    { programAddress: tokenProgramAddress }\n  );\n  return [transferIx];\n}\n\nexport {\n  encodePayment,\n  decodePayment,\n  preparePaymentHeader,\n  signPaymentHeader,\n  createPayment,\n  createPaymentHeader,\n  createPaymentHeader2,\n  createAndSignPayment\n};\n//# sourceMappingURL=chunk-SQV4BQTM.mjs.map","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/sign/walletlink/relay/ui/WalletLinkRelayUI.ts","export const CORE_PROTOCOL = \"wc\";\nexport const CORE_VERSION = 2;\nexport const CORE_CONTEXT = \"core\";\n\nexport const CORE_STORAGE_PREFIX = `${CORE_PROTOCOL}@${CORE_VERSION}:${CORE_CONTEXT}:`;\n\nexport const CORE_DEFAULT = {\n  name: CORE_CONTEXT,\n  logger: \"error\",\n};\n\nexport const CORE_STORAGE_OPTIONS = {\n  database: \":memory:\",\n};\n","import { FIVE_MINUTES, ONE_DAY, ONE_HOUR, SEVEN_DAYS } from \"@walletconnect/time\";\nimport { EngineTypes } from \"@walletconnect/types\";\n\nexport const ENGINE_CONTEXT = \"engine\";\n\nexport const ENGINE_RPC_OPTS: EngineTypes.RpcOptsMap = {\n  wc_sessionPropose: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1100,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1101,\n    },\n    reject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1120,\n    },\n    autoReject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1121,\n    },\n  },\n  wc_sessionSettle: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1102,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1103,\n    },\n  },\n  wc_sessionUpdate: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1104,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1105,\n    },\n  },\n  wc_sessionExtend: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1106,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1107,\n    },\n  },\n  wc_sessionRequest: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1108,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1109,\n    },\n  },\n  wc_sessionEvent: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1110,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1111,\n    },\n  },\n\n  wc_sessionDelete: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1112,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1113,\n    },\n  },\n  wc_sessionPing: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1114,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1115,\n    },\n  },\n  wc_sessionAuthenticate: {\n    req: {\n      ttl: ONE_HOUR,\n      prompt: true,\n      tag: 1116,\n    },\n    res: {\n      ttl: ONE_HOUR,\n      prompt: false,\n      tag: 1117,\n    },\n    reject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1118,\n    },\n    autoReject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1119,\n    },\n  },\n};\n\nexport const SESSION_REQUEST_EXPIRY_BOUNDARIES = {\n  min: FIVE_MINUTES,\n  max: SEVEN_DAYS,\n};\n\nexport const ENGINE_QUEUE_STATES: { idle: \"IDLE\"; active: \"ACTIVE\" } = {\n  idle: \"IDLE\",\n  active: \"ACTIVE\",\n};\n\nexport const TVF_METHODS = {\n  // evm\n  eth_sendTransaction: {\n    key: \"\",\n  },\n  eth_sendRawTransaction: {\n    key: \"\",\n  },\n  wallet_sendCalls: {\n    key: \"\",\n  },\n\n  // solana\n  solana_signTransaction: {\n    key: \"signature\",\n  },\n  solana_signAllTransactions: {\n    key: \"transactions\",\n  },\n  solana_signAndSendTransaction: {\n    key: \"signature\",\n  },\n\n  // sui\n  sui_signAndExecuteTransaction: {\n    key: \"digest\",\n  },\n  sui_signTransaction: {\n    key: \"\",\n  },\n\n  // hedera\n  hedera_signAndExecuteTransaction: {\n    key: \"transactionId\",\n  },\n  hedera_executeTransaction: {\n    key: \"transactionId\",\n  },\n\n  // near\n  near_signTransaction: {\n    key: \"\",\n  },\n  near_signTransactions: {\n    key: \"\",\n  },\n\n  // tron\n  tron_signTransaction: {\n    key: \"txID\",\n  },\n\n  // xrpl\n  xrpl_signTransaction: {\n    key: \"\",\n  },\n\n  xrpl_signTransactionFor: {\n    key: \"\",\n  },\n\n  // algorand\n  algo_signTxn: {\n    key: \"\",\n  },\n\n  // bitcoin\n  sendTransfer: {\n    key: \"txid\",\n  },\n\n  // stacks\n  stacks_stxTransfer: {\n    key: \"txId\",\n  },\n\n  // polkadot\n  polkadot_signTransaction: {\n    key: \"\",\n  },\n\n  // cosmos\n  cosmos_signDirect: {\n    key: \"\",\n  },\n};\n","import { toHex } from '../../utils/encoding/toHex.js'\nimport { gasPerPubdataDefault } from '../constants/number.js'\nimport type { EIP712DomainFn } from '../types/eip712.js'\nimport type {\n  ZksyncEIP712TransactionSignable,\n  ZksyncTransactionSerializable,\n  ZksyncTransactionSerializableEIP712,\n} from '../types/transaction.js'\nimport { assertEip712Transaction } from './assertEip712Transaction.js'\nimport { hashBytecode } from './hashBytecode.js'\n\nexport const getEip712Domain: EIP712DomainFn<\n  ZksyncTransactionSerializable,\n  ZksyncEIP712TransactionSignable\n> = (transaction) => {\n  assertEip712Transaction(transaction)\n\n  const message = transactionToMessage(\n    transaction as ZksyncTransactionSerializableEIP712,\n  )\n\n  return {\n    domain: {\n      name: 'zkSync',\n      version: '2',\n      chainId: transaction.chainId,\n    },\n    types: {\n      Transaction: [\n        { name: 'txType', type: 'uint256' },\n        { name: 'from', type: 'uint256' },\n        { name: 'to', type: 'uint256' },\n        { name: 'gasLimit', type: 'uint256' },\n        { name: 'gasPerPubdataByteLimit', type: 'uint256' },\n        { name: 'maxFeePerGas', type: 'uint256' },\n        { name: 'maxPriorityFeePerGas', type: 'uint256' },\n        { name: 'paymaster', type: 'uint256' },\n        { name: 'nonce', type: 'uint256' },\n        { name: 'value', type: 'uint256' },\n        { name: 'data', type: 'bytes' },\n        { name: 'factoryDeps', type: 'bytes32[]' },\n        { name: 'paymasterInput', type: 'bytes' },\n      ],\n    },\n    primaryType: 'Transaction',\n    message: message,\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Utilities\n\nfunction transactionToMessage(\n  transaction: ZksyncTransactionSerializableEIP712,\n): ZksyncEIP712TransactionSignable {\n  const {\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    factoryDeps,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n  } = transaction\n\n  return {\n    txType: 113n,\n    from: BigInt(from),\n    to: to ? BigInt(to) : 0n,\n    gasLimit: gas ?? 0n,\n    gasPerPubdataByteLimit: gasPerPubdata ?? gasPerPubdataDefault,\n    maxFeePerGas: maxFeePerGas ?? 0n,\n    maxPriorityFeePerGas: maxPriorityFeePerGas ?? 0n,\n    paymaster: paymaster ? BigInt(paymaster) : 0n,\n    nonce: nonce ? BigInt(nonce) : 0n,\n    value: value ?? 0n,\n    data: data ?? '0x',\n    factoryDeps: factoryDeps?.map((dep) => toHex(hashBytecode(dep))) ?? [],\n    paymasterInput: paymasterInput ? paymasterInput : '0x',\n  }\n}\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/core/error/serialize.ts","import { InvalidAddressError } from '../../errors/address.js'\nimport { BaseError } from '../../errors/base.js'\nimport { InvalidChainIdError } from '../../errors/chain.js'\nimport type { ExactPartial } from '../../types/utils.js'\nimport { isAddress } from '../../utils/address/isAddress.js'\nimport { InvalidEip712TransactionError } from '../errors/transaction.js'\nimport type {\n  ZksyncTransactionSerializable,\n  ZksyncTransactionSerializableEIP712,\n} from '../types/transaction.js'\nimport { isEIP712Transaction } from './isEip712Transaction.js'\n\nexport function assertEip712Transaction(\n  transaction: ExactPartial<ZksyncTransactionSerializable>,\n) {\n  const { chainId, to, from, paymaster, paymasterInput } =\n    transaction as ZksyncTransactionSerializableEIP712\n\n  if (!isEIP712Transaction(transaction))\n    throw new InvalidEip712TransactionError()\n  if (!chainId || chainId <= 0) throw new InvalidChainIdError({ chainId })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (from && !isAddress(from)) throw new InvalidAddressError({ address: from })\n  if (paymaster && !isAddress(paymaster))\n    throw new InvalidAddressError({ address: paymaster })\n  if (paymaster && !paymasterInput) {\n    throw new BaseError(\n      '`paymasterInput` must be provided when `paymaster` is defined',\n    )\n  }\n  if (!paymaster && paymasterInput) {\n    throw new BaseError(\n      '`paymaster` must be provided when `paymasterInput` is defined',\n    )\n  }\n}\n","// TODO(v3): Rename to `toLocalAccount` + add `source` property to define source (privateKey, mnemonic, hdKey, etc).\n\nimport type { Address } from 'abitype'\n\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../errors/address.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport {\n  type IsAddressErrorType,\n  isAddress,\n} from '../utils/address/isAddress.js'\nimport type {\n  AccountSource,\n  CustomSource,\n  JsonRpcAccount,\n  LocalAccount,\n} from './types.js'\n\ntype GetAccountReturnType<accountSource extends AccountSource> =\n  | (accountSource extends Address ? JsonRpcAccount : never)\n  | (accountSource extends CustomSource ? LocalAccount : never)\n\nexport type ToAccountErrorType =\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\n/**\n * @description Creates an Account from a custom signing implementation.\n *\n * @returns A Local Account.\n */\nexport function toAccount<accountSource extends AccountSource>(\n  source: accountSource,\n): GetAccountReturnType<accountSource> {\n  if (typeof source === 'string') {\n    if (!isAddress(source, { strict: false }))\n      throw new InvalidAddressError({ address: source })\n    return {\n      address: source,\n      type: 'json-rpc',\n    } as GetAccountReturnType<accountSource>\n  }\n\n  if (!isAddress(source.address, { strict: false }))\n    throw new InvalidAddressError({ address: source.address })\n  return {\n    address: source.address,\n    nonceManager: source.nonceManager,\n    sign: source.sign,\n    signAuthorization: source.signAuthorization,\n    signMessage: source.signMessage,\n    signTransaction: source.signTransaction,\n    signTypedData: source.signTypedData,\n    source: 'custom',\n    type: 'local',\n  } as GetAccountReturnType<accountSource>\n}\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/sign/scw/SCWSigner.ts","import {\n  createPaymentHeader,\n  createPaymentHeader2,\n  encodePayment,\n  preparePaymentHeader,\n  signPaymentHeader\n} from \"./chunk-SQV4BQTM.mjs\";\nimport {\n  SupportedEVMNetworks,\n  SupportedSVMNetworks,\n  getNetworkId,\n  isEvmSignerWallet,\n  isMultiNetworkSigner,\n  isSvmSignerWallet\n} from \"./chunk-3EQVFRKV.mjs\";\nimport {\n  getUsdcChainConfigForChain\n} from \"./chunk-K4TZLEOT.mjs\";\n\n// src/client/createPaymentHeader.ts\nasync function createPaymentHeader3(client, x402Version, paymentRequirements, config) {\n  if (paymentRequirements.scheme === \"exact\") {\n    if (SupportedEVMNetworks.includes(paymentRequirements.network)) {\n      const evmClient = isMultiNetworkSigner(client) ? client.evm : client;\n      if (!isEvmSignerWallet(evmClient)) {\n        throw new Error(\"Invalid evm wallet client provided\");\n      }\n      return await createPaymentHeader(\n        evmClient,\n        x402Version,\n        paymentRequirements\n      );\n    }\n    if (SupportedSVMNetworks.includes(paymentRequirements.network)) {\n      const svmClient = isMultiNetworkSigner(client) ? client.svm : client;\n      if (!isSvmSignerWallet(svmClient)) {\n        throw new Error(\"Invalid svm wallet client provided\");\n      }\n      return await createPaymentHeader2(\n        svmClient,\n        x402Version,\n        paymentRequirements,\n        config\n      );\n    }\n    throw new Error(\"Unsupported network\");\n  }\n  throw new Error(\"Unsupported scheme\");\n}\n\n// src/client/preparePaymentHeader.ts\nfunction preparePaymentHeader2(from, x402Version, paymentRequirements) {\n  if (paymentRequirements.scheme === \"exact\" && SupportedEVMNetworks.includes(paymentRequirements.network)) {\n    return preparePaymentHeader(from, x402Version, paymentRequirements);\n  }\n  throw new Error(\"Unsupported scheme\");\n}\n\n// src/client/selectPaymentRequirements.ts\nfunction selectPaymentRequirements(paymentRequirements, network, scheme) {\n  const broadlyAcceptedPaymentRequirements = paymentRequirements.filter((requirement) => {\n    const isExpectedScheme = !scheme || requirement.scheme === scheme;\n    const isExpectedChain = !network || (Array.isArray(network) ? network.includes(requirement.network) : network == requirement.network);\n    return isExpectedScheme && isExpectedChain;\n  });\n  const usdcRequirements = broadlyAcceptedPaymentRequirements.filter((requirement) => {\n    return requirement.asset === getUsdcChainConfigForChain(getNetworkId(requirement.network))?.usdcAddress;\n  });\n  if (usdcRequirements.length > 0) {\n    return usdcRequirements[0];\n  }\n  if (broadlyAcceptedPaymentRequirements.length > 0) {\n    return broadlyAcceptedPaymentRequirements[0];\n  }\n  return paymentRequirements[0];\n}\n\n// src/client/signPaymentHeader.ts\nasync function signPaymentHeader2(client, paymentRequirements, unsignedPaymentHeader) {\n  if (paymentRequirements.scheme === \"exact\" && SupportedEVMNetworks.includes(paymentRequirements.network)) {\n    const evmClient = isMultiNetworkSigner(client) ? client.evm : client;\n    if (!isEvmSignerWallet(evmClient)) {\n      throw new Error(\"Invalid evm wallet client provided\");\n    }\n    const signedPaymentHeader = await signPaymentHeader(evmClient, paymentRequirements, unsignedPaymentHeader);\n    return encodePayment(signedPaymentHeader);\n  }\n  throw new Error(\"Unsupported scheme\");\n}\n\nexport {\n  createPaymentHeader3 as createPaymentHeader,\n  preparePaymentHeader2 as preparePaymentHeader,\n  selectPaymentRequirements,\n  signPaymentHeader2 as signPaymentHeader\n};\n//# sourceMappingURL=chunk-F22J6Y36.mjs.map","/**\n * @internal\n *\n * Map with a LRU (Least recently used) policy.\n * @see https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nexport class LruMap<value = unknown> extends Map<string, value> {\n  maxSize: number\n\n  constructor(size: number) {\n    super()\n    this.maxSize = size\n  }\n\n  override get(key: string) {\n    const value = super.get(key)\n\n    if (super.has(key) && value !== undefined) {\n      this.delete(key)\n      super.set(key, value)\n    }\n\n    return value\n  }\n\n  override set(key: string, value: value) {\n    super.set(key, value)\n    if (this.maxSize && this.size > this.maxSize) {\n      const firstKey = this.keys().next().value\n      if (firstKey) this.delete(firstKey)\n    }\n    return this\n  }\n}\n","import {\n    type FetchAccountConfig,\n    fetchEncodedAccount,\n    fetchJsonParsedAccount,\n    type MaybeAccount,\n    type MaybeEncodedAccount,\n} from '@solana/accounts';\nimport type { Address } from '@solana/addresses';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { JsonParsedSysvarAccount } from '@solana/rpc-parsed-types';\nimport type { Rpc } from '@solana/rpc-spec';\n\nexport const SYSVAR_CLOCK_ADDRESS =\n    'SysvarC1ock11111111111111111111111111111111' as Address<'SysvarC1ock11111111111111111111111111111111'>;\nexport const SYSVAR_EPOCH_REWARDS_ADDRESS =\n    'SysvarEpochRewards1111111111111111111111111' as Address<'SysvarEpochRewards1111111111111111111111111'>;\nexport const SYSVAR_EPOCH_SCHEDULE_ADDRESS =\n    'SysvarEpochSchedu1e111111111111111111111111' as Address<'SysvarEpochSchedu1e111111111111111111111111'>;\nexport const SYSVAR_INSTRUCTIONS_ADDRESS =\n    'Sysvar1nstructions1111111111111111111111111' as Address<'Sysvar1nstructions1111111111111111111111111'>;\nexport const SYSVAR_LAST_RESTART_SLOT_ADDRESS =\n    'SysvarLastRestartS1ot1111111111111111111111' as Address<'SysvarLastRestartS1ot1111111111111111111111'>;\nexport const SYSVAR_RECENT_BLOCKHASHES_ADDRESS =\n    'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\nexport const SYSVAR_RENT_ADDRESS =\n    'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\nexport const SYSVAR_SLOT_HASHES_ADDRESS =\n    'SysvarS1otHashes111111111111111111111111111' as Address<'SysvarS1otHashes111111111111111111111111111'>;\nexport const SYSVAR_SLOT_HISTORY_ADDRESS =\n    'SysvarS1otHistory11111111111111111111111111' as Address<'SysvarS1otHistory11111111111111111111111111'>;\nexport const SYSVAR_STAKE_HISTORY_ADDRESS =\n    'SysvarStakeHistory1111111111111111111111111' as Address<'SysvarStakeHistory1111111111111111111111111'>;\n\ntype SysvarAddress =\n    | typeof SYSVAR_CLOCK_ADDRESS\n    | typeof SYSVAR_EPOCH_REWARDS_ADDRESS\n    | typeof SYSVAR_EPOCH_SCHEDULE_ADDRESS\n    | typeof SYSVAR_INSTRUCTIONS_ADDRESS\n    | typeof SYSVAR_LAST_RESTART_SLOT_ADDRESS\n    | typeof SYSVAR_RECENT_BLOCKHASHES_ADDRESS\n    | typeof SYSVAR_RENT_ADDRESS\n    | typeof SYSVAR_SLOT_HASHES_ADDRESS\n    | typeof SYSVAR_SLOT_HISTORY_ADDRESS\n    | typeof SYSVAR_STAKE_HISTORY_ADDRESS;\n\n/**\n * Fetch an encoded sysvar account.\n *\n * Sysvars are special accounts that contain dynamically-updated data about the network cluster, the\n * blockchain history, and the executing transaction.\n */\nexport async function fetchEncodedSysvarAccount<TAddress extends SysvarAddress>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: TAddress,\n    config?: FetchAccountConfig,\n): Promise<MaybeEncodedAccount<TAddress>> {\n    return await fetchEncodedAccount<TAddress>(rpc, address, config);\n}\n\n/**\n * Fetch a JSON-parsed sysvar account.\n *\n * Sysvars are special accounts that contain dynamically-updated data about the network cluster, the\n * blockchain history, and the executing transaction.\n */\nexport async function fetchJsonParsedSysvarAccount<TAddress extends SysvarAddress>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: TAddress,\n    config?: FetchAccountConfig,\n): Promise<MaybeAccount<JsonParsedSysvarAccount, TAddress> | MaybeEncodedAccount<TAddress>> {\n    return await fetchJsonParsedAccount<JsonParsedSysvarAccount, TAddress>(rpc, address, config);\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core.js\";\n\nexport abstract class IKeyChain {\n  public abstract keychain: Map<string, string>;\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract has(tag: string, opts?: any): boolean;\n\n  public abstract set(tag: string, key: string, opts?: any): Promise<void>;\n\n  public abstract get(tag: string, opts?: any): string;\n\n  public abstract del(tag: string, opts?: any): Promise<void>;\n}\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/sign/walletlink/relay/ui/WLMobileRelayUI.ts","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/util/web.ts","import {\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { AbortController } from '@solana/event-target-impl';\n\nimport { DataPublisher } from './data-publisher';\n\ntype Config = Readonly<{\n    /**\n     * Triggering this abort signal will cause all iterators spawned from this iterator to return\n     * once they have published all queued messages.\n     */\n    abortSignal: AbortSignal;\n    /**\n     * Messages from this channel of `dataPublisher` will be the ones yielded through the iterators.\n     *\n     * Messages only begin to be queued after the first time an iterator begins to poll. Channel\n     * messages published before that time will be dropped.\n     */\n    dataChannelName: string;\n    // FIXME: It would be nice to be able to constrain the type of `dataPublisher` to one that\n    //        definitely supports the `dataChannelName` and `errorChannelName` channels, and\n    //        furthermore publishes `TData` on the `dataChannelName` channel. This is more difficult\n    //        than it should be: https://tsplay.dev/NlZelW\n    dataPublisher: DataPublisher;\n    /**\n     * Messages from this channel of `dataPublisher` will be the ones thrown through the iterators.\n     *\n     * Any new iterators created after the first error is encountered will reject with that error\n     * when polled.\n     */\n    errorChannelName: string;\n}>;\n\nconst enum PublishType {\n    DATA,\n    ERROR,\n}\n\ntype IteratorKey = symbol;\ntype IteratorState<TData> =\n    | {\n          __hasPolled: false;\n          publishQueue: (\n              | {\n                    __type: PublishType.DATA;\n                    data: TData;\n                }\n              | {\n                    __type: PublishType.ERROR;\n                    err: unknown;\n                }\n          )[];\n      }\n    | {\n          __hasPolled: true;\n          onData: (data: TData) => void;\n          onError: Parameters<ConstructorParameters<typeof Promise>[0]>[1];\n      };\n\nlet EXPLICIT_ABORT_TOKEN: symbol;\nfunction createExplicitAbortToken() {\n    // This function is an annoying workaround to prevent `process.env.NODE_ENV` from appearing at\n    // the top level of this module and thwarting an optimizing compiler's attempt to tree-shake.\n    return Symbol(\n        process.env.NODE_ENV !== \"production\"\n            ? \"This symbol is thrown from a socket's iterator when the connection is explicitly \" +\n                  'aborted by the user'\n            : undefined,\n    );\n}\n\nconst UNINITIALIZED = Symbol();\n\n/**\n * Returns an `AsyncIterable` given a data publisher.\n *\n * The iterable will produce iterators that vend messages published to `dataChannelName` and will\n * throw the first time a message is published to `errorChannelName`. Triggering the abort signal\n * will cause all iterators spawned from this iterator to return once they have published all queued\n * messages.\n *\n * Things to note:\n *\n * - If a message is published over a channel before the `AsyncIterator` attached to it has polled\n *   for the next result, the message will be queued in memory.\n * - Messages only begin to be queued after the first time an iterator begins to poll. Channel\n *   messages published before that time will be dropped.\n * - If there are messages in the queue and an error occurs, all queued messages will be vended to\n *   the iterator before the error is thrown.\n * - If there are messages in the queue and the abort signal fires, all queued messages will be\n *   vended to the iterator after which it will return.\n * - Any new iterators created after the first error is encountered will reject with that error when\n *   polled.\n *\n * @param config\n *\n * @example\n * ```ts\n * const iterable = createAsyncIterableFromDataPublisher({\n *     abortSignal: AbortSignal.timeout(10_000),\n *     dataChannelName: 'message',\n *     dataPublisher,\n *     errorChannelName: 'error',\n * });\n * try {\n *     for await (const message of iterable) {\n *         console.log('Got message', message);\n *     }\n * } catch (e) {\n *     console.error('An error was published to the error channel', e);\n * } finally {\n *     console.log(\"It's been 10 seconds; that's enough for now.\");\n * }\n * ```\n */\nexport function createAsyncIterableFromDataPublisher<TData>({\n    abortSignal,\n    dataChannelName,\n    dataPublisher,\n    errorChannelName,\n}: Config): AsyncIterable<TData> {\n    const iteratorState: Map<IteratorKey, IteratorState<TData>> = new Map();\n    function publishErrorToAllIterators(reason: unknown) {\n        for (const [iteratorKey, state] of iteratorState.entries()) {\n            if (state.__hasPolled) {\n                iteratorState.delete(iteratorKey);\n                state.onError(reason);\n            } else {\n                state.publishQueue.push({\n                    __type: PublishType.ERROR,\n                    err: reason,\n                });\n            }\n        }\n    }\n    const abortController = new AbortController();\n    abortSignal.addEventListener('abort', () => {\n        abortController.abort();\n        publishErrorToAllIterators((EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken()));\n    });\n    const options = { signal: abortController.signal } as const;\n    let firstError: unknown = UNINITIALIZED;\n    dataPublisher.on(\n        errorChannelName,\n        err => {\n            if (firstError === UNINITIALIZED) {\n                firstError = err;\n                abortController.abort();\n                publishErrorToAllIterators(err);\n            }\n        },\n        options,\n    );\n    dataPublisher.on(\n        dataChannelName,\n        data => {\n            iteratorState.forEach((state, iteratorKey) => {\n                if (state.__hasPolled) {\n                    const { onData } = state;\n                    iteratorState.set(iteratorKey, { __hasPolled: false, publishQueue: [] });\n                    onData(data as TData);\n                } else {\n                    state.publishQueue.push({\n                        __type: PublishType.DATA,\n                        data: data as TData,\n                    });\n                }\n            });\n        },\n        options,\n    );\n    return {\n        async *[Symbol.asyncIterator]() {\n            if (abortSignal.aborted) {\n                return;\n            }\n            if (firstError !== UNINITIALIZED) {\n                throw firstError;\n            }\n            const iteratorKey = Symbol();\n            iteratorState.set(iteratorKey, { __hasPolled: false, publishQueue: [] });\n            try {\n                while (true) {\n                    const state = iteratorState.get(iteratorKey);\n                    if (!state) {\n                        // There should always be state by now.\n                        throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING);\n                    }\n                    if (state.__hasPolled) {\n                        // You should never be able to poll twice in a row.\n                        throw new SolanaError(\n                            SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n                        );\n                    }\n                    const publishQueue = state.publishQueue;\n                    try {\n                        if (publishQueue.length) {\n                            state.publishQueue = [];\n                            for (const item of publishQueue) {\n                                if (item.__type === PublishType.DATA) {\n                                    yield item.data;\n                                } else {\n                                    throw item.err;\n                                }\n                            }\n                        } else {\n                            yield await new Promise<TData>((resolve, reject) => {\n                                iteratorState.set(iteratorKey, {\n                                    __hasPolled: true,\n                                    onData: resolve,\n                                    onError: reject,\n                                });\n                            });\n                        }\n                    } catch (e) {\n                        if (e === (EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken())) {\n                            return;\n                        } else {\n                            throw e;\n                        }\n                    }\n                }\n            } finally {\n                iteratorState.delete(iteratorKey);\n            }\n        },\n    };\n}\n","import type * as Errors from './Errors.js'\n\nconst bigIntSuffix = '#__bigint'\n\n/**\n * Parses a JSON string, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.parse('{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}')\n * // @log: {\n * // @log:   foo: 'bar',\n * // @log:   baz: 69420694206942069420694206942069420694206942069420n\n * // @log: }\n * ```\n *\n * @param string - The value to parse.\n * @param reviver - A function that transforms the results.\n * @returns The parsed value.\n */\nexport function parse(\n  string: string,\n  reviver?: ((this: any, key: string, value: any) => any) | undefined,\n) {\n  return JSON.parse(string, (key, value_) => {\n    const value = value_\n    if (typeof value === 'string' && value.endsWith(bigIntSuffix))\n      return BigInt(value.slice(0, -bigIntSuffix.length))\n    return typeof reviver === 'function' ? reviver(key, value) : value\n  })\n}\n\nexport declare namespace parse {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Stringifies a value to its JSON representation, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.stringify({\n *   foo: 'bar',\n *   baz: 69420694206942069420694206942069420694206942069420n,\n * })\n * // @log: '{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}'\n * ```\n *\n * @param value - The value to stringify.\n * @param replacer - A function that transforms the results. It is passed the key and value of the property, and must return the value to be used in the JSON string. If this function returns `undefined`, the property is not included in the resulting JSON string.\n * @param space - A string or number that determines the indentation of the JSON string. If it is a number, it indicates the number of spaces to use as indentation; if it is a string (e.g. `'\\t'`), it uses the string as the indentation character.\n * @returns The JSON string.\n */\nexport function stringify(\n  value: any,\n  replacer?: ((this: any, key: string, value: any) => any) | null | undefined,\n  space?: string | number | undefined,\n) {\n  return JSON.stringify(\n    value,\n    (key, value) => {\n      if (typeof replacer === 'function') return replacer(key, value)\n      if (typeof value === 'bigint') return value.toString() + bigIntSuffix\n      return value\n    },\n    space,\n  )\n}\n\nexport declare namespace stringify {\n  type ErrorType = Errors.GlobalErrorType\n}\n","export const METHODS_TO_VERIFY = [\n  \"wc_sessionPropose\",\n  \"wc_sessionRequest\",\n  \"wc_authRequest\",\n  \"wc_sessionAuthenticate\",\n];\n","import { defineChain } from '../../utils/chain/defineChain.js'\nimport { chainConfig } from '../../zksync/chainConfig.js'\n\nexport const abstract = /*#__PURE__*/ defineChain({\n  ...chainConfig,\n  blockTime: 200,\n  id: 2_741,\n  name: 'Abstract',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'ETH',\n    symbol: 'ETH',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://api.mainnet.abs.xyz'],\n      webSocket: ['wss://api.mainnet.abs.xyz/ws'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Etherscan',\n      url: 'https://abscan.org',\n    },\n    native: {\n      name: 'Abstract Explorer',\n      url: 'https://explorer.mainnet.abs.xyz',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xAa4De41dba0Ca5dCBb288b7cC6b708F3aaC759E7',\n      blockCreated: 5288,\n    },\n    erc6492Verifier: {\n      address: '0xfB688330379976DA81eB64Fe4BF50d7401763B9C',\n      blockCreated: 5263,\n    },\n  },\n})\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n} from '@solana/kit';\n\nexport enum AuthorityType {\n  MintTokens,\n  FreezeAccount,\n  AccountOwner,\n  CloseAccount,\n  TransferFeeConfig,\n  WithheldWithdraw,\n  CloseMint,\n  InterestRate,\n  PermanentDelegate,\n  ConfidentialTransferMint,\n  TransferHookProgramId,\n  ConfidentialTransferFeeConfig,\n  MetadataPointer,\n  GroupPointer,\n  GroupMemberPointer,\n  ScaledUiAmount,\n  Pause,\n}\n\nexport type AuthorityTypeArgs = AuthorityType;\n\nexport function getAuthorityTypeEncoder(): FixedSizeEncoder<AuthorityTypeArgs> {\n  return getEnumEncoder(AuthorityType);\n}\n\nexport function getAuthorityTypeDecoder(): FixedSizeDecoder<AuthorityType> {\n  return getEnumDecoder(AuthorityType);\n}\n\nexport function getAuthorityTypeCodec(): FixedSizeCodec<\n  AuthorityTypeArgs,\n  AuthorityType\n> {\n  return combineCodec(getAuthorityTypeEncoder(), getAuthorityTypeDecoder());\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { ICore } from \"./core.js\";\n\nexport declare namespace ExpirerTypes {\n  interface Expiration {\n    target: string;\n    expiry: number;\n  }\n\n  interface Created {\n    target: string;\n    expiration: Expiration;\n  }\n\n  interface Deleted {\n    target: string;\n    expiration: Expiration;\n  }\n\n  interface Expired {\n    target: string;\n    expiration: Expiration;\n  }\n}\n\nexport abstract class IExpirer extends IEvents {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  public abstract readonly length: number;\n\n  public abstract readonly keys: string[];\n\n  public abstract readonly values: ExpirerTypes.Expiration[];\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract has(key: string | number): boolean;\n\n  public abstract set(key: string | number, expiry: number): void;\n\n  public abstract get(key: string | number): ExpirerTypes.Expiration;\n\n  public abstract del(key: string | number): void;\n}\n","export const AUTH_PROTOCOL = \"wc\";\nexport const AUTH_VERSION = 1.5;\nexport const AUTH_CONTEXT = \"auth\";\nexport const AUTH_KEYS_CONTEXT = \"authKeys\";\nexport const AUTH_PAIRING_TOPIC_CONTEXT = \"pairingTopics\";\nexport const AUTH_REQUEST_CONTEXT = \"requests\";\n\nexport const AUTH_STORAGE_PREFIX = `${AUTH_PROTOCOL}@${AUTH_VERSION}:${AUTH_CONTEXT}:`;\nexport const AUTH_PUBLIC_KEY_NAME = `${AUTH_STORAGE_PREFIX}:PUB_KEY`;\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const story = /*#__PURE__*/ defineChain({\n  id: 1514,\n  name: 'Story',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'IP Token',\n    symbol: 'IP',\n  },\n  contracts: {\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 340998,\n    },\n    ensRegistry: {\n      address: '0x5dc881dda4e4a8d312be3544ad13118d1a04cb17',\n      blockCreated: 648924,\n    },\n    ensUniversalResolver: {\n      address: '0xddfb18888a9466688235887dec2a10c4f5effee9',\n      blockCreated: 649114,\n    },\n  },\n  rpcUrls: {\n    default: { http: ['https://mainnet.storyrpc.io'] },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Story explorer',\n      url: 'https://storyscan.io',\n      apiUrl: 'https://storyscan.io/api/v2',\n    },\n  },\n  ensTlds: ['.ip'],\n  testnet: false,\n})\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/sign/scw/SCWKeyManager.ts","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/CoinbaseWalletProvider.ts","import {\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SolanaError,\n} from '@solana/errors';\nimport { EventTarget } from '@solana/event-target-impl';\nimport { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\nimport { getDataPublisherFromEventEmitter } from '@solana/subscribable';\nimport WebSocket from '@solana/ws-impl';\n\nexport type Config = Readonly<{\n    /**\n     * The number of bytes to admit into the WebSocket's send buffer before queueing messages on the\n     * client.\n     *\n     * When you call {@link RpcSubscriptionsChannel.send | `send()`} on a `WebSocket` the runtime\n     * might add the message to a buffer rather than send it right away. In the event that\n     * `socket.bufferedAmount` exceeds the value configured here, messages will be added to a queue\n     * in your application code instead of being sent to the WebSocket, until such time as the\n     * `bufferedAmount` falls back below the high watermark.\n     */\n    sendBufferHighWatermark: number;\n    /**\n     * An `AbortSignal` to fire when you want to explicitly close the `WebSocket`.\n     *\n     * If the channel is open it will be closed with a normal closure code\n     * (https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1) If the channel has not been\n     * established yet, firing this signal will result in the `AbortError` being thrown to the\n     * caller who was trying to open the channel.\n     */\n    signal: AbortSignal;\n    /**\n     * A string representing the target endpoint.\n     *\n     * In Node, it must be an absolute URL using the `ws` or `wss` protocol.\n     */\n    url: string;\n}>;\n\ntype WebSocketMessage = ArrayBufferLike | ArrayBufferView | Blob | string;\n\nconst NORMAL_CLOSURE_CODE = 1000; // https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1\n\n/**\n * Creates an object that represents an open channel to a `WebSocket` server.\n *\n * You can use it to send messages by calling its\n * {@link RpcSubscriptionsChannel.send | `send()`} function and you can receive them by subscribing\n * to the {@link RpcSubscriptionChannelEvents} it emits.\n */\nexport function createWebSocketChannel({\n    sendBufferHighWatermark,\n    signal,\n    url,\n}: Config): Promise<RpcSubscriptionsChannel<WebSocketMessage, string>> {\n    if (signal.aborted) {\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        return Promise.reject(signal.reason);\n    }\n    let bufferDrainWatcher: Readonly<{ onCancel(): void; promise: Promise<void> }> | undefined;\n    let hasConnected = false;\n    const listenerRemovers = new Set<() => void>();\n    function cleanupListeners() {\n        listenerRemovers.forEach(r => {\n            r();\n        });\n        listenerRemovers.clear();\n    }\n    function handleAbort() {\n        cleanupListeners();\n        if (!hasConnected) {\n            rejectOpen(signal.reason);\n        }\n        if (webSocket.readyState !== WebSocket.CLOSED && webSocket.readyState !== WebSocket.CLOSING) {\n            webSocket.close(NORMAL_CLOSURE_CODE);\n        }\n    }\n    function handleClose(ev: CloseEvent) {\n        cleanupListeners();\n        bufferDrainWatcher?.onCancel();\n        signal.removeEventListener('abort', handleAbort);\n        webSocket.removeEventListener('close', handleClose);\n        webSocket.removeEventListener('error', handleError);\n        webSocket.removeEventListener('message', handleMessage);\n        webSocket.removeEventListener('open', handleOpen);\n        if (!signal.aborted && !(ev.wasClean && ev.code === NORMAL_CLOSURE_CODE)) {\n            eventTarget.dispatchEvent(\n                new CustomEvent('error', {\n                    detail: new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED, {\n                        cause: ev,\n                    }),\n                }),\n            );\n        }\n    }\n    function handleError(ev: Event) {\n        if (signal.aborted) {\n            return;\n        }\n        if (!hasConnected) {\n            const failedToConnectError = new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT, {\n                errorEvent: ev,\n            });\n            rejectOpen(failedToConnectError);\n            eventTarget.dispatchEvent(\n                new CustomEvent('error', {\n                    detail: failedToConnectError,\n                }),\n            );\n        }\n    }\n    function handleMessage(ev: MessageEvent) {\n        if (signal.aborted) {\n            return;\n        }\n        eventTarget.dispatchEvent(new CustomEvent('message', { detail: ev.data }));\n    }\n    const eventTarget = new EventTarget();\n    const dataPublisher = getDataPublisherFromEventEmitter(eventTarget);\n    function handleOpen() {\n        hasConnected = true;\n        resolveOpen({\n            ...dataPublisher,\n            async send(message) {\n                if (webSocket.readyState !== WebSocket.OPEN) {\n                    throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED);\n                }\n                if (!bufferDrainWatcher && webSocket.bufferedAmount > sendBufferHighWatermark) {\n                    let onCancel!: () => void;\n                    const promise = new Promise<void>((resolve, reject) => {\n                        const intervalId = setInterval(() => {\n                            if (\n                                webSocket.readyState !== WebSocket.OPEN ||\n                                !(webSocket.bufferedAmount > sendBufferHighWatermark)\n                            ) {\n                                clearInterval(intervalId);\n                                bufferDrainWatcher = undefined;\n                                resolve();\n                            }\n                        }, 16);\n                        onCancel = () => {\n                            bufferDrainWatcher = undefined;\n                            clearInterval(intervalId);\n                            reject(\n                                new SolanaError(\n                                    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n                                ),\n                            );\n                        };\n                    });\n                    bufferDrainWatcher = {\n                        onCancel,\n                        promise,\n                    };\n                }\n                if (bufferDrainWatcher) {\n                    if (ArrayBuffer.isView(message) && !(message instanceof DataView)) {\n                        const TypedArrayConstructor = message.constructor as {\n                            new (...args: [typeof message]): typeof message;\n                        };\n                        // Clone the message to prevent mutation while queued.\n                        message = new TypedArrayConstructor(message);\n                    }\n                    await bufferDrainWatcher.promise;\n                }\n                webSocket.send(message);\n            },\n        });\n    }\n    const webSocket = new WebSocket(url);\n    signal.addEventListener('abort', handleAbort);\n    webSocket.addEventListener('close', handleClose);\n    webSocket.addEventListener('error', handleError);\n    webSocket.addEventListener('message', handleMessage);\n    webSocket.addEventListener('open', handleOpen);\n    let rejectOpen!: (e: SolanaError) => void;\n    let resolveOpen!: (value: RpcSubscriptionsChannel<WebSocketMessage, string>) => void;\n    return new Promise<RpcSubscriptionsChannel<WebSocketMessage, string>>((resolve, reject) => {\n        rejectOpen = reject;\n        resolveOpen = resolve;\n    });\n}\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const seiTestnet = /*#__PURE__*/ defineChain({\n  id: 1328,\n  name: 'Sei Testnet',\n  nativeCurrency: { name: 'Sei', symbol: 'SEI', decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: ['https://evm-rpc-testnet.sei-apis.com'],\n      webSocket: ['wss://evm-ws-testnet.sei-apis.com'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Seitrace',\n      url: 'https://seitrace.com',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 98697651,\n    },\n  },\n  testnet: true,\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const polygon = /*#__PURE__*/ defineChain({\n  id: 137,\n  name: 'Polygon',\n  blockTime: 2000,\n  nativeCurrency: { name: 'POL', symbol: 'POL', decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: ['https://polygon-rpc.com'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'PolygonScan',\n      url: 'https://polygonscan.com',\n      apiUrl: 'https://api.etherscan.io/v2/api',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xca11bde05977b3631167028862be2a173976ca11',\n      blockCreated: 25770160,\n    },\n  },\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const polygonAmoy = /*#__PURE__*/ defineChain({\n  id: 80_002,\n  name: 'Polygon Amoy',\n  nativeCurrency: { name: 'POL', symbol: 'POL', decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: ['https://rpc-amoy.polygon.technology'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'PolygonScan',\n      url: 'https://amoy.polygonscan.com',\n      apiUrl: 'https://api.etherscan.io/v2/api',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xca11bde05977b3631167028862be2a173976ca11',\n      blockCreated: 3127388,\n    },\n  },\n  testnet: true,\n})\n","import { secp256k1 } from '@noble/curves/secp256k1'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { Compute, ExactPartial, OneOf } from './internal/types.js'\nimport * as Json from './Json.js'\nimport * as Solidity from './Solidity.js'\n\n/** Root type for an ECDSA signature. */\nexport type Signature<\n  recovered extends boolean = true,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<\n  recovered extends true\n    ? {\n        r: bigintType\n        s: bigintType\n        yParity: numberType\n      }\n    : {\n        r: bigintType\n        s: bigintType\n        yParity?: numberType | undefined\n      }\n>\n\n/** RPC-formatted ECDSA signature. */\nexport type Rpc<recovered extends boolean = true> = Signature<\n  recovered,\n  Hex.Hex,\n  Hex.Hex\n>\n\n/** (Legacy) ECDSA signature. */\nexport type Legacy<bigintType = bigint, numberType = number> = {\n  r: bigintType\n  s: bigintType\n  v: numberType\n}\n\n/** RPC-formatted (Legacy) ECDSA signature. */\nexport type LegacyRpc = Legacy<Hex.Hex, Hex.Hex>\n\nexport type Tuple = readonly [yParity: Hex.Hex, r: Hex.Hex, s: Hex.Hex]\n\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function assert(\n  signature: ExactPartial<Signature>,\n  options: assert.Options = {},\n): asserts signature is Signature {\n  const { recovered } = options\n  if (typeof signature.r === 'undefined')\n    throw new MissingPropertiesError({ signature })\n  if (typeof signature.s === 'undefined')\n    throw new MissingPropertiesError({ signature })\n  if (recovered && typeof signature.yParity === 'undefined')\n    throw new MissingPropertiesError({ signature })\n  if (signature.r < 0n || signature.r > Solidity.maxUint256)\n    throw new InvalidRError({ value: signature.r })\n  if (signature.s < 0n || signature.s > Solidity.maxUint256)\n    throw new InvalidSError({ value: signature.s })\n  if (\n    typeof signature.yParity === 'number' &&\n    signature.yParity !== 0 &&\n    signature.yParity !== 1\n  )\n    throw new InvalidYParityError({ value: signature.yParity })\n}\n\nexport declare namespace assert {\n  type Options = {\n    /** Whether or not the signature should be recovered (contain `yParity`). */\n    recovered?: boolean\n  }\n\n  type ErrorType =\n    | MissingPropertiesError\n    | InvalidRError\n    | InvalidSError\n    | InvalidYParityError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromBytes(signature: Bytes.Bytes): Signature {\n  return fromHex(Hex.fromBytes(signature))\n}\n\nexport declare namespace fromBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromHex(signature: Hex.Hex): Signature {\n  if (signature.length !== 130 && signature.length !== 132)\n    throw new InvalidSerializedSizeError({ signature })\n\n  const r = BigInt(Hex.slice(signature, 0, 32))\n  const s = BigInt(Hex.slice(signature, 32, 64))\n\n  const yParity = (() => {\n    const yParity = Number(`0x${signature.slice(130)}`)\n    if (Number.isNaN(yParity)) return undefined\n    try {\n      return vToYParity(yParity)\n    } catch {\n      throw new InvalidYParityError({ value: yParity })\n    }\n  })()\n\n  if (typeof yParity === 'undefined')\n    return {\n      r,\n      s,\n    } as never\n  return {\n    r,\n    s,\n    yParity,\n  } as never\n}\n\nexport declare namespace fromHex {\n  type ErrorType =\n    | Hex.from.ErrorType\n    | InvalidSerializedSizeError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */\nexport function extract(value: extract.Value): Signature | undefined {\n  if (typeof value.r === 'undefined') return undefined\n  if (typeof value.s === 'undefined') return undefined\n  return from(value as any)\n}\n\nexport declare namespace extract {\n  type Value = {\n    r?: bigint | Hex.Hex | undefined\n    s?: bigint | Hex.Hex | undefined\n    yParity?: number | Hex.Hex | undefined\n    v?: number | Hex.Hex | undefined\n  }\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */\nexport function from<\n  const signature extends\n    | OneOf<Signature<boolean> | Rpc<boolean> | Legacy | LegacyRpc>\n    | Hex.Hex\n    | Bytes.Bytes,\n>(\n  signature:\n    | signature\n    | OneOf<Signature<boolean> | Rpc<boolean> | Legacy | LegacyRpc>\n    | Hex.Hex\n    | Bytes.Bytes,\n): from.ReturnType<signature> {\n  const signature_ = (() => {\n    if (typeof signature === 'string') return fromHex(signature)\n    if (signature instanceof Uint8Array) return fromBytes(signature)\n    if (typeof signature.r === 'string') return fromRpc(signature)\n    if (signature.v) return fromLegacy(signature)\n    return {\n      r: signature.r,\n      s: signature.s,\n      ...(typeof signature.yParity !== 'undefined'\n        ? { yParity: signature.yParity }\n        : {}),\n    }\n  })()\n  assert(signature_)\n  return signature_ as never\n}\n\nexport declare namespace from {\n  type ReturnType<\n    signature extends\n      | OneOf<Signature<boolean> | Rpc<boolean> | Legacy | LegacyRpc>\n      | Hex.Hex\n      | Bytes.Bytes,\n  > = signature extends Signature<boolean> & { v?: undefined }\n    ? signature\n    : Signature\n\n  type ErrorType =\n    | assert.ErrorType\n    | fromBytes.ErrorType\n    | fromHex.ErrorType\n    | vToYParity.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerBytes(signature: Bytes.Bytes): Signature<false> {\n  return fromDerHex(Hex.fromBytes(signature))\n}\n\nexport declare namespace fromDerBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerHex(signature: Hex.Hex): Signature<false> {\n  const { r, s } = secp256k1.Signature.fromDER(Hex.from(signature).slice(2))\n  return { r, s }\n}\n\nexport declare namespace fromDerHex {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromLegacy(signature: Legacy): Signature {\n  return {\n    r: signature.r,\n    s: signature.s,\n    yParity: vToYParity(signature.v),\n  }\n}\n\nexport declare namespace fromLegacy {\n  type ErrorType = vToYParity.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromRpc(signature: {\n  r: Hex.Hex\n  s: Hex.Hex\n  yParity?: Hex.Hex | undefined\n  v?: Hex.Hex | undefined\n}): Signature {\n  const yParity = (() => {\n    const v = signature.v ? Number(signature.v) : undefined\n    let yParity = signature.yParity ? Number(signature.yParity) : undefined\n    if (typeof v === 'number' && typeof yParity !== 'number')\n      yParity = vToYParity(v)\n    if (typeof yParity !== 'number')\n      throw new InvalidYParityError({ value: signature.yParity })\n    return yParity\n  })()\n\n  return {\n    r: BigInt(signature.r),\n    s: BigInt(signature.s),\n    yParity,\n  }\n}\n\nexport declare namespace fromRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromTuple(tuple: Tuple): Signature {\n  const [yParity, r, s] = tuple\n  return from({\n    r: r === '0x' ? 0n : BigInt(r),\n    s: s === '0x' ? 0n : BigInt(s),\n    yParity: yParity === '0x' ? 0 : Number(yParity),\n  })\n}\n\nexport declare namespace fromTuple {\n  type ErrorType = from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toBytes(signature: Signature<boolean>): Bytes.Bytes {\n  return Bytes.fromHex(toHex(signature))\n}\n\nexport declare namespace toBytes {\n  type ErrorType =\n    | toHex.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toHex(signature: Signature<boolean>): Hex.Hex {\n  assert(signature)\n\n  const r = signature.r\n  const s = signature.s\n\n  const signature_ = Hex.concat(\n    Hex.fromNumber(r, { size: 32 }),\n    Hex.fromNumber(s, { size: 32 }),\n    // If the signature is recovered, add the recovery byte to the signature.\n    typeof signature.yParity === 'number'\n      ? Hex.fromNumber(yParityToV(signature.yParity), { size: 1 })\n      : '0x',\n  )\n\n  return signature_\n}\n\nexport declare namespace toHex {\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerBytes(signature: Signature<boolean>): Bytes.Bytes {\n  const sig = new secp256k1.Signature(signature.r, signature.s)\n  return sig.toDERRawBytes()\n}\n\nexport declare namespace toDerBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerHex(signature: Signature<boolean>): Hex.Hex {\n  const sig = new secp256k1.Signature(signature.r, signature.s)\n  return `0x${sig.toDERHex()}`\n}\n\nexport declare namespace toDerHex {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */\nexport function toLegacy(signature: Signature): Legacy {\n  return {\n    r: signature.r,\n    s: signature.s,\n    v: yParityToV(signature.yParity),\n  }\n}\n\nexport declare namespace toLegacy {\n  type ErrorType = yParityToV.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */\nexport function toRpc(signature: Signature): Rpc {\n  const { r, s, yParity } = signature\n  return {\n    r: Hex.fromNumber(r, { size: 32 }),\n    s: Hex.fromNumber(s, { size: 32 }),\n    yParity: yParity === 0 ? '0x0' : '0x1',\n  }\n}\n\nexport declare namespace toRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */\nexport function toTuple(signature: Signature): Tuple {\n  const { r, s, yParity } = signature\n\n  return [\n    yParity ? '0x01' : '0x',\n    r === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(r!)),\n    s === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(s!)),\n  ] as const\n}\n\nexport declare namespace toTuple {\n  type ErrorType =\n    | Hex.trimLeft.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function validate(\n  signature: ExactPartial<Signature>,\n  options: validate.Options = {},\n): boolean {\n  try {\n    assert(signature, options)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /** Whether or not the signature should be recovered (contain `yParity`). */\n    recovered?: boolean\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */\nexport function vToYParity(v: number): Signature['yParity'] {\n  if (v === 0 || v === 27) return 0\n  if (v === 1 || v === 28) return 1\n  if (v >= 35) return v % 2 === 0 ? 1 : 0\n  throw new InvalidVError({ value: v })\n}\n\nexport declare namespace vToYParity {\n  type ErrorType = InvalidVError | Errors.GlobalErrorType\n}\n\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */\nexport function yParityToV(yParity: number): number {\n  if (yParity === 0) return 27\n  if (yParity === 1) return 28\n  throw new InvalidYParityError({ value: yParity })\n}\n\nexport declare namespace yParityToV {\n  type ErrorType = InvalidVError | Errors.GlobalErrorType\n}\n\n/** Thrown when the serialized signature is of an invalid size. */\nexport class InvalidSerializedSizeError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidSerializedSizeError'\n\n  constructor({ signature }: { signature: Hex.Hex | Bytes.Bytes }) {\n    super(`Value \\`${signature}\\` is an invalid signature size.`, {\n      metaMessages: [\n        'Expected: 64 bytes or 65 bytes.',\n        `Received ${Hex.size(Hex.from(signature))} bytes.`,\n      ],\n    })\n  }\n}\n\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */\nexport class MissingPropertiesError extends Errors.BaseError {\n  override readonly name = 'Signature.MissingPropertiesError'\n\n  constructor({ signature }: { signature: unknown }) {\n    super(\n      `Signature \\`${Json.stringify(signature)}\\` is missing either an \\`r\\`, \\`s\\`, or \\`yParity\\` property.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `r` value. */\nexport class InvalidRError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidRError'\n\n  constructor({ value }: { value: unknown }) {\n    super(\n      `Value \\`${value}\\` is an invalid r value. r must be a positive integer less than 2^256.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `s` value. */\nexport class InvalidSError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidSError'\n\n  constructor({ value }: { value: unknown }) {\n    super(\n      `Value \\`${value}\\` is an invalid s value. s must be a positive integer less than 2^256.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `yParity` value. */\nexport class InvalidYParityError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidYParityError'\n\n  constructor({ value }: { value: unknown }) {\n    super(\n      `Value \\`${value}\\` is an invalid y-parity value. Y-parity must be 0 or 1.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `v` value. */\nexport class InvalidVError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidVError'\n\n  constructor({ value }: { value: number }) {\n    super(`Value \\`${value}\\` is an invalid v value. v must be 27, 28 or >=35.`)\n  }\n}\n","// TODO(v3): Convert to sync.\n\nimport { secp256k1 } from '@noble/curves/secp256k1'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'\nimport {\n  type HexToBytesErrorType,\n  hexToBytes,\n} from '../../utils/encoding/toBytes.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport { serializeSignature } from '../../utils/signature/serializeSignature.js'\n\ntype To = 'object' | 'bytes' | 'hex'\n\nexport type SignParameters<to extends To = 'object'> = {\n  hash: Hex\n  privateKey: Hex\n  to?: to | To | undefined\n}\n\nexport type SignReturnType<to extends To = 'object'> =\n  | (to extends 'object' ? Signature : never)\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type SignErrorType =\n  | HexToBytesErrorType\n  | IsHexErrorType\n  | NumberToHexErrorType\n  | ErrorType\n\nlet extraEntropy: Hex | boolean = false\n\n/**\n * Sets extra entropy for signing functions.\n */\nexport function setSignEntropy(entropy: true | Hex) {\n  if (!entropy) throw new Error('must be a `true` or a hex value.')\n  extraEntropy = entropy\n}\n\n/**\n * @description Signs a hash with a given private key.\n *\n * @param hash The hash to sign.\n * @param privateKey The private key to sign with.\n *\n * @returns The signature.\n */\nexport async function sign<to extends To = 'object'>({\n  hash,\n  privateKey,\n  to = 'object',\n}: SignParameters<to>): Promise<SignReturnType<to>> {\n  const { r, s, recovery } = secp256k1.sign(\n    hash.slice(2),\n    privateKey.slice(2),\n    {\n      lowS: true,\n      extraEntropy: isHex(extraEntropy, { strict: false })\n        ? hexToBytes(extraEntropy)\n        : extraEntropy,\n    },\n  )\n  const signature = {\n    r: numberToHex(r, { size: 32 }),\n    s: numberToHex(s, { size: 32 }),\n    v: recovery ? 28n : 27n,\n    yParity: recovery,\n  }\n  return (() => {\n    if (to === 'bytes' || to === 'hex')\n      return serializeSignature({ ...signature, to })\n    return signature\n  })() as SignReturnType<to>\n}\n","import {\n  EVENT_CLIENT_AUTHENTICATE_ERRORS,\n  EVENT_CLIENT_AUTHENTICATE_TRACES,\n  EVENT_CLIENT_PAIRING_ERRORS,\n  EVENT_CLIENT_PAIRING_TRACES,\n  EVENT_CLIENT_SESSION_ERRORS,\n  EVENT_CLIENT_SESSION_TRACES,\n  EXPIRER_EVENTS,\n  PAIRING_EVENTS,\n  RELAYER_DEFAULT_PROTOCOL,\n  RELAYER_EVENTS,\n  TRANSPORT_TYPES,\n  VERIFY_SERVER,\n} from \"@walletconnect/core\";\n\nimport {\n  formatJsonRpcError,\n  formatJsonRpcRequest,\n  formatJsonRpcResult,\n  payloadId,\n  isJsonRpcError,\n  isJsonRpcRequest,\n  isJsonRpcResponse,\n  isJsonRpcResult,\n  JsonRpcRequest,\n  ErrorResponse,\n  getBigIntRpcId,\n} from \"@walletconnect/jsonrpc-utils\";\nimport { FIVE_MINUTES, ONE_SECOND, toMiliseconds } from \"@walletconnect/time\";\nimport {\n  EnginePrivate,\n  EngineTypes,\n  ExpirerTypes,\n  IEngine,\n  IEngineEvents,\n  JsonRpcTypes,\n  PendingRequestTypes,\n  Verify,\n  CoreTypes,\n  ProposalTypes,\n  RelayerTypes,\n  SessionTypes,\n  PairingTypes,\n  AuthTypes,\n  EventClientTypes,\n} from \"@walletconnect/types\";\nimport {\n  calcExpiry,\n  createDelayedPromise,\n  engineEvent,\n  getInternalError,\n  getSdkError,\n  isConformingNamespaces,\n  isExpired,\n  isSessionCompatible,\n  isUndefined,\n  isValidController,\n  isValidErrorReason,\n  isValidEvent,\n  isValidId,\n  isValidNamespaces,\n  isValidNamespacesChainId,\n  isValidNamespacesEvent,\n  isValidNamespacesRequest,\n  isValidObject,\n  isValidParams,\n  isValidRelay,\n  isValidRelays,\n  isValidRequest,\n  isValidRequestExpiry,\n  hashMessage,\n  isValidRequiredNamespaces,\n  isValidResponse,\n  isValidString,\n  parseExpirerTarget,\n  TYPE_1,\n  TYPE_2,\n  handleDeeplinkRedirect,\n  MemoryStore,\n  getDeepLink,\n  hashKey,\n  getDidAddress,\n  formatMessage,\n  getMethodsFromRecap,\n  buildNamespacesFromAuth,\n  createEncodedRecap,\n  getChainsFromRecap,\n  mergeEncodedRecaps,\n  getRecapFromResources,\n  validateSignedCacao,\n  getNamespacedDidChainId,\n  parseChainId,\n  getLinkModeURL,\n  BASE64,\n  BASE64URL,\n  getSearchParamFromURL,\n  isReactNative,\n  isTestRun,\n  isValidArray,\n  extractSolanaTransactionId,\n  getSuiDigest,\n  mergeRequiredAndOptionalNamespaces,\n  getNearTransactionIdFromSignedTransaction,\n  getAlgorandTransactionId,\n  buildSignedExtrinsicHash,\n  getSignDirectHash,\n  LimitedSet,\n  getWalletSendCallsHashes,\n} from \"@walletconnect/utils\";\nimport EventEmmiter from \"events\";\nimport {\n  ENGINE_CONTEXT,\n  ENGINE_RPC_OPTS,\n  PROPOSAL_EXPIRY_MESSAGE,\n  SESSION_EXPIRY,\n  SESSION_REQUEST_EXPIRY_BOUNDARIES,\n  METHODS_TO_VERIFY,\n  WALLETCONNECT_DEEPLINK_CHOICE,\n  ENGINE_QUEUE_STATES,\n  AUTH_PUBLIC_KEY_NAME,\n  TVF_METHODS,\n} from \"../constants/index.js\";\n\nexport class Engine extends IEngine {\n  public name = ENGINE_CONTEXT;\n\n  private events: IEngineEvents = new EventEmmiter();\n  private initialized = false;\n\n  /**\n   * Queue responsible for processing incoming requests such as session_update, session_event, session_ping etc\n   * It's needed when the client receives multiple requests at once from the mailbox immediately after initialization and to avoid attempting to process them all at the same time\n   */\n  private requestQueue: EngineTypes.EngineQueue<EngineTypes.EventCallback<JsonRpcRequest>> = {\n    state: ENGINE_QUEUE_STATES.idle,\n    queue: [],\n  };\n\n  /**\n   * Queue responsible for processing incoming session_request\n   * The queue emits the next request only after the previous one has been responded to\n   */\n  private sessionRequestQueue: EngineTypes.EngineQueue<PendingRequestTypes.Struct> = {\n    state: ENGINE_QUEUE_STATES.idle,\n    queue: [],\n  };\n\n  // This prevents duplicate emissions due to WalletConnect's at-least-once delivery guarantee.\n  // When disableRequestQueue is enabled, consumers must implement additional deduplication.\n  private emittedSessionRequests = new LimitedSet({ limit: 500 });\n\n  private requestQueueDelay = ONE_SECOND;\n  private expectedPairingMethodMap: Map<string, string[]> = new Map();\n  // Ephemeral (in-memory) map to store recently deleted items\n  private recentlyDeletedMap = new Map<\n    string | number,\n    \"pairing\" | \"session\" | \"proposal\" | \"request\"\n  >();\n\n  private recentlyDeletedLimit = 200;\n  private relayMessageCache: RelayerTypes.MessageEvent[] = [];\n  private pendingSessions: Map<\n    number,\n    {\n      sessionTopic: string;\n      pairingTopic: string;\n      proposalId: number;\n      publicKey: string;\n    }\n  > = new Map();\n\n  constructor(client: IEngine[\"client\"]) {\n    super(client);\n  }\n\n  public init: IEngine[\"init\"] = async () => {\n    if (!this.initialized) {\n      await this.cleanup();\n      this.registerRelayerEvents();\n      this.registerExpirerEvents();\n      this.registerPairingEvents();\n      await this.registerLinkModeListeners();\n      this.client.core.pairing.register({ methods: Object.keys(ENGINE_RPC_OPTS) });\n      this.initialized = true;\n      setTimeout(async () => {\n        await this.processPendingMessageEvents();\n\n        this.sessionRequestQueue.queue = this.getPendingSessionRequests();\n        this.processSessionRequestQueue();\n      }, toMiliseconds(this.requestQueueDelay));\n    }\n  };\n\n  private async processPendingMessageEvents() {\n    try {\n      const topics = this.client.session.keys;\n      const pendingMessages = this.client.core.relayer.messages.getWithoutAck(topics);\n      for (const [topic, messages] of Object.entries(pendingMessages)) {\n        for (const message of messages) {\n          try {\n            await this.onProviderMessageEvent({\n              topic,\n              message,\n              publishedAt: Date.now(),\n            });\n          } catch (error) {\n            this.client.logger.warn(\n              `Error processing pending message event for topic: ${topic}, message: ${message}`,\n            );\n          }\n        }\n      }\n    } catch (error) {\n      this.client.logger.warn(error, \"processPendingMessageEvents failed\");\n    }\n  }\n\n  // ---------- Public ------------------------------------------------ //\n\n  public connect: IEngine[\"connect\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    const connectParams = {\n      ...params,\n      requiredNamespaces: params.requiredNamespaces || {},\n      optionalNamespaces: params.optionalNamespaces || {},\n    };\n    await this.isValidConnect(connectParams);\n\n    // requiredNamespaces are deprecated, assign them to optionalNamespaces\n    connectParams.optionalNamespaces = mergeRequiredAndOptionalNamespaces(\n      connectParams.requiredNamespaces,\n      connectParams.optionalNamespaces,\n    );\n\n    connectParams.requiredNamespaces = {};\n\n    const {\n      pairingTopic,\n      requiredNamespaces,\n      optionalNamespaces,\n      sessionProperties,\n      scopedProperties,\n      relays,\n    } = connectParams;\n    let topic = pairingTopic;\n    let uri: string | undefined;\n    let active = false;\n    try {\n      if (topic) {\n        const pairing = this.client.core.pairing.pairings.get(topic);\n        this.client.logger.warn(\n          \"connect() with existing pairing topic is deprecated and will be removed in the next major release.\",\n        );\n        active = pairing.active;\n      }\n    } catch (error) {\n      this.client.logger.error(`connect() -> pairing.get(${topic}) failed`);\n      throw error;\n    }\n    if (!topic || !active) {\n      const { topic: newTopic, uri: newUri } = await this.client.core.pairing.create({\n        internal: { skipSubscribe: true },\n      });\n      topic = newTopic;\n      uri = newUri;\n    }\n    // safety check to ensure pairing topic is available\n    if (!topic) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `connect() pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n\n    const publicKey = await this.client.core.crypto.generateKeyPair();\n\n    const expiry = ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl || FIVE_MINUTES;\n    const expiryTimestamp = calcExpiry(expiry);\n    const proposal = {\n      requiredNamespaces,\n      optionalNamespaces,\n      relays: relays ?? [{ protocol: RELAYER_DEFAULT_PROTOCOL }],\n      proposer: {\n        publicKey,\n        metadata: this.client.metadata,\n      },\n      expiryTimestamp,\n      pairingTopic: topic,\n      ...(sessionProperties && { sessionProperties }),\n      ...(scopedProperties && { scopedProperties }),\n      id: payloadId(),\n    };\n    const sessionConnectTarget = engineEvent(\"session_connect\", proposal.id);\n\n    const {\n      reject,\n      resolve,\n      done: approval,\n    } = createDelayedPromise<SessionTypes.Struct>(expiry, PROPOSAL_EXPIRY_MESSAGE);\n\n    const proposalExpireHandler = ({ id }: { id: number }) => {\n      if (id === proposal.id) {\n        this.client.events.off(\"proposal_expire\", proposalExpireHandler);\n        this.pendingSessions.delete(proposal.id);\n        // emit the event to trigger reject, this approach automatically cleans up the .once listener below\n        this.events.emit(sessionConnectTarget, {\n          error: { message: PROPOSAL_EXPIRY_MESSAGE, code: 0 },\n        });\n      }\n    };\n\n    this.client.events.on(\"proposal_expire\", proposalExpireHandler);\n    this.events.once<\"session_connect\">(sessionConnectTarget, ({ error, session }) => {\n      this.client.events.off(\"proposal_expire\", proposalExpireHandler);\n      if (error) reject(error);\n      else if (session) {\n        resolve(session);\n      }\n    });\n\n    await this.sendProposeSession({\n      proposal,\n      publishOpts: {\n        internal: {\n          throwOnFailedPublish: true,\n        },\n        tvf: {\n          correlationId: proposal.id,\n        },\n      },\n    });\n\n    await this.setProposal(proposal.id, proposal);\n    return { uri, approval };\n  };\n\n  public pair: IEngine[\"pair\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      return await this.client.core.pairing.pair(params);\n    } catch (error) {\n      this.client.logger.error(\"pair() failed\");\n      throw error;\n    }\n  };\n\n  public approve: IEngine[\"approve\"] = async (params) => {\n    const configEvent = this.client.core.eventClient.createEvent({\n      properties: {\n        topic: params?.id?.toString(),\n        trace: [EVENT_CLIENT_SESSION_TRACES.session_approve_started],\n      },\n    });\n    try {\n      this.isInitialized();\n      await this.confirmOnlineStateOrThrow();\n    } catch (error) {\n      configEvent.setError(EVENT_CLIENT_SESSION_ERRORS.no_internet_connection);\n      throw error;\n    }\n    try {\n      await this.isValidProposalId(params?.id);\n    } catch (error) {\n      this.client.logger.error(`approve() -> proposal.get(${params?.id}) failed`);\n      configEvent.setError(EVENT_CLIENT_SESSION_ERRORS.proposal_not_found);\n      throw error;\n    }\n\n    try {\n      await this.isValidApprove(params);\n    } catch (error) {\n      this.client.logger.error(\"approve() -> isValidApprove() failed\");\n      configEvent.setError(\n        EVENT_CLIENT_SESSION_ERRORS.session_approve_namespace_validation_failure,\n      );\n      throw error;\n    }\n\n    const { id, relayProtocol, namespaces, sessionProperties, scopedProperties, sessionConfig } =\n      params;\n\n    const proposal = this.client.proposal.get(id);\n\n    this.client.core.eventClient.deleteEvent({ eventId: configEvent.eventId });\n\n    const { pairingTopic, proposer, requiredNamespaces, optionalNamespaces } = proposal;\n\n    let event = this.client.core.eventClient?.getEvent({\n      topic: pairingTopic,\n    }) as EventClientTypes.Event;\n    if (!event) {\n      event = this.client.core.eventClient?.createEvent({\n        type: EVENT_CLIENT_SESSION_TRACES.session_approve_started,\n        properties: {\n          topic: pairingTopic,\n          trace: [\n            EVENT_CLIENT_SESSION_TRACES.session_approve_started,\n            EVENT_CLIENT_SESSION_TRACES.session_namespaces_validation_success,\n          ],\n        },\n      });\n    }\n\n    const selfPublicKey = await this.client.core.crypto.generateKeyPair();\n    const peerPublicKey = proposer.publicKey;\n    const sessionTopic = await this.client.core.crypto.generateSharedKey(\n      selfPublicKey,\n      peerPublicKey,\n    );\n    const sessionSettle = {\n      relay: { protocol: relayProtocol ?? \"irn\" },\n      namespaces,\n      controller: { publicKey: selfPublicKey, metadata: this.client.metadata },\n      expiry: calcExpiry(SESSION_EXPIRY),\n      ...(sessionProperties && { sessionProperties }),\n      ...(scopedProperties && { scopedProperties }),\n      ...(sessionConfig && { sessionConfig }),\n    };\n    const transportType = TRANSPORT_TYPES.relay;\n    event.addTrace(EVENT_CLIENT_SESSION_TRACES.subscribing_session_topic);\n    try {\n      await this.client.core.relayer.subscribe(sessionTopic, {\n        transportType,\n        internal: { skipSubscribe: true },\n      });\n    } catch (error) {\n      event.setError(EVENT_CLIENT_SESSION_ERRORS.subscribe_session_topic_failure);\n      throw error;\n    }\n\n    event.addTrace(EVENT_CLIENT_SESSION_TRACES.subscribe_session_topic_success);\n\n    const session = {\n      ...sessionSettle,\n      topic: sessionTopic,\n      requiredNamespaces,\n      optionalNamespaces,\n      pairingTopic,\n      acknowledged: false,\n      self: sessionSettle.controller,\n      peer: {\n        publicKey: proposer.publicKey,\n        metadata: proposer.metadata,\n      },\n      controller: selfPublicKey,\n      transportType: TRANSPORT_TYPES.relay,\n    };\n    await this.client.session.set(sessionTopic, session);\n\n    event.addTrace(EVENT_CLIENT_SESSION_TRACES.store_session);\n\n    try {\n      await this.sendApproveSession({\n        sessionTopic,\n        proposal,\n        pairingProposalResponse: {\n          relay: {\n            protocol: relayProtocol ?? \"irn\",\n          },\n          responderPublicKey: selfPublicKey,\n        },\n        sessionSettleRequest: sessionSettle,\n        publishOpts: {\n          internal: {\n            throwOnFailedPublish: true,\n          },\n          tvf: {\n            correlationId: id,\n          },\n        },\n      });\n\n      event.addTrace(EVENT_CLIENT_SESSION_TRACES.session_approve_publish_success);\n    } catch (error) {\n      this.client.logger.error(error);\n      // if the publish fails, delete the session and throw an error\n      this.client.session.delete(sessionTopic, getSdkError(\"USER_DISCONNECTED\"));\n      await this.client.core.relayer.unsubscribe(sessionTopic);\n      throw error;\n    }\n\n    this.client.core.eventClient.deleteEvent({ eventId: event.eventId });\n\n    await this.client.core.pairing.updateMetadata({\n      topic: pairingTopic,\n      metadata: proposer.metadata,\n    });\n    await this.deleteProposal(id);\n    await this.client.core.pairing.activate({ topic: pairingTopic });\n    await this.setExpiry(sessionTopic, calcExpiry(SESSION_EXPIRY));\n    return {\n      topic: sessionTopic,\n      acknowledged: () => Promise.resolve(this.client.session.get(sessionTopic)),\n    };\n  };\n\n  public reject: IEngine[\"reject\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      await this.isValidReject(params);\n    } catch (error) {\n      this.client.logger.error(\"reject() -> isValidReject() failed\");\n      throw error;\n    }\n    const { id, reason } = params;\n    let pairingTopic;\n    try {\n      const proposal = this.client.proposal.get(id);\n      pairingTopic = proposal.pairingTopic;\n    } catch (error) {\n      this.client.logger.error(`reject() -> proposal.get(${id}) failed`);\n      throw error;\n    }\n\n    if (pairingTopic) {\n      await this.sendError({\n        id,\n        topic: pairingTopic,\n        error: reason,\n        rpcOpts: ENGINE_RPC_OPTS.wc_sessionPropose.reject,\n      });\n    }\n\n    await this.deleteProposal(id);\n  };\n\n  public update: IEngine[\"update\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      await this.isValidUpdate(params);\n    } catch (error) {\n      this.client.logger.error(\"update() -> isValidUpdate() failed\");\n      throw error;\n    }\n    const { topic, namespaces } = params;\n\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    const clientRpcId = payloadId();\n    const relayRpcId = getBigIntRpcId().toString() as any;\n\n    const oldNamespaces = this.client.session.get(topic).namespaces;\n    this.events.once(engineEvent(\"session_update\", clientRpcId), ({ error }: any) => {\n      if (error) reject(error);\n      else {\n        resolve();\n      }\n    });\n    // Update the session with the new namespaces, if the publish fails, revert to the old.\n    // This allows the client to use the updated session like emitting events\n    // without waiting for the peer to acknowledge\n    await this.client.session.update(topic, { namespaces });\n    await this.sendRequest({\n      topic,\n      method: \"wc_sessionUpdate\",\n      params: { namespaces },\n      throwOnFailedPublish: true,\n      clientRpcId,\n      relayRpcId,\n    }).catch((error) => {\n      this.client.logger.error(error);\n      this.client.session.update(topic, { namespaces: oldNamespaces });\n      reject(error);\n    });\n    return { acknowledged };\n  };\n\n  public extend: IEngine[\"extend\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      await this.isValidExtend(params);\n    } catch (error) {\n      this.client.logger.error(\"extend() -> isValidExtend() failed\");\n      throw error;\n    }\n\n    const { topic } = params;\n    const clientRpcId = payloadId();\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    this.events.once(engineEvent(\"session_extend\", clientRpcId), ({ error }: any) => {\n      if (error) reject(error);\n      else resolve();\n    });\n\n    await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n    this.sendRequest({\n      topic,\n      method: \"wc_sessionExtend\",\n      params: {},\n      clientRpcId,\n      throwOnFailedPublish: true,\n    }).catch((e) => {\n      reject(e);\n    });\n\n    return { acknowledged };\n  };\n\n  public request: IEngine[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    this.isInitialized();\n    try {\n      await this.isValidRequest(params);\n    } catch (error) {\n      this.client.logger.error(\"request() -> isValidRequest() failed\");\n      throw error;\n    }\n    const { chainId, request, topic, expiry = ENGINE_RPC_OPTS.wc_sessionRequest.req.ttl } = params;\n    const session = this.client.session.get(topic);\n\n    if (session?.transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n    const clientRpcId = payloadId();\n    const relayRpcId = getBigIntRpcId().toString() as any;\n    const { done, resolve, reject } = createDelayedPromise<T>(\n      expiry,\n      \"Request expired. Please try again.\",\n    );\n    this.events.once<\"session_request\">(\n      engineEvent(\"session_request\", clientRpcId),\n      ({ error, result }) => {\n        if (error) reject(error);\n        else resolve(result);\n      },\n    );\n    const protocolMethod = \"wc_sessionRequest\";\n    const appLink = this.getAppLinkIfEnabled(session.peer.metadata, session.transportType);\n    if (appLink) {\n      await this.sendRequest({\n        clientRpcId,\n        relayRpcId,\n        topic,\n        method: protocolMethod,\n        params: {\n          request: {\n            ...request,\n            expiryTimestamp: calcExpiry(expiry),\n          },\n          chainId,\n        },\n        expiry,\n        throwOnFailedPublish: true,\n        appLink,\n      }).catch((error) => reject(error));\n\n      this.client.events.emit(\"session_request_sent\", {\n        topic,\n        request,\n        chainId,\n        id: clientRpcId,\n      });\n      const result = await done();\n      return result;\n    }\n\n    const protocolRequestParams: JsonRpcTypes.RequestParams[\"wc_sessionRequest\"] = {\n      request: {\n        ...request,\n        expiryTimestamp: calcExpiry(expiry),\n      },\n      chainId,\n    };\n\n    return await Promise.all([\n      new Promise<void>(async (resolve) => {\n        await this.sendRequest({\n          clientRpcId,\n          relayRpcId,\n          topic,\n          method: protocolMethod,\n          params: protocolRequestParams,\n          expiry,\n          throwOnFailedPublish: true,\n          tvf: this.getTVFParams(clientRpcId, protocolRequestParams),\n        }).catch((error) => reject(error));\n        this.client.events.emit(\"session_request_sent\", {\n          topic,\n          request,\n          chainId,\n          id: clientRpcId,\n        });\n        resolve();\n      }),\n      new Promise<void>(async (resolve) => {\n        // only attempt to handle deeplinks if they are not explicitly disabled in the session config\n        if (!session.sessionConfig?.disableDeepLink) {\n          const wcDeepLink = (await getDeepLink(\n            this.client.core.storage,\n            WALLETCONNECT_DEEPLINK_CHOICE,\n          )) as string;\n          await handleDeeplinkRedirect({ id: clientRpcId, topic, wcDeepLink });\n        }\n        resolve();\n      }),\n      done(),\n    ]).then((result) => result[2]); // order is important here, we want to return the result of the `done` promise\n  };\n\n  public respond: IEngine[\"respond\"] = async (params) => {\n    this.isInitialized();\n    const event = this.client.core.eventClient.createEvent({\n      properties: {\n        topic: params?.topic || params?.response?.id?.toString(),\n        trace: [EVENT_CLIENT_SESSION_TRACES.session_request_response_started],\n      },\n    });\n    try {\n      await this.isValidRespond(params);\n    } catch (error) {\n      event.addTrace((error as Error)?.message);\n      event.setError(EVENT_CLIENT_SESSION_ERRORS.session_request_response_validation_failure);\n\n      throw error;\n    }\n\n    event.addTrace(EVENT_CLIENT_SESSION_TRACES.session_request_response_validation_success);\n\n    const { topic, response } = params;\n    const { id } = response;\n    const session = this.client.session.get(topic);\n\n    if (session.transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n\n    const appLink = this.getAppLinkIfEnabled(session.peer.metadata, session.transportType);\n    try {\n      event.addTrace(EVENT_CLIENT_SESSION_TRACES.session_request_response_publish_started);\n      if (isJsonRpcResult(response)) {\n        await this.sendResult({\n          id,\n          topic,\n          result: response.result,\n          throwOnFailedPublish: true,\n          appLink,\n        });\n      } else if (isJsonRpcError(response)) {\n        await this.sendError({ id, topic, error: response.error, appLink });\n      }\n      this.cleanupAfterResponse(params);\n    } catch (error) {\n      event.addTrace((error as Error)?.message);\n      event.setError(EVENT_CLIENT_SESSION_ERRORS.session_request_response_publish_failure);\n      throw error;\n    }\n  };\n\n  public ping: IEngine[\"ping\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      await this.isValidPing(params);\n    } catch (error) {\n      this.client.logger.error(\"ping() -> isValidPing() failed\");\n      throw error;\n    }\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      const clientRpcId = payloadId();\n      const relayRpcId = getBigIntRpcId().toString() as any;\n      const { done, resolve, reject } = createDelayedPromise<void>();\n      this.events.once(engineEvent(\"session_ping\", clientRpcId), ({ error }: any) => {\n        if (error) reject(error);\n        else resolve();\n      });\n      await Promise.all([\n        this.sendRequest({\n          topic,\n          method: \"wc_sessionPing\",\n          params: {},\n          throwOnFailedPublish: true,\n          clientRpcId,\n          relayRpcId,\n        }),\n        done(),\n      ]);\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      this.client.logger.warn(\n        \"ping() on pairing topic is deprecated and will be removed in the next major release.\",\n      );\n      await this.client.core.pairing.ping({ topic });\n    }\n  };\n\n  public emit: IEngine[\"emit\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    await this.isValidEmit(params);\n    const { topic, event, chainId } = params;\n    const relayRpcId = getBigIntRpcId().toString() as any;\n    const clientRpcId = payloadId();\n    await this.sendRequest({\n      topic,\n      method: \"wc_sessionEvent\",\n      params: { event, chainId },\n      throwOnFailedPublish: true,\n      relayRpcId,\n      clientRpcId,\n    });\n  };\n\n  public disconnect: IEngine[\"disconnect\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    await this.isValidDisconnect(params);\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      // await an ack to ensure the relay has received the disconnect request\n      await this.sendRequest({\n        topic,\n        method: \"wc_sessionDelete\",\n        params: getSdkError(\"USER_DISCONNECTED\"),\n        throwOnFailedPublish: true,\n      });\n      await this.deleteSession({ topic, emitEvent: false });\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      await this.client.core.pairing.disconnect({ topic });\n    } else {\n      const { message } = getInternalError(\n        \"MISMATCHED_TOPIC\",\n        `Session or pairing topic not found: ${topic}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  public find: IEngine[\"find\"] = (params) => {\n    this.isInitialized();\n    return this.client.session.getAll().filter((session) => isSessionCompatible(session, params));\n  };\n\n  public getPendingSessionRequests: IEngine[\"getPendingSessionRequests\"] = () => {\n    return this.client.pendingRequest.getAll();\n  };\n\n  // ---------- Auth ------------------------------------------------ //\n\n  public authenticate: IEngine[\"authenticate\"] = async (params, walletUniversalLink) => {\n    this.isInitialized();\n    this.isValidAuthenticate(params);\n\n    const isLinkMode =\n      walletUniversalLink &&\n      this.client.core.linkModeSupportedApps.includes(walletUniversalLink) &&\n      this.client.metadata.redirect?.linkMode;\n\n    const transportType: RelayerTypes.TransportType = isLinkMode\n      ? TRANSPORT_TYPES.link_mode\n      : TRANSPORT_TYPES.relay;\n\n    if (transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n\n    const {\n      chains,\n      statement = \"\",\n      uri,\n      domain,\n      nonce,\n      type,\n      exp,\n      nbf,\n      methods = [],\n      expiry,\n    } = params;\n    // reassign resources to remove reference as the array is modified and might cause side effects\n    const resources = [...(params.resources || [])];\n\n    const { topic: pairingTopic, uri: connectionUri } = await this.client.core.pairing.create({\n      methods: [\"wc_sessionAuthenticate\"],\n      transportType,\n    });\n\n    this.client.logger.info({\n      message: \"Generated new pairing\",\n      pairing: { topic: pairingTopic, uri: connectionUri },\n    });\n\n    const publicKey = await this.client.core.crypto.generateKeyPair();\n    const responseTopic = hashKey(publicKey);\n\n    await Promise.all([\n      this.client.auth.authKeys.set(AUTH_PUBLIC_KEY_NAME, { responseTopic, publicKey }),\n      this.client.auth.pairingTopics.set(responseTopic, { topic: responseTopic, pairingTopic }),\n    ]);\n\n    // Subscribe to response topic\n    await this.client.core.relayer.subscribe(responseTopic, { transportType });\n\n    this.client.logger.info(`sending request to new pairing topic: ${pairingTopic}`);\n\n    if (methods.length > 0) {\n      const { namespace } = parseChainId(chains[0]);\n      let recap = createEncodedRecap(namespace, \"request\", methods);\n      const existingRecap = getRecapFromResources(resources);\n      if (existingRecap) {\n        // per Recaps spec, recap must occupy the last position in the resources array\n        // using .pop to remove the element given we already checked it's a recap and will replace it\n        const mergedRecap = mergeEncodedRecaps(recap, resources.pop() as string);\n        recap = mergedRecap;\n      }\n      resources.push(recap);\n    }\n\n    // Ensure the expiry is greater than the minimum required for the request - currently 1h\n    const authRequestExpiry =\n      expiry && expiry > ENGINE_RPC_OPTS.wc_sessionAuthenticate.req.ttl\n        ? expiry\n        : ENGINE_RPC_OPTS.wc_sessionAuthenticate.req.ttl;\n\n    const request: AuthTypes.SessionAuthenticateRequestParams = {\n      authPayload: {\n        type: type ?? \"caip122\",\n        chains,\n        statement,\n        aud: uri,\n        domain,\n        version: \"1\",\n        nonce,\n        iat: new Date().toISOString(),\n        exp,\n        nbf,\n        resources,\n      },\n      requester: { publicKey, metadata: this.client.metadata },\n      expiryTimestamp: calcExpiry(authRequestExpiry),\n    };\n\n    // ----- build namespaces for fallback session proposal ----- //\n    const namespaces = {\n      eip155: {\n        chains,\n        // request `personal_sign` method by default to allow for fallback siwe\n        methods: [...new Set([\"personal_sign\", ...methods])],\n        events: [\"chainChanged\", \"accountsChanged\"],\n      },\n    };\n\n    const proposal = {\n      requiredNamespaces: {},\n      optionalNamespaces: namespaces,\n      relays: [{ protocol: \"irn\" }],\n      pairingTopic,\n      proposer: {\n        publicKey,\n        metadata: this.client.metadata,\n      },\n      expiryTimestamp: calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl),\n      id: payloadId(),\n    };\n\n    const { done, resolve, reject } = createDelayedPromise(authRequestExpiry, \"Request expired\");\n\n    const authenticateId = payloadId();\n    const sessionConnectEventTarget = engineEvent(\"session_connect\", proposal.id);\n    const authenticateEventTarget = engineEvent(\"session_request\", authenticateId);\n\n    // handle fallback session proposal response\n    const onSessionConnect = async ({ error, session }: any) => {\n      // cleanup listener for authenticate response\n      this.events.off(authenticateEventTarget, onAuthenticate);\n      if (error) reject(error);\n      else if (session) {\n        resolve({\n          session,\n        });\n      }\n    };\n    // handle session authenticate response\n    const onAuthenticate = async (payload: any) => {\n      // delete this auth request on response\n      // we're using payload from the wallet to establish the session so we don't need to keep this around\n      await this.deletePendingAuthRequest(authenticateId, { message: \"fulfilled\", code: 0 });\n      if (payload.error) {\n        // wallets that do not support wc_sessionAuthenticate will return an error\n        // we should not reject the promise in this case as the fallback session proposal will be used\n        const error = getSdkError(\"WC_METHOD_UNSUPPORTED\", \"wc_sessionAuthenticate\");\n        if (payload.error.code === error.code) return;\n\n        // cleanup listener for fallback response\n        this.events.off(sessionConnectEventTarget, onSessionConnect);\n        return reject(payload.error.message);\n      }\n      // delete fallback proposal on successful authenticate as the proposal will not be responded to\n      await this.deleteProposal(proposal.id);\n      // cleanup listener for fallback response\n      this.events.off(sessionConnectEventTarget, onSessionConnect);\n\n      const {\n        cacaos,\n        responder,\n      }: {\n        cacaos: AuthTypes.SessionAuthenticateResponseParams[\"cacaos\"];\n        responder: AuthTypes.SessionAuthenticateResponseParams[\"responder\"];\n      } = payload.result;\n\n      const approvedMethods: string[] = [];\n      const approvedAccounts: string[] = [];\n      for (const cacao of cacaos) {\n        const isValid = await validateSignedCacao({ cacao, projectId: this.client.core.projectId });\n        if (!isValid) {\n          this.client.logger.error(cacao, \"Signature verification failed\");\n          reject(getSdkError(\"SESSION_SETTLEMENT_FAILED\", \"Signature verification failed\"));\n        }\n\n        const { p: payload } = cacao;\n        const recap = getRecapFromResources(payload.resources);\n\n        const approvedChains: string[] = [getNamespacedDidChainId(payload.iss) as string];\n        const parsedAddress = getDidAddress(payload.iss) as string;\n\n        if (recap) {\n          const methodsfromRecap = getMethodsFromRecap(recap);\n          const chainsFromRecap = getChainsFromRecap(recap);\n          approvedMethods.push(...methodsfromRecap);\n          approvedChains.push(...chainsFromRecap);\n        }\n\n        for (const chain of approvedChains) {\n          approvedAccounts.push(`${chain}:${parsedAddress}`);\n        }\n      }\n      const sessionTopic = await this.client.core.crypto.generateSharedKey(\n        publicKey,\n        responder.publicKey,\n      );\n\n      //create session object\n      let session: SessionTypes.Struct | undefined;\n\n      if (approvedMethods.length > 0) {\n        session = {\n          topic: sessionTopic,\n          acknowledged: true,\n          self: {\n            publicKey,\n            metadata: this.client.metadata,\n          },\n          peer: responder,\n          controller: responder.publicKey,\n          expiry: calcExpiry(SESSION_EXPIRY),\n          requiredNamespaces: {},\n          optionalNamespaces: {},\n          relay: { protocol: \"irn\" },\n          pairingTopic,\n          namespaces: buildNamespacesFromAuth(\n            [...new Set(approvedMethods)],\n            [...new Set(approvedAccounts)],\n          ),\n          transportType,\n        };\n\n        await this.client.core.relayer.subscribe(sessionTopic, { transportType });\n        await this.client.session.set(sessionTopic, session);\n        if (pairingTopic) {\n          await this.client.core.pairing.updateMetadata({\n            topic: pairingTopic,\n            metadata: responder.metadata,\n          });\n        }\n\n        session = this.client.session.get(sessionTopic);\n      }\n\n      if (\n        this.client.metadata.redirect?.linkMode &&\n        responder.metadata.redirect?.linkMode &&\n        responder.metadata.redirect?.universal &&\n        walletUniversalLink\n      ) {\n        // save wallet link in array of apps that support linkMode\n        this.client.core.addLinkModeSupportedApp(responder.metadata.redirect.universal);\n\n        this.client.session.update(sessionTopic, {\n          transportType: TRANSPORT_TYPES.link_mode,\n        });\n      }\n\n      resolve({\n        auths: cacaos,\n        session,\n      });\n    };\n\n    // subscribe to response events\n    this.events.once<\"session_connect\">(sessionConnectEventTarget, onSessionConnect);\n    this.events.once(authenticateEventTarget, onAuthenticate);\n\n    let linkModeURL;\n    try {\n      if (isLinkMode) {\n        const payload = formatJsonRpcRequest(\"wc_sessionAuthenticate\", request, authenticateId);\n        this.client.core.history.set(pairingTopic, payload);\n        const message = await this.client.core.crypto.encode(\"\", payload, {\n          type: TYPE_2,\n          encoding: BASE64URL,\n        });\n        linkModeURL = getLinkModeURL(walletUniversalLink, pairingTopic, message);\n      } else {\n        // send both (main & fallback) requests\n        await Promise.all([\n          this.sendRequest({\n            topic: pairingTopic,\n            method: \"wc_sessionAuthenticate\",\n            params: request,\n            expiry: params.expiry,\n            throwOnFailedPublish: true,\n            clientRpcId: authenticateId,\n          }),\n          this.sendRequest({\n            topic: pairingTopic,\n            method: \"wc_sessionPropose\",\n            params: proposal,\n            expiry: ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl,\n            throwOnFailedPublish: true,\n            clientRpcId: proposal.id,\n          }),\n        ]);\n      }\n    } catch (error) {\n      // cleanup listeners on failed publish\n      this.events.off(sessionConnectEventTarget, onSessionConnect);\n      this.events.off(authenticateEventTarget, onAuthenticate);\n      throw error;\n    }\n\n    await this.setProposal(proposal.id, proposal);\n    await this.setAuthRequest(authenticateId, {\n      request: {\n        ...request,\n        verifyContext: {} as any,\n      },\n      pairingTopic,\n      transportType,\n    });\n\n    return {\n      uri: linkModeURL ?? connectionUri,\n      response: done,\n    } as EngineTypes.SessionAuthenticateResponsePromise;\n  };\n\n  public approveSessionAuthenticate: IEngine[\"approveSessionAuthenticate\"] = async (\n    sessionAuthenticateResponseParams,\n  ) => {\n    const { id, auths } = sessionAuthenticateResponseParams;\n\n    const event = this.client.core.eventClient.createEvent({\n      properties: {\n        topic: id.toString(),\n        trace: [EVENT_CLIENT_AUTHENTICATE_TRACES.authenticated_session_approve_started],\n      },\n    });\n\n    try {\n      this.isInitialized();\n    } catch (error) {\n      event.setError(EVENT_CLIENT_AUTHENTICATE_ERRORS.no_internet_connection);\n      throw error;\n    }\n\n    const pendingRequest = this.getPendingAuthRequest(id);\n\n    if (!pendingRequest) {\n      event.setError(\n        EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_pending_request_not_found,\n      );\n      throw new Error(`Could not find pending auth request with id ${id}`);\n    }\n\n    const transportType = pendingRequest.transportType || TRANSPORT_TYPES.relay;\n    if (transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n\n    const receiverPublicKey = pendingRequest.requester.publicKey;\n    const senderPublicKey = await this.client.core.crypto.generateKeyPair();\n    const responseTopic = hashKey(receiverPublicKey);\n\n    const encodeOpts = {\n      type: TYPE_1,\n      receiverPublicKey,\n      senderPublicKey,\n    };\n\n    const approvedMethods: string[] = [];\n    const approvedAccounts: string[] = [];\n    for (const cacao of auths) {\n      const isValid = await validateSignedCacao({ cacao, projectId: this.client.core.projectId });\n      if (!isValid) {\n        event.setError(EVENT_CLIENT_AUTHENTICATE_ERRORS.invalid_cacao);\n\n        const invalidErr = getSdkError(\n          \"SESSION_SETTLEMENT_FAILED\",\n          \"Signature verification failed\",\n        );\n\n        await this.sendError({\n          id,\n          topic: responseTopic,\n          error: invalidErr,\n          encodeOpts,\n        });\n\n        throw new Error(invalidErr.message);\n      }\n\n      event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.cacaos_verified);\n\n      const { p: payload } = cacao;\n      const recap = getRecapFromResources(payload.resources);\n\n      const approvedChains: string[] = [getNamespacedDidChainId(payload.iss) as string];\n\n      const parsedAddress = getDidAddress(payload.iss) as string;\n\n      if (recap) {\n        const methodsfromRecap = getMethodsFromRecap(recap);\n        const chainsFromRecap = getChainsFromRecap(recap);\n        approvedMethods.push(...methodsfromRecap);\n        approvedChains.push(...chainsFromRecap);\n      }\n      for (const chain of approvedChains) {\n        approvedAccounts.push(`${chain}:${parsedAddress}`);\n      }\n    }\n\n    const sessionTopic = await this.client.core.crypto.generateSharedKey(\n      senderPublicKey,\n      receiverPublicKey,\n    );\n\n    event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.create_authenticated_session_topic);\n\n    let session: SessionTypes.Struct | undefined;\n    if (approvedMethods?.length > 0) {\n      session = {\n        topic: sessionTopic,\n        acknowledged: true,\n        self: {\n          publicKey: senderPublicKey,\n          metadata: this.client.metadata,\n        },\n        peer: {\n          publicKey: receiverPublicKey,\n          metadata: pendingRequest.requester.metadata,\n        },\n        controller: receiverPublicKey,\n        expiry: calcExpiry(SESSION_EXPIRY),\n        authentication: auths,\n        requiredNamespaces: {},\n        optionalNamespaces: {},\n        relay: { protocol: \"irn\" },\n        pairingTopic: pendingRequest.pairingTopic,\n        namespaces: buildNamespacesFromAuth(\n          [...new Set(approvedMethods)],\n          [...new Set(approvedAccounts)],\n        ),\n        transportType,\n      };\n\n      event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.subscribing_authenticated_session_topic);\n\n      try {\n        await this.client.core.relayer.subscribe(sessionTopic, { transportType });\n      } catch (error) {\n        event.setError(\n          EVENT_CLIENT_AUTHENTICATE_ERRORS.subscribe_authenticated_session_topic_failure,\n        );\n        throw error;\n      }\n\n      event.addTrace(\n        EVENT_CLIENT_AUTHENTICATE_TRACES.subscribe_authenticated_session_topic_success,\n      );\n\n      await this.client.session.set(sessionTopic, session);\n\n      event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.store_authenticated_session);\n\n      await this.client.core.pairing.updateMetadata({\n        topic: pendingRequest.pairingTopic,\n        metadata: pendingRequest.requester.metadata,\n      });\n    }\n\n    event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.publishing_authenticated_session_approve);\n\n    try {\n      await this.sendResult<\"wc_sessionAuthenticate\">({\n        topic: responseTopic,\n        id,\n        result: {\n          cacaos: auths,\n          responder: {\n            publicKey: senderPublicKey,\n            metadata: this.client.metadata,\n          },\n        },\n        encodeOpts,\n        throwOnFailedPublish: true,\n        appLink: this.getAppLinkIfEnabled(pendingRequest.requester.metadata, transportType),\n      });\n    } catch (error) {\n      event.setError(\n        EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_approve_publish_failure,\n      );\n      throw error;\n    }\n\n    await this.client.auth.requests.delete(id, { message: \"fulfilled\", code: 0 });\n    await this.client.core.pairing.activate({ topic: pendingRequest.pairingTopic });\n    this.client.core.eventClient.deleteEvent({ eventId: event.eventId });\n\n    return { session };\n  };\n\n  public rejectSessionAuthenticate: IEngine[\"rejectSessionAuthenticate\"] = async (params) => {\n    this.isInitialized();\n\n    const { id, reason } = params;\n\n    const pendingRequest = this.getPendingAuthRequest(id);\n\n    if (!pendingRequest) {\n      throw new Error(`Could not find pending auth request with id ${id}`);\n    }\n\n    if (pendingRequest.transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n\n    const receiverPublicKey = pendingRequest.requester.publicKey;\n    const senderPublicKey = await this.client.core.crypto.generateKeyPair();\n    const responseTopic = hashKey(receiverPublicKey);\n\n    const encodeOpts = {\n      type: TYPE_1,\n      receiverPublicKey,\n      senderPublicKey,\n    };\n\n    await this.sendError({\n      id,\n      topic: responseTopic,\n      error: reason,\n      encodeOpts,\n      rpcOpts: ENGINE_RPC_OPTS.wc_sessionAuthenticate.reject,\n      appLink: this.getAppLinkIfEnabled(\n        pendingRequest.requester.metadata,\n        pendingRequest.transportType,\n      ),\n    });\n    await this.client.auth.requests.delete(id, { message: \"rejected\", code: 0 });\n    await this.deleteProposal(id);\n  };\n\n  public formatAuthMessage: IEngine[\"formatAuthMessage\"] = (params) => {\n    this.isInitialized();\n    const { request, iss } = params;\n    return formatMessage(request, iss);\n  };\n\n  /**\n   * no longer used as the client initializes instantly without waiting to connect+subscribe\n   * @deprecated\n   */\n  public processRelayMessageCache: IEngine[\"processRelayMessageCache\"] = () => {\n    // process the relay messages cache in the next tick to allow event listeners to be registered by the implementing app\n    setTimeout(async () => {\n      if (this.relayMessageCache.length === 0) return;\n      while (this.relayMessageCache.length > 0) {\n        try {\n          const message = this.relayMessageCache.shift();\n          if (message) {\n            await this.onRelayMessage(message);\n          }\n        } catch (error) {\n          this.client.logger.error(error);\n        }\n      }\n    }, 50);\n  };\n\n  // ---------- Private Helpers --------------------------------------- //\n\n  private cleanupDuplicatePairings: EnginePrivate[\"cleanupDuplicatePairings\"] = async (\n    session: SessionTypes.Struct,\n  ) => {\n    // older SDK versions are missing the `pairingTopic` prop thus we need to check for it\n    if (!session.pairingTopic) return;\n\n    try {\n      const pairing = this.client.core.pairing.pairings.get(session.pairingTopic);\n      const allPairings = this.client.core.pairing.pairings.getAll();\n      const duplicates = allPairings.filter(\n        (p) =>\n          p.peerMetadata?.url &&\n          p.peerMetadata?.url === session.peer.metadata.url &&\n          p.topic &&\n          p.topic !== pairing.topic,\n      );\n      if (duplicates.length === 0) return;\n      this.client.logger.info(`Cleaning up ${duplicates.length} duplicate pairing(s)`);\n      await Promise.all(\n        duplicates.map((p) => this.client.core.pairing.disconnect({ topic: p.topic })),\n      );\n      this.client.logger.info(`Duplicate pairings clean up finished`);\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  };\n\n  private deleteSession: EnginePrivate[\"deleteSession\"] = async (params) => {\n    const { topic, expirerHasDeleted = false, emitEvent = true, id = 0 } = params;\n    const { self } = this.client.session.get(topic);\n    // Await the unsubscribe first to avoid deleting the symKey too early below.\n    await this.client.core.relayer.unsubscribe(topic);\n    await this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\"));\n    this.addToRecentlyDeleted(topic, \"session\");\n    if (this.client.core.crypto.keychain.has(self.publicKey)) {\n      await this.client.core.crypto.deleteKeyPair(self.publicKey);\n    }\n    if (this.client.core.crypto.keychain.has(topic)) {\n      await this.client.core.crypto.deleteSymKey(topic);\n    }\n    if (!expirerHasDeleted) this.client.core.expirer.del(topic);\n    // remove any deeplinks from storage after the session is deleted\n    // to avoid navigating to incorrect deeplink later on\n    this.client.core.storage\n      .removeItem(WALLETCONNECT_DEEPLINK_CHOICE)\n      .catch((e) => this.client.logger.warn(e));\n    this.getPendingSessionRequests().forEach((r) => {\n      if (r.topic === topic) {\n        this.deletePendingSessionRequest(r.id, getSdkError(\"USER_DISCONNECTED\"));\n      }\n    });\n    // reset the queue state back to idle if a request for the deleted session is still in the queue\n    if (topic === this.sessionRequestQueue.queue[0]?.topic) {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;\n    }\n    if (emitEvent) this.client.events.emit(\"session_delete\", { id, topic });\n  };\n\n  private deleteProposal: EnginePrivate[\"deleteProposal\"] = async (id, expirerHasDeleted) => {\n    if (expirerHasDeleted) {\n      try {\n        const proposal = this.client.proposal.get(id);\n        const event = this.client.core.eventClient.getEvent({ topic: proposal.pairingTopic });\n        event?.setError(EVENT_CLIENT_SESSION_ERRORS.proposal_expired);\n      } catch (error) {}\n    }\n    await Promise.all([\n      this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\")),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n    this.addToRecentlyDeleted(id, \"proposal\");\n  };\n\n  private deletePendingSessionRequest: EnginePrivate[\"deletePendingSessionRequest\"] = async (\n    id,\n    reason,\n    expirerHasDeleted = false,\n  ) => {\n    await Promise.all([\n      this.client.pendingRequest.delete(id, reason),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n    this.addToRecentlyDeleted(id, \"request\");\n    this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((r) => r.id !== id);\n    if (expirerHasDeleted) {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;\n      this.client.events.emit(\"session_request_expire\", { id });\n    }\n  };\n\n  private deletePendingAuthRequest: EnginePrivate[\"deletePendingAuthRequest\"] = async (\n    id,\n    reason,\n    expirerHasDeleted = false,\n  ) => {\n    await Promise.all([\n      this.client.auth.requests.delete(id, reason),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n  };\n\n  private setExpiry: EnginePrivate[\"setExpiry\"] = async (topic, expiry) => {\n    if (!this.client.session.keys.includes(topic)) return;\n    this.client.core.expirer.set(topic, expiry);\n    await this.client.session.update(topic, { expiry });\n  };\n\n  private setProposal: EnginePrivate[\"setProposal\"] = async (id, proposal) => {\n    this.client.core.expirer.set(id, calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl));\n    await this.client.proposal.set(id, proposal);\n  };\n\n  private setAuthRequest: EnginePrivate[\"setAuthRequest\"] = async (id, params) => {\n    const { request, pairingTopic, transportType = TRANSPORT_TYPES.relay } = params;\n    this.client.core.expirer.set(id, request.expiryTimestamp);\n    await this.client.auth.requests.set(id, {\n      authPayload: request.authPayload,\n      requester: request.requester,\n      expiryTimestamp: request.expiryTimestamp,\n      id,\n      pairingTopic,\n      verifyContext: request.verifyContext,\n      transportType,\n    });\n  };\n\n  private setPendingSessionRequest: EnginePrivate[\"setPendingSessionRequest\"] = async (\n    pendingRequest: PendingRequestTypes.Struct,\n  ) => {\n    const { id, topic, params, verifyContext } = pendingRequest;\n    const expiry =\n      params.request.expiryTimestamp || calcExpiry(ENGINE_RPC_OPTS.wc_sessionRequest.req.ttl);\n    this.client.core.expirer.set(id, expiry);\n    await this.client.pendingRequest.set(id, {\n      id,\n      topic,\n      params,\n      verifyContext,\n    });\n  };\n\n  private sendRequest: EnginePrivate[\"sendRequest\"] = async (args) => {\n    const {\n      topic,\n      method,\n      params,\n      expiry,\n      relayRpcId,\n      clientRpcId,\n      throwOnFailedPublish,\n      appLink,\n      tvf,\n      publishOpts = {},\n    } = args;\n    const payload = formatJsonRpcRequest(method, params, clientRpcId);\n\n    let message: string;\n    const isLinkMode = !!appLink;\n\n    try {\n      const encoding = isLinkMode ? BASE64URL : BASE64;\n      message = await this.client.core.crypto.encode(topic, payload, { encoding });\n    } catch (error) {\n      await this.cleanup();\n      this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${topic} failed`);\n      throw error;\n    }\n\n    let attestation: string | undefined;\n    if (METHODS_TO_VERIFY.includes(method)) {\n      const decryptedId = hashMessage(JSON.stringify(payload));\n      const id = hashMessage(message);\n      attestation = await this.client.core.verify.register({ id, decryptedId });\n    }\n\n    const opts = {\n      ...ENGINE_RPC_OPTS[method].req,\n      ...publishOpts,\n    };\n\n    opts.attestation = attestation;\n    if (expiry) opts.ttl = expiry;\n    if (relayRpcId) opts.id = relayRpcId;\n    this.client.core.history.set(topic, payload);\n\n    if (isLinkMode) {\n      const redirectURL = getLinkModeURL(appLink, topic, message);\n      await (global as any).Linking.openURL(redirectURL, this.client.name);\n    } else {\n      opts.tvf = {\n        ...tvf,\n        correlationId: payload.id,\n      };\n\n      if (throwOnFailedPublish) {\n        opts.internal = {\n          ...opts.internal,\n          throwOnFailedPublish: true,\n        };\n        await this.client.core.relayer.publish(topic, message, opts);\n      } else {\n        this.client.core.relayer\n          .publish(topic, message, opts)\n          .catch((error) => this.client.logger.error(error));\n      }\n    }\n\n    return payload.id;\n  };\n\n  private sendProposeSession: EnginePrivate[\"sendProposeSession\"] = async (params) => {\n    const { proposal, publishOpts } = params;\n\n    const proposeSessionPayload = formatJsonRpcRequest(\"wc_sessionPropose\", proposal, proposal.id);\n\n    this.client.core.history.set(proposal.pairingTopic, proposeSessionPayload);\n\n    const proposeSessionMessage = await this.client.core.crypto.encode(\n      proposal.pairingTopic,\n      proposeSessionPayload,\n      {\n        encoding: BASE64,\n      },\n    );\n\n    const decryptedId = hashMessage(JSON.stringify(proposeSessionPayload));\n    const attestationId = hashMessage(proposeSessionMessage);\n    const attestation = await this.client.core.verify.register({ id: attestationId, decryptedId });\n\n    await this.client.core.relayer.publishCustom({\n      payload: {\n        pairingTopic: proposal.pairingTopic,\n        sessionProposal: proposeSessionMessage,\n      },\n      opts: {\n        ...publishOpts,\n        publishMethod: \"wc_proposeSession\",\n        attestation,\n      },\n    });\n  };\n\n  private sendApproveSession: EnginePrivate[\"sendApproveSession\"] = async (params) => {\n    const { sessionTopic, pairingProposalResponse, proposal, sessionSettleRequest, publishOpts } =\n      params;\n    const pairingPayload = formatJsonRpcResult(proposal.id, pairingProposalResponse);\n\n    const pairingResponseMessage = await this.client.core.crypto.encode(\n      proposal.pairingTopic,\n      pairingPayload,\n      {\n        encoding: BASE64,\n      },\n    );\n\n    const sessionSettlePayload = formatJsonRpcRequest(\n      \"wc_sessionSettle\",\n      sessionSettleRequest,\n      publishOpts?.id,\n    );\n\n    const sessionSettlementRequestMessage = await this.client.core.crypto.encode(\n      sessionTopic,\n      sessionSettlePayload,\n      {\n        encoding: BASE64,\n      },\n    );\n\n    this.client.core.history.set(sessionTopic, sessionSettlePayload);\n\n    await this.client.core.relayer.publishCustom({\n      payload: {\n        sessionTopic,\n        pairingTopic: proposal.pairingTopic,\n        sessionProposalResponse: pairingResponseMessage,\n        sessionSettlementRequest: sessionSettlementRequestMessage,\n      },\n      opts: {\n        ...publishOpts,\n        publishMethod: \"wc_approveSession\",\n      },\n    });\n  };\n\n  private sendResult: EnginePrivate[\"sendResult\"] = async (args) => {\n    const { id, topic, result, throwOnFailedPublish, encodeOpts, appLink } = args;\n    const payload = formatJsonRpcResult(id, result);\n    let message;\n    const isLinkMode = appLink && typeof (global as any)?.Linking !== \"undefined\";\n\n    try {\n      const encoding = isLinkMode ? BASE64URL : BASE64;\n      message = await this.client.core.crypto.encode(topic, payload, {\n        ...(encodeOpts || {}),\n        encoding,\n      });\n    } catch (error) {\n      // if encoding fails e.g. due to missing keychain, we want to cleanup all related data as its unusable\n      await this.cleanup();\n      this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${topic} failed`);\n      throw error;\n    }\n    let record;\n    let tvf;\n    try {\n      record = await this.client.core.history.get(topic, id);\n      const request = record.request;\n      try {\n        tvf = this.getTVFParams(id, request.params, result);\n      } catch (error) {\n        this.client.logger.warn(\n          `sendResult() -> getTVFParams() failed: ${(error as Error)?.message}`,\n        );\n      }\n    } catch (error) {\n      this.client.logger.error(`sendResult() -> history.get(${topic}, ${id}) failed`);\n      throw error;\n    }\n\n    if (isLinkMode) {\n      const redirectURL = getLinkModeURL(appLink, topic, message);\n      await (global as any).Linking.openURL(redirectURL, this.client.name);\n    } else {\n      const method = record.request.method as JsonRpcTypes.WcMethod;\n      const opts = ENGINE_RPC_OPTS[method].res;\n\n      opts.tvf = {\n        ...tvf,\n        correlationId: id,\n      };\n\n      if (throwOnFailedPublish) {\n        opts.internal = {\n          ...opts.internal,\n          throwOnFailedPublish: true,\n        };\n        await this.client.core.relayer.publish(topic, message, opts);\n      } else {\n        this.client.core.relayer\n          .publish(topic, message, opts)\n          .catch((error) => this.client.logger.error(error));\n      }\n    }\n\n    await this.client.core.history.resolve(payload);\n  };\n\n  private sendError: EnginePrivate[\"sendError\"] = async (params) => {\n    const { id, topic, error, encodeOpts, rpcOpts, appLink } = params;\n    const payload = formatJsonRpcError(id, error);\n    let message;\n    const isLinkMode = appLink && typeof (global as any)?.Linking !== \"undefined\";\n    try {\n      const encoding = isLinkMode ? BASE64URL : BASE64;\n      message = await this.client.core.crypto.encode(topic, payload, {\n        ...(encodeOpts || {}),\n        encoding,\n      });\n    } catch (error) {\n      await this.cleanup();\n      this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${topic} failed`);\n      throw error;\n    }\n    let record;\n    try {\n      record = await this.client.core.history.get(topic, id);\n    } catch (error) {\n      this.client.logger.error(`sendError() -> history.get(${topic}, ${id}) failed`);\n      throw error;\n    }\n\n    if (isLinkMode) {\n      const redirectURL = getLinkModeURL(appLink, topic, message);\n      await (global as any).Linking.openURL(redirectURL, this.client.name);\n    } else {\n      const method = record.request.method as JsonRpcTypes.WcMethod;\n      const opts = rpcOpts || ENGINE_RPC_OPTS[method].res;\n      // await is intentionally omitted to speed up performance\n      this.client.core.relayer.publish(topic, message, opts);\n    }\n\n    await this.client.core.history.resolve(payload);\n  };\n\n  private cleanup: EnginePrivate[\"cleanup\"] = async () => {\n    const sessionTopics: string[] = [];\n    const proposalIds: number[] = [];\n    this.client.session.getAll().forEach((session) => {\n      let toCleanup = false;\n      if (isExpired(session.expiry)) toCleanup = true;\n      if (!this.client.core.crypto.keychain.has(session.topic)) toCleanup = true;\n      if (toCleanup) sessionTopics.push(session.topic);\n    });\n    this.client.proposal.getAll().forEach((proposal) => {\n      if (isExpired(proposal.expiryTimestamp)) proposalIds.push(proposal.id);\n    });\n    await Promise.all([\n      ...sessionTopics.map((topic) => this.deleteSession({ topic })),\n      ...proposalIds.map((id) => this.deleteProposal(id)),\n    ]);\n  };\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n\n  private async confirmOnlineStateOrThrow() {\n    await this.client.core.relayer.confirmOnlineStateOrThrow();\n  }\n\n  // ---------- Relay Events Router ----------------------------------- //\n\n  private registerRelayerEvents() {\n    this.client.core.relayer.on(RELAYER_EVENTS.message, (event: RelayerTypes.MessageEvent) => {\n      this.onProviderMessageEvent(event);\n    });\n  }\n\n  private onProviderMessageEvent = async (event: RelayerTypes.MessageEvent) => {\n    // capture any messages that arrive before the client is initialized so we can process them after initialization is complete\n    if (!this.initialized || this.relayMessageCache.length > 0) {\n      this.relayMessageCache.push(event);\n    } else {\n      await this.onRelayMessage(event);\n    }\n  };\n\n  private async onRelayMessage(event: RelayerTypes.MessageEvent) {\n    const { topic, message, attestation, transportType } = event;\n\n    // Retrieve the public key (if defined) to decrypt possible `auth_request` response\n    const { publicKey } = this.client.auth.authKeys.keys.includes(AUTH_PUBLIC_KEY_NAME)\n      ? this.client.auth.authKeys.get(AUTH_PUBLIC_KEY_NAME)\n      : ({ responseTopic: undefined, publicKey: undefined } as any);\n\n    try {\n      const payload = await this.client.core.crypto.decode(topic, message, {\n        receiverPublicKey: publicKey,\n        encoding: transportType === TRANSPORT_TYPES.link_mode ? BASE64URL : BASE64,\n      });\n\n      if (isJsonRpcRequest(payload)) {\n        this.client.core.history.set(topic, payload);\n        await this.onRelayEventRequest({\n          topic,\n          payload,\n          attestation,\n          transportType,\n          encryptedId: hashMessage(message),\n        });\n      } else if (isJsonRpcResponse(payload)) {\n        await this.client.core.history.resolve(payload);\n        await this.onRelayEventResponse({ topic, payload, transportType });\n        this.client.core.history.delete(topic, payload.id);\n      } else {\n        await this.onRelayEventUnknownPayload({ topic, payload, transportType });\n      }\n      await this.client.core.relayer.messages.ack(topic, message);\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  }\n\n  private onRelayEventRequest: EnginePrivate[\"onRelayEventRequest\"] = async (event) => {\n    this.requestQueue.queue.push(event);\n    await this.processRequestsQueue();\n  };\n\n  private processRequestsQueue = async () => {\n    if (this.requestQueue.state === ENGINE_QUEUE_STATES.active) {\n      this.client.logger.info(`Request queue already active, skipping...`);\n      return;\n    }\n\n    this.client.logger.info(\n      `Request queue starting with ${this.requestQueue.queue.length} requests`,\n    );\n\n    while (this.requestQueue.queue.length > 0) {\n      this.requestQueue.state = ENGINE_QUEUE_STATES.active;\n      const request = this.requestQueue.queue.shift();\n      if (!request) continue;\n\n      try {\n        await this.processRequest(request);\n      } catch (error) {\n        this.client.logger.warn(error);\n      }\n    }\n    this.requestQueue.state = ENGINE_QUEUE_STATES.idle;\n  };\n\n  private processRequest: EnginePrivate[\"onRelayEventRequest\"] = async (event) => {\n    const { topic, payload, attestation, transportType, encryptedId } = event;\n\n    const reqMethod = payload.method as JsonRpcTypes.WcMethod;\n\n    if (this.shouldIgnorePairingRequest({ topic, requestMethod: reqMethod })) {\n      return;\n    }\n\n    switch (reqMethod) {\n      case \"wc_sessionPropose\":\n        return await this.onSessionProposeRequest({ topic, payload, attestation, encryptedId });\n      case \"wc_sessionSettle\":\n        return await this.onSessionSettleRequest(topic, payload);\n      case \"wc_sessionUpdate\":\n        return await this.onSessionUpdateRequest(topic, payload);\n      case \"wc_sessionExtend\":\n        return await this.onSessionExtendRequest(topic, payload);\n      case \"wc_sessionPing\":\n        return await this.onSessionPingRequest(topic, payload);\n      case \"wc_sessionDelete\":\n        return await this.onSessionDeleteRequest(topic, payload);\n      case \"wc_sessionRequest\":\n        return await this.onSessionRequest({\n          topic,\n          payload,\n          attestation,\n          encryptedId,\n          transportType,\n        });\n      case \"wc_sessionEvent\":\n        return await this.onSessionEventRequest(topic, payload);\n      case \"wc_sessionAuthenticate\":\n        return await this.onSessionAuthenticateRequest({\n          topic,\n          payload,\n          attestation,\n          encryptedId,\n          transportType,\n        });\n      default:\n        return this.client.logger.info(`Unsupported request method ${reqMethod}`);\n    }\n  };\n\n  private onRelayEventResponse: EnginePrivate[\"onRelayEventResponse\"] = async (event) => {\n    const { topic, payload, transportType } = event;\n    const record = await this.client.core.history.get(topic, payload.id);\n    const resMethod = record.request.method as JsonRpcTypes.WcMethod;\n\n    switch (resMethod) {\n      case \"wc_sessionPropose\":\n        return this.onSessionProposeResponse(topic, payload, transportType);\n      case \"wc_sessionSettle\":\n        return this.onSessionSettleResponse(topic, payload);\n      case \"wc_sessionUpdate\":\n        return this.onSessionUpdateResponse(topic, payload);\n      case \"wc_sessionExtend\":\n        return this.onSessionExtendResponse(topic, payload);\n      case \"wc_sessionPing\":\n        return this.onSessionPingResponse(topic, payload);\n      case \"wc_sessionRequest\":\n        return this.onSessionRequestResponse(topic, payload);\n      case \"wc_sessionAuthenticate\":\n        return this.onSessionAuthenticateResponse(topic, payload);\n      default:\n        return this.client.logger.info(`Unsupported response method ${resMethod}`);\n    }\n  };\n\n  private onRelayEventUnknownPayload: EnginePrivate[\"onRelayEventUnknownPayload\"] = (event) => {\n    const { topic } = event;\n    const { message } = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `Decoded payload on topic ${topic} is not identifiable as a JSON-RPC request or a response.`,\n    );\n    throw new Error(message);\n  };\n\n  private shouldIgnorePairingRequest: EnginePrivate[\"shouldIgnorePairingRequest\"] = (params) => {\n    const { topic, requestMethod } = params;\n    const expectedMethods = this.expectedPairingMethodMap.get(topic);\n    // check if the request method matches the expected method\n    if (!expectedMethods) return false;\n    if (expectedMethods.includes(requestMethod)) return false;\n\n    /**\n     * we want to make sure fallback session proposal is ignored only if there are subscribers\n     * for the `session_authenticate` event, otherwise this would result in no-op for the user\n     */\n    if (expectedMethods.includes(\"wc_sessionAuthenticate\")) {\n      if (this.client.events.listenerCount(\"session_authenticate\") > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // ---------- Relay Events Handlers --------------------------------- //\n\n  private onSessionProposeRequest: EnginePrivate[\"onSessionProposeRequest\"] = async (args) => {\n    const { topic, payload, attestation, encryptedId } = args;\n    const { params, id } = payload;\n    try {\n      const event = this.client.core.eventClient.getEvent({ topic });\n\n      if (this.client.events.listenerCount(\"session_proposal\") === 0) {\n        console.warn(\"No listener for session_proposal event\");\n        event?.setError(EVENT_CLIENT_PAIRING_ERRORS.proposal_listener_not_found);\n      }\n\n      this.isValidConnect({ ...payload.params });\n      const expiryTimestamp =\n        params.expiryTimestamp || calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl);\n      const proposal = {\n        id,\n        pairingTopic: topic,\n        expiryTimestamp,\n        attestation,\n        encryptedId,\n        ...params,\n      };\n      await this.setProposal(id, proposal);\n\n      const verifyContext = await this.getVerifyContext({\n        attestationId: attestation,\n        hash: hashMessage(JSON.stringify(payload)),\n        encryptedId,\n        metadata: proposal.proposer.metadata,\n      });\n\n      event?.addTrace(EVENT_CLIENT_PAIRING_TRACES.emit_session_proposal);\n\n      this.client.events.emit(\"session_proposal\", { id, params: proposal, verifyContext });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n        rpcOpts: ENGINE_RPC_OPTS.wc_sessionPropose.autoReject,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionProposeResponse: EnginePrivate[\"onSessionProposeResponse\"] = async (\n    topic,\n    payload,\n    transportType,\n  ) => {\n    const { id } = payload;\n\n    if (isJsonRpcResult(payload)) {\n      const { result } = payload;\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", result });\n      const proposal = this.client.proposal.get(id);\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", proposal });\n      const selfPublicKey = proposal.proposer.publicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        selfPublicKey,\n      });\n      const peerPublicKey = result.responderPublicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        peerPublicKey,\n      });\n      const sessionTopic = await this.client.core.crypto.generateSharedKey(\n        selfPublicKey,\n        peerPublicKey,\n      );\n      this.pendingSessions.set(id, {\n        sessionTopic,\n        pairingTopic: topic,\n        proposalId: id,\n        publicKey: selfPublicKey,\n      });\n\n      const subscriptionId = await this.client.core.relayer.subscribe(sessionTopic, {\n        transportType,\n      });\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        subscriptionId,\n      });\n      await this.client.core.pairing.activate({ topic });\n    } else if (isJsonRpcError(payload)) {\n      await this.deleteProposal(id);\n      const target = engineEvent(\"session_connect\", id);\n      const listeners = this.events.listenerCount(target);\n      if (listeners === 0) {\n        throw new Error(`emitting ${target} without any listeners, 954`);\n      }\n      this.events.emit(target, { error: payload.error });\n    }\n  };\n\n  private onSessionSettleRequest: EnginePrivate[\"onSessionSettleRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      this.isValidSessionSettleRequest(params);\n      const {\n        relay,\n        controller,\n        expiry,\n        namespaces,\n        sessionProperties,\n        scopedProperties,\n        sessionConfig,\n      } = payload.params;\n      const pendingSession = [...this.pendingSessions.values()].find(\n        (s) => s.sessionTopic === topic,\n      );\n\n      if (!pendingSession) {\n        return this.client.logger.error(`Pending session not found for topic ${topic}`);\n      }\n\n      const proposal = this.client.proposal.get(pendingSession.proposalId);\n\n      const session: SessionTypes.Struct = {\n        topic,\n        relay,\n        expiry,\n        namespaces,\n        acknowledged: true,\n        pairingTopic: pendingSession.pairingTopic,\n        requiredNamespaces: proposal.requiredNamespaces,\n        optionalNamespaces: proposal.optionalNamespaces,\n        controller: controller.publicKey,\n        self: {\n          publicKey: pendingSession.publicKey,\n          metadata: this.client.metadata,\n        },\n        peer: {\n          publicKey: controller.publicKey,\n          metadata: controller.metadata,\n        },\n        ...(sessionProperties && { sessionProperties }),\n        ...(scopedProperties && { scopedProperties }),\n        ...(sessionConfig && { sessionConfig }),\n        transportType: TRANSPORT_TYPES.relay,\n      };\n\n      await this.client.session.set(session.topic, session);\n      await this.setExpiry(session.topic, session.expiry);\n\n      await this.client.core.pairing.updateMetadata({\n        topic: pendingSession.pairingTopic,\n        metadata: session.peer.metadata,\n      });\n\n      this.client.events.emit(\"session_connect\", { session });\n      this.events.emit(engineEvent(\"session_connect\", pendingSession.proposalId), { session });\n\n      this.pendingSessions.delete(pendingSession.proposalId);\n      this.deleteProposal(pendingSession.proposalId, false);\n      this.cleanupDuplicatePairings(session);\n\n      await this.sendResult<\"wc_sessionSettle\">({\n        id: payload.id,\n        topic,\n        result: true,\n      });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionSettleResponse: EnginePrivate[\"onSessionSettleResponse\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      await this.client.session.update(topic, { acknowledged: true });\n      this.events.emit(engineEvent(\"session_approve\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      await this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\"));\n      this.events.emit(engineEvent(\"session_approve\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionUpdateRequest: EnginePrivate[\"onSessionUpdateRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { params, id } = payload;\n    try {\n      const memoryKey = `${topic}_session_update`;\n      // compare the current request id with the last processed session update\n      // we want to update only if the request is newer than the last processed one\n      const lastSessionUpdateId = MemoryStore.get<number>(memoryKey);\n\n      if (lastSessionUpdateId && this.isRequestOutOfSync(lastSessionUpdateId, id)) {\n        this.client.logger.warn(`Discarding out of sync request - ${id}`);\n        this.sendError({ id, topic, error: getSdkError(\"INVALID_UPDATE_REQUEST\") });\n        return;\n      }\n      this.isValidUpdate({ topic, ...params });\n      try {\n        MemoryStore.set(memoryKey, id);\n        await this.client.session.update(topic, { namespaces: params.namespaces });\n        await this.sendResult<\"wc_sessionUpdate\">({\n          id,\n          topic,\n          result: true,\n        });\n      } catch (e) {\n        MemoryStore.delete(memoryKey);\n        throw e;\n      }\n\n      this.client.events.emit(\"session_update\", { id, topic, params });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  // compares the timestamp of the last processed request with the current request\n  // client <-> client rpc ID is timestamp + 3 random digits\n  private isRequestOutOfSync = (lastId: number, currentId: number) => {\n    return currentId.toString().slice(0, -3) < lastId.toString().slice(0, -3);\n  };\n\n  private onSessionUpdateResponse: EnginePrivate[\"onSessionUpdateResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_update\", id);\n    const listeners = this.events.listenerCount(target);\n    if (listeners === 0) {\n      throw new Error(`emitting ${target} without any listeners`);\n    }\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionExtendRequest: EnginePrivate[\"onSessionExtendRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidExtend({ topic });\n      await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n      await this.sendResult<\"wc_sessionExtend\">({\n        id,\n        topic,\n        result: true,\n      });\n      this.client.events.emit(\"session_extend\", { id, topic });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionExtendResponse: EnginePrivate[\"onSessionExtendResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_extend\", id);\n    const listeners = this.events.listenerCount(target);\n    if (listeners === 0) {\n      throw new Error(`emitting ${target} without any listeners`);\n    }\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionPingRequest: EnginePrivate[\"onSessionPingRequest\"] = async (topic, payload) => {\n    const { id } = payload;\n    try {\n      this.isValidPing({ topic });\n      await this.sendResult<\"wc_sessionPing\">({\n        id,\n        topic,\n        result: true,\n        throwOnFailedPublish: true,\n      });\n      this.client.events.emit(\"session_ping\", { id, topic });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionPingResponse: EnginePrivate[\"onSessionPingResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_ping\", id);\n\n    // put at the end of the stack to avoid a race condition\n    // where session_ping listener is not yet initialized\n    setTimeout(() => {\n      const listeners = this.events.listenerCount(target);\n      if (listeners === 0) {\n        throw new Error(`emitting ${target} without any listeners 2176`);\n      }\n\n      if (isJsonRpcResult(payload)) {\n        this.events.emit(engineEvent(\"session_ping\", id), {});\n      } else if (isJsonRpcError(payload)) {\n        this.events.emit(engineEvent(\"session_ping\", id), { error: payload.error });\n      }\n    }, 500);\n  };\n\n  private onSessionDeleteRequest: EnginePrivate[\"onSessionDeleteRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidDisconnect({ topic, reason: payload.params });\n      await Promise.all([\n        new Promise((resolve) => {\n          // RPC request needs to happen before deletion as it utilizes session encryption\n          this.client.core.relayer.once(RELAYER_EVENTS.publish, async () => {\n            resolve(await this.deleteSession({ topic, id }));\n          });\n        }),\n        this.sendResult<\"wc_sessionDelete\">({\n          id,\n          topic,\n          result: true,\n        }),\n        this.cleanupPendingSentRequestsForTopic({ topic, error: getSdkError(\"USER_DISCONNECTED\") }),\n      ]).catch((err) => this.client.logger.error(err));\n    } catch (err: any) {\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequest: EnginePrivate[\"onSessionRequest\"] = async (args) => {\n    const { topic, payload, attestation, encryptedId, transportType } = args;\n    const { id, params } = payload;\n    try {\n      await this.isValidRequest({ topic, ...params });\n      const session = this.client.session.get(topic);\n      const verifyContext = await this.getVerifyContext({\n        attestationId: attestation,\n        hash: hashMessage(JSON.stringify(formatJsonRpcRequest(\"wc_sessionRequest\", params, id))),\n        encryptedId,\n        metadata: session.peer.metadata,\n        transportType,\n      });\n      const request = {\n        id,\n        topic,\n        params,\n        verifyContext,\n      };\n      await this.setPendingSessionRequest(request);\n\n      if (\n        transportType === TRANSPORT_TYPES.link_mode &&\n        session.peer.metadata.redirect?.universal\n      ) {\n        // save app as supported for link mode\n        this.client.core.addLinkModeSupportedApp(session.peer.metadata.redirect?.universal);\n      }\n\n      // without sequential processing. This bypasses deduplication provided by the queue,\n      // at-least-once delivery guarantee.\n      if (this.client.signConfig?.disableRequestQueue) {\n        this.emitSessionRequest(request);\n      } else {\n        this.addSessionRequestToSessionRequestQueue(request);\n        this.processSessionRequestQueue();\n      }\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequestResponse: EnginePrivate[\"onSessionRequestResponse\"] = (\n    _topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_request\", id);\n    const listeners = this.events.listenerCount(target);\n    if (listeners === 0) {\n      throw new Error(`emitting ${target} without any listeners`);\n    }\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { result: payload.result });\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionEventRequest: EnginePrivate[\"onSessionEventRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      // similar to session update, we want to discard out of sync requests\n      // additionally we have to check the event type as well e.g. chainChanged/accountsChanged\n      const memoryKey = `${topic}_session_event_${params.event.name}`;\n      // compare the current request id with the last processed session update\n      // we want to update only if the request is newer than the last processed one\n      const lastSessionUpdateId = MemoryStore.get<number>(memoryKey);\n      if (lastSessionUpdateId && this.isRequestOutOfSync(lastSessionUpdateId, id)) {\n        this.client.logger.info(`Discarding out of sync request - ${id}`);\n        return;\n      }\n\n      this.isValidEmit({ topic, ...params });\n      this.client.events.emit(\"session_event\", { id, topic, params });\n      MemoryStore.set(memoryKey, id);\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionAuthenticateResponse: EnginePrivate[\"onSessionAuthenticateResponse\"] = (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    this.client.logger.trace({\n      type: \"method\",\n      method: \"onSessionAuthenticateResponse\",\n      topic,\n      payload,\n    });\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { result: payload.result });\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionAuthenticateRequest: EnginePrivate[\"onSessionAuthenticateRequest\"] = async (\n    args,\n  ) => {\n    const { topic, payload, attestation, encryptedId, transportType } = args;\n    try {\n      const { requester, authPayload, expiryTimestamp } = payload.params;\n      const verifyContext = await this.getVerifyContext({\n        attestationId: attestation,\n        hash: hashMessage(JSON.stringify(payload)),\n        encryptedId,\n        metadata: requester.metadata,\n        transportType,\n      });\n      const pendingRequest = {\n        requester,\n        pairingTopic: topic,\n        id: payload.id,\n        authPayload,\n        verifyContext,\n        expiryTimestamp,\n      };\n      await this.setAuthRequest(payload.id, {\n        request: pendingRequest,\n        pairingTopic: topic,\n        transportType,\n      });\n\n      if (transportType === TRANSPORT_TYPES.link_mode && requester.metadata.redirect?.universal) {\n        // save app as supported for link mode\n        this.client.core.addLinkModeSupportedApp(requester.metadata.redirect.universal);\n      }\n\n      this.client.events.emit(\"session_authenticate\", {\n        topic,\n        params: payload.params,\n        id: payload.id,\n        verifyContext,\n      });\n    } catch (err: any) {\n      this.client.logger.error(err);\n\n      const receiverPublicKey = payload.params.requester.publicKey;\n      const senderPublicKey = await this.client.core.crypto.generateKeyPair();\n      const appLink = this.getAppLinkIfEnabled(payload.params.requester.metadata, transportType);\n\n      const encodeOpts = {\n        type: TYPE_1,\n        receiverPublicKey,\n        senderPublicKey,\n      };\n      await this.sendError({\n        id: payload.id,\n        topic,\n        error: err,\n        encodeOpts,\n        rpcOpts: ENGINE_RPC_OPTS.wc_sessionAuthenticate.autoReject,\n        appLink,\n      });\n    }\n  };\n\n  /**\n   * Adds a session request to the sequential processing queue.\n   *\n   * The queue provides built-in deduplication and sequential processing,\n   * which helps handle WalletConnect's at-least-once delivery guarantee.\n   */\n  private addSessionRequestToSessionRequestQueue = (request: PendingRequestTypes.Struct) => {\n    this.sessionRequestQueue.queue.push(request);\n  };\n\n  private cleanupAfterResponse = (params: EngineTypes.RespondParams) => {\n    this.deletePendingSessionRequest(params.response.id, { message: \"fulfilled\", code: 0 });\n    // intentionally delay the emitting of the next pending request a bit\n    setTimeout(() => {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;\n      this.processSessionRequestQueue();\n    }, toMiliseconds(this.requestQueueDelay));\n  };\n\n  // Allows for cleanup on any sent pending requests if the peer disconnects the session before responding\n  private cleanupPendingSentRequestsForTopic = ({\n    topic,\n    error,\n  }: {\n    topic: string;\n    error: ErrorResponse;\n  }) => {\n    const pendingRequests = this.client.core.history.pending;\n    if (pendingRequests.length > 0) {\n      const forSession = pendingRequests.filter(\n        (r) => r.topic === topic && r.request.method === \"wc_sessionRequest\",\n      );\n      forSession.forEach((r) => {\n        const id = r.request.id;\n        const target = engineEvent(\"session_request\", id);\n        const listeners = this.events.listenerCount(target);\n        if (listeners === 0) {\n          throw new Error(`emitting ${target} without any listeners`);\n        }\n        // notify .request() handler of the rejection\n        this.events.emit(engineEvent(\"session_request\", r.request.id), {\n          error,\n        });\n      });\n    }\n  };\n\n  private processSessionRequestQueue = () => {\n    if (this.sessionRequestQueue.state === ENGINE_QUEUE_STATES.active) {\n      this.client.logger.info(\"session request queue is already active.\");\n      return;\n    }\n    // Select the first/oldest request in the array to ensure last-in-first-out (LIFO)\n    const request = this.sessionRequestQueue.queue[0];\n    if (!request) {\n      this.client.logger.info(\"session request queue is empty.\");\n      return;\n    }\n\n    try {\n      this.emitSessionRequest(request);\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  };\n\n  /**\n   * Emits a session request event with built-in deduplication.\n   *\n   * This method implements deduplication using emittedSessionRequests set to handle\n   * WalletConnect's at-least-once delivery guarantee. However, when disableRequestQueue\n   * is enabled, additional deduplication may be needed at the consumer level.\n   */\n  private emitSessionRequest = (request: PendingRequestTypes.Struct) => {\n    if (this.emittedSessionRequests.has(request.id)) {\n      this.client.logger.warn(\n        {\n          id: request.id,\n        },\n        `Skipping emitting \\`session_request\\` event for duplicate request. id: ${request.id}`,\n      );\n      return;\n    }\n    this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.active;\n    this.emittedSessionRequests.add(request.id);\n    this.client.events.emit(\"session_request\", request);\n  };\n\n  // ---------- Expirer Events ---------------------------------------- //\n\n  private registerExpirerEvents() {\n    this.client.core.expirer.on(EXPIRER_EVENTS.expired, async (event: ExpirerTypes.Expiration) => {\n      const { topic, id } = parseExpirerTarget(event.target);\n      if (id && this.client.pendingRequest.keys.includes(id)) {\n        return await this.deletePendingSessionRequest(id, getInternalError(\"EXPIRED\"), true);\n      }\n      if (id && this.client.auth.requests.keys.includes(id)) {\n        return await this.deletePendingAuthRequest(id, getInternalError(\"EXPIRED\"), true);\n      }\n\n      if (topic) {\n        if (this.client.session.keys.includes(topic)) {\n          await this.deleteSession({ topic, expirerHasDeleted: true });\n          this.client.events.emit(\"session_expire\", { topic });\n        }\n      } else if (id) {\n        await this.deleteProposal(id, true);\n        this.client.events.emit(\"proposal_expire\", { id });\n      }\n    });\n  }\n\n  // ---------- Pairing Events ---------------------------------------- //\n  private registerPairingEvents() {\n    this.client.core.pairing.events.on(PAIRING_EVENTS.create, (pairing: PairingTypes.Struct) =>\n      this.onPairingCreated(pairing),\n    );\n    this.client.core.pairing.events.on(PAIRING_EVENTS.delete, (pairing: PairingTypes.Struct) => {\n      this.addToRecentlyDeleted(pairing.topic, \"pairing\");\n    });\n  }\n\n  /**\n   * when a pairing is created, we check if there is a pending proposal for it.\n   * if there is, we send it to onSessionProposeRequest to be processed as if it was received from the relay.\n   * It allows QR/URI to be scanned multiple times without having to create new pairing.\n   */\n  private onPairingCreated = (pairing: PairingTypes.Struct) => {\n    if (pairing.methods) {\n      this.expectedPairingMethodMap.set(pairing.topic, pairing.methods);\n    }\n    if (pairing.active) return;\n    const proposals = this.client.proposal.getAll();\n    const proposal = proposals.find((p) => p.pairingTopic === pairing.topic);\n    if (!proposal) return;\n    this.onSessionProposeRequest({\n      topic: pairing.topic,\n      payload: formatJsonRpcRequest(\n        \"wc_sessionPropose\",\n        {\n          ...proposal,\n          requiredNamespaces: proposal.requiredNamespaces,\n          optionalNamespaces: proposal.optionalNamespaces,\n          relays: proposal.relays,\n          proposer: proposal.proposer,\n          sessionProperties: proposal.sessionProperties,\n          scopedProperties: proposal.scopedProperties,\n        },\n        proposal.id,\n      ),\n      attestation: proposal.attestation,\n      encryptedId: proposal.encryptedId,\n    });\n  };\n\n  // ---------- Validation Helpers ------------------------------------ //\n  private isValidPairingTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.core.pairing.pairings.get(topic).expiry)) {\n      const { message } = getInternalError(\"EXPIRED\", `pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    // Store will throw custom message if topic was recently deleted\n    this.checkRecentlyDeleted(topic);\n    if (!this.client.session.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.session.get(topic).expiry)) {\n      await this.deleteSession({ topic });\n      const { message } = getInternalError(\"EXPIRED\", `session topic: ${topic}`);\n      throw new Error(message);\n    }\n\n    if (!this.client.core.crypto.keychain.has(topic)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session topic does not exist in keychain: ${topic}`,\n      );\n      await this.deleteSession({ topic });\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionOrPairingTopic(topic: string) {\n    this.checkRecentlyDeleted(topic);\n    if (this.client.session.keys.includes(topic)) {\n      await this.isValidSessionTopic(topic);\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      this.isValidPairingTopic(topic);\n    } else if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session or pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    } else {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session or pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n  }\n\n  private async isValidProposalId(id: any) {\n    if (!isValidId(id)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `proposal id should be a number: ${id}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.proposal.keys.includes(id)) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${id}`);\n      throw new Error(message);\n    }\n    if (isExpired(this.client.proposal.get(id).expiryTimestamp)) {\n      await this.deleteProposal(id);\n      const { message } = getInternalError(\"EXPIRED\", `proposal id: ${id}`);\n      throw new Error(message);\n    }\n  }\n\n  // ---------- Validation  ------------------------------------------- //\n\n  private isValidConnect: EnginePrivate[\"isValidConnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `connect() params: ${JSON.stringify(params)}`,\n      );\n      throw new Error(message);\n    }\n    const {\n      pairingTopic,\n      requiredNamespaces,\n      optionalNamespaces,\n      sessionProperties,\n      scopedProperties,\n      relays,\n    } = params;\n    if (!isUndefined(pairingTopic)) await this.isValidPairingTopic(pairingTopic);\n\n    if (!isValidRelays(relays, true)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `connect() relays: ${relays}`);\n      throw new Error(message);\n    }\n\n    // validate required namespaces only if they are defined\n    if (\n      requiredNamespaces &&\n      !isUndefined(requiredNamespaces) &&\n      isValidObject(requiredNamespaces) !== 0\n    ) {\n      const warning =\n        \"requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces\";\n      // if logger level is one of the following, the logger.warn will not be shown, so we need to use console.warn\n      if ([\"fatal\", \"error\", \"silent\"].includes(this.client.logger.level)) {\n        console.warn(warning);\n      } else {\n        this.client.logger.warn(warning);\n      }\n      this.validateNamespaces(requiredNamespaces, \"requiredNamespaces\");\n    }\n\n    // validate optional namespaces only if they are defined\n    if (\n      optionalNamespaces &&\n      !isUndefined(optionalNamespaces) &&\n      isValidObject(optionalNamespaces) !== 0\n    ) {\n      this.validateNamespaces(optionalNamespaces, \"optionalNamespaces\");\n    }\n\n    // validate session properties only if they are defined\n    if (sessionProperties && !isUndefined(sessionProperties)) {\n      this.validateSessionProps(sessionProperties, \"sessionProperties\");\n    }\n\n    if (scopedProperties && !isUndefined(scopedProperties)) {\n      this.validateSessionProps(scopedProperties, \"scopedProperties\");\n\n      const requestedNamespaces = Object.keys(requiredNamespaces || {}).concat(\n        Object.keys(optionalNamespaces || {}),\n      );\n\n      const scopedNamespaces = Object.keys(scopedProperties);\n      // .split(\":\")[0] to account for inline <namespace>:<chainId>\n      const valid = scopedNamespaces.every((ns) => requestedNamespaces.includes(ns.split(\":\")[0]));\n      if (!valid) {\n        throw new Error(\n          `Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(\n            scopedProperties,\n          )}, required/optional namespaces: ${JSON.stringify(requestedNamespaces)}`,\n        );\n      }\n    }\n  };\n\n  private validateNamespaces = (\n    namespaces: ProposalTypes.RequiredNamespaces | ProposalTypes.OptionalNamespaces,\n    type: string,\n  ) => {\n    const validRequiredNamespacesError = isValidRequiredNamespaces(namespaces, \"connect()\", type);\n    if (validRequiredNamespacesError) throw new Error(validRequiredNamespacesError.message);\n  };\n\n  private isValidApprove: EnginePrivate[\"isValidApprove\"] = async (params) => {\n    if (!isValidParams(params))\n      throw new Error(\n        getInternalError(\"MISSING_OR_INVALID\", `approve() params: ${params}`).message,\n      );\n    const { id, namespaces, relayProtocol, sessionProperties, scopedProperties } = params;\n\n    this.checkRecentlyDeleted(id);\n    await this.isValidProposalId(id);\n    const proposal = this.client.proposal.get(id);\n    const validNamespacesError = isValidNamespaces(namespaces, \"approve()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      proposal.requiredNamespaces,\n      namespaces,\n      \"approve()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    if (!isValidString(relayProtocol, true)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `approve() relayProtocol: ${relayProtocol}`,\n      );\n      throw new Error(message);\n    }\n\n    if (sessionProperties && !isUndefined(sessionProperties)) {\n      this.validateSessionProps(sessionProperties, \"sessionProperties\");\n    }\n\n    if (scopedProperties && !isUndefined(scopedProperties)) {\n      this.validateSessionProps(scopedProperties, \"scopedProperties\");\n\n      const approvedNamespaces = new Set(Object.keys(namespaces));\n      const scopedNamespaces = Object.keys(scopedProperties);\n\n      // the approved scoped namespaces must be a subset of the approved namespaces\n      // .split(\":\")[0] to account for inline <namespace>:<chainId>\n      const valid = scopedNamespaces.every((ns) => approvedNamespaces.has(ns.split(\":\")[0]));\n      if (!valid) {\n        throw new Error(\n          `Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(\n            scopedProperties,\n          )}, approved namespaces: ${Array.from(approvedNamespaces).join(\", \")}`,\n        );\n      }\n    }\n  };\n\n  private isValidReject: EnginePrivate[\"isValidReject\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `reject() params: ${params}`);\n      throw new Error(message);\n    }\n    const { id, reason } = params;\n    this.checkRecentlyDeleted(id);\n    await this.isValidProposalId(id);\n    if (!isValidErrorReason(reason)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `reject() reason: ${JSON.stringify(reason)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidSessionSettleRequest: EnginePrivate[\"isValidSessionSettleRequest\"] = (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() params: ${params}`,\n      );\n      throw new Error(message);\n    }\n    const { relay, controller, namespaces, expiry } = params;\n    if (!isValidRelay(relay)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() relay protocol should be a string`,\n      );\n      throw new Error(message);\n    }\n    const validControllerError = isValidController(controller, \"onSessionSettleRequest()\");\n    if (validControllerError) throw new Error(validControllerError.message);\n    const validNamespacesError = isValidNamespaces(namespaces, \"onSessionSettleRequest()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    if (isExpired(expiry)) {\n      const { message } = getInternalError(\"EXPIRED\", `onSessionSettleRequest()`);\n      throw new Error(message);\n    }\n  };\n\n  private isValidUpdate: EnginePrivate[\"isValidUpdate\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `update() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, namespaces } = params;\n\n    this.checkRecentlyDeleted(topic);\n    await this.isValidSessionTopic(topic);\n    const session = this.client.session.get(topic);\n    const validNamespacesError = isValidNamespaces(namespaces, \"update()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      session.requiredNamespaces,\n      namespaces,\n      \"update()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    // TODO(ilja) - check if wallet\n  };\n\n  private isValidExtend: EnginePrivate[\"isValidExtend\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `extend() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n\n    this.checkRecentlyDeleted(topic);\n    await this.isValidSessionTopic(topic);\n  };\n\n  private isValidRequest: EnginePrivate[\"isValidRequest\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, request, chainId, expiry } = params;\n    this.checkRecentlyDeleted(topic);\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidRequest(request)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() ${JSON.stringify(request)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesRequest(namespaces, chainId, request.method)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() method: ${request.method}`,\n      );\n      throw new Error(message);\n    }\n    if (expiry && !isValidRequestExpiry(expiry, SESSION_REQUEST_EXPIRY_BOUNDARIES)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() expiry: ${expiry}. Expiry must be a number (in seconds) between ${SESSION_REQUEST_EXPIRY_BOUNDARIES.min} and ${SESSION_REQUEST_EXPIRY_BOUNDARIES.max}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidRespond: EnginePrivate[\"isValidRespond\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `respond() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, response } = params;\n\n    try {\n      // if the session is already disconnected, we can't respond to the request so we need to delete it\n      await this.isValidSessionTopic(topic);\n    } catch (error) {\n      if (params?.response?.id) this.cleanupAfterResponse(params);\n      throw error;\n    }\n    if (!isValidResponse(response)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `respond() response: ${JSON.stringify(response)}`,\n      );\n      throw new Error(message);\n    }\n\n    const request = this.client.pendingRequest.get(response.id);\n\n    if (request.topic !== topic) {\n      const { message } = getInternalError(\n        \"MISMATCHED_TOPIC\",\n        `Request response topic mismatch. reqId: ${response.id}, expected topic: ${request.topic}, received topic: ${topic}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidPing: EnginePrivate[\"isValidPing\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `ping() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n\n  private isValidEmit: EnginePrivate[\"isValidEmit\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, event, chainId } = params;\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidEvent(event)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesEvent(namespaces, chainId, event.name)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidDisconnect: EnginePrivate[\"isValidDisconnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `disconnect() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n\n  private isValidAuthenticate = (params: AuthTypes.SessionAuthenticateParams) => {\n    const { chains, uri, domain, nonce } = params;\n\n    // ----- validate params ----- //\n    if (!Array.isArray(chains) || chains.length === 0) {\n      throw new Error(\"chains is required and must be a non-empty array\");\n    }\n    if (!isValidString(uri, false)) {\n      throw new Error(\"uri is required parameter\");\n    }\n    if (!isValidString(domain, false)) {\n      throw new Error(\"domain is required parameter\");\n    }\n    if (!isValidString(nonce, false)) {\n      throw new Error(\"nonce is required parameter\");\n    }\n\n    // ----- reject multi namespaces ----- //\n    const uniqueNamespaces = [...new Set(chains.map((chain) => parseChainId(chain).namespace))];\n    if (uniqueNamespaces.length > 1) {\n      throw new Error(\n        \"Multi-namespace requests are not supported. Please request single namespace only.\",\n      );\n    }\n\n    const { namespace } = parseChainId(chains[0]);\n    if (namespace !== \"eip155\") {\n      throw new Error(\n        \"Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.\",\n      );\n    }\n  };\n\n  private getVerifyContext = async (params: {\n    attestationId?: string;\n    hash?: string;\n    encryptedId?: string;\n    metadata: CoreTypes.Metadata;\n    transportType?: RelayerTypes.TransportType;\n  }) => {\n    const { attestationId, hash, encryptedId, metadata, transportType } = params;\n    const context: Verify.Context = {\n      verified: {\n        verifyUrl: metadata.verifyUrl || VERIFY_SERVER,\n        validation: \"UNKNOWN\",\n        origin: metadata.url || \"\",\n      },\n    };\n\n    try {\n      if (transportType === TRANSPORT_TYPES.link_mode) {\n        const applink = this.getAppLinkIfEnabled(metadata, transportType);\n        context.verified.validation =\n          applink && new URL(applink).origin === new URL(metadata.url).origin ? \"VALID\" : \"INVALID\";\n        return context;\n      }\n      const result = await this.client.core.verify.resolve({\n        attestationId,\n        hash,\n        encryptedId,\n        verifyUrl: metadata.verifyUrl,\n      });\n      if (result) {\n        context.verified.origin = result.origin;\n        context.verified.isScam = result.isScam;\n        context.verified.validation =\n          result.origin === new URL(metadata.url).origin ? \"VALID\" : \"INVALID\";\n      }\n    } catch (e) {\n      this.client.logger.warn(e);\n    }\n\n    this.client.logger.debug(`Verify context: ${JSON.stringify(context)}`);\n    return context;\n  };\n\n  private validateSessionProps = (properties: SessionTypes.ScopedProperties, type: string) => {\n    Object.values(properties).forEach((property, index) => {\n      if (property === null || property === undefined) {\n        const { message } = getInternalError(\n          \"MISSING_OR_INVALID\",\n          `${type} must contain an existing value for each key. Received: ${property} for key ${\n            Object.keys(properties)[index]\n          }`,\n        );\n        throw new Error(message);\n      }\n    });\n  };\n\n  private getPendingAuthRequest = (id: number) => {\n    const request = this.client.auth.requests.get(id);\n    return typeof request === \"object\" ? request : undefined;\n  };\n\n  private addToRecentlyDeleted = (\n    id: string | number,\n    type: \"pairing\" | \"session\" | \"proposal\" | \"request\",\n  ) => {\n    this.recentlyDeletedMap.set(id, type);\n    // remove first half of the map if it exceeds the limit\n    if (this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {\n      let i = 0;\n      const numItemsToDelete = this.recentlyDeletedLimit / 2;\n      for (const k of this.recentlyDeletedMap.keys()) {\n        if (i++ >= numItemsToDelete) {\n          break;\n        }\n        this.recentlyDeletedMap.delete(k);\n      }\n    }\n  };\n\n  private checkRecentlyDeleted = (id: string | number) => {\n    const deletedRecord = this.recentlyDeletedMap.get(id);\n    if (deletedRecord) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `Record was recently deleted - ${deletedRecord}: ${id}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isLinkModeEnabled = (\n    peerMetadata?: CoreTypes.Metadata,\n    transportType?: RelayerTypes.TransportType,\n  ): boolean => {\n    if (!peerMetadata || transportType !== TRANSPORT_TYPES.link_mode) return false;\n\n    return (\n      this.client.metadata?.redirect?.linkMode === true &&\n      this.client.metadata?.redirect?.universal !== undefined &&\n      this.client.metadata?.redirect?.universal !== \"\" &&\n      peerMetadata?.redirect?.universal !== undefined &&\n      peerMetadata?.redirect?.universal !== \"\" &&\n      peerMetadata?.redirect?.linkMode === true &&\n      this.client.core.linkModeSupportedApps.includes(peerMetadata.redirect.universal) &&\n      typeof (global as any)?.Linking !== \"undefined\"\n    );\n  };\n\n  private getAppLinkIfEnabled = (\n    peerMetadata?: CoreTypes.Metadata,\n    transportType?: RelayerTypes.TransportType,\n  ): string | undefined => {\n    return this.isLinkModeEnabled(peerMetadata, transportType)\n      ? peerMetadata?.redirect?.universal\n      : undefined;\n  };\n\n  private handleLinkModeMessage = ({ url }: { url: string }) => {\n    if (!url || !url.includes(\"wc_ev\") || !url.includes(\"topic\")) return;\n\n    const topic = getSearchParamFromURL(url, \"topic\") || \"\";\n    const message = decodeURIComponent(getSearchParamFromURL(url, \"wc_ev\") || \"\");\n\n    const sessionExists = this.client.session.keys.includes(topic);\n\n    if (sessionExists) {\n      this.client.session.update(topic, { transportType: TRANSPORT_TYPES.link_mode });\n    }\n\n    this.client.core.dispatchEnvelope({ topic, message, sessionExists });\n  };\n\n  private registerLinkModeListeners = async () => {\n    if (isTestRun() || (isReactNative() && this.client.metadata.redirect?.linkMode)) {\n      const linking = (global as any)?.Linking;\n      // global.Linking is set by react-native-compat\n      if (typeof linking !== \"undefined\") {\n        // set URL listener\n        linking.addEventListener(\"url\", this.handleLinkModeMessage, this.client.name);\n\n        // check for initial URL -> cold boots\n        const initialUrl = await linking.getInitialURL();\n        if (initialUrl) {\n          // wait to process the message to allow event listeners to be registered by the implementing app\n          setTimeout(() => {\n            this.handleLinkModeMessage({ url: initialUrl });\n          }, 50);\n        }\n      }\n    }\n  };\n\n  private getTVFParams = (\n    id: number,\n    params: JsonRpcTypes.RequestParams[\"wc_sessionRequest\"],\n    result?: any,\n  ) => {\n    // this check will filter all Sign protocol methods since they don't have a method property\n    if (!params.request?.method) {\n      return {};\n    }\n\n    const tvf: RelayerTypes.ITVF = {\n      correlationId: id,\n      rpcMethods: [params.request.method],\n      chainId: params.chainId,\n    };\n    try {\n      const txHashes = this.extractTxHashesFromResult(params.request, result);\n      tvf.txHashes = txHashes;\n      tvf.contractAddresses = this.isValidContractData(params.request.params)\n        ? [params.request.params?.[0]?.to]\n        : [];\n    } catch (e) {\n      this.client.logger.warn(e, \"Error getting TVF params\");\n    }\n    return tvf;\n  };\n\n  private isValidContractData = (params: any) => {\n    if (!params) return false;\n    try {\n      const data = params?.data || params?.[0]?.data;\n\n      if (!data.startsWith(\"0x\")) return false;\n\n      const hexPart = data.slice(2);\n      if (!/^[0-9a-fA-F]*$/.test(hexPart)) return false;\n\n      return hexPart.length % 2 === 0;\n    } catch (e) {}\n    return false;\n  };\n\n  private extractTxHashesFromResult = (\n    request: JsonRpcTypes.RequestParams[\"wc_sessionRequest\"][\"request\"],\n    result: any,\n  ): string[] => {\n    try {\n      if (!result) return [];\n\n      const method = request.method;\n      const methodConfig = TVF_METHODS[method as keyof typeof TVF_METHODS];\n\n      if (method === \"sui_signTransaction\") {\n        return [getSuiDigest(result.transactionBytes)];\n      }\n\n      if (method === \"near_signTransaction\") {\n        return [getNearTransactionIdFromSignedTransaction(result)];\n      }\n\n      if (method === \"near_signTransactions\") {\n        return result.map((tx: any) => getNearTransactionIdFromSignedTransaction(tx));\n      }\n\n      if (method === \"xrpl_signTransactionFor\" || method === \"xrpl_signTransaction\") {\n        return [result.tx_json?.hash];\n      }\n\n      if (method === \"polkadot_signTransaction\") {\n        return [\n          buildSignedExtrinsicHash({\n            transaction: request.params.transactionPayload,\n            signature: result.signature,\n          }),\n        ];\n      }\n\n      if (method === \"algo_signTxn\") {\n        return isValidArray(result)\n          ? result.map((tx: any) => getAlgorandTransactionId(tx))\n          : [getAlgorandTransactionId(result)];\n      }\n\n      if (method === \"cosmos_signDirect\") {\n        return [getSignDirectHash(result)];\n      }\n\n      if (method === \"wallet_sendCalls\") {\n        return getWalletSendCallsHashes(result);\n      }\n\n      // result = 0x...\n      if (typeof result === \"string\") {\n        return [result];\n      }\n\n      // result = { key: [0x...] } or { key: 0x... }\n      const hashes: string[] = result[methodConfig.key];\n\n      // result = { key: [0x...] }\n      if (isValidArray(hashes)) {\n        if (method === \"solana_signAllTransactions\") {\n          return hashes.map((hash) => extractSolanaTransactionId(hash));\n        }\n\n        return hashes;\n\n        // result = { key: 0x... }\n      } else if (typeof hashes === \"string\") {\n        return [hashes];\n      }\n    } catch (e) {\n      this.client.logger.warn(e, \"Error extracting tx hashes from result\");\n    }\n    return [];\n  };\n}\n","/**\n * NIST secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Seems to be rigid (not backdoored)\n * [as per discussion](https://bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975).\n *\n * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n * [See explanation](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha2';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { createCurve, type CurveFnWithCreate } from './_shortw_utils.ts';\nimport { createHasher, type Hasher, type HTFMethod, isogenyMap } from './abstract/hash-to-curve.ts';\nimport { Field, mod, pow2 } from './abstract/modular.ts';\nimport type { Hex, PrivKey } from './abstract/utils.ts';\nimport {\n  aInRange,\n  bytesToNumberBE,\n  concatBytes,\n  ensureBytes,\n  inRange,\n  numberToBytesBE,\n} from './abstract/utils.ts';\nimport { mapToCurveSimpleSWU, type ProjPointType as PointType } from './abstract/weierstrass.ts';\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a: bigint, b: bigint) => (a + b / _2n) / b;\n\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y: bigint): bigint {\n  const P = secp256k1P;\n  // prettier-ignore\n  const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n  // prettier-ignore\n  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n  const b2 = (y * y * y) % P; // x^3, 11\n  const b3 = (b2 * b2 * y) % P; // x^7\n  const b6 = (pow2(b3, _3n, P) * b3) % P;\n  const b9 = (pow2(b6, _3n, P) * b3) % P;\n  const b11 = (pow2(b9, _2n, P) * b2) % P;\n  const b22 = (pow2(b11, _11n, P) * b11) % P;\n  const b44 = (pow2(b22, _22n, P) * b22) % P;\n  const b88 = (pow2(b44, _44n, P) * b44) % P;\n  const b176 = (pow2(b88, _88n, P) * b88) % P;\n  const b220 = (pow2(b176, _44n, P) * b44) % P;\n  const b223 = (pow2(b220, _3n, P) * b3) % P;\n  const t1 = (pow2(b223, _23n, P) * b22) % P;\n  const t2 = (pow2(t1, _6n, P) * b2) % P;\n  const root = pow2(t2, _2n, P);\n  if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error('Cannot find square root');\n  return root;\n}\n\nconst Fpk1 = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\n\n/**\n * secp256k1 curve, ECDSA and ECDH methods.\n *\n * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1';\n * const priv = secp256k1.utils.randomPrivateKey();\n * const pub = secp256k1.getPublicKey(priv);\n * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\n * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\n * const isValid = secp256k1.verify(sig, msg, pub) === true;\n * ```\n */\nexport const secp256k1: CurveFnWithCreate = createCurve(\n  {\n    a: _0n,\n    b: BigInt(7),\n    Fp: Fpk1,\n    n: secp256k1N,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    endo: {\n      // Endomorphism, see above\n      beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n      splitScalar: (k: bigint) => {\n        const n = secp256k1N;\n        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n        const b2 = a1;\n        const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg) k1 = n - k1;\n        if (k2neg) k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n          throw new Error('splitScalar: Endomorphism failed, k=' + k);\n        }\n        return { k1neg, k1, k2neg, k2 };\n      },\n    },\n  },\n  sha256\n);\n\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES: { [tag: string]: Uint8Array } = {};\nfunction taggedHash(tag: string, ...messages: Uint8Array[]): Uint8Array {\n  let tagP = TAGGED_HASH_PREFIXES[tag];\n  if (tagP === undefined) {\n    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n    tagP = concatBytes(tagH, tagH);\n    TAGGED_HASH_PREFIXES[tag] = tagP;\n  }\n  return sha256(concatBytes(tagP, ...messages));\n}\n\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point: PointType<bigint>) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n: bigint) => numberToBytesBE(n, 32);\nconst modP = (x: bigint) => mod(x, secp256k1P);\nconst modN = (x: bigint) => mod(x, secp256k1N);\nconst Point = /* @__PURE__ */ (() => secp256k1.ProjectivePoint)();\nconst GmulAdd = (Q: PointType<bigint>, a: bigint, b: bigint) =>\n  Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv: PrivKey) {\n  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n  let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside\n  const scalar = p.hasEvenY() ? d_ : modN(-d_);\n  return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x: bigint): PointType<bigint> {\n  aInRange('x', x, _1n, secp256k1P); // Fail if x  p.\n  const xx = modP(x * x);\n  const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n  let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n  if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n  const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n  p.assertValidity();\n  return p;\n}\nconst num = bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args: Uint8Array[]): bigint {\n  return modN(num(taggedHash('BIP0340/challenge', ...args)));\n}\n\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey: Hex): Uint8Array {\n  return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(\n  message: Hex,\n  privateKey: PrivKey,\n  auxRand: Hex = randomBytes(32)\n): Uint8Array {\n  const m = ensureBytes('message', message);\n  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n  const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n  const t = numTo32b(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n  const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n  const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n  if (k_ === _0n) throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.\n  const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n  const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n  sig.set(rx, 0);\n  sig.set(numTo32b(modN(k + e * d)), 32);\n  // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n  if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');\n  return sig;\n}\n\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature: Hex, message: Hex, publicKey: Hex): boolean {\n  const sig = ensureBytes('signature', signature, 64);\n  const m = ensureBytes('message', message);\n  const pub = ensureBytes('publicKey', publicKey, 32);\n  try {\n    const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n    const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n    if (!inRange(r, _1n, secp256k1P)) return false;\n    const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n    if (!inRange(s, _1n, secp256k1N)) return false;\n    const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n    const R = GmulAdd(P, s, modN(-e)); // R = sG - eP\n    if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n    return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n  } catch (error) {\n    return false;\n  }\n}\n\nexport type SecpSchnorr = {\n  getPublicKey: typeof schnorrGetPublicKey;\n  sign: typeof schnorrSign;\n  verify: typeof schnorrVerify;\n  utils: {\n    randomPrivateKey: () => Uint8Array;\n    lift_x: typeof lift_x;\n    pointToBytes: (point: PointType<bigint>) => Uint8Array;\n    numberToBytesBE: typeof numberToBytesBE;\n    bytesToNumberBE: typeof bytesToNumberBE;\n    taggedHash: typeof taggedHash;\n    mod: typeof mod;\n  };\n};\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1';\n * const priv = schnorr.utils.randomPrivateKey();\n * const pub = schnorr.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, priv);\n * const isValid = schnorr.verify(sig, msg, pub);\n * ```\n */\nexport const schnorr: SecpSchnorr = /* @__PURE__ */ (() => ({\n  getPublicKey: schnorrGetPublicKey,\n  sign: schnorrSign,\n  verify: schnorrVerify,\n  utils: {\n    randomPrivateKey: secp256k1.utils.randomPrivateKey,\n    lift_x,\n    pointToBytes,\n    numberToBytesBE,\n    bytesToNumberBE,\n    taggedHash,\n    mod,\n  },\n}))();\n\nconst isoMap = /* @__PURE__ */ (() =>\n  isogenyMap(\n    Fpk1,\n    [\n      // xNum\n      [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n      ],\n      // xDen\n      [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n      // yNum\n      [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n      ],\n      // yDen\n      [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n    ].map((i) => i.map((j) => BigInt(j))) as [bigint[], bigint[], bigint[], bigint[]]\n  ))();\nconst mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n  }))();\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */\nexport const secp256k1_hasher: Hasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(\n    secp256k1.ProjectivePoint,\n    (scalars: bigint[]) => {\n      const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n      return isoMap(x, y);\n    },\n    {\n      DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n      encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n      p: Fpk1.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha256,\n    } as const\n  ))();\n\nexport const hashToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() =>\n  secp256k1_hasher.hashToCurve)();\n\nexport const encodeToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() =>\n  secp256k1_hasher.encodeToCurve)();\n","import { Logger } from \"@walletconnect/logger\";\nimport { IKeyValueStorage } from \"@walletconnect/keyvaluestorage\";\nimport { ICore } from \"./core.js\";\n\nexport declare namespace Verify {\n  export interface Context {\n    verified: {\n      origin: string;\n      validation: \"UNKNOWN\" | \"VALID\" | \"INVALID\";\n      verifyUrl: string;\n      isScam?: boolean;\n    };\n  }\n}\n\nexport abstract class IVerify {\n  public abstract readonly context: string;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public store: IKeyValueStorage,\n  ) {}\n\n  public abstract register(params: {\n    id: string;\n    decryptedId: string;\n  }): Promise<string | undefined>;\n\n  public abstract resolve(params: {\n    attestationId?: string;\n    hash?: string;\n    encryptedId?: string;\n    verifyUrl?: string;\n  }): Promise<{ origin: string; isScam?: boolean }>;\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { pad } from '../../utils/data/pad.js'\nimport { type ToBytesErrorType, toBytes } from '../../utils/encoding/toBytes.js'\nimport { type Sha256ErrorType, sha256 } from '../../utils/hash/sha256.js'\nimport { maxBytecodeSize } from '../constants/number.js'\nimport {\n  BytecodeLengthExceedsMaxSizeError,\n  type BytecodeLengthExceedsMaxSizeErrorType,\n  BytecodeLengthInWordsMustBeOddError,\n  type BytecodeLengthInWordsMustBeOddErrorType,\n  BytecodeLengthMustBeDivisibleBy32Error,\n  type BytecodeLengthMustBeDivisibleBy32ErrorType,\n} from '../errors/bytecode.js'\n\nexport type HashBytecodeErrorType =\n  | BytecodeLengthExceedsMaxSizeErrorType\n  | BytecodeLengthInWordsMustBeOddErrorType\n  | BytecodeLengthMustBeDivisibleBy32ErrorType\n  | Sha256ErrorType\n  | ToBytesErrorType\n  | ErrorType\n\nexport function hashBytecode(bytecode: Hex): Uint8Array {\n  const bytecodeBytes = toBytes(bytecode)\n  if (bytecodeBytes.length % 32 !== 0)\n    throw new BytecodeLengthMustBeDivisibleBy32Error({\n      givenLength: bytecodeBytes.length,\n    })\n\n  if (bytecodeBytes.length > maxBytecodeSize)\n    throw new BytecodeLengthExceedsMaxSizeError({\n      givenLength: bytecodeBytes.length,\n      maxBytecodeSize,\n    })\n\n  const hashStr = sha256(bytecodeBytes)\n  const hash = toBytes(hashStr)\n\n  // Note that the length of the bytecode\n  // should be provided in 32-byte words.\n  const bytecodeLengthInWords = bytecodeBytes.length / 32\n  if (bytecodeLengthInWords % 2 === 0) {\n    throw new BytecodeLengthInWordsMustBeOddError({\n      givenLengthInWords: bytecodeLengthInWords,\n    })\n  }\n\n  const bytecodeLength = toBytes(bytecodeLengthInWords)\n\n  // The bytecode should always take the first 2 bytes of the bytecode hash,\n  // so we pad it from the left in case the length is smaller than 2 bytes.\n  const bytecodeLengthPadded = pad(bytecodeLength, { size: 2 })\n\n  const codeHashVersion = new Uint8Array([1, 0])\n  hash.set(codeHashVersion, 0)\n  hash.set(bytecodeLengthPadded, 2)\n\n  return hash\n}\n","/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, SessionTypes } from \"@walletconnect/types\";\n\nimport { SIGN_CLIENT_STORAGE_PREFIX, SESSION_CONTEXT } from \"../constants/index.js\";\n\nexport class Session extends Store<string, SessionTypes.Struct> {\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    super(core, logger, SESSION_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);\n  }\n}\n","import { getVersion } from './internal/errors.js'\n\nexport type GlobalErrorType<name extends string = 'Error'> = Error & {\n  name: name\n}\n\n/**\n * Base error class inherited by all errors thrown by ox.\n *\n * @example\n * ```ts\n * import { Errors } from 'ox'\n * throw new Errors.BaseError('An error occurred')\n * ```\n */\nexport class BaseError<\n  cause extends Error | undefined = undefined,\n> extends Error {\n  details: string\n  docs?: string | undefined\n  docsPath?: string | undefined\n  shortMessage: string\n\n  override cause: cause\n  override name = 'BaseError'\n\n  version = `ox@${getVersion()}`\n\n  constructor(shortMessage: string, options: BaseError.Options<cause> = {}) {\n    const details = (() => {\n      if (options.cause instanceof BaseError) {\n        if (options.cause.details) return options.cause.details\n        if (options.cause.shortMessage) return options.cause.shortMessage\n      }\n      if (\n        options.cause &&\n        'details' in options.cause &&\n        typeof options.cause.details === 'string'\n      )\n        return options.cause.details\n      if (options.cause?.message) return options.cause.message\n      return options.details!\n    })()\n    const docsPath = (() => {\n      if (options.cause instanceof BaseError)\n        return options.cause.docsPath || options.docsPath\n      return options.docsPath\n    })()\n\n    const docsBaseUrl = 'https://oxlib.sh'\n    const docs = `${docsBaseUrl}${docsPath ?? ''}`\n\n    const message = [\n      shortMessage || 'An error occurred.',\n      ...(options.metaMessages ? ['', ...options.metaMessages] : []),\n      ...(details || docsPath\n        ? [\n            '',\n            details ? `Details: ${details}` : undefined,\n            docsPath ? `See: ${docs}` : undefined,\n          ]\n        : []),\n    ]\n      .filter((x) => typeof x === 'string')\n      .join('\\n')\n\n    super(message, options.cause ? { cause: options.cause } : undefined)\n\n    this.cause = options.cause as any\n    this.details = details\n    this.docs = docs\n    this.docsPath = docsPath\n    this.shortMessage = shortMessage\n  }\n\n  walk(): Error\n  walk(fn: (err: unknown) => boolean): Error | null\n  walk(fn?: any): any {\n    return walk(this, fn)\n  }\n}\n\nexport declare namespace BaseError {\n  type Options<cause extends Error | undefined = Error | undefined> = {\n    cause?: cause | undefined\n    details?: string | undefined\n    docsPath?: string | undefined\n    metaMessages?: (string | undefined)[] | undefined\n  }\n}\n\n/** @internal */\nfunction walk(\n  err: unknown,\n  fn?: ((err: unknown) => boolean) | undefined,\n): unknown {\n  if (fn?.(err)) return err\n  if (err && typeof err === 'object' && 'cause' in err && err.cause)\n    return walk(err.cause, fn)\n  return fn ? null : err\n}\n","import { equalBytes } from '@noble/curves/abstract/utils'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as internal from './internal/bytes.js'\nimport * as internal_hex from './internal/hex.js'\nimport * as Json from './Json.js'\n\nconst decoder = /*#__PURE__*/ new TextDecoder()\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\n/** Root type for a Bytes array. */\nexport type Bytes = Uint8Array\n\n/**\n * Asserts if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.assert('abc')\n * // @error: Bytes.InvalidBytesTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid Bytes value.\n * // @error: Bytes values must be of type `Uint8Array`.\n * ```\n *\n * @param value - Value to assert.\n */\nexport function assert(value: unknown): asserts value is Bytes {\n  if (value instanceof Uint8Array) return\n  if (!value) throw new InvalidBytesTypeError(value)\n  if (typeof value !== 'object') throw new InvalidBytesTypeError(value)\n  if (!('BYTES_PER_ELEMENT' in value)) throw new InvalidBytesTypeError(value)\n  if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== 'Uint8Array')\n    throw new InvalidBytesTypeError(value)\n}\n\nexport declare namespace assert {\n  type ErrorType = InvalidBytesTypeError | Errors.GlobalErrorType\n}\n\n/**\n * Concatenates two or more {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.concat(\n *   Bytes.from([1]),\n *   Bytes.from([69]),\n *   Bytes.from([420, 69]),\n * )\n * // @log: Uint8Array [ 1, 69, 420, 69 ]\n * ```\n *\n * @param values - Values to concatenate.\n * @returns Concatenated {@link ox#Bytes.Bytes}.\n */\nexport function concat(...values: readonly Bytes[]): Bytes {\n  let length = 0\n  for (const arr of values) {\n    length += arr.length\n  }\n  const result = new Uint8Array(length)\n  for (let i = 0, index = 0; i < values.length; i++) {\n    const arr = values[i]\n    result.set(arr!, index)\n    index += arr!.length\n  }\n  return result\n}\n\nexport declare namespace concat {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates a {@link ox#Bytes.Bytes} value from a `Uint8Array`, a hex string, or an array of unsigned 8-bit integers.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Bytes.fromBoolean`\n *\n * - `Bytes.fromString`\n *\n * - `Bytes.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.from([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n *\n * const data = Bytes.from('0xdeadbeef')\n * // @log: Uint8Array([222, 173, 190, 239])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nexport function from(value: Hex.Hex | Bytes | readonly number[]): Bytes {\n  if (value instanceof Uint8Array) return value\n  if (typeof value === 'string') return fromHex(value)\n  return fromArray(value)\n}\n\nexport declare namespace from {\n  type ErrorType =\n    | fromHex.ErrorType\n    | fromArray.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts an array of unsigned 8-bit integers into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromArray([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nexport function fromArray(value: readonly number[] | Uint8Array): Bytes {\n  return value instanceof Uint8Array ? value : new Uint8Array(value)\n}\n\nexport declare namespace fromArray {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Encodes a boolean value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true)\n * // @log: Uint8Array([1])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true, { size: 32 })\n * // @log: Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n * ```\n *\n * @param value - Boolean value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromBoolean(value: boolean, options: fromBoolean.Options = {}) {\n  const { size } = options\n  const bytes = new Uint8Array(1)\n  bytes[0] = Number(value)\n  if (typeof size === 'number') {\n    internal.assertSize(bytes, size)\n    return padLeft(bytes, size)\n  }\n  return bytes\n}\n\nexport declare namespace fromBoolean {\n  type Options = {\n    /** Size of the output bytes. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Hex.Hex} value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Hex.Hex} value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromHex(value: Hex.Hex, options: fromHex.Options = {}): Bytes {\n  const { size } = options\n\n  let hex = value\n  if (size) {\n    internal_hex.assertSize(value, size)\n    hex = Hex.padRight(value, size)\n  }\n\n  let hexString = hex.slice(2) as string\n  if (hexString.length % 2) hexString = `0${hexString}`\n\n  const length = hexString.length / 2\n  const bytes = new Uint8Array(length)\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = internal.charCodeToBase16(hexString.charCodeAt(j++))\n    const nibbleRight = internal.charCodeToBase16(hexString.charCodeAt(j++))\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new Errors.BaseError(\n        `Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`,\n      )\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight\n  }\n  return bytes\n}\n\nexport declare namespace fromHex {\n  type Options = {\n    /** Size of the output bytes. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal_hex.assertSize.ErrorType\n    | Hex.padRight.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a number value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420)\n * // @log: Uint8Array([1, 164])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420, { size: 4 })\n * // @log: Uint8Array([0, 0, 1, 164])\n * ```\n *\n * @param value - Number value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromNumber(\n  value: bigint | number,\n  options?: fromNumber.Options | undefined,\n) {\n  const hex = Hex.fromNumber(value, options)\n  return fromHex(hex)\n}\n\nexport declare namespace fromNumber {\n  export type Options = Hex.fromNumber.Options\n\n  export type ErrorType =\n    | Hex.fromNumber.ErrorType\n    | fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a string into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - String to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromString(\n  value: string,\n  options: fromString.Options = {},\n): Bytes {\n  const { size } = options\n\n  const bytes = encoder.encode(value)\n  if (typeof size === 'number') {\n    internal.assertSize(bytes, size)\n    return padRight(bytes, size)\n  }\n  return bytes\n}\n\nexport declare namespace fromString {\n  type Options = {\n    /** Size of the output bytes. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | padRight.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if two {@link ox#Bytes.Bytes} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([1]))\n * // @log: true\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([2]))\n * // @log: false\n * ```\n *\n * @param bytesA - First {@link ox#Bytes.Bytes} value.\n * @param bytesB - Second {@link ox#Bytes.Bytes} value.\n * @returns `true` if the two values are equal, otherwise `false`.\n */\nexport function isEqual(bytesA: Bytes, bytesB: Bytes) {\n  return equalBytes(bytesA, bytesB)\n}\n\nexport declare namespace isEqual {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.from([1]), 4)\n * // @log: Uint8Array([0, 0, 0, 1])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nexport function padLeft(\n  value: Bytes,\n  size?: number | undefined,\n): padLeft.ReturnType {\n  return internal.pad(value, { dir: 'left', size })\n}\n\nexport declare namespace padLeft {\n  type ReturnType = internal.pad.ReturnType\n  type ErrorType = internal.pad.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padRight(Bytes.from([1]), 4)\n * // @log: Uint8Array([1, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nexport function padRight(\n  value: Bytes,\n  size?: number | undefined,\n): padRight.ReturnType {\n  return internal.pad(value, { dir: 'right', size })\n}\n\nexport declare namespace padRight {\n  type ReturnType = internal.pad.ReturnType\n  type ErrorType = internal.pad.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Generates random {@link ox#Bytes.Bytes} of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.random(32)\n * // @log: Uint8Array([... x32])\n * ```\n *\n * @param length - Length of the random {@link ox#Bytes.Bytes} to generate.\n * @returns Random {@link ox#Bytes.Bytes} of the specified length.\n */\nexport function random(length: number): Bytes {\n  return crypto.getRandomValues(new Uint8Array(length))\n}\n\nexport declare namespace random {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Retrieves the size of a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.size(Bytes.from([1, 2, 3, 4]))\n * // @log: 4\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Size of the {@link ox#Bytes.Bytes} value.\n */\nexport function size(value: Bytes): number {\n  return value.length\n}\n\nexport declare namespace size {\n  export type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(\n *   Bytes.from([1, 2, 3, 4, 5, 6, 7, 8, 9]),\n *   1,\n *   4,\n * )\n * // @log: Uint8Array([2, 3, 4])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value.\n * @param start - Start offset.\n * @param end - End offset.\n * @param options - Slice options.\n * @returns Sliced {@link ox#Bytes.Bytes} value.\n */\nexport function slice(\n  value: Bytes,\n  start?: number | undefined,\n  end?: number | undefined,\n  options: slice.Options = {},\n): Bytes {\n  const { strict } = options\n  internal.assertStartOffset(value, start)\n  const value_ = value.slice(start, end)\n  if (strict) internal.assertEndOffset(value_, start, end)\n  return value_\n}\n\nexport declare namespace slice {\n  type Options = {\n    /** Asserts that the sliced value is the same size as the given start/end offsets. */\n    strict?: boolean | undefined\n  }\n\n  export type ErrorType =\n    | internal.assertStartOffset.ErrorType\n    | internal.assertEndOffset.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a bigint.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBigInt(Bytes.from([1, 164]))\n * // @log: 420n\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded bigint.\n */\nexport function toBigInt(bytes: Bytes, options: toBigInt.Options = {}): bigint {\n  const { size } = options\n  if (typeof size !== 'undefined') internal.assertSize(bytes, size)\n  const hex = Hex.fromBytes(bytes, options)\n  return Hex.toBigInt(hex, options)\n}\n\nexport declare namespace toBigInt {\n  type Options = {\n    /** Whether or not the number of a signed representation. */\n    signed?: boolean | undefined\n    /** Size of the bytes. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Hex.toBigInt.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a boolean.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([1]))\n * // @log: true\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded boolean.\n */\nexport function toBoolean(\n  bytes: Bytes,\n  options: toBoolean.Options = {},\n): boolean {\n  const { size } = options\n  let bytes_ = bytes\n  if (typeof size !== 'undefined') {\n    internal.assertSize(bytes_, size)\n    bytes_ = trimLeft(bytes_)\n  }\n  if (bytes_.length > 1 || bytes_[0]! > 1)\n    throw new InvalidBytesBooleanError(bytes_)\n  return Boolean(bytes_[0])\n}\n\nexport declare namespace toBoolean {\n  type Options = {\n    /** Size of the bytes. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | trimLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toHex(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded {@link ox#Hex.Hex} value.\n */\nexport function toHex(value: Bytes, options: toHex.Options = {}): Hex.Hex {\n  return Hex.fromBytes(value, options)\n}\n\nexport declare namespace toHex {\n  type Options = {\n    /** Size of the bytes. */\n    size?: number | undefined\n  }\n\n  type ErrorType = Hex.fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a number.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toNumber(Bytes.from([1, 164]))\n * // @log: 420\n * ```\n */\nexport function toNumber(bytes: Bytes, options: toNumber.Options = {}): number {\n  const { size } = options\n  if (typeof size !== 'undefined') internal.assertSize(bytes, size)\n  const hex = Hex.fromBytes(bytes, options)\n  return Hex.toNumber(hex, options)\n}\n\nexport declare namespace toNumber {\n  type Options = {\n    /** Whether or not the number of a signed representation. */\n    signed?: boolean | undefined\n    /** Size of the bytes. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Hex.toNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a string.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.toString(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'Hello world'\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded string.\n */\nexport function toString(bytes: Bytes, options: toString.Options = {}): string {\n  const { size } = options\n\n  let bytes_ = bytes\n  if (typeof size !== 'undefined') {\n    internal.assertSize(bytes_, size)\n    bytes_ = trimRight(bytes_)\n  }\n  return decoder.decode(bytes_)\n}\n\nexport declare namespace toString {\n  export type Options = {\n    /** Size of the bytes. */\n    size?: number | undefined\n  }\n\n  export type ErrorType =\n    | internal.assertSize.ErrorType\n    | trimRight.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Trims leading zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimLeft(Bytes.from([0, 0, 0, 0, 1, 2, 3]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nexport function trimLeft(value: Bytes): Bytes {\n  return internal.trim(value, { dir: 'left' })\n}\n\nexport declare namespace trimLeft {\n  type ErrorType = internal.trim.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Trims trailing zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimRight(Bytes.from([1, 2, 3, 0, 0, 0, 0]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nexport function trimRight(value: Bytes): Bytes {\n  return internal.trim(value, { dir: 'right' })\n}\n\nexport declare namespace trimRight {\n  export type ErrorType = internal.trim.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Checks if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.validate('0x')\n * // @log: false\n *\n * Bytes.validate(Bytes.from([1, 2, 3]))\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns `true` if the value is {@link ox#Bytes.Bytes}, otherwise `false`.\n */\nexport function validate(value: unknown): value is Bytes {\n  try {\n    assert(value)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  export type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Thrown when the bytes value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([5]))\n * // @error: Bytes.InvalidBytesBooleanError: Bytes value `[5]` is not a valid boolean.\n * // @error: The bytes array must contain a single byte of either a `0` or `1` value.\n * ```\n */\nexport class InvalidBytesBooleanError extends Errors.BaseError {\n  override readonly name = 'Bytes.InvalidBytesBooleanError'\n\n  constructor(bytes: Bytes) {\n    super(`Bytes value \\`${bytes}\\` is not a valid boolean.`, {\n      metaMessages: [\n        'The bytes array must contain a single byte of either a `0` or `1` value.',\n      ],\n    })\n  }\n}\n\n/**\n * Thrown when a value cannot be converted to bytes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * Bytes.from('foo')\n * // @error: Bytes.InvalidBytesTypeError: Value `foo` of type `string` is an invalid Bytes value.\n * ```\n */\nexport class InvalidBytesTypeError extends Errors.BaseError {\n  override readonly name = 'Bytes.InvalidBytesTypeError'\n\n  constructor(value: unknown) {\n    super(\n      `Value \\`${typeof value === 'object' ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid Bytes value.`,\n      {\n        metaMessages: ['Bytes values must be of type `Bytes`.'],\n      },\n    )\n  }\n}\n\n/**\n * Thrown when a size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromString('Hello World!', { size: 8 })\n * // @error: Bytes.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nexport class SizeOverflowError extends Errors.BaseError {\n  override readonly name = 'Bytes.SizeOverflowError'\n\n  constructor({ givenSize, maxSize }: { givenSize: number; maxSize: number }) {\n    super(\n      `Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`,\n    )\n  }\n}\n\n/**\n * Thrown when a slice offset is out-of-bounds.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(Bytes.from([1, 2, 3]), 4)\n * // @error: Bytes.SliceOffsetOutOfBoundsError: Slice starting at offset `4` is out-of-bounds (size: `3`).\n * ```\n */\nexport class SliceOffsetOutOfBoundsError extends Errors.BaseError {\n  override readonly name = 'Bytes.SliceOffsetOutOfBoundsError'\n\n  constructor({\n    offset,\n    position,\n    size,\n  }: { offset: number; position: 'start' | 'end'; size: number }) {\n    super(\n      `Slice ${\n        position === 'start' ? 'starting' : 'ending'\n      } at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`,\n    )\n  }\n}\n\n/**\n * Thrown when a the padding size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.fromString('Hello World!'), 8)\n * // @error: [Bytes.SizeExceedsPaddingSizeError: Bytes size (`12`) exceeds padding size (`8`).\n * ```\n */\nexport class SizeExceedsPaddingSizeError extends Errors.BaseError {\n  override readonly name = 'Bytes.SizeExceedsPaddingSizeError'\n\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'Hex' | 'Bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`,\n    )\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, PendingRequestTypes } from \"@walletconnect/types\";\nimport { REQUEST_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX } from \"../constants/index.js\";\n\nexport class PendingRequest extends Store<number, PendingRequestTypes.Struct> {\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    super(\n      core,\n      logger,\n      REQUEST_CONTEXT,\n      SIGN_CLIENT_STORAGE_PREFIX,\n      (val: PendingRequestTypes.Struct) => val.id,\n    );\n  }\n}\n","import { secp256k1 } from '@noble/curves/secp256k1'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { Hex } from '../types/misc.js'\nimport { type ToHexErrorType, toHex } from '../utils/encoding/toHex.js'\nimport type { NonceManager } from '../utils/nonceManager.js'\nimport { type ToAccountErrorType, toAccount } from './toAccount.js'\nimport type { PrivateKeyAccount } from './types.js'\nimport {\n  type PublicKeyToAddressErrorType,\n  publicKeyToAddress,\n} from './utils/publicKeyToAddress.js'\nimport { type SignErrorType, sign } from './utils/sign.js'\nimport { signAuthorization } from './utils/signAuthorization.js'\nimport { type SignMessageErrorType, signMessage } from './utils/signMessage.js'\nimport {\n  type SignTransactionErrorType,\n  signTransaction,\n} from './utils/signTransaction.js'\nimport {\n  type SignTypedDataErrorType,\n  signTypedData,\n} from './utils/signTypedData.js'\n\nexport type PrivateKeyToAccountOptions = {\n  nonceManager?: NonceManager | undefined\n}\n\nexport type PrivateKeyToAccountErrorType =\n  | ToAccountErrorType\n  | ToHexErrorType\n  | PublicKeyToAddressErrorType\n  | SignErrorType\n  | SignMessageErrorType\n  | SignTransactionErrorType\n  | SignTypedDataErrorType\n  | ErrorType\n\n/**\n * @description Creates an Account from a private key.\n *\n * @returns A Private Key Account.\n */\nexport function privateKeyToAccount(\n  privateKey: Hex,\n  options: PrivateKeyToAccountOptions = {},\n): PrivateKeyAccount {\n  const { nonceManager } = options\n  const publicKey = toHex(secp256k1.getPublicKey(privateKey.slice(2), false))\n  const address = publicKeyToAddress(publicKey)\n\n  const account = toAccount({\n    address,\n    nonceManager,\n    async sign({ hash }) {\n      return sign({ hash, privateKey, to: 'hex' })\n    },\n    async signAuthorization(authorization) {\n      return signAuthorization({ ...authorization, privateKey })\n    },\n    async signMessage({ message }) {\n      return signMessage({ message, privateKey })\n    },\n    async signTransaction(transaction, { serializer } = {}) {\n      return signTransaction({ privateKey, transaction, serializer })\n    },\n    async signTypedData(typedData) {\n      return signTypedData({ ...typedData, privateKey } as any)\n    },\n  })\n\n  return {\n    ...account,\n    publicKey,\n    source: 'privateKey',\n  } as PrivateKeyAccount\n}\n","unable to read source [project]/node_modules/@coinbase/wallet-sdk/src/sign/walletlink/relay/ui/components/RedirectDialog/RedirectDialog.tsx","import { THIRTY_DAYS, FIVE_SECONDS } from \"@walletconnect/time\";\n\nexport const SUBSCRIBER_EVENTS = {\n  created: \"subscription_created\",\n  deleted: \"subscription_deleted\",\n  expired: \"subscription_expired\",\n  disabled: \"subscription_disabled\",\n  sync: \"subscription_sync\",\n  resubscribed: \"subscription_resubscribed\",\n};\n\nexport const SUBSCRIBER_DEFAULT_TTL = THIRTY_DAYS;\n\nexport const SUBSCRIBER_CONTEXT = \"subscription\";\n\nexport const SUBSCRIBER_STORAGE_VERSION = \"0.3\";\n\nexport const PENDING_SUB_RESOLUTION_TIMEOUT = FIVE_SECONDS * 1000;\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getI64Decoder,\n    getI64Encoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Epoch, Slot, UnixTimestamp } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_CLOCK_ADDRESS } from './sysvar';\n\ntype SysvarClockSize = 40;\n\n/**\n * Contains data on cluster time, including the current slot, epoch, and estimated wall-clock Unix\n * timestamp. It is updated every slot.\n */\nexport type SysvarClock = Readonly<{\n    /** The current epoch */\n    epoch: Epoch;\n    /**\n     * The Unix timestamp of the first slot in this epoch.\n     *\n     * In the first slot of an epoch, this timestamp is identical to the `unixTimestamp`.\n     */\n    epochStartTimestamp: UnixTimestamp;\n    /** The most recent epoch for which the leader schedule has already been generated */\n    leaderScheduleEpoch: Epoch;\n    /** The current slot */\n    slot: Slot;\n    /** The Unix timestamp of this slot */\n    unixTimestamp: UnixTimestamp;\n}>;\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarClock} to a byte array representing\n * the `Clock` sysvar's account data.\n */\nexport function getSysvarClockEncoder(): FixedSizeEncoder<SysvarClock, SysvarClockSize> {\n    return getStructEncoder([\n        ['slot', getU64Encoder()],\n        ['epochStartTimestamp', getI64Encoder()],\n        ['epoch', getU64Encoder()],\n        ['leaderScheduleEpoch', getU64Encoder()],\n        ['unixTimestamp', getI64Encoder()],\n    ]) as FixedSizeEncoder<SysvarClock, SysvarClockSize>;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `Clock` sysvar's\n * account data to a {@link SysvarClock}.\n */\nexport function getSysvarClockDecoder(): FixedSizeDecoder<SysvarClock, SysvarClockSize> {\n    return getStructDecoder([\n        ['slot', getU64Decoder()],\n        ['epochStartTimestamp', getI64Decoder()],\n        ['epoch', getU64Decoder()],\n        ['leaderScheduleEpoch', getU64Decoder()],\n        ['unixTimestamp', getI64Decoder()],\n    ]) as FixedSizeDecoder<SysvarClock, SysvarClockSize>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarClock}\n *\n * @see {@link getSysvarClockDecoder}\n * @see {@link getSysvarClockEncoder}\n */\nexport function getSysvarClockCodec(): FixedSizeCodec<SysvarClock, SysvarClock, SysvarClockSize> {\n    return combineCodec(getSysvarClockEncoder(), getSysvarClockDecoder());\n}\n\n/**\n * Fetches the `Clock` sysvar account using any RPC that supports the {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarClock(rpc: Rpc<GetAccountInfoApi>, config?: FetchAccountConfig): Promise<SysvarClock> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_CLOCK_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarClockDecoder());\n    return decoded.data;\n}\n","import type { ChainFormatters } from '../types/chain.js'\nimport type { RpcTransaction } from '../types/rpc.js'\nimport { hexToBigInt } from '../utils/encoding/fromHex.js'\nimport { defineBlock } from '../utils/formatters/block.js'\nimport {\n  defineTransaction,\n  formatTransaction,\n} from '../utils/formatters/transaction.js'\nimport { defineTransactionReceipt } from '../utils/formatters/transactionReceipt.js'\nimport type { OpStackBlock, OpStackRpcBlock } from './types/block.js'\nimport type {\n  OpStackRpcTransaction,\n  OpStackRpcTransactionReceipt,\n  OpStackTransaction,\n  OpStackTransactionReceipt,\n} from './types/transaction.js'\n\nexport const formatters = {\n  block: /*#__PURE__*/ defineBlock({\n    format(args: OpStackRpcBlock): OpStackBlock {\n      const transactions = args.transactions?.map((transaction) => {\n        if (typeof transaction === 'string') return transaction\n        const formatted = formatTransaction(\n          transaction as RpcTransaction,\n        ) as OpStackTransaction\n        if (formatted.typeHex === '0x7e') {\n          formatted.isSystemTx = transaction.isSystemTx\n          formatted.mint = transaction.mint\n            ? hexToBigInt(transaction.mint)\n            : undefined\n          formatted.sourceHash = transaction.sourceHash\n          formatted.type = 'deposit'\n        }\n        return formatted\n      })\n      return {\n        transactions,\n        stateRoot: args.stateRoot,\n      } as OpStackBlock\n    },\n  }),\n  transaction: /*#__PURE__*/ defineTransaction({\n    format(args: OpStackRpcTransaction): OpStackTransaction {\n      const transaction = {} as OpStackTransaction\n      if (args.type === '0x7e') {\n        transaction.isSystemTx = args.isSystemTx\n        transaction.mint = args.mint ? hexToBigInt(args.mint) : undefined\n        transaction.sourceHash = args.sourceHash\n        transaction.type = 'deposit'\n      }\n      return transaction\n    },\n  }),\n  transactionReceipt: /*#__PURE__*/ defineTransactionReceipt({\n    format(args: OpStackRpcTransactionReceipt): OpStackTransactionReceipt {\n      return {\n        l1GasPrice: args.l1GasPrice ? hexToBigInt(args.l1GasPrice) : null,\n        l1GasUsed: args.l1GasUsed ? hexToBigInt(args.l1GasUsed) : null,\n        l1Fee: args.l1Fee ? hexToBigInt(args.l1Fee) : null,\n        l1FeeScalar: args.l1FeeScalar ? Number(args.l1FeeScalar) : null,\n      } as OpStackTransactionReceipt\n    },\n  }),\n} as const satisfies ChainFormatters\n","import type { Abi } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport type { DeployContractParameters as DeployContractParameters_ } from '../../actions/wallet/deployContract.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ContractConstructorArgs } from '../../types/contract.js'\nimport type { Hash, Hex } from '../../types/misc.js'\nimport {\n  contract2FactoryAddress,\n  contractDeployerAddress,\n} from '../constants/address.js'\nimport type { ChainEIP712 } from '../types/chain.js'\nimport type { ContractDeploymentType } from '../types/contract.js'\nimport {\n  type EncodeDeployDataErrorType,\n  encodeDeployData,\n} from '../utils/abi/encodeDeployData.js'\nimport {\n  type SendEip712TransactionErrorType,\n  type SendEip712TransactionParameters,\n  type SendEip712TransactionReturnType,\n  sendEip712Transaction,\n} from './sendEip712Transaction.js'\n\nexport type DeployContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  allArgs = ContractConstructorArgs<abi>,\n> = DeployContractParameters_<abi, chain, account, chainOverride, allArgs> & {\n  deploymentType?: ContractDeploymentType | undefined\n  factoryDeps?: Hex[] | undefined\n  salt?: Hash | undefined\n}\n\nexport type DeployContractReturnType = SendEip712TransactionReturnType\n\nexport type DeployContractErrorType =\n  | EncodeDeployDataErrorType\n  | SendEip712TransactionErrorType\n  | ErrorType\n\n/**\n * Deploys a contract to the network, given bytecode and constructor arguments using EIP712 transaction.\n *\n * - Docs: https://viem.sh/docs/contract/deployContract\n *\n * @param walletClient - Client to use\n * @param parameters - {@link DeployContractParameters}\n * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link DeployContractReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync } from 'viem/chains'\n * import { deployContract } from 'viem/zksync'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x'),\n *   chain: zksync,\n *   transport: custom(provider),\n * })\n * const hash = await deployContract(client, {\n *   abi: [],\n *   account: '0x,\n *   deploymentType: 'create',\n *   bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',\n *   factoryDeps: ['0x608060405260405161083e38038061083e833981016040819052610...'],\n *   gasPerPubdata: 50000n\n * })\n */\nexport function deployContract<\n  const abi extends Abi | readonly unknown[],\n  chain extends ChainEIP712 | undefined,\n  account extends Account | undefined,\n  chainOverride extends ChainEIP712 | undefined,\n>(\n  walletClient: Client<Transport, chain, account>,\n  parameters: DeployContractParameters<abi, chain, account, chainOverride>,\n): Promise<DeployContractReturnType> {\n  const { abi, args, bytecode, deploymentType, salt, ...request } =\n    parameters as DeployContractParameters\n\n  const data = encodeDeployData({\n    abi,\n    args,\n    bytecode,\n    deploymentType,\n    salt,\n  })\n\n  // Add the bytecode to the factoryDeps if it's not already there\n  request.factoryDeps = request.factoryDeps || []\n  if (!request.factoryDeps.includes(bytecode))\n    request.factoryDeps.push(bytecode)\n\n  return sendEip712Transaction(walletClient, {\n    ...request,\n    data,\n    to:\n      deploymentType === 'create2' || deploymentType === 'create2Account'\n        ? contract2FactoryAddress\n        : contractDeployerAddress,\n  } as unknown as SendEip712TransactionParameters<\n    chain,\n    account,\n    chainOverride\n  >)\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"@walletconnect/types\";\n\nimport {\n  AUTH_KEYS_CONTEXT,\n  AUTH_STORAGE_PREFIX,\n  AUTH_PUBLIC_KEY_NAME,\n} from \"../constants/index.js\";\n\nexport class AuthKey extends Store<string, { responseTopic: string; publicKey: string }> {\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    super(core, logger, AUTH_KEYS_CONTEXT, AUTH_STORAGE_PREFIX, () => AUTH_PUBLIC_KEY_NAME);\n  }\n}\n","import { THIRTY_DAYS, ONE_DAY, THIRTY_SECONDS } from \"@walletconnect/time\";\nimport { RelayerTypes, PairingJsonRpcTypes } from \"@walletconnect/types\";\n\nexport const PAIRING_CONTEXT = \"pairing\";\n\nexport const PAIRING_STORAGE_VERSION = \"0.3\";\n\nexport const PAIRING_DEFAULT_TTL = THIRTY_DAYS;\n\nexport const PAIRING_RPC_OPTS: Record<\n  PairingJsonRpcTypes.WcMethod | \"unregistered_method\",\n  {\n    req: RelayerTypes.PublishOptions;\n    res: RelayerTypes.PublishOptions;\n  }\n> = {\n  wc_pairingDelete: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1000,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1001,\n    },\n  },\n  wc_pairingPing: {\n    req: {\n      ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1002,\n    },\n    res: {\n      ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1003,\n    },\n  },\n  unregistered_method: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 0,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 0,\n    },\n  },\n};\n\nexport const PAIRING_EVENTS = {\n  create: \"pairing_create\",\n  expire: \"pairing_expire\",\n  delete: \"pairing_delete\",\n  ping: \"pairing_ping\",\n};\n","import { chainConfig } from '../../op-stack/chainConfig.js'\nimport { defineChain } from '../../utils/chain/defineChain.js'\n\nconst sourceId = 1 // mainnet\n\nexport const base = /*#__PURE__*/ defineChain({\n  ...chainConfig,\n  id: 8453,\n  name: 'Base',\n  nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: ['https://mainnet.base.org'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Basescan',\n      url: 'https://basescan.org',\n      apiUrl: 'https://api.basescan.org/api',\n    },\n  },\n  contracts: {\n    ...chainConfig.contracts,\n    disputeGameFactory: {\n      [sourceId]: {\n        address: '0x43edB88C4B80fDD2AdFF2412A7BebF9dF42cB40e',\n      },\n    },\n    l2OutputOracle: {\n      [sourceId]: {\n        address: '0x56315b90c40730925ec5485cf004d835058518A0',\n      },\n    },\n    multicall3: {\n      address: '0xca11bde05977b3631167028862be2a173976ca11',\n      blockCreated: 5022,\n    },\n    portal: {\n      [sourceId]: {\n        address: '0x49048044D57e1C92A77f79988d21Fa8fAF74E97e',\n        blockCreated: 17482143,\n      },\n    },\n    l1StandardBridge: {\n      [sourceId]: {\n        address: '0x3154Cf16ccdb4C6d922629664174b904d80F2C35',\n        blockCreated: 17482143,\n      },\n    },\n  },\n  sourceId,\n})\n\nexport const basePreconf = /*#__PURE__*/ defineChain({\n  ...base,\n  experimental_preconfirmationTime: 200,\n  rpcUrls: {\n    default: {\n      http: ['https://mainnet-preconf.base.org'],\n    },\n  },\n})\n","import { EventEmitter } from \"events\";\nimport {\n  JsonRpcResponse,\n  JsonRpcRequest,\n  ErrorResponse,\n  JsonRpcResult,\n  JsonRpcError,\n} from \"@walletconnect/jsonrpc-types\";\nimport { ISignClient } from \"./client.js\";\nimport { RelayerTypes } from \"../core/relayer.js\";\nimport { SessionTypes } from \"./session.js\";\nimport { ProposalTypes } from \"./proposal.js\";\nimport { PairingTypes } from \"../core/pairing.js\";\nimport { JsonRpcTypes } from \"./jsonrpc.js\";\nimport { PendingRequestTypes } from \"./pendingRequest.js\";\nimport { AuthTypes } from \"./auth.js\";\nimport { CryptoTypes } from \"../core/crypto.js\";\n\nexport declare namespace EngineTypes {\n  type Event =\n    | \"session_connect\"\n    | \"session_approve\"\n    | \"session_update\"\n    | \"session_extend\"\n    | \"session_ping\"\n    | \"pairing_ping\"\n    | \"session_request\";\n\n  interface EventArguments {\n    session_connect: {\n      error?: ErrorResponse;\n      session?: SessionTypes.Struct;\n    };\n    session_approve: { error?: ErrorResponse };\n    session_update: { error?: ErrorResponse };\n    session_extend: { error?: ErrorResponse };\n    session_ping: { error?: ErrorResponse };\n    pairing_ping: { error?: ErrorResponse };\n    session_request: { error?: ErrorResponse; result?: any };\n  }\n\n  interface UriParameters {\n    protocol: string;\n    version: number;\n    topic: string;\n    symKey: string;\n    relay: RelayerTypes.ProtocolOptions;\n    methods?: string[];\n    expiryTimestamp?: number;\n  }\n\n  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {\n    topic: string;\n    payload: T;\n    transportType?: RelayerTypes.MessageEvent[\"transportType\"];\n    attestation?: string;\n    encryptedId?: string;\n  }\n\n  interface ConnectParams {\n    /**\n     * @deprecated Use `optionalNamespaces` instead.\n     */\n    requiredNamespaces?: ProposalTypes.RequiredNamespaces;\n    optionalNamespaces?: ProposalTypes.OptionalNamespaces;\n    sessionProperties?: ProposalTypes.SessionProperties;\n    scopedProperties?: ProposalTypes.ScopedProperties;\n    pairingTopic?: string;\n    relays?: RelayerTypes.ProtocolOptions[];\n  }\n\n  interface PairParams {\n    uri: string;\n  }\n\n  interface ApproveParams {\n    id: number;\n    namespaces: SessionTypes.Namespaces;\n    sessionProperties?: ProposalTypes.SessionProperties;\n    scopedProperties?: ProposalTypes.ScopedProperties;\n    sessionConfig?: SessionTypes.SessionConfig;\n    relayProtocol?: string;\n  }\n\n  interface RejectParams {\n    id: number;\n    reason: ErrorResponse;\n  }\n\n  interface UpdateParams {\n    topic: string;\n    namespaces: SessionTypes.Namespaces;\n  }\n\n  interface ExtendParams {\n    topic: string;\n  }\n\n  interface RequestParams {\n    topic: string;\n    request: {\n      method: string;\n      params: any;\n    };\n    chainId: string;\n    expiry?: number;\n  }\n\n  interface RespondParams {\n    topic: string;\n    response: JsonRpcResponse;\n  }\n\n  interface EmitParams {\n    topic: string;\n    event: {\n      name: string;\n      data: any;\n    };\n    chainId: string;\n  }\n\n  interface PingParams {\n    topic: string;\n  }\n\n  interface DisconnectParams {\n    topic: string;\n    reason: ErrorResponse;\n  }\n\n  interface FindParams {\n    requiredNamespaces: ProposalTypes.RequiredNamespaces;\n  }\n\n  type AcknowledgedPromise = Promise<{ acknowledged: () => Promise<void> }>;\n\n  type SessionAuthenticateResponsePromise = {\n    uri: string;\n    response: () => Promise<AuthTypes.AuthenticateResponseResult>;\n  };\n\n  interface RpcOpts {\n    req: RelayerTypes.PublishOptions & {\n      ttl: number;\n    };\n    res: RelayerTypes.PublishOptions & {\n      ttl: number;\n    };\n    reject?: RelayerTypes.PublishOptions & {\n      ttl: number;\n    };\n    autoReject?: RelayerTypes.PublishOptions & {\n      ttl: number;\n    };\n  }\n\n  type RpcOptsMap = Record<JsonRpcTypes.WcMethod, RpcOpts>;\n\n  type EngineQueue<T> = {\n    state: \"IDLE\" | \"ACTIVE\";\n    queue: T[];\n  };\n}\n\nexport abstract class IEngineEvents extends EventEmitter {\n  constructor() {\n    super();\n  }\n\n  public abstract emit: <E extends EngineTypes.Event>(\n    event: string,\n    args: EngineTypes.EventArguments[E],\n  ) => boolean;\n\n  public abstract once: <E extends EngineTypes.Event>(\n    event: string,\n    listener: (args: EngineTypes.EventArguments[E]) => any,\n  ) => this;\n}\n\n// -- private method interface -------------------------------------- //\n\nexport interface EnginePrivate {\n  sendRequest<M extends JsonRpcTypes.WcMethod>(args: {\n    topic: string;\n    method: M;\n    params: JsonRpcTypes.RequestParams[M];\n    expiry?: number;\n    relayRpcId?: number;\n    clientRpcId?: number;\n    throwOnFailedPublish?: boolean;\n    appLink?: string;\n    tvf?: RelayerTypes.ITVF;\n    publishOpts?: RelayerTypes.PublishOptions;\n  }): Promise<number>;\n\n  sendBatchRequest<M extends JsonRpcTypes.WcMethod>(args: {\n    sharedPayload: Record<string, any>;\n    requests: Record<\n      string,\n      {\n        topic: string;\n        method: M;\n        params: JsonRpcTypes.RequestParams[M];\n        expiry?: number;\n        relayRpcId?: number;\n        clientRpcId?: number;\n      }\n    >;\n    throwOnFailedPublish?: boolean;\n    appLink?: string;\n    tvf?: RelayerTypes.ITVF;\n    publishOpts?: RelayerTypes.PublishOptions;\n  }): Promise<number>;\n\n  sendResult<M extends JsonRpcTypes.WcMethod>(args: {\n    id: number;\n    topic: string;\n    result: JsonRpcTypes.Results[M];\n    throwOnFailedPublish?: boolean;\n    encodeOpts?: CryptoTypes.EncodeOptions;\n    appLink?: string;\n    publishOpts?: RelayerTypes.PublishOptions;\n  }): Promise<void>;\n\n  sendError(params: {\n    id: number;\n    topic: string;\n    error: JsonRpcTypes.Error;\n    encodeOpts?: CryptoTypes.EncodeOptions;\n    rpcOpts?: RelayerTypes.PublishOptions;\n    appLink?: string;\n    publishOpts?: RelayerTypes.PublishOptions;\n  }): Promise<void>;\n\n  sendApproveSession(params: {\n    sessionTopic: string;\n    proposal: ProposalTypes.Struct;\n    pairingProposalResponse: JsonRpcTypes.Results[JsonRpcTypes.WcMethod];\n    sessionSettleRequest: JsonRpcTypes.RequestParams[JsonRpcTypes.WcMethod];\n    publishOpts: RelayerTypes.PublishOptions;\n  }): Promise<void>;\n\n  sendProposeSession(params: {\n    proposal: ProposalTypes.Struct;\n    publishOpts: RelayerTypes.PublishOptions;\n  }): Promise<void>;\n\n  onRelayEventRequest(event: EngineTypes.EventCallback<JsonRpcRequest>): Promise<void>;\n\n  onRelayEventResponse(event: EngineTypes.EventCallback<JsonRpcResponse>): Promise<void>;\n\n  onRelayEventUnknownPayload(event: EngineTypes.EventCallback<any>): Promise<void>;\n\n  shouldIgnorePairingRequest(params: { topic: string; requestMethod: string }): boolean;\n\n  deleteSession(params: {\n    topic: string;\n    expirerHasDeleted?: boolean;\n    id?: number;\n    emitEvent?: boolean;\n  }): Promise<void>;\n\n  deleteProposal(id: number, expirerHasDeleted?: boolean): Promise<void>;\n\n  setExpiry(topic: string, expiry: number): Promise<void>;\n\n  setProposal(id: number, proposal: ProposalTypes.Struct): Promise<void>;\n\n  setAuthRequest(\n    id: number,\n    params: {\n      request: AuthTypes.SessionAuthenticateRequest;\n      pairingTopic: string;\n      transportType?: RelayerTypes.MessageEvent[\"transportType\"];\n    },\n  ): Promise<void>;\n\n  setPendingSessionRequest(pendingRequest: PendingRequestTypes.Struct): Promise<void>;\n\n  deletePendingSessionRequest(\n    id: number,\n    reason: ErrorResponse,\n    expirerHasDeleted?: boolean,\n  ): Promise<void>;\n\n  deletePendingAuthRequest(\n    id: number,\n    reason: ErrorResponse,\n    expirerHasDeleted?: boolean,\n  ): Promise<void>;\n\n  cleanupDuplicatePairings(session: SessionTypes.Struct): Promise<void>;\n\n  cleanup(): Promise<void>;\n\n  onSessionProposeRequest(params: {\n    topic: string;\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionPropose\"]>;\n    attestation?: string;\n    encryptedId?: string;\n  }): Promise<void>;\n\n  onSessionProposeResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionPropose\"]> | JsonRpcError,\n    transportType?: RelayerTypes.MessageEvent[\"transportType\"],\n  ): Promise<void>;\n\n  onSessionSettleRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionSettle\"]>,\n  ): Promise<void>;\n\n  onSessionSettleResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionSettle\"]> | JsonRpcError,\n  ): Promise<void>;\n\n  onSessionUpdateRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionUpdate\"]>,\n  ): Promise<void>;\n\n  onSessionUpdateResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionUpdate\"]> | JsonRpcError,\n  ): void;\n\n  onSessionExtendRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionExtend\"]>,\n  ): Promise<void>;\n\n  onSessionExtendResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionExtend\"]> | JsonRpcError,\n  ): void;\n\n  onSessionPingRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionPing\"]>,\n  ): Promise<void>;\n\n  onSessionPingResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionPing\"]> | JsonRpcError,\n  ): void;\n\n  onSessionDeleteRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionDelete\"]>,\n  ): Promise<void>;\n\n  onSessionRequest(params: {\n    topic: string;\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionRequest\"]>;\n    transportType?: RelayerTypes.MessageEvent[\"transportType\"];\n    attestation?: string;\n    encryptedId?: string;\n  }): Promise<void>;\n\n  onSessionRequestResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionRequest\"]> | JsonRpcError,\n  ): void;\n\n  onSessionEventRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionEvent\"]>,\n  ): Promise<void>;\n\n  onSessionAuthenticateRequest(params: {\n    topic: string;\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionAuthenticate\"]>;\n    transportType?: RelayerTypes.MessageEvent[\"transportType\"];\n    attestation?: string;\n    encryptedId?: string;\n  }): Promise<void>;\n\n  onSessionAuthenticateResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionAuthenticate\"]> | JsonRpcError,\n  ): void;\n\n  // -- Validators ---------------------------------------------------- //\n  isValidConnect(params: EngineTypes.ConnectParams): Promise<void>;\n\n  isValidSessionSettleRequest(params: JsonRpcTypes.RequestParams[\"wc_sessionSettle\"]): void;\n\n  isValidApprove(params: EngineTypes.ApproveParams): Promise<void>;\n\n  isValidReject(params: EngineTypes.RejectParams): Promise<void>;\n\n  isValidUpdate(params: EngineTypes.UpdateParams): Promise<void>;\n\n  isValidExtend(params: EngineTypes.ExtendParams): Promise<void>;\n\n  isValidRequest(params: EngineTypes.RequestParams): Promise<void>;\n\n  isValidRespond(params: EngineTypes.RespondParams): Promise<void>;\n\n  isValidPing(params: EngineTypes.PingParams): Promise<void>;\n\n  isValidEmit(params: EngineTypes.EmitParams): Promise<void>;\n\n  isValidDisconnect(params: EngineTypes.DisconnectParams): Promise<void>;\n}\n\n// -- class interface ----------------------------------------------- //\n\nexport abstract class IEngine {\n  constructor(public client: ISignClient) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract connect(\n    params: EngineTypes.ConnectParams,\n  ): Promise<{ uri?: string; approval: () => Promise<SessionTypes.Struct> }>;\n\n  public abstract pair(params: EngineTypes.PairParams): Promise<PairingTypes.Struct>;\n\n  public abstract approve(\n    params: EngineTypes.ApproveParams,\n  ): Promise<{ topic: string; acknowledged: () => Promise<SessionTypes.Struct> }>;\n\n  public abstract reject(params: EngineTypes.RejectParams): Promise<void>;\n\n  public abstract update(params: EngineTypes.UpdateParams): EngineTypes.AcknowledgedPromise;\n\n  public abstract extend(params: EngineTypes.ExtendParams): EngineTypes.AcknowledgedPromise;\n\n  public abstract request<T>(params: EngineTypes.RequestParams): Promise<T>;\n\n  public abstract respond(params: EngineTypes.RespondParams): Promise<void>;\n\n  public abstract emit(params: EngineTypes.EmitParams): Promise<void>;\n\n  public abstract ping(params: EngineTypes.PingParams): Promise<void>;\n\n  public abstract disconnect(params: EngineTypes.DisconnectParams): Promise<void>;\n\n  public abstract find: (params: EngineTypes.FindParams) => SessionTypes.Struct[];\n\n  public abstract getPendingSessionRequests: () => PendingRequestTypes.Struct[];\n\n  public abstract authenticate: (\n    params: AuthTypes.SessionAuthenticateParams,\n    walletUniversalLink?: string,\n  ) => Promise<EngineTypes.SessionAuthenticateResponsePromise>;\n\n  public abstract approveSessionAuthenticate: (\n    params: AuthTypes.ApproveSessionAuthenticateParams,\n  ) => Promise<{ session: SessionTypes.Struct | undefined }>;\n\n  public abstract formatAuthMessage: (params: {\n    request: AuthTypes.BaseAuthRequestParams;\n    iss: string;\n  }) => string;\n\n  public abstract rejectSessionAuthenticate(params: EngineTypes.RejectParams): Promise<void>;\n\n  /**\n   * no longer used as the client initializes instantly without waiting to connect+subscribe\n   * @deprecated\n   */\n  public abstract processRelayMessageCache(): void;\n}\n","export const HISTORY_EVENTS = {\n  created: \"history_created\",\n  updated: \"history_updated\",\n  deleted: \"history_deleted\",\n  sync: \"history_sync\",\n};\n\nexport const HISTORY_CONTEXT = \"history\";\n\nexport const HISTORY_STORAGE_VERSION = \"0.3\";\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const peaq = /*#__PURE__*/ defineChain({\n  id: 3338,\n  name: 'Peaq',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'peaq',\n    symbol: 'PEAQ',\n  },\n  rpcUrls: {\n    default: {\n      http: [\n        'https://quicknode1.peaq.xyz',\n        'https://quicknode2.peaq.xyz',\n        'https://quicknode3.peaq.xyz',\n      ],\n      webSocket: [\n        'wss://quicknode1.peaq.xyz',\n        'wss://quicknode2.peaq.xyz',\n        'wss://quicknode3.peaq.xyz',\n      ],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Subscan',\n      url: 'https://peaq.subscan.io',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xca11bde05977b3631167028862be2a173976ca11',\n      blockCreated: 3566354,\n    },\n  },\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\nimport { chainConfig } from '../../zksync/chainConfig.js'\n\nexport const abstractTestnet = /*#__PURE__*/ defineChain({\n  ...chainConfig,\n  blockTime: 200,\n  id: 11_124,\n  name: 'Abstract Testnet',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'ETH',\n    symbol: 'ETH',\n  },\n  rpcUrls: {\n    default: { http: ['https://api.testnet.abs.xyz'] },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Etherscan',\n      url: 'https://sepolia.abscan.org',\n    },\n    native: {\n      name: 'Abstract Explorer',\n      url: 'https://explorer.testnet.abs.xyz',\n    },\n  },\n  testnet: true,\n  contracts: {\n    multicall3: {\n      address: '0xF9cda624FBC7e059355ce98a31693d299FACd963',\n      blockCreated: 358349,\n    },\n    erc6492Verifier: {\n      address: '0xfB688330379976DA81eB64Fe4BF50d7401763B9C',\n      blockCreated: 431682,\n    },\n  },\n})\n","import { Logger } from \"@walletconnect/logger\";\nimport { IAuth, ICore } from \"@walletconnect/types\";\nimport { AuthPairingTopic } from \"./authPairingTopic.js\";\nimport { AuthRequest } from \"./authRequest.js\";\nimport { AuthKey } from \"./authKey.js\";\n\nexport class AuthStore {\n  public authKeys: IAuth[\"authKeys\"];\n  public pairingTopics: IAuth[\"pairingTopics\"];\n  public requests: IAuth[\"requests\"];\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    this.authKeys = new AuthKey(this.core, this.logger);\n    this.pairingTopics = new AuthPairingTopic(this.core, this.logger);\n    this.requests = new AuthRequest(this.core, this.logger);\n  }\n\n  public async init() {\n    await this.authKeys.init();\n    await this.pairingTopics.init();\n    await this.requests.init();\n  }\n}\n","import * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { Compute, ExactPartial } from './internal/types.js'\nimport * as Json from './Json.js'\n\n/** Root type for an ECDSA Public Key. */\nexport type PublicKey<\n  compressed extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<\n  compressed extends true\n    ? {\n        prefix: numberType\n        x: bigintType\n        y?: undefined\n      }\n    : {\n        prefix: numberType\n        x: bigintType\n        y: bigintType\n      }\n>\n\n/**\n * Asserts that a {@link ox#PublicKey.PublicKey} is valid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @error: PublicKey.InvalidError: Value \\`{\"y\":\"1\"}\\` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nexport function assert(\n  publicKey: ExactPartial<PublicKey>,\n  options: assert.Options = {},\n): asserts publicKey is PublicKey {\n  const { compressed } = options\n  const { prefix, x, y } = publicKey\n\n  // Uncompressed\n  if (\n    compressed === false ||\n    (typeof x === 'bigint' && typeof y === 'bigint')\n  ) {\n    if (prefix !== 4)\n      throw new InvalidPrefixError({\n        prefix,\n        cause: new InvalidUncompressedPrefixError(),\n      })\n    return\n  }\n\n  // Compressed\n  if (\n    compressed === true ||\n    (typeof x === 'bigint' && typeof y === 'undefined')\n  ) {\n    if (prefix !== 3 && prefix !== 2)\n      throw new InvalidPrefixError({\n        prefix,\n        cause: new InvalidCompressedPrefixError(),\n      })\n    return\n  }\n\n  // Unknown/invalid\n  throw new InvalidError({ publicKey })\n}\n\nexport declare namespace assert {\n  type Options = {\n    /** Whether or not the public key should be compressed. */\n    compressed?: boolean\n  }\n\n  type ErrorType = InvalidError | InvalidPrefixError | Errors.GlobalErrorType\n}\n\n/**\n * Compresses a {@link ox#PublicKey.PublicKey}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const compressed = PublicKey.compress(publicKey) // [!code focus]\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The public key to compress.\n * @returns The compressed public key.\n */\nexport function compress(publicKey: PublicKey<false>): PublicKey<true> {\n  const { x, y } = publicKey\n  return {\n    prefix: y % 2n === 0n ? 2 : 3,\n    x,\n  }\n}\n\nexport declare namespace compress {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates a typed {@link ox#PublicKey.PublicKey} object from a {@link ox#PublicKey.PublicKey}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from('0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param value - The public key value to instantiate.\n * @returns The instantiated {@link ox#PublicKey.PublicKey}.\n */\nexport function from<\n  const publicKey extends\n    | CompressedPublicKey\n    | UncompressedPublicKey\n    | Hex.Hex\n    | Bytes.Bytes,\n>(value: from.Value<publicKey>): from.ReturnType<publicKey> {\n  const publicKey = (() => {\n    if (Hex.validate(value)) return fromHex(value)\n    if (Bytes.validate(value)) return fromBytes(value)\n\n    const { prefix, x, y } = value\n    if (typeof x === 'bigint' && typeof y === 'bigint')\n      return { prefix: prefix ?? 0x04, x, y }\n    return { prefix, x }\n  })()\n\n  assert(publicKey)\n\n  return publicKey as never\n}\n\n/** @internal */\ntype CompressedPublicKey = PublicKey<true>\n\n/** @internal */\ntype UncompressedPublicKey = Omit<PublicKey<false>, 'prefix'> & {\n  prefix?: PublicKey['prefix'] | undefined\n}\n\nexport declare namespace from {\n  type Value<\n    publicKey extends\n      | CompressedPublicKey\n      | UncompressedPublicKey\n      | Hex.Hex\n      | Bytes.Bytes = PublicKey,\n  > = publicKey | CompressedPublicKey | UncompressedPublicKey\n\n  type ReturnType<\n    publicKey extends\n      | CompressedPublicKey\n      | UncompressedPublicKey\n      | Hex.Hex\n      | Bytes.Bytes = PublicKey,\n  > = publicKey extends CompressedPublicKey | UncompressedPublicKey\n    ? publicKey extends UncompressedPublicKey\n      ? Compute<publicKey & { readonly prefix: 0x04 }>\n      : publicKey\n    : PublicKey\n\n  type ErrorType = assert.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nexport function fromBytes(publicKey: Bytes.Bytes): PublicKey {\n  return fromHex(Hex.fromBytes(publicKey))\n}\n\nexport declare namespace fromBytes {\n  type ErrorType =\n    | fromHex.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### Deserializing a Compressed Public Key\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x038318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed75')\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nexport function fromHex(publicKey: Hex.Hex): PublicKey {\n  if (\n    publicKey.length !== 132 &&\n    publicKey.length !== 130 &&\n    publicKey.length !== 68\n  )\n    throw new InvalidSerializedSizeError({ publicKey })\n\n  if (publicKey.length === 130) {\n    const x = BigInt(Hex.slice(publicKey, 0, 32))\n    const y = BigInt(Hex.slice(publicKey, 32, 64))\n    return {\n      prefix: 4,\n      x,\n      y,\n    } as never\n  }\n\n  if (publicKey.length === 132) {\n    const prefix = Number(Hex.slice(publicKey, 0, 1))\n    const x = BigInt(Hex.slice(publicKey, 1, 33))\n    const y = BigInt(Hex.slice(publicKey, 33, 65))\n    return {\n      prefix,\n      x,\n      y,\n    } as never\n  }\n\n  const prefix = Number(Hex.slice(publicKey, 0, 1))\n  const x = BigInt(Hex.slice(publicKey, 1, 33))\n  return {\n    prefix,\n    x,\n  } as never\n}\n\nexport declare namespace fromHex {\n  type ErrorType = Hex.slice.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const bytes = PublicKey.toBytes(publicKey) // [!code focus]\n * // @log: Uint8Array [128, 3, 131, ...]\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nexport function toBytes(\n  publicKey: PublicKey<boolean>,\n  options: toBytes.Options = {},\n): Bytes.Bytes {\n  return Bytes.fromHex(toHex(publicKey, options))\n}\n\nexport declare namespace toBytes {\n  type Options = {\n    /**\n     * Whether to include the prefix in the serialized public key.\n     * @default true\n     */\n    includePrefix?: boolean | undefined\n  }\n\n  type ErrorType =\n    | Hex.fromNumber.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const hex = PublicKey.toHex(publicKey) // [!code focus]\n * // @log: '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5'\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nexport function toHex(\n  publicKey: PublicKey<boolean>,\n  options: toHex.Options = {},\n): Hex.Hex {\n  assert(publicKey)\n\n  const { prefix, x, y } = publicKey\n  const { includePrefix = true } = options\n\n  const publicKey_ = Hex.concat(\n    includePrefix ? Hex.fromNumber(prefix, { size: 1 }) : '0x',\n    Hex.fromNumber(x, { size: 32 }),\n    // If the public key is not compressed, add the y coordinate.\n    typeof y === 'bigint' ? Hex.fromNumber(y, { size: 32 }) : '0x',\n  )\n\n  return publicKey_\n}\n\nexport declare namespace toHex {\n  type Options = {\n    /**\n     * Whether to include the prefix in the serialized public key.\n     * @default true\n     */\n    includePrefix?: boolean | undefined\n  }\n\n  type ErrorType = Hex.fromNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Validates a {@link ox#PublicKey.PublicKey}. Returns `true` if valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const valid = PublicKey.validate({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @log: false\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nexport function validate(\n  publicKey: ExactPartial<PublicKey>,\n  options: validate.Options = {},\n): boolean {\n  try {\n    assert(publicKey, options)\n    return true\n  } catch (_error) {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /** Whether or not the public key should be compressed. */\n    compressed?: boolean\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Thrown when a public key is invalid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({ y: 1n })\n * // @error: PublicKey.InvalidError: Value `{\"y\":1n}` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n */\nexport class InvalidError extends Errors.BaseError {\n  override readonly name = 'PublicKey.InvalidError'\n\n  constructor({ publicKey }: { publicKey: unknown }) {\n    super(`Value \\`${Json.stringify(publicKey)}\\` is not a valid public key.`, {\n      metaMessages: [\n        'Public key must contain:',\n        '- an `x` and `prefix` value (compressed)',\n        '- an `x`, `y`, and `prefix` value (uncompressed)',\n      ],\n    })\n  }\n}\n\n/** Thrown when a public key has an invalid prefix. */\nexport class InvalidPrefixError<\n  cause extends InvalidCompressedPrefixError | InvalidUncompressedPrefixError =\n    | InvalidCompressedPrefixError\n    | InvalidUncompressedPrefixError,\n> extends Errors.BaseError<cause> {\n  override readonly name = 'PublicKey.InvalidPrefixError'\n\n  constructor({ prefix, cause }: { prefix: number | undefined; cause: cause }) {\n    super(`Prefix \"${prefix}\" is invalid.`, {\n      cause,\n    })\n  }\n}\n\n/** Thrown when the public key has an invalid prefix for a compressed public key. */\nexport class InvalidCompressedPrefixError extends Errors.BaseError {\n  override readonly name = 'PublicKey.InvalidCompressedPrefixError'\n\n  constructor() {\n    super('Prefix must be 2 or 3 for compressed public keys.')\n  }\n}\n\n/** Thrown when the public key has an invalid prefix for an uncompressed public key. */\nexport class InvalidUncompressedPrefixError extends Errors.BaseError {\n  override readonly name = 'PublicKey.InvalidUncompressedPrefixError'\n\n  constructor() {\n    super('Prefix must be 4 for uncompressed public keys.')\n  }\n}\n\n/** Thrown when the public key has an invalid serialized size. */\nexport class InvalidSerializedSizeError extends Errors.BaseError {\n  override readonly name = 'PublicKey.InvalidSerializedSizeError'\n\n  constructor({ publicKey }: { publicKey: Hex.Hex | Bytes.Bytes }) {\n    super(`Value \\`${publicKey}\\` is an invalid public key size.`, {\n      metaMessages: [\n        'Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).',\n        `Received ${Hex.size(Hex.from(publicKey))} bytes.`,\n      ],\n    })\n  }\n}\n","/**\n * hash-to-curve from RFC 9380.\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * https://www.rfc-editor.org/rfc/rfc9380\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport type { AffinePoint, Group, GroupConstructor } from './curve.ts';\nimport { FpInvertBatch, type IField, mod } from './modular.ts';\nimport type { CHash } from './utils.ts';\nimport { abytes, bytesToNumberBE, concatBytes, utf8ToBytes, validateObject } from './utils.ts';\n\nexport type UnicodeOrBytes = string | Uint8Array;\n\n/**\n * * `DST` is a domain separation tag, defined in section 2.2.5\n * * `p` characteristic of F, where F is a finite field of characteristic p and order q = p^m\n * * `m` is extension degree (1 for prime fields)\n * * `k` is the target security target in bits (e.g. 128), from section 5.1\n * * `expand` is `xmd` (SHA2, SHA3, BLAKE) or `xof` (SHAKE, BLAKE-XOF)\n * * `hash` conforming to `utils.CHash` interface, with `outputLen` / `blockLen` props\n */\nexport type Opts = {\n  DST: UnicodeOrBytes;\n  p: bigint;\n  m: number;\n  k: number;\n  expand: 'xmd' | 'xof';\n  hash: CHash;\n};\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = bytesToNumberBE;\n\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value: number, length: number): Uint8Array {\n  anum(value);\n  anum(length);\n  if (value < 0 || value >= 1 << (8 * length)) throw new Error('invalid I2OSP input: ' + value);\n  const res = Array.from({ length }).fill(0) as number[];\n  for (let i = length - 1; i >= 0; i--) {\n    res[i] = value & 0xff;\n    value >>>= 8;\n  }\n  return new Uint8Array(res);\n}\n\nfunction strxor(a: Uint8Array, b: Uint8Array): Uint8Array {\n  const arr = new Uint8Array(a.length);\n  for (let i = 0; i < a.length; i++) {\n    arr[i] = a[i] ^ b[i];\n  }\n  return arr;\n}\n\nfunction anum(item: unknown): void {\n  if (!Number.isSafeInteger(item)) throw new Error('number expected');\n}\n\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */\nexport function expand_message_xmd(\n  msg: Uint8Array,\n  DST: Uint8Array,\n  lenInBytes: number,\n  H: CHash\n): Uint8Array {\n  abytes(msg);\n  abytes(DST);\n  anum(lenInBytes);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  if (DST.length > 255) DST = H(concatBytes(utf8ToBytes('H2C-OVERSIZE-DST-'), DST));\n  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n  const ell = Math.ceil(lenInBytes / b_in_bytes);\n  if (lenInBytes > 65535 || ell > 255) throw new Error('expand_message_xmd: invalid lenInBytes');\n  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));\n  const Z_pad = i2osp(0, r_in_bytes);\n  const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n  const b = new Array<Uint8Array>(ell);\n  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n  b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));\n  for (let i = 1; i <= ell; i++) {\n    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n    b[i] = H(concatBytes(...args));\n  }\n  const pseudo_random_bytes = concatBytes(...b);\n  return pseudo_random_bytes.slice(0, lenInBytes);\n}\n\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */\nexport function expand_message_xof(\n  msg: Uint8Array,\n  DST: Uint8Array,\n  lenInBytes: number,\n  k: number,\n  H: CHash\n): Uint8Array {\n  abytes(msg);\n  abytes(DST);\n  anum(lenInBytes);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n  if (DST.length > 255) {\n    const dkLen = Math.ceil((2 * k) / 8);\n    DST = H.create({ dkLen }).update(utf8ToBytes('H2C-OVERSIZE-DST-')).update(DST).digest();\n  }\n  if (lenInBytes > 65535 || DST.length > 255)\n    throw new Error('expand_message_xof: invalid lenInBytes');\n  return (\n    H.create({ dkLen: lenInBytes })\n      .update(msg)\n      .update(i2osp(lenInBytes, 2))\n      // 2. DST_prime = DST || I2OSP(len(DST), 1)\n      .update(DST)\n      .update(i2osp(DST.length, 1))\n      .digest()\n  );\n}\n\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nexport function hash_to_field(msg: Uint8Array, count: number, options: Opts): bigint[][] {\n  validateObject(options, {\n    DST: 'stringOrUint8Array',\n    p: 'bigint',\n    m: 'isSafeInteger',\n    k: 'isSafeInteger',\n    hash: 'hash',\n  });\n  const { p, k, m, hash, expand, DST: _DST } = options;\n  abytes(msg);\n  anum(count);\n  const DST = typeof _DST === 'string' ? utf8ToBytes(_DST) : _DST;\n  const log2p = p.toString(2).length;\n  const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n  const len_in_bytes = count * m * L;\n  let prb; // pseudo_random_bytes\n  if (expand === 'xmd') {\n    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n  } else if (expand === 'xof') {\n    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n  } else if (expand === '_internal_pass') {\n    // for internal tests only\n    prb = msg;\n  } else {\n    throw new Error('expand must be \"xmd\" or \"xof\"');\n  }\n  const u = new Array(count);\n  for (let i = 0; i < count; i++) {\n    const e = new Array(m);\n    for (let j = 0; j < m; j++) {\n      const elm_offset = L * (j + i * m);\n      const tv = prb.subarray(elm_offset, elm_offset + L);\n      e[j] = mod(os2ip(tv), p);\n    }\n    u[i] = e;\n  }\n  return u;\n}\n\nexport type XY<T> = (x: T, y: T) => { x: T; y: T };\nexport type XYRatio<T> = [T[], T[], T[], T[]]; // xn/xd, yn/yd\nexport function isogenyMap<T, F extends IField<T>>(field: F, map: XYRatio<T>): XY<T> {\n  // Make same order as in spec\n  const coeff = map.map((i) => Array.from(i).reverse());\n  return (x: T, y: T) => {\n    const [xn, xd, yn, yd] = coeff.map((val) =>\n      val.reduce((acc, i) => field.add(field.mul(acc, x), i))\n    );\n    // 6.6.3\n    // Exceptional cases of iso_map are inputs that cause the denominator of\n    // either rational function to evaluate to zero; such cases MUST return\n    // the identity point on E.\n    const [xd_inv, yd_inv] = FpInvertBatch(field, [xd, yd], true);\n    x = field.mul(xn, xd_inv); // xNum / xDen\n    y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\n    return { x, y };\n  };\n}\n\n/** Point interface, which curves must implement to work correctly with the module. */\nexport interface H2CPoint<T> extends Group<H2CPoint<T>> {\n  add(rhs: H2CPoint<T>): H2CPoint<T>;\n  toAffine(iz?: bigint): AffinePoint<T>;\n  clearCofactor(): H2CPoint<T>;\n  assertValidity(): void;\n}\n\nexport interface H2CPointConstructor<T> extends GroupConstructor<H2CPoint<T>> {\n  fromAffine(ap: AffinePoint<T>): H2CPoint<T>;\n}\n\nexport type MapToCurve<T> = (scalar: bigint[]) => AffinePoint<T>;\n\n// Separated from initialization opts, so users won't accidentally change per-curve parameters\n// (changing DST is ok!)\nexport type htfBasicOpts = { DST: UnicodeOrBytes };\nexport type HTFMethod<T> = (msg: Uint8Array, options?: htfBasicOpts) => H2CPoint<T>;\nexport type MapMethod<T> = (scalars: bigint[]) => H2CPoint<T>;\nexport type Hasher<T> = {\n  hashToCurve: HTFMethod<T>;\n  encodeToCurve: HTFMethod<T>;\n  mapToCurve: MapMethod<T>;\n  defaults: Opts & { encodeDST?: UnicodeOrBytes };\n};\n\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. */\nexport function createHasher<T>(\n  Point: H2CPointConstructor<T>,\n  mapToCurve: MapToCurve<T>,\n  defaults: Opts & { encodeDST?: UnicodeOrBytes }\n): Hasher<T> {\n  if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');\n  function map(num: bigint[]) {\n    return Point.fromAffine(mapToCurve(num));\n  }\n  function clear(initial: H2CPoint<T>) {\n    const P = initial.clearCofactor();\n    if (P.equals(Point.ZERO)) return Point.ZERO; // zero will throw in assert\n    P.assertValidity();\n    return P;\n  }\n\n  return {\n    defaults,\n\n    // Encodes byte string to elliptic curve.\n    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n    hashToCurve(msg: Uint8Array, options?: htfBasicOpts): H2CPoint<T> {\n      const u = hash_to_field(msg, 2, { ...defaults, DST: defaults.DST, ...options } as Opts);\n      const u0 = map(u[0]);\n      const u1 = map(u[1]);\n      return clear(u0.add(u1));\n    },\n\n    // Encodes byte string to elliptic curve.\n    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n    encodeToCurve(msg: Uint8Array, options?: htfBasicOpts): H2CPoint<T> {\n      const u = hash_to_field(msg, 1, { ...defaults, DST: defaults.encodeDST, ...options } as Opts);\n      return clear(map(u[0]));\n    },\n\n    // Same as encodeToCurve, but without hash\n    mapToCurve(scalars: bigint[]): H2CPoint<T> {\n      if (!Array.isArray(scalars)) throw new Error('expected array of bigints');\n      for (const i of scalars)\n        if (typeof i !== 'bigint') throw new Error('expected array of bigints');\n      return clear(map(scalars));\n    },\n  };\n}\n","export const VERIFY_CONTEXT = \"verify-api\";\n\nconst VERIFY_SERVER_COM = \"https://verify.walletconnect.com\";\nconst VERIFY_SERVER_ORG = \"https://verify.walletconnect.org\";\nexport const VERIFY_SERVER = VERIFY_SERVER_ORG;\nexport const VERIFY_SERVER_V3 = `${VERIFY_SERVER}/v3`;\n\nexport const TRUSTED_VERIFY_URLS = [VERIFY_SERVER_COM, VERIFY_SERVER_ORG];\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { COMPUTE_BUDGET_PROGRAM_ADDRESS } from '../programs';\n\nexport const REQUEST_HEAP_FRAME_DISCRIMINATOR = 1;\n\nexport function getRequestHeapFrameDiscriminatorBytes() {\n  return getU8Encoder().encode(REQUEST_HEAP_FRAME_DISCRIMINATOR);\n}\n\nexport type RequestHeapFrameInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<TRemainingAccounts>;\n\nexport type RequestHeapFrameInstructionData = {\n  discriminator: number;\n  /**\n   * Requested transaction-wide program heap size in bytes.\n   * Must be multiple of 1024. Applies to each program, including CPIs.\n   */\n  bytes: number;\n};\n\nexport type RequestHeapFrameInstructionDataArgs = {\n  /**\n   * Requested transaction-wide program heap size in bytes.\n   * Must be multiple of 1024. Applies to each program, including CPIs.\n   */\n  bytes: number;\n};\n\nexport function getRequestHeapFrameInstructionDataEncoder(): FixedSizeEncoder<RequestHeapFrameInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['bytes', getU32Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: REQUEST_HEAP_FRAME_DISCRIMINATOR })\n  );\n}\n\nexport function getRequestHeapFrameInstructionDataDecoder(): FixedSizeDecoder<RequestHeapFrameInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['bytes', getU32Decoder()],\n  ]);\n}\n\nexport function getRequestHeapFrameInstructionDataCodec(): FixedSizeCodec<\n  RequestHeapFrameInstructionDataArgs,\n  RequestHeapFrameInstructionData\n> {\n  return combineCodec(\n    getRequestHeapFrameInstructionDataEncoder(),\n    getRequestHeapFrameInstructionDataDecoder()\n  );\n}\n\nexport type RequestHeapFrameInput = {\n  bytes: RequestHeapFrameInstructionDataArgs['bytes'];\n};\n\nexport function getRequestHeapFrameInstruction<\n  TProgramAddress extends Address = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n>(\n  input: RequestHeapFrameInput,\n  config?: { programAddress?: TProgramAddress }\n): RequestHeapFrameInstruction<TProgramAddress> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? COMPUTE_BUDGET_PROGRAM_ADDRESS;\n\n  // Original args.\n  const args = { ...input };\n\n  return Object.freeze({\n    data: getRequestHeapFrameInstructionDataEncoder().encode(\n      args as RequestHeapFrameInstructionDataArgs\n    ),\n    programAddress,\n  } as RequestHeapFrameInstruction<TProgramAddress>);\n}\n\nexport type ParsedRequestHeapFrameInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n> = {\n  programAddress: Address<TProgram>;\n  data: RequestHeapFrameInstructionData;\n};\n\nexport function parseRequestHeapFrameInstruction<TProgram extends string>(\n  instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>\n): ParsedRequestHeapFrameInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getRequestHeapFrameInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","import { EventEmitter } from \"events\";\nimport { Core } from \"@walletconnect/core\";\nimport { SignClientTypes, ISignClient, ISignClientEvents, EngineTypes } from \"@walletconnect/types\";\nimport { populateAppMetadata, createLogger } from \"@walletconnect/utils\";\nimport { getLoggerContext } from \"@walletconnect/logger\";\nimport {\n  SIGN_CLIENT_DEFAULT,\n  SIGN_CLIENT_PROTOCOL,\n  SIGN_CLIENT_VERSION,\n} from \"./constants/index.js\";\nimport { AuthStore, Engine, PendingRequest, Proposal, Session } from \"./controllers/index.js\";\n\nexport class SignClient extends ISignClient {\n  public readonly protocol = SIGN_CLIENT_PROTOCOL;\n  public readonly version = SIGN_CLIENT_VERSION;\n  public readonly name: ISignClient[\"name\"] = SIGN_CLIENT_DEFAULT.name;\n  public readonly metadata: ISignClient[\"metadata\"];\n\n  public core: ISignClient[\"core\"];\n  public logger: ISignClient[\"logger\"];\n  public events: ISignClient[\"events\"] = new EventEmitter();\n  public engine: ISignClient[\"engine\"];\n  public session: ISignClient[\"session\"];\n  public proposal: ISignClient[\"proposal\"];\n  public pendingRequest: ISignClient[\"pendingRequest\"];\n  public auth: ISignClient[\"auth\"];\n  public signConfig?: ISignClient[\"signConfig\"];\n\n  static async init(opts?: SignClientTypes.Options) {\n    const client = new SignClient(opts);\n    await client.initialize();\n\n    return client;\n  }\n\n  constructor(opts?: SignClientTypes.Options) {\n    super(opts);\n\n    this.name = opts?.name || SIGN_CLIENT_DEFAULT.name;\n    this.metadata = populateAppMetadata(opts?.metadata);\n    this.signConfig = opts?.signConfig;\n\n    const logger = createLogger({\n      logger: opts?.logger || SIGN_CLIENT_DEFAULT.logger,\n      name: this.name,\n    });\n    this.logger = logger;\n    this.core = opts?.core || new Core(opts);\n    this.session = new Session(this.core, this.logger);\n    this.proposal = new Proposal(this.core, this.logger);\n    this.pendingRequest = new PendingRequest(this.core, this.logger);\n    this.engine = new Engine(this);\n    this.auth = new AuthStore(this.core, this.logger);\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n\n  // ---------- Events ----------------------------------------------- //\n\n  public on: ISignClientEvents[\"on\"] = (name, listener) => {\n    return this.events.on(name, listener);\n  };\n\n  public once: ISignClientEvents[\"once\"] = (name, listener) => {\n    return this.events.once(name, listener);\n  };\n\n  public off: ISignClientEvents[\"off\"] = (name, listener) => {\n    return this.events.off(name, listener);\n  };\n\n  public removeListener: ISignClientEvents[\"removeListener\"] = (name, listener) => {\n    return this.events.removeListener(name, listener);\n  };\n\n  public removeAllListeners: ISignClientEvents[\"removeAllListeners\"] = (name) => {\n    return this.events.removeAllListeners(name);\n  };\n\n  // ---------- Engine ----------------------------------------------- //\n\n  public connect: ISignClient[\"connect\"] = async (params) => {\n    try {\n      return await this.engine.connect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public pair: ISignClient[\"pair\"] = async (params) => {\n    try {\n      return await this.engine.pair(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public approve: ISignClient[\"approve\"] = async (params) => {\n    try {\n      return await this.engine.approve(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public reject: ISignClient[\"reject\"] = async (params) => {\n    try {\n      return await this.engine.reject(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public update: ISignClient[\"update\"] = async (params) => {\n    try {\n      return await this.engine.update(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public extend: ISignClient[\"extend\"] = async (params) => {\n    try {\n      return await this.engine.extend(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public request: ISignClient[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    try {\n      return await this.engine.request<T>(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public respond: ISignClient[\"respond\"] = async (params) => {\n    try {\n      return await this.engine.respond(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public ping: ISignClient[\"ping\"] = async (params) => {\n    try {\n      return await this.engine.ping(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public emit: ISignClient[\"emit\"] = async (params) => {\n    try {\n      return await this.engine.emit(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public disconnect: ISignClient[\"disconnect\"] = async (params) => {\n    try {\n      return await this.engine.disconnect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public find: ISignClient[\"find\"] = (params) => {\n    try {\n      return this.engine.find(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public getPendingSessionRequests: ISignClient[\"getPendingSessionRequests\"] = () => {\n    try {\n      return this.engine.getPendingSessionRequests();\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public authenticate: ISignClient[\"authenticate\"] = async (params, walletUniversalLink) => {\n    try {\n      return await this.engine.authenticate(params, walletUniversalLink);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public formatAuthMessage: ISignClient[\"formatAuthMessage\"] = (params) => {\n    try {\n      return this.engine.formatAuthMessage(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public approveSessionAuthenticate: ISignClient[\"approveSessionAuthenticate\"] = async (params) => {\n    try {\n      return await this.engine.approveSessionAuthenticate(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public rejectSessionAuthenticate: ISignClient[\"rejectSessionAuthenticate\"] = async (params) => {\n    try {\n      return await this.engine.rejectSessionAuthenticate(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    try {\n      await this.core.start();\n      await this.session.init();\n      await this.proposal.init();\n      await this.pendingRequest.init();\n      await this.auth.init();\n      await this.engine.init();\n      this.logger.info(`SignClient Initialization Success`);\n    } catch (error: any) {\n      this.logger.info(`SignClient Initialization Failure`);\n      this.logger.error(error.message);\n      throw error;\n    }\n  }\n}\n","import { RpcRequest, RpcRequestTransformer, RpcResponseTransformer } from '@solana/rpc-spec-types';\n\nexport type KeyPathWildcard = { readonly ['__keyPathWildcard:@solana/kit']: unique symbol };\nexport type KeyPath = ReadonlyArray<KeyPath | KeyPathWildcard | number | string>;\n\nexport const KEYPATH_WILDCARD = {} as KeyPathWildcard;\n\ntype NodeVisitor = <TState extends TraversalState>(value: unknown, state: TState) => unknown;\nexport type TraversalState = Readonly<{\n    keyPath: KeyPath;\n}>;\n\nfunction getTreeWalker(visitors: NodeVisitor[]) {\n    return function traverse<TState extends TraversalState>(node: unknown, state: TState): unknown {\n        if (Array.isArray(node)) {\n            return node.map((element, ii) => {\n                const nextState = {\n                    ...state,\n                    keyPath: [...state.keyPath, ii],\n                };\n                return traverse(element, nextState);\n            });\n        } else if (typeof node === 'object' && node !== null) {\n            const out: Record<number | string | symbol, unknown> = {};\n            for (const propName in node) {\n                if (!Object.prototype.hasOwnProperty.call(node, propName)) {\n                    continue;\n                }\n                const nextState = {\n                    ...state,\n                    keyPath: [...state.keyPath, propName],\n                };\n                out[propName] = traverse(node[propName as keyof typeof node], nextState);\n            }\n            return out;\n        } else {\n            return visitors.reduce((acc, visitNode) => visitNode(acc, state), node);\n        }\n    };\n}\n\n/**\n * Creates a transformer that traverses the request parameters and executes the provided visitors at\n * each node. A custom initial state can be provided but must at least provide `{ keyPath: [] }`.\n *\n * @example\n * ```ts\n * import { getTreeWalkerRequestTransformer } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getTreeWalkerRequestTransformer(\n *     [\n *         // Replaces foo.bar with \"baz\".\n *         (node, state) => (state.keyPath === ['foo', 'bar'] ? 'baz' : node),\n *         // Increments all numbers by 1.\n *         node => (typeof node === number ? node + 1 : node),\n *     ],\n *     { keyPath: [] },\n * );\n * ```\n */\nexport function getTreeWalkerRequestTransformer<TState extends TraversalState>(\n    visitors: NodeVisitor[],\n    initialState: TState,\n): RpcRequestTransformer {\n    return <TParams>(request: RpcRequest<TParams>): RpcRequest => {\n        const traverse = getTreeWalker(visitors);\n        return Object.freeze({\n            ...request,\n            params: traverse(request.params, initialState),\n        });\n    };\n}\n\nexport function getTreeWalkerResponseTransformer<TState extends TraversalState>(\n    visitors: NodeVisitor[],\n    initialState: TState,\n): RpcResponseTransformer {\n    return json => getTreeWalker(visitors)(json, initialState);\n}\n","export const EVENT_CLIENT_CONTEXT = \"event-client\";\n\nexport const EVENT_CLIENT_PAIRING_TRACES = {\n  pairing_started: \"pairing_started\",\n  pairing_uri_validation_success: \"pairing_uri_validation_success\",\n  pairing_uri_not_expired: \"pairing_uri_not_expired\",\n  store_new_pairing: \"store_new_pairing\",\n  subscribing_pairing_topic: \"subscribing_pairing_topic\",\n  subscribe_pairing_topic_success: \"subscribe_pairing_topic_success\",\n  existing_pairing: \"existing_pairing\",\n  pairing_not_expired: \"pairing_not_expired\",\n  emit_inactive_pairing: \"emit_inactive_pairing\",\n  emit_session_proposal: \"emit_session_proposal\",\n  subscribing_to_pairing_topic: \"subscribing_to_pairing_topic\",\n};\n\nexport const EVENT_CLIENT_PAIRING_ERRORS = {\n  no_wss_connection: \"no_wss_connection\",\n  no_internet_connection: \"no_internet_connection\",\n  malformed_pairing_uri: \"malformed_pairing_uri\",\n  active_pairing_already_exists: \"active_pairing_already_exists\",\n  subscribe_pairing_topic_failure: \"subscribe_pairing_topic_failure\",\n  pairing_expired: \"pairing_expired\",\n  proposal_expired: \"proposal_expired\",\n  proposal_listener_not_found: \"proposal_listener_not_found\",\n};\n\nexport const EVENT_CLIENT_SESSION_TRACES = {\n  session_approve_started: \"session_approve_started\",\n  proposal_not_expired: \"proposal_not_expired\",\n  session_namespaces_validation_success: \"session_namespaces_validation_success\",\n  create_session_topic: \"create_session_topic\",\n  subscribing_session_topic: \"subscribing_session_topic\",\n  subscribe_session_topic_success: \"subscribe_session_topic_success\",\n  publishing_session_approve: \"publishing_session_approve\",\n  session_approve_publish_success: \"session_approve_publish_success\",\n  store_session: \"store_session\",\n  publishing_session_settle: \"publishing_session_settle\",\n  session_settle_publish_success: \"session_settle_publish_success\",\n  session_request_response_started: \"session_request_response_started\",\n  session_request_response_validation_success: \"session_request_response_validation_success\",\n  session_request_response_publish_started: \"session_request_response_publish_started\",\n};\n\nexport const EVENT_CLIENT_SESSION_ERRORS = {\n  no_internet_connection: \"no_internet_connection\",\n  no_wss_connection: \"no_wss_connection\",\n  proposal_expired: \"proposal_expired\",\n  subscribe_session_topic_failure: \"subscribe_session_topic_failure\",\n  session_approve_publish_failure: \"session_approve_publish_failure\",\n  session_settle_publish_failure: \"session_settle_publish_failure\",\n  session_approve_namespace_validation_failure: \"session_approve_namespace_validation_failure\",\n  proposal_not_found: \"proposal_not_found\",\n  session_request_response_validation_failure: \"session_request_response_validation_failure\",\n  session_request_response_publish_failure: \"session_request_response_publish_failure\",\n};\n\nexport const EVENT_CLIENT_AUTHENTICATE_TRACES = {\n  authenticated_session_approve_started: \"authenticated_session_approve_started\",\n  authenticated_session_not_expired: \"authenticated_session_not_expired\",\n  chains_caip2_compliant: \"chains_caip2_compliant\",\n  chains_evm_compliant: \"chains_evm_compliant\",\n  create_authenticated_session_topic: \"create_authenticated_session_topic\",\n  cacaos_verified: \"cacaos_verified\",\n  store_authenticated_session: \"store_authenticated_session\",\n  subscribing_authenticated_session_topic: \"subscribing_authenticated_session_topic\",\n  subscribe_authenticated_session_topic_success: \"subscribe_authenticated_session_topic_success\",\n  publishing_authenticated_session_approve: \"publishing_authenticated_session_approve\",\n  authenticated_session_approve_publish_success: \"authenticated_session_approve_publish_success\",\n};\n\nexport const EVENT_CLIENT_AUTHENTICATE_ERRORS = {\n  no_internet_connection: \"no_internet_connection\",\n  no_wss_connection: \"no_wss_connection\",\n  missing_session_authenticate_request: \"missing_session_authenticate_request\",\n  session_authenticate_request_expired: \"session_authenticate_request_expired\",\n  chains_caip2_compliant_failure: \"chains_caip2_compliant_failure\",\n  chains_evm_compliant_failure: \"chains_evm_compliant_failure\",\n  invalid_cacao: \"invalid_cacao\",\n  subscribe_authenticated_session_topic_failure: \"subscribe_authenticated_session_topic_failure\",\n  authenticated_session_approve_publish_failure: \"authenticated_session_approve_publish_failure\",\n  authenticated_session_pending_request_not_found:\n    \"authenticated_session_pending_request_not_found\",\n};\n\nexport const EVENTS_STORAGE_VERSION = 0.1;\n\nexport const EVENTS_STORAGE_CONTEXT = \"event-client\";\n\nexport const EVENTS_STORAGE_CLEANUP_INTERVAL = 86400;\n\nexport const EVENTS_CLIENT_API_URL = \"https://pulse.walletconnect.org/batch\";\n","import { ripemd160 as noble_ripemd160 } from '@noble/hashes/ripemd160'\nimport { keccak_256 as noble_keccak256 } from '@noble/hashes/sha3'\nimport { sha256 as noble_sha256 } from '@noble/hashes/sha256'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\n\n/**\n * Calculates the [Keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `keccak_256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef')\n * // @log: '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @example\n * ### Calculate Hash of a String\n *\n * ```ts twoslash\n * import { Hash, Hex } from 'ox'\n *\n * Hash.keccak256(Hex.fromString('hello world'))\n * // @log: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0'\n * ```\n *\n * @example\n * ### Configure Return Type\n *\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef', { as: 'Bytes' })\n * // @log: Uint8Array [...]\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Keccak256 hash.\n */\nexport function keccak256<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Hex.Hex | Bytes.Bytes,\n  options: keccak256.Options<as> = {},\n): keccak256.ReturnType<as> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const bytes = noble_keccak256(Bytes.from(value))\n  if (as === 'Bytes') return bytes as never\n  return Hex.fromBytes(bytes) as never\n}\n\nexport declare namespace keccak256 {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> = {\n    /** The return type. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Calculates the [Ripemd160](https://en.wikipedia.org/wiki/RIPEMD) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `ripemd160` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.ripemd160('0xdeadbeef')\n * // '0x226821c2f5423e11fe9af68bd285c249db2e4b5a'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Ripemd160 hash.\n */\nexport function ripemd160<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Hex.Hex | Bytes.Bytes,\n  options: ripemd160.Options<as> = {},\n): ripemd160.ReturnType<as> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const bytes = noble_ripemd160(Bytes.from(value))\n  if (as === 'Bytes') return bytes as never\n  return Hex.fromBytes(bytes) as never\n}\n\nexport declare namespace ripemd160 {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> = {\n    /** The return type. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Calculates the [Sha256](https://en.wikipedia.org/wiki/SHA-256) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `sha256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.sha256('0xdeadbeef')\n * // '0x5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Sha256 hash.\n */\nexport function sha256<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Hex.Hex | Bytes.Bytes,\n  options: sha256.Options<as> = {},\n): sha256.ReturnType<as> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const bytes = noble_sha256(Bytes.from(value))\n  if (as === 'Bytes') return bytes as never\n  return Hex.fromBytes(bytes) as never\n}\n\nexport declare namespace sha256 {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /** The return type. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if a string is a valid hash value.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.validate('0x')\n * // @log: false\n *\n * Hash.validate('0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid hash.\n */\nexport function validate(value: string): value is Hex.Hex {\n  return Hex.validate(value) && Hex.size(value) === 32\n}\n\nexport declare namespace validate {\n  type ErrorType =\n    | Hex.validate.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n","import { secp256k1 } from '@noble/curves/secp256k1'\nimport * as Address from './Address.js'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as Entropy from './internal/entropy.js'\nimport type { OneOf } from './internal/types.js'\nimport * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\n\n/** Re-export of noble/curves secp256k1 utilities. */\nexport const noble = secp256k1\n\n/**\n * Creates a new secp256k1 ECDSA key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const { privateKey, publicKey } = Secp256k1.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */\nexport function createKeyPair<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: createKeyPair.Options<as> = {},\n): createKeyPair.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const privateKey = randomPrivateKey({ as })\n  const publicKey = getPublicKey({ privateKey })\n\n  return {\n    privateKey: privateKey as never,\n    publicKey,\n  }\n}\n\nexport declare namespace createKeyPair {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> = {\n    privateKey:\n      | (as extends 'Bytes' ? Bytes.Bytes : never)\n      | (as extends 'Hex' ? Hex.Hex : never)\n    publicKey: PublicKey.PublicKey\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | PublicKey.from.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes the secp256k1 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const publicKey = Secp256k1.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey(\n  options: getPublicKey.Options,\n): PublicKey.PublicKey {\n  const { privateKey } = options\n  const point = secp256k1.ProjectivePoint.fromPrivateKey(\n    Hex.from(privateKey).slice(2),\n  )\n  return PublicKey.from(point)\n}\n\nexport declare namespace getPublicKey {\n  type Options = {\n    /**\n     * Private key to compute the public key from.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType =\n    | Hex.from.ErrorType\n    | PublicKey.from.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const { privateKey: privateKeyA } = Secp256k1.createKeyPair()\n * const { publicKey: publicKeyB } = Secp256k1.createKeyPair()\n *\n * const sharedSecret = Secp256k1.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nexport function getSharedSecret<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: getSharedSecret.Options<as>,\n): getSharedSecret.ReturnType<as> {\n  const { as = 'Hex', privateKey, publicKey } = options\n  const point = secp256k1.ProjectivePoint.fromHex(\n    PublicKey.toHex(publicKey).slice(2),\n  )\n  const sharedPoint = point.multiply(\n    secp256k1.utils.normPrivateKeyToScalar(Hex.from(privateKey).slice(2)),\n  )\n  const sharedSecret = sharedPoint.toRawBytes(true) // compressed format\n  if (as === 'Hex') return Hex.fromBytes(sharedSecret) as never\n  return sharedSecret as never\n}\n\nexport declare namespace getSharedSecret {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned shared secret.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /**\n     * Private key to use for the shared secret computation.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n    /**\n     * Public key to use for the shared secret computation.\n     */\n    publicKey: PublicKey.PublicKey<boolean>\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Hex.from.ErrorType\n    | PublicKey.toHex.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Generates a random ECDSA private key on the secp256k1 curve.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: randomPrivateKey.Options<as> = {},\n): randomPrivateKey.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const bytes = secp256k1.utils.randomPrivateKey()\n  if (as === 'Hex') return Hex.fromBytes(bytes) as never\n  return bytes as never\n}\n\nexport declare namespace randomPrivateKey {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Hex.fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Recovers the signing address from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const address = Secp256k1.recoverAddress({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered address.\n */\nexport function recoverAddress(\n  options: recoverAddress.Options,\n): recoverAddress.ReturnType {\n  return Address.fromPublicKey(recoverPublicKey(options))\n}\n\nexport declare namespace recoverAddress {\n  type Options = {\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Signature of the payload. */\n    signature: Signature.Signature\n  }\n\n  type ReturnType = Address.Address\n\n  type ErrorType =\n    | Address.fromPublicKey.ErrorType\n    | recoverPublicKey.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = Secp256k1.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */\nexport function recoverPublicKey(\n  options: recoverPublicKey.Options,\n): PublicKey.PublicKey {\n  const { payload, signature } = options\n  const { r, s, yParity } = signature\n  const signature_ = new secp256k1.Signature(\n    BigInt(r),\n    BigInt(s),\n  ).addRecoveryBit(yParity)\n  const point = signature_.recoverPublicKey(Hex.from(payload).substring(2))\n  return PublicKey.from(point)\n}\n\nexport declare namespace recoverPublicKey {\n  type Options = {\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Signature of the payload. */\n    signature: Signature.Signature\n  }\n\n  type ErrorType =\n    | PublicKey.from.ErrorType\n    | Hex.from.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs the payload with the provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */\nexport function sign(options: sign.Options): Signature.Signature {\n  const {\n    extraEntropy = Entropy.extraEntropy,\n    hash,\n    payload,\n    privateKey,\n  } = options\n  const { r, s, recovery } = secp256k1.sign(\n    Bytes.from(payload),\n    Bytes.from(privateKey),\n    {\n      extraEntropy:\n        typeof extraEntropy === 'boolean'\n          ? extraEntropy\n          : Hex.from(extraEntropy).slice(2),\n      lowS: true,\n      ...(hash ? { prehash: true } : {}),\n    },\n  )\n  return {\n    r,\n    s,\n    yParity: recovery,\n  }\n}\n\nexport declare namespace sign {\n  type Options = {\n    /**\n     * Extra entropy to add to the signing process. Setting to `false` will disable it.\n     * @default true\n     */\n    extraEntropy?: boolean | Hex.Hex | Bytes.Bytes | undefined\n    /**\n     *  If set to `true`, the payload will be hashed (sha256) before being signed.\n     */\n    hash?: boolean | undefined\n    /**\n     * Payload to sign.\n     */\n    payload: Hex.Hex | Bytes.Bytes\n    /**\n     * ECDSA private key.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Bytes.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a payload was signed by the provided address.\n *\n * @example\n * ### Verify with Ethereum Address\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Verify with Public Key\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = '0x...'\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided address.\n */\nexport function verify(options: verify.Options): boolean {\n  const { address, hash, payload, publicKey, signature } = options\n  if (address)\n    return Address.isEqual(address, recoverAddress({ payload, signature }))\n  return secp256k1.verify(\n    signature,\n    Bytes.from(payload),\n    PublicKey.toBytes(publicKey),\n    ...(hash ? [{ prehash: true, lowS: true }] : []),\n  )\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** If set to `true`, the payload will be hashed (sha256) before being verified. */\n    hash?: boolean | undefined\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n  } & OneOf<\n    | {\n        /** Address that signed the payload. */\n        address: Address.Address\n        /** Signature of the payload. */\n        signature: Signature.Signature\n      }\n    | {\n        /** Public key that signed the payload. */\n        publicKey: PublicKey.PublicKey<boolean>\n        /** Signature of the payload. */\n        signature: Signature.Signature<false>\n      }\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n","/**\n * Short Weierstrass curve methods. The formula is: y = x + ax + b.\n *\n * ### Parameters\n *\n * To initialize a weierstrass curve, one needs to pass following params:\n *\n * * a: formula param\n * * b: formula param\n * * Fp: finite field of prime characteristic P; may be complex (Fp2). Arithmetics is done in field\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * Gx: Base point (x, y) aka generator point. Gx = x coordinate\n * * Gy: ...y coordinate\n * * h: cofactor, usually 1. h*n = curve group order (n is only subgroup order)\n * * lowS: whether to enable (default) or disable \"low-s\" non-malleable signatures\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// prettier-ignore\nimport {\n  pippenger, validateBasic, wNAF,\n  type AffinePoint, type BasicCurve, type Group, type GroupConstructor\n} from './curve.ts';\n// prettier-ignore\nimport {\n  Field,\n  FpInvertBatch,\n  getMinHashLength, invert, mapHashToField, mod, validateField,\n  type IField\n} from './modular.ts';\n// prettier-ignore\nimport {\n  aInRange, abool,\n  bitMask,\n  bytesToHex, bytesToNumberBE, concatBytes, createHmacDrbg, ensureBytes, hexToBytes,\n  inRange, isBytes, memoized, numberToBytesBE, numberToHexUnpadded, validateObject,\n  type CHash, type Hex, type PrivKey\n} from './utils.ts';\n\nexport type { AffinePoint };\ntype HmacFnSync = (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array;\n/**\n * When Weierstrass curve has `a=0`, it becomes Koblitz curve.\n * Koblitz curves allow using **efficiently-computable GLV endomorphism **.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n *\n * Endomorphism consists of beta, lambda and splitScalar:\n *\n * 1. GLV endomorphism  transforms a point: `P = (x, y)  (P) = (x mod p, y)`\n * 2. GLV scalar decomposition transforms a scalar: `k  k + k (mod n)`\n * 3. Then these are combined: `kP = kP + k(P)`\n * 4. Two 128-bit point-by-scalar multiplications + one point addition is faster than\n *    one 256-bit multiplication.\n *\n * where\n * * beta:   F with  = 1,   1\n * * lambda:   F with  = 1,   1\n * * splitScalar decomposes k  k, k, by using reduced basis vectors.\n *   Gauss lattice reduction calculates them from initial basis vectors `(n, 0), (-, 0)`\n *\n * Check out `test/misc/endomorphism.js` and\n * [gist](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n */\nexport type EndomorphismOpts = {\n  beta: bigint;\n  splitScalar: (k: bigint) => { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\n};\nexport type BasicWCurve<T> = BasicCurve<T> & {\n  // Params: a, b\n  a: T;\n  b: T;\n\n  // Optional params\n  allowedPrivateKeyLengths?: readonly number[]; // for P521\n  wrapPrivateKey?: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\n  endo?: EndomorphismOpts;\n  // When a cofactor != 1, there can be an effective methods to:\n  // 1. Determine whether a point is torsion-free\n  isTorsionFree?: (c: ProjConstructor<T>, point: ProjPointType<T>) => boolean;\n  // 2. Clear torsion component\n  clearCofactor?: (c: ProjConstructor<T>, point: ProjPointType<T>) => ProjPointType<T>;\n};\n\nexport type Entropy = Hex | boolean;\nexport type SignOpts = { lowS?: boolean; extraEntropy?: Entropy; prehash?: boolean };\nexport type VerOpts = { lowS?: boolean; prehash?: boolean; format?: 'compact' | 'der' | undefined };\n\nfunction validateSigVerOpts(opts: SignOpts | VerOpts) {\n  if (opts.lowS !== undefined) abool('lowS', opts.lowS);\n  if (opts.prehash !== undefined) abool('prehash', opts.prehash);\n}\n\n// Instance for 3d XYZ points\nexport interface ProjPointType<T> extends Group<ProjPointType<T>> {\n  readonly px: T;\n  readonly py: T;\n  readonly pz: T;\n  get x(): T;\n  get y(): T;\n  toAffine(iz?: T): AffinePoint<T>;\n  toHex(isCompressed?: boolean): string;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n\n  assertValidity(): void;\n  hasEvenY(): boolean;\n  multiplyUnsafe(scalar: bigint): ProjPointType<T>;\n  multiplyAndAddUnsafe(Q: ProjPointType<T>, a: bigint, b: bigint): ProjPointType<T> | undefined;\n  isTorsionFree(): boolean;\n  clearCofactor(): ProjPointType<T>;\n  _setWindowSize(windowSize: number): void;\n}\n// Static methods for 3d XYZ points\nexport interface ProjConstructor<T> extends GroupConstructor<ProjPointType<T>> {\n  new (x: T, y: T, z: T): ProjPointType<T>;\n  fromAffine(p: AffinePoint<T>): ProjPointType<T>;\n  fromHex(hex: Hex): ProjPointType<T>;\n  fromPrivateKey(privateKey: PrivKey): ProjPointType<T>;\n  normalizeZ(points: ProjPointType<T>[]): ProjPointType<T>[];\n  msm(points: ProjPointType<T>[], scalars: bigint[]): ProjPointType<T>;\n}\n\nexport type CurvePointsType<T> = BasicWCurve<T> & {\n  // Bytes\n  fromBytes?: (bytes: Uint8Array) => AffinePoint<T>;\n  toBytes?: (c: ProjConstructor<T>, point: ProjPointType<T>, isCompressed: boolean) => Uint8Array;\n};\n\nexport type CurvePointsTypeWithLength<T> = Readonly<\n  CurvePointsType<T> & { nByteLength: number; nBitLength: number }\n>;\n\nfunction validatePointOpts<T>(curve: CurvePointsType<T>): CurvePointsTypeWithLength<T> {\n  const opts = validateBasic(curve);\n  validateObject(\n    opts,\n    {\n      a: 'field',\n      b: 'field',\n    },\n    {\n      allowInfinityPoint: 'boolean',\n      allowedPrivateKeyLengths: 'array',\n      clearCofactor: 'function',\n      fromBytes: 'function',\n      isTorsionFree: 'function',\n      toBytes: 'function',\n      wrapPrivateKey: 'boolean',\n    }\n  );\n  const { endo, Fp, a } = opts;\n  if (endo) {\n    if (!Fp.eql(a, Fp.ZERO)) {\n      throw new Error('invalid endo: CURVE.a must be 0');\n    }\n    if (\n      typeof endo !== 'object' ||\n      typeof endo.beta !== 'bigint' ||\n      typeof endo.splitScalar !== 'function'\n    ) {\n      throw new Error('invalid endo: expected \"beta\": bigint and \"splitScalar\": function');\n    }\n  }\n  return Object.freeze({ ...opts } as const);\n}\n\nexport type CurvePointsRes<T> = {\n  CURVE: ReturnType<typeof validatePointOpts<T>>;\n  ProjectivePoint: ProjConstructor<T>;\n  normPrivateKeyToScalar: (key: PrivKey) => bigint;\n  weierstrassEquation: (x: T) => T;\n  isWithinCurveOrder: (num: bigint) => boolean;\n};\n\nexport class DERErr extends Error {\n  constructor(m = '') {\n    super(m);\n  }\n}\nexport type IDER = {\n  // asn.1 DER encoding utils\n  Err: typeof DERErr;\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (tag: number, data: string) => string;\n    // v - value, l - left bytes (unparsed)\n    decode(tag: number, data: Uint8Array): { v: Uint8Array; l: Uint8Array };\n  };\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(num: bigint): string;\n    decode(data: Uint8Array): bigint;\n  };\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint };\n  hexFromSig(sig: { r: bigint; s: bigint }): string;\n};\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexport const DER: IDER = {\n  // asn.1 DER encoding utils\n  Err: DERErr,\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (tag: number, data: string): string => {\n      const { Err: E } = DER;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length & 1) throw new E('tlv.encode: unpadded data');\n      const dataLen = data.length / 2;\n      const len = numberToHexUnpadded(dataLen);\n      if ((len.length / 2) & 0b1000_0000) throw new E('tlv.encode: long form length too big');\n      // length of length with long form flag\n      const lenLen = dataLen > 127 ? numberToHexUnpadded((len.length / 2) | 0b1000_0000) : '';\n      const t = numberToHexUnpadded(tag);\n      return t + lenLen + len + data;\n    },\n    // v - value, l - left bytes (unparsed)\n    decode(tag: number, data: Uint8Array): { v: Uint8Array; l: Uint8Array } {\n      const { Err: E } = DER;\n      let pos = 0;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length < 2 || data[pos++] !== tag) throw new E('tlv.decode: wrong tlv');\n      const first = data[pos++];\n      const isLong = !!(first & 0b1000_0000); // First bit of first length byte is flag for short/long form\n      let length = 0;\n      if (!isLong) length = first;\n      else {\n        // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n        const lenLen = first & 0b0111_1111;\n        if (!lenLen) throw new E('tlv.decode(long): indefinite length not supported');\n        if (lenLen > 4) throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n        const lengthBytes = data.subarray(pos, pos + lenLen);\n        if (lengthBytes.length !== lenLen) throw new E('tlv.decode: length bytes not complete');\n        if (lengthBytes[0] === 0) throw new E('tlv.decode(long): zero leftmost byte');\n        for (const b of lengthBytes) length = (length << 8) | b;\n        pos += lenLen;\n        if (length < 128) throw new E('tlv.decode(long): not minimal encoding');\n      }\n      const v = data.subarray(pos, pos + length);\n      if (v.length !== length) throw new E('tlv.decode: wrong value length');\n      return { v, l: data.subarray(pos + length) };\n    },\n  },\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(num: bigint): string {\n      const { Err: E } = DER;\n      if (num < _0n) throw new E('integer: negative integers are not allowed');\n      let hex = numberToHexUnpadded(num);\n      // Pad with zero byte if negative flag is present\n      if (Number.parseInt(hex[0], 16) & 0b1000) hex = '00' + hex;\n      if (hex.length & 1) throw new E('unexpected DER parsing assertion: unpadded hex');\n      return hex;\n    },\n    decode(data: Uint8Array): bigint {\n      const { Err: E } = DER;\n      if (data[0] & 0b1000_0000) throw new E('invalid signature integer: negative');\n      if (data[0] === 0x00 && !(data[1] & 0b1000_0000))\n        throw new E('invalid signature integer: unnecessary leading zero');\n      return bytesToNumberBE(data);\n    },\n  },\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint } {\n    // parse DER signature\n    const { Err: E, _int: int, _tlv: tlv } = DER;\n    const data = ensureBytes('signature', hex);\n    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n    if (seqLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n    const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n    if (sLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    return { r: int.decode(rBytes), s: int.decode(sBytes) };\n  },\n  hexFromSig(sig: { r: bigint; s: bigint }): string {\n    const { _tlv: tlv, _int: int } = DER;\n    const rs = tlv.encode(0x02, int.encode(sig.r));\n    const ss = tlv.encode(0x02, int.encode(sig.s));\n    const seq = rs + ss;\n    return tlv.encode(0x30, seq);\n  },\n};\n\nfunction numToSizedHex(num: bigint, size: number): string {\n  return bytesToHex(numberToBytesBE(num, size));\n}\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\nexport function weierstrassPoints<T>(opts: CurvePointsType<T>): CurvePointsRes<T> {\n  const CURVE = validatePointOpts(opts);\n  const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n  const Fn = Field(CURVE.n, CURVE.nBitLength);\n\n  const toBytes =\n    CURVE.toBytes ||\n    ((_c: ProjConstructor<T>, point: ProjPointType<T>, _isCompressed: boolean) => {\n      const a = point.toAffine();\n      return concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n  const fromBytes =\n    CURVE.fromBytes ||\n    ((bytes: Uint8Array) => {\n      // const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n      const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n      const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n      return { x, y };\n    });\n\n  /**\n   * y = x + ax + b: Short weierstrass curve formula. Takes x, returns y.\n   * @returns y\n   */\n  function weierstrassEquation(x: T): T {\n    const { a, b } = CURVE;\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x + a * x + b\n  }\n\n  function isValidXY(x: T, y: T): boolean {\n    const left = Fp.sqr(y); // y\n    const right = weierstrassEquation(x); // x + ax + b\n    return Fp.eql(left, right);\n  }\n\n  // Validate whether the passed curve params are valid.\n  // Test 1: equation y = x + ax + b should work for generator point.\n  if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error('bad curve params: generator point');\n\n  // Test 2: discriminant  part should be non-zero: 4a + 27b != 0.\n  // Guarantees curve is genus-1, smooth (non-singular).\n  const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n  const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n  if (Fp.is0(Fp.add(_4a3, _27b2))) throw new Error('bad curve params: a or b');\n\n  // Valid group elements reside in range 1..n-1\n  function isWithinCurveOrder(num: bigint): boolean {\n    return inRange(num, _1n, CURVE.n);\n  }\n  // Validates if priv key is valid and converts it to bigint.\n  // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n  function normPrivateKeyToScalar(key: PrivKey): bigint {\n    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n    if (lengths && typeof key !== 'bigint') {\n      if (isBytes(key)) key = bytesToHex(key);\n      // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n      if (typeof key !== 'string' || !lengths.includes(key.length))\n        throw new Error('invalid private key');\n      key = key.padStart(nByteLength * 2, '0');\n    }\n    let num: bigint;\n    try {\n      num =\n        typeof key === 'bigint'\n          ? key\n          : bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n    } catch (error) {\n      throw new Error(\n        'invalid private key, expected hex or ' + nByteLength + ' bytes, got ' + typeof key\n      );\n    }\n    if (wrapPrivateKey) num = mod(num, N); // disabled by default, enabled for BLS\n    aInRange('private key', num, _1n, N); // num in range [1..N-1]\n    return num;\n  }\n\n  function aprjpoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n  }\n\n  // Memoized toAffine / validity check. They are heavy. Points are immutable.\n\n  // Converts Projective point to affine (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  // (X, Y, Z)  (x=X/Z, y=Y/Z)\n  const toAffineMemo = memoized((p: Point, iz?: T): AffinePoint<T> => {\n    const { px: x, py: y, pz: z } = p;\n    // Fast-path for normalized points\n    if (Fp.eql(z, Fp.ONE)) return { x, y };\n    const is0 = p.is0();\n    // If invZ was 0, we return zero point. However we still want to execute\n    // all operations, so we replace invZ with a random number, 1.\n    if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n    const ax = Fp.mul(x, iz);\n    const ay = Fp.mul(y, iz);\n    const zz = Fp.mul(z, iz);\n    if (is0) return { x: Fp.ZERO, y: Fp.ZERO };\n    if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n    return { x: ax, y: ay };\n  });\n  // NOTE: on exception this will crash 'cached' and no value will be set.\n  // Otherwise true will be return\n  const assertValidMemo = memoized((p: Point) => {\n    if (p.is0()) {\n      // (0, 1, 0) aka ZERO is invalid in most contexts.\n      // In BLS, ZERO can be serialized, so we allow it.\n      // (0, 0, 0) is invalid representation of ZERO.\n      if (CURVE.allowInfinityPoint && !Fp.is0(p.py)) return;\n      throw new Error('bad point: ZERO');\n    }\n    // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n    const { x, y } = p.toAffine();\n    // Check if x, y are valid field elements\n    if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');\n    if (!isValidXY(x, y)) throw new Error('bad point: equation left != right');\n    if (!p.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    return true;\n  });\n\n  /**\n   * Projective Point works in 3d / projective (homogeneous) coordinates: (X, Y, Z)  (x=X/Z, y=Y/Z)\n   * Default Point works in 2d / affine coordinates: (x, y)\n   * We're doing calculations in projective, because its operations don't require costly inversion.\n   */\n  class Point implements ProjPointType<T> {\n    // base / generator point\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    static readonly ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    readonly px: T;\n    readonly py: T;\n    readonly pz: T;\n\n    constructor(px: T, py: T, pz: T) {\n      if (px == null || !Fp.isValid(px)) throw new Error('x required');\n      if (py == null || !Fp.isValid(py) || Fp.is0(py)) throw new Error('y required');\n      if (pz == null || !Fp.isValid(pz)) throw new Error('z required');\n      this.px = px;\n      this.py = py;\n      this.pz = pz;\n      Object.freeze(this);\n    }\n\n    // Does not validate if the point is on-curve.\n    // Use fromHex instead, or call assertValidity() later.\n    static fromAffine(p: AffinePoint<T>): Point {\n      const { x, y } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n      const is0 = (i: T) => Fp.eql(i, Fp.ZERO);\n      // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n      if (is0(x) && is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n\n    get x(): T {\n      return this.toAffine().x;\n    }\n    get y(): T {\n      return this.toAffine().y;\n    }\n\n    /**\n     * Takes a bunch of Projective Points but executes only one\n     * inversion on all of them. Inversion is very slow operation,\n     * so this improves performance massively.\n     * Optimization: converts a list of projective points to a list of identical points with Z=1.\n     */\n    static normalizeZ(points: Point[]): Point[] {\n      const toInv = FpInvertBatch(\n        Fp,\n        points.map((p) => p.pz)\n      );\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n\n    /**\n     * Converts hash string or Uint8Array to Point.\n     * @param hex short/long ECDSA hex\n     */\n    static fromHex(hex: Hex): Point {\n      const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n      P.assertValidity();\n      return P;\n    }\n\n    // Multiplies generator point by privateKey.\n    static fromPrivateKey(privateKey: PrivKey) {\n      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n    }\n\n    // Multiscalar Multiplication\n    static msm(points: Point[], scalars: bigint[]): Point {\n      return pippenger(Point, Fn, points, scalars);\n    }\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      wnaf.setWindowSize(this, windowSize);\n    }\n\n    // A point on curve is valid if it conforms to equation.\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    hasEvenY(): boolean {\n      const { y } = this.toAffine();\n      if (Fp.isOdd) return !Fp.isOdd(y);\n      throw new Error(\"Field doesn't support isOdd\");\n    }\n\n    /**\n     * Compare one point to another.\n     */\n    equals(other: Point): boolean {\n      aprjpoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n\n    /**\n     * Flips point to one corresponding to (x, -y) in Affine coordinates.\n     */\n    negate(): Point {\n      return new Point(this.px, Fp.neg(this.py), this.pz);\n    }\n\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const { a, b } = CURVE;\n      const b3 = Fp.mul(b, _3n);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      let t0 = Fp.mul(X1, X1); // step 1\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    }\n\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(other: Point): Point {\n      aprjpoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, _3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n      return new Point(X3, Y3, Z3);\n    }\n\n    subtract(other: Point) {\n      return this.add(other.negate());\n    }\n\n    is0() {\n      return this.equals(Point.ZERO);\n    }\n\n    private wNAF(n: bigint): { p: Point; f: Point } {\n      return wnaf.wNAFCached(this, n, Point.normalizeZ);\n    }\n\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed private key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(sc: bigint): Point {\n      const { endo, n: N } = CURVE;\n      aInRange('scalar', sc, _0n, N);\n      const I = Point.ZERO;\n      if (sc === _0n) return I;\n      if (this.is0() || sc === _1n) return this;\n\n      // Case a: no endomorphism. Case b: has precomputes.\n      if (!endo || wnaf.hasPrecomputes(this))\n        return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n\n      // Case c: endomorphism\n      /** See docs for {@link EndomorphismOpts} */\n      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n      let k1p = I;\n      let k2p = I;\n      let d: Point = this;\n      while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n) k1p = k1p.add(d);\n        if (k2 & _1n) k2p = k2p.add(d);\n        d = d.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n      }\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n      return k1p.add(k2p);\n    }\n\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(scalar: bigint): Point {\n      const { endo, n: N } = CURVE;\n      aInRange('scalar', scalar, _1n, N);\n      let point: Point, fake: Point; // Fake point is used to const-time mult\n      /** See docs for {@link EndomorphismOpts} */\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n        let { p: k1p, f: f1p } = this.wNAF(k1);\n        let { p: k2p, f: f2p } = this.wNAF(k2);\n        k1p = wnaf.constTimeNegate(k1neg, k1p);\n        k2p = wnaf.constTimeNegate(k2neg, k2p);\n        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n        point = k1p.add(k2p);\n        fake = f1p.add(f2p);\n      } else {\n        const { p, f } = this.wNAF(scalar);\n        point = p;\n        fake = f;\n      }\n      // Normalize `z` for both points, but return only real one\n      return Point.normalizeZ([point, fake])[0];\n    }\n\n    /**\n     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n     * Not using Strauss-Shamir trick: precomputation tables are faster.\n     * The trick could be useful if both P and Q are not G (not in our case).\n     * @returns non-zero affine point\n     */\n    multiplyAndAddUnsafe(Q: Point, a: bigint, b: bigint): Point | undefined {\n      const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n      const mul = (\n        P: Point,\n        a: bigint // Select faster multiply() method\n      ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n      const sum = mul(this, a).add(mul(Q, b));\n      return sum.is0() ? undefined : sum;\n    }\n\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z)  (x=x/z, y=y/z)\n    toAffine(iz?: T): AffinePoint<T> {\n      return toAffineMemo(this, iz);\n    }\n    isTorsionFree(): boolean {\n      const { h: cofactor, isTorsionFree } = CURVE;\n      if (cofactor === _1n) return true; // No subgroups, always torsion-free\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n    }\n    clearCofactor(): Point {\n      const { h: cofactor, clearCofactor } = CURVE;\n      if (cofactor === _1n) return this; // Fast-path\n      if (clearCofactor) return clearCofactor(Point, this) as Point;\n      return this.multiplyUnsafe(CURVE.h);\n    }\n\n    toRawBytes(isCompressed = true): Uint8Array {\n      abool('isCompressed', isCompressed);\n      this.assertValidity();\n      return toBytes(Point, this, isCompressed);\n    }\n\n    toHex(isCompressed = true): string {\n      abool('isCompressed', isCompressed);\n      return bytesToHex(this.toRawBytes(isCompressed));\n    }\n  }\n  const { endo, nBitLength } = CURVE;\n  const wnaf = wNAF(Point, endo ? Math.ceil(nBitLength / 2) : nBitLength);\n  return {\n    CURVE,\n    ProjectivePoint: Point as ProjConstructor<T>,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder,\n  };\n}\n\n// Instance\nexport interface SignatureType {\n  readonly r: bigint;\n  readonly s: bigint;\n  readonly recovery?: number;\n  assertValidity(): void;\n  addRecoveryBit(recovery: number): RecoveredSignatureType;\n  hasHighS(): boolean;\n  normalizeS(): SignatureType;\n  recoverPublicKey(msgHash: Hex): ProjPointType<bigint>;\n  toCompactRawBytes(): Uint8Array;\n  toCompactHex(): string;\n  toDERRawBytes(isCompressed?: boolean): Uint8Array;\n  toDERHex(isCompressed?: boolean): string;\n}\nexport type RecoveredSignatureType = SignatureType & {\n  readonly recovery: number;\n};\n// Static methods\nexport type SignatureConstructor = {\n  new (r: bigint, s: bigint): SignatureType;\n  fromCompact(hex: Hex): SignatureType;\n  fromDER(hex: Hex): SignatureType;\n};\ntype SignatureLike = { r: bigint; s: bigint };\n\nexport type PubKey = Hex | ProjPointType<bigint>;\n\nexport type CurveType = BasicWCurve<bigint> & {\n  hash: CHash; // CHash not FHash because we need outputLen for DRBG\n  hmac: HmacFnSync;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n  lowS?: boolean;\n  bits2int?: (bytes: Uint8Array) => bigint;\n  bits2int_modN?: (bytes: Uint8Array) => bigint;\n};\n\nfunction validateOpts(\n  curve: CurveType\n): Readonly<CurveType & { nByteLength: number; nBitLength: number }> {\n  const opts = validateBasic(curve);\n  validateObject(\n    opts,\n    {\n      hash: 'hash',\n      hmac: 'function',\n      randomBytes: 'function',\n    },\n    {\n      bits2int: 'function',\n      bits2int_modN: 'function',\n      lowS: 'boolean',\n    }\n  );\n  return Object.freeze({ lowS: true, ...opts } as const);\n}\n\nexport type CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: PrivKey, isCompressed?: boolean) => Uint8Array;\n  getSharedSecret: (privateA: PrivKey, publicB: Hex, isCompressed?: boolean) => Uint8Array;\n  sign: (msgHash: Hex, privKey: PrivKey, opts?: SignOpts) => RecoveredSignatureType;\n  verify: (signature: Hex | SignatureLike, msgHash: Hex, publicKey: Hex, opts?: VerOpts) => boolean;\n  ProjectivePoint: ProjConstructor<bigint>;\n  Signature: SignatureConstructor;\n  utils: {\n    normPrivateKeyToScalar: (key: PrivKey) => bigint;\n    isValidPrivateKey(privateKey: PrivKey): boolean;\n    randomPrivateKey: () => Uint8Array;\n    precompute: (windowSize?: number, point?: ProjPointType<bigint>) => ProjPointType<bigint>;\n  };\n};\n\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */\nexport function weierstrass(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\n  const { Fp, n: CURVE_ORDER, nByteLength, nBitLength } = CURVE;\n  const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n  const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n\n  function modN(a: bigint) {\n    return mod(a, CURVE_ORDER);\n  }\n  function invN(a: bigint) {\n    return invert(a, CURVE_ORDER);\n  }\n\n  const {\n    ProjectivePoint: Point,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder,\n  } = weierstrassPoints({\n    ...CURVE,\n    toBytes(_c, point, isCompressed: boolean): Uint8Array {\n      const a = point.toAffine();\n      const x = Fp.toBytes(a.x);\n      const cat = concatBytes;\n      abool('isCompressed', isCompressed);\n      if (isCompressed) {\n        return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n      } else {\n        return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n      }\n    },\n    fromBytes(bytes: Uint8Array) {\n      const len = bytes.length;\n      const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // this.assertValidity() is done inside of fromHex\n      if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n        const x = bytesToNumberBE(tail);\n        if (!inRange(x, _1n, Fp.ORDER)) throw new Error('Point is not on curve');\n        const y2 = weierstrassEquation(x); // y = x + ax + b\n        let y: bigint;\n        try {\n          y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n        } catch (sqrtError) {\n          const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n          throw new Error('Point is not on curve' + suffix);\n        }\n        const isYOdd = (y & _1n) === _1n;\n        // ECDSA\n        const isHeadOdd = (head & 1) === 1;\n        if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n        return { x, y };\n      } else if (len === uncompressedLen && head === 0x04) {\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return { x, y };\n      } else {\n        const cl = compressedLen;\n        const ul = uncompressedLen;\n        throw new Error(\n          'invalid Point, expected length of ' + cl + ', or uncompressed ' + ul + ', got ' + len\n        );\n      }\n    },\n  });\n\n  function isBiggerThanHalfOrder(number: bigint) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n\n  function normalizeS(s: bigint) {\n    return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n  }\n  // slice bytes num\n  const slcNum = (b: Uint8Array, from: number, to: number) => bytesToNumberBE(b.slice(from, to));\n\n  /**\n   * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n   */\n  class Signature implements SignatureType {\n    readonly r: bigint;\n    readonly s: bigint;\n    readonly recovery?: number;\n    constructor(r: bigint, s: bigint, recovery?: number) {\n      aInRange('r', r, _1n, CURVE_ORDER); // r in [1..N]\n      aInRange('s', s, _1n, CURVE_ORDER); // s in [1..N]\n      this.r = r;\n      this.s = s;\n      if (recovery != null) this.recovery = recovery;\n      Object.freeze(this);\n    }\n\n    // pair (bytes of r, bytes of s)\n    static fromCompact(hex: Hex) {\n      const l = nByteLength;\n      hex = ensureBytes('compactSignature', hex, l * 2);\n      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n    }\n\n    // DER encoded ECDSA signature\n    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n    static fromDER(hex: Hex) {\n      const { r, s } = DER.toSig(ensureBytes('DER', hex));\n      return new Signature(r, s);\n    }\n\n    /**\n     * @todo remove\n     * @deprecated\n     */\n    assertValidity(): void {}\n\n    addRecoveryBit(recovery: number): RecoveredSignature {\n      return new Signature(this.r, this.s, recovery) as RecoveredSignature;\n    }\n\n    recoverPublicKey(msgHash: Hex): typeof Point.BASE {\n      const { r, s, recovery: rec } = this;\n      const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\n      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n      if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');\n      const prefix = (rec & 1) === 0 ? '02' : '03';\n      const R = Point.fromHex(prefix + numToSizedHex(radj, Fp.BYTES));\n      const ir = invN(radj); // r^-1\n      const u1 = modN(-h * ir); // -hr^-1\n      const u2 = modN(s * ir); // sr^-1\n      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n      if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n      Q.assertValidity();\n      return Q;\n    }\n\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS(): boolean {\n      return isBiggerThanHalfOrder(this.s);\n    }\n\n    normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n    }\n\n    // DER-encoded\n    toDERRawBytes() {\n      return hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n      return DER.hexFromSig(this);\n    }\n\n    // padded bytes of r, then padded bytes of s\n    toCompactRawBytes() {\n      return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n      const l = nByteLength;\n      return numToSizedHex(this.r, l) + numToSizedHex(this.s, l);\n    }\n  }\n  type RecoveredSignature = Signature & { recovery: number };\n\n  const utils = {\n    isValidPrivateKey(privateKey: PrivKey) {\n      try {\n        normPrivateKeyToScalar(privateKey);\n        return true;\n      } catch (error) {\n        return false;\n      }\n    },\n    normPrivateKeyToScalar: normPrivateKeyToScalar,\n\n    /**\n     * Produces cryptographically secure private key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */\n    randomPrivateKey: (): Uint8Array => {\n      const length = getMinHashLength(CURVE.n);\n      return mapHashToField(CURVE.randomBytes(length), CURVE.n);\n    },\n\n    /**\n     * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n     * Allows to massively speed-up `point.multiply(scalar)`.\n     * @returns cached point\n     * @example\n     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n     * fast.multiply(privKey); // much faster ECDH now\n     */\n    precompute(windowSize = 8, point = Point.BASE): typeof Point.BASE {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n      return point;\n    },\n  };\n\n  /**\n   * Computes public key for a private key. Checks for validity of the private key.\n   * @param privateKey private key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\n   */\n  function getPublicKey(privateKey: PrivKey, isCompressed = true): Uint8Array {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n  }\n\n  /**\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n   */\n  function isProbPub(item: PrivKey | PubKey): boolean | undefined {\n    if (typeof item === 'bigint') return false;\n    if (item instanceof Point) return true;\n    const arr = ensureBytes('key', item);\n    const len = arr.length;\n    const fpl = Fp.BYTES;\n    const compLen = fpl + 1; // e.g. 33 for 32\n    const uncompLen = 2 * fpl + 1; // e.g. 65 for 32\n    if (CURVE.allowedPrivateKeyLengths || nByteLength === compLen) {\n      return undefined;\n    } else {\n      return len === compLen || len === uncompLen;\n    }\n  }\n\n  /**\n   * ECDH (Elliptic Curve Diffie Hellman).\n   * Computes shared public key from private key and public key.\n   * Checks: 1) private key validity 2) shared key is on-curve.\n   * Does NOT hash the result.\n   * @param privateA private key\n   * @param publicB different public key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns shared public key\n   */\n  function getSharedSecret(privateA: PrivKey, publicB: Hex, isCompressed = true): Uint8Array {\n    if (isProbPub(privateA) === true) throw new Error('first arg must be private key');\n    if (isProbPub(publicB) === false) throw new Error('second arg must be public key');\n    const b = Point.fromHex(publicB); // check for being on-curve\n    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n  }\n\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n  const bits2int =\n    CURVE.bits2int ||\n    function (bytes: Uint8Array): bigint {\n      // Our custom check \"just in case\", for protection against DoS\n      if (bytes.length > 8192) throw new Error('input is too large');\n      // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n      // for some cases, since bytes.length * 8 is not actual bitLength.\n      const num = bytesToNumberBE(bytes); // check for == u8 done here\n      const delta = bytes.length * 8 - nBitLength; // truncate to nBitLength leftmost bits\n      return delta > 0 ? num >> BigInt(delta) : num;\n    };\n  const bits2int_modN =\n    CURVE.bits2int_modN ||\n    function (bytes: Uint8Array): bigint {\n      return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n  // NOTE: pads output with zero as per spec\n  const ORDER_MASK = bitMask(nBitLength);\n  /**\n   * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n   */\n  function int2octets(num: bigint): Uint8Array {\n    aInRange('num < 2^' + nBitLength, num, _0n, ORDER_MASK);\n    // works with order, can have different size than numToField!\n    return numberToBytesBE(num, nByteLength);\n  }\n\n  // Steps A, D of RFC6979 3.2\n  // Creates RFC6979 seed; converts msg/privKey to numbers.\n  // Used only in sign, not in verify.\n  // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n  // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n  function prepSig(msgHash: Hex, privateKey: PrivKey, opts = defaultSigOpts) {\n    if (['recovered', 'canonical'].some((k) => k in opts))\n      throw new Error('sign() legacy options not supported');\n    const { hash, randomBytes } = CURVE;\n    let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n    if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n    msgHash = ensureBytes('msgHash', msgHash);\n    validateSigVerOpts(opts);\n    if (prehash) msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n\n    // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n    const h1int = bits2int_modN(msgHash);\n    const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n    const seedArgs = [int2octets(d), int2octets(h1int)];\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\n    if (ent != null && ent !== false) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n      seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n    }\n    const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n    function k2sig(kBytes: Uint8Array): RecoveredSignature | undefined {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n      if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n      const ik = invN(k); // k^-1 mod n\n      const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n      const r = modN(q.x); // r = q.x mod n\n      if (r === _0n) return;\n      // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n      // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n      // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n      const s = modN(ik * modN(m + r * d)); // Not using blinding here\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n      let normS = s;\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = normalizeS(s); // if lowS was passed, ensure s is always\n        recovery ^= 1; // // in the bottom half of N\n      }\n      return new Signature(r, normS, recovery) as RecoveredSignature; // use normS, not s\n    }\n    return { seed, k2sig };\n  }\n  const defaultSigOpts: SignOpts = { lowS: CURVE.lowS, prehash: false };\n  const defaultVerOpts: VerOpts = { lowS: CURVE.lowS, prehash: false };\n\n  /**\n   * Signs message hash with a private key.\n   * ```\n   * sign(m, d, k) where\n   *   (x, y) = G  k\n   *   r = x mod n\n   *   s = (m + dr)/k mod n\n   * ```\n   * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n   * @param privKey private key\n   * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n   * @returns signature with recovery param\n   */\n  function sign(msgHash: Hex, privKey: PrivKey, opts = defaultSigOpts): RecoveredSignature {\n    const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n    const C = CURVE;\n    const drbg = createHmacDrbg<RecoveredSignature>(C.hash.outputLen, C.nByteLength, C.hmac);\n    return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n  }\n\n  // Enable precomputes. Slows down first publicKey computation by 20ms.\n  Point.BASE._setWindowSize(8);\n  // utils.precompute(8, ProjectivePoint.BASE)\n\n  /**\n   * Verifies a signature against message hash and public key.\n   * Rejects lowS signatures by default: to override,\n   * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n   *\n   * ```\n   * verify(r, s, h, P) where\n   *   U1 = hs^-1 mod n\n   *   U2 = rs^-1 mod n\n   *   R = U1G - U2P\n   *   mod(R.x, n) == r\n   * ```\n   */\n  function verify(\n    signature: Hex | SignatureLike,\n    msgHash: Hex,\n    publicKey: Hex,\n    opts = defaultVerOpts\n  ): boolean {\n    const sg = signature;\n    msgHash = ensureBytes('msgHash', msgHash);\n    publicKey = ensureBytes('publicKey', publicKey);\n    const { lowS, prehash, format } = opts;\n\n    // Verify opts, deduce signature format\n    validateSigVerOpts(opts);\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n    if (format !== undefined && format !== 'compact' && format !== 'der')\n      throw new Error('format must be compact or der');\n    const isHex = typeof sg === 'string' || isBytes(sg);\n    const isObj =\n      !isHex &&\n      !format &&\n      typeof sg === 'object' &&\n      sg !== null &&\n      typeof sg.r === 'bigint' &&\n      typeof sg.s === 'bigint';\n    if (!isHex && !isObj)\n      throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n\n    let _sig: Signature | undefined = undefined;\n    let P: ProjPointType<bigint>;\n    try {\n      if (isObj) _sig = new Signature(sg.r, sg.s);\n      if (isHex) {\n        // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n        // Since DER can also be 2*nByteLength bytes, we check for it first.\n        try {\n          if (format !== 'compact') _sig = Signature.fromDER(sg);\n        } catch (derError) {\n          if (!(derError instanceof DER.Err)) throw derError;\n        }\n        if (!_sig && format !== 'der') _sig = Signature.fromCompact(sg);\n      }\n      P = Point.fromHex(publicKey);\n    } catch (error) {\n      return false;\n    }\n    if (!_sig) return false;\n    if (lowS && _sig.hasHighS()) return false;\n    if (prehash) msgHash = CURVE.hash(msgHash);\n    const { r, s } = _sig;\n    const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n    const is = invN(s); // s^-1\n    const u1 = modN(h * is); // u1 = hs^-1 mod n\n    const u2 = modN(r * is); // u2 = rs^-1 mod n\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\n    if (!R) return false;\n    const v = modN(R.x);\n    return v === r;\n  }\n  return {\n    CURVE,\n    getPublicKey,\n    getSharedSecret,\n    sign,\n    verify,\n    ProjectivePoint: Point,\n    Signature,\n    utils,\n  };\n}\n\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio<T>(\n  Fp: IField<T>,\n  Z: T\n): (u: T, v: T) => { isValid: boolean; value: T } {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = _0n;\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n  // 2n ** c1 == 2n << (c1-1)\n  const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n  let sqrtRatio = (u: T, v: T): { isValid: boolean; value: T } => {\n    let tv1 = c6; // 1. tv1 = c6\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n    for (let i = c1; i > _1n; i--) {\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\n      tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n    return { isValid: isQR, value: tv3 };\n  };\n  if (Fp.ORDER % _4n === _3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n    sqrtRatio = (u: T, v: T) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n      return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  }\n  // No curves uses that\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n  return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU<T>(\n  Fp: IField<T>,\n  opts: {\n    A: T;\n    B: T;\n    Z: T;\n  }\n): (u: T) => { x: T; y: T } {\n  validateField(Fp);\n  if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n    throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n  if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');\n  // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n  return (u: T): { x: T; y: T } => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n    tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n    tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n    tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n    tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n    const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n    y = Fp.mul(y, value); // 20.   y = y * y1\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n    const e1 = Fp.isOdd!(u) === Fp.isOdd!(y); // 23.  e1 = sgn0(u) == sgn0(y)\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n    const tv4_inv = FpInvertBatch(Fp, [tv4], true)[0];\n    x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n    return { x, y };\n  };\n}\n","import type { Account } from '../../accounts/types.js'\nimport type {\n  SignTransactionErrorType as SignTransactionErrorType_,\n  SignTransactionReturnType as SignTransactionReturnType_,\n} from '../../actions/wallet/signTransaction.js'\nimport { signTransaction as signTransaction_ } from '../../actions/wallet/signTransaction.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  ExtractChainFormatterParameters,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport type { ChainEIP712 } from '../types/chain.js'\nimport type { TransactionRequestEIP712 } from '../types/transaction.js'\nimport { isEIP712Transaction } from '../utils/isEip712Transaction.js'\nimport { signEip712Transaction } from './signEip712Transaction.js'\n\ntype FormattedTransactionRequest<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n> = ExtractChainFormatterParameters<\n  chain,\n  'transactionRequest',\n  TransactionRequestEIP712\n>\n\nexport type SignTransactionParameters<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n> = UnionOmit<\n  FormattedTransactionRequest<\n    chainOverride extends ChainEIP712 ? chainOverride : chain\n  >,\n  'from'\n> &\n  GetAccountParameter<account> &\n  GetChainParameter<chain, chainOverride>\n\nexport type SignTransactionReturnType = SignTransactionReturnType_\n\nexport type SignTransactionErrorType = SignTransactionErrorType_\n\n/**\n * Signs a transaction.\n *\n * - Docs: https://viem.sh/docs/zksync/actions/signTransaction\n *\n * @param args - {@link SignTransactionParameters}\n * @returns The signed serialized transaction. {@link SignTransactionReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { zksync } from 'viem/chains'\n * import { signTransaction } from 'viem/zksync'\n *\n * const client = createWalletClient({\n *   chain: zksync,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signTransaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: 1n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync } from 'viem/chains'\n * import { signTransaction } from 'viem/zksync'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x'),\n *   chain: zksync,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signTransaction(client, {\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: 1n,\n * })\n */\nexport async function signTransaction<\n  chain extends ChainEIP712 | undefined,\n  account extends Account | undefined,\n  chainOverride extends ChainEIP712 | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  args: SignTransactionParameters<chain, account, chainOverride>,\n): Promise<SignTransactionReturnType> {\n  if (isEIP712Transaction(args)) return signEip712Transaction(client, args)\n  return await signTransaction_(client, args as any)\n}\n","import type { createSolanaRpcApi } from '@solana/rpc-api';\n\nimport { createSolanaJsonRpcIntegerOverflowError } from './rpc-integer-overflow-error';\n\n/**\n * When you create {@link Rpc} instances with custom transports but otherwise the default RPC API\n * behaviours, use this.\n *\n * @example\n * ```ts\n * const myCustomRpc = createRpc({\n *     api: createSolanaRpcApi(DEFAULT_RPC_CONFIG),\n *     transport: myCustomTransport,\n * });\n * ```\n */\nexport const DEFAULT_RPC_CONFIG: Partial<NonNullable<Parameters<typeof createSolanaRpcApi>[0]>> = {\n    defaultCommitment: 'confirmed',\n    onIntegerOverflow(request, keyPath, value) {\n        throw createSolanaJsonRpcIntegerOverflowError(request.methodName, keyPath, value);\n    },\n};\n","import type { Account } from '../../accounts/types.js'\nimport type {\n  SendTransactionErrorType as core_SendTransactionErrorType,\n  SendTransactionParameters as core_SendTransactionParameters,\n  SendTransactionReturnType as core_SendTransactionReturnType,\n  SendTransactionRequest,\n} from '../../actions/wallet/sendTransaction.js'\nimport { sendTransaction as core_sendTransaction } from '../../actions/wallet/sendTransaction.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ChainEIP712 } from '../types/chain.js'\nimport { isEIP712Transaction } from '../utils/isEip712Transaction.js'\nimport {\n  type SendEip712TransactionParameters,\n  sendEip712Transaction,\n} from './sendEip712Transaction.js'\n\nexport type SendTransactionParameters<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  request extends SendTransactionRequest<\n    chain,\n    chainOverride\n  > = SendTransactionRequest<chain, chainOverride>,\n> = core_SendTransactionParameters<chain, account, chainOverride, request>\n\nexport type SendTransactionReturnType = core_SendTransactionReturnType\n\nexport type SendTransactionErrorType = core_SendTransactionErrorType\n\n/**\n * Creates, signs, and sends a new transaction to the network.\n *\n * - Docs: https://viem.sh/docs/zksync/actions/sendTransaction\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)\n *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)\n *\n * @param client - Client to use\n * @param parameters - {@link SendTransactionParameters}\n * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link SendTransactionReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { zksync } from 'viem/chains'\n * import { sendTransaction } from 'viem/zksync'\n *\n * const client = createWalletClient({\n *   chain: zksync,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await sendTransaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync } from 'viem/chains'\n * import { sendTransaction } from 'viem/zksync'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x'),\n *   chain: zksync,\n *   transport: http(),\n * })\n * const hash = await sendTransaction(client, {\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n */\nexport async function sendTransaction<\n  chain extends ChainEIP712 | undefined,\n  account extends Account | undefined,\n  const request extends SendTransactionRequest<chain, chainOverride>,\n  chainOverride extends ChainEIP712 | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SendTransactionParameters<chain, account, chainOverride, request>,\n): Promise<SendTransactionReturnType> {\n  if (isEIP712Transaction(parameters))\n    return sendEip712Transaction(\n      client,\n      parameters as SendEip712TransactionParameters,\n    )\n  return core_sendTransaction(\n    client,\n    parameters as core_SendTransactionParameters,\n  )\n}\n","import type { createSolanaRpcSubscriptionsApi } from '@solana/rpc-subscriptions-api';\n\nimport { createSolanaJsonRpcIntegerOverflowError } from './rpc-integer-overflow-error';\n\nexport const DEFAULT_RPC_SUBSCRIPTIONS_CONFIG: Partial<\n    NonNullable<Parameters<typeof createSolanaRpcSubscriptionsApi>[0]>\n> = {\n    defaultCommitment: 'confirmed',\n    onIntegerOverflow(request, keyPath, value) {\n        throw createSolanaJsonRpcIntegerOverflowError(request.methodName, keyPath, value);\n    },\n};\n","import type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport { getChainId } from '../../actions/public/getChainId.js'\nimport type {\n  SignTransactionErrorType,\n  SignTransactionReturnType,\n} from '../../actions/wallet/signTransaction.js'\nimport { signTypedData } from '../../actions/wallet/signTypedData.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../errors/account.js'\nimport { BaseError } from '../../errors/base.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  ExtractChainFormatterParameters,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport { assertCurrentChain } from '../../utils/chain/assertCurrentChain.js'\nimport { getAction } from '../../utils/getAction.js'\nimport type { ChainEIP712 } from '../types/chain.js'\nimport type { TransactionRequestEIP712 } from '../types/transaction.js'\nimport {\n  type AssertEip712RequestParameters,\n  assertEip712Request,\n} from '../utils/assertEip712Request.js'\n\ntype FormattedTransactionRequest<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n> = ExtractChainFormatterParameters<\n  chain,\n  'transactionRequest',\n  TransactionRequestEIP712\n>\n\nexport type SignEip712TransactionParameters<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n> = UnionOmit<\n  FormattedTransactionRequest<\n    chainOverride extends ChainEIP712 ? chainOverride : chain\n  >,\n  'from'\n> &\n  GetAccountParameter<account> &\n  GetChainParameter<chain, chainOverride>\n\nexport type SignEip712TransactionReturnType = SignTransactionReturnType\n\nexport type SignEip712TransactionErrorType = SignTransactionErrorType\n\n/**\n * Signs an EIP712 transaction.\n *\n *\n * @param client - Client to use\n * @param args - {@link SignTransactionParameters}\n * @returns The signed serialized transaction. {@link SignTransactionReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { zksync } from 'viem/chains'\n * import { signEip712Transaction } from 'viem/zksync'\n *\n * const client = createWalletClient({\n *   chain: zksync,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signEip712Transaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: 1n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync } from 'viem/chains'\n * import { signEip712Transaction } from 'viem/zksync'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x'),\n *   chain: zksync,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signEip712Transaction(client, {\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: 1n,\n * })\n */\nexport async function signEip712Transaction<\n  chain extends ChainEIP712 | undefined,\n  account extends Account | undefined,\n  chainOverride extends ChainEIP712 | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  args: SignEip712TransactionParameters<chain, account, chainOverride>,\n): Promise<SignEip712TransactionReturnType> {\n  const {\n    account: account_ = client.account,\n    chain = client.chain,\n    ...transaction\n  } = args\n\n  const account = account_ ? parseAccount(account_) : client.account\n\n  if (!account)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/signTransaction',\n    })\n\n  assertEip712Request({\n    account,\n    chain,\n    ...(args as AssertEip712RequestParameters),\n  })\n\n  if (!chain?.custom?.getEip712Domain)\n    throw new BaseError('`getEip712Domain` not found on chain.')\n  if (!chain?.serializers?.transaction)\n    throw new BaseError('transaction serializer not found on chain.')\n\n  const chainId = await getAction(client, getChainId, 'getChainId')({})\n  if (chain !== null)\n    assertCurrentChain({\n      currentChainId: chainId,\n      chain: chain,\n    })\n\n  const eip712Domain = chain?.custom.getEip712Domain({\n    ...transaction,\n    chainId,\n    from: account.address,\n    type: 'eip712',\n  })\n\n  const customSignature = await signTypedData(client, {\n    ...eip712Domain,\n    account,\n  })\n\n  return chain?.serializers?.transaction(\n    {\n      chainId,\n      ...transaction,\n      customSignature,\n      type: 'eip712' as any,\n    },\n    { r: '0x0', s: '0x0', v: 0n },\n  ) as SignEip712TransactionReturnType\n}\n","import { getSymbols } from '../compat/_internal/getSymbols.mjs';\nimport { getTag } from '../compat/_internal/getTag.mjs';\nimport { uint32ArrayTag, uint16ArrayTag, uint8ClampedArrayTag, uint8ArrayTag, symbolTag, stringTag, setTag, regexpTag, objectTag, numberTag, mapTag, int32ArrayTag, int16ArrayTag, int8ArrayTag, float64ArrayTag, float32ArrayTag, dateTag, booleanTag, dataViewTag, arrayBufferTag, arrayTag, argumentsTag } from '../compat/_internal/tags.mjs';\nimport { isPrimitive } from '../predicate/isPrimitive.mjs';\nimport { isTypedArray } from '../predicate/isTypedArray.mjs';\n\nfunction cloneDeepWith(obj, cloneValue) {\n    return cloneDeepWithImpl(obj, undefined, obj, new Map(), cloneValue);\n}\nfunction cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack = new Map(), cloneValue = undefined) {\n    const cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack);\n    if (cloned != null) {\n        return cloned;\n    }\n    if (isPrimitive(valueToClone)) {\n        return valueToClone;\n    }\n    if (stack.has(valueToClone)) {\n        return stack.get(valueToClone);\n    }\n    if (Array.isArray(valueToClone)) {\n        const result = new Array(valueToClone.length);\n        stack.set(valueToClone, result);\n        for (let i = 0; i < valueToClone.length; i++) {\n            result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);\n        }\n        if (Object.hasOwn(valueToClone, 'index')) {\n            result.index = valueToClone.index;\n        }\n        if (Object.hasOwn(valueToClone, 'input')) {\n            result.input = valueToClone.input;\n        }\n        return result;\n    }\n    if (valueToClone instanceof Date) {\n        return new Date(valueToClone.getTime());\n    }\n    if (valueToClone instanceof RegExp) {\n        const result = new RegExp(valueToClone.source, valueToClone.flags);\n        result.lastIndex = valueToClone.lastIndex;\n        return result;\n    }\n    if (valueToClone instanceof Map) {\n        const result = new Map();\n        stack.set(valueToClone, result);\n        for (const [key, value] of valueToClone) {\n            result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack, cloneValue));\n        }\n        return result;\n    }\n    if (valueToClone instanceof Set) {\n        const result = new Set();\n        stack.set(valueToClone, result);\n        for (const value of valueToClone) {\n            result.add(cloneDeepWithImpl(value, undefined, objectToClone, stack, cloneValue));\n        }\n        return result;\n    }\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(valueToClone)) {\n        return valueToClone.subarray();\n    }\n    if (isTypedArray(valueToClone)) {\n        const result = new (Object.getPrototypeOf(valueToClone).constructor)(valueToClone.length);\n        stack.set(valueToClone, result);\n        for (let i = 0; i < valueToClone.length; i++) {\n            result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);\n        }\n        return result;\n    }\n    if (valueToClone instanceof ArrayBuffer ||\n        (typeof SharedArrayBuffer !== 'undefined' && valueToClone instanceof SharedArrayBuffer)) {\n        return valueToClone.slice(0);\n    }\n    if (valueToClone instanceof DataView) {\n        const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);\n        stack.set(valueToClone, result);\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    if (typeof File !== 'undefined' && valueToClone instanceof File) {\n        const result = new File([valueToClone], valueToClone.name, {\n            type: valueToClone.type,\n        });\n        stack.set(valueToClone, result);\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    if (valueToClone instanceof Blob) {\n        const result = new Blob([valueToClone], { type: valueToClone.type });\n        stack.set(valueToClone, result);\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    if (valueToClone instanceof Error) {\n        const result = new valueToClone.constructor();\n        stack.set(valueToClone, result);\n        result.message = valueToClone.message;\n        result.name = valueToClone.name;\n        result.stack = valueToClone.stack;\n        result.cause = valueToClone.cause;\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    if (typeof valueToClone === 'object' && isCloneableObject(valueToClone)) {\n        const result = Object.create(Object.getPrototypeOf(valueToClone));\n        stack.set(valueToClone, result);\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    return valueToClone;\n}\nfunction copyProperties(target, source, objectToClone = target, stack, cloneValue) {\n    const keys = [...Object.keys(source), ...getSymbols(source)];\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const descriptor = Object.getOwnPropertyDescriptor(target, key);\n        if (descriptor == null || descriptor.writable) {\n            target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue);\n        }\n    }\n}\nfunction isCloneableObject(object) {\n    switch (getTag(object)) {\n        case argumentsTag:\n        case arrayTag:\n        case arrayBufferTag:\n        case dataViewTag:\n        case booleanTag:\n        case dateTag:\n        case float32ArrayTag:\n        case float64ArrayTag:\n        case int8ArrayTag:\n        case int16ArrayTag:\n        case int32ArrayTag:\n        case mapTag:\n        case numberTag:\n        case objectTag:\n        case regexpTag:\n        case setTag:\n        case stringTag:\n        case symbolTag:\n        case uint8ArrayTag:\n        case uint8ClampedArrayTag:\n        case uint16ArrayTag:\n        case uint32ArrayTag: {\n            return true;\n        }\n        default: {\n            return false;\n        }\n    }\n}\n\nexport { cloneDeepWith, cloneDeepWithImpl, copyProperties };\n","import {\n    Callable,\n    createRpcMessage,\n    RpcRequestTransformer,\n    RpcResponse,\n    RpcResponseTransformer,\n} from '@solana/rpc-spec-types';\n\nimport type { RpcTransport } from './rpc-transport';\n\nexport type RpcApiConfig = Readonly<{\n    /**\n     * An optional function that transforms the {@link RpcRequest} before it is sent to the JSON RPC\n     * server.\n     *\n     * This is useful when the params supplied by the caller need to be transformed before\n     * forwarding the message to the server. Use cases for this include applying defaults,\n     * forwarding calls to renamed methods, and serializing complex values.\n     */\n    requestTransformer?: RpcRequestTransformer;\n    /**\n     * An optional function that transforms the {@link RpcResponse} before it is returned to the\n     * caller.\n     *\n     * Use cases for this include constructing complex data types from serialized data, and throwing\n     * exceptions.\n     */\n    responseTransformer?: RpcResponseTransformer;\n}>;\n\n/**\n * This type allows an {@link RpcApi} to describe how a particular request should be issued to the\n * JSON RPC server.\n *\n * Given a function that was called on a {@link Rpc}, this object exposes an `execute` function that\n * dictates which request will be sent, how the underlying transport will be used, and how the\n * responses will be transformed.\n *\n * This function accepts a {@link RpcTransport} and an `AbortSignal` and asynchronously returns a\n * {@link RpcResponse}. This gives us the opportunity to:\n *\n * - define the `payload` from the requested method name and parameters before passing it to the\n *   transport.\n * - call the underlying transport zero, one or multiple times depending on the use-case (e.g.\n *   caching or aggregating multiple responses).\n * - transform the response from the JSON RPC server, in case it does not match the `TResponse`\n *   specified by the {@link PendingRpcRequest | PendingRpcRequest<TResponse>} returned from that\n *   function.\n */\nexport type RpcPlan<TResponse> = {\n    execute: (\n        config: Readonly<{\n            signal?: AbortSignal;\n            transport: RpcTransport;\n        }>,\n    ) => Promise<RpcResponse<TResponse>>;\n};\n\n/**\n * For each of `TRpcMethods`, this object exposes a method with the same name that maps between its\n * input arguments and a {@link RpcPlan | RpcPlan<TResponse>} that implements the execution of a\n * JSON RPC request to fetch `TResponse`.\n */\nexport type RpcApi<TRpcMethods> = {\n    [MethodName in keyof TRpcMethods]: RpcReturnTypeMapper<TRpcMethods[MethodName]>;\n};\n\ntype RpcReturnTypeMapper<TRpcMethod> = TRpcMethod extends Callable\n    ? (...rawParams: unknown[]) => RpcPlan<ReturnType<TRpcMethod>>\n    : never;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RpcApiMethod = (...args: any) => any;\ninterface RpcApiMethods {\n    [methodName: string]: RpcApiMethod;\n}\n\n/**\n * Creates a JavaScript proxy that converts _any_ function call called on it to a {@link RpcPlan} by\n * creating an `execute` function that:\n *\n * - sets the transport payload to a JSON RPC v2 payload object with the requested `methodName` and\n *   `params` properties, optionally transformed by {@link RpcApiConfig.requestTransformer}.\n * - transforms the transport's response using the {@link RpcApiConfig.responseTransformer}\n *   function, if provided.\n *\n * @example\n * ```ts\n * // For example, given this `RpcApi`:\n * const rpcApi = createJsonRpcApi({\n *     requestTransformer: (...rawParams) => rawParams.reverse(),\n *     responseTransformer: response => response.result,\n * });\n *\n * // ...the following function call:\n * rpcApi.foo('bar', { baz: 'bat' });\n *\n * // ...will produce a `RpcPlan` that:\n * // -   Uses the following payload: { id: 1, jsonrpc: '2.0', method: 'foo', params: [{ baz: 'bat' }, 'bar'] }.\n * // -   Returns the \"result\" property of the RPC response.\n * ```\n */\nexport function createJsonRpcApi<TRpcMethods extends RpcApiMethods>(config?: RpcApiConfig): RpcApi<TRpcMethods> {\n    return new Proxy({} as RpcApi<TRpcMethods>, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get<TMethodName extends keyof RpcApi<TRpcMethods>>(\n            ...args: Parameters<NonNullable<ProxyHandler<RpcApi<TRpcMethods>>['get']>>\n        ) {\n            const [_, p] = args;\n            const methodName = p.toString() as keyof TRpcMethods as string;\n            return function (\n                ...rawParams: Parameters<\n                    TRpcMethods[TMethodName] extends CallableFunction ? TRpcMethods[TMethodName] : never\n                >\n            ): RpcPlan<ReturnType<TRpcMethods[TMethodName]>> {\n                const rawRequest = Object.freeze({ methodName, params: rawParams });\n                const request = config?.requestTransformer ? config?.requestTransformer(rawRequest) : rawRequest;\n                return Object.freeze(<RpcPlan<ReturnType<TRpcMethods[TMethodName]>>>{\n                    execute: async ({ signal, transport }) => {\n                        const payload = createRpcMessage(request);\n                        const response = await transport({ payload, signal });\n                        if (!config?.responseTransformer) {\n                            return response;\n                        }\n                        return config.responseTransformer(response, request);\n                    },\n                });\n            };\n        },\n    });\n}\n","import type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport { getChainId } from '../../actions/public/getChainId.js'\nimport { prepareTransactionRequest } from '../../actions/wallet/prepareTransactionRequest.js'\nimport { sendRawTransaction } from '../../actions/wallet/sendRawTransaction.js'\nimport type {\n  SendTransactionErrorType,\n  SendTransactionParameters,\n  SendTransactionRequest,\n  SendTransactionReturnType,\n} from '../../actions/wallet/sendTransaction.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../errors/account.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { Chain } from '../../types/chain.js'\nimport { assertCurrentChain } from '../../utils/chain/assertCurrentChain.js'\nimport {\n  type GetTransactionErrorParameters,\n  getTransactionError,\n} from '../../utils/errors/getTransactionError.js'\nimport { getAction } from '../../utils/getAction.js'\nimport type { ChainEIP712 } from '../types/chain.js'\nimport { assertEip712Request } from '../utils/assertEip712Request.js'\nimport { signTransaction } from './signTransaction.js'\n\nexport type SendEip712TransactionParameters<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  request extends SendTransactionRequest<\n    chain,\n    chainOverride\n  > = SendTransactionRequest<chain, chainOverride>,\n> = SendTransactionParameters<chain, account, chainOverride, request>\n\nexport type SendEip712TransactionReturnType = SendTransactionReturnType\n\nexport type SendEip712TransactionErrorType = SendTransactionErrorType\n\n/**\n * Creates, signs, and sends a new EIP712 transaction to the network.\n *\n * @param client - Client to use\n * @param parameters - {@link SendEip712TransactionParameters}\n * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link SendTransactionReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { zksync } from 'viem/chains'\n * import { sendEip712Transaction } from 'viem/zksync'\n *\n * const client = createWalletClient({\n *   chain: zksync,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await sendEip712Transaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync } from 'viem/chains'\n * import { sendEip712Transaction } from 'viem/zksync'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x'),\n *   chain: zksync,\n *   transport: http(),\n * })\n *\n * const hash = await sendEip712Transaction(client, {\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n */\nexport async function sendEip712Transaction<\n  chain extends ChainEIP712 | undefined,\n  account extends Account | undefined,\n  const request extends SendTransactionRequest<chain, chainOverride>,\n  chainOverride extends ChainEIP712 | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SendEip712TransactionParameters<\n    chain,\n    account,\n    chainOverride,\n    request\n  >,\n): Promise<SendEip712TransactionReturnType> {\n  const { account: account_ = client.account, chain = client.chain } =\n    parameters\n\n  const account = account_ ? parseAccount(account_) : client.account\n\n  if (!account)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/sendTransaction',\n    })\n\n  try {\n    assertEip712Request(parameters)\n\n    // Prepare the request for signing (assign appropriate fees, etc.)\n    const request = await prepareTransactionRequest(client, {\n      ...parameters,\n      nonceManager: account.nonceManager,\n      parameters: ['gas', 'nonce', 'fees'],\n    } as any)\n\n    let chainId: number | undefined\n    if (chain !== null) {\n      chainId = await getAction(client, getChainId, 'getChainId')({})\n      assertCurrentChain({\n        currentChainId: chainId,\n        chain,\n      })\n    }\n\n    const serializedTransaction = await signTransaction(client, {\n      ...request,\n      chainId,\n    } as any)\n\n    return await getAction(\n      client,\n      sendRawTransaction,\n      'sendRawTransaction',\n    )({\n      serializedTransaction,\n    })\n  } catch (err) {\n    throw getTransactionError(err as BaseError, {\n      ...(parameters as GetTransactionErrorParameters),\n      account,\n      chain: chain as Chain,\n    })\n  }\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getBooleanDecoder,\n    getBooleanEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n    getU128Decoder,\n    getU128Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport {\n    Blockhash,\n    getBlockhashDecoder,\n    getBlockhashEncoder,\n    getDefaultLamportsDecoder,\n    getDefaultLamportsEncoder,\n    Lamports,\n} from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_EPOCH_REWARDS_ADDRESS } from './sysvar';\n\ntype SysvarEpochRewardsSize = 81;\n\n/**\n * Tracks whether the rewards period (including calculation and distribution) is in progress, as\n * well as the details needed to resume distribution when starting from a snapshot during the\n * rewards period.\n *\n * The sysvar is repopulated at the start of the first block of each epoch. Therefore, the sysvar\n * contains data about the current epoch until a new epoch begins.\n */\nexport type SysvarEpochRewards = Readonly<{\n    /** Whether the rewards period (including calculation and distribution) is active */\n    active: boolean;\n    /** The rewards currently distributed for the current epoch, in {@link Lamports} */\n    distributedRewards: Lamports;\n    /** The starting block height of the rewards distribution in the current epoch */\n    distributionStartingBlockHeight: bigint;\n    /**\n     * Number of partitions in the rewards distribution in the current epoch, used to generate an\n     * `EpochRewardsHasher`\n     */\n    numPartitions: bigint;\n    /**\n     * The {@link Blockhash} of the parent block of the first block in the epoch, used to seed an\n     * `EpochRewardsHasher`\n     */\n    parentBlockhash: Blockhash;\n    /**\n     * The total rewards points calculated for the current epoch, where points equals the sum of\n     * (delegated stake * credits observed) for all  delegations\n     */\n    totalPoints: bigint;\n    /** The total rewards for the current epoch, in {@link Lamports} */\n    totalRewards: Lamports;\n}>;\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarEpochRewards} to a byte array\n * representing the `EpochRewards` sysvar's account data.\n */\nexport function getSysvarEpochRewardsEncoder(): FixedSizeEncoder<SysvarEpochRewards, SysvarEpochRewardsSize> {\n    return getStructEncoder([\n        ['distributionStartingBlockHeight', getU64Encoder()],\n        ['numPartitions', getU64Encoder()],\n        ['parentBlockhash', getBlockhashEncoder()],\n        ['totalPoints', getU128Encoder()],\n        ['totalRewards', getDefaultLamportsEncoder()],\n        ['distributedRewards', getDefaultLamportsEncoder()],\n        ['active', getBooleanEncoder()],\n    ]) as FixedSizeEncoder<SysvarEpochRewards, SysvarEpochRewardsSize>;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `EpochRewards`\n * sysvar's account data to a {@link SysvarEpochRewards}.\n */\nexport function getSysvarEpochRewardsDecoder(): FixedSizeDecoder<SysvarEpochRewards, SysvarEpochRewardsSize> {\n    return getStructDecoder([\n        ['distributionStartingBlockHeight', getU64Decoder()],\n        ['numPartitions', getU64Decoder()],\n        ['parentBlockhash', getBlockhashDecoder()],\n        ['totalPoints', getU128Decoder()],\n        ['totalRewards', getDefaultLamportsDecoder()],\n        ['distributedRewards', getDefaultLamportsDecoder()],\n        ['active', getBooleanDecoder()],\n    ]) as FixedSizeDecoder<SysvarEpochRewards, SysvarEpochRewardsSize>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarEpochRewards}\n *\n * @see {@link getSysvarEpochRewardsDecoder}\n * @see {@link getSysvarEpochRewardsEncoder}\n */\nexport function getSysvarEpochRewardsCodec(): FixedSizeCodec<\n    SysvarEpochRewards,\n    SysvarEpochRewards,\n    SysvarEpochRewardsSize\n> {\n    return combineCodec(getSysvarEpochRewardsEncoder(), getSysvarEpochRewardsDecoder());\n}\n\n/**\n * Fetch the `EpochRewards` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarEpochRewards(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarEpochRewards> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_EPOCH_REWARDS_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarEpochRewardsDecoder());\n    return decoded.data;\n}\n","import { SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, SolanaError } from '@solana/errors';\nimport type { RpcTransport } from '@solana/rpc-spec';\nimport type { RpcResponse } from '@solana/rpc-spec-types';\nimport type Dispatcher from 'undici-types/dispatcher';\n\nimport { HttpTransportConfig as Config } from './http-transport-config';\nimport { assertIsAllowedHttpRequestHeaders, normalizeHeaders } from './http-transport-headers';\n\nlet didWarnDispatcherWasSuppliedInNonNodeEnvironment = false;\nfunction warnDispatcherWasSuppliedInNonNodeEnvironment() {\n    if (didWarnDispatcherWasSuppliedInNonNodeEnvironment) {\n        return;\n    }\n    didWarnDispatcherWasSuppliedInNonNodeEnvironment = true;\n    console.warn(\n        'You have supplied a `Dispatcher` to `createHttpTransport()`. It has been ignored ' +\n            'because Undici dispatchers only work in Node environments. To eliminate this ' +\n            'warning, omit the `dispatcher_NODE_ONLY` property from your config when running in ' +\n            'a non-Node environment.',\n    );\n}\n\n/**\n * Creates a function you can use to make `POST` requests with headers suitable for sending JSON\n * data to a server.\n *\n * @example\n * ```ts\n * import { createHttpTransport } from '@solana/rpc-transport-http';\n *\n * const transport = createHttpTransport({ url: 'https://api.mainnet-beta.solana.com' });\n * const response = await transport({\n *     payload: { id: 1, jsonrpc: '2.0', method: 'getSlot' },\n * });\n * const data = await response.json();\n * ```\n */\nexport function createHttpTransport(config: Config): RpcTransport {\n    if (process.env.NODE_ENV !== \"production\" && !__NODEJS__ && 'dispatcher_NODE_ONLY' in config) {\n        warnDispatcherWasSuppliedInNonNodeEnvironment();\n    }\n    const { fromJson, headers, toJson, url } = config;\n    if (process.env.NODE_ENV !== \"production\" && headers) {\n        assertIsAllowedHttpRequestHeaders(headers);\n    }\n    let dispatcherConfig: { dispatcher: Dispatcher | undefined } | undefined;\n    if (__NODEJS__ && 'dispatcher_NODE_ONLY' in config) {\n        dispatcherConfig = { dispatcher: config.dispatcher_NODE_ONLY };\n    }\n    const customHeaders = headers && normalizeHeaders(headers);\n    return async function makeHttpRequest<TResponse>({\n        payload,\n        signal,\n    }: Parameters<RpcTransport>[0]): Promise<RpcResponse<TResponse>> {\n        const body = toJson ? toJson(payload) : JSON.stringify(payload);\n        const requestInfo = {\n            ...dispatcherConfig,\n            body,\n            headers: {\n                ...customHeaders,\n                // Keep these headers lowercase so they will override any user-supplied headers above.\n                accept: 'application/json',\n                'content-length': body.length.toString(),\n                'content-type': 'application/json; charset=utf-8',\n            },\n            method: 'POST',\n            signal,\n        };\n        const response = await fetch(url, requestInfo);\n        if (!response.ok) {\n            throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, {\n                headers: response.headers,\n                message: response.statusText,\n                statusCode: response.status,\n            });\n        }\n        if (fromJson) {\n            return fromJson(await response.text(), payload) as TResponse;\n        }\n        return await response.json();\n    };\n}\n","import { downcastNodeToNumberIfBigint } from './request-transformer-bigint-downcast-internal';\nimport { getTreeWalkerRequestTransformer } from './tree-traversal';\n\n/**\n * Creates a transformer that downcasts all `BigInt` values to `Number`.\n *\n * @example\n * ```ts\n * import { getBigIntDowncastRequestTransformer } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getBigIntDowncastRequestTransformer();\n * ```\n *\n */\nexport function getBigIntDowncastRequestTransformer() {\n    return getTreeWalkerRequestTransformer([downcastNodeToNumberIfBigint], { keyPath: [] });\n}\n","import { Network, PaymentRequirements } from \"../types\";\nimport { getUsdcChainConfigForChain } from \"../shared/evm\";\nimport { getNetworkId } from \"../shared/network\";\n\n/**\n * Default selector for payment requirements.\n * Default behavior is to select the first payment requirement that has a USDC asset.\n * If no USDC payment requirement is found, the first payment requirement is selected.\n *\n * @param paymentRequirements - The payment requirements to select from.\n * @param network - The network to check against. If not provided, the network will not be checked.\n * @param scheme - The scheme to check against. If not provided, the scheme will not be checked.\n * @returns The payment requirement that is the most appropriate for the user.\n */\nexport function selectPaymentRequirements(paymentRequirements: PaymentRequirements[], network?: Network | Network[], scheme?: \"exact\"): PaymentRequirements {\n  // Filter down to the scheme/network if provided\n  const broadlyAcceptedPaymentRequirements = paymentRequirements.filter(requirement => {\n    // If the scheme is not provided, we accept any scheme.\n    const isExpectedScheme = !scheme || requirement.scheme === scheme;\n    // If the chain is not provided, we accept any chain.\n    const isExpectedChain = !network || (Array.isArray(network) ? network.includes(requirement.network) : network == requirement.network);\n\n    return isExpectedScheme && isExpectedChain;\n  });\n\n  // Filter down to USDC requirements\n  const usdcRequirements = broadlyAcceptedPaymentRequirements.filter(requirement => {\n    // If the address is a USDC address, we return it.\n    return requirement.asset === getUsdcChainConfigForChain(getNetworkId(requirement.network))?.usdcAddress;\n  });\n\n  // Prioritize USDC requirements if available\n  if (usdcRequirements.length > 0) {\n    return usdcRequirements[0];\n  }\n  // If no USDC requirements are found, return the first broadly accepted requirement.\n  if (broadlyAcceptedPaymentRequirements.length > 0) {\n    return broadlyAcceptedPaymentRequirements[0];\n  }\n  // If no matching requirements are found, return the first requirement.\n  return paymentRequirements[0];\n}\n\n/**\n * Selector for payment requirements.\n *\n * @param paymentRequirements - The payment requirements to select from.\n * @param network - The network to check against. If not provided, the network will not be checked.\n * @param scheme - The scheme to check against. If not provided, the scheme will not be checked.\n * @returns The payment requirement that is the most appropriate for the user.\n */\nexport type PaymentRequirementsSelector = (paymentRequirements: PaymentRequirements[], network?: Network | Network[], scheme?: \"exact\") => PaymentRequirements;\n\n","import { Callable, RpcRequest, RpcRequestTransformer } from '@solana/rpc-spec-types';\nimport { DataPublisher } from '@solana/subscribable';\n\nimport { RpcSubscriptionsChannel } from './rpc-subscriptions-channel';\nimport { RpcSubscriptionsTransportDataEvents } from './rpc-subscriptions-transport';\n\nexport type RpcSubscriptionsApiConfig<TApiMethods extends RpcSubscriptionsApiMethods> = Readonly<{\n    planExecutor: RpcSubscriptionsPlanExecutor<ReturnType<TApiMethods[keyof TApiMethods]>>;\n    /**\n     * An optional function that transforms the {@link RpcRequest} before it is sent to the JSON RPC\n     * server.\n     *\n     * This is useful when the params supplied by the caller need to be transformed before\n     * forwarding the message to the server. Use cases for this include applying defaults,\n     * forwarding calls to renamed methods, and serializing complex values.\n     */\n    requestTransformer?: RpcRequestTransformer;\n}>;\n\n/**\n * A function that implements a protocol for subscribing and unsubscribing from notifications given\n * a {@link RpcSubscriptionsChannel}, a {@link RpcRequest}, and an `AbortSignal`.\n *\n * @returns A {@link DataPublisher} that emits {@link RpcSubscriptionsTransportDataEvents}\n */\ntype RpcSubscriptionsPlanExecutor<TNotification> = (\n    config: Readonly<{\n        channel: RpcSubscriptionsChannel<unknown, unknown>;\n        request: RpcRequest;\n        signal: AbortSignal;\n    }>,\n) => Promise<DataPublisher<RpcSubscriptionsTransportDataEvents<TNotification>>>;\n\n/**\n * This type allows an {@link RpcSubscriptionsApi} to describe how a particular subscription should\n * be issued to the JSON RPC server.\n *\n * Given a function that was called on a {@link RpcSubscriptions}, this object exposes an `execute`\n * function that dictates which subscription request will be sent, how the underlying transport will\n * be used, and how the notifications will be transformed.\n *\n * This function accepts a {@link RpcSubscriptionsChannel} and an `AbortSignal` and asynchronously\n * returns a {@link DataPublisher}. This gives us the opportunity to:\n *\n * - define the `payload` from the requested method name and parameters before passing it to the\n *   channel.\n * - call the underlying channel zero, one or multiple times depending on the use-case (e.g.\n *   caching or coalescing multiple subscriptions).\n * - transform the notification from the JSON RPC server, in case it does not match the\n *   `TNotification` specified by the\n *   {@link PendingRpcSubscriptionsRequest | PendingRpcSubscriptionsRequest<TNotification>} emitted\n *   from the publisher returned.\n */\nexport type RpcSubscriptionsPlan<TNotification> = Readonly<{\n    /**\n     * This method may be called with a newly-opened channel or a pre-established channel.\n     */\n    execute: (\n        config: Readonly<{\n            channel: RpcSubscriptionsChannel<unknown, unknown>;\n            signal: AbortSignal;\n        }>,\n    ) => Promise<DataPublisher<RpcSubscriptionsTransportDataEvents<TNotification>>>;\n    /**\n     * This request is used to uniquely identify the subscription.\n     * It typically comes from the method name and parameters of the subscription call,\n     * after potentially being transformed by the RPC Subscriptions API.\n     */\n    request: RpcRequest;\n}>;\n\n/**\n * For each of `TRpcSubscriptionsMethods`, this object exposes a method with the same name that maps\n * between its input arguments and a\n * {@link RpcSubscriptionsPlan | RpcSubscriptionsPlan<TNotification>} that implements the execution\n * of a JSON RPC subscription for `TNotifications`.\n */\nexport type RpcSubscriptionsApi<TRpcSubscriptionMethods> = {\n    [MethodName in keyof TRpcSubscriptionMethods]: RpcSubscriptionsReturnTypeMapper<\n        TRpcSubscriptionMethods[MethodName]\n    >;\n};\n\ntype RpcSubscriptionsReturnTypeMapper<TRpcMethod> = TRpcMethod extends Callable\n    ? (...rawParams: unknown[]) => RpcSubscriptionsPlan<ReturnType<TRpcMethod>>\n    : never;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RpcSubscriptionsApiMethod = (...args: any) => any;\nexport interface RpcSubscriptionsApiMethods {\n    [methodName: string]: RpcSubscriptionsApiMethod;\n}\n\n/**\n * Creates a JavaScript proxy that converts _any_ function call called on it to a\n * {@link RpcSubscriptionsPlan} by creating an `execute` function that:\n *\n * - calls the supplied {@link RpcSubscriptionsApiConfig.planExecutor} with a JSON RPC v2 payload\n *   object with the requested `methodName` and `params` properties, optionally transformed by\n *   {@link RpcSubscriptionsApiConfig.requestTransformer}.\n *\n * @example\n * ```ts\n * // For example, given this `RpcSubscriptionsApi`:\n * const rpcSubscriptionsApi = createJsonRpcSubscriptionsApi({\n *     async planExecutor({ channel, request }) {\n *         await channel.send(request);\n *         return {\n *             ...channel,\n *             on(type, listener, options) {\n *                 if (type !== 'message') {\n *                     return channel.on(type, listener, options);\n *                 }\n *                 return channel.on(\n *                     'message',\n *                     function resultGettingListener(message) {\n *                         listener(message.result);\n *                     },\n *                     options,\n *                 );\n *             }\n *         }\n *     },\n *     requestTransformer: (...rawParams) => rawParams.reverse(),\n * });\n *\n * // ...the following function call:\n * rpcSubscriptionsApi.foo('bar', { baz: 'bat' });\n *\n * // ...will produce a `RpcSubscriptionsPlan` that:\n * // -   Uses the following payload: { id: 1, jsonrpc: '2.0', method: 'foo', params: [{ baz: 'bat' }, 'bar'] }.\n * // -   Emits the \"result\" property of each RPC Subscriptions message.\n * ```\n */\nexport function createRpcSubscriptionsApi<TRpcSubscriptionsApiMethods extends RpcSubscriptionsApiMethods>(\n    config: RpcSubscriptionsApiConfig<TRpcSubscriptionsApiMethods>,\n): RpcSubscriptionsApi<TRpcSubscriptionsApiMethods> {\n    return new Proxy({} as RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get<TNotificationName extends keyof RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>>(\n            ...args: Parameters<NonNullable<ProxyHandler<RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>>['get']>>\n        ) {\n            const [_, p] = args;\n            const methodName = p.toString() as keyof TRpcSubscriptionsApiMethods as string;\n            return function (\n                ...params: Parameters<\n                    TRpcSubscriptionsApiMethods[TNotificationName] extends CallableFunction\n                        ? TRpcSubscriptionsApiMethods[TNotificationName]\n                        : never\n                >\n            ): RpcSubscriptionsPlan<ReturnType<TRpcSubscriptionsApiMethods[TNotificationName]>> {\n                const rawRequest = { methodName, params };\n                const request = config.requestTransformer ? config.requestTransformer(rawRequest) : rawRequest;\n                return {\n                    execute(planConfig) {\n                        return config.planExecutor({ ...planConfig, request });\n                    },\n                    request,\n                };\n            };\n        },\n    });\n}\n","import { RpcRequest } from './rpc-request';\n\nlet _nextMessageId = 0n;\nfunction getNextMessageId(): string {\n    const id = _nextMessageId;\n    _nextMessageId++;\n    return id.toString();\n}\n\n/**\n * Returns a spec-compliant JSON RPC 2.0 message, given a method name and some params.\n *\n * Generates a new `id` on each call by incrementing a `bigint` and casting it to a string.\n */\nexport function createRpcMessage<TParams>(request: RpcRequest<TParams>) {\n    return {\n        id: getNextMessageId(),\n        jsonrpc: '2.0',\n        method: request.methodName,\n        params: request.params,\n    };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\n\n/** ElGamal ciphertext containing an account balance. */\nexport type EncryptedBalance = ReadonlyUint8Array;\n\nexport type EncryptedBalanceArgs = EncryptedBalance;\n\nexport function getEncryptedBalanceEncoder(): FixedSizeEncoder<EncryptedBalanceArgs> {\n  return fixEncoderSize(getBytesEncoder(), 64);\n}\n\nexport function getEncryptedBalanceDecoder(): FixedSizeDecoder<EncryptedBalance> {\n  return fixDecoderSize(getBytesDecoder(), 64);\n}\n\nexport function getEncryptedBalanceCodec(): FixedSizeCodec<\n  EncryptedBalanceArgs,\n  EncryptedBalance\n> {\n  return combineCodec(\n    getEncryptedBalanceEncoder(),\n    getEncryptedBalanceDecoder()\n  );\n}\n","import type { Address as abitype_Address } from 'abitype'\nimport * as Bytes from './Bytes.js'\nimport * as Caches from './Caches.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as PublicKey from './PublicKey.js'\n\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/\n\n/** Root type for Address. */\nexport type Address = abitype_Address\n\n/**\n * Asserts that the given value is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xdeadbeef')\n * // @error: InvalidAddressError: Address \"0xdeadbeef\" is invalid.\n * ```\n *\n * @param value - Value to assert if it is a valid address.\n * @param options - Assertion options.\n */\nexport function assert(\n  value: string,\n  options: assert.Options = {},\n): asserts value is Address {\n  const { strict = true } = options\n\n  if (!addressRegex.test(value))\n    throw new InvalidAddressError({\n      address: value,\n      cause: new InvalidInputError(),\n    })\n\n  if (strict) {\n    if (value.toLowerCase() === value) return\n    if (checksum(value as Address) !== value)\n      throw new InvalidAddressError({\n        address: value,\n        cause: new InvalidChecksumError(),\n      })\n  }\n}\n\nexport declare namespace assert {\n  type Options = {\n    /**\n     * Enables strict mode. Whether or not to compare the address against its checksum.\n     *\n     * @default true\n     */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType = InvalidAddressError | Errors.GlobalErrorType\n}\n\n/**\n * Computes the checksum address for the given {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.checksum('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @param address - The address to compute the checksum for.\n * @returns The checksummed address.\n */\nexport function checksum(address: string): Address {\n  if (Caches.checksum.has(address)) return Caches.checksum.get(address)!\n\n  assert(address, { strict: false })\n\n  const hexAddress = address.substring(2).toLowerCase()\n  const hash = Hash.keccak256(Bytes.fromString(hexAddress), { as: 'Bytes' })\n\n  const characters = hexAddress.split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1]! >> 4 >= 8 && characters[i]) {\n      characters[i] = characters[i]!.toUpperCase()\n    }\n    if ((hash[i >> 1]! & 0x0f) >= 8 && characters[i + 1]) {\n      characters[i + 1] = characters[i + 1]!.toUpperCase()\n    }\n  }\n\n  const result = `0x${characters.join('')}` as const\n  Caches.checksum.set(address, result)\n  return result\n}\n\nexport declare namespace checksum {\n  type ErrorType =\n    | assert.ErrorType\n    | Hash.keccak256.ErrorType\n    | Bytes.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a stringified address to a typed (checksummed) {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e', {\n *   checksum: false\n * })\n * // @log: '0xa0cf798816d4b9b9866b5330eea46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('hello')\n * // @error: InvalidAddressError: Address \"0xa\" is invalid.\n * ```\n *\n * @param address - An address string to convert to a typed Address.\n * @param options - Conversion options.\n * @returns The typed Address.\n */\nexport function from(address: string, options: from.Options = {}): Address {\n  const { checksum: checksumVal = false } = options\n  assert(address)\n  if (checksumVal) return checksum(address)\n  return address as Address\n}\n\nexport declare namespace from {\n  type Options = {\n    /**\n     * Whether to checksum the address.\n     *\n     * @default false\n     */\n    checksum?: boolean | undefined\n  }\n\n  type ErrorType =\n    | assert.ErrorType\n    | checksum.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts an ECDSA public key to an {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address, PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from(\n *   '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5',\n * )\n * const address = Address.fromPublicKey(publicKey)\n * // @log: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'\n * ```\n *\n * @param publicKey - The ECDSA public key to convert to an {@link ox#Address.Address}.\n * @param options - Conversion options.\n * @returns The {@link ox#Address.Address} corresponding to the public key.\n */\nexport function fromPublicKey(\n  publicKey: PublicKey.PublicKey,\n  options: fromPublicKey.Options = {},\n): Address {\n  const address = Hash.keccak256(\n    `0x${PublicKey.toHex(publicKey).slice(4)}`,\n  ).substring(26)\n  return from(`0x${address}`, options)\n}\n\nexport declare namespace fromPublicKey {\n  type Options = {\n    /**\n     * Whether to checksum the address.\n     *\n     * @default false\n     */\n    checksum?: boolean | undefined\n  }\n\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | PublicKey.toHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if two {@link ox#Address.Address} are equal.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * )\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251f'\n * )\n * // @log: false\n * ```\n *\n * @param addressA - The first address to compare.\n * @param addressB - The second address to compare.\n * @returns Whether the addresses are equal.\n */\nexport function isEqual(addressA: Address, addressB: Address): boolean {\n  assert(addressA, { strict: false })\n  assert(addressB, { strict: false })\n  return addressA.toLowerCase() === addressB.toLowerCase()\n}\n\nexport declare namespace isEqual {\n  type ErrorType = assert.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Checks if the given address is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param address - Value to check if it is a valid address.\n * @param options - Check options.\n * @returns Whether the address is a valid address.\n */\nexport function validate(\n  address: string,\n  options: validate.Options = {},\n): address is Address {\n  const { strict = true } = options ?? {}\n  try {\n    assert(address, { strict })\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /**\n     * Enables strict mode. Whether or not to compare the address against its checksum.\n     *\n     * @default true\n     */\n    strict?: boolean | undefined\n  }\n}\n\n/**\n * Thrown when an address is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0x123')\n * // @error: Address.InvalidAddressError: Address `0x123` is invalid.\n * ```\n */\nexport class InvalidAddressError<\n  cause extends InvalidInputError | InvalidChecksumError =\n    | InvalidInputError\n    | InvalidChecksumError,\n> extends Errors.BaseError<cause> {\n  override readonly name = 'Address.InvalidAddressError'\n\n  constructor({ address, cause }: { address: string; cause: cause }) {\n    super(`Address \"${address}\" is invalid.`, {\n      cause,\n    })\n  }\n}\n\n/** Thrown when an address is not a 20 byte (40 hexadecimal character) value. */\nexport class InvalidInputError extends Errors.BaseError {\n  override readonly name = 'Address.InvalidInputError'\n\n  constructor() {\n    super('Address is not a 20 byte (40 hexadecimal character) value.')\n  }\n}\n\n/** Thrown when an address does not match its checksum counterpart. */\nexport class InvalidChecksumError extends Errors.BaseError {\n  override readonly name = 'Address.InvalidChecksumError'\n\n  constructor() {\n    super('Address does not match its checksum counterpart.')\n  }\n}\n","import { isSolanaError, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED } from '@solana/errors';\nimport { AbortController } from '@solana/event-target-impl';\nimport type { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\n\ntype Config<TChannel extends RpcSubscriptionsChannel<unknown, unknown>> = Readonly<{\n    abortSignal: AbortSignal;\n    channel: TChannel;\n    intervalMs: number;\n}>;\n\nconst PING_PAYLOAD = {\n    jsonrpc: '2.0',\n    method: 'ping',\n} as const;\n\n/**\n * Given a {@link RpcSubscriptionsChannel}, will return a new channel that sends a ping message to\n * the inner channel if a message has not been sent or received in the last `intervalMs`. In web\n * browsers, this implementation sends no ping when the network is down, and sends a ping\n * immediately upon the network coming back up.\n */\nexport function getRpcSubscriptionsChannelWithAutoping<TChannel extends RpcSubscriptionsChannel<object, unknown>>({\n    abortSignal: callerAbortSignal,\n    channel,\n    intervalMs,\n}: Config<TChannel>): TChannel {\n    let intervalId: ReturnType<typeof setInterval> | undefined;\n    function sendPing() {\n        channel.send(PING_PAYLOAD).catch((e: unknown) => {\n            if (isSolanaError(e, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED)) {\n                pingerAbortController.abort();\n            }\n        });\n    }\n    function restartPingTimer() {\n        clearInterval(intervalId);\n        intervalId = setInterval(sendPing, intervalMs);\n    }\n    const pingerAbortController = new AbortController();\n    pingerAbortController.signal.addEventListener('abort', () => {\n        clearInterval(intervalId);\n    });\n    callerAbortSignal.addEventListener('abort', () => {\n        pingerAbortController.abort();\n    });\n    channel.on(\n        'error',\n        () => {\n            pingerAbortController.abort();\n        },\n        { signal: pingerAbortController.signal },\n    );\n    channel.on('message', restartPingTimer, { signal: pingerAbortController.signal });\n    if (!__BROWSER__ || globalThis.navigator.onLine) {\n        restartPingTimer();\n    }\n    if (__BROWSER__) {\n        globalThis.addEventListener(\n            'offline',\n            function handleOffline() {\n                clearInterval(intervalId);\n            },\n            { signal: pingerAbortController.signal },\n        );\n        globalThis.addEventListener(\n            'online',\n            function handleOnline() {\n                sendPing();\n                restartPingTimer();\n            },\n            { signal: pingerAbortController.signal },\n        );\n    }\n    return {\n        ...channel,\n        send(...args) {\n            if (!pingerAbortController.signal.aborted) {\n                restartPingTimer();\n            }\n            return channel.send(...args);\n        },\n    };\n}\n","function base(ALPHABET, name) {\n  if (ALPHABET.length >= 255) {\n    throw new TypeError('Alphabet too long');\n  }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) {\n      throw new TypeError(x + ' is ambiguous');\n    }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256);\n  var iFACTOR = Math.log(256) / Math.log(BASE);\n  function encode(source) {\n    if (source instanceof Uint8Array);\n    else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) {\n      throw new TypeError('Expected Uint8Array');\n    }\n    if (source.length === 0) {\n      return '';\n    }\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n    var b58 = new Uint8Array(size);\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n        carry += 256 * b58[it1] >>> 0;\n        b58[it1] = carry % BASE >>> 0;\n        carry = carry / BASE >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      pbegin++;\n    }\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) {\n      str += ALPHABET.charAt(b58[it2]);\n    }\n    return str;\n  }\n  function decodeUnsafe(source) {\n    if (typeof source !== 'string') {\n      throw new TypeError('Expected String');\n    }\n    if (source.length === 0) {\n      return new Uint8Array();\n    }\n    var psz = 0;\n    if (source[psz] === ' ') {\n      return;\n    }\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n    var size = (source.length - psz) * FACTOR + 1 >>> 0;\n    var b256 = new Uint8Array(size);\n    while (source[psz]) {\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n      if (carry === 255) {\n        return;\n      }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {\n        carry += BASE * b256[it3] >>> 0;\n        b256[it3] = carry % 256 >>> 0;\n        carry = carry / 256 >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      psz++;\n    }\n    if (source[psz] === ' ') {\n      return;\n    }\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch;\n  }\n  function decode(string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) {\n      return buffer;\n    }\n    throw new Error(`Non-${ name } character`);\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\nexport default _brrp__multiformats_scope_baseX;","import { AbortController } from '@solana/event-target-impl';\nimport type { RpcTransport } from '@solana/rpc-spec';\nimport type { RpcResponse } from '@solana/rpc-spec-types';\n\ntype CoalescedRequest = {\n    readonly abortController: AbortController;\n    numConsumers: number;\n    readonly responsePromise: Promise<RpcResponse>;\n};\n\ntype GetDeduplicationKeyFn = (payload: unknown) => string | undefined;\n\n// This used to be a `Symbol()`, but there's a bug in Node <21 where the `undici` library passes\n// the `reason` property of the `AbortSignal` straight to `Error.captureStackTrace()` without first\n// typechecking it. `Error.captureStackTrace()` fatals when given a `Symbol`.\n// See https://github.com/nodejs/undici/pull/2597\nlet EXPLICIT_ABORT_TOKEN: ReturnType<typeof createExplicitAbortToken>;\nfunction createExplicitAbortToken() {\n    // This function is an annoying workaround to prevent `process.env.NODE_ENV` from appearing at\n    // the top level of this module and thwarting an optimizing compiler's attempt to tree-shake.\n    return process.env.NODE_ENV !== \"production\"\n        ? {\n              EXPLICIT_ABORT_TOKEN:\n                  'This object is thrown from the request that underlies a series of coalesced ' +\n                  'requests when the last request in that series aborts',\n          }\n        : {};\n}\n\nexport function getRpcTransportWithRequestCoalescing<TTransport extends RpcTransport>(\n    transport: TTransport,\n    getDeduplicationKey: GetDeduplicationKeyFn,\n): TTransport {\n    let coalescedRequestsByDeduplicationKey: Record<string, CoalescedRequest> | undefined;\n    return async function makeCoalescedHttpRequest<TResponse>(\n        request: Parameters<RpcTransport>[0],\n    ): Promise<RpcResponse<TResponse>> {\n        const { payload, signal } = request;\n        const deduplicationKey = getDeduplicationKey(payload);\n        if (deduplicationKey === undefined) {\n            return await transport(request);\n        }\n        if (!coalescedRequestsByDeduplicationKey) {\n            queueMicrotask(() => {\n                coalescedRequestsByDeduplicationKey = undefined;\n            });\n            coalescedRequestsByDeduplicationKey = {};\n        }\n        if (coalescedRequestsByDeduplicationKey[deduplicationKey] == null) {\n            const abortController = new AbortController();\n            const responsePromise = (async () => {\n                try {\n                    return await transport<TResponse>({\n                        ...request,\n                        signal: abortController.signal,\n                    });\n                } catch (e) {\n                    if (e === (EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken())) {\n                        // We triggered this error when the last subscriber aborted. Letting this\n                        // error bubble up from here would cause runtime fatals where there should\n                        // be none.\n                        return;\n                    }\n                    throw e;\n                }\n            })();\n            coalescedRequestsByDeduplicationKey[deduplicationKey] = {\n                abortController,\n                numConsumers: 0,\n                responsePromise,\n            };\n        }\n        const coalescedRequest = coalescedRequestsByDeduplicationKey[deduplicationKey];\n        coalescedRequest.numConsumers++;\n        if (signal) {\n            const responsePromise = coalescedRequest.responsePromise as Promise<RpcResponse<TResponse>>;\n            return await new Promise<RpcResponse<TResponse>>((resolve, reject) => {\n                const handleAbort = (e: AbortSignalEventMap['abort']) => {\n                    signal.removeEventListener('abort', handleAbort);\n                    coalescedRequest.numConsumers -= 1;\n                    queueMicrotask(() => {\n                        if (coalescedRequest.numConsumers === 0) {\n                            const abortController = coalescedRequest.abortController;\n                            abortController.abort((EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken()));\n                        }\n                    });\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                    reject((e.target as AbortSignal).reason);\n                };\n                signal.addEventListener('abort', handleAbort);\n                responsePromise\n                    .then(resolve)\n                    .catch(reject)\n                    .finally(() => {\n                        signal.removeEventListener('abort', handleAbort);\n                    });\n            });\n        } else {\n            return (await coalescedRequest.responsePromise) as RpcResponse<TResponse>;\n        }\n    } as TTransport;\n}\n","import { RpcResponse } from '@solana/rpc-spec-types';\n\ntype Config = Readonly<{\n    /** A value of arbitrary type to be sent to a RPC server */\n    payload: unknown;\n    /**\n     * An optional `AbortSignal` on which the `'abort'` event will be fired if the request should be\n     * cancelled.\n     */\n    signal?: AbortSignal;\n}>;\n\n/**\n * A function that can act as a transport for a {@link Rpc}. It need only return a promise for a\n * response given the supplied config.\n */\nexport type RpcTransport = {\n    <TResponse>(config: Config): Promise<RpcResponse<TResponse>>;\n};\n\n/**\n * Returns `true` if the given payload is a JSON RPC v2 payload.\n *\n * This means, the payload is an object such that:\n *\n * - It has a `jsonrpc` property with a value of `'2.0'`.\n * - It has a `method` property that is a string.\n * - It has a `params` property of any type.\n *\n * @example\n * ```ts\n * import { isJsonRpcPayload } from '@solana/rpc-spec';\n *\n * if (isJsonRpcPayload(payload)) {\n *     const payloadMethod: string = payload.method;\n *     const payloadParams: unknown = payload.params;\n * }\n * ```\n */\nexport function isJsonRpcPayload(payload: unknown): payload is Readonly<{\n    jsonrpc: '2.0';\n    method: string;\n    params: unknown;\n}> {\n    if (payload == null || typeof payload !== 'object' || Array.isArray(payload)) {\n        return false;\n    }\n    return (\n        'jsonrpc' in payload &&\n        payload.jsonrpc === '2.0' &&\n        'method' in payload &&\n        typeof payload.method === 'string' &&\n        'params' in payload\n    );\n}\n","export const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","import { Commitment } from '@solana/rpc-types';\n\nexport function applyDefaultCommitment({\n    commitmentPropertyName,\n    params,\n    optionsObjectPositionInParams,\n    overrideCommitment,\n}: Readonly<{\n    commitmentPropertyName: string;\n    optionsObjectPositionInParams: number;\n    overrideCommitment?: Commitment;\n    params: unknown[];\n}>) {\n    const paramInTargetPosition = params[optionsObjectPositionInParams];\n    if (\n        // There's no config.\n        paramInTargetPosition === undefined ||\n        // There is a config object.\n        (paramInTargetPosition && typeof paramInTargetPosition === 'object' && !Array.isArray(paramInTargetPosition))\n    ) {\n        if (\n            // The config object already has a commitment set.\n            paramInTargetPosition &&\n            commitmentPropertyName in paramInTargetPosition\n        ) {\n            if (\n                !paramInTargetPosition[commitmentPropertyName as keyof typeof paramInTargetPosition] ||\n                paramInTargetPosition[commitmentPropertyName as keyof typeof paramInTargetPosition] === 'finalized'\n            ) {\n                // Delete the commitment property; `finalized` is already the server default.\n                const nextParams = [...params];\n                const {\n                    [commitmentPropertyName as keyof typeof paramInTargetPosition]: _, // eslint-disable-line @typescript-eslint/no-unused-vars\n                    ...rest\n                } = paramInTargetPosition;\n                if (Object.keys(rest).length > 0) {\n                    nextParams[optionsObjectPositionInParams] = rest;\n                } else {\n                    if (optionsObjectPositionInParams === nextParams.length - 1) {\n                        nextParams.length--;\n                    } else {\n                        nextParams[optionsObjectPositionInParams] = undefined;\n                    }\n                }\n                return nextParams;\n            }\n        } else if (overrideCommitment !== 'finalized') {\n            // Apply the default commitment.\n            const nextParams = [...params];\n            nextParams[optionsObjectPositionInParams] = {\n                ...paramInTargetPosition,\n                [commitmentPropertyName]: overrideCommitment,\n            };\n            return nextParams;\n        }\n    }\n    return params;\n}\n","import {\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SolanaError,\n} from '@solana/errors';\nimport { DataPublisher } from '@solana/subscribable';\n\ntype RpcSubscriptionsChannelSolanaErrorCode =\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT;\n\nexport type RpcSubscriptionChannelEvents<TInboundMessage> = {\n    /**\n     * Fires when the channel closes unexpectedly.\n     * @eventProperty\n     */\n    error: SolanaError<RpcSubscriptionsChannelSolanaErrorCode>;\n    /**\n     * Fires on every message received from the remote end.\n     * @eventProperty\n     */\n    message: TInboundMessage;\n};\n\n/**\n * A {@link DataPublisher} on which you can subscribe to events of type\n * {@link RpcSubscriptionChannelEvents | RpcSubscriptionChannelEvents<TInboundMessage>}.\n * Additionally, you can use this object to send messages of type `TOutboundMessage` back to the\n * remote end by calling its {@link RpcSubscriptionsChannel.send | `send(message)`} method.\n */\nexport interface RpcSubscriptionsChannel<TOutboundMessage, TInboundMessage>\n    extends DataPublisher<RpcSubscriptionChannelEvents<TInboundMessage>> {\n    send(message: TOutboundMessage): Promise<void>;\n}\n\n/**\n * A channel creator is a function that accepts an `AbortSignal`, returns a new\n * {@link RpcSubscriptionsChannel}, and tears down the channel when the abort signal fires.\n */\nexport type RpcSubscriptionsChannelCreator<TOutboundMessage, TInboundMessage> = (\n    config: Readonly<{\n        abortSignal: AbortSignal;\n    }>,\n) => Promise<RpcSubscriptionsChannel<TOutboundMessage, TInboundMessage>>;\n\n/**\n * Given a channel with inbound messages of type `T` and a function of type `T => U`, returns a new\n * channel with inbound messages of type `U`.\n *\n * Note that this only affects messages of type `\"message\"` and thus, does not affect incoming error\n * messages.\n *\n * @example Parsing incoming JSON messages\n * ```ts\n * const transformedChannel = transformChannelInboundMessages(channel, JSON.parse);\n * ```\n */\nexport function transformChannelInboundMessages<TOutboundMessage, TNewInboundMessage, TInboundMessage>(\n    channel: RpcSubscriptionsChannel<TOutboundMessage, TInboundMessage>,\n    transform: (message: TInboundMessage) => TNewInboundMessage,\n): RpcSubscriptionsChannel<TOutboundMessage, TNewInboundMessage> {\n    return Object.freeze<RpcSubscriptionsChannel<TOutboundMessage, TNewInboundMessage>>({\n        ...channel,\n        on(type, subscriber, options) {\n            if (type !== 'message') {\n                return channel.on(\n                    type,\n                    subscriber as (data: RpcSubscriptionChannelEvents<TInboundMessage>[typeof type]) => void,\n                    options,\n                );\n            }\n            return channel.on(\n                'message',\n                message => (subscriber as (data: TNewInboundMessage) => void)(transform(message)),\n                options,\n            );\n        },\n    });\n}\n\n/**\n * Given a channel with outbound messages of type `T` and a function of type `U => T`, returns a new\n * channel with outbound messages of type `U`.\n *\n * @example Stringifying JSON messages before sending them over the wire\n * ```ts\n * const transformedChannel = transformChannelOutboundMessages(channel, JSON.stringify);\n * ```\n */\nexport function transformChannelOutboundMessages<TNewOutboundMessage, TOutboundMessage, TInboundMessage>(\n    channel: RpcSubscriptionsChannel<TOutboundMessage, TInboundMessage>,\n    transform: (message: TNewOutboundMessage) => TOutboundMessage,\n): RpcSubscriptionsChannel<TNewOutboundMessage, TInboundMessage> {\n    return Object.freeze<RpcSubscriptionsChannel<TNewOutboundMessage, TInboundMessage>>({\n        ...channel,\n        send: message => channel.send(transform(message)),\n    });\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { COMPUTE_BUDGET_PROGRAM_ADDRESS } from '../programs';\n\nexport const REQUEST_UNITS_DISCRIMINATOR = 0;\n\nexport function getRequestUnitsDiscriminatorBytes() {\n  return getU8Encoder().encode(REQUEST_UNITS_DISCRIMINATOR);\n}\n\nexport type RequestUnitsInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<TRemainingAccounts>;\n\nexport type RequestUnitsInstructionData = {\n  discriminator: number;\n  /** Units to request for transaction-wide compute. */\n  units: number;\n  /** Prioritization fee lamports. */\n  additionalFee: number;\n};\n\nexport type RequestUnitsInstructionDataArgs = {\n  /** Units to request for transaction-wide compute. */\n  units: number;\n  /** Prioritization fee lamports. */\n  additionalFee: number;\n};\n\nexport function getRequestUnitsInstructionDataEncoder(): FixedSizeEncoder<RequestUnitsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['units', getU32Encoder()],\n      ['additionalFee', getU32Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: REQUEST_UNITS_DISCRIMINATOR })\n  );\n}\n\nexport function getRequestUnitsInstructionDataDecoder(): FixedSizeDecoder<RequestUnitsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['units', getU32Decoder()],\n    ['additionalFee', getU32Decoder()],\n  ]);\n}\n\nexport function getRequestUnitsInstructionDataCodec(): FixedSizeCodec<\n  RequestUnitsInstructionDataArgs,\n  RequestUnitsInstructionData\n> {\n  return combineCodec(\n    getRequestUnitsInstructionDataEncoder(),\n    getRequestUnitsInstructionDataDecoder()\n  );\n}\n\nexport type RequestUnitsInput = {\n  units: RequestUnitsInstructionDataArgs['units'];\n  additionalFee: RequestUnitsInstructionDataArgs['additionalFee'];\n};\n\nexport function getRequestUnitsInstruction<\n  TProgramAddress extends Address = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n>(\n  input: RequestUnitsInput,\n  config?: { programAddress?: TProgramAddress }\n): RequestUnitsInstruction<TProgramAddress> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? COMPUTE_BUDGET_PROGRAM_ADDRESS;\n\n  // Original args.\n  const args = { ...input };\n\n  return Object.freeze({\n    data: getRequestUnitsInstructionDataEncoder().encode(\n      args as RequestUnitsInstructionDataArgs\n    ),\n    programAddress,\n  } as RequestUnitsInstruction<TProgramAddress>);\n}\n\nexport type ParsedRequestUnitsInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n> = { programAddress: Address<TProgram>; data: RequestUnitsInstructionData };\n\nexport function parseRequestUnitsInstruction<TProgram extends string>(\n  instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>\n): ParsedRequestUnitsInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getRequestUnitsInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * Transforms a value into a JSON string, whilst rendering bigints as large unsafe integers.\n */\nexport function stringifyJsonWithBigInts(value: unknown, space?: number | string): string {\n    return unwrapBigIntValueObject(\n        JSON.stringify(value, (_, v) => (typeof v === 'bigint' ? wrapBigIntValueObject(v) : v), space),\n    );\n}\n\ntype BigIntValueObject = {\n    // `$` implies 'this is a value object'.\n    // `n` implies 'interpret the value as a bigint'.\n    $n: string;\n};\n\nfunction wrapBigIntValueObject(value: bigint): BigIntValueObject {\n    return { $n: `${value}` };\n}\n\nfunction unwrapBigIntValueObject(value: string): string {\n    return value.replace(/\\{\\s*\"\\$n\"\\s*:\\s*\"(-?\\d+)\"\\s*\\}/g, '$1');\n}\n","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nexport function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nexport function abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nexport function ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nexport function byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nexport const byteSwapIfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexport const swap32IfBE = isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nexport class Hash {\n}\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport const wrapConstructor = createHasher;\nexport const wrapConstructorWithOpts = createOptHasher;\nexport const wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return Uint8Array.from(crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","import { createPublicClient, createWalletClient, http, publicActions } from \"viem\";\nimport type {\n  Chain,\n  Transport,\n  Client,\n  Account,\n  RpcSchema,\n  PublicActions,\n  WalletActions,\n  PublicClient,\n  LocalAccount,\n} from \"viem\";\nimport {\n  baseSepolia,\n  avalancheFuji,\n  base,\n  sei,\n  seiTestnet,\n  polygon,\n  polygonAmoy,\n  peaq,\n  avalanche,\n  iotexTestnet,\n  iotex,\n  abstract,\n  abstractTestnet,\n  story,\n  eduChain,\n} from \"viem/chains\";\nimport { skaleBaseSepolia } from \"../custom-chains\";\nimport { privateKeyToAccount } from \"viem/accounts\";\nimport { Hex } from \"viem\";\nimport { eip712WalletActions } from \"viem/zksync\";\n\n// Create a public client for reading data\nexport type SignerWallet<\n  chain extends Chain = Chain,\n  transport extends Transport = Transport,\n  account extends Account = Account,\n> = Client<\n  transport,\n  chain,\n  account,\n  RpcSchema,\n  PublicActions<transport, chain, account> & WalletActions<chain, account>\n>;\n\nexport type ConnectedClient<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain,\n  account extends Account | undefined = undefined,\n> = PublicClient<transport, chain, account>;\n\nexport type EvmSigner = SignerWallet<Chain, Transport, Account> | LocalAccount;\n\n/**\n * Creates a public client configured for the specified network\n *\n * @param network - The network to connect to\n * @returns A public client instance connected to the specified chain\n */\nexport function createConnectedClient(\n  network: string,\n): ConnectedClient<Transport, Chain, undefined> {\n  const chain = getChainFromNetwork(network);\n\n  return createPublicClient({\n    chain,\n    transport: http(),\n  }).extend(publicActions);\n}\n\n/**\n * Creates a public client configured for the Base Sepolia testnet\n *\n * @deprecated Use `createConnectedClient(\"base-sepolia\")` instead\n * @returns A public client instance connected to Base Sepolia\n */\nexport function createClientSepolia(): ConnectedClient<Transport, typeof baseSepolia, undefined> {\n  return createConnectedClient(\"base-sepolia\") as ConnectedClient<\n    Transport,\n    typeof baseSepolia,\n    undefined\n  >;\n}\n\n/**\n * Creates a public client configured for the Avalanche Fuji testnet\n *\n * @deprecated Use `createConnectedClient(\"avalanche-fuji\")` instead\n * @returns A public client instance connected to Avalanche Fuji\n */\nexport function createClientAvalancheFuji(): ConnectedClient<\n  Transport,\n  typeof avalancheFuji,\n  undefined\n> {\n  return createConnectedClient(\"avalanche-fuji\") as ConnectedClient<\n    Transport,\n    typeof avalancheFuji,\n    undefined\n  >;\n}\n\n/**\n * Creates a wallet client configured for the specified chain with a private key\n *\n * @param network - The network to connect to\n * @param privateKey - The private key to use for signing transactions\n * @returns A wallet client instance connected to the specified chain with the provided private key\n */\nexport function createSigner(network: string, privateKey: Hex): SignerWallet<Chain> {\n  const chain = getChainFromNetwork(network);\n\n  const walletClient = createWalletClient({\n    chain,\n    transport: http(),\n    account: privateKeyToAccount(privateKey),\n  });\n\n  if (isZkStackChain(chain)) {\n    return walletClient.extend(publicActions).extend(eip712WalletActions());\n  }\n\n  return walletClient.extend(publicActions);\n}\n\n/**\n * Creates a wallet client configured for the Base Sepolia testnet with a private key\n *\n * @deprecated Use `createSigner(\"base-sepolia\", privateKey)` instead\n * @param privateKey - The private key to use for signing transactions\n * @returns A wallet client instance connected to Base Sepolia with the provided private key\n */\nexport function createSignerSepolia(privateKey: Hex): SignerWallet<typeof baseSepolia> {\n  return createSigner(\"base-sepolia\", privateKey) as SignerWallet<typeof baseSepolia>;\n}\n\n/**\n * Creates a wallet client configured for the Avalanche Fuji testnet with a private key\n *\n * @deprecated Use `createSigner(\"avalanche-fuji\", privateKey)` instead\n * @param privateKey - The private key to use for signing transactions\n * @returns A wallet client instance connected to Avalanche Fuji with the provided private key\n */\nexport function createSignerAvalancheFuji(privateKey: Hex): SignerWallet<typeof avalancheFuji> {\n  return createSigner(\"avalanche-fuji\", privateKey) as SignerWallet<typeof avalancheFuji>;\n}\n\n/**\n * Checks if a wallet is a signer wallet\n *\n * @param wallet - The wallet to check\n * @returns True if the wallet is a signer wallet, false otherwise\n */\nexport function isSignerWallet<\n  TChain extends Chain = Chain,\n  TTransport extends Transport = Transport,\n  TAccount extends Account = Account,\n>(\n  wallet: SignerWallet<TChain, TTransport, TAccount> | LocalAccount,\n): wallet is SignerWallet<TChain, TTransport, TAccount> {\n  return (\n    typeof wallet === \"object\" && wallet !== null && \"chain\" in wallet && \"transport\" in wallet\n  );\n}\n\n/**\n * Checks if a wallet is an account\n *\n * @param wallet - The wallet to check\n * @returns True if the wallet is an account, false otherwise\n */\nexport function isAccount<\n  TChain extends Chain = Chain,\n  TTransport extends Transport = Transport,\n  TAccount extends Account = Account,\n>(wallet: SignerWallet<TChain, TTransport, TAccount> | LocalAccount): wallet is LocalAccount {\n  const w = wallet as LocalAccount;\n  return (\n    typeof wallet === \"object\" &&\n    wallet !== null &&\n    typeof w.address === \"string\" &&\n    typeof w.type === \"string\" &&\n    // Check for essential signing capabilities\n    typeof w.sign === \"function\" &&\n    typeof w.signMessage === \"function\" &&\n    typeof w.signTypedData === \"function\" &&\n    // Check for transaction signing (required by LocalAccount)\n    typeof w.signTransaction === \"function\"\n  );\n}\n\n/**\n * Maps network strings to Chain objects\n *\n * @param network - The network string to convert to a Chain object\n * @returns The corresponding Chain object\n */\nexport function getChainFromNetwork(network: string | undefined): Chain {\n  if (!network) {\n    throw new Error(\"NETWORK environment variable is not set\");\n  }\n\n  switch (network) {\n    case \"abstract\":\n      return abstract;\n    case \"abstract-testnet\":\n      return abstractTestnet;\n    case \"base\":\n      return base;\n    case \"base-sepolia\":\n      return baseSepolia;\n    case \"avalanche\":\n      return avalanche;\n    case \"avalanche-fuji\":\n      return avalancheFuji;\n    case \"sei\":\n      return sei;\n    case \"sei-testnet\":\n      return seiTestnet;\n    case \"polygon\":\n      return polygon;\n    case \"polygon-amoy\":\n      return polygonAmoy;\n    case \"peaq\":\n      return peaq;\n    case \"story\":\n      return story;\n    case \"educhain\":\n      return eduChain;\n    case \"iotex\":\n      return iotex;\n    case \"iotex-testnet\":\n      return iotexTestnet;\n    case \"skale-base-sepolia\":\n      return skaleBaseSepolia;\n    default:\n      throw new Error(`Unsupported network: ${network}`);\n  }\n}\n\nconst ZKSTACK_CHAIN_IDS = new Set([\n  2741, // Abstract Mainnet\n  11124, // Abstract Sepolia Testnet\n]);\n\n/**\n * Checks whether the given chain is part of the zkstack stack\n *\n * @param chain - The chain to check\n * @returns True if the chain is a ZK stack chain\n */\nexport function isZkStackChain(chain: Chain): boolean {\n  return ZKSTACK_CHAIN_IDS.has(chain.id);\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getDiscriminatedUnionDecoder,\n  getDiscriminatedUnionEncoder,\n  getF64Decoder,\n  getF64Encoder,\n  getI16Decoder,\n  getI16Encoder,\n  getMapDecoder,\n  getMapEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getUnitDecoder,\n  getUnitEncoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type GetDiscriminatedUnionVariant,\n  type GetDiscriminatedUnionVariantContent,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/kit';\nimport {\n  getAccountStateDecoder,\n  getAccountStateEncoder,\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  getEncryptedBalanceDecoder,\n  getEncryptedBalanceEncoder,\n  getTransferFeeDecoder,\n  getTransferFeeEncoder,\n  type AccountState,\n  type AccountStateArgs,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n  type EncryptedBalance,\n  type EncryptedBalanceArgs,\n  type TransferFee,\n  type TransferFeeArgs,\n} from '.';\n\nexport type Extension =\n  | { __kind: 'Uninitialized' }\n  | {\n      __kind: 'TransferFeeConfig';\n      /** Optional authority to set the fee. */\n      transferFeeConfigAuthority: Address;\n      /** Withdraw from mint instructions must be signed by this key. */\n      withdrawWithheldAuthority: Address;\n      /** Withheld transfer fee tokens that have been moved to the mint for withdrawal. */\n      withheldAmount: bigint;\n      /** Older transfer fee, used if the current epoch < newerTransferFee.epoch. */\n      olderTransferFee: TransferFee;\n      /** Newer transfer fee, used if the current epoch >= newerTransferFee.epoch. */\n      newerTransferFee: TransferFee;\n    }\n  | {\n      __kind: 'TransferFeeAmount';\n      /** Withheld transfer fee tokens that can be claimed by the fee authority. */\n      withheldAmount: bigint;\n    }\n  | { __kind: 'MintCloseAuthority'; closeAuthority: Address }\n  | {\n      __kind: 'ConfidentialTransferMint';\n      /**\n       * Authority to modify the `ConfidentialTransferMint` configuration and to\n       * approve new accounts (if `auto_approve_new_accounts` is true).\n       *\n       * The legacy Token Multisig account is not supported as the authority.\n       */\n      authority: Option<Address>;\n      /**\n       * Indicate if newly configured accounts must be approved by the\n       * `authority` before they may be used by the user.\n       *\n       * * If `true`, no approval is required and new accounts may be used immediately.\n       * * If `false`, the authority must approve newly configured accounts (see\n       *   `ConfidentialTransferInstruction::ConfigureAccount`).\n       */\n      autoApproveNewAccounts: boolean;\n      /** Authority to decode any transfer amount in a confidential transfer. */\n      auditorElgamalPubkey: Option<Address>;\n    }\n  | {\n      __kind: 'ConfidentialTransferAccount';\n      /**\n       * `true` if this account has been approved for use. All confidential\n       * transfer operations for the account will fail until approval is granted.\n       */\n      approved: boolean;\n      /** The public key associated with ElGamal encryption. */\n      elgamalPubkey: Address;\n      /** The low 16 bits of the pending balance (encrypted by `elgamal_pubkey`). */\n      pendingBalanceLow: EncryptedBalance;\n      /** The high 32 bits of the pending balance (encrypted by `elgamal_pubkey`). */\n      pendingBalanceHigh: EncryptedBalance;\n      /** The available balance (encrypted by `encrypiton_pubkey`). */\n      availableBalance: EncryptedBalance;\n      /** The decryptable available balance. */\n      decryptableAvailableBalance: DecryptableBalance;\n      /** If `false`, the extended account rejects any incoming confidential transfers. */\n      allowConfidentialCredits: boolean;\n      /** If `false`, the base account rejects any incoming transfers. */\n      allowNonConfidentialCredits: boolean;\n      /** The total number of `Deposit` and `Transfer` instructions that have credited `pending_balance`. */\n      pendingBalanceCreditCounter: bigint;\n      /**\n       * The maximum number of `Deposit` and `Transfer` instructions that can\n       * credit `pending_balance` before the `ApplyPendingBalance`\n       * instruction is executed.\n       */\n      maximumPendingBalanceCreditCounter: bigint;\n      /**\n       * The `expected_pending_balance_credit_counter` value that was included in\n       * the last `ApplyPendingBalance` instruction.\n       */\n      expectedPendingBalanceCreditCounter: bigint;\n      /**\n       * The actual `pending_balance_credit_counter` when the last\n       * `ApplyPendingBalance` instruction was executed.\n       */\n      actualPendingBalanceCreditCounter: bigint;\n    }\n  | { __kind: 'DefaultAccountState'; state: AccountState }\n  | { __kind: 'ImmutableOwner' }\n  | {\n      __kind: 'MemoTransfer';\n      /** Require transfers into this account to be accompanied by a memo. */\n      requireIncomingTransferMemos: boolean;\n    }\n  | { __kind: 'NonTransferable' }\n  | {\n      __kind: 'InterestBearingConfig';\n      rateAuthority: Address;\n      initializationTimestamp: bigint;\n      preUpdateAverageRate: number;\n      lastUpdateTimestamp: bigint;\n      currentRate: number;\n    }\n  | {\n      __kind: 'CpiGuard';\n      /** Lock certain token operations from taking place within CPI for this account. */\n      lockCpi: boolean;\n    }\n  | { __kind: 'PermanentDelegate'; delegate: Address }\n  | { __kind: 'NonTransferableAccount' }\n  | {\n      __kind: 'TransferHook';\n      /** The transfer hook update authority. */\n      authority: Address;\n      /** The transfer hook program account. */\n      programId: Address;\n    }\n  | {\n      __kind: 'TransferHookAccount';\n      /**\n       * Whether or not this account is currently transferring tokens\n       * True during the transfer hook cpi, otherwise false.\n       */\n      transferring: boolean;\n    }\n  | {\n      __kind: 'ConfidentialTransferFee';\n      /** Optional authority to set the withdraw withheld authority ElGamal key. */\n      authority: Option<Address>;\n      /**\n       * Withheld fees from accounts must be encrypted with this ElGamal key.\n       *\n       * Note that whoever holds the ElGamal private key for this ElGamal public\n       * key has the ability to decode any withheld fee amount that are\n       * associated with accounts. When combined with the fee parameters, the\n       * withheld fee amounts can reveal information about transfer amounts.\n       */\n      elgamalPubkey: Address;\n      /** If `false`, the harvest of withheld tokens to mint is rejected. */\n      harvestToMintEnabled: boolean;\n      /**\n       * Withheld confidential transfer fee tokens that have been moved to the\n       * mint for withdrawal.\n       */\n      withheldAmount: EncryptedBalance;\n    }\n  | {\n      __kind: 'ConfidentialTransferFeeAmount';\n      /** Amount withheld during confidential transfers, to be harvest to the mint. */\n      withheldAmount: EncryptedBalance;\n    }\n  | {\n      __kind: 'MetadataPointer';\n      /** Optional authority that can set the metadata address. */\n      authority: Option<Address>;\n      /** Optional Account Address that holds the metadata. */\n      metadataAddress: Option<Address>;\n    }\n  | {\n      __kind: 'TokenMetadata';\n      /** The authority that can sign to update the metadata. */\n      updateAuthority: Option<Address>;\n      /** The associated mint, used to counter spoofing to be sure that metadata belongs to a particular mint. */\n      mint: Address;\n      /** The longer name of the token. */\n      name: string;\n      /** The shortened symbol for the token. */\n      symbol: string;\n      /** The URI pointing to richer metadata. */\n      uri: string;\n      /** Any additional metadata about the token as key-value pairs. */\n      additionalMetadata: Map<string, string>;\n    }\n  | {\n      __kind: 'GroupPointer';\n      /** Optional authority that can set the group address. */\n      authority: Option<Address>;\n      /** Optional account address that holds the group. */\n      groupAddress: Option<Address>;\n    }\n  | {\n      __kind: 'TokenGroup';\n      /** The authority that can sign to update the group. */\n      updateAuthority: Option<Address>;\n      /** The associated mint, used to counter spoofing to be sure that group belongs to a particular mint. */\n      mint: Address;\n      /** The current number of group members. */\n      size: bigint;\n      /** The maximum number of group members. */\n      maxSize: bigint;\n    }\n  | {\n      __kind: 'GroupMemberPointer';\n      /** Optional authority that can set the member address. */\n      authority: Option<Address>;\n      /** Optional account address that holds the member. */\n      memberAddress: Option<Address>;\n    }\n  | {\n      __kind: 'TokenGroupMember';\n      /** The associated mint, used to counter spoofing to be sure that member belongs to a particular mint. */\n      mint: Address;\n      /** The pubkey of the `TokenGroup`. */\n      group: Address;\n      /** The member number. */\n      memberNumber: bigint;\n    }\n  | { __kind: 'ConfidentialMintBurn' }\n  | {\n      __kind: 'ScaledUiAmountConfig';\n      authority: Address;\n      multiplier: number;\n      newMultiplierEffectiveTimestamp: bigint;\n      newMultiplier: number;\n    }\n  | { __kind: 'PausableConfig'; authority: Option<Address>; paused: boolean }\n  | { __kind: 'PausableAccount' };\n\nexport type ExtensionArgs =\n  | { __kind: 'Uninitialized' }\n  | {\n      __kind: 'TransferFeeConfig';\n      /** Optional authority to set the fee. */\n      transferFeeConfigAuthority: Address;\n      /** Withdraw from mint instructions must be signed by this key. */\n      withdrawWithheldAuthority: Address;\n      /** Withheld transfer fee tokens that have been moved to the mint for withdrawal. */\n      withheldAmount: number | bigint;\n      /** Older transfer fee, used if the current epoch < newerTransferFee.epoch. */\n      olderTransferFee: TransferFeeArgs;\n      /** Newer transfer fee, used if the current epoch >= newerTransferFee.epoch. */\n      newerTransferFee: TransferFeeArgs;\n    }\n  | {\n      __kind: 'TransferFeeAmount';\n      /** Withheld transfer fee tokens that can be claimed by the fee authority. */\n      withheldAmount: number | bigint;\n    }\n  | { __kind: 'MintCloseAuthority'; closeAuthority: Address }\n  | {\n      __kind: 'ConfidentialTransferMint';\n      /**\n       * Authority to modify the `ConfidentialTransferMint` configuration and to\n       * approve new accounts (if `auto_approve_new_accounts` is true).\n       *\n       * The legacy Token Multisig account is not supported as the authority.\n       */\n      authority: OptionOrNullable<Address>;\n      /**\n       * Indicate if newly configured accounts must be approved by the\n       * `authority` before they may be used by the user.\n       *\n       * * If `true`, no approval is required and new accounts may be used immediately.\n       * * If `false`, the authority must approve newly configured accounts (see\n       *   `ConfidentialTransferInstruction::ConfigureAccount`).\n       */\n      autoApproveNewAccounts: boolean;\n      /** Authority to decode any transfer amount in a confidential transfer. */\n      auditorElgamalPubkey: OptionOrNullable<Address>;\n    }\n  | {\n      __kind: 'ConfidentialTransferAccount';\n      /**\n       * `true` if this account has been approved for use. All confidential\n       * transfer operations for the account will fail until approval is granted.\n       */\n      approved: boolean;\n      /** The public key associated with ElGamal encryption. */\n      elgamalPubkey: Address;\n      /** The low 16 bits of the pending balance (encrypted by `elgamal_pubkey`). */\n      pendingBalanceLow: EncryptedBalanceArgs;\n      /** The high 32 bits of the pending balance (encrypted by `elgamal_pubkey`). */\n      pendingBalanceHigh: EncryptedBalanceArgs;\n      /** The available balance (encrypted by `encrypiton_pubkey`). */\n      availableBalance: EncryptedBalanceArgs;\n      /** The decryptable available balance. */\n      decryptableAvailableBalance: DecryptableBalanceArgs;\n      /** If `false`, the extended account rejects any incoming confidential transfers. */\n      allowConfidentialCredits: boolean;\n      /** If `false`, the base account rejects any incoming transfers. */\n      allowNonConfidentialCredits: boolean;\n      /** The total number of `Deposit` and `Transfer` instructions that have credited `pending_balance`. */\n      pendingBalanceCreditCounter: number | bigint;\n      /**\n       * The maximum number of `Deposit` and `Transfer` instructions that can\n       * credit `pending_balance` before the `ApplyPendingBalance`\n       * instruction is executed.\n       */\n      maximumPendingBalanceCreditCounter: number | bigint;\n      /**\n       * The `expected_pending_balance_credit_counter` value that was included in\n       * the last `ApplyPendingBalance` instruction.\n       */\n      expectedPendingBalanceCreditCounter: number | bigint;\n      /**\n       * The actual `pending_balance_credit_counter` when the last\n       * `ApplyPendingBalance` instruction was executed.\n       */\n      actualPendingBalanceCreditCounter: number | bigint;\n    }\n  | { __kind: 'DefaultAccountState'; state: AccountStateArgs }\n  | { __kind: 'ImmutableOwner' }\n  | {\n      __kind: 'MemoTransfer';\n      /** Require transfers into this account to be accompanied by a memo. */\n      requireIncomingTransferMemos: boolean;\n    }\n  | { __kind: 'NonTransferable' }\n  | {\n      __kind: 'InterestBearingConfig';\n      rateAuthority: Address;\n      initializationTimestamp: number | bigint;\n      preUpdateAverageRate: number;\n      lastUpdateTimestamp: number | bigint;\n      currentRate: number;\n    }\n  | {\n      __kind: 'CpiGuard';\n      /** Lock certain token operations from taking place within CPI for this account. */\n      lockCpi: boolean;\n    }\n  | { __kind: 'PermanentDelegate'; delegate: Address }\n  | { __kind: 'NonTransferableAccount' }\n  | {\n      __kind: 'TransferHook';\n      /** The transfer hook update authority. */\n      authority: Address;\n      /** The transfer hook program account. */\n      programId: Address;\n    }\n  | {\n      __kind: 'TransferHookAccount';\n      /**\n       * Whether or not this account is currently transferring tokens\n       * True during the transfer hook cpi, otherwise false.\n       */\n      transferring: boolean;\n    }\n  | {\n      __kind: 'ConfidentialTransferFee';\n      /** Optional authority to set the withdraw withheld authority ElGamal key. */\n      authority: OptionOrNullable<Address>;\n      /**\n       * Withheld fees from accounts must be encrypted with this ElGamal key.\n       *\n       * Note that whoever holds the ElGamal private key for this ElGamal public\n       * key has the ability to decode any withheld fee amount that are\n       * associated with accounts. When combined with the fee parameters, the\n       * withheld fee amounts can reveal information about transfer amounts.\n       */\n      elgamalPubkey: Address;\n      /** If `false`, the harvest of withheld tokens to mint is rejected. */\n      harvestToMintEnabled: boolean;\n      /**\n       * Withheld confidential transfer fee tokens that have been moved to the\n       * mint for withdrawal.\n       */\n      withheldAmount: EncryptedBalanceArgs;\n    }\n  | {\n      __kind: 'ConfidentialTransferFeeAmount';\n      /** Amount withheld during confidential transfers, to be harvest to the mint. */\n      withheldAmount: EncryptedBalanceArgs;\n    }\n  | {\n      __kind: 'MetadataPointer';\n      /** Optional authority that can set the metadata address. */\n      authority: OptionOrNullable<Address>;\n      /** Optional Account Address that holds the metadata. */\n      metadataAddress: OptionOrNullable<Address>;\n    }\n  | {\n      __kind: 'TokenMetadata';\n      /** The authority that can sign to update the metadata. */\n      updateAuthority: OptionOrNullable<Address>;\n      /** The associated mint, used to counter spoofing to be sure that metadata belongs to a particular mint. */\n      mint: Address;\n      /** The longer name of the token. */\n      name: string;\n      /** The shortened symbol for the token. */\n      symbol: string;\n      /** The URI pointing to richer metadata. */\n      uri: string;\n      /** Any additional metadata about the token as key-value pairs. */\n      additionalMetadata: Map<string, string>;\n    }\n  | {\n      __kind: 'GroupPointer';\n      /** Optional authority that can set the group address. */\n      authority: OptionOrNullable<Address>;\n      /** Optional account address that holds the group. */\n      groupAddress: OptionOrNullable<Address>;\n    }\n  | {\n      __kind: 'TokenGroup';\n      /** The authority that can sign to update the group. */\n      updateAuthority: OptionOrNullable<Address>;\n      /** The associated mint, used to counter spoofing to be sure that group belongs to a particular mint. */\n      mint: Address;\n      /** The current number of group members. */\n      size: number | bigint;\n      /** The maximum number of group members. */\n      maxSize: number | bigint;\n    }\n  | {\n      __kind: 'GroupMemberPointer';\n      /** Optional authority that can set the member address. */\n      authority: OptionOrNullable<Address>;\n      /** Optional account address that holds the member. */\n      memberAddress: OptionOrNullable<Address>;\n    }\n  | {\n      __kind: 'TokenGroupMember';\n      /** The associated mint, used to counter spoofing to be sure that member belongs to a particular mint. */\n      mint: Address;\n      /** The pubkey of the `TokenGroup`. */\n      group: Address;\n      /** The member number. */\n      memberNumber: number | bigint;\n    }\n  | { __kind: 'ConfidentialMintBurn' }\n  | {\n      __kind: 'ScaledUiAmountConfig';\n      authority: Address;\n      multiplier: number;\n      newMultiplierEffectiveTimestamp: number | bigint;\n      newMultiplier: number;\n    }\n  | {\n      __kind: 'PausableConfig';\n      authority: OptionOrNullable<Address>;\n      paused: boolean;\n    }\n  | { __kind: 'PausableAccount' };\n\nexport function getExtensionEncoder(): Encoder<ExtensionArgs> {\n  return getDiscriminatedUnionEncoder(\n    [\n      ['Uninitialized', getUnitEncoder()],\n      [\n        'TransferFeeConfig',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['transferFeeConfigAuthority', getAddressEncoder()],\n            ['withdrawWithheldAuthority', getAddressEncoder()],\n            ['withheldAmount', getU64Encoder()],\n            ['olderTransferFee', getTransferFeeEncoder()],\n            ['newerTransferFee', getTransferFeeEncoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'TransferFeeAmount',\n        addEncoderSizePrefix(\n          getStructEncoder([['withheldAmount', getU64Encoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'MintCloseAuthority',\n        addEncoderSizePrefix(\n          getStructEncoder([['closeAuthority', getAddressEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferMint',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['autoApproveNewAccounts', getBooleanEncoder()],\n            [\n              'auditorElgamalPubkey',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferAccount',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['approved', getBooleanEncoder()],\n            ['elgamalPubkey', getAddressEncoder()],\n            ['pendingBalanceLow', getEncryptedBalanceEncoder()],\n            ['pendingBalanceHigh', getEncryptedBalanceEncoder()],\n            ['availableBalance', getEncryptedBalanceEncoder()],\n            ['decryptableAvailableBalance', getDecryptableBalanceEncoder()],\n            ['allowConfidentialCredits', getBooleanEncoder()],\n            ['allowNonConfidentialCredits', getBooleanEncoder()],\n            ['pendingBalanceCreditCounter', getU64Encoder()],\n            ['maximumPendingBalanceCreditCounter', getU64Encoder()],\n            ['expectedPendingBalanceCreditCounter', getU64Encoder()],\n            ['actualPendingBalanceCreditCounter', getU64Encoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'DefaultAccountState',\n        addEncoderSizePrefix(\n          getStructEncoder([['state', getAccountStateEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'ImmutableOwner',\n        addEncoderSizePrefix(getStructEncoder([]), getU16Encoder()),\n      ],\n      [\n        'MemoTransfer',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['requireIncomingTransferMemos', getBooleanEncoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'NonTransferable',\n        addEncoderSizePrefix(getStructEncoder([]), getU16Encoder()),\n      ],\n      [\n        'InterestBearingConfig',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['rateAuthority', getAddressEncoder()],\n            ['initializationTimestamp', getU64Encoder()],\n            ['preUpdateAverageRate', getI16Encoder()],\n            ['lastUpdateTimestamp', getU64Encoder()],\n            ['currentRate', getI16Encoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'CpiGuard',\n        addEncoderSizePrefix(\n          getStructEncoder([['lockCpi', getBooleanEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'PermanentDelegate',\n        addEncoderSizePrefix(\n          getStructEncoder([['delegate', getAddressEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'NonTransferableAccount',\n        addEncoderSizePrefix(getStructEncoder([]), getU16Encoder()),\n      ],\n      [\n        'TransferHook',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['authority', getAddressEncoder()],\n            ['programId', getAddressEncoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'TransferHookAccount',\n        addEncoderSizePrefix(\n          getStructEncoder([['transferring', getBooleanEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferFee',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['elgamalPubkey', getAddressEncoder()],\n            ['harvestToMintEnabled', getBooleanEncoder()],\n            ['withheldAmount', getEncryptedBalanceEncoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferFeeAmount',\n        addEncoderSizePrefix(\n          getStructEncoder([['withheldAmount', getEncryptedBalanceEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'MetadataPointer',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'metadataAddress',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'TokenMetadata',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'updateAuthority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['mint', getAddressEncoder()],\n            ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n            ['symbol', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n            ['uri', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n            [\n              'additionalMetadata',\n              getMapEncoder(\n                addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),\n                addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())\n              ),\n            ],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'GroupPointer',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'groupAddress',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'TokenGroup',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'updateAuthority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['mint', getAddressEncoder()],\n            ['size', getU64Encoder()],\n            ['maxSize', getU64Encoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'GroupMemberPointer',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'memberAddress',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'TokenGroupMember',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['mint', getAddressEncoder()],\n            ['group', getAddressEncoder()],\n            ['memberNumber', getU64Encoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      ['ConfidentialMintBurn', getUnitEncoder()],\n      [\n        'ScaledUiAmountConfig',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['authority', getAddressEncoder()],\n            ['multiplier', getF64Encoder()],\n            ['newMultiplierEffectiveTimestamp', getU64Encoder()],\n            ['newMultiplier', getF64Encoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'PausableConfig',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['paused', getBooleanEncoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      ['PausableAccount', getUnitEncoder()],\n    ],\n    { size: getU16Encoder() }\n  );\n}\n\nexport function getExtensionDecoder(): Decoder<Extension> {\n  return getDiscriminatedUnionDecoder(\n    [\n      ['Uninitialized', getUnitDecoder()],\n      [\n        'TransferFeeConfig',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['transferFeeConfigAuthority', getAddressDecoder()],\n            ['withdrawWithheldAuthority', getAddressDecoder()],\n            ['withheldAmount', getU64Decoder()],\n            ['olderTransferFee', getTransferFeeDecoder()],\n            ['newerTransferFee', getTransferFeeDecoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'TransferFeeAmount',\n        addDecoderSizePrefix(\n          getStructDecoder([['withheldAmount', getU64Decoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'MintCloseAuthority',\n        addDecoderSizePrefix(\n          getStructDecoder([['closeAuthority', getAddressDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferMint',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['autoApproveNewAccounts', getBooleanDecoder()],\n            [\n              'auditorElgamalPubkey',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferAccount',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['approved', getBooleanDecoder()],\n            ['elgamalPubkey', getAddressDecoder()],\n            ['pendingBalanceLow', getEncryptedBalanceDecoder()],\n            ['pendingBalanceHigh', getEncryptedBalanceDecoder()],\n            ['availableBalance', getEncryptedBalanceDecoder()],\n            ['decryptableAvailableBalance', getDecryptableBalanceDecoder()],\n            ['allowConfidentialCredits', getBooleanDecoder()],\n            ['allowNonConfidentialCredits', getBooleanDecoder()],\n            ['pendingBalanceCreditCounter', getU64Decoder()],\n            ['maximumPendingBalanceCreditCounter', getU64Decoder()],\n            ['expectedPendingBalanceCreditCounter', getU64Decoder()],\n            ['actualPendingBalanceCreditCounter', getU64Decoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'DefaultAccountState',\n        addDecoderSizePrefix(\n          getStructDecoder([['state', getAccountStateDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'ImmutableOwner',\n        addDecoderSizePrefix(getStructDecoder([]), getU16Decoder()),\n      ],\n      [\n        'MemoTransfer',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['requireIncomingTransferMemos', getBooleanDecoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'NonTransferable',\n        addDecoderSizePrefix(getStructDecoder([]), getU16Decoder()),\n      ],\n      [\n        'InterestBearingConfig',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['rateAuthority', getAddressDecoder()],\n            ['initializationTimestamp', getU64Decoder()],\n            ['preUpdateAverageRate', getI16Decoder()],\n            ['lastUpdateTimestamp', getU64Decoder()],\n            ['currentRate', getI16Decoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'CpiGuard',\n        addDecoderSizePrefix(\n          getStructDecoder([['lockCpi', getBooleanDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'PermanentDelegate',\n        addDecoderSizePrefix(\n          getStructDecoder([['delegate', getAddressDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'NonTransferableAccount',\n        addDecoderSizePrefix(getStructDecoder([]), getU16Decoder()),\n      ],\n      [\n        'TransferHook',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['authority', getAddressDecoder()],\n            ['programId', getAddressDecoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'TransferHookAccount',\n        addDecoderSizePrefix(\n          getStructDecoder([['transferring', getBooleanDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferFee',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['elgamalPubkey', getAddressDecoder()],\n            ['harvestToMintEnabled', getBooleanDecoder()],\n            ['withheldAmount', getEncryptedBalanceDecoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferFeeAmount',\n        addDecoderSizePrefix(\n          getStructDecoder([['withheldAmount', getEncryptedBalanceDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'MetadataPointer',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'metadataAddress',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'TokenMetadata',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'updateAuthority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['mint', getAddressDecoder()],\n            ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n            ['symbol', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n            ['uri', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n            [\n              'additionalMetadata',\n              getMapDecoder(\n                addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()),\n                addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())\n              ),\n            ],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'GroupPointer',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'groupAddress',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'TokenGroup',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'updateAuthority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['mint', getAddressDecoder()],\n            ['size', getU64Decoder()],\n            ['maxSize', getU64Decoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'GroupMemberPointer',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'memberAddress',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'TokenGroupMember',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['mint', getAddressDecoder()],\n            ['group', getAddressDecoder()],\n            ['memberNumber', getU64Decoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      ['ConfidentialMintBurn', getUnitDecoder()],\n      [\n        'ScaledUiAmountConfig',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['authority', getAddressDecoder()],\n            ['multiplier', getF64Decoder()],\n            ['newMultiplierEffectiveTimestamp', getU64Decoder()],\n            ['newMultiplier', getF64Decoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'PausableConfig',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['paused', getBooleanDecoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      ['PausableAccount', getUnitDecoder()],\n    ],\n    { size: getU16Decoder() }\n  );\n}\n\nexport function getExtensionCodec(): Codec<ExtensionArgs, Extension> {\n  return combineCodec(getExtensionEncoder(), getExtensionDecoder());\n}\n\n// Data Enum Helpers.\nexport function extension(\n  kind: 'Uninitialized'\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'Uninitialized'>;\nexport function extension(\n  kind: 'TransferFeeConfig',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TransferFeeConfig'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TransferFeeConfig'>;\nexport function extension(\n  kind: 'TransferFeeAmount',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TransferFeeAmount'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TransferFeeAmount'>;\nexport function extension(\n  kind: 'MintCloseAuthority',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'MintCloseAuthority'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'MintCloseAuthority'>;\nexport function extension(\n  kind: 'ConfidentialTransferMint',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ConfidentialTransferMint'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ConfidentialTransferMint'\n>;\nexport function extension(\n  kind: 'ConfidentialTransferAccount',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ConfidentialTransferAccount'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ConfidentialTransferAccount'\n>;\nexport function extension(\n  kind: 'DefaultAccountState',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'DefaultAccountState'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'DefaultAccountState'>;\nexport function extension(\n  kind: 'ImmutableOwner',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ImmutableOwner'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'ImmutableOwner'>;\nexport function extension(\n  kind: 'MemoTransfer',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'MemoTransfer'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'MemoTransfer'>;\nexport function extension(\n  kind: 'NonTransferable',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'NonTransferable'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'NonTransferable'>;\nexport function extension(\n  kind: 'InterestBearingConfig',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'InterestBearingConfig'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'InterestBearingConfig'\n>;\nexport function extension(\n  kind: 'CpiGuard',\n  data: GetDiscriminatedUnionVariantContent<ExtensionArgs, '__kind', 'CpiGuard'>\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'CpiGuard'>;\nexport function extension(\n  kind: 'PermanentDelegate',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'PermanentDelegate'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'PermanentDelegate'>;\nexport function extension(\n  kind: 'NonTransferableAccount',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'NonTransferableAccount'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'NonTransferableAccount'\n>;\nexport function extension(\n  kind: 'TransferHook',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TransferHook'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TransferHook'>;\nexport function extension(\n  kind: 'TransferHookAccount',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TransferHookAccount'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TransferHookAccount'>;\nexport function extension(\n  kind: 'ConfidentialTransferFee',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ConfidentialTransferFee'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ConfidentialTransferFee'\n>;\nexport function extension(\n  kind: 'ConfidentialTransferFeeAmount',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ConfidentialTransferFeeAmount'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ConfidentialTransferFeeAmount'\n>;\nexport function extension(\n  kind: 'MetadataPointer',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'MetadataPointer'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'MetadataPointer'>;\nexport function extension(\n  kind: 'TokenMetadata',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TokenMetadata'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TokenMetadata'>;\nexport function extension(\n  kind: 'GroupPointer',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'GroupPointer'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'GroupPointer'>;\nexport function extension(\n  kind: 'TokenGroup',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TokenGroup'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TokenGroup'>;\nexport function extension(\n  kind: 'GroupMemberPointer',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'GroupMemberPointer'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'GroupMemberPointer'>;\nexport function extension(\n  kind: 'TokenGroupMember',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TokenGroupMember'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TokenGroupMember'>;\nexport function extension(\n  kind: 'ConfidentialMintBurn'\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ConfidentialMintBurn'\n>;\nexport function extension(\n  kind: 'ScaledUiAmountConfig',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ScaledUiAmountConfig'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ScaledUiAmountConfig'\n>;\nexport function extension(\n  kind: 'PausableConfig',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'PausableConfig'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'PausableConfig'>;\nexport function extension(\n  kind: 'PausableAccount'\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'PausableAccount'>;\nexport function extension<K extends ExtensionArgs['__kind'], Data>(\n  kind: K,\n  data?: Data\n) {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isExtension<K extends Extension['__kind']>(\n  kind: K,\n  value: Extension\n): value is Extension & { __kind: K } {\n  return value.__kind === kind;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getBooleanDecoder,\n    getBooleanEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Epoch, Slot } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_EPOCH_SCHEDULE_ADDRESS } from './sysvar';\n\ntype SysvarEpochScheduleSize = 33;\n\n/**\n * Includes the number of slots per epoch, timing of leader schedule selection, and information\n * about epoch warm-up time.\n */\nexport type SysvarEpochSchedule = Readonly<{\n    /**\n     * First normal-length epoch after the warmup period,\n     * log2(slotsPerEpoch) - log2(MINIMUM_SLOTS_PER_EPOCH)\n     */\n    firstNormalEpoch: Epoch;\n    /**\n     * The first slot after the warmup period, MINIMUM_SLOTS_PER_EPOCH * (2^(firstNormalEpoch) - 1)\n     */\n    firstNormalSlot: Slot;\n    /**\n     * A number of slots before beginning of an epoch to calculate a leader schedule for that\n     * epoch.\n     */\n    leaderScheduleSlotOffset: bigint;\n    /** The maximum number of slots in each epoch */\n    slotsPerEpoch: bigint;\n    /** Whether epochs start short and grow */\n    warmup: boolean;\n}>;\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarEpochSchedule} to a byte array\n * representing the `EpochSchedule` sysvar's account data.\n */\nexport function getSysvarEpochScheduleEncoder(): FixedSizeEncoder<SysvarEpochSchedule, SysvarEpochScheduleSize> {\n    return getStructEncoder([\n        ['slotsPerEpoch', getU64Encoder()],\n        ['leaderScheduleSlotOffset', getU64Encoder()],\n        ['warmup', getBooleanEncoder()],\n        ['firstNormalEpoch', getU64Encoder()],\n        ['firstNormalSlot', getU64Encoder()],\n    ]) as FixedSizeEncoder<SysvarEpochSchedule, SysvarEpochScheduleSize>;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `EpochSchedule`\n * sysvar's account data to a {@link SysvarEpochSchedule}.\n */\nexport function getSysvarEpochScheduleDecoder(): FixedSizeDecoder<SysvarEpochSchedule, SysvarEpochScheduleSize> {\n    return getStructDecoder([\n        ['slotsPerEpoch', getU64Decoder()],\n        ['leaderScheduleSlotOffset', getU64Decoder()],\n        ['warmup', getBooleanDecoder()],\n        ['firstNormalEpoch', getU64Decoder()],\n        ['firstNormalSlot', getU64Decoder()],\n    ]) as FixedSizeDecoder<SysvarEpochSchedule, SysvarEpochScheduleSize>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarEpochSchedule}\n *\n * @see {@link getSysvarEpochScheduleDecoder}\n * @see {@link getSysvarEpochScheduleEncoder}\n */\nexport function getSysvarEpochScheduleCodec(): FixedSizeCodec<\n    SysvarEpochSchedule,\n    SysvarEpochSchedule,\n    SysvarEpochScheduleSize\n> {\n    return combineCodec(getSysvarEpochScheduleEncoder(), getSysvarEpochScheduleDecoder());\n}\n\n/**\n * Fetches the `EpochSchedule` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarEpochSchedule(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarEpochSchedule> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_EPOCH_SCHEDULE_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarEpochScheduleDecoder());\n    return decoded.data;\n}\n","import { Chain, getAddress, Hex, LocalAccount, toHex, Transport } from \"viem\";\nimport { getNetworkId } from \"../../../shared\";\nimport {\n  authorizationTypes,\n  isAccount,\n  isSignerWallet,\n  SignerWallet,\n} from \"../../../types/shared/evm\";\nimport { ExactEvmPayloadAuthorization, PaymentRequirements } from \"../../../types/verify\";\n\n/**\n * Signs an EIP-3009 authorization for USDC transfer\n *\n * @param walletClient - The wallet client that will sign the authorization\n * @param params - The authorization parameters containing transfer details\n * @param params.from - The address tokens will be transferred from\n * @param params.to - The address tokens will be transferred to\n * @param params.value - The amount of USDC tokens to transfer (in base units)\n * @param params.validAfter - Unix timestamp after which the authorization becomes valid\n * @param params.validBefore - Unix timestamp before which the authorization is valid\n * @param params.nonce - Random 32-byte nonce to prevent replay attacks\n * @param paymentRequirements - The payment requirements containing asset and network information\n * @param paymentRequirements.asset - The address of the USDC contract\n * @param paymentRequirements.network - The network where the USDC contract exists\n * @param paymentRequirements.extra - The extra information containing the name and version of the ERC20 contract\n * @returns The signature for the authorization\n */\nexport async function signAuthorization<transport extends Transport, chain extends Chain>(\n  walletClient: SignerWallet<chain, transport> | LocalAccount,\n  { from, to, value, validAfter, validBefore, nonce }: ExactEvmPayloadAuthorization,\n  { asset, network, extra }: PaymentRequirements,\n): Promise<{ signature: Hex }> {\n  const chainId = getNetworkId(network);\n  const name = extra?.name;\n  const version = extra?.version;\n\n  const data = {\n    types: authorizationTypes,\n    domain: {\n      name,\n      version,\n      chainId,\n      verifyingContract: getAddress(asset),\n    },\n    primaryType: \"TransferWithAuthorization\" as const,\n    message: {\n      from: getAddress(from),\n      to: getAddress(to),\n      value,\n      validAfter,\n      validBefore,\n      nonce: nonce,\n    },\n  };\n\n  if (isSignerWallet(walletClient)) {\n    const signature = await walletClient.signTypedData(data);\n    return {\n      signature,\n    };\n  } else if (isAccount(walletClient) && walletClient.signTypedData) {\n    const signature = await walletClient.signTypedData(data);\n    return {\n      signature,\n    };\n  } else {\n    throw new Error(\"Invalid wallet client provided does not support signTypedData\");\n  }\n}\n\n/**\n * Generates a random 32-byte nonce for use in authorization signatures\n *\n * @returns A random 32-byte nonce as a hex string\n */\nexport function createNonce(): Hex {\n  const cryptoObj =\n    typeof globalThis.crypto !== \"undefined\" &&\n    typeof globalThis.crypto.getRandomValues === \"function\"\n      ? globalThis.crypto\n      : // Dynamic require is needed to support node.js\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        require(\"crypto\").webcrypto;\n  return toHex(cryptoObj.getRandomValues(new Uint8Array(32)));\n}\n","import {\n    getSolanaErrorFromJsonRpcError,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID,\n    SolanaError,\n} from '@solana/errors';\nimport { AbortController } from '@solana/event-target-impl';\nimport { safeRace } from '@solana/promises';\nimport { createRpcMessage, RpcRequest, RpcResponseData, RpcResponseTransformer } from '@solana/rpc-spec-types';\nimport { DataPublisher } from '@solana/subscribable';\nimport { demultiplexDataPublisher } from '@solana/subscribable';\n\nimport { RpcSubscriptionChannelEvents } from './rpc-subscriptions-channel';\nimport { RpcSubscriptionsChannel } from './rpc-subscriptions-channel';\n\ntype Config<TNotification> = Readonly<{\n    channel: RpcSubscriptionsChannel<unknown, RpcNotification<TNotification> | RpcResponseData<RpcSubscriptionId>>;\n    responseTransformer?: RpcResponseTransformer;\n    signal: AbortSignal;\n    subscribeRequest: RpcRequest;\n    unsubscribeMethodName: string;\n}>;\n\ntype RpcNotification<TNotification> = Readonly<{\n    method: string;\n    params: Readonly<{\n        result: TNotification;\n        subscription: number;\n    }>;\n}>;\n\ntype RpcSubscriptionId = number;\n\ntype RpcSubscriptionNotificationEvents<TNotification> = Omit<RpcSubscriptionChannelEvents<TNotification>, 'message'> & {\n    notification: TNotification;\n};\n\nconst subscriberCountBySubscriptionIdByChannel = new WeakMap<WeakKey, Record<number, number>>();\nfunction decrementSubscriberCountAndReturnNewCount(channel: WeakKey, subscriptionId?: number): number | undefined {\n    return augmentSubscriberCountAndReturnNewCount(-1, channel, subscriptionId);\n}\nfunction incrementSubscriberCount(channel: WeakKey, subscriptionId?: number): void {\n    augmentSubscriberCountAndReturnNewCount(1, channel, subscriptionId);\n}\nfunction getSubscriberCountBySubscriptionIdForChannel(channel: WeakKey): Record<number, number> {\n    let subscriberCountBySubscriptionId = subscriberCountBySubscriptionIdByChannel.get(channel);\n    if (!subscriberCountBySubscriptionId) {\n        subscriberCountBySubscriptionIdByChannel.set(channel, (subscriberCountBySubscriptionId = {}));\n    }\n    return subscriberCountBySubscriptionId;\n}\nfunction augmentSubscriberCountAndReturnNewCount(\n    amount: -1 | 1,\n    channel: WeakKey,\n    subscriptionId?: number,\n): number | undefined {\n    if (subscriptionId === undefined) {\n        return;\n    }\n    const subscriberCountBySubscriptionId = getSubscriberCountBySubscriptionIdForChannel(channel);\n    if (!subscriberCountBySubscriptionId[subscriptionId] && amount > 0) {\n        subscriberCountBySubscriptionId[subscriptionId] = 0;\n    }\n    const newCount = amount + subscriberCountBySubscriptionId[subscriptionId];\n    if (newCount <= 0) {\n        delete subscriberCountBySubscriptionId[subscriptionId];\n    } else {\n        subscriberCountBySubscriptionId[subscriptionId] = newCount;\n    }\n    return newCount;\n}\n\nconst cache = new WeakMap();\nfunction getMemoizedDemultiplexedNotificationPublisherFromChannelAndResponseTransformer<TNotification>(\n    channel: RpcSubscriptionsChannel<unknown, RpcNotification<TNotification>>,\n    subscribeRequest: RpcRequest,\n    responseTransformer?: RpcResponseTransformer,\n): DataPublisher<{\n    [channelName: `notification:${number}`]: TNotification;\n}> {\n    let publisherByResponseTransformer = cache.get(channel);\n    if (!publisherByResponseTransformer) {\n        cache.set(channel, (publisherByResponseTransformer = new WeakMap()));\n    }\n    const responseTransformerKey = responseTransformer ?? channel;\n    let publisher = publisherByResponseTransformer.get(responseTransformerKey);\n    if (!publisher) {\n        publisherByResponseTransformer.set(\n            responseTransformerKey,\n            (publisher = demultiplexDataPublisher(channel, 'message', rawMessage => {\n                const message = rawMessage as RpcNotification<unknown> | RpcResponseData<unknown>;\n                if (!('method' in message)) {\n                    return;\n                }\n                const transformedNotification = responseTransformer\n                    ? responseTransformer(message.params.result, subscribeRequest)\n                    : message.params.result;\n                return [`notification:${message.params.subscription}`, transformedNotification];\n            })),\n        );\n    }\n    return publisher;\n}\n\n/**\n * Given a channel, this function executes the particular subscription plan required by the Solana\n * JSON RPC Subscriptions API.\n *\n * @param config\n *\n * 1. Calls the `subscribeRequest` on the remote RPC\n * 2. Waits for a response containing the subscription id\n * 3. Returns a {@link DataPublisher} that publishes notifications related to that subscriptions id,\n *    filtering out all others\n * 4. Calls the `unsubscribeMethodName` on the remote RPC when the abort signal is fired.\n */\nexport async function executeRpcPubSubSubscriptionPlan<TNotification>({\n    channel,\n    responseTransformer,\n    signal,\n    subscribeRequest,\n    unsubscribeMethodName,\n}: Config<TNotification>): Promise<DataPublisher<RpcSubscriptionNotificationEvents<TNotification>>> {\n    let subscriptionId: number | undefined;\n    channel.on(\n        'error',\n        () => {\n            // An error on the channel indicates that the subscriptions are dead.\n            // There is no longer any sense hanging on to subscription ids.\n            // Erasing it here will prevent the unsubscribe code from running.\n            subscriptionId = undefined;\n            subscriberCountBySubscriptionIdByChannel.delete(channel);\n        },\n        { signal },\n    );\n    /**\n     * STEP 1\n     * Create a promise that rejects if this subscription is aborted and sends\n     * the unsubscribe message if the subscription is active at that time.\n     */\n    const abortPromise = new Promise<never>((_, reject) => {\n        function handleAbort(this: AbortSignal) {\n            /**\n             * Because of https://github.com/solana-labs/solana/pull/18943, two subscriptions for\n             * materially the same notification will be coalesced on the server. This means they\n             * will be assigned the same subscription id, and will occupy one subscription slot. We\n             * must be careful not to send the unsubscribe message until the last subscriber aborts.\n             */\n            if (decrementSubscriberCountAndReturnNewCount(channel, subscriptionId) === 0) {\n                const unsubscribePayload = createRpcMessage({\n                    methodName: unsubscribeMethodName,\n                    params: [subscriptionId],\n                });\n                subscriptionId = undefined;\n                channel.send(unsubscribePayload).catch(() => {});\n            }\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            reject(this.reason);\n        }\n        if (signal.aborted) {\n            handleAbort.call(signal);\n        } else {\n            signal.addEventListener('abort', handleAbort);\n        }\n    });\n    /**\n     * STEP 2\n     * Send the subscription request.\n     */\n    const subscribePayload = createRpcMessage(subscribeRequest);\n    await channel.send(subscribePayload);\n    /**\n     * STEP 3\n     * Wait for the acknowledgement from the server with the subscription id.\n     */\n    const subscriptionIdPromise = new Promise<RpcSubscriptionId>((resolve, reject) => {\n        const abortController = new AbortController();\n        signal.addEventListener('abort', abortController.abort.bind(abortController));\n        const options = { signal: abortController.signal } as const;\n        channel.on(\n            'error',\n            err => {\n                abortController.abort();\n                reject(err);\n            },\n            options,\n        );\n        channel.on(\n            'message',\n            message => {\n                if (message && typeof message === 'object' && 'id' in message && message.id === subscribePayload.id) {\n                    abortController.abort();\n                    if ('error' in message) {\n                        reject(getSolanaErrorFromJsonRpcError(message.error));\n                    } else {\n                        resolve(message.result);\n                    }\n                }\n            },\n            options,\n        );\n    });\n    subscriptionId = await safeRace([abortPromise, subscriptionIdPromise]);\n    if (subscriptionId == null) {\n        throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID);\n    }\n    incrementSubscriberCount(channel, subscriptionId);\n    /**\n     * STEP 4\n     * Filter out notifications unrelated to this subscription.\n     */\n    const notificationPublisher = getMemoizedDemultiplexedNotificationPublisherFromChannelAndResponseTransformer(\n        channel,\n        subscribeRequest,\n        responseTransformer,\n    );\n    const notificationKey = `notification:${subscriptionId}` as const;\n    return {\n        on(type, listener, options) {\n            switch (type) {\n                case 'notification':\n                    return notificationPublisher.on(\n                        notificationKey,\n                        listener as (data: RpcSubscriptionNotificationEvents<TNotification>['notification']) => void,\n                        options,\n                    );\n                case 'error':\n                    return channel.on(\n                        'error',\n                        listener as (data: RpcSubscriptionNotificationEvents<TNotification>['error']) => void,\n                        options,\n                    );\n                default:\n                    throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED, {\n                        channelName: type,\n                        supportedChannelNames: ['notification', 'error'],\n                    });\n            }\n        },\n    };\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Slot } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_LAST_RESTART_SLOT_ADDRESS } from './sysvar';\n\ntype SysvarLastRestartSlotSize = 8;\n\n/**\n * Information about the last restart slot (hard fork).\n *\n * The `LastRestartSlot` sysvar provides access to the last restart slot kept in the bank fork for\n * the slot on the fork that executes the current transaction. In case there was no fork it returns\n * `0`.\n */\nexport type SysvarLastRestartSlot = Readonly<{\n    /** The last restart {@link Slot} */\n    lastRestartSlot: Slot;\n}>;\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarLastRestartSlot} to a byte array\n * representing the `LastRestartSlot` sysvar's account data.\n */\nexport function getSysvarLastRestartSlotEncoder(): FixedSizeEncoder<SysvarLastRestartSlot, SysvarLastRestartSlotSize> {\n    return getStructEncoder([['lastRestartSlot', getU64Encoder()]]) as FixedSizeEncoder<\n        SysvarLastRestartSlot,\n        SysvarLastRestartSlotSize\n    >;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `LastRestartSlot`\n * sysvar's account data to a {@link SysvarLastRestartSlot}.\n */\nexport function getSysvarLastRestartSlotDecoder(): FixedSizeDecoder<SysvarLastRestartSlot, SysvarLastRestartSlotSize> {\n    return getStructDecoder([['lastRestartSlot', getU64Decoder()]]) as FixedSizeDecoder<\n        SysvarLastRestartSlot,\n        SysvarLastRestartSlotSize\n    >;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarLastRestartSlot}\n *\n * @see {@link getSysvarLastRestartSlotDecoder}\n * @see {@link getSysvarLastRestartSlotEncoder}\n */\nexport function getSysvarLastRestartSlotCodec(): FixedSizeCodec<\n    SysvarLastRestartSlot,\n    SysvarLastRestartSlot,\n    SysvarLastRestartSlotSize\n> {\n    return combineCodec(getSysvarLastRestartSlotEncoder(), getSysvarLastRestartSlotDecoder());\n}\n\n/**\n * Fetches the `LastRestartSlot` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarLastRestartSlot(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarLastRestartSlot> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_LAST_RESTART_SLOT_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarLastRestartSlotDecoder());\n    return decoded.data;\n}\n","import { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\n\nexport type ChannelPoolEntry = {\n    channel: PromiseLike<RpcSubscriptionsChannel<unknown, unknown>> | RpcSubscriptionsChannel<unknown, unknown>;\n    readonly dispose: () => void;\n    subscriptionCount: number;\n};\n\ntype ChannelPool = { readonly entries: ChannelPoolEntry[]; freeChannelIndex: number };\n\nexport function createChannelPool(): ChannelPool {\n    return {\n        entries: [],\n        freeChannelIndex: -1,\n    };\n}\n","import { isJsonRpcPayload } from '@solana/rpc-spec';\n\nconst SOLANA_RPC_METHODS = [\n    'getAccountInfo',\n    'getBalance',\n    'getBlock',\n    'getBlockCommitment',\n    'getBlockHeight',\n    'getBlockProduction',\n    'getBlocks',\n    'getBlocksWithLimit',\n    'getBlockTime',\n    'getClusterNodes',\n    'getEpochInfo',\n    'getEpochSchedule',\n    'getFeeForMessage',\n    'getFirstAvailableBlock',\n    'getGenesisHash',\n    'getHealth',\n    'getHighestSnapshotSlot',\n    'getIdentity',\n    'getInflationGovernor',\n    'getInflationRate',\n    'getInflationReward',\n    'getLargestAccounts',\n    'getLatestBlockhash',\n    'getLeaderSchedule',\n    'getMaxRetransmitSlot',\n    'getMaxShredInsertSlot',\n    'getMinimumBalanceForRentExemption',\n    'getMultipleAccounts',\n    'getProgramAccounts',\n    'getRecentPerformanceSamples',\n    'getRecentPrioritizationFees',\n    'getSignaturesForAddress',\n    'getSignatureStatuses',\n    'getSlot',\n    'getSlotLeader',\n    'getSlotLeaders',\n    'getStakeMinimumDelegation',\n    'getSupply',\n    'getTokenAccountBalance',\n    'getTokenAccountsByDelegate',\n    'getTokenAccountsByOwner',\n    'getTokenLargestAccounts',\n    'getTokenSupply',\n    'getTransaction',\n    'getTransactionCount',\n    'getVersion',\n    'getVoteAccounts',\n    'index',\n    'isBlockhashValid',\n    'minimumLedgerSlot',\n    'requestAirdrop',\n    'sendTransaction',\n    'simulateTransaction',\n] as const;\n\n/**\n * Helper function that checks if a given `RpcRequest` comes from the Solana RPC API.\n */\nexport function isSolanaRequest(payload: unknown): payload is Readonly<{\n    jsonrpc: '2.0';\n    method: (typeof SOLANA_RPC_METHODS)[number];\n    params: unknown;\n}> {\n    return isJsonRpcPayload(payload) && (SOLANA_RPC_METHODS as readonly string[]).includes(payload.method);\n}\n","import type { RpcRequest, RpcRequestTransformer } from '@solana/rpc-spec-types';\nimport type { Commitment } from '@solana/rpc-types';\n\nimport { applyDefaultCommitment } from './request-transformer-default-commitment-internal';\n\n/**\n * Creates a transformer that adds the provided default commitment to the configuration object of the request when applicable.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { getDefaultCommitmentRequestTransformer, OPTIONS_OBJECT_POSITION_BY_METHOD } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getDefaultCommitmentRequestTransformer({\n *     defaultCommitment: 'confirmed',\n *     optionsObjectPositionByMethod: OPTIONS_OBJECT_POSITION_BY_METHOD,\n * });\n */\nexport function getDefaultCommitmentRequestTransformer({\n    defaultCommitment,\n    optionsObjectPositionByMethod,\n}: Readonly<{\n    defaultCommitment?: Commitment;\n    optionsObjectPositionByMethod: Record<string, number>;\n}>): RpcRequestTransformer {\n    return <TParams>(request: RpcRequest<TParams>): RpcRequest => {\n        const { params, methodName } = request;\n\n        // We only apply default commitment to array parameters.\n        if (!Array.isArray(params)) {\n            return request;\n        }\n\n        // Find the position of the options object in the parameters and abort if not found.\n        const optionsObjectPositionInParams = optionsObjectPositionByMethod[methodName];\n        if (optionsObjectPositionInParams == null) {\n            return request;\n        }\n\n        return Object.freeze({\n            methodName,\n            params: applyDefaultCommitment({\n                commitmentPropertyName: methodName === 'sendTransaction' ? 'preflightCommitment' : 'commitment',\n                optionsObjectPositionInParams,\n                overrideCommitment: defaultCommitment,\n                params,\n            }),\n        });\n    };\n}\n","import { AbortController } from '@solana/event-target-impl';\nimport { RpcSubscriptionsChannelCreator } from '@solana/rpc-subscriptions-spec';\n\nimport { ChannelPoolEntry, createChannelPool } from './rpc-subscriptions-channel-pool-internal';\n\ntype Config = Readonly<{\n    maxSubscriptionsPerChannel: number;\n    minChannels: number;\n}>;\n\n/**\n * Given a channel creator, will return a new channel creator with the following behavior.\n *\n * 1. When called, returns a {@link RpcSubscriptionsChannel}. Adds that channel to a pool.\n * 2. When called again, creates and returns new\n *    {@link RpcSubscriptionChannel | RpcSubscriptionChannels} up to the number specified by\n *    `minChannels`.\n * 3. When `minChannels` channels have been created, subsequent calls vend whichever existing\n *    channel from the pool has the fewest subscribers, or the next one in rotation in the event of\n *    a tie.\n * 4. Once all channels carry the number of subscribers specified by the number\n *    `maxSubscriptionsPerChannel`, new channels in excess of `minChannel` will be created,\n *    returned, and added to the pool.\n * 5. A channel will be destroyed once all of its subscribers' abort signals fire.\n */\nexport function getChannelPoolingChannelCreator<\n    TChannelCreator extends RpcSubscriptionsChannelCreator<unknown, unknown>,\n>(createChannel: TChannelCreator, { maxSubscriptionsPerChannel, minChannels }: Config): TChannelCreator {\n    const pool = createChannelPool();\n    /**\n     * This function advances the free channel index to the pool entry with the most capacity. It\n     * sets the index to `-1` if all channels are full.\n     */\n    function recomputeFreeChannelIndex() {\n        if (pool.entries.length < minChannels) {\n            // Don't set the free channel index until the pool fills up; we want to keep creating\n            // channels before we start rotating among them.\n            pool.freeChannelIndex = -1;\n            return;\n        }\n        let mostFreeChannel: Readonly<{ poolIndex: number; subscriptionCount: number }> | undefined;\n        for (let ii = 0; ii < pool.entries.length; ii++) {\n            const nextPoolIndex = (pool.freeChannelIndex + ii + 2) % pool.entries.length;\n            const nextPoolEntry =\n                // Start from the item two positions after the current item. This way, the\n                // search will finish on the item after the current one. This ensures that, if\n                // any channels tie for having the most capacity, the one that will be chosen is\n                // the one immediately to the current one's right (wrapping around).\n                pool.entries[nextPoolIndex];\n            if (\n                nextPoolEntry.subscriptionCount < maxSubscriptionsPerChannel &&\n                (!mostFreeChannel || mostFreeChannel.subscriptionCount >= nextPoolEntry.subscriptionCount)\n            ) {\n                mostFreeChannel = {\n                    poolIndex: nextPoolIndex,\n                    subscriptionCount: nextPoolEntry.subscriptionCount,\n                };\n            }\n        }\n        pool.freeChannelIndex = mostFreeChannel?.poolIndex ?? -1;\n    }\n    return function getExistingChannelWithMostCapacityOrCreateChannel({ abortSignal }) {\n        let poolEntry: ChannelPoolEntry;\n        function destroyPoolEntry() {\n            const index = pool.entries.findIndex(entry => entry === poolEntry);\n            pool.entries.splice(index, 1);\n            poolEntry.dispose();\n            recomputeFreeChannelIndex();\n        }\n        if (pool.freeChannelIndex === -1) {\n            const abortController = new AbortController();\n            const newChannelPromise = createChannel({ abortSignal: abortController.signal });\n            newChannelPromise\n                .then(newChannel => {\n                    newChannel.on('error', destroyPoolEntry, { signal: abortController.signal });\n                })\n                .catch(destroyPoolEntry);\n            poolEntry = {\n                channel: newChannelPromise,\n                dispose() {\n                    abortController.abort();\n                },\n                subscriptionCount: 0,\n            };\n            pool.entries.push(poolEntry);\n        } else {\n            poolEntry = pool.entries[pool.freeChannelIndex];\n        }\n        /**\n         * A note about subscription counts.\n         * Because of https://github.com/solana-labs/solana/pull/18943, two subscriptions for\n         * materially the same notification will be coalesced on the server. This means they will be\n         * assigned the same subscription id, and will occupy one subscription slot. We can't tell,\n         * from here, whether a subscription will be treated in this way or not, so we\n         * unconditionally increment the subscription count every time a subscription request is\n         * made. This may result in subscription channels being treated as out-of-capacity when in\n         * fact they are not.\n         */\n        poolEntry.subscriptionCount++;\n        abortSignal.addEventListener('abort', function destroyConsumer() {\n            poolEntry.subscriptionCount--;\n            if (poolEntry.subscriptionCount === 0) {\n                destroyPoolEntry();\n            } else if (pool.freeChannelIndex !== -1) {\n                // Back the free channel index up one position, and recompute it.\n                pool.freeChannelIndex--;\n                recomputeFreeChannelIndex();\n            }\n        });\n        recomputeFreeChannelIndex();\n        return poolEntry.channel;\n    } as TChannelCreator;\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { COMPUTE_BUDGET_PROGRAM_ADDRESS } from '../programs';\n\nexport const SET_COMPUTE_UNIT_LIMIT_DISCRIMINATOR = 2;\n\nexport function getSetComputeUnitLimitDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_COMPUTE_UNIT_LIMIT_DISCRIMINATOR);\n}\n\nexport type SetComputeUnitLimitInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<TRemainingAccounts>;\n\nexport type SetComputeUnitLimitInstructionData = {\n  discriminator: number;\n  /** Transaction-wide compute unit limit. */\n  units: number;\n};\n\nexport type SetComputeUnitLimitInstructionDataArgs = {\n  /** Transaction-wide compute unit limit. */\n  units: number;\n};\n\nexport function getSetComputeUnitLimitInstructionDataEncoder(): FixedSizeEncoder<SetComputeUnitLimitInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['units', getU32Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_COMPUTE_UNIT_LIMIT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetComputeUnitLimitInstructionDataDecoder(): FixedSizeDecoder<SetComputeUnitLimitInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['units', getU32Decoder()],\n  ]);\n}\n\nexport function getSetComputeUnitLimitInstructionDataCodec(): FixedSizeCodec<\n  SetComputeUnitLimitInstructionDataArgs,\n  SetComputeUnitLimitInstructionData\n> {\n  return combineCodec(\n    getSetComputeUnitLimitInstructionDataEncoder(),\n    getSetComputeUnitLimitInstructionDataDecoder()\n  );\n}\n\nexport type SetComputeUnitLimitInput = {\n  units: SetComputeUnitLimitInstructionDataArgs['units'];\n};\n\nexport function getSetComputeUnitLimitInstruction<\n  TProgramAddress extends Address = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n>(\n  input: SetComputeUnitLimitInput,\n  config?: { programAddress?: TProgramAddress }\n): SetComputeUnitLimitInstruction<TProgramAddress> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? COMPUTE_BUDGET_PROGRAM_ADDRESS;\n\n  // Original args.\n  const args = { ...input };\n\n  return Object.freeze({\n    data: getSetComputeUnitLimitInstructionDataEncoder().encode(\n      args as SetComputeUnitLimitInstructionDataArgs\n    ),\n    programAddress,\n  } as SetComputeUnitLimitInstruction<TProgramAddress>);\n}\n\nexport type ParsedSetComputeUnitLimitInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n> = {\n  programAddress: Address<TProgram>;\n  data: SetComputeUnitLimitInstructionData;\n};\n\nexport function parseSetComputeUnitLimitInstruction<TProgram extends string>(\n  instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>\n): ParsedSetComputeUnitLimitInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getSetComputeUnitLimitInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","import fastStableStringify from '@solana/fast-stable-stringify';\nimport { isJsonRpcPayload } from '@solana/rpc-spec';\n\nexport function getSolanaRpcPayloadDeduplicationKey(payload: unknown): string | undefined {\n    return isJsonRpcPayload(payload) ? fastStableStringify([payload.method, payload.params]) : undefined;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    getArrayDecoder,\n    getArrayEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport {\n    type Blockhash,\n    getBlockhashDecoder,\n    getBlockhashEncoder,\n    getDefaultLamportsDecoder,\n    getDefaultLamportsEncoder,\n    type Lamports,\n} from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_RECENT_BLOCKHASHES_ADDRESS } from './sysvar';\n\ntype FeeCalculator = Readonly<{\n    /**\n     * The current cost of a signature.\n     *\n     * This amount may increase/decrease over time based on cluster processing load\n     */\n    lamportsPerSignature: Lamports;\n}>;\ntype Entry = Readonly<{\n    blockhash: Blockhash;\n    feeCalculator: FeeCalculator;\n}>;\n\n/**\n * Information about recent blocks and their fee calculators.\n *\n * @deprecated Transaction fees should be determined with the\n * {@link GetFeeForMessageApi.getFeeForMessage} RPC method. For additional context see the\n * [Comprehensive Compute Fees proposal](https://docs.anza.xyz/proposals/comprehensive-compute-fees/).\n */\nexport type SysvarRecentBlockhashes = Entry[];\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarRecentBlockhashes} to a byte array\n * representing the `RecentBlockhashes` sysvar's account data.\n *\n * @deprecated Transaction fees should be determined with the\n * {@link GetFeeForMessageApi.getFeeForMessage} RPC method. For additional context see the\n * [Comprehensive Compute Fees proposal](https://docs.anza.xyz/proposals/comprehensive-compute-fees/).\n */\nexport function getSysvarRecentBlockhashesEncoder(): VariableSizeEncoder<SysvarRecentBlockhashes> {\n    return getArrayEncoder(\n        getStructEncoder([\n            ['blockhash', getBlockhashEncoder()],\n            ['feeCalculator', getStructEncoder([['lamportsPerSignature', getDefaultLamportsEncoder()]])],\n        ]),\n    );\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `RecentBlockhashes`\n * sysvar's account data to a {@link SysvarRecentBlockhashes}.\n *\n * @deprecated Transaction fees should be determined with the\n * {@link GetFeeForMessageApi.getFeeForMessage} RPC method. For additional context see the\n * [Comprehensive Compute Fees proposal](https://docs.anza.xyz/proposals/comprehensive-compute-fees/).\n */\nexport function getSysvarRecentBlockhashesDecoder(): VariableSizeDecoder<SysvarRecentBlockhashes> {\n    return getArrayDecoder(\n        getStructDecoder([\n            ['blockhash', getBlockhashDecoder()],\n            ['feeCalculator', getStructDecoder([['lamportsPerSignature', getDefaultLamportsDecoder()]])],\n        ]),\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarRecentBlockhashes}\n *\n * @deprecated Transaction fees should be determined with the\n * {@link GetFeeForMessageApi.getFeeForMessage} RPC method. For additional context see the\n * [Comprehensive Compute Fees proposal](https://docs.anza.xyz/proposals/comprehensive-compute-fees/).\n *\n * @see {@link getSysvarRecentBlockhashesDecoder}\n * @see {@link getSysvarRecentBlockhashesEncoder}\n */\nexport function getSysvarRecentBlockhashesCodec(): VariableSizeCodec<SysvarRecentBlockhashes> {\n    return combineCodec(getSysvarRecentBlockhashesEncoder(), getSysvarRecentBlockhashesDecoder());\n}\n\n/**\n * Fetches the `RecentBlockhashes` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n *\n * @deprecated Transaction fees should be determined with the\n * {@link GetFeeForMessageApi.getFeeForMessage} RPC method. For additional context see the\n * [Comprehensive Compute Fees proposal](https://docs.anza.xyz/proposals/comprehensive-compute-fees/).\n */\nexport async function fetchSysvarRecentBlockhashes(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarRecentBlockhashes> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_RECENT_BLOCKHASHES_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarRecentBlockhashesDecoder());\n    return decoded.data;\n}\n","import { pipe } from '@solana/functional';\nimport { createHttpTransport, createHttpTransportForSolanaRpc } from '@solana/rpc-transport-http';\nimport type { ClusterUrl } from '@solana/rpc-types';\n\nimport { RpcTransportFromClusterUrl } from './rpc-clusters';\nimport { getRpcTransportWithRequestCoalescing } from './rpc-request-coalescer';\nimport { getSolanaRpcPayloadDeduplicationKey } from './rpc-request-deduplication';\n\ntype RpcTransportConfig = Parameters<typeof createHttpTransport>[0];\ninterface DefaultRpcTransportConfig<TClusterUrl extends ClusterUrl> extends RpcTransportConfig {\n    url: TClusterUrl;\n}\n\nfunction normalizeHeaders<T extends Record<string, string>>(\n    headers: T,\n): { [K in string & keyof T as Lowercase<K>]: T[K] } {\n    const out: Record<string, string> = {};\n    for (const headerName in headers) {\n        // Lowercasing header names makes it easier to override user-supplied headers.\n        out[headerName.toLowerCase()] = headers[headerName];\n    }\n    return out as { [K in string & keyof T as Lowercase<K>]: T[K] };\n}\n\n/**\n * Creates a {@link RpcTransport} with some default behaviours.\n *\n * The default behaviours include:\n * - An automatically-set `Solana-Client` request header, containing the version of `@solana/kit`\n * - Logic that coalesces multiple calls in the same runloop, for the same methods with the same\n *   arguments, into a single network request.\n * - [node-only] An automatically-set `Accept-Encoding` request header asking the server to compress\n *   responses\n *\n * @param config\n */\nexport function createDefaultRpcTransport<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcTransportConfig<TClusterUrl>,\n): RpcTransportFromClusterUrl<TClusterUrl> {\n    return pipe(\n        createHttpTransportForSolanaRpc({\n            ...config,\n            headers: {\n                ...(__NODEJS__ &&\n                    ({\n                        // Keep these headers lowercase so they will be overridden by any user-supplied headers below.\n                        'accept-encoding':\n                            // Natively supported by Node LTS v20.18.0 and above.\n                            'br,gzip,deflate', // Brotli, gzip, and Deflate, in that order.\n                    } as { [overrideHeader: string]: string })),\n                ...(config.headers ? normalizeHeaders(config.headers) : undefined),\n                ...({\n                    // Keep these headers lowercase so they will override any user-supplied headers above.\n                    'solana-client': __VERSION__ ? `js/${__VERSION__}` : 'UNKNOWN',\n                } as { [overrideHeader: string]: string }),\n            },\n        }) as RpcTransportFromClusterUrl<TClusterUrl>,\n        transport => getRpcTransportWithRequestCoalescing(transport, getSolanaRpcPayloadDeduplicationKey),\n    );\n}\n","import { TypedEventEmitter, TypedEventTarget } from './event-emitter';\n\ntype UnsubscribeFn = () => void;\n\n/**\n * Represents an object with an `on` function that you can call to subscribe to certain data over a\n * named channel.\n *\n * @example\n * ```ts\n * let dataPublisher: DataPublisher<{ error: SolanaError }>;\n * dataPublisher.on('data', handleData); // ERROR. `data` is not a known channel name.\n * dataPublisher.on('error', e => {\n *     console.error(e);\n * }); // OK.\n * ```\n */\nexport interface DataPublisher<TDataByChannelName extends Record<string, unknown> = Record<string, unknown>> {\n    /**\n     * Call this to subscribe to data over a named channel.\n     *\n     * @param channelName The name of the channel on which to subscribe for messages\n     * @param subscriber The function to call when a message becomes available\n     * @param options.signal An abort signal you can fire to unsubscribe\n     *\n     * @returns A function that you can call to unsubscribe\n     */\n    on<const TChannelName extends keyof TDataByChannelName>(\n        channelName: TChannelName,\n        subscriber: (data: TDataByChannelName[TChannelName]) => void,\n        options?: { signal: AbortSignal },\n    ): UnsubscribeFn;\n}\n\n/**\n * Returns an object with an `on` function that you can call to subscribe to certain data over a\n * named channel.\n *\n * The `on` function returns an unsubscribe function.\n *\n * @example\n * ```ts\n * const socketDataPublisher = getDataPublisherFromEventEmitter(new WebSocket('wss://api.devnet.solana.com'));\n * const unsubscribe = socketDataPublisher.on('message', message => {\n *     if (JSON.parse(message.data).id === 42) {\n *         console.log('Got response 42');\n *         unsubscribe();\n *     }\n * });\n * ```\n */\nexport function getDataPublisherFromEventEmitter<TEventMap extends Record<string, Event>>(\n    eventEmitter: TypedEventEmitter<TEventMap> | TypedEventTarget<TEventMap>,\n): DataPublisher<{\n    [TEventType in keyof TEventMap]: TEventMap[TEventType] extends CustomEvent ? TEventMap[TEventType]['detail'] : null;\n}> {\n    return {\n        on(channelName, subscriber, options) {\n            function innerListener(ev: Event) {\n                if (ev instanceof CustomEvent) {\n                    const data = (ev as CustomEvent<TEventMap[typeof channelName]>).detail;\n                    (subscriber as unknown as (data: TEventMap[typeof channelName]) => void)(data);\n                } else {\n                    (subscriber as () => void)();\n                }\n            }\n            eventEmitter.addEventListener(channelName, innerListener, options);\n            return () => {\n                eventEmitter.removeEventListener(channelName, innerListener);\n            };\n        },\n    };\n}\n","import { KeyPath, TraversalState } from './tree-traversal';\n\nexport function getIntegerOverflowNodeVisitor(onIntegerOverflow: (keyPath: KeyPath, value: bigint) => void) {\n    return <T>(value: T, { keyPath }: TraversalState): T => {\n        if (typeof value === 'bigint') {\n            if (onIntegerOverflow && (value > Number.MAX_SAFE_INTEGER || value < -Number.MAX_SAFE_INTEGER)) {\n                onIntegerOverflow(keyPath as (number | string)[], value);\n            }\n        }\n        return value;\n    };\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getF64Decoder,\n    getF64Encoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU8Decoder,\n    getU8Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport {\n    F64UnsafeSeeDocumentation,\n    getDefaultLamportsDecoder,\n    getDefaultLamportsEncoder,\n    type Lamports,\n} from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_RENT_ADDRESS } from './sysvar';\n\ntype SysvarRentSize = 17;\n\n/**\n * Configuration for network rent.\n */\nexport type SysvarRent = Readonly<{\n    /**\n     * The percentage of collected rent that is burned.\n     *\n     * Valid values are in the range [0, 100]. The remaining percentage is distributed to\n     * validators.\n     */\n    burnPercent: number;\n    /** Amount of time (in years) a balance must include rent for the account to be rent exempt */\n    exemptionThreshold: F64UnsafeSeeDocumentation;\n    /** Rental rate in {@link Lamports}/byte-year. */\n    lamportsPerByteYear: Lamports;\n}>;\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarRent} to a byte array representing\n * the `Rent` sysvar's account data.\n */\nexport function getSysvarRentEncoder(): FixedSizeEncoder<SysvarRent, SysvarRentSize> {\n    return getStructEncoder([\n        ['lamportsPerByteYear', getDefaultLamportsEncoder()],\n        ['exemptionThreshold', getF64Encoder()],\n        ['burnPercent', getU8Encoder()],\n    ]) as FixedSizeEncoder<SysvarRent, SysvarRentSize>;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `Rent` sysvar's\n * account data to a {@link SysvarRent}.\n */\nexport function getSysvarRentDecoder(): FixedSizeDecoder<SysvarRent, SysvarRentSize> {\n    return getStructDecoder([\n        ['lamportsPerByteYear', getDefaultLamportsDecoder()],\n        ['exemptionThreshold', getF64Decoder()],\n        ['burnPercent', getU8Decoder()],\n    ]) as FixedSizeDecoder<SysvarRent, SysvarRentSize>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarRent}\n *\n * @see {@link getSysvarRentDecoder}\n * @see {@link getSysvarRentEncoder}\n */\nexport function getSysvarRentCodec(): FixedSizeCodec<SysvarRent, SysvarRent, SysvarRentSize> {\n    return combineCodec(getSysvarRentEncoder(), getSysvarRentDecoder());\n}\n\n/**\n * Fetches the `Rent` sysvar account using any RPC that supports the {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarRent(rpc: Rpc<GetAccountInfoApi>, config?: FetchAccountConfig): Promise<SysvarRent> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_RENT_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarRentDecoder());\n    return decoded.data;\n}\n","import { RpcRequest } from '@solana/rpc-spec-types';\n\nimport { getIntegerOverflowNodeVisitor } from './request-transformer-integer-overflow-internal';\nimport { getTreeWalkerRequestTransformer, KeyPath } from './tree-traversal';\n\nexport type IntegerOverflowHandler = (request: RpcRequest, keyPath: KeyPath, value: bigint) => void;\n\n/**\n * Creates a transformer that traverses the request parameters and executes the provided handler\n * when an integer overflow is detected.\n *\n * @example\n * ```ts\n * import { getIntegerOverflowRequestTransformer } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getIntegerOverflowRequestTransformer((request, keyPath, value) => {\n *     throw new Error(`Integer overflow at ${keyPath.join('.')}: ${value}`);\n * });\n * ```\n */\nexport function getIntegerOverflowRequestTransformer(onIntegerOverflow: IntegerOverflowHandler) {\n    return <TParams>(request: RpcRequest<TParams>): RpcRequest => {\n        const transformer = getTreeWalkerRequestTransformer(\n            [getIntegerOverflowNodeVisitor((...args) => onIntegerOverflow(request, ...args))],\n            { keyPath: [] },\n        );\n        return transformer(request);\n    };\n}\n","import { Address, Chain, LocalAccount, Transport } from \"viem\";\nimport { isSignerWallet, SignerWallet } from \"../../../types/shared/evm\";\nimport { PaymentPayload, PaymentRequirements, UnsignedPaymentPayload } from \"../../../types/verify\";\nimport { createNonce, signAuthorization } from \"./sign\";\nimport { encodePayment } from \"./utils/paymentUtils\";\n\n/**\n * Prepares an unsigned payment header with the given sender address and payment requirements.\n *\n * @param from - The sender's address from which the payment will be made\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns An unsigned payment payload containing authorization details\n */\nexport function preparePaymentHeader(\n  from: Address,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): UnsignedPaymentPayload {\n  const nonce = createNonce();\n\n  const validAfter = BigInt(\n    Math.floor(Date.now() / 1000) - 600, // 10 minutes before\n  ).toString();\n  const validBefore = BigInt(\n    Math.floor(Date.now() / 1000 + paymentRequirements.maxTimeoutSeconds),\n  ).toString();\n\n  return {\n    x402Version,\n    scheme: paymentRequirements.scheme,\n    network: paymentRequirements.network,\n    payload: {\n      signature: undefined,\n      authorization: {\n        from,\n        to: paymentRequirements.payTo as Address,\n        value: paymentRequirements.maxAmountRequired,\n        validAfter: validAfter.toString(),\n        validBefore: validBefore.toString(),\n        nonce,\n      },\n    },\n  };\n}\n\n/**\n * Signs a payment header using the provided client and payment requirements.\n *\n * @param client - The signer wallet instance used to sign the payment header\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @param unsignedPaymentHeader - The unsigned payment payload to be signed\n * @returns A promise that resolves to the signed payment payload\n */\nexport async function signPaymentHeader<transport extends Transport, chain extends Chain>(\n  client: SignerWallet<chain, transport> | LocalAccount,\n  paymentRequirements: PaymentRequirements,\n  unsignedPaymentHeader: UnsignedPaymentPayload,\n): Promise<PaymentPayload> {\n  const { signature } = await signAuthorization(\n    client,\n    unsignedPaymentHeader.payload.authorization,\n    paymentRequirements,\n  );\n\n  return {\n    ...unsignedPaymentHeader,\n    payload: {\n      ...unsignedPaymentHeader.payload,\n      signature,\n    },\n  };\n}\n\n/**\n * Creates a complete payment payload by preparing and signing a payment header.\n *\n * @param client - The signer wallet instance used to create and sign the payment\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns A promise that resolves to the complete signed payment payload\n */\nexport async function createPayment<transport extends Transport, chain extends Chain>(\n  client: SignerWallet<chain, transport> | LocalAccount,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<PaymentPayload> {\n  const from = isSignerWallet(client) ? client.account!.address : client.address;\n  const unsignedPaymentHeader = preparePaymentHeader(from, x402Version, paymentRequirements);\n  return signPaymentHeader(client, paymentRequirements, unsignedPaymentHeader);\n}\n\n/**\n * Creates and encodes a payment header for the given client and payment requirements.\n *\n * @param client - The signer wallet instance used to create the payment header\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns A promise that resolves to the encoded payment header string\n */\nexport async function createPaymentHeader(\n  client: SignerWallet | LocalAccount,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<string> {\n  const payment = await createPayment(client, x402Version, paymentRequirements);\n  return encodePayment(payment);\n}\n","import { EventTarget } from '@solana/event-target-impl';\n\nimport { DataPublisher, getDataPublisherFromEventEmitter } from './data-publisher';\n\n/**\n * Given a channel that carries messages for multiple subscribers on a single channel name, this\n * function returns a new {@link DataPublisher} that splits them into multiple channel names.\n *\n * @param messageTransformer A function that receives the message as the first argument, and returns\n * a tuple of the derived channel name and the message.\n *\n * @example\n * Imagine a channel that carries multiple notifications whose destination is contained within the\n * message itself.\n *\n * ```ts\n * const demuxedDataPublisher = demultiplexDataPublisher(channel, 'message', message => {\n *     const destinationChannelName = `notification-for:${message.subscriberId}`;\n *     return [destinationChannelName, message];\n * });\n * ```\n *\n * Now you can subscribe to _only_ the messages you are interested in, without having to subscribe\n * to the entire `'message'` channel and filter out the messages that are not for you.\n *\n * ```ts\n * demuxedDataPublisher.on(\n *     'notification-for:123',\n *     message => {\n *         console.log('Got a message for subscriber 123', message);\n *     },\n *     { signal: AbortSignal.timeout(5_000) },\n * );\n * ```\n */\nexport function demultiplexDataPublisher<\n    TDataPublisher extends DataPublisher,\n    const TChannelName extends Parameters<TDataPublisher['on']>[0],\n>(\n    publisher: TDataPublisher,\n    sourceChannelName: TChannelName,\n    messageTransformer: (\n        // FIXME: Deriving the type of the message from `TDataPublisher` and `TChannelName` would\n        //        help callers to constrain their transform functions.\n        message: unknown,\n    ) => [destinationChannelName: string, message: unknown] | void,\n): DataPublisher {\n    let innerPublisherState:\n        | {\n              readonly dispose: () => void;\n              numSubscribers: number;\n          }\n        | undefined;\n    const eventTarget = new EventTarget();\n    const demultiplexedDataPublisher = getDataPublisherFromEventEmitter(eventTarget);\n    return {\n        ...demultiplexedDataPublisher,\n        on(channelName, subscriber, options) {\n            if (!innerPublisherState) {\n                const innerPublisherUnsubscribe = publisher.on(sourceChannelName, sourceMessage => {\n                    const transformResult = messageTransformer(sourceMessage);\n                    if (!transformResult) {\n                        return;\n                    }\n                    const [destinationChannelName, message] = transformResult;\n                    eventTarget.dispatchEvent(\n                        new CustomEvent(destinationChannelName, {\n                            detail: message,\n                        }),\n                    );\n                });\n                innerPublisherState = {\n                    dispose: innerPublisherUnsubscribe,\n                    numSubscribers: 0,\n                };\n            }\n            innerPublisherState.numSubscribers++;\n            const unsubscribe = demultiplexedDataPublisher.on(channelName, subscriber, options);\n            let isActive = true;\n            function handleUnsubscribe() {\n                if (!isActive) {\n                    return;\n                }\n                isActive = false;\n                options?.signal.removeEventListener('abort', handleUnsubscribe);\n                innerPublisherState!.numSubscribers--;\n                if (innerPublisherState!.numSubscribers === 0) {\n                    innerPublisherState!.dispose();\n                    innerPublisherState = undefined;\n                }\n                unsubscribe();\n            }\n            options?.signal.addEventListener('abort', handleUnsubscribe);\n            return handleUnsubscribe;\n        },\n    };\n}\n","export const OPTIONS_OBJECT_POSITION_BY_METHOD: Record<string, number> = {\n    accountNotifications: 1,\n    blockNotifications: 1,\n    getAccountInfo: 1,\n    getBalance: 1,\n    getBlock: 1,\n    getBlockHeight: 0,\n    getBlockProduction: 0,\n    getBlocks: 2,\n    getBlocksWithLimit: 2,\n    getEpochInfo: 0,\n    getFeeForMessage: 1,\n    getInflationGovernor: 0,\n    getInflationReward: 1,\n    getLargestAccounts: 0,\n    getLatestBlockhash: 0,\n    getLeaderSchedule: 1,\n    getMinimumBalanceForRentExemption: 1,\n    getMultipleAccounts: 1,\n    getProgramAccounts: 1,\n    getSignaturesForAddress: 1,\n    getSlot: 0,\n    getSlotLeader: 0,\n    getStakeMinimumDelegation: 0,\n    getSupply: 0,\n    getTokenAccountBalance: 1,\n    getTokenAccountsByDelegate: 2,\n    getTokenAccountsByOwner: 2,\n    getTokenLargestAccounts: 1,\n    getTokenSupply: 1,\n    getTransaction: 1,\n    getTransactionCount: 0,\n    getVoteAccounts: 0,\n    isBlockhashValid: 1,\n    logsNotifications: 1,\n    programNotifications: 1,\n    requestAirdrop: 2,\n    sendTransaction: 1,\n    signatureNotifications: 1,\n    simulateTransaction: 1,\n};\n","import { createSolanaRpcApi } from '@solana/rpc-api';\nimport { createRpc, RpcTransport } from '@solana/rpc-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n\nimport type { RpcFromTransport, SolanaRpcApiFromTransport } from './rpc-clusters';\nimport { DEFAULT_RPC_CONFIG } from './rpc-default-config';\nimport { createDefaultRpcTransport } from './rpc-transport';\n\ntype DefaultRpcTransportConfig<TClusterUrl extends ClusterUrl> = Parameters<\n    typeof createDefaultRpcTransport<TClusterUrl>\n>[0];\n\n/**\n * Creates a {@link Rpc} instance that exposes the Solana JSON RPC API given a cluster URL and some\n * optional transport config. See {@link createDefaultRpcTransport} for the shape of the transport\n * config.\n */\nexport function createSolanaRpc<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<DefaultRpcTransportConfig<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcFromTransport(createDefaultRpcTransport({ url: clusterUrl, ...config }));\n}\n\n/**\n * Creates a {@link Rpc} instance that exposes the Solana JSON RPC API given the supplied\n * {@link RpcTransport}.\n */\nexport function createSolanaRpcFromTransport<TTransport extends RpcTransport>(transport: TTransport) {\n    return createRpc({\n        api: createSolanaRpcApi(DEFAULT_RPC_CONFIG),\n        transport,\n    }) as RpcFromTransport<SolanaRpcApiFromTransport<TTransport>, TTransport>;\n}\n","import { RpcTransport } from '@solana/rpc-spec';\nimport { parseJsonWithBigInts, stringifyJsonWithBigInts } from '@solana/rpc-spec-types';\n\nimport { createHttpTransport } from './http-transport';\nimport { HttpTransportConfig } from './http-transport-config';\nimport { isSolanaRequest } from './is-solana-request';\n\ntype Config = Pick<HttpTransportConfig, 'dispatcher_NODE_ONLY' | 'headers' | 'url'>;\n\n/**\n * Creates a {@link RpcTransport} that uses JSON HTTP requests  much like the\n * {@link createHttpTransport} function - except that it also uses custom `toJson` and `fromJson`\n * functions in order to allow `bigint` values to be serialized and deserialized correctly over the\n * wire.\n *\n * Since this is something specific to the Solana RPC API, these custom JSON functions are only\n * triggered when the request is recognized as a Solana RPC request. Normal RPC APIs should aim to\n * wrap their `bigint` values  e.g. `u64` or `i64`  in special value objects that represent the\n * number as a string to avoid numerical values going above `Number.MAX_SAFE_INTEGER`.\n *\n * It has the same configuration options as {@link createHttpTransport}, but without the `fromJson`\n * and `toJson` options.\n */\nexport function createHttpTransportForSolanaRpc(config: Config): RpcTransport {\n    return createHttpTransport({\n        ...config,\n        fromJson: (rawResponse: string, payload: unknown) =>\n            isSolanaRequest(payload) ? parseJsonWithBigInts(rawResponse) : JSON.parse(rawResponse),\n        toJson: (payload: unknown) =>\n            isSolanaRequest(payload) ? stringifyJsonWithBigInts(payload) : JSON.stringify(payload),\n    });\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { COMPUTE_BUDGET_PROGRAM_ADDRESS } from '../programs';\n\nexport const SET_COMPUTE_UNIT_PRICE_DISCRIMINATOR = 3;\n\nexport function getSetComputeUnitPriceDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_COMPUTE_UNIT_PRICE_DISCRIMINATOR);\n}\n\nexport type SetComputeUnitPriceInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<TRemainingAccounts>;\n\nexport type SetComputeUnitPriceInstructionData = {\n  discriminator: number;\n  /** Transaction compute unit price used for prioritization fees. */\n  microLamports: bigint;\n};\n\nexport type SetComputeUnitPriceInstructionDataArgs = {\n  /** Transaction compute unit price used for prioritization fees. */\n  microLamports: number | bigint;\n};\n\nexport function getSetComputeUnitPriceInstructionDataEncoder(): FixedSizeEncoder<SetComputeUnitPriceInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['microLamports', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_COMPUTE_UNIT_PRICE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetComputeUnitPriceInstructionDataDecoder(): FixedSizeDecoder<SetComputeUnitPriceInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['microLamports', getU64Decoder()],\n  ]);\n}\n\nexport function getSetComputeUnitPriceInstructionDataCodec(): FixedSizeCodec<\n  SetComputeUnitPriceInstructionDataArgs,\n  SetComputeUnitPriceInstructionData\n> {\n  return combineCodec(\n    getSetComputeUnitPriceInstructionDataEncoder(),\n    getSetComputeUnitPriceInstructionDataDecoder()\n  );\n}\n\nexport type SetComputeUnitPriceInput = {\n  microLamports: SetComputeUnitPriceInstructionDataArgs['microLamports'];\n};\n\nexport function getSetComputeUnitPriceInstruction<\n  TProgramAddress extends Address = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n>(\n  input: SetComputeUnitPriceInput,\n  config?: { programAddress?: TProgramAddress }\n): SetComputeUnitPriceInstruction<TProgramAddress> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? COMPUTE_BUDGET_PROGRAM_ADDRESS;\n\n  // Original args.\n  const args = { ...input };\n\n  return Object.freeze({\n    data: getSetComputeUnitPriceInstructionDataEncoder().encode(\n      args as SetComputeUnitPriceInstructionDataArgs\n    ),\n    programAddress,\n  } as SetComputeUnitPriceInstruction<TProgramAddress>);\n}\n\nexport type ParsedSetComputeUnitPriceInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n> = {\n  programAddress: Address<TProgram>;\n  data: SetComputeUnitPriceInstructionData;\n};\n\nexport function parseSetComputeUnitPriceInstruction<TProgram extends string>(\n  instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>\n): ParsedSetComputeUnitPriceInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getSetComputeUnitPriceInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    getArrayDecoder,\n    getArrayEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport { type Blockhash, getBlockhashDecoder, getBlockhashEncoder, type Slot } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_SLOT_HASHES_ADDRESS } from './sysvar';\n\ntype Entry = Readonly<{\n    hash: Blockhash;\n    slot: Slot;\n}>;\n\n/** The most recent hashes of a slot's parent banks. */\nexport type SysvarSlotHashes = Entry[];\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarSlotHashes} to a byte array\n * representing the `SlotHashes` sysvar's account data.\n */\nexport function getSysvarSlotHashesEncoder(): VariableSizeEncoder<SysvarSlotHashes> {\n    return getArrayEncoder(\n        getStructEncoder([\n            ['slot', getU64Encoder()],\n            ['hash', getBlockhashEncoder()],\n        ]),\n    );\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `SlotHashes` sysvar's\n * account data to a {@link SysvarSlotHashes}.\n */\nexport function getSysvarSlotHashesDecoder(): VariableSizeDecoder<SysvarSlotHashes> {\n    return getArrayDecoder(\n        getStructDecoder([\n            ['slot', getU64Decoder()],\n            ['hash', getBlockhashDecoder()],\n        ]),\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarSlotHashes}\n *\n * @see {@link getSysvarSlotHashesDecoder}\n * @see {@link getSysvarSlotHashesEncoder}\n */\nexport function getSysvarSlotHashesCodec(): VariableSizeCodec<SysvarSlotHashes> {\n    return combineCodec(getSysvarSlotHashesEncoder(), getSysvarSlotHashesDecoder());\n}\n\n/**\n * Fetches the `SlotHashes` sysvar account using any RPC that supports the {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarSlotHashes(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarSlotHashes> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_SLOT_HASHES_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarSlotHashesDecoder());\n    return decoded.data;\n}\n","import { encodePayment } from \"../../utils\";\nimport {\n  Address,\n  pipe,\n  createTransactionMessage,\n  setTransactionMessageFeePayer,\n  setTransactionMessageLifetimeUsingBlockhash,\n  appendTransactionMessageInstructions,\n  partiallySignTransactionMessageWithSigners,\n  prependTransactionMessageInstruction,\n  getBase64EncodedWireTransaction,\n  TransactionSigner,\n  Instruction,\n} from \"@solana/kit\";\nimport { PaymentPayload, PaymentRequirements } from \"../../../types/verify\";\nimport { X402Config } from \"../../../types/config\";\nimport {\n  fetchMint,\n  findAssociatedTokenPda,\n  getTransferCheckedInstruction,\n  TOKEN_2022_PROGRAM_ADDRESS,\n} from \"@solana-program/token-2022\";\nimport { TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\nimport {\n  estimateComputeUnitLimitFactory,\n  getSetComputeUnitLimitInstruction,\n  setTransactionMessageComputeUnitPrice,\n} from \"@solana-program/compute-budget\";\nimport { getRpcClient } from \"../../../shared/svm/rpc\";\n\n/**\n * Creates and encodes a payment header for the given client and payment requirements.\n *\n * @param client - The signer instance used to create the payment header\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @param config - Optional configuration for X402 operations (e.g., custom RPC URLs)\n * @returns A promise that resolves to a base64 encoded payment header string\n */\nexport async function createPaymentHeader(\n  client: TransactionSigner,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n  config?: X402Config,\n): Promise<string> {\n  const paymentPayload = await createAndSignPayment(\n    client,\n    x402Version,\n    paymentRequirements,\n    config,\n  );\n  return encodePayment(paymentPayload);\n}\n\n/**\n * Creates and signs a payment for the given client and payment requirements.\n *\n * @param client - The signer instance used to create and sign the payment tx\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements\n * @param config - Optional configuration for X402 operations (e.g., custom RPC URLs)\n * @returns A promise that resolves to a payment payload containing a base64 encoded solana token transfer tx\n */\nexport async function createAndSignPayment(\n  client: TransactionSigner,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n  config?: X402Config,\n): Promise<PaymentPayload> {\n  const transactionMessage = await createTransferTransactionMessage(\n    client,\n    paymentRequirements,\n    config,\n  );\n  const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage);\n  const base64EncodedWireTransaction = getBase64EncodedWireTransaction(signedTransaction);\n\n  // return payment payload\n  return {\n    scheme: paymentRequirements.scheme,\n    network: paymentRequirements.network,\n    x402Version: x402Version,\n    payload: {\n      transaction: base64EncodedWireTransaction,\n    },\n  } as PaymentPayload;\n}\n\n/**\n * Creates a transfer transaction message for the given client and payment requirements.\n *\n * @param client - The signer instance used to create the transfer transaction message\n * @param paymentRequirements - The payment requirements\n * @param config - Optional configuration for X402 operations (e.g., custom RPC URLs)\n * @returns A promise that resolves to the transaction message with the transfer instruction\n */\nasync function createTransferTransactionMessage(\n  client: TransactionSigner,\n  paymentRequirements: PaymentRequirements,\n  config?: X402Config,\n) {\n  const rpc = getRpcClient(paymentRequirements.network, config?.svmConfig?.rpcUrl);\n\n  // create the transfer instruction\n  const transferInstructions = await createTransferInstructions(\n    client,\n    paymentRequirements,\n    config,\n  );\n\n  // create tx to simulate\n  const feePayer = paymentRequirements.extra?.feePayer as Address;\n  const txToSimulate = pipe(\n    createTransactionMessage({ version: 0 }),\n    tx => setTransactionMessageComputeUnitPrice(1, tx), // 1 microlamport priority fee\n    tx => setTransactionMessageFeePayer(feePayer, tx),\n    tx => appendTransactionMessageInstructions(transferInstructions, tx),\n  );\n\n  // estimate the compute budget limit (gas limit)\n  const estimateComputeUnitLimit = estimateComputeUnitLimitFactory({ rpc });\n  const estimatedUnits = await estimateComputeUnitLimit(txToSimulate);\n\n  // finalize the transaction message by adding the compute budget limit and blockhash\n  const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n  const tx = pipe(\n    txToSimulate,\n    tx =>\n      prependTransactionMessageInstruction(\n        getSetComputeUnitLimitInstruction({ units: estimatedUnits }),\n        tx,\n      ),\n    tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n  );\n\n  return tx;\n}\n\n/**\n * Creates a transfer instruction for the given client and payment requirements.\n * This function will determine which transfer instruction to create\n * based on the program that created the token (token-2022 or token).\n *\n * @param client - The signer instance used to create the transfer instruction\n * @param paymentRequirements - The payment requirements\n * @param config - Optional configuration for X402 operations (e.g., custom RPC URLs)\n * @returns A promise that resolves to the transfer instruction array\n */\nasync function createTransferInstructions(\n  client: TransactionSigner,\n  paymentRequirements: PaymentRequirements,\n  config?: X402Config,\n): Promise<Instruction[]> {\n  const { asset, maxAmountRequired: amount, payTo } = paymentRequirements;\n\n  const rpc = getRpcClient(paymentRequirements.network, config?.svmConfig?.rpcUrl);\n  const tokenMint = await fetchMint(rpc, asset as Address);\n  const tokenProgramAddress = tokenMint.programAddress;\n\n  // validate that the asset was created by a known token program\n  if (\n    tokenProgramAddress.toString() !== TOKEN_PROGRAM_ADDRESS.toString() &&\n    tokenProgramAddress.toString() !== TOKEN_2022_PROGRAM_ADDRESS.toString()\n  ) {\n    throw new Error(\"Asset was not created by a known token program\");\n  }\n\n  const [sourceATA] = await findAssociatedTokenPda({\n    mint: asset as Address,\n    owner: client.address,\n    tokenProgram: tokenProgramAddress,\n  });\n\n  const [destinationATA] = await findAssociatedTokenPda({\n    mint: asset as Address,\n    owner: payTo as Address,\n    tokenProgram: tokenProgramAddress,\n  });\n\n  const transferIx = getTransferCheckedInstruction(\n    {\n      source: sourceATA,\n      mint: asset as Address,\n      destination: destinationATA,\n      authority: client,\n      amount: BigInt(amount),\n      decimals: tokenMint.data.decimals,\n    },\n    { programAddress: tokenProgramAddress },\n  );\n  return [transferIx];\n}\n","const empty = new Uint8Array(0);\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\nconst fromHex = hex => {\n  const hexes = hex.match(/../g);\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n};\nconst equals = (aa, bb) => {\n  if (aa === bb)\n    return true;\n  if (aa.byteLength !== bb.byteLength) {\n    return false;\n  }\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false;\n    }\n  }\n  return true;\n};\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')\n    return o;\n  if (o instanceof ArrayBuffer)\n    return new Uint8Array(o);\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n};\nconst isBinary = o => o instanceof ArrayBuffer || ArrayBuffer.isView(o);\nconst fromString = str => new TextEncoder().encode(str);\nconst toString = b => new TextDecoder().decode(b);\nexport {\n  equals,\n  coerce,\n  isBinary,\n  fromHex,\n  toHex,\n  fromString,\n  toString,\n  empty\n};","import { pipe } from '@solana/functional';\nimport {\n    RpcSubscriptionsChannel,\n    transformChannelInboundMessages,\n    transformChannelOutboundMessages,\n} from '@solana/rpc-subscriptions-spec';\n\n/**\n * Given a {@link RpcSubscriptionsChannel}, will return a new channel that parses data published to\n * the `'message'` channel as JSON, and JSON-stringifies messages sent via the\n * {@link RpcSubscriptionsChannel.send | send(message)} method.\n */\nexport function getRpcSubscriptionsChannelWithJSONSerialization(\n    channel: RpcSubscriptionsChannel<string, string>,\n): RpcSubscriptionsChannel<unknown, unknown> {\n    return pipe(\n        channel,\n        c => transformChannelInboundMessages(c, JSON.parse),\n        c => transformChannelOutboundMessages(c, JSON.stringify),\n    );\n}\n","import { pipe } from '@solana/functional';\nimport { parseJsonWithBigInts, stringifyJsonWithBigInts } from '@solana/rpc-spec-types';\nimport {\n    RpcSubscriptionsChannel,\n    transformChannelInboundMessages,\n    transformChannelOutboundMessages,\n} from '@solana/rpc-subscriptions-spec';\n\n/**\n * Similarly, to {@link getRpcSubscriptionsChannelWithJSONSerialization}, this function will\n * stringify and parse JSON message to and from the given `string` channel. However, this function\n * parses any integer value as a `BigInt` in order to safely handle numbers that exceed the\n * JavaScript [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\n * value.\n */\nexport function getRpcSubscriptionsChannelWithBigIntJSONSerialization(\n    channel: RpcSubscriptionsChannel<string, string>,\n): RpcSubscriptionsChannel<unknown, unknown> {\n    return pipe(\n        channel,\n        c => transformChannelInboundMessages(c, parseJsonWithBigInts),\n        c => transformChannelOutboundMessages(c, stringifyJsonWithBigInts),\n    );\n}\n","import { cloneDeepWith as cloneDeepWith$1, copyProperties } from '../../object/cloneDeepWith.mjs';\nimport { argumentsTag, booleanTag, stringTag, numberTag } from '../_internal/tags.mjs';\n\nfunction cloneDeepWith(obj, cloneValue) {\n    return cloneDeepWith$1(obj, (value, key, object, stack) => {\n        const cloned = cloneValue?.(value, key, object, stack);\n        if (cloned != null) {\n            return cloned;\n        }\n        if (typeof obj !== 'object') {\n            return undefined;\n        }\n        switch (Object.prototype.toString.call(obj)) {\n            case numberTag:\n            case stringTag:\n            case booleanTag: {\n                const result = new obj.constructor(obj?.valueOf());\n                copyProperties(result, obj);\n                return result;\n            }\n            case argumentsTag: {\n                const result = {};\n                copyProperties(result, obj);\n                result.length = obj.length;\n                result[Symbol.iterator] = obj[Symbol.iterator];\n                return result;\n            }\n            default: {\n                return undefined;\n            }\n        }\n    });\n}\n\nexport { cloneDeepWith };\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getArrayCodec,\n    getU64Codec,\n    getU64Decoder,\n    getU64Encoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs';\nimport {\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SolanaError,\n} from '@solana/errors';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Slot } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_SLOT_HISTORY_ADDRESS } from './sysvar';\n\nconst BITVEC_DISCRIMINATOR = 1;\n// Max number of bits in the bitvector.\n// The Solana SDK defines a constant `MAX_ENTRIES` representing the maximum\n// number of bits that can be represented by the bitvector in the `SlotHistory`\n// sysvar. This value is 1024 * 1024 = 1_048_576.\n// See https://github.com/anza-xyz/agave/blob/e0203f22dc83cb792fa97f91dbe6e924cbd08af1/sdk/program/src/slot_history.rs#L43\nconst BITVEC_NUM_BITS = 1024 * 1024;\n// The length of the bitvector in blocks.\n// At 64 bits per block, this is 1024 * 1024 / 64 = 16_384.\nconst BITVEC_LENGTH = BITVEC_NUM_BITS / 64;\n\nconst SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE =\n    1 + // Discriminator\n    8 + // bitvector length (u64)\n    BITVEC_LENGTH * 8 +\n    8 + // Number of bits (u64)\n    8; // Next slot (u64)\n\nlet memoizedU64Encoder: FixedSizeEncoder<bigint, 8> | undefined;\nlet memoizedU64Decoder: FixedSizeDecoder<bigint, 8> | undefined;\nlet memoizedU64ArrayEncoder: FixedSizeEncoder<bigint[]> | undefined;\nlet memoizedU64ArrayDecoder: FixedSizeDecoder<bigint[]> | undefined;\n\nfunction getMemoizedU64Encoder(): FixedSizeEncoder<bigint, 8> {\n    if (!memoizedU64Encoder) memoizedU64Encoder = getU64Encoder();\n    return memoizedU64Encoder;\n}\nfunction getMemoizedU64Decoder(): FixedSizeDecoder<bigint, 8> {\n    if (!memoizedU64Decoder) memoizedU64Decoder = getU64Decoder();\n    return memoizedU64Decoder;\n}\nfunction getMemoizedU64ArrayEncoder(): FixedSizeEncoder<bigint[], typeof BITVEC_LENGTH> {\n    if (!memoizedU64ArrayEncoder) memoizedU64ArrayEncoder = getArrayCodec(getU64Codec(), { size: BITVEC_LENGTH });\n    return memoizedU64ArrayEncoder;\n}\nfunction getMemoizedU64ArrayDecoder(): FixedSizeDecoder<bigint[], typeof BITVEC_LENGTH> {\n    if (!memoizedU64ArrayDecoder) memoizedU64ArrayDecoder = getArrayCodec(getU64Codec(), { size: BITVEC_LENGTH });\n    return memoizedU64ArrayDecoder;\n}\n\ntype SysvarSlotHistorySize = typeof SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE;\n\n/** A bitvector of slots present over the last epoch. */\nexport type SysvarSlotHistory = {\n    /**\n     * A vector of 64-bit numbers which, when their bits are strung together, represent a record of\n     * non-skipped slots.\n     *\n     * The bit in position (slot % MAX_ENTRIES) is 0 if the slot was skipped and 1 otherwise, valid\n     * only when the candidate slot is less than `nextSlot` and greater than or equal to\n     * `MAX_ENTRIES - nextSlot`.\n     */\n    bits: bigint[];\n    /** The number of the slot one newer than tracked by the bitvector */\n    nextSlot: Slot;\n};\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarSlotHistory} to a byte array\n * representing the `SlotHistory` sysvar's account data.\n */\nexport function getSysvarSlotHistoryEncoder(): FixedSizeEncoder<SysvarSlotHistory, SysvarSlotHistorySize> {\n    return createEncoder({\n        fixedSize: SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE,\n        write: (value: SysvarSlotHistory, bytes, offset) => {\n            // First byte is the bitvector discriminator.\n            bytes.set([BITVEC_DISCRIMINATOR], offset);\n            offset += 1;\n            // Next 8 bytes are the bitvector length.\n            getMemoizedU64Encoder().write(BigInt(BITVEC_LENGTH), bytes, offset);\n            offset += 8;\n            // Next `BITVEC_LENGTH` bytes are the bitvector.\n            // Any missing bits are assumed to be 0.\n            getMemoizedU64ArrayEncoder().write(value.bits, bytes, offset);\n            offset += BITVEC_LENGTH * 8;\n            // Next 8 bytes are the number of bits.\n            getMemoizedU64Encoder().write(BigInt(BITVEC_NUM_BITS), bytes, offset);\n            offset += 8;\n            // Next 8 bytes are the next slot.\n            getMemoizedU64Encoder().write(value.nextSlot, bytes, offset);\n            offset += 8;\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `SlotHistory` sysvar's\n * account data to a {@link SysvarSlotHistory}.\n */\nexport function getSysvarSlotHistoryDecoder(): FixedSizeDecoder<SysvarSlotHistory, SysvarSlotHistorySize> {\n    return createDecoder({\n        fixedSize: SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            // Byte length should be exact.\n            if (bytes.length != SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n                    actual: bytes.length,\n                    expected: SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE,\n                });\n            }\n            // First byte is the bitvector discriminator.\n            const discriminator = bytes[offset];\n            offset += 1;\n            if (discriminator !== BITVEC_DISCRIMINATOR) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                    actual: discriminator,\n                    expected: BITVEC_DISCRIMINATOR,\n                });\n            }\n            // Next 8 bytes are the bitvector length.\n            const bitVecLength = getMemoizedU64Decoder().read(bytes, offset)[0];\n            offset += 8;\n            if (bitVecLength !== BigInt(BITVEC_LENGTH)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n                    actual: bitVecLength,\n                    codecDescription: 'SysvarSlotHistoryCodec',\n                    expected: BITVEC_LENGTH,\n                });\n            }\n            // Next `BITVEC_LENGTH` bytes are the bitvector.\n            const bits = getMemoizedU64ArrayDecoder().read(bytes, offset)[0];\n            offset += BITVEC_LENGTH * 8;\n            // Next 8 bytes are the number of bits.\n            const numBits = getMemoizedU64Decoder().read(bytes, offset)[0];\n            offset += 8;\n            if (numBits !== BigInt(BITVEC_NUM_BITS)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n                    actual: numBits,\n                    codecDescription: 'SysvarSlotHistoryCodec',\n                    expected: BITVEC_NUM_BITS,\n                });\n            }\n            // Next 8 bytes are the next slot.\n            const nextSlot = getMemoizedU64Decoder().read(bytes, offset)[0];\n            offset += 8;\n            return [\n                {\n                    bits,\n                    nextSlot,\n                },\n                offset,\n            ];\n        },\n    });\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarSlotHistory}\n *\n * @see {@link getSysvarSlotHistoryDecoder}\n * @see {@link getSysvarSlotHistoryEncoder}\n */\nexport function getSysvarSlotHistoryCodec(): FixedSizeCodec<\n    SysvarSlotHistory,\n    SysvarSlotHistory,\n    SysvarSlotHistorySize\n> {\n    return combineCodec(getSysvarSlotHistoryEncoder(), getSysvarSlotHistoryDecoder());\n}\n\n/**\n * Fetches the `SlotHistory` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarSlotHistory(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarSlotHistory> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_SLOT_HISTORY_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarSlotHistoryDecoder());\n    return decoded.data;\n}\n","import { createWebSocketChannel } from '@solana/rpc-subscriptions-channel-websocket';\nimport type { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\nimport type { ClusterUrl } from '@solana/rpc-types';\n\nimport { getRpcSubscriptionsChannelWithAutoping } from './rpc-subscriptions-autopinger';\nimport { getChannelPoolingChannelCreator } from './rpc-subscriptions-channel-pool';\nimport { RpcSubscriptionsChannelCreatorFromClusterUrl } from './rpc-subscriptions-clusters';\nimport { getRpcSubscriptionsChannelWithJSONSerialization } from './rpc-subscriptions-json';\nimport { getRpcSubscriptionsChannelWithBigIntJSONSerialization } from './rpc-subscriptions-json-bigint';\n\nexport type DefaultRpcSubscriptionsChannelConfig<TClusterUrl extends ClusterUrl> = Readonly<{\n    /**\n     * The number of milliseconds to wait since the last message sent or received over the channel\n     * before sending a ping message to keep the channel open.\n     */\n    intervalMs?: number;\n    /**\n     * The number of subscribers that may share a channel before a new channel must be created.\n     *\n     * It is important that you set this to the maximum number of subscriptions that your RPC\n     * provider recommends making over a single connection; the default is set deliberately low, so\n     * as to comply with the restrictive limits of the public mainnet RPC node.\n     *\n     * @defaultValue 100\n     */\n    maxSubscriptionsPerChannel?: number;\n    /** The number of channels to create before reusing a channel for a new subscription. */\n    minChannels?: number;\n    /**\n     * The number of bytes of data to admit into the\n     * [`WebSocket`](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket) buffer before\n     * buffering data on the client.\n     */\n    sendBufferHighWatermark?: number;\n    /** The URL of the web socket server. Must use the `ws` or `wss` protocols. */\n    url: TClusterUrl;\n}>;\n\n/**\n * Similar to {@link createDefaultRpcSubscriptionsChannelCreator} with some Solana-specific\n * defaults.\n *\n * For instance, it safely handles `BigInt` values in JSON messages since Solana RPC servers accept\n * and return integers larger than [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER).\n */\nexport function createDefaultSolanaRpcSubscriptionsChannelCreator<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsChannelConfig<TClusterUrl>,\n): RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown> {\n    return createDefaultRpcSubscriptionsChannelCreatorImpl({\n        ...config,\n        jsonSerializer: getRpcSubscriptionsChannelWithBigIntJSONSerialization,\n    });\n}\n\n/**\n * Creates a function that returns new subscription channels when called.\n */\nexport function createDefaultRpcSubscriptionsChannelCreator<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsChannelConfig<TClusterUrl>,\n): RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown> {\n    return createDefaultRpcSubscriptionsChannelCreatorImpl({\n        ...config,\n        jsonSerializer: getRpcSubscriptionsChannelWithJSONSerialization,\n    });\n}\n\nfunction createDefaultRpcSubscriptionsChannelCreatorImpl<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsChannelConfig<TClusterUrl> & {\n        jsonSerializer: (channel: RpcSubscriptionsChannel<string, string>) => RpcSubscriptionsChannel<unknown, unknown>;\n    },\n): RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown> {\n    if (/^wss?:/i.test(config.url) === false) {\n        const protocolMatch = config.url.match(/^([^:]+):/);\n        throw new DOMException(\n            protocolMatch\n                ? \"Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or \" +\n                  `'wss'. '${protocolMatch[1]}:' is not allowed.`\n                : `Failed to construct 'WebSocket': The URL '${config.url}' is invalid.`,\n        );\n    }\n    const { intervalMs, ...rest } = config;\n    const createDefaultRpcSubscriptionsChannel = (({ abortSignal }) => {\n        return createWebSocketChannel({\n            ...rest,\n            sendBufferHighWatermark:\n                config.sendBufferHighWatermark ??\n                // Let 128KB of data into the WebSocket buffer before buffering it in the app.\n                131_072,\n            signal: abortSignal,\n        })\n            .then(config.jsonSerializer)\n            .then(channel =>\n                getRpcSubscriptionsChannelWithAutoping({\n                    abortSignal,\n                    channel,\n                    intervalMs: intervalMs ?? 5_000,\n                }),\n            );\n    }) as RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown>;\n    return getChannelPoolingChannelCreator(createDefaultRpcSubscriptionsChannel, {\n        maxSubscriptionsPerChannel:\n            config.maxSubscriptionsPerChannel ??\n            /**\n             * A note about this default. The idea here is that, because some RPC providers impose\n             * an upper limit on the number of subscriptions you can make per channel, we must\n             * choose a number low enough to avoid hitting that limit. Without knowing what provider\n             * a given person is using, or what their limit is, we have to choose the lowest of all\n             * known limits. As of this writing (October 2024) that is the public mainnet RPC node\n             * (api.mainnet-beta.solana.com) at 100 subscriptions.\n             */\n            100,\n        minChannels: config.minChannels ?? 1,\n    });\n}\n","import { pipe } from '@solana/functional';\nimport { RpcRequest, RpcRequestTransformer } from '@solana/rpc-spec-types';\nimport { Commitment } from '@solana/rpc-types';\n\nimport { getBigIntDowncastRequestTransformer } from './request-transformer-bigint-downcast';\nimport { getDefaultCommitmentRequestTransformer } from './request-transformer-default-commitment';\nimport { getIntegerOverflowRequestTransformer, IntegerOverflowHandler } from './request-transformer-integer-overflow';\nimport { OPTIONS_OBJECT_POSITION_BY_METHOD } from './request-transformer-options-object-position-config';\n\nexport type RequestTransformerConfig = Readonly<{\n    /**\n     * An optional {@link Commitment} value to use as the default when none is supplied by the\n     * caller.\n     */\n    defaultCommitment?: Commitment;\n    /**\n     * An optional function that will be called whenever a `bigint` input exceeds that which can be\n     * expressed using JavaScript numbers.\n     *\n     * This is used in the default {@link SolanaRpcSubscriptionsApi} to throw an exception rather\n     * than to allow truncated values to propagate through a program.\n     */\n    onIntegerOverflow?: IntegerOverflowHandler;\n}>;\n\n/**\n * Returns the default request transformer for the Solana RPC API.\n *\n * Under the hood, this function composes multiple\n * {@link RpcRequestTransformer | RpcRequestTransformers} together such as the\n * {@link getDefaultCommitmentTransformer}, the {@link getIntegerOverflowRequestTransformer} and the\n * {@link getBigIntDowncastRequestTransformer}.\n *\n * @example\n * ```ts\n * import { getDefaultRequestTransformerForSolanaRpc } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getDefaultRequestTransformerForSolanaRpc({\n *     defaultCommitment: 'confirmed',\n *     onIntegerOverflow: (request, keyPath, value) => {\n *         throw new Error(`Integer overflow at ${keyPath.join('.')}: ${value}`);\n *     },\n * });\n * ```\n */\nexport function getDefaultRequestTransformerForSolanaRpc(config?: RequestTransformerConfig): RpcRequestTransformer {\n    const handleIntegerOverflow = config?.onIntegerOverflow;\n    return (request: RpcRequest): RpcRequest => {\n        return pipe(\n            request,\n            handleIntegerOverflow ? getIntegerOverflowRequestTransformer(handleIntegerOverflow) : r => r,\n            getBigIntDowncastRequestTransformer(),\n            getDefaultCommitmentRequestTransformer({\n                defaultCommitment: config?.defaultCommitment,\n                optionsObjectPositionByMethod: OPTIONS_OBJECT_POSITION_BY_METHOD,\n            }),\n        );\n    };\n}\n","import basex from '../../vendor/base-x.js';\nimport { coerce } from '../bytes.js';\nclass Encoder {\n  constructor(name, prefix, baseEncode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n  encode(bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${ this.prefix }${ this.baseEncode(bytes) }`;\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}\nclass Decoder {\n  constructor(name, prefix, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character');\n    }\n    this.prefixCodePoint = prefix.codePointAt(0);\n    this.baseDecode = baseDecode;\n  }\n  decode(text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${ JSON.stringify(text) }, ${ this.name } decoder only supports inputs prefixed with ${ this.prefix }`);\n      }\n      return this.baseDecode(text.slice(this.prefix.length));\n    } else {\n      throw Error('Can only multibase decode strings');\n    }\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n}\nclass ComposedDecoder {\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n  decode(input) {\n    const prefix = input[0];\n    const decoder = this.decoders[prefix];\n    if (decoder) {\n      return decoder.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${ JSON.stringify(input) }, only inputs prefixed with ${ Object.keys(this.decoders) } are supported`);\n    }\n  }\n}\nexport const or = (left, right) => new ComposedDecoder({\n  ...left.decoders || { [left.prefix]: left },\n  ...right.decoders || { [right.prefix]: right }\n});\nexport class Codec {\n  constructor(name, prefix, baseEncode, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n}\nexport const from = ({name, prefix, encode, decode}) => new Codec(name, prefix, encode, decode);\nexport const baseX = ({prefix, name, alphabet}) => {\n  const {encode, decode} = basex(alphabet, name);\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: text => coerce(decode(text))\n  });\n};\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  const codes = {};\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n  let end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n  }\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n  for (let i = 0; i < end; ++i) {\n    const value = codes[string[i]];\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${ name } character`);\n    }\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 255 & buffer >> bits;\n    }\n  }\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n};\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0;\n  let buffer = 0;\n  for (let i = 0; i < data.length; ++i) {\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n  return out;\n};\nexport const rfc4648 = ({name, prefix, bitsPerChar, alphabet}) => {\n  return from({\n    prefix,\n    name,\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n    decode(input) {\n      return decode(input, alphabet, bitsPerChar, name);\n    }\n  });\n};","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { COMPUTE_BUDGET_PROGRAM_ADDRESS } from '../programs';\n\nexport const SET_LOADED_ACCOUNTS_DATA_SIZE_LIMIT_DISCRIMINATOR = 4;\n\nexport function getSetLoadedAccountsDataSizeLimitDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    SET_LOADED_ACCOUNTS_DATA_SIZE_LIMIT_DISCRIMINATOR\n  );\n}\n\nexport type SetLoadedAccountsDataSizeLimitInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<TRemainingAccounts>;\n\nexport type SetLoadedAccountsDataSizeLimitInstructionData = {\n  discriminator: number;\n  accountDataSizeLimit: number;\n};\n\nexport type SetLoadedAccountsDataSizeLimitInstructionDataArgs = {\n  accountDataSizeLimit: number;\n};\n\nexport function getSetLoadedAccountsDataSizeLimitInstructionDataEncoder(): FixedSizeEncoder<SetLoadedAccountsDataSizeLimitInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['accountDataSizeLimit', getU32Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_LOADED_ACCOUNTS_DATA_SIZE_LIMIT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetLoadedAccountsDataSizeLimitInstructionDataDecoder(): FixedSizeDecoder<SetLoadedAccountsDataSizeLimitInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['accountDataSizeLimit', getU32Decoder()],\n  ]);\n}\n\nexport function getSetLoadedAccountsDataSizeLimitInstructionDataCodec(): FixedSizeCodec<\n  SetLoadedAccountsDataSizeLimitInstructionDataArgs,\n  SetLoadedAccountsDataSizeLimitInstructionData\n> {\n  return combineCodec(\n    getSetLoadedAccountsDataSizeLimitInstructionDataEncoder(),\n    getSetLoadedAccountsDataSizeLimitInstructionDataDecoder()\n  );\n}\n\nexport type SetLoadedAccountsDataSizeLimitInput = {\n  accountDataSizeLimit: SetLoadedAccountsDataSizeLimitInstructionDataArgs['accountDataSizeLimit'];\n};\n\nexport function getSetLoadedAccountsDataSizeLimitInstruction<\n  TProgramAddress extends Address = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n>(\n  input: SetLoadedAccountsDataSizeLimitInput,\n  config?: { programAddress?: TProgramAddress }\n): SetLoadedAccountsDataSizeLimitInstruction<TProgramAddress> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? COMPUTE_BUDGET_PROGRAM_ADDRESS;\n\n  // Original args.\n  const args = { ...input };\n\n  return Object.freeze({\n    data: getSetLoadedAccountsDataSizeLimitInstructionDataEncoder().encode(\n      args as SetLoadedAccountsDataSizeLimitInstructionDataArgs\n    ),\n    programAddress,\n  } as SetLoadedAccountsDataSizeLimitInstruction<TProgramAddress>);\n}\n\nexport type ParsedSetLoadedAccountsDataSizeLimitInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n> = {\n  programAddress: Address<TProgram>;\n  data: SetLoadedAccountsDataSizeLimitInstructionData;\n};\n\nexport function parseSetLoadedAccountsDataSizeLimitInstruction<\n  TProgram extends string,\n>(\n  instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>\n): ParsedSetLoadedAccountsDataSizeLimitInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getSetLoadedAccountsDataSizeLimitInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","import { KeyPath, KEYPATH_WILDCARD, TraversalState } from './tree-traversal';\n\nexport function getBigIntUpcastVisitor(allowedNumericKeyPaths: readonly KeyPath[]) {\n    return function upcastNodeToBigIntIfNumber(value: unknown, { keyPath }: TraversalState) {\n        const isInteger = (typeof value === 'number' && Number.isInteger(value)) || typeof value === 'bigint';\n        if (!isInteger) return value;\n        if (keyPathIsAllowedToBeNumeric(keyPath, allowedNumericKeyPaths)) {\n            return Number(value);\n        } else {\n            return BigInt(value);\n        }\n    };\n}\n\nfunction keyPathIsAllowedToBeNumeric(keyPath: KeyPath, allowedNumericKeyPaths: readonly KeyPath[]) {\n    return allowedNumericKeyPaths.some(prohibitedKeyPath => {\n        if (prohibitedKeyPath.length !== keyPath.length) {\n            return false;\n        }\n        for (let ii = keyPath.length - 1; ii >= 0; ii--) {\n            const keyPathPart = keyPath[ii];\n            const prohibitedKeyPathPart = prohibitedKeyPath[ii];\n            if (\n                prohibitedKeyPathPart !== keyPathPart &&\n                (prohibitedKeyPathPart !== KEYPATH_WILDCARD || typeof keyPathPart !== 'number')\n            ) {\n                return false;\n            }\n        }\n        return true;\n    });\n}\n","import {\n  createKeyPairSignerFromBytes,\n  createKeyPairSignerFromPrivateKeyBytes,\n  type RpcDevnet,\n  type SolanaRpcApiDevnet,\n  type RpcMainnet,\n  type SolanaRpcApiMainnet,\n  type TransactionSigner,\n  isTransactionSigner,\n} from \"@solana/kit\";\nimport { base58 } from \"@scure/base\";\nimport { getRpcClient } from \"./rpc\";\nimport { Network, SupportedSVMNetworks } from \"../../types/shared\";\nexport type { KeyPairSigner } from \"@solana/kit\";\n\nexport type SvmConnectedClient = RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>;\nexport type SvmSigner = TransactionSigner;\n\n/**\n * Creates a public client configured for the specified SVM network\n *\n * @param network - The network to connect to\n * @returns A public client instance connected to the specified chain\n */\nexport function createSvmConnectedClient(network: string): SvmConnectedClient {\n  if (!SupportedSVMNetworks.find(n => n === network)) {\n    throw new Error(`Unsupported SVM network: ${network}`);\n  }\n  return getRpcClient(network as Network);\n}\n\n/**\n * Creates a Solana signer from a private key.\n *\n * @param privateKey - The base58 encoded private key to create a signer from.\n * @returns A Solana signer.\n */\nexport async function createSignerFromBase58(privateKey: string): Promise<TransactionSigner> {\n  // decode the base58 encoded private key\n  const bytes = base58.decode(privateKey);\n\n  // generate a keypair signer from the bytes based on the byte-length\n  // 64 bytes represents concatenated private + public key\n  if (bytes.length === 64) {\n    return await createKeyPairSignerFromBytes(bytes);\n  }\n  // 32 bytes represents only the private key\n  if (bytes.length === 32) {\n    return await createKeyPairSignerFromPrivateKeyBytes(bytes);\n  }\n  throw new Error(`Unexpected key length: ${bytes.length}. Expected 32 or 64 bytes.`);\n}\n\n/**\n * Checks if the given wallet is a Solana transaction signer wallet.\n *\n * @param wallet - The object wallet to check.\n * @returns True if the wallet satisfies the TransactionSigner interface.\n */\nexport function isSignerWallet(wallet: unknown): wallet is SvmSigner {\n  return (\n    typeof wallet === \"object\" &&\n    wallet !== null &&\n    isTransactionSigner(wallet as TransactionSigner)\n  );\n}\n","import { cloneDeepWith } from './cloneDeepWith.mjs';\n\nfunction cloneDeep(obj) {\n    return cloneDeepWith(obj);\n}\n\nexport { cloneDeep };\n","import { getTag } from '../_internal/getTag.mjs';\n\nfunction isArguments(value) {\n    return value !== null && typeof value === 'object' && getTag(value) === '[object Arguments]';\n}\n\nexport { isArguments };\n","function isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\n\nexport { isObjectLike };\n","function noop() { }\n\nexport { noop };\n","import {\n  createSolanaRpc,\n  devnet,\n  mainnet,\n  RpcDevnet,\n  SolanaRpcApiDevnet,\n  SolanaRpcApiMainnet,\n  RpcMainnet,\n  createSolanaRpcSubscriptions,\n  RpcSubscriptionsFromTransport,\n  SolanaRpcSubscriptionsApi,\n  RpcSubscriptionsTransportFromClusterUrl,\n  ClusterUrl,\n} from \"@solana/kit\";\nimport { Network } from \"../../types/shared\";\n\n/**\n * Default public RPC endpoint for Solana devnet\n */\nconst DEVNET_RPC_URL = \"https://api.devnet.solana.com\";\n\n/**\n * Default public RPC endpoint for Solana mainnet\n */\nconst MAINNET_RPC_URL = \"https://api.mainnet-beta.solana.com\";\n\n/**\n * Default public WebSocket endpoint for Solana devnet\n */\nconst DEVNET_WS_URL = \"wss://api.devnet.solana.com\";\n\n/**\n * Default public WebSocket endpoint for Solana mainnet\n */\nconst MAINNET_WS_URL = \"wss://api.mainnet-beta.solana.com\";\n\n/**\n * Creates a Solana RPC client for the devnet network.\n *\n * @param url - Optional URL of the devnet network.\n * @returns A Solana RPC client.\n */\nexport function createDevnetRpcClient(url?: string): RpcDevnet<SolanaRpcApiDevnet> {\n  return createSolanaRpc(\n    url ? devnet(url) : devnet(DEVNET_RPC_URL),\n  ) as RpcDevnet<SolanaRpcApiDevnet>;\n}\n\n/**\n * Creates a Solana RPC client for the mainnet network.\n *\n * @param url - Optional URL of the mainnet network.\n * @returns A Solana RPC client.\n */\nexport function createMainnetRpcClient(url?: string): RpcMainnet<SolanaRpcApiMainnet> {\n  return createSolanaRpc(\n    url ? mainnet(url) : mainnet(MAINNET_RPC_URL),\n  ) as RpcMainnet<SolanaRpcApiMainnet>;\n}\n\n/**\n * Gets the RPC client for the given network.\n *\n * @param network - The network to get the RPC client for\n * @param url - Optional URL of the network. If not provided, the default URL will be used.\n * @returns The RPC client for the given network\n */\nexport function getRpcClient(\n  network: Network,\n  url?: string,\n): RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet> {\n  // TODO: should the networks be replaced with enum references?\n  if (network === \"solana-devnet\") {\n    return createDevnetRpcClient(url);\n  } else if (network === \"solana\") {\n    return createMainnetRpcClient(url);\n  } else {\n    throw new Error(\"Invalid network\");\n  }\n}\n\n/**\n * Gets the RPC subscriptions for the given network.\n *\n * @param network - The network to get the RPC subscriptions for\n * @param url - Optional URL of the network. If not provided, the default URL will be used.\n * @returns The RPC subscriptions for the given network\n */\nexport function getRpcSubscriptions(\n  network: Network,\n  url?: string,\n): RpcSubscriptionsFromTransport<\n  SolanaRpcSubscriptionsApi,\n  RpcSubscriptionsTransportFromClusterUrl<ClusterUrl>\n> {\n  // TODO: should the networks be replaced with enum references?\n  if (network === \"solana-devnet\") {\n    return createSolanaRpcSubscriptions(devnet(url ? httpToWs(url) : DEVNET_WS_URL));\n  } else if (network === \"solana\") {\n    return createSolanaRpcSubscriptions(mainnet(url ? httpToWs(url) : MAINNET_WS_URL));\n  } else {\n    throw new Error(\"Invalid network\");\n  }\n}\n\n/**\n *\n * Converts an HTTP URL to a WebSocket URL\n *\n * @param url - The URL to convert to a WebSocket URL\n * @returns The WebSocket URL\n */\nfunction httpToWs(url: string): string {\n  if (url.startsWith(\"http\")) {\n    return url.replace(\"http\", \"ws\");\n  }\n  return url;\n}\n","import { AbortController } from '@solana/event-target-impl';\nimport fastStableStringify from '@solana/fast-stable-stringify';\nimport { RpcSubscriptionsTransport } from '@solana/rpc-subscriptions-spec';\nimport { DataPublisher } from '@solana/subscribable';\n\ntype CacheEntry = {\n    readonly abortController: AbortController;\n    readonly dataPublisherPromise: Promise<DataPublisher>;\n    numSubscribers: number;\n};\n\n/**\n * Given a {@link RpcSubscriptionsTransport}, will return a new transport that coalesces identical\n * subscriptions into a single subscription request to the server. The determination of whether a\n * subscription is the same as another is based on the `rpcRequest` returned by its\n * {@link RpcSubscriptionsPlan}. The subscription will only be aborted once all subscribers abort,\n * or there is an error.\n */\nexport function getRpcSubscriptionsTransportWithSubscriptionCoalescing<TTransport extends RpcSubscriptionsTransport>(\n    transport: TTransport,\n): TTransport {\n    const cache = new Map<string, CacheEntry>();\n    return function rpcSubscriptionsTransportWithSubscriptionCoalescing(config) {\n        const { request, signal } = config;\n        const subscriptionConfigurationHash = fastStableStringify([request.methodName, request.params]);\n\n        let cachedDataPublisherPromise = cache.get(subscriptionConfigurationHash);\n        if (!cachedDataPublisherPromise) {\n            const abortController = new AbortController();\n            const dataPublisherPromise = transport({\n                ...config,\n                signal: abortController.signal,\n            });\n            dataPublisherPromise\n                .then(dataPublisher => {\n                    dataPublisher.on(\n                        'error',\n                        () => {\n                            cache.delete(subscriptionConfigurationHash);\n                            abortController.abort();\n                        },\n                        { signal: abortController.signal },\n                    );\n                })\n                .catch(() => {});\n            cache.set(\n                subscriptionConfigurationHash,\n                (cachedDataPublisherPromise = {\n                    abortController,\n                    dataPublisherPromise,\n                    numSubscribers: 0,\n                }),\n            );\n        }\n        cachedDataPublisherPromise.numSubscribers++;\n        signal.addEventListener(\n            'abort',\n            () => {\n                cachedDataPublisherPromise.numSubscribers--;\n                if (cachedDataPublisherPromise.numSubscribers === 0) {\n                    queueMicrotask(() => {\n                        if (cachedDataPublisherPromise.numSubscribers === 0) {\n                            cache.delete(subscriptionConfigurationHash);\n                            cachedDataPublisherPromise.abortController.abort();\n                        }\n                    });\n                }\n            },\n            { signal: cachedDataPublisherPromise.abortController.signal },\n        );\n        return cachedDataPublisherPromise.dataPublisherPromise;\n    } as TTransport;\n}\n","function isPlainObject(object) {\n    if (typeof object !== 'object') {\n        return false;\n    }\n    if (object == null) {\n        return false;\n    }\n    if (Object.getPrototypeOf(object) === null) {\n        return true;\n    }\n    if (Object.prototype.toString.call(object) !== '[object Object]') {\n        const tag = object[Symbol.toStringTag];\n        if (tag == null) {\n            return false;\n        }\n        const isTagReadonly = !Object.getOwnPropertyDescriptor(object, Symbol.toStringTag)?.writable;\n        if (isTagReadonly) {\n            return false;\n        }\n        return object.toString() === `[object ${tag}]`;\n    }\n    let proto = object;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(object) === proto;\n}\n\nexport { isPlainObject };\n","import { getBigIntUpcastVisitor } from './response-transformer-bigint-upcast-internal';\nimport { getTreeWalkerResponseTransformer, KeyPath } from './tree-traversal';\n\n/**\n * Returns a transformer that upcasts all `Number` values to `BigInts` unless they match within the\n * provided {@link KeyPath | KeyPaths}. In other words, the provided {@link KeyPath | KeyPaths} will\n * remain as `Number` values, any other numeric value will be upcasted to a `BigInt`.\n *\n * Note that you can use {@link KEYPATH_WILDCARD} to match any key within a {@link KeyPath}.\n *\n * @example\n * ```ts\n * import { getBigIntUpcastResponseTransformer } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getBigIntUpcastResponseTransformer([\n *     ['index'],\n *     ['instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n *     ['instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n *     ['instructions', KEYPATH_WILDCARD, 'stackHeight'],\n * ]);\n * ```\n */\nexport function getBigIntUpcastResponseTransformer(allowedNumericKeyPaths: readonly KeyPath[]) {\n    return getTreeWalkerResponseTransformer([getBigIntUpcastVisitor(allowedNumericKeyPaths)], { keyPath: [] });\n}\n","import { RpcResponseTransformer } from '@solana/rpc-spec-types';\n\ntype JsonRpcResponse = { result: unknown };\n\n/**\n * Returns a transformer that extracts the `result` field from the body of the RPC response.\n *\n * For instance, we go from `{ jsonrpc: '2.0', result: 'foo', id: 1 }` to `'foo'`.\n *\n * @example\n * ```ts\n * import { getResultResponseTransformer } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getResultResponseTransformer();\n * ```\n */\nexport function getResultResponseTransformer(): RpcResponseTransformer {\n    return json => (json as JsonRpcResponse).result;\n}\n","import { getSolanaErrorFromJsonRpcError } from '@solana/errors';\nimport { RpcResponseTransformer } from '@solana/rpc-spec-types';\n\ntype JsonRpcResponse = { error: Parameters<typeof getSolanaErrorFromJsonRpcError>[0] } | { result: unknown };\n\n/**\n * Returns a transformer that throws a {@link SolanaError} with the appropriate RPC error code if\n * the body of the RPC response contains an error.\n *\n * @example\n * ```ts\n * import { getThrowSolanaErrorResponseTransformer } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getThrowSolanaErrorResponseTransformer();\n * ```\n */\nexport function getThrowSolanaErrorResponseTransformer(): RpcResponseTransformer {\n    return json => {\n        const jsonRpcResponse = json as JsonRpcResponse;\n        if ('error' in jsonRpcResponse) {\n            throw getSolanaErrorFromJsonRpcError(jsonRpcResponse.error);\n        }\n        return jsonRpcResponse;\n    };\n}\n","/**\n * A provisory compute unit limit is used to indicate that the transaction\n * should be estimated for compute units before being sent to the network.\n *\n * Setting it to zero ensures the transaction fails unless it is properly estimated.\n */\nexport const PROVISORY_COMPUTE_UNIT_LIMIT = 0;\n\n/**\n * The maximum compute unit limit that can be set for a transaction.\n */\nexport const MAX_COMPUTE_UNIT_LIMIT = 1_400_000;\n","import {\n  BaseTransactionMessage,\n  getU32Decoder,\n  getU64Decoder,\n  Instruction,\n  MicroLamports,\n  ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  ComputeBudgetInstruction,\n  identifyComputeBudgetInstruction,\n  SetComputeUnitLimitInstruction,\n  SetComputeUnitPriceInstruction,\n} from './generated';\n\n/**\n * Finds the index of the first `SetComputeUnitLimit` instruction in a transaction message\n * and its set limit, if any.\n */\nexport function getSetComputeUnitLimitInstructionIndexAndUnits(\n  transactionMessage: BaseTransactionMessage\n): { index: number; units: number } | null {\n  const index = getSetComputeUnitLimitInstructionIndex(transactionMessage);\n  if (index < 0) {\n    return null;\n  }\n\n  const units = getU32Decoder().decode(\n    transactionMessage.instructions[index].data as ReadonlyUint8Array,\n    1\n  );\n\n  return { index, units };\n}\n\n/**\n * Finds the index of the first `SetComputeUnitLimit` instruction in a transaction message, if any.\n */\nexport function getSetComputeUnitLimitInstructionIndex(\n  transactionMessage: BaseTransactionMessage\n) {\n  return transactionMessage.instructions.findIndex(\n    isSetComputeUnitLimitInstruction\n  );\n}\n\n/**\n * Checks if the given instruction is a `SetComputeUnitLimit` instruction.\n */\nexport function isSetComputeUnitLimitInstruction(\n  instruction: Instruction\n): instruction is SetComputeUnitLimitInstruction {\n  return (\n    instruction.programAddress === COMPUTE_BUDGET_PROGRAM_ADDRESS &&\n    identifyComputeBudgetInstruction(instruction.data as Uint8Array) ===\n      ComputeBudgetInstruction.SetComputeUnitLimit\n  );\n}\n\n/**\n * Finds the index of the first `SetComputeUnitPrice` instruction in a transaction message\n * and its set micro-lamports, if any.\n */\nexport function getSetComputeUnitPriceInstructionIndexAndMicroLamports(\n  transactionMessage: BaseTransactionMessage\n): { index: number; microLamports: MicroLamports } | null {\n  const index = getSetComputeUnitPriceInstructionIndex(transactionMessage);\n  if (index < 0) {\n    return null;\n  }\n\n  const microLamports = getU64Decoder().decode(\n    transactionMessage.instructions[index].data as ReadonlyUint8Array,\n    1\n  ) as MicroLamports;\n\n  return { index, microLamports };\n}\n\n/**\n * Finds the index of the first `SetComputeUnitPrice` instruction in a transaction message, if any.\n */\nexport function getSetComputeUnitPriceInstructionIndex(\n  transactionMessage: BaseTransactionMessage\n) {\n  return transactionMessage.instructions.findIndex(\n    isSetComputeUnitPriceInstruction\n  );\n}\n\n/**\n * Checks if the given instruction is a `SetComputeUnitPrice` instruction.\n */\nexport function isSetComputeUnitPriceInstruction(\n  instruction: Instruction\n): instruction is SetComputeUnitPriceInstruction {\n  return (\n    instruction.programAddress === COMPUTE_BUDGET_PROGRAM_ADDRESS &&\n    identifyComputeBudgetInstruction(instruction.data as Uint8Array) ===\n      ComputeBudgetInstruction.SetComputeUnitPrice\n  );\n}\n","import { pipe } from '@solana/functional';\nimport { RpcRequest, RpcResponse, RpcResponseTransformer } from '@solana/rpc-spec-types';\n\nimport { AllowedNumericKeypaths } from './response-transformer-allowed-numeric-values';\nimport { getBigIntUpcastResponseTransformer } from './response-transformer-bigint-upcast';\nimport { getResultResponseTransformer } from './response-transformer-result';\nimport { getThrowSolanaErrorResponseTransformer } from './response-transformer-throw-solana-error';\n\nexport type ResponseTransformerConfig<TApi> = Readonly<{\n    /**\n     * An optional map from the name of an API method to an array of {@link KeyPath | KeyPaths}\n     * pointing to values in the response that should materialize in the application as `Number`\n     * instead of `BigInt`.\n     */\n    allowedNumericKeyPaths?: AllowedNumericKeypaths<TApi>;\n}>;\n\n/**\n * Returns the default response transformer for the Solana RPC API.\n *\n * Under the hood, this function composes multiple\n * {@link RpcResponseTransformer | RpcResponseTransformers} together such as the\n * {@link getThrowSolanaErrorResponseTransformer}, the {@link getResultResponseTransformer} and the\n * {@link getBigIntUpcastResponseTransformer}.\n *\n * @example\n * ```ts\n * import { getDefaultResponseTransformerForSolanaRpc } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getDefaultResponseTransformerForSolanaRpc({\n *     allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n * });\n * ```\n */\nexport function getDefaultResponseTransformerForSolanaRpc<TApi>(\n    config?: ResponseTransformerConfig<TApi>,\n): RpcResponseTransformer {\n    return (response: RpcResponse, request: RpcRequest): RpcResponse => {\n        const methodName = request.methodName as keyof TApi;\n        const keyPaths =\n            config?.allowedNumericKeyPaths && methodName ? config.allowedNumericKeyPaths[methodName] : undefined;\n        return pipe(\n            response,\n            r => getThrowSolanaErrorResponseTransformer()(r, request),\n            r => getResultResponseTransformer()(r, request),\n            r => getBigIntUpcastResponseTransformer(keyPaths ?? [])(r, request),\n        );\n    };\n}\n\n/**\n * Returns the default response transformer for the Solana RPC Subscriptions API.\n *\n * Under the hood, this function composes the {@link getBigIntUpcastResponseTransformer}.\n *\n * @example\n * ```ts\n * import { getDefaultResponseTransformerForSolanaRpcSubscriptions } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getDefaultResponseTransformerForSolanaRpcSubscriptions({\n *     allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n * });\n * ```\n */\nexport function getDefaultResponseTransformerForSolanaRpcSubscriptions<TApi>(\n    config?: ResponseTransformerConfig<TApi>,\n): RpcResponseTransformer {\n    return (response: RpcResponse, request: RpcRequest): RpcResponse => {\n        const methodName = request.methodName as keyof TApi;\n        const keyPaths =\n            config?.allowedNumericKeyPaths && methodName ? config.allowedNumericKeyPaths[methodName] : undefined;\n        return pipe(response, r => getBigIntUpcastResponseTransformer(keyPaths ?? [])(r, request));\n    };\n}\n","import { isPrimitive } from '../predicate/isPrimitive.mjs';\nimport { isTypedArray } from '../predicate/isTypedArray.mjs';\n\nfunction clone(obj) {\n    if (isPrimitive(obj)) {\n        return obj;\n    }\n    if (Array.isArray(obj) ||\n        isTypedArray(obj) ||\n        obj instanceof ArrayBuffer ||\n        (typeof SharedArrayBuffer !== 'undefined' && obj instanceof SharedArrayBuffer)) {\n        return obj.slice(0);\n    }\n    const prototype = Object.getPrototypeOf(obj);\n    const Constructor = prototype.constructor;\n    if (obj instanceof Date || obj instanceof Map || obj instanceof Set) {\n        return new Constructor(obj);\n    }\n    if (obj instanceof RegExp) {\n        const newRegExp = new Constructor(obj);\n        newRegExp.lastIndex = obj.lastIndex;\n        return newRegExp;\n    }\n    if (obj instanceof DataView) {\n        return new Constructor(obj.buffer.slice(0));\n    }\n    if (obj instanceof Error) {\n        const newError = new Constructor(obj.message);\n        newError.stack = obj.stack;\n        newError.name = obj.name;\n        newError.cause = obj.cause;\n        return newError;\n    }\n    if (typeof File !== 'undefined' && obj instanceof File) {\n        const newFile = new Constructor([obj], obj.name, { type: obj.type, lastModified: obj.lastModified });\n        return newFile;\n    }\n    if (typeof obj === 'object') {\n        const newObject = Object.create(prototype);\n        return Object.assign(newObject, obj);\n    }\n    return obj;\n}\n\nexport { clone };\n","import { KeyPath, KEYPATH_WILDCARD } from './tree-traversal';\n\nexport type AllowedNumericKeypaths<TApi> = Partial<Record<keyof TApi, readonly KeyPath[]>>;\n\n// Numeric values nested in `jsonParsed` accounts\nexport const jsonParsedTokenAccountsConfigs = [\n    // parsed Token/Token22 token account\n    ['data', 'parsed', 'info', 'tokenAmount', 'decimals'],\n    ['data', 'parsed', 'info', 'tokenAmount', 'uiAmount'],\n    ['data', 'parsed', 'info', 'rentExemptReserve', 'decimals'],\n    ['data', 'parsed', 'info', 'rentExemptReserve', 'uiAmount'],\n    ['data', 'parsed', 'info', 'delegatedAmount', 'decimals'],\n    ['data', 'parsed', 'info', 'delegatedAmount', 'uiAmount'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'olderTransferFee', 'transferFeeBasisPoints'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'newerTransferFee', 'transferFeeBasisPoints'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'preUpdateAverageRate'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'currentRate'],\n];\nexport const jsonParsedAccountsConfigs = [\n    ...jsonParsedTokenAccountsConfigs,\n    // parsed AddressTableLookup account\n    ['data', 'parsed', 'info', 'lastExtendedSlotStartIndex'],\n    // parsed Config account\n    ['data', 'parsed', 'info', 'slashPenalty'],\n    ['data', 'parsed', 'info', 'warmupCooldownRate'],\n    // parsed Token/Token22 mint account\n    ['data', 'parsed', 'info', 'decimals'],\n    // parsed Token/Token22 multisig account\n    ['data', 'parsed', 'info', 'numRequiredSigners'],\n    ['data', 'parsed', 'info', 'numValidSigners'],\n    // parsed Stake account\n    ['data', 'parsed', 'info', 'stake', 'delegation', 'warmupCooldownRate'],\n    // parsed Sysvar rent account\n    ['data', 'parsed', 'info', 'exemptionThreshold'],\n    ['data', 'parsed', 'info', 'burnPercent'],\n    // parsed Vote account\n    ['data', 'parsed', 'info', 'commission'],\n    ['data', 'parsed', 'info', 'votes', KEYPATH_WILDCARD, 'confirmationCount'],\n];\nexport const innerInstructionsConfigs = [\n    ['index'],\n    ['instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n    ['instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n    ['instructions', KEYPATH_WILDCARD, 'stackHeight'],\n];\nexport const messageConfig = [\n    ['addressTableLookups', KEYPATH_WILDCARD, 'writableIndexes', KEYPATH_WILDCARD],\n    ['addressTableLookups', KEYPATH_WILDCARD, 'readonlyIndexes', KEYPATH_WILDCARD],\n    ['header', 'numReadonlySignedAccounts'],\n    ['header', 'numReadonlyUnsignedAccounts'],\n    ['header', 'numRequiredSignatures'],\n    ['instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n    ['instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n    ['instructions', KEYPATH_WILDCARD, 'stackHeight'],\n] as const;\n","import * as evm from \"./evm/wallet\";\nimport * as svm from \"../../shared/svm/wallet\";\nimport { SupportedEVMNetworks, SupportedSVMNetworks } from \"./network\";\nimport { Hex } from \"viem\";\n\nexport type ConnectedClient = evm.ConnectedClient | svm.SvmConnectedClient;\nexport type Signer = evm.EvmSigner | svm.SvmSigner;\nexport type MultiNetworkSigner = { evm: evm.EvmSigner; svm: svm.SvmSigner };\n\n/**\n * Creates a public client configured for the specified network.\n *\n * @param network - The network to connect to.\n * @returns A public client instance connected to the specified chain.\n */\nexport function createConnectedClient(network: string): ConnectedClient {\n  if (SupportedEVMNetworks.find(n => n === network)) {\n    return evm.createConnectedClient(network);\n  }\n\n  if (SupportedSVMNetworks.find(n => n === network)) {\n    return svm.createSvmConnectedClient(network);\n  }\n\n  throw new Error(`Unsupported network: ${network}`);\n}\n\n/**\n * Creates a wallet client configured for the specified chain with a private key.\n *\n * @param network - The network to connect to.\n * @param privateKey - The private key to use for signing transactions. This should be a hex string for EVM or a base58 encoded string for SVM.\n * @returns A wallet client instance connected to the specified chain with the provided private key.\n */\nexport function createSigner(network: string, privateKey: Hex | string): Promise<Signer> {\n  // evm\n  if (SupportedEVMNetworks.find(n => n === network)) {\n    return Promise.resolve(evm.createSigner(network, privateKey as Hex));\n  }\n\n  // svm\n  if (SupportedSVMNetworks.find(n => n === network)) {\n    return svm.createSignerFromBase58(privateKey as string);\n  }\n\n  throw new Error(`Unsupported network: ${network}`);\n}\n\n/**\n * Checks if the given wallet is an EVM signer wallet.\n *\n * @param wallet - The object wallet to check.\n * @returns True if the wallet is an EVM signer wallet, false otherwise.\n */\nexport function isEvmSignerWallet(wallet: Signer): wallet is evm.EvmSigner {\n  return evm.isSignerWallet(wallet as evm.EvmSigner) || evm.isAccount(wallet as evm.EvmSigner);\n}\n\n/**\n * Checks if the given wallet is an SVM signer wallet\n *\n * @param wallet - The object wallet to check\n * @returns True if the wallet is an SVM signer wallet, false otherwise\n */\nexport function isSvmSignerWallet(wallet: Signer): wallet is svm.SvmSigner {\n  return svm.isSignerWallet(wallet);\n}\n\n/**\n * Checks if the given wallet is a multi network signer wallet\n *\n * @param wallet - The object wallet to check\n * @returns True if the wallet is a multi network signer wallet, false otherwise\n */\nexport function isMultiNetworkSigner(wallet: object): wallet is MultiNetworkSigner {\n  return \"evm\" in wallet && \"svm\" in wallet;\n}\n","import { pipe } from '@solana/functional';\nimport { RpcSubscriptionsChannelCreator, RpcSubscriptionsTransport } from '@solana/rpc-subscriptions-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n\nimport {\n    RpcSubscriptionsChannelCreatorDevnet,\n    RpcSubscriptionsChannelCreatorFromClusterUrl,\n    RpcSubscriptionsChannelCreatorMainnet,\n    RpcSubscriptionsChannelCreatorTestnet,\n    RpcSubscriptionsTransportDevnet,\n    RpcSubscriptionsTransportFromClusterUrl,\n    RpcSubscriptionsTransportMainnet,\n    RpcSubscriptionsTransportTestnet,\n} from './rpc-subscriptions-clusters';\nimport { getRpcSubscriptionsTransportWithSubscriptionCoalescing } from './rpc-subscriptions-coalescer';\n\nexport type DefaultRpcSubscriptionsTransportConfig<TClusterUrl extends ClusterUrl> = Readonly<{\n    createChannel: RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown>;\n}>;\n\n/**\n * Creates a {@link RpcSubscriptionsTransport} with some default behaviours.\n *\n * The default behaviours include:\n * - Logic that coalesces multiple subscriptions for the same notifications with the same arguments\n *   into a single subscription.\n *\n * @param config\n */\nexport function createDefaultRpcSubscriptionsTransport<TClusterUrl extends ClusterUrl>({\n    createChannel,\n}: DefaultRpcSubscriptionsTransportConfig<TClusterUrl>) {\n    return pipe(\n        createRpcSubscriptionsTransportFromChannelCreator(\n            createChannel,\n        ) as RpcSubscriptionsTransport as RpcSubscriptionsTransportFromClusterUrl<TClusterUrl>,\n        transport => getRpcSubscriptionsTransportWithSubscriptionCoalescing(transport),\n    );\n}\n\nexport function createRpcSubscriptionsTransportFromChannelCreator<\n    TChannelCreator extends RpcSubscriptionsChannelCreator<TOutboundMessage, TInboundMessage>,\n    TInboundMessage,\n    TOutboundMessage,\n>(createChannel: TChannelCreator) {\n    return (async ({ execute, signal }) => {\n        const channel = await createChannel({ abortSignal: signal });\n        return await execute({ channel, signal });\n    }) as TChannelCreator extends RpcSubscriptionsChannelCreatorDevnet<TOutboundMessage, TInboundMessage>\n        ? RpcSubscriptionsTransportDevnet\n        : TChannelCreator extends RpcSubscriptionsChannelCreatorTestnet<TOutboundMessage, TInboundMessage>\n          ? RpcSubscriptionsTransportTestnet\n          : TChannelCreator extends RpcSubscriptionsChannelCreatorMainnet<TOutboundMessage, TInboundMessage>\n            ? RpcSubscriptionsTransportMainnet\n            : RpcSubscriptionsTransport;\n}\n","/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from \"./_u64.js\";\n// prettier-ignore\nimport { abytes, aexists, anumber, aoutput, clean, createHasher, createXOFer, Hash, swap32IfBE, toBytes, u32 } from \"./utils.js\";\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst IOTAS = split(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\nexport function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta \n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho () and Pi ()\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi ()\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota ()\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    clean(B);\n}\n/** Keccak sponge function. */\nexport class Keccak extends Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        this.enableXOF = false;\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        // Can be passed from user as dkLen\n        anumber(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        // 0 < blockLen < 200\n        if (!(0 < blockLen && blockLen < 200))\n            throw new Error('only keccak-f1600 function is supported');\n        this.state = new Uint8Array(200);\n        this.state32 = u32(this.state);\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    keccak() {\n        swap32IfBE(this.state32);\n        keccakP(this.state32, this.rounds);\n        swap32IfBE(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        aexists(this);\n        data = toBytes(data);\n        abytes(data);\n        const { blockLen, state } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        aexists(this, false);\n        abytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        anumber(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        aoutput(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        clean(this.state);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => createHasher(() => new Keccak(blockLen, suffix, outputLen));\n/** SHA3-224 hash function. */\nexport const sha3_224 = /* @__PURE__ */ (() => gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */\nexport const sha3_256 = /* @__PURE__ */ (() => gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */\nexport const sha3_384 = /* @__PURE__ */ (() => gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */\nexport const sha3_512 = /* @__PURE__ */ (() => gen(0x06, 72, 512 / 8))();\n/** keccak-224 hash function. */\nexport const keccak_224 = /* @__PURE__ */ (() => gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */\nexport const keccak_256 = /* @__PURE__ */ (() => gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */\nexport const keccak_384 = /* @__PURE__ */ (() => gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */\nexport const keccak_512 = /* @__PURE__ */ (() => gen(0x01, 72, 512 / 8))();\nconst genShake = (suffix, blockLen, outputLen) => createXOFer((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\n/** SHAKE128 XOF with 128-bit security. */\nexport const shake128 = /* @__PURE__ */ (() => genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */\nexport const shake256 = /* @__PURE__ */ (() => genShake(0x1f, 136, 256 / 8))();\n//# sourceMappingURL=sha3.js.map","import {\n  appendTransactionMessageInstruction,\n  BaseTransactionMessage,\n} from '@solana/kit';\nimport { PROVISORY_COMPUTE_UNIT_LIMIT } from './constants';\nimport { getSetComputeUnitLimitInstruction } from './generated';\nimport { getSetComputeUnitLimitInstructionIndexAndUnits } from './internal';\n\n/**\n * Appends a `SetComputeUnitLimit` instruction with a provisory\n * compute unit limit to a given transaction message\n * if and only if it does not already have one.\n *\n * @example\n * ```ts\n * const transactionMessage = pipe(\n *   createTransactionMessage({ version: 0 }),\n *   fillProvisorySetComputeUnitLimitInstruction,\n *   // ...\n * );\n * ```\n */\nexport function fillProvisorySetComputeUnitLimitInstruction<\n  TTransactionMessage extends BaseTransactionMessage,\n>(transactionMessage: TTransactionMessage) {\n  return updateOrAppendSetComputeUnitLimitInstruction(\n    (previousUnits) =>\n      previousUnits === null ? PROVISORY_COMPUTE_UNIT_LIMIT : previousUnits,\n    transactionMessage\n  );\n}\n\n/**\n * Updates the first `SetComputeUnitLimit` instruction in a transaction message\n * with the given units, or appends a new instruction if none exists.\n * A function of the current value can be provided instead of a static value.\n *\n * @param units - The new compute unit limit, or a function that takes the previous\n *                compute unit limit and returns the new limit.\n * @param transactionMessage - The transaction message to update.\n *\n * @example\n * ```ts\n * const updatedTransactionMessage = updateOrAppendSetComputeUnitLimitInstruction(\n *   // E.g. Keep the current limit if it is set, otherwise set it to the maximum.\n *   (currentUnits) => currentUnits === null ? MAX_COMPUTE_UNIT_LIMIT : currentUnits,\n *   transactionMessage,\n * );\n * ```\n */\nexport function updateOrAppendSetComputeUnitLimitInstruction<\n  TTransactionMessage extends BaseTransactionMessage,\n>(\n  units: number | ((previousUnits: number | null) => number),\n  transactionMessage: TTransactionMessage\n): TTransactionMessage {\n  const getUnits = (previousUnits: number | null): number =>\n    typeof units === 'function' ? units(previousUnits) : units;\n  const instructionDetails =\n    getSetComputeUnitLimitInstructionIndexAndUnits(transactionMessage);\n\n  if (!instructionDetails) {\n    return appendTransactionMessageInstruction(\n      getSetComputeUnitLimitInstruction({ units: getUnits(null) }),\n      transactionMessage\n    ) as unknown as TTransactionMessage;\n  }\n\n  const { index, units: previousUnits } = instructionDetails;\n  const newUnits = getUnits(previousUnits);\n  if (newUnits === previousUnits) {\n    return transactionMessage;\n  }\n\n  const newInstruction = getSetComputeUnitLimitInstruction({ units: newUnits });\n  const newInstructions = [...transactionMessage.instructions];\n  newInstructions.splice(index, 1, newInstruction);\n  return Object.freeze({\n    ...transactionMessage,\n    instructions: newInstructions,\n  });\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    getArrayDecoder,\n    getArrayEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport { Epoch, getDefaultLamportsDecoder, getDefaultLamportsEncoder, type Lamports } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_STAKE_HISTORY_ADDRESS } from './sysvar';\n\ntype Entry = Readonly<{\n    /** The epoch to which this stake history entry pertains */\n    epoch: Epoch;\n    stakeHistory: Readonly<{\n        /**\n         * Sum of portion of stakes requested to be warmed up, but not fully activated yet, in\n         * {@link Lamports}\n         */\n        activating: Lamports;\n        /**\n         * Sum of portion of stakes requested to be cooled down, but not fully deactivated yet, in\n         * {@link Lamports}\n         */\n        deactivating: Lamports;\n        /** Effective stake at this epoch, in {@link Lamports} */\n        effective: Lamports;\n    }>;\n}>;\n\n/** History of stake activations and de-activations. */\nexport type SysvarStakeHistory = Entry[];\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarStakeHistory} to a byte array\n * representing the `StakeHistory` sysvar's account data.\n */\nexport function getSysvarStakeHistoryEncoder(): VariableSizeEncoder<SysvarStakeHistory> {\n    return getArrayEncoder(\n        getStructEncoder([\n            ['epoch', getU64Encoder()],\n            [\n                'stakeHistory',\n                getStructEncoder([\n                    ['effective', getDefaultLamportsEncoder()],\n                    ['activating', getDefaultLamportsEncoder()],\n                    ['deactivating', getDefaultLamportsEncoder()],\n                ]),\n            ],\n        ]),\n        { size: getU64Encoder() },\n    );\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `StakeHistory`\n * sysvar's account data to a {@link SysvarStakeHistory}.\n */\nexport function getSysvarStakeHistoryDecoder(): VariableSizeDecoder<SysvarStakeHistory> {\n    return getArrayDecoder(\n        getStructDecoder([\n            ['epoch', getU64Decoder()],\n            [\n                'stakeHistory',\n                getStructDecoder([\n                    ['effective', getDefaultLamportsDecoder()],\n                    ['activating', getDefaultLamportsDecoder()],\n                    ['deactivating', getDefaultLamportsDecoder()],\n                ]),\n            ],\n        ]),\n        { size: getU64Decoder() },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarStakeHistory}\n *\n * @see {@link getSysvarStakeHistoryDecoder}\n * @see {@link getSysvarStakeHistoryEncoder}\n */\nexport function getSysvarStakeHistoryCodec(): VariableSizeCodec<SysvarStakeHistory> {\n    return combineCodec(getSysvarStakeHistoryEncoder(), getSysvarStakeHistoryDecoder());\n}\n\n/**\n * Fetches the `StakeHistory` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarStakeHistory(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarStakeHistory> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_STAKE_HISTORY_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarStakeHistoryDecoder());\n    return decoded.data;\n}\n","import type { SolanaRpcSubscriptionsApi, SolanaRpcSubscriptionsApiUnstable } from '@solana/rpc-subscriptions-api';\nimport { createSolanaRpcSubscriptionsApi } from '@solana/rpc-subscriptions-api';\nimport {\n    createSubscriptionRpc,\n    RpcSubscriptionsApiMethods,\n    type RpcSubscriptionsTransport,\n} from '@solana/rpc-subscriptions-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n\nimport { DEFAULT_RPC_SUBSCRIPTIONS_CONFIG } from './rpc-default-config';\nimport {\n    createDefaultSolanaRpcSubscriptionsChannelCreator,\n    DefaultRpcSubscriptionsChannelConfig,\n} from './rpc-subscriptions-channel';\nimport type { RpcSubscriptionsFromTransport } from './rpc-subscriptions-clusters';\nimport { createDefaultRpcSubscriptionsTransport } from './rpc-subscriptions-transport';\n\ntype Config<TClusterUrl extends ClusterUrl> = DefaultRpcSubscriptionsChannelConfig<TClusterUrl>;\n\nfunction createSolanaRpcSubscriptionsImpl<TClusterUrl extends ClusterUrl, TApi extends RpcSubscriptionsApiMethods>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<Config<TClusterUrl>, 'url'>,\n) {\n    const transport = createDefaultRpcSubscriptionsTransport({\n        createChannel: createDefaultSolanaRpcSubscriptionsChannelCreator({ ...config, url: clusterUrl }),\n    });\n    return createSolanaRpcSubscriptionsFromTransport<typeof transport, TApi>(transport);\n}\n\n/**\n * Creates a {@link RpcSubscriptions} instance that exposes the Solana JSON RPC WebSocket API given\n * a cluster URL and some optional channel config. See\n * {@link createDefaultRpcSubscriptionsChannelCreator} for the shape of the channel config.\n */\nexport function createSolanaRpcSubscriptions<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<Config<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcSubscriptionsImpl<TClusterUrl, SolanaRpcSubscriptionsApi>(clusterUrl, config);\n}\n\n/**\n * Creates a {@link RpcSubscriptions} instance that exposes the Solana JSON RPC WebSocket API,\n * including its unstable methods, given a cluster URL and some optional channel config. See\n * {@link createDefaultRpcSubscriptionsChannelCreator} for the shape of the channel config.\n */\nexport function createSolanaRpcSubscriptions_UNSTABLE<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<Config<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcSubscriptionsImpl<TClusterUrl, SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>(\n        clusterUrl,\n        config,\n    );\n}\n\n/**\n * Creates a {@link RpcSubscriptions} instance that exposes the Solana JSON RPC WebSocket API given\n * the supplied {@link RpcSubscriptionsTransport}.\n */\nexport function createSolanaRpcSubscriptionsFromTransport<\n    TTransport extends RpcSubscriptionsTransport,\n    TApi extends RpcSubscriptionsApiMethods = SolanaRpcSubscriptionsApi,\n>(transport: TTransport) {\n    return createSubscriptionRpc({\n        api: createSolanaRpcSubscriptionsApi<TApi>(DEFAULT_RPC_SUBSCRIPTIONS_CONFIG),\n        transport,\n    }) as RpcSubscriptionsFromTransport<TApi, TTransport>;\n}\n","import { cloneDeep } from './cloneDeep.mjs';\nimport { clone } from '../../object/clone.mjs';\nimport { isPrimitive } from '../../predicate/isPrimitive.mjs';\nimport { getSymbols } from '../_internal/getSymbols.mjs';\nimport { isArguments } from '../predicate/isArguments.mjs';\nimport { isObjectLike } from '../predicate/isObjectLike.mjs';\nimport { isPlainObject } from '../predicate/isPlainObject.mjs';\nimport { isTypedArray } from '../predicate/isTypedArray.mjs';\n\nfunction mergeWith(object, ...otherArgs) {\n    const sources = otherArgs.slice(0, -1);\n    const merge = otherArgs[otherArgs.length - 1];\n    let result = object;\n    for (let i = 0; i < sources.length; i++) {\n        const source = sources[i];\n        result = mergeWithDeep(result, source, merge, new Map());\n    }\n    return result;\n}\nfunction mergeWithDeep(target, source, merge, stack) {\n    if (isPrimitive(target)) {\n        target = Object(target);\n    }\n    if (source == null || typeof source !== 'object') {\n        return target;\n    }\n    if (stack.has(source)) {\n        return clone(stack.get(source));\n    }\n    stack.set(source, target);\n    if (Array.isArray(source)) {\n        source = source.slice();\n        for (let i = 0; i < source.length; i++) {\n            source[i] = source[i] ?? undefined;\n        }\n    }\n    const sourceKeys = [...Object.keys(source), ...getSymbols(source)];\n    for (let i = 0; i < sourceKeys.length; i++) {\n        const key = sourceKeys[i];\n        let sourceValue = source[key];\n        let targetValue = target[key];\n        if (isArguments(sourceValue)) {\n            sourceValue = { ...sourceValue };\n        }\n        if (isArguments(targetValue)) {\n            targetValue = { ...targetValue };\n        }\n        if (typeof Buffer !== 'undefined' && Buffer.isBuffer(sourceValue)) {\n            sourceValue = cloneDeep(sourceValue);\n        }\n        if (Array.isArray(sourceValue)) {\n            if (typeof targetValue === 'object' && targetValue != null) {\n                const cloned = [];\n                const targetKeys = Reflect.ownKeys(targetValue);\n                for (let i = 0; i < targetKeys.length; i++) {\n                    const targetKey = targetKeys[i];\n                    cloned[targetKey] = targetValue[targetKey];\n                }\n                targetValue = cloned;\n            }\n            else {\n                targetValue = [];\n            }\n        }\n        const merged = merge(targetValue, sourceValue, key, target, source, stack);\n        if (merged != null) {\n            target[key] = merged;\n        }\n        else if (Array.isArray(sourceValue)) {\n            target[key] = mergeWithDeep(targetValue, sourceValue, merge, stack);\n        }\n        else if (isObjectLike(targetValue) && isObjectLike(sourceValue)) {\n            target[key] = mergeWithDeep(targetValue, sourceValue, merge, stack);\n        }\n        else if (targetValue == null && isPlainObject(sourceValue)) {\n            target[key] = mergeWithDeep({}, sourceValue, merge, stack);\n        }\n        else if (targetValue == null && isTypedArray(sourceValue)) {\n            target[key] = cloneDeep(sourceValue);\n        }\n        else if (targetValue === undefined || sourceValue !== undefined) {\n            target[key] = sourceValue;\n        }\n    }\n    return target;\n}\n\nexport { mergeWith };\n","import {\n  BaseTransactionMessage,\n  TransactionMessageWithFeePayer,\n} from '@solana/kit';\nimport {\n  MAX_COMPUTE_UNIT_LIMIT,\n  PROVISORY_COMPUTE_UNIT_LIMIT,\n} from './constants';\nimport {\n  EstimateComputeUnitLimitFactoryFunction,\n  EstimateComputeUnitLimitFactoryFunctionConfig,\n} from './estimateComputeLimitInternal';\nimport { getSetComputeUnitLimitInstructionIndexAndUnits } from './internal';\nimport { updateOrAppendSetComputeUnitLimitInstruction } from './setComputeLimit';\n\ntype EstimateAndUpdateProvisoryComputeUnitLimitFactoryFunction = <\n  TTransactionMessage extends BaseTransactionMessage &\n    TransactionMessageWithFeePayer,\n>(\n  transactionMessage: TTransactionMessage,\n  config?: EstimateComputeUnitLimitFactoryFunctionConfig\n) => Promise<TTransactionMessage>;\n\n/**\n * Given a transaction message, if it does not have an explicit compute unit limit,\n * estimates the compute unit limit and updates the transaction message with\n * the estimated limit. Otherwise, returns the transaction message unchanged.\n *\n * It requires a function that estimates the compute unit limit.\n *\n * @example\n * ```ts\n * const estimateAndUpdateCUs = estimateAndUpdateProvisoryComputeUnitLimitFactory(\n *     estimateComputeUnitLimitFactory({ rpc })\n * );\n *\n * const transactionMessageWithCUs = await estimateAndUpdateCUs(transactionMessage);\n * ```\n *\n * @see {@link estimateAndUpdateProvisoryComputeUnitLimitFactory}\n */\nexport function estimateAndUpdateProvisoryComputeUnitLimitFactory(\n  estimateComputeUnitLimit: EstimateComputeUnitLimitFactoryFunction\n): EstimateAndUpdateProvisoryComputeUnitLimitFactoryFunction {\n  return async function fn(transactionMessage, config) {\n    const instructionDetails =\n      getSetComputeUnitLimitInstructionIndexAndUnits(transactionMessage);\n\n    // If the transaction message already has a compute unit limit instruction\n    // which is set to a specific value  i.e. not 0 or the maximum limit \n    // we don't need to estimate the compute unit limit.\n    if (\n      instructionDetails &&\n      instructionDetails.units !== PROVISORY_COMPUTE_UNIT_LIMIT &&\n      instructionDetails.units !== MAX_COMPUTE_UNIT_LIMIT\n    ) {\n      return transactionMessage;\n    }\n\n    return updateOrAppendSetComputeUnitLimitInstruction(\n      await estimateComputeUnitLimit(transactionMessage, config),\n      transactionMessage\n    );\n  };\n}\n","import {\n  BaseTransactionMessage,\n  Commitment,\n  compileTransaction,\n  getBase64EncodedWireTransaction,\n  isSolanaError,\n  isTransactionMessageWithDurableNonceLifetime,\n  pipe,\n  Rpc,\n  SimulateTransactionApi,\n  Slot,\n  SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT,\n  SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n  SolanaError,\n  Transaction,\n  TransactionMessageWithFeePayer,\n} from '@solana/kit';\nimport { updateOrAppendSetComputeUnitLimitInstruction } from './setComputeLimit';\nimport { MAX_COMPUTE_UNIT_LIMIT } from './constants';\n\nexport type EstimateComputeUnitLimitFactoryConfig = Readonly<{\n  /** An object that supports the {@link SimulateTransactionApi} of the Solana RPC API */\n  rpc: Rpc<SimulateTransactionApi>;\n}>;\n\nexport type EstimateComputeUnitLimitFactoryFunction = (\n  transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer,\n  config?: EstimateComputeUnitLimitFactoryFunctionConfig\n) => Promise<number>;\n\nexport type EstimateComputeUnitLimitFactoryFunctionConfig = {\n  abortSignal?: AbortSignal;\n  /**\n   * Compute the estimate as of the highest slot that has reached this level of commitment.\n   *\n   * @defaultValue Whichever default is applied by the underlying {@link RpcApi} in use. For\n   * example, when using an API created by a `createSolanaRpc*()` helper, the default commitment\n   * is `\"confirmed\"` unless configured otherwise. Unmitigated by an API layer on the client, the\n   * default commitment applied by the server is `\"finalized\"`.\n   */\n  commitment?: Commitment;\n  /**\n   * Prevents accessing stale data by enforcing that the RPC node has processed transactions up to\n   * this slot\n   */\n  minContextSlot?: Slot;\n};\n\ntype EstimateComputeUnitLimitConfig =\n  EstimateComputeUnitLimitFactoryFunctionConfig &\n    Readonly<{\n      rpc: Rpc<SimulateTransactionApi>;\n      transactionMessage: BaseTransactionMessage &\n        TransactionMessageWithFeePayer;\n    }>;\n\n/**\n * Simulates a transaction message on the network and returns the number of compute units it\n * consumed during simulation.\n *\n * The estimate this function returns can be used to set a compute unit limit on the transaction.\n * Correctly budgeting a compute unit limit for your transaction message can increase the probability\n * that your transaction will be accepted for processing.\n *\n * If you don't declare a compute unit limit on your transaction, validators will assume an upper\n * limit of 200K compute units (CU) per instruction. Since validators have an incentive to pack as\n * many transactions into each block as possible, they may choose to include transactions that they\n * know will fit into the remaining compute budget for the current block over transactions that\n * might not. For this reason, you should set a compute unit limit on each of your transaction\n * messages, whenever possible.\n *\n * ## Example\n *\n * ```ts\n * import { getSetComputeLimitInstruction } from '@solana-program/compute-budget';\n * import { createSolanaRpc, getComputeUnitEstimateForTransactionMessageFactory, pipe } from '@solana/kit';\n *\n * // Create an estimator function.\n * const rpc = createSolanaRpc('http://127.0.0.1:8899');\n * const getComputeUnitEstimateForTransactionMessage =\n *     getComputeUnitEstimateForTransactionMessageFactory({ rpc });\n *\n * // Create your transaction message.\n * const transactionMessage = pipe(\n *     createTransactionMessage({ version: 'legacy' }),\n *     /* ... *\\/\n * );\n *\n * // Request an estimate of the actual compute units this message will consume.\n * const computeUnitsEstimate =\n *     await getComputeUnitEstimateForTransactionMessage(transactionMessage);\n *\n * // Set the transaction message's compute unit budget.\n * const transactionMessageWithComputeUnitLimit = prependTransactionMessageInstruction(\n *     getSetComputeLimitInstruction({ units: computeUnitsEstimate }),\n *     transactionMessage,\n * );\n * ```\n *\n * > [!WARNING]\n * > The compute unit estimate is just that &ndash; an estimate. The compute unit consumption of the\n * > actual transaction might be higher or lower than what was observed in simulation. Unless you\n * > are confident that your particular transaction message will consume the same or fewer compute\n * > units as was estimated, you might like to augment the estimate by either a fixed number of CUs\n * > or a multiplier.\n *\n * > [!NOTE]\n * > If you are preparing an _unsigned_ transaction, destined to be signed and submitted to the\n * > network by a wallet, you might like to leave it up to the wallet to determine the compute unit\n * > limit. Consider that the wallet might have a more global view of how many compute units certain\n * > types of transactions consume, and might be able to make better estimates of an appropriate\n * > compute unit budget.\n */\nexport async function estimateComputeUnitLimit({\n  transactionMessage,\n  ...configs\n}: EstimateComputeUnitLimitConfig): Promise<number> {\n  const replaceRecentBlockhash =\n    !isTransactionMessageWithDurableNonceLifetime(transactionMessage);\n  const transaction = pipe(\n    transactionMessage,\n    (m) =>\n      updateOrAppendSetComputeUnitLimitInstruction(MAX_COMPUTE_UNIT_LIMIT, m),\n    compileTransaction\n  );\n\n  return await simulateTransactionAndGetConsumedUnits({\n    transaction,\n    replaceRecentBlockhash,\n    ...configs,\n  });\n}\n\ntype SimulateTransactionAndGetConsumedUnitsConfig = Omit<\n  EstimateComputeUnitLimitConfig,\n  'transactionMessage'\n> &\n  Readonly<{ replaceRecentBlockhash?: boolean; transaction: Transaction }>;\n\nasync function simulateTransactionAndGetConsumedUnits({\n  abortSignal,\n  rpc,\n  transaction,\n  ...simulateConfig\n}: SimulateTransactionAndGetConsumedUnitsConfig): Promise<number> {\n  const wireTransactionBytes = getBase64EncodedWireTransaction(transaction);\n\n  try {\n    const {\n      value: { err: transactionError, unitsConsumed },\n    } = await rpc\n      .simulateTransaction(wireTransactionBytes, {\n        ...simulateConfig,\n        encoding: 'base64',\n        sigVerify: false,\n      })\n      .send({ abortSignal });\n    if (unitsConsumed == null) {\n      // This should never be hit, because all RPCs should support `unitsConsumed` by now.\n      throw new SolanaError(\n        SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT\n      );\n    }\n    // FIXME(https://github.com/anza-xyz/agave/issues/1295): The simulation response returns\n    // compute units as a u64, but the `SetComputeLimit` instruction only accepts a u32. Until\n    // this changes, downcast it.\n    const downcastUnitsConsumed =\n      unitsConsumed > 4_294_967_295n ? 4_294_967_295 : Number(unitsConsumed);\n    if (transactionError) {\n      throw new SolanaError(\n        SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n        {\n          cause: transactionError,\n          unitsConsumed: downcastUnitsConsumed,\n        }\n      );\n    }\n    return downcastUnitsConsumed;\n  } catch (e) {\n    if (\n      isSolanaError(\n        e,\n        SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT\n      )\n    )\n      throw e;\n    throw new SolanaError(\n      SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT,\n      { cause: e }\n    );\n  }\n}\n","import { from } from './base.js';\nimport {\n  fromString,\n  toString\n} from '../bytes.js';\nexport const identity = from({\n  prefix: '\\0',\n  name: 'identity',\n  encode: buf => toString(buf),\n  decode: str => fromString(str)\n});","import { rfc4648 } from './base.js';\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n});","import { rfc4648 } from './base.js';\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n});","export const Base64EncodedRegex = /^[A-Za-z0-9+/]*={0,2}$/;\n\n/**\n * Encodes a string to base64 format\n *\n * @param data - The string to be encoded to base64\n * @returns The base64 encoded string\n */\nexport function safeBase64Encode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    return globalThis.btoa(data);\n  }\n  return Buffer.from(data).toString(\"base64\");\n}\n\n/**\n * Decodes a base64 string back to its original format\n *\n * @param data - The base64 encoded string to be decoded\n * @returns The decoded string in UTF-8 format\n */\nexport function safeBase64Decode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.atob === \"function\") {\n    return globalThis.atob(data);\n  }\n  return Buffer.from(data, \"base64\").toString(\"utf-8\");\n}\n","export const usdcABI = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"spender\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"value\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"Approval\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"authorizer\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"bytes32\",\n        name: \"nonce\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"AuthorizationCanceled\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"authorizer\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"bytes32\",\n        name: \"nonce\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"AuthorizationUsed\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"_account\",\n        type: \"address\",\n      },\n    ],\n    name: \"Blacklisted\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newBlacklister\",\n        type: \"address\",\n      },\n    ],\n    name: \"BlacklisterChanged\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"burner\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"Burn\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newMasterMinter\",\n        type: \"address\",\n      },\n    ],\n    name: \"MasterMinterChanged\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"minter\",\n        type: \"address\",\n      },\n      { indexed: true, internalType: \"address\", name: \"to\", type: \"address\" },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"Mint\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"minter\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"minterAllowedAmount\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"MinterConfigured\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"oldMinter\",\n        type: \"address\",\n      },\n    ],\n    name: \"MinterRemoved\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"previousOwner\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"newOwner\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnershipTransferred\",\n    type: \"event\",\n  },\n  { anonymous: false, inputs: [], name: \"Pause\", type: \"event\" },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newAddress\",\n        type: \"address\",\n      },\n    ],\n    name: \"PauserChanged\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newRescuer\",\n        type: \"address\",\n      },\n    ],\n    name: \"RescuerChanged\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      { indexed: true, internalType: \"address\", name: \"from\", type: \"address\" },\n      { indexed: true, internalType: \"address\", name: \"to\", type: \"address\" },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"value\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"Transfer\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"_account\",\n        type: \"address\",\n      },\n    ],\n    name: \"UnBlacklisted\",\n    type: \"event\",\n  },\n  { anonymous: false, inputs: [], name: \"Unpause\", type: \"event\" },\n  {\n    inputs: [],\n    name: \"CANCEL_AUTHORIZATION_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"DOMAIN_SEPARATOR\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"PERMIT_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"RECEIVE_WITH_AUTHORIZATION_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"TRANSFER_WITH_AUTHORIZATION_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"owner\", type: \"address\" },\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n    ],\n    name: \"allowance\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n    ],\n    name: \"approve\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"authorizer\", type: \"address\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n    ],\n    name: \"authorizationState\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n    name: \"balanceOf\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_account\", type: \"address\" }],\n    name: \"blacklist\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"blacklister\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"uint256\", name: \"_amount\", type: \"uint256\" }],\n    name: \"burn\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"authorizer\", type: \"address\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\n      { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\n      { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" },\n    ],\n    name: \"cancelAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"authorizer\", type: \"address\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" },\n    ],\n    name: \"cancelAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"minter\", type: \"address\" },\n      { internalType: \"uint256\", name: \"minterAllowedAmount\", type: \"uint256\" },\n    ],\n    name: \"configureMinter\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"currency\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"decimals\",\n    outputs: [{ internalType: \"uint8\", name: \"\", type: \"uint8\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"decrement\", type: \"uint256\" },\n    ],\n    name: \"decreaseAllowance\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"increment\", type: \"uint256\" },\n    ],\n    name: \"increaseAllowance\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"string\", name: \"tokenName\", type: \"string\" },\n      { internalType: \"string\", name: \"tokenSymbol\", type: \"string\" },\n      { internalType: \"string\", name: \"tokenCurrency\", type: \"string\" },\n      { internalType: \"uint8\", name: \"tokenDecimals\", type: \"uint8\" },\n      { internalType: \"address\", name: \"newMasterMinter\", type: \"address\" },\n      { internalType: \"address\", name: \"newPauser\", type: \"address\" },\n      { internalType: \"address\", name: \"newBlacklister\", type: \"address\" },\n      { internalType: \"address\", name: \"newOwner\", type: \"address\" },\n    ],\n    name: \"initialize\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"string\", name: \"newName\", type: \"string\" }],\n    name: \"initializeV2\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"lostAndFound\", type: \"address\" }],\n    name: \"initializeV2_1\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address[]\",\n        name: \"accountsToBlacklist\",\n        type: \"address[]\",\n      },\n      { internalType: \"string\", name: \"newSymbol\", type: \"string\" },\n    ],\n    name: \"initializeV2_2\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_account\", type: \"address\" }],\n    name: \"isBlacklisted\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n    name: \"isMinter\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"masterMinter\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"_to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"_amount\", type: \"uint256\" },\n    ],\n    name: \"mint\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"minter\", type: \"address\" }],\n    name: \"minterAllowance\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"name\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"owner\", type: \"address\" }],\n    name: \"nonces\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"owner\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"pause\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"paused\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"pauser\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"owner\", type: \"address\" },\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" },\n    ],\n    name: \"permit\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"owner\", type: \"address\" },\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\n      { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\n      { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\n      { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" },\n    ],\n    name: \"permit\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" },\n    ],\n    name: \"receiveWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\n      { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\n      { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" },\n    ],\n    name: \"receiveWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"minter\", type: \"address\" }],\n    name: \"removeMinter\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"contract IERC20\",\n        name: \"tokenContract\",\n        type: \"address\",\n      },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n    ],\n    name: \"rescueERC20\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"rescuer\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"symbol\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n    ],\n    name: \"transfer\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n    ],\n    name: \"transferFrom\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"newOwner\", type: \"address\" }],\n    name: \"transferOwnership\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" },\n    ],\n    name: \"transferWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\n      { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\n      { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" },\n    ],\n    name: \"transferWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_account\", type: \"address\" }],\n    name: \"unBlacklist\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"unpause\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_newBlacklister\", type: \"address\" }],\n    name: \"updateBlacklister\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_newMasterMinter\", type: \"address\" }],\n    name: \"updateMasterMinter\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_newPauser\", type: \"address\" }],\n    name: \"updatePauser\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"newRescuer\", type: \"address\" }],\n    name: \"updateRescuer\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"version\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n] as const;\n","import { baseX } from './base.js';\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n});","import { z } from \"zod\";\nimport { NetworkSchema } from \"../shared\";\nimport { SvmAddressRegex } from \"../shared/svm\";\nimport { Base64EncodedRegex } from \"../../shared/base64\";\n\n// Constants\nconst EvmMaxAtomicUnits = 18;\nconst EvmAddressRegex = /^0x[0-9a-fA-F]{40}$/;\nconst MixedAddressRegex = /^0x[a-fA-F0-9]{40}|[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$/;\nconst HexEncoded64ByteRegex = /^0x[0-9a-fA-F]{64}$/;\nconst EvmSignatureRegex = /^0x[0-9a-fA-F]+$/; // Flexible hex signature validation\n// Enums\nexport const schemes = [\"exact\"] as const;\nexport const x402Versions = [1] as const;\nexport const ErrorReasons = [\n  \"insufficient_funds\",\n  \"invalid_exact_evm_payload_authorization_valid_after\",\n  \"invalid_exact_evm_payload_authorization_valid_before\",\n  \"invalid_exact_evm_payload_authorization_value\",\n  \"invalid_exact_evm_payload_signature\",\n  \"invalid_exact_evm_payload_undeployed_smart_wallet\",\n  \"invalid_exact_evm_payload_recipient_mismatch\",\n  \"invalid_exact_svm_payload_transaction\",\n  \"invalid_exact_svm_payload_transaction_amount_mismatch\",\n  \"invalid_exact_svm_payload_transaction_create_ata_instruction\",\n  \"invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_payee\",\n  \"invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_asset\",\n  \"invalid_exact_svm_payload_transaction_instructions\",\n  \"invalid_exact_svm_payload_transaction_instructions_length\",\n  \"invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction\",\n  \"invalid_exact_svm_payload_transaction_instructions_compute_price_instruction\",\n  \"invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high\",\n  \"invalid_exact_svm_payload_transaction_instruction_not_spl_token_transfer_checked\",\n  \"invalid_exact_svm_payload_transaction_instruction_not_token_2022_transfer_checked\",\n  \"invalid_exact_svm_payload_transaction_fee_payer_included_in_instruction_accounts\",\n  \"invalid_exact_svm_payload_transaction_fee_payer_transferring_funds\",\n  \"invalid_exact_svm_payload_transaction_not_a_transfer_instruction\",\n  \"invalid_exact_svm_payload_transaction_receiver_ata_not_found\",\n  \"invalid_exact_svm_payload_transaction_sender_ata_not_found\",\n  \"invalid_exact_svm_payload_transaction_simulation_failed\",\n  \"invalid_exact_svm_payload_transaction_transfer_to_incorrect_ata\",\n  \"invalid_network\",\n  \"invalid_payload\",\n  \"invalid_payment_requirements\",\n  \"invalid_scheme\",\n  \"invalid_payment\",\n  \"payment_expired\",\n  \"unsupported_scheme\",\n  \"invalid_x402_version\",\n  \"invalid_transaction_state\",\n  \"invalid_x402_version\",\n  \"settle_exact_svm_block_height_exceeded\",\n  \"settle_exact_svm_transaction_confirmation_timed_out\",\n  \"unsupported_scheme\",\n  \"unexpected_settle_error\",\n  \"unexpected_verify_error\",\n] as const;\n\n// Refiners\nconst isInteger: (value: string) => boolean = value =>\n  Number.isInteger(Number(value)) && Number(value) >= 0;\nconst hasMaxLength = (maxLength: number) => (value: string) => value.length <= maxLength;\n\n// x402PaymentRequirements\nconst EvmOrSvmAddress = z.string().regex(EvmAddressRegex).or(z.string().regex(SvmAddressRegex));\nconst mixedAddressOrSvmAddress = z\n  .string()\n  .regex(MixedAddressRegex)\n  .or(z.string().regex(SvmAddressRegex));\nexport const PaymentRequirementsSchema = z.object({\n  scheme: z.enum(schemes),\n  network: NetworkSchema,\n  maxAmountRequired: z.string().refine(isInteger),\n  resource: z.string().url(),\n  description: z.string(),\n  mimeType: z.string(),\n  outputSchema: z.record(z.any()).optional(),\n  payTo: EvmOrSvmAddress,\n  maxTimeoutSeconds: z.number().int(),\n  asset: mixedAddressOrSvmAddress,\n  extra: z.record(z.any()).optional(),\n});\nexport type PaymentRequirements = z.infer<typeof PaymentRequirementsSchema>;\n\n// x402ExactEvmPayload\nexport const ExactEvmPayloadAuthorizationSchema = z.object({\n  from: z.string().regex(EvmAddressRegex),\n  to: z.string().regex(EvmAddressRegex),\n  value: z.string().refine(isInteger).refine(hasMaxLength(EvmMaxAtomicUnits)),\n  validAfter: z.string().refine(isInteger),\n  validBefore: z.string().refine(isInteger),\n  nonce: z.string().regex(HexEncoded64ByteRegex),\n});\nexport type ExactEvmPayloadAuthorization = z.infer<typeof ExactEvmPayloadAuthorizationSchema>;\n\nexport const ExactEvmPayloadSchema = z.object({\n  signature: z.string().regex(EvmSignatureRegex),\n  authorization: ExactEvmPayloadAuthorizationSchema,\n});\nexport type ExactEvmPayload = z.infer<typeof ExactEvmPayloadSchema>;\n\n// x402ExactSvmPayload\nexport const ExactSvmPayloadSchema = z.object({\n  transaction: z.string().regex(Base64EncodedRegex),\n});\nexport type ExactSvmPayload = z.infer<typeof ExactSvmPayloadSchema>;\n\n// x402PaymentPayload\nexport const PaymentPayloadSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  scheme: z.enum(schemes),\n  network: NetworkSchema,\n  payload: z.union([ExactEvmPayloadSchema, ExactSvmPayloadSchema]),\n});\nexport type PaymentPayload = z.infer<typeof PaymentPayloadSchema>;\nexport type UnsignedPaymentPayload = Omit<PaymentPayload, \"payload\"> & {\n  payload: Omit<ExactEvmPayload, \"signature\"> & { signature: undefined };\n};\n\n// x402 Resource Server Response\nexport const x402ResponseSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  error: z.enum(ErrorReasons).optional(),\n  accepts: z.array(PaymentRequirementsSchema).optional(),\n  payer: z.string().regex(MixedAddressRegex).optional(),\n});\nexport type x402Response = z.infer<typeof x402ResponseSchema>;\n\n// x402RequestStructure\nconst HTTPVerbsSchema = z.enum([\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\", \"HEAD\"]);\nexport type HTTPVerbs = z.infer<typeof HTTPVerbsSchema>;\n\nexport const HTTPRequestStructureSchema = z.object({\n  type: z.literal(\"http\"),\n  method: HTTPVerbsSchema,\n  queryParams: z.record(z.string(), z.string()).optional(),\n  bodyType: z.enum([\"json\", \"form-data\", \"multipart-form-data\", \"text\", \"binary\"]).optional(),\n  bodyFields: z.record(z.string(), z.any()).optional(),\n  headerFields: z.record(z.string(), z.any()).optional(),\n});\n\n// export const MCPRequestStructureSchema = z.object({\n//   type: z.literal(\"mcp\"),\n//   sessionIsPayed: z.boolean(),\n//   payedAction: z.object({\n//     kind: z.enum([\"prompts\", \"resources\", \"tools\"]),\n//     name: z.string(),\n//   }).optional(),\n// });\n\n// export const OpenAPIRequestStructureSchema = z.object({\n//   type: z.literal(\"openapi\"),\n//   openApiUrl: z.string().url(),\n//   path: z.string(),\n// });\n\nexport const RequestStructureSchema = z.discriminatedUnion(\"type\", [\n  HTTPRequestStructureSchema,\n  // MCPRequestStructureSchema,\n  // OpenAPIRequestStructureSchema,\n]);\n\nexport type HTTPRequestStructure = z.infer<typeof HTTPRequestStructureSchema>;\n// export type MCPRequestStructure = z.infer<typeof MCPRequestStructureSchema>;\n// export type OpenAPIRequestStructure = z.infer<typeof OpenAPIRequestStructureSchema>;\nexport type RequestStructure = z.infer<typeof RequestStructureSchema>;\n\n// x402DiscoveryResource\nexport const DiscoveredResourceSchema = z.object({\n  resource: z.string(),\n  type: z.enum([\"http\"]),\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  accepts: z.array(PaymentRequirementsSchema),\n  lastUpdated: z.date(),\n  metadata: z.record(z.any()).optional(),\n});\nexport type DiscoveredResource = z.infer<typeof DiscoveredResourceSchema>;\n\n// x402SettleRequest\nexport const SettleRequestSchema = z.object({\n  paymentPayload: PaymentPayloadSchema,\n  paymentRequirements: PaymentRequirementsSchema,\n});\nexport type SettleRequest = z.infer<typeof SettleRequestSchema>;\n\n// x402VerifyRequest\nexport const VerifyRequestSchema = z.object({\n  paymentPayload: PaymentPayloadSchema,\n  paymentRequirements: PaymentRequirementsSchema,\n});\nexport type VerifyRequest = z.infer<typeof VerifyRequestSchema>;\n\n// x402VerifyResponse\nexport const VerifyResponseSchema = z.object({\n  isValid: z.boolean(),\n  invalidReason: z.enum(ErrorReasons).optional(),\n  payer: EvmOrSvmAddress.optional(),\n});\nexport type VerifyResponse = z.infer<typeof VerifyResponseSchema>;\n\n// x402SettleResponse\nexport const SettleResponseSchema = z.object({\n  success: z.boolean(),\n  errorReason: z.enum(ErrorReasons).optional(),\n  payer: EvmOrSvmAddress.optional(),\n  transaction: z.string().regex(MixedAddressRegex),\n  network: NetworkSchema,\n});\nexport type SettleResponse = z.infer<typeof SettleResponseSchema>;\n\n// x402DiscoverListRequest\nexport const ListDiscoveryResourcesRequestSchema = z.object({\n  type: z.string().optional(),\n  limit: z.number().optional(),\n  offset: z.number().optional(),\n});\nexport type ListDiscoveryResourcesRequest = z.infer<typeof ListDiscoveryResourcesRequestSchema>;\n\n// x402ListDiscoveryResourcesResponse\nexport const ListDiscoveryResourcesResponseSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  items: z.array(DiscoveredResourceSchema),\n  pagination: z.object({\n    limit: z.number(),\n    offset: z.number(),\n    total: z.number(),\n  }),\n});\nexport type ListDiscoveryResourcesResponse = z.infer<typeof ListDiscoveryResourcesResponseSchema>;\n\n// x402SupportedPaymentKind\nexport const SupportedPaymentKindSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  scheme: z.enum(schemes),\n  network: NetworkSchema,\n  extra: z.record(z.any()).optional(),\n});\nexport type SupportedPaymentKind = z.infer<typeof SupportedPaymentKindSchema>;\n\n// x402SupportedPaymentKindsResponse\nexport const SupportedPaymentKindsResponseSchema = z.object({\n  kinds: z.array(SupportedPaymentKindSchema),\n});\nexport type SupportedPaymentKindsResponse = z.infer<typeof SupportedPaymentKindsResponseSchema>;\n","import { rfc4648 } from './base.js';\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n});\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n});","import { mergeWith } from './mergeWith.mjs';\nimport { noop } from '../../function/noop.mjs';\n\nfunction merge(object, ...sources) {\n    return mergeWith(object, ...sources, noop);\n}\n\nexport { merge };\n","export const LOGGER = \"error\";\n\nexport const RELAY_URL = \"wss://relay.walletconnect.org\";\n\nexport const PROTOCOL = \"wc\";\nexport const WC_VERSION = 2;\nexport const CONTEXT = \"universal_provider\";\n\nexport const STORAGE = `${PROTOCOL}@${WC_VERSION}:${CONTEXT}:`;\n\nexport const RPC_URL = \"https://rpc.walletconnect.org/v1/\";\n\nexport const GENERIC_SUBPROVIDER_NAME = \"generic\";\n\nexport const BUNDLER_URL = `${RPC_URL}bundler`;\n\nexport const CALL_STATUS_STORAGE_KEY = \"call_status\";\n\nexport const CALL_STATUS_RESULT_EXPIRY = 86400; // 24 hours in seconds\n","import { merge } from \"es-toolkit/compat\";\nimport { SessionTypes } from \"@walletconnect/types\";\nimport {\n  isCaipNamespace,\n  isValidObject,\n  mergeArrays,\n  parseChainId,\n  parseNamespaceKey,\n} from \"@walletconnect/utils\";\nimport { RPC_URL } from \"../constants/index.js\";\nimport { Namespace, NamespaceConfig } from \"../types/index.js\";\n\nexport function getRpcUrl(chainId: string, rpc: Namespace, projectId?: string): string | undefined {\n  const chain = parseChainId(chainId);\n  return (\n    rpc.rpcMap?.[chain.reference] ||\n    `${RPC_URL}?chainId=${chain.namespace}:${chain.reference}&projectId=${projectId}`\n  );\n}\n\nexport function getChainId(chain: string): string {\n  return chain.includes(\":\") ? chain.split(\":\")[1] : chain;\n}\n\nexport function validateChainApproval(chain: string, chains: string[]): void {\n  if (!chains.includes(chain)) {\n    throw new Error(\n      `Chain '${chain}' not approved. Please use one of the following: ${chains.toString()}`,\n    );\n  }\n}\n\nexport function getChainsFromApprovedSession(accounts: string[]): string[] {\n  return accounts.map((address) => `${address.split(\":\")[0]}:${address.split(\":\")[1]}`);\n}\n\nexport function getAccountsFromSession(namespace: string, session: SessionTypes.Struct): string[] {\n  // match namespaces e.g. eip155 with eip155:1\n  const matchedNamespaceKeys = Object.keys(session.namespaces).filter((key) =>\n    key.includes(namespace),\n  );\n  if (!matchedNamespaceKeys.length) return [];\n  const accounts: string[] = [];\n  matchedNamespaceKeys.forEach((key) => {\n    const accountsForNamespace = session.namespaces[key].accounts;\n    accounts.push(...accountsForNamespace);\n  });\n  return accounts;\n}\n\nexport function filterNamespacesWithNoChains(namespaces: NamespaceConfig): NamespaceConfig {\n  return Object.fromEntries(\n    Object.entries(namespaces).filter(([_, ns]) => ns?.chains?.length && ns?.chains?.length > 0),\n  );\n}\n\nexport function mergeRequiredOptionalNamespaces(\n  required: NamespaceConfig = {},\n  optional: NamespaceConfig = {},\n) {\n  const requiredNamespaces = filterNamespacesWithNoChains(normalizeNamespaces(required));\n  const optionalNamespaces = filterNamespacesWithNoChains(normalizeNamespaces(optional));\n  return merge(requiredNamespaces, optionalNamespaces);\n}\n\n/**\n * Converts\n * {\n *  \"eip155:1\": {...},\n *  \"eip155:2\": {...},\n * }\n * into\n * {\n *  \"eip155\": {\n *      chains: [\"eip155:1\", \"eip155:2\"],\n *      ...\n *    }\n * }\n *\n */\nexport function normalizeNamespaces(namespaces: NamespaceConfig): NamespaceConfig {\n  const normalizedNamespaces: NamespaceConfig = {};\n  if (!isValidObject(namespaces)) return normalizedNamespaces;\n\n  for (const [key, values] of Object.entries(namespaces)) {\n    const chains = isCaipNamespace(key) ? [key] : values.chains;\n    const methods = values.methods || [];\n    const events = values.events || [];\n    const rpcMap = values.rpcMap || {};\n    const normalizedKey = parseNamespaceKey(key);\n    normalizedNamespaces[normalizedKey] = {\n      ...normalizedNamespaces[normalizedKey],\n      ...values,\n      chains: mergeArrays(chains, normalizedNamespaces[normalizedKey]?.chains),\n      methods: mergeArrays(methods, normalizedNamespaces[normalizedKey]?.methods),\n      events: mergeArrays(events, normalizedNamespaces[normalizedKey]?.events),\n    };\n    // avoid adding empty `rpcMap: {}` if there are no values for it\n    if (isValidObject(rpcMap) || isValidObject(normalizedNamespaces[normalizedKey]?.rpcMap || {})) {\n      normalizedNamespaces[normalizedKey].rpcMap = {\n        ...rpcMap,\n        ...normalizedNamespaces[normalizedKey]?.rpcMap,\n      };\n    }\n  }\n  return normalizedNamespaces;\n}\n\nexport function parseCaip10Account(caip10Account: string): string {\n  return caip10Account.includes(\":\") ? caip10Account.split(\":\")[2] : caip10Account;\n}\n\n/**\n * Populates the chains array for each namespace with the chains extracted from the accounts if are otherwise missing\n */\nexport function populateNamespacesChains(\n  namespaces: SessionTypes.Namespaces,\n): Record<string, SessionTypes.Namespace> {\n  const parsedNamespaces: Record<string, SessionTypes.Namespace> = {};\n  for (const [key, values] of Object.entries(namespaces)) {\n    const methods = values.methods || [];\n    const events = values.events || [];\n    const accounts = values.accounts || [];\n    // If the key includes a CAIP separator `:` we know it's a namespace + chainId (e.g. `eip155:1`)\n    const chains = isCaipNamespace(key)\n      ? [key]\n      : values.chains\n        ? values.chains\n        : getChainsFromApprovedSession(values.accounts);\n    parsedNamespaces[key] = {\n      chains,\n      methods,\n      events,\n      accounts,\n    };\n  }\n  return parsedNamespaces;\n}\n\nexport function convertChainIdToNumber(chainId: string | number): number | string {\n  if (typeof chainId === \"number\") return chainId;\n  if (chainId.includes(\"0x\")) {\n    return parseInt(chainId, 16);\n  }\n\n  chainId = chainId.includes(\":\") ? chainId.split(\":\")[1] : chainId;\n  return isNaN(Number(chainId)) ? chainId : Number(chainId);\n}\n\nexport function isValidJSONObject(str: string): boolean {\n  try {\n    const parsed = JSON.parse(str);\n    return typeof parsed === \"object\" && parsed !== null && !Array.isArray(parsed);\n  } catch {\n    return false;\n  }\n}\n","const globals = {};\nexport const getGlobal = (key: string) => {\n  return globals[key];\n};\n\nexport const setGlobal = (key: string, value: unknown) => {\n  globals[key] = value;\n};\n","import {\n  estimateComputeUnitLimit,\n  EstimateComputeUnitLimitFactoryConfig,\n  EstimateComputeUnitLimitFactoryFunction,\n} from './estimateComputeLimitInternal';\n\n/**\n * Use this utility to estimate the actual compute unit cost of a given transaction message.\n *\n * Correctly budgeting a compute unit limit for your transaction message can increase the\n * probability that your transaction will be accepted for processing. If you don't declare a compute\n * unit limit on your transaction, validators will assume an upper limit of 200K compute units (CU)\n * per instruction.\n *\n * Since validators have an incentive to pack as many transactions into each block as possible, they\n * may choose to include transactions that they know will fit into the remaining compute budget for\n * the current block over transactions that might not. For this reason, you should set a compute\n * unit limit on each of your transaction messages, whenever possible.\n *\n * > [!WARNING]\n * > The compute unit estimate is just that -- an estimate. The compute unit consumption of the\n * > actual transaction might be higher or lower than what was observed in simulation. Unless you\n * > are confident that your particular transaction message will consume the same or fewer compute\n * > units as was estimated, you might like to augment the estimate by either a fixed number of CUs\n * > or a multiplier.\n *\n * > [!NOTE]\n * > If you are preparing an _unsigned_ transaction, destined to be signed and submitted to the\n * > network by a wallet, you might like to leave it up to the wallet to determine the compute unit\n * > limit. Consider that the wallet might have a more global view of how many compute units certain\n * > types of transactions consume, and might be able to make better estimates of an appropriate\n * > compute unit budget.\n *\n * > [!INFO]\n * > In the event that a transaction message does not already have a `SetComputeUnitLimit`\n * > instruction, this function will add one before simulation. This ensures that the compute unit\n * > consumption of the `SetComputeUnitLimit` instruction itself is included in the estimate.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { getSetComputeUnitLimitInstruction } from '@solana-program/compute-budget';\n * import { createSolanaRpc, estimateComputeUnitLimitFactory, pipe } from '@solana/kit';\n *\n * // Create an estimator function.\n * const rpc = createSolanaRpc('http://127.0.0.1:8899');\n * const estimateComputeUnitLimit = estimateComputeUnitLimitFactory({ rpc });\n *\n * // Create your transaction message.\n * const transactionMessage = pipe(\n *     createTransactionMessage({ version: 'legacy' }),\n *     /* ... *\\/\n * );\n *\n * // Request an estimate of the actual compute units this message will consume. This is done by\n * // simulating the transaction and grabbing the estimated compute units from the result.\n * const estimatedUnits = await estimateComputeUnitLimit(transactionMessage);\n *\n * // Set the transaction message's compute unit budget.\n * const transactionMessageWithComputeUnitLimit = prependTransactionMessageInstruction(\n *     getSetComputeUnitLimitInstruction({ units: estimatedUnits }),\n *     transactionMessage,\n * );\n * ```\n */\nexport function estimateComputeUnitLimitFactory({\n  rpc,\n}: EstimateComputeUnitLimitFactoryConfig): EstimateComputeUnitLimitFactoryFunction {\n  return async function estimateComputeUnitLimitFactoryFunction(\n    transactionMessage,\n    config\n  ) {\n    return await estimateComputeUnitLimit({\n      ...config,\n      rpc,\n      transactionMessage,\n    });\n  };\n}\n","import { SessionTypes } from \"@walletconnect/types\";\nimport { isValidObject } from \"@walletconnect/utils\";\n\nimport { isValidJSONObject } from \"./misc.js\";\n\nconst EIP155_PREFIX = \"eip155\";\nconst CAPABILITIES_KEYS = [\n  \"atomic\",\n  \"flow-control\",\n  \"paymasterService\",\n  \"sessionKeys\",\n  \"auxiliaryFunds\",\n];\n\nconst hexToDecimal = (hex?: string) => {\n  return hex && hex.startsWith(\"0x\") ? BigInt(hex).toString(10) : hex;\n};\n\nconst decimalToHex = (decimal: string) => {\n  return decimal && decimal.startsWith(\"0x\") ? decimal : `0x${BigInt(decimal).toString(16)}`;\n};\n\nconst getCapabilitiesFromObject = (object: Record<string, any>) => {\n  const capabilitiesKeys = Object.keys(object).filter((item) => CAPABILITIES_KEYS.includes(item));\n\n  return capabilitiesKeys.reduce(\n    (acc, key) => {\n      acc[key] = parseCapabilityValue(object[key]);\n      return acc;\n    },\n    {} as Record<string, any>,\n  );\n};\n\nconst parseCapabilityValue = (value: any) => {\n  if (typeof value === \"string\" && isValidJSONObject(value)) {\n    return JSON.parse(value);\n  }\n  return value;\n};\n\nexport const extractCapabilitiesFromSession = (\n  session: SessionTypes.Struct,\n  address: string,\n  chainIds: string[],\n) => {\n  const { sessionProperties = {}, scopedProperties = {} } = session;\n  const result: Record<string, any> = {};\n\n  if (!isValidObject(scopedProperties) && !isValidObject(sessionProperties)) {\n    return;\n  }\n\n  // get all capabilities from sessionProperties as they apply to all chains/addresses\n  const globalCapabilities = getCapabilitiesFromObject(sessionProperties);\n\n  for (const chain of chainIds) {\n    const chainId = hexToDecimal(chain);\n    if (!chainId) {\n      continue;\n    }\n\n    result[decimalToHex(chainId)] = globalCapabilities;\n\n    const chainSpecific = scopedProperties?.[`${EIP155_PREFIX}:${chainId}`];\n\n    if (chainSpecific) {\n      const addressSpecific = chainSpecific?.[`${EIP155_PREFIX}:${chainId}:${address}`];\n\n      // use the address specific capabilities if they exist, otherwise use the chain specific capabilities\n      result[decimalToHex(chainId)] = {\n        ...result[decimalToHex(chainId)],\n        ...getCapabilitiesFromObject(addressSpecific || chainSpecific),\n      };\n    }\n  }\n\n  // remove any chains that have no capabilities\n  for (const [key, value] of Object.entries(result)) {\n    if (Object.keys(value).length === 0) {\n      delete result[key];\n    }\n  }\n\n  return Object.keys(result).length > 0 ? result : undefined;\n};\n","import { IKeyValueStorage } from \"@walletconnect/keyvaluestorage\";\n\nlet storage: Storage;\n\nexport class Storage {\n  private storage: IKeyValueStorage;\n  constructor(storage: IKeyValueStorage) {\n    this.storage = storage;\n  }\n\n  async getItem<T>(key: string): Promise<T | undefined> {\n    return await this.storage.getItem<T>(key);\n  }\n\n  async setItem<T>(key: string, value: T) {\n    return await this.storage.setItem(key, value);\n  }\n\n  async removeItem(key: string) {\n    return await this.storage.removeItem(key);\n  }\n\n  static getStorage(kvStorage: IKeyValueStorage) {\n    if (!storage) {\n      storage = new Storage(kvStorage);\n    }\n    return storage;\n  }\n}\n","import { calcExpiry, isExpired, parseChainId } from \"@walletconnect/utils\";\nimport { formatJsonRpcRequest } from \"@walletconnect/jsonrpc-utils\";\nimport JsonRpcProvider from \"@walletconnect/jsonrpc-provider\";\n\nimport { StoredSendCalls, StoreSendCallsParams } from \"../types/index.js\";\nimport { CALL_STATUS_RESULT_EXPIRY, CALL_STATUS_STORAGE_KEY } from \"../constants/index.js\";\nimport { Storage } from \"./storage.js\";\n\nexport async function prepareCallStatusFromStoredSendCalls(\n  storedSendCalls: StoredSendCalls,\n  getHttpProvider: (chainId: number) => JsonRpcProvider,\n) {\n  const chainId = parseChainId(storedSendCalls.result.capabilities.caip345.caip2);\n  const hashes = storedSendCalls.result.capabilities.caip345.transactionHashes;\n  const allPromises = await Promise.allSettled(\n    hashes.map((hash) => getTransactionReceipt(chainId.reference, hash, getHttpProvider)),\n  );\n  const receipts = allPromises\n    .filter((r) => r.status === \"fulfilled\")\n    .map((r) => r.value)\n    .filter((r) => r);\n\n  // log failed transactions\n  allPromises\n    .filter((r) => r.status === \"rejected\")\n    .forEach((r) => console.warn(\"Failed to fetch transaction receipt:\", r.reason));\n\n  const someReceiptsPending = !receipts.length || receipts.some((r) => !r);\n  const allReceiptsSuccessful = receipts.every((r) => r?.status === \"0x1\");\n  const allReceiptsFailed = receipts.every((r) => r?.status === \"0x0\");\n  const someReceiptsFailed = receipts.some((r) => r?.status === \"0x0\");\n\n  let status;\n  if (someReceiptsPending) {\n    //100 = some pending\n    status = 100;\n  } else if (allReceiptsSuccessful) {\n    // 200 = all successful\n    status = 200;\n  } else if (allReceiptsFailed) {\n    // 500 = all failed\n    status = 500;\n  } else if (someReceiptsFailed) {\n    // 600 = some failures\n    status = 600;\n  }\n\n  return {\n    id: storedSendCalls.result.id,\n    version: storedSendCalls.request.version,\n    atomic: storedSendCalls.request.atomicRequired,\n    chainId: storedSendCalls.request.chainId,\n    capabilities: storedSendCalls.result.capabilities,\n    receipts,\n    status,\n  };\n}\n\nexport async function getTransactionReceipt(\n  chainId: string,\n  transactionHash: string,\n  getHttpProvider: (chainId: number) => JsonRpcProvider,\n) {\n  return await getHttpProvider(parseInt(chainId)).request(\n    formatJsonRpcRequest(\"eth_getTransactionReceipt\", [transactionHash]),\n  );\n}\n\nexport async function storeSendCalls({\n  sendCalls,\n  storage,\n}: {\n  sendCalls: StoreSendCallsParams;\n  storage: Storage;\n}) {\n  const sendCallsStatusResults =\n    await storage.getItem<Record<string, StoredSendCalls>>(CALL_STATUS_STORAGE_KEY);\n\n  await storage.setItem(CALL_STATUS_STORAGE_KEY, {\n    ...sendCallsStatusResults,\n    [sendCalls.result.id]: {\n      request: sendCalls.request,\n      result: sendCalls.result,\n      expiry: calcExpiry(CALL_STATUS_RESULT_EXPIRY),\n    },\n  });\n}\n\nexport async function deleteSendCallsResult({\n  resultId,\n  storage,\n}: {\n  resultId: string;\n  storage: Storage;\n}) {\n  const sendCallsStatusResults =\n    await storage.getItem<Record<string, StoredSendCalls>>(CALL_STATUS_STORAGE_KEY);\n  if (!sendCallsStatusResults) return;\n\n  delete sendCallsStatusResults[resultId];\n  await storage.setItem(CALL_STATUS_STORAGE_KEY, sendCallsStatusResults);\n\n  // delete old expired results\n  for (const resultId in sendCallsStatusResults) {\n    if (isExpired(sendCallsStatusResults[resultId].expiry)) {\n      delete sendCallsStatusResults[resultId];\n    }\n  }\n  await storage.setItem(CALL_STATUS_STORAGE_KEY, sendCallsStatusResults);\n}\n\nexport async function getStoredSendCalls({\n  resultId,\n  storage,\n}: {\n  resultId: string;\n  storage: Storage;\n}): Promise<StoredSendCalls | undefined> {\n  const storedSendCalls =\n    await storage.getItem<Record<string, StoredSendCalls>>(CALL_STATUS_STORAGE_KEY);\n\n  const result = storedSendCalls?.[resultId];\n  if (result && !isExpired(result.expiry)) {\n    return result;\n  } else {\n    await deleteSendCallsResult({ resultId, storage });\n  }\n\n  return undefined;\n}\n","import { rfc4648 } from './base.js';\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n});\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n});\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n});\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n});\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n});\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n});\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n});\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n});\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n});","import Client from \"@walletconnect/sign-client\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport { HttpConnection } from \"@walletconnect/jsonrpc-http-connection\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport { formatJsonRpcRequest } from \"@walletconnect/jsonrpc-utils\";\n\nimport {\n  IProvider,\n  RpcProvidersMap,\n  SubProviderOpts,\n  RequestParams,\n  SessionNamespace,\n  SendCallsResult,\n} from \"../types/index.js\";\n\nimport {\n  extractCapabilitiesFromSession,\n  getChainId,\n  getGlobal,\n  getRpcUrl,\n  getStoredSendCalls,\n  prepareCallStatusFromStoredSendCalls,\n  Storage,\n  storeSendCalls,\n} from \"../utils/index.js\";\nimport EventEmitter from \"events\";\nimport { BUNDLER_URL, PROVIDER_EVENTS } from \"../constants/index.js\";\n\nclass Eip155Provider implements IProvider {\n  public name = \"eip155\";\n  public client: Client;\n  // the active chainId on the dapp\n  public chainId: number;\n  public namespace: SessionNamespace;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public storage: Storage;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.httpProviders = this.createHttpProviders();\n    this.chainId = parseInt(this.getDefaultChain());\n    this.storage = Storage.getStorage(this.client.core.storage);\n  }\n\n  public async request<T = unknown>(args: RequestParams): Promise<T> {\n    switch (args.request.method) {\n      case \"eth_requestAccounts\":\n        return this.getAccounts() as unknown as T;\n      case \"eth_accounts\":\n        return this.getAccounts() as unknown as T;\n      case \"wallet_switchEthereumChain\": {\n        return (await this.handleSwitchChain(args)) as unknown as T;\n      }\n      case \"eth_chainId\":\n        return parseInt(this.getDefaultChain()) as unknown as T;\n      case \"wallet_getCapabilities\":\n        return (await this.getCapabilities(args)) as unknown as T;\n      case \"wallet_getCallsStatus\":\n        return (await this.getCallStatus(args)) as unknown as T;\n      case \"wallet_sendCalls\":\n        return (await this.sendCalls(args)) as unknown as T;\n      default:\n        break;\n    }\n    if (this.namespace.methods.includes(args.request.method)) {\n      return await this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(parseInt(chainId), rpcUrl);\n    }\n    const previous = this.chainId;\n    this.chainId = parseInt(chainId);\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, {\n      currentCaipChainId: `${this.name}:${chainId}`,\n      previousCaipChainId: `${this.name}:${previous}`,\n    });\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId.toString();\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private createHttpProvider(\n    chainId: number,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc =\n      rpcUrl || getRpcUrl(`${this.name}:${chainId}`, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n\n  private setHttpProvider(chainId: number, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChain = parseInt(getChainId(chain));\n      http[parsedChain] = this.createHttpProvider(parsedChain, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private getHttpProvider(chainId?: number): JsonRpcProvider {\n    const chain = chainId || this.chainId;\n    const http = this.httpProviders[chain];\n    if (http) {\n      return http;\n    }\n\n    this.httpProviders = {\n      ...this.httpProviders,\n      [chain]: this.createHttpProvider(chain),\n    };\n    return this.httpProviders[chain];\n  }\n\n  private async handleSwitchChain(args: RequestParams): Promise<any> {\n    let hexChainId = args.request.params ? args.request.params[0]?.chainId : \"0x0\";\n    hexChainId = hexChainId.startsWith(\"0x\") ? hexChainId : `0x${hexChainId}`;\n    const parsedChainId = parseInt(hexChainId, 16);\n    // if chainId is already approved, switch locally\n    if (this.isChainApproved(parsedChainId)) {\n      this.setDefaultChain(`${parsedChainId}`);\n    } else if (this.namespace.methods.includes(\"wallet_switchEthereumChain\")) {\n      // try to switch chain within the wallet\n      await this.client.request({\n        topic: args.topic,\n        request: {\n          method: args.request.method,\n          params: [\n            {\n              chainId: hexChainId,\n            },\n          ],\n        },\n        chainId: this.namespace.chains?.[0], // Sending a previously unapproved chainId will cause namespace validation failure so we must set request chainId to the first chainId in the namespace to avoid it\n      } as EngineTypes.RequestParams);\n      this.setDefaultChain(`${parsedChainId}`);\n    } else {\n      throw new Error(\n        `Failed to switch to chain 'eip155:${parsedChainId}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`,\n      );\n    }\n    return null;\n  }\n\n  private isChainApproved(chainId: number): boolean {\n    return this.namespace.chains.includes(`${this.name}:${chainId}`);\n  }\n\n  /**\n   * util method to get the capabilities for given address and chainIds from the wallet\n   * 1. check if the capabilities are stored in the sessionProperties legacy way - address+chainIds for backwards compatibility\n   * 2. check if the capabilities are stored in the sessionProperties\n   * 3. check if the capabilities are stored in the scopedProperties\n   * 4. if not, send the request to the wallet\n   * 5. update the session with the capabilities so they can be retrieved later\n   * 6. return the capabilities\n   */\n  private async getCapabilities(args: RequestParams) {\n    // if capabilities are stored in the session, return them, else send the request to the wallet\n    const address = args.request?.params?.[0];\n    const chainIds: string[] = args.request?.params?.[1] || [];\n\n    if (!address) throw new Error(\"Missing address parameter in `wallet_getCapabilities` request\");\n    const session = this.client.session.get(args.topic);\n    const sessionCapabilities = session?.sessionProperties?.capabilities || {};\n\n    // cache key is address + chainIds to allow requests to be made to different chains\n    const capabilitiesKey = `${address}${chainIds.join(\",\")}`;\n    const legacyCapabilities = sessionCapabilities?.[capabilitiesKey];\n    if (legacyCapabilities) {\n      return legacyCapabilities;\n    }\n    let cachedCapabilities;\n    try {\n      cachedCapabilities = extractCapabilitiesFromSession(session, address, chainIds);\n    } catch (error) {\n      console.warn(\"Failed to extract capabilities from session\", error);\n    }\n\n    if (cachedCapabilities) {\n      return cachedCapabilities;\n    }\n\n    // intentionally omit catching errors/rejection during `request` to allow the error to bubble up\n    const capabilities = await this.client.request(args as EngineTypes.RequestParams);\n    try {\n      // update the session with the capabilities so they can be retrieved later\n      await this.client.session.update(args.topic, {\n        sessionProperties: {\n          ...(session.sessionProperties || {}),\n          capabilities: {\n            ...(sessionCapabilities || {}),\n            [capabilitiesKey]: capabilities,\n          } as any, // by spec sessionProperties should be <string, string> but here are used as objects?\n        },\n      });\n    } catch (error) {\n      console.warn(\"Failed to update session with capabilities\", error);\n    }\n    return capabilities;\n  }\n\n  private async getCallStatus(args: RequestParams) {\n    const session = this.client.session.get(args.topic);\n    const bundlerName = session.sessionProperties?.bundler_name as string;\n    if (bundlerName) {\n      const bundlerUrl = this.getBundlerUrl(args.chainId, bundlerName);\n      try {\n        return await this.getUserOperationReceipt(bundlerUrl, args);\n      } catch (error) {\n        console.warn(\"Failed to fetch call status from bundler\", error, bundlerUrl);\n      }\n    }\n    const customUrl = session.sessionProperties?.bundler_url as string;\n    if (customUrl) {\n      try {\n        return await this.getUserOperationReceipt(customUrl, args);\n      } catch (error) {\n        console.warn(\"Failed to fetch call status from custom bundler\", error, customUrl);\n      }\n    }\n\n    const storedSendCalls = await getStoredSendCalls({\n      resultId: args.request.params?.[0] as string,\n      storage: this.storage,\n    });\n    if (storedSendCalls) {\n      try {\n        return await prepareCallStatusFromStoredSendCalls(\n          storedSendCalls,\n          this.getHttpProvider.bind(this),\n        );\n      } catch (error) {\n        console.warn(\"Failed to fetch call status from stored send calls\", error, storedSendCalls);\n      }\n    }\n\n    if (this.namespace.methods.includes(args.request.method)) {\n      return await this.client.request(args as EngineTypes.RequestParams);\n    }\n\n    throw new Error(\"Fetching call status not approved by the wallet.\");\n  }\n\n  private async getUserOperationReceipt(bundlerUrl: string, args: RequestParams) {\n    const url = new URL(bundlerUrl);\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(\n        formatJsonRpcRequest(\"eth_getUserOperationReceipt\", [args.request.params?.[0]]),\n      ),\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch user operation receipt - ${response.status}`);\n    }\n    return await response.json();\n  }\n\n  private getBundlerUrl(cap2ChainId: string, bundlerName: string) {\n    return `${BUNDLER_URL}?projectId=${this.client.core.projectId}&chainId=${cap2ChainId}&bundler=${bundlerName}`;\n  }\n\n  private async sendCalls(args: RequestParams) {\n    const result = await this.client.request<SendCallsResult>(args as EngineTypes.RequestParams);\n    const sendCallsParams = args.request.params?.[0];\n    const resultId = result?.id;\n    const capabilities = result?.capabilities || {};\n    const caip2 = capabilities?.caip345?.caip2;\n    const transactionHashes = capabilities?.caip345?.transactionHashes;\n\n    if (!resultId || !caip2 || !transactionHashes?.length) {\n      return result;\n    }\n\n    await storeSendCalls({\n      sendCalls: { request: sendCallsParams, result },\n      storage: this.storage,\n    });\n    return result;\n  }\n}\n\nexport default Eip155Provider;\n","import { SignClient } from \"@walletconnect/sign-client\";\nimport { SessionTypes } from \"@walletconnect/types\";\nimport { JsonRpcResult } from \"@walletconnect/jsonrpc-types\";\nimport { createLogger, getSdkError, isValidArray, parseNamespaceKey } from \"@walletconnect/utils\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport {\n  convertChainIdToNumber,\n  getAccountsFromSession,\n  getChainsFromApprovedSession,\n  mergeRequiredOptionalNamespaces,\n  parseCaip10Account,\n  populateNamespacesChains,\n  setGlobal,\n} from \"./utils/index.js\";\nimport Eip155Provider from \"./providers/eip155.js\";\nimport GenericProvider from \"./providers/generic.js\";\n\nimport {\n  IUniversalProvider,\n  IProvider,\n  RpcProviderMap,\n  ConnectParams,\n  RequestArguments,\n  UniversalProviderOpts,\n  NamespaceConfig,\n  PairingsCleanupOpts,\n  ProviderAccounts,\n  AuthenticateParams,\n  DefaultChainChanged,\n  OnChainChanged,\n  EmitAccountsChangedOnChainChange,\n} from \"./types/index.js\";\n\nimport {\n  RELAY_URL,\n  LOGGER,\n  STORAGE,\n  PROVIDER_EVENTS,\n  GENERIC_SUBPROVIDER_NAME,\n  CONTEXT,\n} from \"./constants/index.js\";\nimport EventEmitter from \"events\";\nimport { formatJsonRpcResult } from \"@walletconnect/jsonrpc-utils\";\n\nexport class UniversalProvider implements IUniversalProvider {\n  public client!: InstanceType<typeof SignClient>;\n  public namespaces?: NamespaceConfig;\n  public optionalNamespaces?: NamespaceConfig;\n  public sessionProperties?: SessionTypes.SessionProperties;\n  public scopedProperties?: SessionTypes.ScopedProperties;\n  public events: EventEmitter = new EventEmitter();\n  public rpcProviders: RpcProviderMap = {};\n  public session?: SessionTypes.Struct;\n  public providerOpts: UniversalProviderOpts;\n  public logger: Logger;\n  public uri: string | undefined;\n\n  private disableProviderPing = false;\n\n  static async init(opts: UniversalProviderOpts) {\n    const provider = new UniversalProvider(opts);\n    await provider.initialize();\n    return provider;\n  }\n\n  constructor(opts: UniversalProviderOpts) {\n    this.providerOpts = opts;\n    this.logger = createLogger({\n      logger: opts.logger ?? LOGGER,\n      name: this.providerOpts.name ?? CONTEXT,\n    });\n    this.disableProviderPing = opts?.disableProviderPing || false;\n  }\n\n  public async request<T = unknown>(\n    args: RequestArguments,\n    chain?: string | undefined,\n    expiry?: number | undefined,\n  ): Promise<T> {\n    const [namespace, chainId] = this.validateChain(chain);\n\n    if (!this.session) {\n      throw new Error(\"Please call connect() before request()\");\n    }\n    return (await this.getProvider(namespace).request({\n      request: {\n        ...args,\n      },\n      chainId: `${namespace}:${chainId}`,\n      topic: this.session.topic,\n      expiry,\n    })) as T;\n  }\n\n  public sendAsync(\n    args: RequestArguments,\n    callback: (error: Error | null, response: JsonRpcResult) => void,\n    chain?: string | undefined,\n    expiry?: number | undefined,\n  ): void {\n    const id = new Date().getTime();\n    this.request(args, chain, expiry)\n      .then((response) => callback(null, formatJsonRpcResult(id, response)))\n      .catch((error) => callback(error, undefined as any));\n  }\n\n  public async enable(): Promise<ProviderAccounts> {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n    if (!this.session) {\n      await this.connect({\n        namespaces: this.namespaces,\n        optionalNamespaces: this.optionalNamespaces,\n        sessionProperties: this.sessionProperties,\n        scopedProperties: this.scopedProperties,\n      });\n    }\n    const accounts = await this.requestAccounts();\n    return accounts as ProviderAccounts;\n  }\n\n  public async disconnect(): Promise<void> {\n    if (!this.session) {\n      throw new Error(\"Please call connect() before enable()\");\n    }\n    await this.client.disconnect({\n      topic: this.session?.topic,\n      reason: getSdkError(\"USER_DISCONNECTED\"),\n    });\n    await this.cleanup();\n  }\n\n  public async connect(opts: ConnectParams): Promise<SessionTypes.Struct | undefined> {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n    this.setNamespaces(opts);\n    // omit `await` to avoid delaying the pairing flow\n    this.cleanupPendingPairings();\n    if (opts.skipPairing) return;\n\n    return await this.pair(opts.pairingTopic);\n  }\n\n  public async authenticate(opts: AuthenticateParams, walletUniversalLink?: string) {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n    this.setNamespaces(opts);\n    await this.cleanupPendingPairings();\n\n    const { uri, response } = await this.client.authenticate(opts, walletUniversalLink);\n    if (uri) {\n      this.uri = uri;\n      this.events.emit(\"display_uri\", uri);\n    }\n    const result = await response();\n    this.session = result.session;\n    if (this.session) {\n      // assign namespaces from session if not already defined\n      const approved = populateNamespacesChains(this.session.namespaces) as NamespaceConfig;\n      this.namespaces = mergeRequiredOptionalNamespaces(this.namespaces, approved);\n      await this.persist(\"namespaces\", this.namespaces);\n      this.onConnect();\n    }\n    return result;\n  }\n\n  public on(event: any, listener: any): void {\n    this.events.on(event, listener);\n  }\n\n  public once(event: string, listener: any): void {\n    this.events.once(event, listener);\n  }\n\n  public removeListener(event: string, listener: any): void {\n    this.events.removeListener(event, listener);\n  }\n\n  public off(event: string, listener: any): void {\n    this.events.off(event, listener);\n  }\n\n  get isWalletConnect() {\n    return true;\n  }\n\n  public async pair(pairingTopic: string | undefined): Promise<SessionTypes.Struct> {\n    const { uri, approval } = await this.client.connect({\n      pairingTopic,\n      requiredNamespaces: this.namespaces,\n      optionalNamespaces: this.optionalNamespaces,\n      sessionProperties: this.sessionProperties,\n      scopedProperties: this.scopedProperties,\n    });\n\n    if (uri) {\n      this.uri = uri;\n      this.events.emit(\"display_uri\", uri);\n    }\n\n    const session = await approval();\n    this.session = session;\n    // assign namespaces from session if not already defined\n    const approved = populateNamespacesChains(session.namespaces) as NamespaceConfig;\n    this.namespaces = mergeRequiredOptionalNamespaces(this.namespaces, approved);\n    await this.persist(\"namespaces\", this.namespaces);\n    await this.persist(\"optionalNamespaces\", this.optionalNamespaces);\n\n    this.onConnect();\n    return this.session;\n  }\n\n  public setDefaultChain(chain: string, rpcUrl?: string | undefined) {\n    try {\n      // ignore without active session\n      if (!this.session) return;\n      const [namespace, chainId] = this.validateChain(chain);\n      const provider = this.getProvider(namespace);\n      provider.setDefaultChain(chainId, rpcUrl);\n    } catch (error) {\n      // ignore the error if the fx is used prematurely before namespaces are set\n      if (!/Please call connect/.test((error as Error).message)) throw error;\n    }\n  }\n\n  public async cleanupPendingPairings(opts: PairingsCleanupOpts = {}): Promise<void> {\n    try {\n      this.logger.info(\"Cleaning up inactive pairings...\");\n      const inactivePairings = this.client.pairing.getAll();\n\n      if (!isValidArray(inactivePairings)) return;\n\n      for (const pairing of inactivePairings) {\n        if (opts.deletePairings) {\n          this.client.core.expirer.set(pairing.topic, 0);\n        } else {\n          await this.client.core.relayer.subscriber.unsubscribe(pairing.topic);\n        }\n      }\n\n      this.logger.info(`Inactive pairings cleared: ${inactivePairings.length}`);\n    } catch (error) {\n      this.logger.warn(error, \"Failed to cleanup pending pairings\");\n    }\n  }\n\n  public abortPairingAttempt() {\n    this.logger.warn(\"abortPairingAttempt is deprecated. This is now a no-op.\");\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async checkStorage() {\n    this.namespaces = (await this.getFromStore(`namespaces`)) || {};\n    this.optionalNamespaces = (await this.getFromStore(`optionalNamespaces`)) || {};\n    if (this.session) this.createProviders();\n  }\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    await this.createClient();\n    await this.checkStorage();\n    this.registerEventListeners();\n  }\n\n  private async createClient() {\n    this.client =\n      this.providerOpts.client ||\n      (await SignClient.init({\n        core: this.providerOpts.core,\n        logger: this.providerOpts.logger || LOGGER,\n        relayUrl: this.providerOpts.relayUrl || RELAY_URL,\n        projectId: this.providerOpts.projectId,\n        metadata: this.providerOpts.metadata,\n        storageOptions: this.providerOpts.storageOptions,\n        storage: this.providerOpts.storage,\n        name: this.providerOpts.name,\n        customStoragePrefix: this.providerOpts.customStoragePrefix,\n        telemetryEnabled: this.providerOpts.telemetryEnabled,\n      }));\n\n    if (this.providerOpts.session) {\n      try {\n        this.session = this.client.session.get(this.providerOpts.session.topic);\n      } catch (error) {\n        this.logger.error(error, \"Failed to get session\");\n        throw new Error(\n          `The provided session: ${this.providerOpts?.session?.topic} doesn't exist in the Sign client`,\n        );\n      }\n    } else {\n      const sessions = this.client.session.getAll();\n      this.session = sessions[0];\n    }\n    this.logger.trace(`SignClient Initialized`);\n  }\n\n  private createProviders(): void {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n\n    if (!this.session) {\n      throw new Error(\"Session not initialized. Please call connect() before enable()\");\n    }\n\n    const providersToCreate = [\n      ...new Set(\n        Object.keys(this.session.namespaces).map((namespace) => parseNamespaceKey(namespace)),\n      ),\n    ];\n\n    setGlobal(\"client\", this.client);\n    setGlobal(\"events\", this.events);\n    setGlobal(\"disableProviderPing\", this.disableProviderPing);\n\n    providersToCreate.forEach((namespace) => {\n      if (!this.session) return;\n      const accounts = getAccountsFromSession(namespace, this.session);\n      if (accounts?.length === 0) {\n        return;\n      }\n      const approvedChains = getChainsFromApprovedSession(accounts);\n      const mergedNamespaces = mergeRequiredOptionalNamespaces(\n        this.namespaces,\n        this.optionalNamespaces,\n      );\n      const combinedNamespace = {\n        ...mergedNamespaces[namespace],\n        accounts,\n        chains: approvedChains,\n      };\n      switch (namespace) {\n        case \"eip155\":\n          this.rpcProviders[namespace] = new Eip155Provider({\n            namespace: combinedNamespace,\n          });\n          break;\n        default:\n          this.rpcProviders[namespace] = new GenericProvider({\n            namespace: combinedNamespace,\n          });\n      }\n    });\n  }\n\n  private registerEventListeners(): void {\n    if (typeof this.client === \"undefined\") {\n      throw new Error(\"Sign Client is not initialized\");\n    }\n\n    this.client.on(\"session_ping\", (args) => {\n      const { topic } = args;\n      if (topic !== this.session?.topic) return;\n      this.events.emit(\"session_ping\", args);\n    });\n\n    this.client.on(\"session_event\", (args) => {\n      const { params, topic } = args;\n      if (topic !== this.session?.topic) return;\n      const { event } = params;\n      if (event.name === \"accountsChanged\") {\n        const accounts = event.data;\n        if (accounts && isValidArray(accounts))\n          this.events.emit(\"accountsChanged\", accounts.map(parseCaip10Account));\n      } else if (event.name === \"chainChanged\") {\n        const requestChainId = params.chainId;\n        const payloadChainId = params.event.data as number;\n        const namespace = parseNamespaceKey(requestChainId);\n        // chainIds might differ between the request & payload - request is always in CAIP2 format, while payload might be string, number, CAIP2 or hex\n        // take priority of the payload chainId\n        const chainIdToProcess =\n          convertChainIdToNumber(requestChainId) !== convertChainIdToNumber(payloadChainId)\n            ? `${namespace}:${convertChainIdToNumber(payloadChainId)}`\n            : requestChainId;\n\n        this.onChainChanged({ currentCaipChainId: chainIdToProcess });\n      } else {\n        this.events.emit(event.name, event.data);\n      }\n\n      this.events.emit(\"session_event\", args);\n    });\n\n    this.client.on(\"session_update\", ({ topic, params }) => {\n      if (topic !== this.session?.topic) return;\n      const { namespaces } = params;\n      const _session = this.client?.session.get(topic);\n      this.session = { ..._session, namespaces } as SessionTypes.Struct;\n      this.onSessionUpdate();\n      this.events.emit(\"session_update\", { topic, params });\n    });\n\n    this.client.on(\"session_delete\", async (payload) => {\n      if (payload.topic !== this.session?.topic) return;\n      await this.cleanup();\n      this.events.emit(\"session_delete\", payload);\n      this.events.emit(\"disconnect\", {\n        ...getSdkError(\"USER_DISCONNECTED\"),\n        data: payload.topic,\n      });\n    });\n\n    this.on(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, (params: DefaultChainChanged) => {\n      this.onChainChanged({ ...params, internal: true });\n    });\n  }\n\n  private getProvider(namespace: string): IProvider {\n    return this.rpcProviders[namespace] || this.rpcProviders[GENERIC_SUBPROVIDER_NAME];\n  }\n\n  private onSessionUpdate(): void {\n    Object.keys(this.rpcProviders).forEach((namespace: string) => {\n      this.getProvider(namespace).updateNamespace(\n        this.session?.namespaces[namespace] as SessionTypes.BaseNamespace,\n      );\n    });\n  }\n\n  private setNamespaces(params: ConnectParams): void {\n    const {\n      namespaces = {},\n      optionalNamespaces = {},\n      sessionProperties,\n      scopedProperties,\n    } = params;\n\n    // requiredNamespaces are deprecated, assign them to optionalNamespaces\n    this.optionalNamespaces = mergeRequiredOptionalNamespaces(namespaces, optionalNamespaces);\n    this.sessionProperties = sessionProperties;\n    this.scopedProperties = scopedProperties;\n  }\n\n  private validateChain(chain?: string): [string, string] {\n    const [namespace, chainId] = chain?.split(\":\") || [\"\", \"\"];\n    if (!this.namespaces || !Object.keys(this.namespaces).length) return [namespace, chainId];\n    // validate namespace\n    if (namespace) {\n      if (\n        // some namespaces might be defined with inline chainId e.g. eip155:1\n        // and we need to parse them\n        !Object.keys(this.namespaces || {})\n          .map((key) => parseNamespaceKey(key))\n          .includes(namespace)\n      ) {\n        throw new Error(\n          `Namespace '${namespace}' is not configured. Please call connect() first with namespace config.`,\n        );\n      }\n    }\n    if (namespace && chainId) {\n      return [namespace, chainId];\n    }\n    const defaultNamespace = parseNamespaceKey(Object.keys(this.namespaces)[0]);\n    const defaultChain = this.rpcProviders[defaultNamespace].getDefaultChain();\n    return [defaultNamespace, defaultChain];\n  }\n\n  private async requestAccounts(): Promise<string[]> {\n    const [namespace] = this.validateChain();\n    return await this.getProvider(namespace).requestAccounts();\n  }\n\n  private async onChainChanged({\n    currentCaipChainId,\n    previousCaipChainId,\n    internal = false,\n  }: OnChainChanged): Promise<void> {\n    if (!this.namespaces) return;\n\n    const [namespace, chainId] = this.validateChain(currentCaipChainId);\n\n    if (!chainId) return;\n\n    this.updateNamespaceChain(namespace, chainId);\n\n    if (!internal) {\n      this.getProvider(namespace).setDefaultChain(chainId);\n    } else {\n      // emit the events during the `internal` cycle of chain change\n      // otherwise events are emitted twice\n      // once on the chainChanged event and once triggered by `this.getProvider(namespace).setDefaultChain(chainId);`\n      this.events.emit(\"chainChanged\", chainId);\n      this.emitAccountsChangedOnChainChange({\n        namespace,\n        currentCaipChainId,\n        previousCaipChainId,\n      });\n    }\n\n    await this.persist(\"namespaces\", this.namespaces);\n  }\n\n  /**\n   * Emits `accountsChanged` event when a chain is changed and there are new accounts on the new chain\n   */\n  private emitAccountsChangedOnChainChange({\n    namespace,\n    currentCaipChainId,\n    previousCaipChainId,\n  }: EmitAccountsChangedOnChainChange): void {\n    try {\n      if (previousCaipChainId === currentCaipChainId) {\n        return;\n      }\n\n      const accounts = this.session?.namespaces[namespace]?.accounts;\n      if (!accounts) return;\n      const newChainIdAccounts = accounts\n        .filter((account) => account.includes(`${currentCaipChainId}:`))\n        .map(parseCaip10Account);\n      if (!isValidArray(newChainIdAccounts)) return;\n      this.events.emit(\"accountsChanged\", newChainIdAccounts);\n    } catch (error) {\n      this.logger.warn(error, \"Failed to emit accountsChanged on chain change\");\n    }\n  }\n\n  private updateNamespaceChain(namespace: string, chainId: string): void {\n    if (!this.namespaces) return;\n\n    const namespaceKey = this.namespaces[namespace] ? namespace : `${namespace}:${chainId}`;\n\n    const defaultNamespace = {\n      chains: [],\n      methods: [],\n      events: [],\n      defaultChain: chainId,\n    };\n\n    if (!this.namespaces[namespaceKey]) {\n      this.namespaces[namespaceKey] = defaultNamespace;\n    } else if (this.namespaces[namespaceKey]) {\n      this.namespaces[namespaceKey].defaultChain = chainId;\n    }\n  }\n\n  private onConnect() {\n    this.createProviders();\n    this.events.emit(\"connect\", { session: this.session });\n  }\n\n  private async cleanup() {\n    this.namespaces = undefined;\n    this.optionalNamespaces = undefined;\n    this.sessionProperties = undefined;\n    await this.deleteFromStore(\"namespaces\");\n    await this.deleteFromStore(\"optionalNamespaces\");\n    await this.deleteFromStore(\"sessionProperties\");\n    // reset the session after removing from store as the topic is used there\n    this.session = undefined;\n    this.cleanupPendingPairings({ deletePairings: true });\n    await this.cleanupStorage();\n  }\n\n  private async persist(key: string, data: unknown) {\n    const topic = this.session?.topic || \"\";\n    await this.client.core.storage.setItem(`${STORAGE}/${key}${topic}`, data);\n  }\n\n  private async getFromStore(key: string) {\n    const topic = this.session?.topic || \"\";\n    return await this.client.core.storage.getItem(`${STORAGE}/${key}${topic}`);\n  }\n\n  private async deleteFromStore(key: string) {\n    const topic = this.session?.topic || \"\";\n    await this.client.core.storage.removeItem(`${STORAGE}/${key}${topic}`);\n  }\n\n  // remove all storage items if there are no sessions left\n  private async cleanupStorage() {\n    try {\n      if (this.client?.session.length > 0) {\n        return;\n      }\n      const keys = await this.client.core.storage.getKeys();\n      for (const key of keys) {\n        if (key.startsWith(STORAGE)) {\n          await this.client.core.storage.removeItem(key);\n        }\n      }\n    } catch (error) {\n      this.logger.warn(error, \"Failed to cleanup storage\");\n    }\n  }\n}\nexport default UniversalProvider;\n","import {\n  appendTransactionMessageInstruction,\n  BaseTransactionMessage,\n  MicroLamports,\n} from '@solana/kit';\nimport { getSetComputeUnitPriceInstruction } from './generated';\nimport { getSetComputeUnitPriceInstructionIndexAndMicroLamports } from './internal';\n\n/**\n * Sets the compute unit price of a transaction message in micro-Lamports.\n *\n * @example\n * ```ts\n * const transactionMessage = pipe(\n *   createTransactionMessage({ version: 0 }),\n *   (m) => setTransactionMessageComputeUnitPrice(10_000, m),\n *   // ...\n * );\n * ```\n */\nexport function setTransactionMessageComputeUnitPrice<\n  TTransactionMessage extends BaseTransactionMessage,\n>(microLamports: number | bigint, transactionMessage: TTransactionMessage) {\n  return appendTransactionMessageInstruction(\n    getSetComputeUnitPriceInstruction({ microLamports }),\n    transactionMessage\n  );\n}\n\n/**\n * Updates the first `SetComputeUnitPrice` instruction in a transaction message\n * with the given micro-Lamports, or appends a new instruction if none exists.\n * A function of the current value can be provided instead of a static value.\n *\n * @param microLamports - The new compute unit price, or a function that\n *                        takes the previous price and returns the new one.\n * @param transactionMessage - The transaction message to update.\n *\n * @example\n * ```ts\n * const updatedTransactionMessage = updateOrAppendSetComputeUnitPriceInstruction(\n *   // E.g. double the current price or set it to 10_000 if it isn't set.\n *   (currentPrice) => currentPrice === null ? 10_000 : currentPrice * 2,\n *   transactionMessage,\n * );\n * ```\n */\nexport function updateOrAppendSetComputeUnitPriceInstruction<\n  TTransactionMessage extends BaseTransactionMessage,\n>(\n  microLamports:\n    | MicroLamports\n    | ((previousMicroLamports: MicroLamports | null) => MicroLamports),\n  transactionMessage: TTransactionMessage\n): TTransactionMessage {\n  const getMicroLamports = (\n    previousMicroLamports: MicroLamports | null\n  ): MicroLamports =>\n    typeof microLamports === 'function'\n      ? microLamports(previousMicroLamports)\n      : microLamports;\n  const instructionDetails =\n    getSetComputeUnitPriceInstructionIndexAndMicroLamports(transactionMessage);\n\n  if (!instructionDetails) {\n    return appendTransactionMessageInstruction(\n      getSetComputeUnitPriceInstruction({\n        microLamports: getMicroLamports(null),\n      }),\n      transactionMessage\n    ) as unknown as TTransactionMessage;\n  }\n\n  const { index, microLamports: previousMicroLamports } = instructionDetails;\n  const newMicroLamports = getMicroLamports(previousMicroLamports);\n  if (newMicroLamports === previousMicroLamports) {\n    return transactionMessage;\n  }\n\n  const newInstruction = getSetComputeUnitPriceInstruction({\n    microLamports: newMicroLamports,\n  });\n  const newInstructions = [...transactionMessage.instructions];\n  newInstructions.splice(index, 1, newInstruction);\n  return Object.freeze({\n    ...transactionMessage,\n    instructions: newInstructions,\n  });\n}\n","import { UniversalProvider as Provider } from \"./UniversalProvider.js\";\nexport * from \"./types/index.js\";\nexport const UniversalProvider = Provider;\nexport default Provider;\n","import { baseX } from './base.js';\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n});\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n});","import { baseX } from './base.js';\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n});\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n});","/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { Hash, abytes, aexists, aoutput, clean, createView, toBytes } from \"./utils.js\";\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nexport function Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        data = toBytes(data);\n        abytes(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        clean(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map","import { rfc4648 } from './base.js';\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n});\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n});\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n});\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n});","import { z } from \"zod\";\nimport { safeBase64Decode, safeBase64Encode } from \"../../shared\";\nimport { PaymentRequirementsSchema, SettleResponse } from \"./x402Specs\";\n\nexport const facilitatorRequestSchema = z.object({\n  paymentHeader: z.string(),\n  paymentRequirements: PaymentRequirementsSchema,\n});\n\nexport type FacilitatorRequest = z.infer<typeof facilitatorRequestSchema>;\n\n/**\n * Encodes a settlement response into a base64 header string\n *\n * @param response - The settlement response to encode\n * @returns A base64 encoded string containing the settlement response\n */\nexport function settleResponseHeader(response: SettleResponse): string {\n  return safeBase64Encode(JSON.stringify(response));\n}\n\n/**\n * Decodes a base64 header string back into a settlement response\n *\n * @param header - The base64 encoded settlement response header\n * @returns The decoded settlement response object\n */\nexport function settleResponseFromHeader(header: string): SettleResponse {\n  const decoded = safeBase64Decode(header);\n  return JSON.parse(decoded) as SettleResponse;\n}\n","import { from } from './base.js';\nconst alphabet = Array.from('\\uD83D\\uDE80\\uD83E\\uDE90\\u2604\\uD83D\\uDEF0\\uD83C\\uDF0C\\uD83C\\uDF11\\uD83C\\uDF12\\uD83C\\uDF13\\uD83C\\uDF14\\uD83C\\uDF15\\uD83C\\uDF16\\uD83C\\uDF17\\uD83C\\uDF18\\uD83C\\uDF0D\\uD83C\\uDF0F\\uD83C\\uDF0E\\uD83D\\uDC09\\u2600\\uD83D\\uDCBB\\uD83D\\uDDA5\\uD83D\\uDCBE\\uD83D\\uDCBF\\uD83D\\uDE02\\u2764\\uD83D\\uDE0D\\uD83E\\uDD23\\uD83D\\uDE0A\\uD83D\\uDE4F\\uD83D\\uDC95\\uD83D\\uDE2D\\uD83D\\uDE18\\uD83D\\uDC4D\\uD83D\\uDE05\\uD83D\\uDC4F\\uD83D\\uDE01\\uD83D\\uDD25\\uD83E\\uDD70\\uD83D\\uDC94\\uD83D\\uDC96\\uD83D\\uDC99\\uD83D\\uDE22\\uD83E\\uDD14\\uD83D\\uDE06\\uD83D\\uDE44\\uD83D\\uDCAA\\uD83D\\uDE09\\u263A\\uD83D\\uDC4C\\uD83E\\uDD17\\uD83D\\uDC9C\\uD83D\\uDE14\\uD83D\\uDE0E\\uD83D\\uDE07\\uD83C\\uDF39\\uD83E\\uDD26\\uD83C\\uDF89\\uD83D\\uDC9E\\u270C\\u2728\\uD83E\\uDD37\\uD83D\\uDE31\\uD83D\\uDE0C\\uD83C\\uDF38\\uD83D\\uDE4C\\uD83D\\uDE0B\\uD83D\\uDC97\\uD83D\\uDC9A\\uD83D\\uDE0F\\uD83D\\uDC9B\\uD83D\\uDE42\\uD83D\\uDC93\\uD83E\\uDD29\\uD83D\\uDE04\\uD83D\\uDE00\\uD83D\\uDDA4\\uD83D\\uDE03\\uD83D\\uDCAF\\uD83D\\uDE48\\uD83D\\uDC47\\uD83C\\uDFB6\\uD83D\\uDE12\\uD83E\\uDD2D\\u2763\\uD83D\\uDE1C\\uD83D\\uDC8B\\uD83D\\uDC40\\uD83D\\uDE2A\\uD83D\\uDE11\\uD83D\\uDCA5\\uD83D\\uDE4B\\uD83D\\uDE1E\\uD83D\\uDE29\\uD83D\\uDE21\\uD83E\\uDD2A\\uD83D\\uDC4A\\uD83E\\uDD73\\uD83D\\uDE25\\uD83E\\uDD24\\uD83D\\uDC49\\uD83D\\uDC83\\uD83D\\uDE33\\u270B\\uD83D\\uDE1A\\uD83D\\uDE1D\\uD83D\\uDE34\\uD83C\\uDF1F\\uD83D\\uDE2C\\uD83D\\uDE43\\uD83C\\uDF40\\uD83C\\uDF37\\uD83D\\uDE3B\\uD83D\\uDE13\\u2B50\\u2705\\uD83E\\uDD7A\\uD83C\\uDF08\\uD83D\\uDE08\\uD83E\\uDD18\\uD83D\\uDCA6\\u2714\\uD83D\\uDE23\\uD83C\\uDFC3\\uD83D\\uDC90\\u2639\\uD83C\\uDF8A\\uD83D\\uDC98\\uD83D\\uDE20\\u261D\\uD83D\\uDE15\\uD83C\\uDF3A\\uD83C\\uDF82\\uD83C\\uDF3B\\uD83D\\uDE10\\uD83D\\uDD95\\uD83D\\uDC9D\\uD83D\\uDE4A\\uD83D\\uDE39\\uD83D\\uDDE3\\uD83D\\uDCAB\\uD83D\\uDC80\\uD83D\\uDC51\\uD83C\\uDFB5\\uD83E\\uDD1E\\uD83D\\uDE1B\\uD83D\\uDD34\\uD83D\\uDE24\\uD83C\\uDF3C\\uD83D\\uDE2B\\u26BD\\uD83E\\uDD19\\u2615\\uD83C\\uDFC6\\uD83E\\uDD2B\\uD83D\\uDC48\\uD83D\\uDE2E\\uD83D\\uDE46\\uD83C\\uDF7B\\uD83C\\uDF43\\uD83D\\uDC36\\uD83D\\uDC81\\uD83D\\uDE32\\uD83C\\uDF3F\\uD83E\\uDDE1\\uD83C\\uDF81\\u26A1\\uD83C\\uDF1E\\uD83C\\uDF88\\u274C\\u270A\\uD83D\\uDC4B\\uD83D\\uDE30\\uD83E\\uDD28\\uD83D\\uDE36\\uD83E\\uDD1D\\uD83D\\uDEB6\\uD83D\\uDCB0\\uD83C\\uDF53\\uD83D\\uDCA2\\uD83E\\uDD1F\\uD83D\\uDE41\\uD83D\\uDEA8\\uD83D\\uDCA8\\uD83E\\uDD2C\\u2708\\uD83C\\uDF80\\uD83C\\uDF7A\\uD83E\\uDD13\\uD83D\\uDE19\\uD83D\\uDC9F\\uD83C\\uDF31\\uD83D\\uDE16\\uD83D\\uDC76\\uD83E\\uDD74\\u25B6\\u27A1\\u2753\\uD83D\\uDC8E\\uD83D\\uDCB8\\u2B07\\uD83D\\uDE28\\uD83C\\uDF1A\\uD83E\\uDD8B\\uD83D\\uDE37\\uD83D\\uDD7A\\u26A0\\uD83D\\uDE45\\uD83D\\uDE1F\\uD83D\\uDE35\\uD83D\\uDC4E\\uD83E\\uDD32\\uD83E\\uDD20\\uD83E\\uDD27\\uD83D\\uDCCC\\uD83D\\uDD35\\uD83D\\uDC85\\uD83E\\uDDD0\\uD83D\\uDC3E\\uD83C\\uDF52\\uD83D\\uDE17\\uD83E\\uDD11\\uD83C\\uDF0A\\uD83E\\uDD2F\\uD83D\\uDC37\\u260E\\uD83D\\uDCA7\\uD83D\\uDE2F\\uD83D\\uDC86\\uD83D\\uDC46\\uD83C\\uDFA4\\uD83D\\uDE47\\uD83C\\uDF51\\u2744\\uD83C\\uDF34\\uD83D\\uDCA3\\uD83D\\uDC38\\uD83D\\uDC8C\\uD83D\\uDCCD\\uD83E\\uDD40\\uD83E\\uDD22\\uD83D\\uDC45\\uD83D\\uDCA1\\uD83D\\uDCA9\\uD83D\\uDC50\\uD83D\\uDCF8\\uD83D\\uDC7B\\uD83E\\uDD10\\uD83E\\uDD2E\\uD83C\\uDFBC\\uD83E\\uDD75\\uD83D\\uDEA9\\uD83C\\uDF4E\\uD83C\\uDF4A\\uD83D\\uDC7C\\uD83D\\uDC8D\\uD83D\\uDCE3\\uD83E\\uDD42');\nconst alphabetBytesToChars = alphabet.reduce((p, c, i) => {\n  p[i] = c;\n  return p;\n}, []);\nconst alphabetCharsToBytes = alphabet.reduce((p, c, i) => {\n  p[c.codePointAt(0)] = i;\n  return p;\n}, []);\nfunction encode(data) {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c];\n    return p;\n  }, '');\n}\nfunction decode(str) {\n  const byts = [];\n  for (const char of str) {\n    const byt = alphabetCharsToBytes[char.codePointAt(0)];\n    if (byt === undefined) {\n      throw new Error(`Non-base256emoji character: ${ char }`);\n    }\n    byts.push(byt);\n  }\n  return new Uint8Array(byts);\n}\nexport const base256emoji = from({\n  prefix: '\\uD83D\\uDE80',\n  name: 'base256emoji',\n  encode,\n  decode\n});","/**\n * Converts an object to a JSON-safe format by converting bigint values to strings\n * and recursively processing nested objects and arrays\n *\n * @param data - The object to convert to JSON-safe format\n * @returns A new object with all bigint values converted to strings\n */\nexport function toJsonSafe<T extends object>(data: T): object {\n  if (typeof data !== \"object\") {\n    throw new Error(\"Data is not an object\");\n  }\n\n  /**\n   * Recursively converts values to JSON-safe format\n   *\n   * @param value - The value to convert\n   * @returns The converted value with bigints as strings\n   */\n  function convert(value: unknown): unknown {\n    if (value !== null && typeof value === \"object\" && !Array.isArray(value)) {\n      return Object.fromEntries(Object.entries(value).map(([key, val]) => [key, convert(val)]));\n    }\n\n    if (Array.isArray(value)) {\n      return value.map(convert);\n    }\n\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    return value;\n  }\n\n  return convert(data) as object;\n}\n","import { Address, Hex } from \"viem\";\nimport {\n  moneySchema,\n  Network,\n  Price,\n  RouteConfig,\n  RoutePattern,\n  ERC20TokenAmount,\n  PaymentRequirements,\n  PaymentPayload,\n  SPLTokenAmount,\n} from \"../types\";\nimport { RoutesConfig } from \"../types\";\nimport { safeBase64Decode } from \"./base64\";\nimport { getUsdcChainConfigForChain } from \"./evm\";\nimport { getNetworkId } from \"./network\";\n\n/**\n * Computes the route patterns for the given routes config\n *\n * @param routes - The routes config to compute the patterns for\n * @returns The route patterns\n */\nexport function computeRoutePatterns(routes: RoutesConfig): RoutePattern[] {\n  const normalizedRoutes = Object.fromEntries(\n    Object.entries(routes).map(([pattern, value]) => [\n      pattern,\n      typeof value === \"string\" || typeof value === \"number\"\n        ? ({ price: value, network: \"base-sepolia\" } as RouteConfig)\n        : (value as RouteConfig),\n    ]),\n  );\n\n  return Object.entries(normalizedRoutes).map(([pattern, routeConfig]) => {\n    // Split pattern into verb and path, defaulting to \"*\" for verb if not specified\n    const [verb, path] = pattern.includes(\" \") ? pattern.split(/\\s+/) : [\"*\", pattern];\n    if (!path) {\n      throw new Error(`Invalid route pattern: ${pattern}`);\n    }\n    return {\n      verb: verb.toUpperCase(),\n      pattern: new RegExp(\n        `^${\n          path\n            // First escape all special regex characters except * and []\n            .replace(/[$()+.?^{|}]/g, \"\\\\$&\")\n            // Then handle our special pattern characters\n            .replace(/\\*/g, \".*?\") // Make wildcard non-greedy and optional\n            .replace(/\\[([^\\]]+)\\]/g, \"[^/]+\") // Convert [param] to regex capture\n            .replace(/\\//g, \"\\\\/\") // Escape slashes\n        }$`,\n        \"i\",\n      ),\n      config: routeConfig,\n    };\n  });\n}\n\n/**\n * Finds the matching route pattern for the given path and method\n *\n * @param routePatterns - The route patterns to search through\n * @param path - The path to match against\n * @param method - The HTTP method to match against\n * @returns The matching route pattern or undefined if no match is found\n */\nexport function findMatchingRoute(\n  routePatterns: RoutePattern[],\n  path: string,\n  method: string,\n): RoutePattern | undefined {\n  // Normalize the path:\n  // 1. Remove query parameters and hash fragments\n  // 2. Replace backslashes with forward slashes\n  // 3. Replace multiple consecutive slashes with a single slash\n  // 4. Keep trailing slash if path is not root\n  let normalizedPath: string;\n  try {\n    // First split off query parameters and hash fragments\n    const pathWithoutQuery = path.split(/[?#]/)[0];\n\n    // Then decode the path - this needs to happen before any normalization\n    // so encoded characters are properly handled\n    const decodedPath = decodeURIComponent(pathWithoutQuery);\n\n    // Normalize the path (just clean up slashes)\n    normalizedPath = decodedPath\n      .replace(/\\\\/g, \"/\") // replace backslashes\n      .replace(/\\/+/g, \"/\") // collapse slashes\n      .replace(/(.+?)\\/+$/, \"$1\"); // trim trailing slashes\n  } catch {\n    // If decoding fails (e.g., invalid % encoding), return undefined\n    return undefined;\n  }\n\n  // Find matching route pattern\n  const matchingRoutes = routePatterns.filter(({ pattern, verb }) => {\n    const matchesPath = pattern.test(normalizedPath);\n    const upperMethod = method.toUpperCase();\n    const matchesVerb = verb === \"*\" || upperMethod === verb;\n\n    const result = matchesPath && matchesVerb;\n    return result;\n  });\n\n  if (matchingRoutes.length === 0) {\n    return undefined;\n  }\n\n  // Use the most specific route (longest path pattern)\n  const matchingRoute = matchingRoutes.reduce((a, b) =>\n    b.pattern.source.length > a.pattern.source.length ? b : a,\n  );\n\n  return matchingRoute;\n}\n\n/**\n * Gets the default asset (USDC) for the given network\n *\n * @param network - The network to get the default asset for\n * @returns The default asset\n */\nexport function getDefaultAsset(network: Network) {\n  const chainId = getNetworkId(network);\n  const usdc = getUsdcChainConfigForChain(chainId);\n  if (!usdc) {\n    throw new Error(`Unable to get default asset on ${network}`);\n  }\n  return {\n    address: usdc.usdcAddress,\n    decimals: 6,\n    eip712: {\n      name: usdc.usdcName,\n      version: \"2\",\n    },\n  };\n}\n\n/**\n * Parses the amount from the given price\n *\n * @param price - The price to parse\n * @param network - The network to get the default asset for\n * @returns The parsed amount or an error message\n */\nexport function processPriceToAtomicAmount(\n  price: Price,\n  network: Network,\n):\n  | { maxAmountRequired: string; asset: ERC20TokenAmount[\"asset\"] | SPLTokenAmount[\"asset\"] }\n  | { error: string } {\n  // Handle USDC amount (string) or token amount (ERC20TokenAmount)\n  let maxAmountRequired: string;\n  let asset: ERC20TokenAmount[\"asset\"] | SPLTokenAmount[\"asset\"];\n\n  if (typeof price === \"string\" || typeof price === \"number\") {\n    // USDC amount in dollars\n    const parsedAmount = moneySchema.safeParse(price);\n    if (!parsedAmount.success) {\n      return {\n        error: `Invalid price (price: ${price}). Must be in the form \"$3.10\", 0.10, \"0.001\", ${parsedAmount.error}`,\n      };\n    }\n    const parsedUsdAmount = parsedAmount.data;\n    asset = getDefaultAsset(network);\n    maxAmountRequired = (parsedUsdAmount * 10 ** asset.decimals).toString();\n  } else {\n    // Token amount in atomic units\n    maxAmountRequired = price.amount;\n    asset = price.asset;\n  }\n\n  return {\n    maxAmountRequired,\n    asset,\n  };\n}\n\n/**\n * Finds the matching payment requirements for the given payment\n *\n * @param paymentRequirements - The payment requirements to search through\n * @param payment - The payment to match against\n * @returns The matching payment requirements or undefined if no match is found\n */\nexport function findMatchingPaymentRequirements(\n  paymentRequirements: PaymentRequirements[],\n  payment: PaymentPayload,\n) {\n  return paymentRequirements.find(\n    value => value.scheme === payment.scheme && value.network === payment.network,\n  );\n}\n\n/**\n * Decodes the X-PAYMENT-RESPONSE header\n *\n * @param header - The X-PAYMENT-RESPONSE header to decode\n * @returns The decoded payment response\n */\nexport function decodeXPaymentResponse(header: string) {\n  const decoded = safeBase64Decode(header);\n  return JSON.parse(decoded) as {\n    success: boolean;\n    transaction: Hex;\n    network: Network;\n    payer: Address;\n  };\n}\n","var encode_1 = encode;\nvar MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n  while (num >= INT) {\n    out[offset++] = num & 255 | MSB;\n    num /= 128;\n  }\n  while (num & MSBALL) {\n    out[offset++] = num & 255 | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  encode.bytes = offset - oldOffset + 1;\n  return out;\n}\nvar decode = read;\nvar MSB$1 = 128, REST$1 = 127;\nfunction read(buf, offset) {\n  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint');\n    }\n    b = buf[counter++];\n    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1);\n  read.bytes = counter - offset;\n  return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function (value) {\n  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;\n};\nvar varint = {\n  encode: encode_1,\n  decode: decode,\n  encodingLength: length\n};\nvar _brrp_varint = varint;\nexport default _brrp_varint;","import varint from '../vendor/varint.js';\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset);\n  return [\n    code,\n    varint.decode.bytes\n  ];\n};\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset);\n  return target;\n};\nexport const encodingLength = int => {\n  return varint.encodingLength(int);\n};","import {\n  coerce,\n  equals as equalBytes\n} from '../bytes.js';\nimport * as varint from '../varint.js';\nexport const create = (code, digest) => {\n  const size = digest.byteLength;\n  const sizeOffset = varint.encodingLength(code);\n  const digestOffset = sizeOffset + varint.encodingLength(size);\n  const bytes = new Uint8Array(digestOffset + size);\n  varint.encodeTo(code, bytes, 0);\n  varint.encodeTo(size, bytes, sizeOffset);\n  bytes.set(digest, digestOffset);\n  return new Digest(code, size, digest, bytes);\n};\nexport const decode = multihash => {\n  const bytes = coerce(multihash);\n  const [code, sizeOffset] = varint.decode(bytes);\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset));\n  const digest = bytes.subarray(sizeOffset + digestOffset);\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length');\n  }\n  return new Digest(code, size, digest, bytes);\n};\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true;\n  } else {\n    return a.code === b.code && a.size === b.size && equalBytes(a.bytes, b.bytes);\n  }\n};\nexport class Digest {\n  constructor(code, size, digest, bytes) {\n    this.code = code;\n    this.size = size;\n    this.digest = digest;\n    this.bytes = bytes;\n  }\n}","/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from \"./_md.js\";\nimport * as u64 from \"./_u64.js\";\nimport { clean, createHasher, rotr } from \"./utils.js\";\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD {\n    constructor(outputLen = 32) {\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        clean(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\nexport class SHA224 extends SHA256 {\n    constructor() {\n        super(28);\n        this.A = SHA224_IV[0] | 0;\n        this.B = SHA224_IV[1] | 0;\n        this.C = SHA224_IV[2] | 0;\n        this.D = SHA224_IV[3] | 0;\n        this.E = SHA224_IV[4] | 0;\n        this.F = SHA224_IV[5] | 0;\n        this.G = SHA224_IV[6] | 0;\n        this.H = SHA224_IV[7] | 0;\n    }\n}\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends HashMD {\n    constructor(outputLen = 64) {\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = SHA512_IV[0] | 0;\n        this.Al = SHA512_IV[1] | 0;\n        this.Bh = SHA512_IV[2] | 0;\n        this.Bl = SHA512_IV[3] | 0;\n        this.Ch = SHA512_IV[4] | 0;\n        this.Cl = SHA512_IV[5] | 0;\n        this.Dh = SHA512_IV[6] | 0;\n        this.Dl = SHA512_IV[7] | 0;\n        this.Eh = SHA512_IV[8] | 0;\n        this.El = SHA512_IV[9] | 0;\n        this.Fh = SHA512_IV[10] | 0;\n        this.Fl = SHA512_IV[11] | 0;\n        this.Gh = SHA512_IV[12] | 0;\n        this.Gl = SHA512_IV[13] | 0;\n        this.Hh = SHA512_IV[14] | 0;\n        this.Hl = SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        clean(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        clean(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexport class SHA384 extends SHA512 {\n    constructor() {\n        super(48);\n        this.Ah = SHA384_IV[0] | 0;\n        this.Al = SHA384_IV[1] | 0;\n        this.Bh = SHA384_IV[2] | 0;\n        this.Bl = SHA384_IV[3] | 0;\n        this.Ch = SHA384_IV[4] | 0;\n        this.Cl = SHA384_IV[5] | 0;\n        this.Dh = SHA384_IV[6] | 0;\n        this.Dl = SHA384_IV[7] | 0;\n        this.Eh = SHA384_IV[8] | 0;\n        this.El = SHA384_IV[9] | 0;\n        this.Fh = SHA384_IV[10] | 0;\n        this.Fl = SHA384_IV[11] | 0;\n        this.Gh = SHA384_IV[12] | 0;\n        this.Gl = SHA384_IV[13] | 0;\n        this.Hh = SHA384_IV[14] | 0;\n        this.Hl = SHA384_IV[15] | 0;\n    }\n}\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\nexport class SHA512_224 extends SHA512 {\n    constructor() {\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nexport class SHA512_256 extends SHA512 {\n    constructor() {\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexport const sha256 = /* @__PURE__ */ createHasher(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224 = /* @__PURE__ */ createHasher(() => new SHA224());\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512 = /* @__PURE__ */ createHasher(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384 = /* @__PURE__ */ createHasher(() => new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256 = /* @__PURE__ */ createHasher(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224 = /* @__PURE__ */ createHasher(() => new SHA512_224());\n//# sourceMappingURL=sha2.js.map","import * as Digest from './digest.js';\nexport const from = ({name, code, encode}) => new Hasher(name, code, encode);\nexport class Hasher {\n  constructor(name, code, encode) {\n    this.name = name;\n    this.code = code;\n    this.encode = encode;\n  }\n  digest(input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input);\n      return result instanceof Uint8Array ? Digest.create(this.code, result) : result.then(digest => Digest.create(this.code, digest));\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}","import { from } from './hasher.js';\nconst sha = name => async data => new Uint8Array(await crypto.subtle.digest(name, data));\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 18,\n  encode: sha('SHA-256')\n});\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 19,\n  encode: sha('SHA-512')\n});","import { coerce } from '../bytes.js';\nimport * as Digest from './digest.js';\nconst code = 0;\nconst name = 'identity';\nconst encode = coerce;\nconst digest = input => Digest.create(code, encode(input));\nexport const identity = {\n  code,\n  name,\n  encode,\n  digest\n};","const textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\nexport const name = 'json';\nexport const code = 512;\nexport const encode = node => textEncoder.encode(JSON.stringify(node));\nexport const decode = data => JSON.parse(textDecoder.decode(data));","import * as identityBase from './bases/identity.js';\nimport * as base2 from './bases/base2.js';\nimport * as base8 from './bases/base8.js';\nimport * as base10 from './bases/base10.js';\nimport * as base16 from './bases/base16.js';\nimport * as base32 from './bases/base32.js';\nimport * as base36 from './bases/base36.js';\nimport * as base58 from './bases/base58.js';\nimport * as base64 from './bases/base64.js';\nimport * as base256emoji from './bases/base256emoji.js';\nimport * as sha2 from './hashes/sha2.js';\nimport * as identity from './hashes/identity.js';\nimport * as raw from './codecs/raw.js';\nimport * as json from './codecs/json.js';\nimport {\n  CID,\n  hasher,\n  digest,\n  varint,\n  bytes\n} from './index.js';\nconst bases = {\n  ...identityBase,\n  ...base2,\n  ...base8,\n  ...base10,\n  ...base16,\n  ...base32,\n  ...base36,\n  ...base58,\n  ...base64,\n  ...base256emoji\n};\nconst hashes = {\n  ...sha2,\n  ...identity\n};\nconst codecs = {\n  raw,\n  json\n};\nexport {\n  CID,\n  hasher,\n  digest,\n  varint,\n  bytes,\n  hashes,\n  bases,\n  codecs\n};","import { ExactSvmPayload } from \"../../types/verify/x402Specs\";\nimport {\n  getBase64EncodedWireTransaction,\n  getBase64Encoder,\n  getTransactionDecoder,\n  getCompiledTransactionMessageDecoder,\n  type TransactionSigner,\n  isTransactionModifyingSigner,\n  isTransactionPartialSigner,\n  RpcDevnet,\n  SolanaRpcApiDevnet,\n  RpcMainnet,\n  SolanaRpcApiMainnet,\n  Transaction,\n  CompiledTransactionMessage,\n  TransactionWithLifetime,\n  TransactionWithinSizeLimit,\n  type SignatureDictionary,\n} from \"@solana/kit\";\nimport { TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\nimport { TOKEN_2022_PROGRAM_ADDRESS } from \"@solana-program/token-2022\";\n\n/**\n * Given an object with a base64 encoded transaction, decode the\n * base64 encoded transaction into a solana transaction object.\n *\n * @param svmPayload - The SVM payload to decode\n * @returns The decoded transaction\n */\nexport function decodeTransactionFromPayload(svmPayload: ExactSvmPayload): Transaction {\n  try {\n    const base64Encoder = getBase64Encoder();\n    const transactionBytes = base64Encoder.encode(svmPayload.transaction);\n    const transactionDecoder = getTransactionDecoder();\n    return transactionDecoder.decode(transactionBytes);\n  } catch (error) {\n    console.error(\"error\", error);\n    throw new Error(\"invalid_exact_svm_payload_transaction\");\n  }\n}\n\n/**\n * Extract the token sender (owner of the source token account)\n * from the TransferChecked instruction.\n *\n * @param transaction - The transaction to extract the token payer from\n * @returns The token payer address as a base58 string\n */\nexport function getTokenPayerFromTransaction(transaction: Transaction): string {\n  const compiled = getCompiledTransactionMessageDecoder().decode(\n    transaction.messageBytes,\n  ) as CompiledTransactionMessage;\n  const staticAccounts = compiled.staticAccounts ?? [];\n  const instructions = compiled.instructions ?? [];\n\n  for (const ix of instructions) {\n    const programIndex = ix.programAddressIndex;\n    const programAddress = staticAccounts[programIndex].toString();\n    if (\n      programAddress === TOKEN_PROGRAM_ADDRESS.toString() ||\n      programAddress === TOKEN_2022_PROGRAM_ADDRESS.toString()\n    ) {\n      const accountIndices: number[] = ix.accountIndices ?? [];\n      if (accountIndices.length >= 4) {\n        // TransferChecked account order: [source, mint, destination, owner, ...]\n        const ownerIndex = accountIndices[3];\n        const ownerAddress = staticAccounts[ownerIndex].toString();\n        if (ownerAddress) return ownerAddress;\n      }\n    }\n  }\n\n  return \"\";\n}\n\n/**\n * Sign and simulate a transaction.\n *\n * @param signer - The signer that will sign the transaction\n * @param transaction - The transaction to sign and simulate\n * @param rpc - The RPC client to use to simulate the transaction\n * @returns The transaction simulation result\n */\nexport async function signAndSimulateTransaction(\n  signer: TransactionSigner,\n  transaction: Transaction,\n  rpc: RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>,\n) {\n  const signedTransaction = await signTransactionWithSigner(signer, transaction);\n\n  // serialize the signed transaction into a base64 encoded wire transaction\n  const base64EncodedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n\n  // simulate the transaction and verify that it will succeed\n  const simulateTxConfig = {\n    sigVerify: true,\n    replaceRecentBlockhash: false,\n    commitment: \"confirmed\",\n    encoding: \"base64\",\n    accounts: undefined,\n    innerInstructions: undefined,\n    minContextSlot: undefined,\n  } as const;\n\n  const simulateResult = await rpc\n    .simulateTransaction(base64EncodedTransaction, simulateTxConfig)\n    .send();\n\n  return simulateResult;\n}\n\n/**\n * Signs a transaction using the provided {@link TransactionSigner}.\n *\n * Prefers modifying signers (wallets that can rewrite the transaction) and falls\n * back to partial signers that only append signatures.\n *\n * @param signer - Wallet or signer capable of producing transaction signatures\n * @param transaction - Compiled transaction to sign\n * @returns The transaction including any signatures added by the signer\n */\nexport async function signTransactionWithSigner<TTransaction extends Transaction>(\n  signer: TransactionSigner,\n  transaction: TTransaction,\n): Promise<TTransaction> {\n  if (isTransactionModifyingSigner(signer)) {\n    const [modifiedTransaction] = await signer.modifyAndSignTransactions([transaction]);\n    if (!modifiedTransaction) {\n      throw new Error(\"transaction_signer_failed_to_return_transaction\");\n    }\n    return modifiedTransaction as TTransaction;\n  }\n\n  if (isTransactionPartialSigner(signer)) {\n    const [signatures] = await signer.signTransactions([\n      transaction as Transaction & TransactionWithinSizeLimit & TransactionWithLifetime,\n    ]);\n    if (!signatures) {\n      throw new Error(\"transaction_signer_failed_to_return_signatures\");\n    }\n    return mergeTransactionSignatures(transaction, signatures);\n  }\n\n  throw new Error(\"transaction_signer_must_support_offline_signing\");\n}\n\n/**\n * Returns a copy of `transaction` with additional signatures merged in.\n *\n * @param transaction - Transaction whose signature map should be augmented\n * @param signatures - Map of addresses to new signature bytes\n * @returns A frozen transaction containing the merged signature map\n */\nfunction mergeTransactionSignatures<TTransaction extends Transaction>(\n  transaction: TTransaction,\n  signatures: SignatureDictionary,\n): TTransaction {\n  return Object.freeze({\n    ...transaction,\n    signatures: Object.freeze({\n      ...transaction.signatures,\n      ...signatures,\n    }),\n  }) as TTransaction;\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n} from '@solana/kit';\n\n/**\n * Extensions that can be applied to mints or accounts.  Mint extensions must\n * only be applied to mint accounts, and account extensions must only be\n * applied to token holding accounts.\n */\nexport enum ExtensionType {\n  Uninitialized,\n  TransferFeeConfig,\n  TransferFeeAmount,\n  MintCloseAuthority,\n  ConfidentialTransferMint,\n  ConfidentialTransferAccount,\n  DefaultAccountState,\n  ImmutableOwner,\n  MemoTransfer,\n  NonTransferable,\n  InterestBearingConfig,\n  CpiGuard,\n  PermanentDelegate,\n  NonTransferableAccount,\n  TransferHook,\n  TransferHookAccount,\n  ConfidentialTransferFee,\n  ConfidentialTransferFeeAmount,\n  ScaledUiAmountConfig,\n  PausableConfig,\n  PausableAccount,\n  MetadataPointer,\n  TokenMetadata,\n  GroupPointer,\n  TokenGroup,\n  GroupMemberPointer,\n  TokenGroupMember,\n}\n\nexport type ExtensionTypeArgs = ExtensionType;\n\nexport function getExtensionTypeEncoder(): FixedSizeEncoder<ExtensionTypeArgs> {\n  return getEnumEncoder(ExtensionType, { size: getU16Encoder() });\n}\n\nexport function getExtensionTypeDecoder(): FixedSizeDecoder<ExtensionType> {\n  return getEnumDecoder(ExtensionType, { size: getU16Decoder() });\n}\n\nexport function getExtensionTypeCodec(): FixedSizeCodec<\n  ExtensionTypeArgs,\n  ExtensionType\n> {\n  return combineCodec(getExtensionTypeEncoder(), getExtensionTypeDecoder());\n}\n","export function asUint8Array(buf) {\n  if (globalThis.Buffer != null) {\n    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n  }\n  return buf;\n}","import { asUint8Array } from './util/as-uint8array.js';\nexport function alloc(size = 0) {\n  if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {\n    return asUint8Array(globalThis.Buffer.alloc(size));\n  }\n  return new Uint8Array(size);\n}\nexport function allocUnsafe(size = 0) {\n  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {\n    return asUint8Array(globalThis.Buffer.allocUnsafe(size));\n  }\n  return new Uint8Array(size);\n}","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: { decode }\n  };\n}\nconst string = createCodec('utf8', 'u', buf => {\n  const decoder = new TextDecoder('utf8');\n  return 'u' + decoder.decode(buf);\n}, str => {\n  const encoder = new TextEncoder();\n  return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', buf => {\n  let string = 'a';\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i]);\n  }\n  return string;\n}, str => {\n  str = str.substring(1);\n  const buf = allocUnsafe(str.length);\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n});\nconst BASES = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii: ascii,\n  binary: ascii,\n  ...bases\n};\nexport default BASES;","import { Account, Address, Chain, Client, Transport } from \"viem\";\nimport { ChainConfig, config } from \"../../types/shared/evm/config\";\nimport { usdcABI as abi } from \"../../types/shared/evm/erc20PermitABI\";\nimport { ConnectedClient } from \"../../types/shared/evm/wallet\";\n\n/**\n * Gets the USDC contract address for the current chain from the client\n *\n * @param client - The Viem client instance connected to the blockchain\n * @returns The USDC contract address for the current chain\n */\nexport function getUsdcAddress<\n  transport extends Transport,\n  chain extends Chain | undefined = undefined,\n  account extends Account | undefined = undefined,\n>(client: Client<transport, chain, account>): Address {\n  return config[client.chain!.id.toString()].usdcAddress as Address;\n}\n\n/**\n * Gets the USDC contract address for a specific chain ID\n *\n * @deprecated Use `getUsdcChainConfigForChain` instead\n * @param chainId - The chain ID to get the USDC contract address for\n * @returns The USDC contract address for the specified chain\n */\nexport function getUsdcAddressForChain(chainId: number): Address {\n  return config[chainId.toString()].usdcAddress as Address;\n}\n\n/**\n * Gets the USDC address and eip712 domain name for a specific chain ID\n *\n * @param chainId - The chain ID\n * @returns The USDC contract address and eip712 domain name  for the specified chain\n */\nexport function getUsdcChainConfigForChain(chainId: number): ChainConfig | undefined {\n  return config[chainId.toString()];\n}\n\n// Cache for storing the version value\nlet versionCache: string | null = null;\n\n/**\n * Gets the version of the USDC contract, using a cache to avoid repeated calls\n *\n * @param client - The Viem client instance connected to the blockchain\n * @returns A promise that resolves to the USDC contract version string\n */\nexport async function getVersion<\n  transport extends Transport,\n  chain extends Chain,\n  account extends Account | undefined = undefined,\n>(client: ConnectedClient<transport, chain, account>): Promise<string> {\n  // Return cached version if available\n  if (versionCache !== null) {\n    return versionCache;\n  }\n\n  // Fetch and cache version if not available\n  const version = await client.readContract({\n    address: getUsdcAddress(client),\n    abi,\n    functionName: \"version\",\n  });\n  versionCache = version as string;\n  return versionCache;\n}\n\n/**\n * Gets the USDC balance for a specific address\n *\n * @param client - The Viem client instance connected to the blockchain\n * @param address - The address to check the USDC balance for\n * @returns A promise that resolves to the USDC balance as a bigint\n */\nexport async function getUSDCBalance<\n  transport extends Transport,\n  chain extends Chain,\n  account extends Account | undefined = undefined,\n>(client: ConnectedClient<transport, chain, account>, address: Address): Promise<bigint> {\n  const chainId = client.chain!.id;\n  const usdc = getUsdcChainConfigForChain(chainId);\n  if (!usdc) {\n    return 0n;\n  }\n  const balance = await client.readContract({\n    address: usdc.usdcAddress as `0x${string}`,\n    abi,\n    functionName: \"balanceOf\",\n    args: [address],\n  });\n  return balance as bigint;\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getDiscriminatedUnionDecoder,\n  getDiscriminatedUnionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getTupleDecoder,\n  getTupleEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUnitDecoder,\n  getUnitEncoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type GetDiscriminatedUnionVariant,\n  type GetDiscriminatedUnionVariantContent,\n} from '@solana/kit';\n\n/** Fields in the metadata account, used for updating. */\nexport type TokenMetadataField =\n  | { __kind: 'Name' }\n  | { __kind: 'Symbol' }\n  | { __kind: 'Uri' }\n  | { __kind: 'Key'; fields: readonly [string] };\n\nexport type TokenMetadataFieldArgs = TokenMetadataField;\n\nexport function getTokenMetadataFieldEncoder(): Encoder<TokenMetadataFieldArgs> {\n  return getDiscriminatedUnionEncoder([\n    ['Name', getUnitEncoder()],\n    ['Symbol', getUnitEncoder()],\n    ['Uri', getUnitEncoder()],\n    [\n      'Key',\n      getStructEncoder([\n        [\n          'fields',\n          getTupleEncoder([\n            addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),\n          ]),\n        ],\n      ]),\n    ],\n  ]);\n}\n\nexport function getTokenMetadataFieldDecoder(): Decoder<TokenMetadataField> {\n  return getDiscriminatedUnionDecoder([\n    ['Name', getUnitDecoder()],\n    ['Symbol', getUnitDecoder()],\n    ['Uri', getUnitDecoder()],\n    [\n      'Key',\n      getStructDecoder([\n        [\n          'fields',\n          getTupleDecoder([\n            addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()),\n          ]),\n        ],\n      ]),\n    ],\n  ]);\n}\n\nexport function getTokenMetadataFieldCodec(): Codec<\n  TokenMetadataFieldArgs,\n  TokenMetadataField\n> {\n  return combineCodec(\n    getTokenMetadataFieldEncoder(),\n    getTokenMetadataFieldDecoder()\n  );\n}\n\n// Data Enum Helpers.\nexport function tokenMetadataField(\n  kind: 'Name'\n): GetDiscriminatedUnionVariant<TokenMetadataFieldArgs, '__kind', 'Name'>;\nexport function tokenMetadataField(\n  kind: 'Symbol'\n): GetDiscriminatedUnionVariant<TokenMetadataFieldArgs, '__kind', 'Symbol'>;\nexport function tokenMetadataField(\n  kind: 'Uri'\n): GetDiscriminatedUnionVariant<TokenMetadataFieldArgs, '__kind', 'Uri'>;\nexport function tokenMetadataField(\n  kind: 'Key',\n  data: GetDiscriminatedUnionVariantContent<\n    TokenMetadataFieldArgs,\n    '__kind',\n    'Key'\n  >['fields']\n): GetDiscriminatedUnionVariant<TokenMetadataFieldArgs, '__kind', 'Key'>;\nexport function tokenMetadataField<\n  K extends TokenMetadataFieldArgs['__kind'],\n  Data,\n>(kind: K, data?: Data) {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isTokenMetadataField<K extends TokenMetadataField['__kind']>(\n  kind: K,\n  value: TokenMetadataField\n): value is TokenMetadataField & { __kind: K } {\n  return value.__kind === kind;\n}\n","import bases from './util/bases.js';\nimport { asUint8Array } from './util/as-uint8array.js';\nexport function fromString(string, encoding = 'utf8') {\n  const base = bases[encoding];\n  if (!base) {\n    throw new Error(`Unsupported encoding \"${ encoding }\"`);\n  }\n  if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {\n    return asUint8Array(globalThis.Buffer.from(string, 'utf-8'));\n  }\n  return base.decoder.decode(`${ base.prefix }${ string }`);\n}","import { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { ICore, IKeyChain } from \"@walletconnect/types\";\nimport { getInternalError, mapToObj, objToMap } from \"@walletconnect/utils\";\n\nimport {\n  CORE_STORAGE_PREFIX,\n  KEYCHAIN_CONTEXT,\n  KEYCHAIN_STORAGE_VERSION,\n} from \"../constants/index.js\";\n\nexport class KeyChain implements IKeyChain {\n  public keychain = new Map<string, string>();\n  public name = KEYCHAIN_CONTEXT;\n  public version = KEYCHAIN_STORAGE_VERSION;\n\n  private initialized = false;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    this.core = core;\n    this.logger = generateChildLogger(logger, this.name);\n  }\n\n  public init: IKeyChain[\"init\"] = async () => {\n    if (!this.initialized) {\n      const keychain = await this.getKeyChain();\n      if (typeof keychain !== \"undefined\") {\n        this.keychain = keychain;\n      }\n      this.initialized = true;\n    }\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n\n  public has: IKeyChain[\"has\"] = (tag) => {\n    this.isInitialized();\n    return this.keychain.has(tag);\n  };\n\n  public set: IKeyChain[\"set\"] = async (tag, key) => {\n    this.isInitialized();\n    this.keychain.set(tag, key);\n    await this.persist();\n  };\n\n  public get: IKeyChain[\"get\"] = (tag) => {\n    this.isInitialized();\n    const key = this.keychain.get(tag);\n    if (typeof key === \"undefined\") {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${tag}`);\n      throw new Error(message);\n    }\n    return key;\n  };\n\n  public del: IKeyChain[\"del\"] = async (tag) => {\n    this.isInitialized();\n    this.keychain.delete(tag);\n    await this.persist();\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async setKeyChain(keychain: Map<string, string>) {\n    await this.core.storage.setItem<Record<string, string>>(this.storageKey, mapToObj(keychain));\n  }\n\n  private async getKeyChain() {\n    const keychain = await this.core.storage.getItem<Record<string, string>>(this.storageKey);\n    return typeof keychain !== \"undefined\" ? objToMap(keychain) : undefined;\n  }\n\n  private async persist() {\n    await this.setKeyChain(this.keychain);\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { ICore, ICrypto, IKeyChain } from \"@walletconnect/types\";\nimport * as relayAuth from \"@walletconnect/relay-auth\";\nimport { fromString } from \"uint8arrays/from-string\";\nimport {\n  decrypt,\n  deriveSymKey,\n  encrypt,\n  generateKeyPair as generateKeyPairUtil,\n  hashKey,\n  getInternalError,\n  generateRandomBytes32,\n  validateEncoding,\n  validateDecoding,\n  isTypeOneEnvelope,\n  isTypeTwoEnvelope,\n  encodeTypeTwoEnvelope,\n  decodeTypeTwoEnvelope,\n  deserialize,\n  decodeTypeByte,\n  BASE16,\n  BASE64,\n} from \"@walletconnect/utils\";\nimport { toString } from \"uint8arrays\";\n\nimport { CRYPTO_CONTEXT, CRYPTO_CLIENT_SEED, CRYPTO_JWT_TTL } from \"../constants/index.js\";\nimport { KeyChain } from \"./keychain.js\";\n\nexport class Crypto implements ICrypto {\n  public name = CRYPTO_CONTEXT;\n  public keychain: ICrypto[\"keychain\"];\n  public readonly randomSessionIdentifier = generateRandomBytes32();\n\n  private initialized = false;\n  private clientId: string | undefined;\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    keychain?: IKeyChain,\n  ) {\n    this.core = core;\n    this.logger = generateChildLogger(logger, this.name);\n    this.keychain = keychain || new KeyChain(this.core, this.logger);\n  }\n\n  public init: ICrypto[\"init\"] = async () => {\n    if (!this.initialized) {\n      await this.keychain.init();\n      this.initialized = true;\n    }\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  public hasKeys: ICrypto[\"hasKeys\"] = (tag) => {\n    this.isInitialized();\n    return this.keychain.has(tag);\n  };\n\n  public getClientId: ICrypto[\"getClientId\"] = async () => {\n    this.isInitialized();\n    if (this.clientId) {\n      return this.clientId;\n    }\n    const seed = await this.getClientSeed();\n    const keyPair = relayAuth.generateKeyPair(seed);\n    const clientId = relayAuth.encodeIss(keyPair.publicKey);\n    this.clientId = clientId;\n    return clientId;\n  };\n\n  public generateKeyPair: ICrypto[\"generateKeyPair\"] = () => {\n    this.isInitialized();\n    const keyPair = generateKeyPairUtil();\n    return this.setPrivateKey(keyPair.publicKey, keyPair.privateKey);\n  };\n\n  public signJWT: ICrypto[\"signJWT\"] = async (aud) => {\n    this.isInitialized();\n    const seed = await this.getClientSeed();\n    const keyPair = relayAuth.generateKeyPair(seed);\n    const sub = this.randomSessionIdentifier;\n    const ttl = CRYPTO_JWT_TTL;\n    const jwt = await relayAuth.signJWT(sub, aud, ttl, keyPair);\n    return jwt;\n  };\n\n  public generateSharedKey: ICrypto[\"generateSharedKey\"] = (\n    selfPublicKey,\n    peerPublicKey,\n    overrideTopic,\n  ) => {\n    this.isInitialized();\n    const selfPrivateKey = this.getPrivateKey(selfPublicKey);\n    const symKey = deriveSymKey(selfPrivateKey, peerPublicKey);\n    return this.setSymKey(symKey, overrideTopic);\n  };\n\n  public setSymKey: ICrypto[\"setSymKey\"] = async (symKey, overrideTopic) => {\n    this.isInitialized();\n    const topic = overrideTopic || hashKey(symKey);\n    await this.keychain.set(topic, symKey);\n    return topic;\n  };\n\n  public deleteKeyPair: ICrypto[\"deleteKeyPair\"] = async (publicKey: string) => {\n    this.isInitialized();\n    await this.keychain.del(publicKey);\n  };\n\n  public deleteSymKey: ICrypto[\"deleteSymKey\"] = async (topic: string) => {\n    this.isInitialized();\n    await this.keychain.del(topic);\n  };\n\n  public encode: ICrypto[\"encode\"] = async (topic, payload, opts) => {\n    this.isInitialized();\n    const params = validateEncoding(opts);\n    const message = safeJsonStringify(payload);\n\n    if (isTypeTwoEnvelope(params)) {\n      return encodeTypeTwoEnvelope(message, opts?.encoding);\n    }\n\n    if (isTypeOneEnvelope(params)) {\n      const selfPublicKey = params.senderPublicKey;\n      const peerPublicKey = params.receiverPublicKey;\n      topic = await this.generateSharedKey(selfPublicKey, peerPublicKey);\n    }\n    const symKey = this.getSymKey(topic);\n    const { type, senderPublicKey } = params;\n    const result = encrypt({ type, symKey, message, senderPublicKey, encoding: opts?.encoding });\n    return result;\n  };\n\n  public decode: ICrypto[\"decode\"] = async (topic, encoded, opts) => {\n    this.isInitialized();\n    const params = validateDecoding(encoded, opts);\n    if (isTypeTwoEnvelope(params)) {\n      const message = decodeTypeTwoEnvelope(encoded, opts?.encoding);\n      return safeJsonParse(message);\n    }\n    if (isTypeOneEnvelope(params)) {\n      const selfPublicKey = params.receiverPublicKey;\n      const peerPublicKey = params.senderPublicKey;\n      topic = await this.generateSharedKey(selfPublicKey, peerPublicKey);\n    }\n    try {\n      const symKey = this.getSymKey(topic);\n      const message = decrypt({ symKey, encoded, encoding: opts?.encoding });\n      const payload = safeJsonParse(message);\n      return payload;\n    } catch (error) {\n      this.logger.error(\n        `Failed to decode message from topic: '${topic}', clientId: '${await this.getClientId()}'`,\n      );\n      this.logger.error(error);\n    }\n  };\n\n  public getPayloadType: ICrypto[\"getPayloadType\"] = (encoded, encoding = BASE64) => {\n    const deserialized = deserialize({ encoded, encoding });\n    return decodeTypeByte(deserialized.type);\n  };\n\n  public getPayloadSenderPublicKey: ICrypto[\"getPayloadSenderPublicKey\"] = (\n    encoded,\n    encoding = BASE64,\n  ) => {\n    const deserialized = deserialize({ encoded, encoding });\n    return deserialized.senderPublicKey\n      ? toString(deserialized.senderPublicKey, BASE16)\n      : undefined;\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async setPrivateKey(publicKey: string, privateKey: string): Promise<string> {\n    await this.keychain.set(publicKey, privateKey);\n    return publicKey;\n  }\n\n  private getPrivateKey(publicKey: string) {\n    const privateKey = this.keychain.get(publicKey);\n    return privateKey;\n  }\n\n  private async getClientSeed(): Promise<Uint8Array> {\n    let seed = \"\";\n    try {\n      seed = this.keychain.get(CRYPTO_CLIENT_SEED);\n    } catch {\n      seed = generateRandomBytes32();\n      await this.keychain.set(CRYPTO_CLIENT_SEED, seed);\n    }\n    return fromString(seed, \"base16\");\n  }\n\n  private getSymKey(topic: string) {\n    const symKey = this.keychain.get(topic);\n    return symKey;\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { ICore, IMessageTracker, MessageRecord } from \"@walletconnect/types\";\nimport { hashMessage, mapToObj, objToMap, getInternalError } from \"@walletconnect/utils\";\nimport {\n  CORE_STORAGE_PREFIX,\n  MESSAGE_DIRECTION,\n  MESSAGES_CONTEXT,\n  MESSAGES_STORAGE_VERSION,\n} from \"../constants/index.js\";\n\nexport class MessageTracker extends IMessageTracker {\n  public messages = new Map<string, MessageRecord>();\n  /**\n   * stores messages that have not been acknowledged by the implementing client\n   * this is used to prevent losing messages in race conditions such as\n   * when a message is received by the relayer before the implementing client is ready to receive it\n   */\n  public messagesWithoutClientAck = new Map<string, MessageRecord>();\n  public name = MESSAGES_CONTEXT;\n  public version = MESSAGES_STORAGE_VERSION;\n\n  private initialized = false;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  constructor(\n    public logger: Logger,\n    public core: ICore,\n  ) {\n    super(logger, core);\n    this.logger = generateChildLogger(logger, this.name);\n    this.core = core;\n  }\n\n  public init: IMessageTracker[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n      try {\n        const messages = await this.getRelayerMessages();\n        if (typeof messages !== \"undefined\") {\n          this.messages = messages;\n        }\n        const messagesWithoutClientAck = await this.getRelayerMessagesWithoutClientAck();\n        if (typeof messagesWithoutClientAck !== \"undefined\") {\n          this.messagesWithoutClientAck = messagesWithoutClientAck;\n        }\n        this.logger.debug(`Successfully Restored records for ${this.name}`);\n        this.logger.trace({ type: \"method\", method: \"restore\", size: this.messages.size });\n      } catch (e) {\n        this.logger.debug(`Failed to Restore records for ${this.name}`);\n        this.logger.error(e as any);\n      } finally {\n        this.initialized = true;\n      }\n    }\n  };\n\n  get context(): string {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n\n  get storageKeyWithoutClientAck() {\n    return (\n      this.storagePrefix +\n      this.version +\n      this.core.customStoragePrefix +\n      \"//\" +\n      this.name +\n      \"_withoutClientAck\"\n    );\n  }\n\n  public set: IMessageTracker[\"set\"] = async (topic, message, direction) => {\n    this.isInitialized();\n    const hash = hashMessage(message);\n    let messages = this.messages.get(topic);\n    if (typeof messages === \"undefined\") {\n      messages = {};\n    }\n    if (typeof messages[hash] !== \"undefined\") {\n      return hash;\n    }\n    messages[hash] = message;\n    this.messages.set(topic, messages);\n    // Only store messages without client ack for inbound messages\n    if (direction === MESSAGE_DIRECTION.inbound) {\n      const messagesWithoutClientAck = this.messagesWithoutClientAck.get(topic) || {};\n      this.messagesWithoutClientAck.set(topic, {\n        ...messagesWithoutClientAck,\n        [hash]: message,\n      });\n    }\n\n    await this.persist();\n    return hash;\n  };\n\n  public get: IMessageTracker[\"get\"] = (topic) => {\n    this.isInitialized();\n    let messages = this.messages.get(topic);\n    if (typeof messages === \"undefined\") {\n      messages = {};\n    }\n    return messages;\n  };\n\n  public getWithoutAck: IMessageTracker[\"getWithoutAck\"] = (topics) => {\n    this.isInitialized();\n    const messages: Record<string, string[]> = {};\n    for (const topic of topics) {\n      const messagesWithoutClientAck = this.messagesWithoutClientAck.get(topic) || {};\n      messages[topic] = Object.values(messagesWithoutClientAck);\n    }\n    return messages;\n  };\n\n  public has: IMessageTracker[\"has\"] = (topic, message) => {\n    this.isInitialized();\n    const messages = this.get(topic);\n    const hash = hashMessage(message);\n    return typeof messages[hash] !== \"undefined\";\n  };\n\n  public ack: IMessageTracker[\"ack\"] = async (topic, message) => {\n    this.isInitialized();\n    const messages = this.messagesWithoutClientAck.get(topic);\n    if (typeof messages === \"undefined\") {\n      return;\n    }\n\n    const hash = hashMessage(message);\n\n    delete messages[hash];\n    if (Object.keys(messages).length === 0) {\n      this.messagesWithoutClientAck.delete(topic);\n    } else {\n      this.messagesWithoutClientAck.set(topic, messages);\n    }\n    await this.persist();\n  };\n\n  public del: IMessageTracker[\"del\"] = async (topic) => {\n    this.isInitialized();\n    this.messages.delete(topic);\n    this.messagesWithoutClientAck.delete(topic);\n    await this.persist();\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async setRelayerMessages(messages: Map<string, MessageRecord>): Promise<void> {\n    await this.core.storage.setItem<Record<string, MessageRecord>>(\n      this.storageKey,\n      mapToObj(messages),\n    );\n  }\n\n  private async setRelayerMessagesWithoutClientAck(\n    messages: Map<string, MessageRecord>,\n  ): Promise<void> {\n    await this.core.storage.setItem<Record<string, MessageRecord>>(\n      this.storageKeyWithoutClientAck,\n      mapToObj(messages),\n    );\n  }\n\n  private async getRelayerMessages(): Promise<Map<string, MessageRecord> | undefined> {\n    const messages = await this.core.storage.getItem<Record<string, MessageRecord>>(\n      this.storageKey,\n    );\n    return typeof messages !== \"undefined\" ? objToMap(messages) : undefined;\n  }\n\n  private async getRelayerMessagesWithoutClientAck(): Promise<\n    Map<string, MessageRecord> | undefined\n  > {\n    const messages = await this.core.storage.getItem<Record<string, MessageRecord>>(\n      this.storageKeyWithoutClientAck,\n    );\n    return typeof messages !== \"undefined\" ? objToMap(messages) : undefined;\n  }\n\n  private async persist() {\n    await this.setRelayerMessages(this.messages);\n    await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { EventEmitter } from \"events\";\nimport { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\nimport { JsonRpcPayload, RequestArguments } from \"@walletconnect/jsonrpc-types\";\nimport { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { RelayJsonRpc } from \"@walletconnect/relay-api\";\nimport { IPublisher, IRelayer, RelayerTypes } from \"@walletconnect/types\";\nimport {\n  getRelayProtocolApi,\n  getRelayProtocolName,\n  isUndefined,\n  createExpiringPromise,\n} from \"@walletconnect/utils\";\nimport { getBigIntRpcId } from \"@walletconnect/jsonrpc-utils\";\nimport { FIVE_MINUTES, ONE_MINUTE, ONE_SECOND, toMiliseconds } from \"@walletconnect/time\";\n\nimport { PUBLISHER_CONTEXT, PUBLISHER_DEFAULT_TTL, RELAYER_EVENTS } from \"../constants/index.js\";\n\ntype IPublishType = {\n  attestation?: string;\n  attempt: number;\n  request: RequestArguments;\n  opts?: RelayerTypes.PublishOptions;\n};\n\nexport class Publisher extends IPublisher {\n  public events = new EventEmitter();\n  public name = PUBLISHER_CONTEXT;\n  public queue = new Map<string, IPublishType>();\n\n  private publishTimeout = toMiliseconds(ONE_MINUTE);\n  private initialPublishTimeout = toMiliseconds(ONE_SECOND * 15);\n  private needsTransportRestart = false;\n\n  constructor(\n    public relayer: IRelayer,\n    public logger: Logger,\n  ) {\n    super(relayer, logger);\n    this.relayer = relayer;\n    this.logger = generateChildLogger(logger, this.name);\n    this.registerEventListeners();\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  public publish: IPublisher[\"publish\"] = async (topic, message, opts) => {\n    this.logger.debug(`Publishing Payload`);\n    this.logger.trace({ type: \"method\", method: \"publish\", params: { topic, message, opts } });\n\n    const ttl = opts?.ttl || PUBLISHER_DEFAULT_TTL;\n    const prompt = opts?.prompt || false;\n    const tag = opts?.tag || 0;\n    const id = opts?.id || (getBigIntRpcId().toString() as any);\n\n    const api = getRelayProtocolApi(getRelayProtocolName().protocol);\n\n    const request: RequestArguments<RelayJsonRpc.PublishParams> = {\n      id,\n      method: opts?.publishMethod || api.publish,\n      params: {\n        topic,\n        message,\n        ttl,\n        prompt,\n        tag,\n        attestation: opts?.attestation,\n        ...opts?.tvf,\n      },\n    };\n\n    const failedPublishMessage = `Failed to publish payload, please try again. id:${id} tag:${tag}`;\n    try {\n      if (isUndefined(request.params?.prompt)) delete request.params?.prompt;\n      if (isUndefined(request.params?.tag)) delete request.params?.tag;\n\n      /**\n       * attempt to publish the payload for <initialPublishTimeout> seconds,\n       * if the publish fails, add the payload to the queue and it will be retried on every pulse\n       * until it is successfully published or <publishTimeout> seconds have passed\n       */\n      const publishPromise = new Promise<void>(async (resolve) => {\n        const onPublish = ({ id }: { id: string }) => {\n          if (request.id?.toString() === id.toString()) {\n            this.removeRequestFromQueue(id);\n            this.relayer.events.removeListener(RELAYER_EVENTS.publish, onPublish);\n            resolve();\n          }\n        };\n        this.relayer.events.on(RELAYER_EVENTS.publish, onPublish);\n        const initialPublish = createExpiringPromise(\n          new Promise((resolve, reject) => {\n            this.rpcPublish(request, opts)\n              .then(resolve)\n              .catch((e) => {\n                this.logger.warn(e, e?.message);\n                reject(e);\n              });\n          }),\n          this.initialPublishTimeout,\n          `Failed initial publish, retrying.... id:${id} tag:${tag}`,\n        );\n        try {\n          await initialPublish;\n          this.events.removeListener(RELAYER_EVENTS.publish, onPublish);\n        } catch (e) {\n          this.queue.set(id, { request, opts, attempt: 1 });\n          this.logger.warn(e, (e as Error)?.message);\n        }\n      });\n      this.logger.trace({\n        type: \"method\",\n        method: \"publish\",\n        params: { id, topic, message, opts },\n      });\n\n      await createExpiringPromise(publishPromise, this.publishTimeout, failedPublishMessage);\n    } catch (e) {\n      this.logger.debug(`Failed to Publish Payload`);\n      this.logger.error(e as any);\n      if (opts?.internal?.throwOnFailedPublish) {\n        throw e;\n      }\n    } finally {\n      this.queue.delete(id);\n    }\n  };\n\n  public publishCustom: IPublisher[\"publishCustom\"] = async (params) => {\n    this.logger.debug(`Publishing custom payload`);\n    this.logger.trace({ type: \"method\", method: \"publishCustom\", params });\n\n    const { payload, opts = {} } = params;\n    const { attestation, tvf, publishMethod, prompt, tag, ttl = FIVE_MINUTES } = opts;\n\n    const id = opts.id || (getBigIntRpcId().toString() as any);\n    const api = getRelayProtocolApi(getRelayProtocolName().protocol);\n    const method = publishMethod || api.publish;\n    const request: RequestArguments<RelayJsonRpc.PublishParams> = {\n      id,\n      method,\n      params: {\n        ...payload,\n        ttl,\n        prompt,\n        tag,\n        attestation,\n        ...tvf,\n      },\n    };\n    const failedPublishMessage = `Failed to publish custom payload, please try again. id:${id} tag:${tag}`;\n    try {\n      if (isUndefined(request.params?.prompt)) delete request.params?.prompt;\n      if (isUndefined(request.params?.tag)) delete request.params?.tag;\n\n      /**\n       * attempt to publish the payload for <initialPublishTimeout> seconds,\n       * if the publish fails, add the payload to the queue and it will be retried on every pulse\n       * until it is successfully published or <publishTimeout> seconds have passed\n       */\n      const publishPromise = new Promise<void>(async (resolve) => {\n        const onPublish = ({ id }: { id: string }) => {\n          if (request.id?.toString() === id.toString()) {\n            this.removeRequestFromQueue(id);\n            this.relayer.events.removeListener(RELAYER_EVENTS.publish, onPublish);\n            resolve();\n          }\n        };\n        this.relayer.events.on(RELAYER_EVENTS.publish, onPublish);\n        const initialPublish = createExpiringPromise(\n          new Promise((resolve, reject) => {\n            this.rpcPublish(request, opts)\n              .then(resolve)\n              .catch((e) => {\n                this.logger.warn(e, e?.message);\n                reject(e);\n              });\n          }),\n          this.initialPublishTimeout,\n          `Failed initial custom payload publish, retrying.... method:${method} id:${id} tag:${tag}`,\n        );\n        try {\n          await initialPublish;\n          this.events.removeListener(RELAYER_EVENTS.publish, onPublish);\n        } catch (e) {\n          this.queue.set(id, { request, opts, attempt: 1 });\n          this.logger.warn(e, (e as Error)?.message);\n        }\n      });\n      this.logger.trace({\n        type: \"method\",\n        method: \"publish\",\n        params: { id, payload, opts },\n      });\n\n      await createExpiringPromise(publishPromise, this.publishTimeout, failedPublishMessage);\n    } catch (e) {\n      this.logger.debug(`Failed to Publish Payload`);\n      this.logger.error(e as any);\n      if (opts?.internal?.throwOnFailedPublish) {\n        throw e;\n      }\n    } finally {\n      this.queue.delete(id);\n    }\n  };\n\n  public on: IPublisher[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n  };\n\n  public once: IPublisher[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n  };\n\n  public off: IPublisher[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n  };\n\n  public removeListener: IPublisher[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async rpcPublish(request: RequestArguments, opts?: RelayerTypes.PublishOptions) {\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"message\", direction: \"outgoing\", request });\n    const result = await this.relayer.request(request);\n\n    this.relayer.events.emit(RELAYER_EVENTS.publish, { ...request, ...opts });\n    this.logger.debug(`Successfully Published Payload`);\n    return result;\n  }\n\n  private removeRequestFromQueue(id: string) {\n    this.queue.delete(id);\n  }\n\n  private checkQueue() {\n    this.queue.forEach(async (params, id) => {\n      const attempt = params.attempt + 1;\n      this.queue.set(id, { ...params, attempt });\n      this.logger.warn(\n        {},\n        `Publisher: queue->publishing: ${params.request.id}, tag: ${params.request.params?.tag}, attempt: ${attempt}`,\n      );\n      await this.rpcPublish(params.request, params.opts);\n      this.logger.warn({}, `Publisher: queue->published: ${params.request.id}`);\n    });\n  }\n\n  private registerEventListeners() {\n    this.relayer.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => {\n      // restart the transport if needed\n      // queue will be processed on the next pulse\n      if (this.needsTransportRestart) {\n        this.needsTransportRestart = false;\n        this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);\n        return;\n      }\n      this.checkQueue();\n    });\n    this.relayer.on(RELAYER_EVENTS.message_ack, (event: JsonRpcPayload) => {\n      this.removeRequestFromQueue(event.id.toString());\n    });\n  }\n}\n","import { ISubscriberTopicMap } from \"@walletconnect/types\";\n\nexport class SubscriberTopicMap implements ISubscriberTopicMap {\n  public map = new Map<string, string[]>();\n\n  get topics(): string[] {\n    return Array.from(this.map.keys());\n  }\n\n  public set: ISubscriberTopicMap[\"set\"] = (topic, id) => {\n    const ids = this.get(topic);\n    if (this.exists(topic, id)) return;\n    this.map.set(topic, [...ids, id]);\n  };\n\n  public get: ISubscriberTopicMap[\"get\"] = (topic) => {\n    const ids = this.map.get(topic);\n    return ids || [];\n  };\n\n  public exists: ISubscriberTopicMap[\"exists\"] = (topic, id) => {\n    const ids = this.get(topic);\n    return ids.includes(id);\n  };\n\n  public delete: ISubscriberTopicMap[\"delete\"] = (topic, id) => {\n    if (typeof id === \"undefined\") {\n      this.map.delete(topic);\n      return;\n    }\n    if (!this.map.has(topic)) return;\n    const ids = this.get(topic);\n    if (!this.exists(topic, id)) return;\n    const remaining = ids.filter((x) => x !== id);\n    if (!remaining.length) {\n      this.map.delete(topic);\n      return;\n    }\n    this.map.set(topic, remaining);\n  };\n\n  public clear: ISubscriberTopicMap[\"clear\"] = () => {\n    this.map.clear();\n  };\n}\n","import { EventEmitter } from \"events\";\nimport { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\nimport { ErrorResponse, RequestArguments } from \"@walletconnect/jsonrpc-types\";\nimport { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { RelayJsonRpc } from \"@walletconnect/relay-api\";\nimport { ONE_SECOND, ONE_MINUTE, toMiliseconds } from \"@walletconnect/time\";\nimport {\n  IRelayer,\n  ISubscriber,\n  RelayerTypes,\n  SubscriberEvents,\n  SubscriberTypes,\n} from \"@walletconnect/types\";\nimport {\n  getSdkError,\n  getInternalError,\n  getRelayProtocolApi,\n  getRelayProtocolName,\n  createExpiringPromise,\n  hashMessage,\n  sleep,\n} from \"@walletconnect/utils\";\nimport {\n  CORE_STORAGE_PREFIX,\n  SUBSCRIBER_CONTEXT,\n  SUBSCRIBER_EVENTS,\n  SUBSCRIBER_STORAGE_VERSION,\n  RELAYER_EVENTS,\n  TRANSPORT_TYPES,\n} from \"../constants/index.js\";\nimport { SubscriberTopicMap } from \"./topicmap.js\";\n\nexport class Subscriber extends ISubscriber {\n  public subscriptions = new Map<string, SubscriberTypes.Active>();\n\n  public topicMap = new SubscriberTopicMap();\n  public events = new EventEmitter();\n  public name = SUBSCRIBER_CONTEXT;\n  public version = SUBSCRIBER_STORAGE_VERSION;\n  public pending = new Map<string, SubscriberTypes.Params>();\n\n  private cached: SubscriberTypes.Active[] = [];\n  private initialized = false;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n  private subscribeTimeout = toMiliseconds(ONE_MINUTE);\n  private initialSubscribeTimeout = toMiliseconds(ONE_SECOND * 15);\n  private clientId: string;\n  private batchSubscribeTopicsLimit = 500;\n\n  constructor(\n    public relayer: IRelayer,\n    public logger: Logger,\n  ) {\n    super(relayer, logger);\n    this.relayer = relayer;\n    this.logger = generateChildLogger(logger, this.name);\n    this.clientId = \"\"; // assigned when calling this.getClientId()\n  }\n\n  public init: ISubscriber[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n      this.registerEventListeners();\n      await this.restore();\n    }\n    this.initialized = true;\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey() {\n    return (\n      this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + \"//\" + this.name\n    );\n  }\n\n  get length() {\n    return this.subscriptions.size;\n  }\n\n  get ids() {\n    return Array.from(this.subscriptions.keys());\n  }\n\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n\n  get topics() {\n    return this.topicMap.topics;\n  }\n\n  get hasAnyTopics() {\n    return (\n      this.topicMap.topics.length > 0 ||\n      this.pending.size > 0 ||\n      this.cached.length > 0 ||\n      this.subscriptions.size > 0\n    );\n  }\n\n  public subscribe: ISubscriber[\"subscribe\"] = async (topic, opts) => {\n    this.isInitialized();\n    this.logger.debug(`Subscribing Topic`);\n    this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic, opts } });\n    try {\n      const relay = getRelayProtocolName(opts);\n      const params = { topic, relay, transportType: opts?.transportType };\n      if (!opts?.internal?.skipSubscribe) {\n        this.pending.set(topic, params);\n      }\n      const id = await this.rpcSubscribe(topic, relay, opts);\n      if (typeof id === \"string\") {\n        this.onSubscribe(id, params);\n        this.logger.debug(`Successfully Subscribed Topic`);\n        this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic, opts } });\n      }\n      return id;\n    } catch (e) {\n      this.logger.debug(`Failed to Subscribe Topic`);\n      this.logger.error(e as any);\n      throw e;\n    }\n  };\n\n  public unsubscribe: ISubscriber[\"unsubscribe\"] = async (topic, opts) => {\n    this.isInitialized();\n    if (typeof opts?.id !== \"undefined\") {\n      await this.unsubscribeById(topic, opts.id, opts);\n    } else {\n      await this.unsubscribeByTopic(topic, opts);\n    }\n  };\n\n  /**\n   * returns `true` only if the topic is actively subscribed to i.e. not pending or cached\n   */\n  public isSubscribed: ISubscriber[\"isSubscribed\"] = (topic: string) => {\n    return new Promise((resolve) => {\n      resolve(this.topicMap.topics.includes(topic));\n    });\n  };\n\n  /**\n   * returns `true` if the topic is known to the subscriber i.e. it is actively subscribed, pending, cached or in the topic map\n   */\n  public isKnownTopic: ISubscriber[\"isKnownTopic\"] = (topic: string) => {\n    return new Promise((resolve) => {\n      resolve(\n        this.topicMap.topics.includes(topic) ||\n          this.pending.has(topic) ||\n          this.cached.some((s) => s.topic === topic),\n      );\n    });\n  };\n\n  public on: ISubscriber[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n  };\n\n  public once: ISubscriber[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n  };\n\n  public off: ISubscriber[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n  };\n\n  public removeListener: ISubscriber[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n  };\n\n  public start: ISubscriber[\"start\"] = async () => {\n    await this.onConnect();\n  };\n\n  public stop: ISubscriber[\"stop\"] = async () => {\n    await this.onDisconnect();\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private hasSubscription(id: string, topic: string) {\n    let result = false;\n    try {\n      const subscription = this.getSubscription(id);\n      result = subscription.topic === topic;\n    } catch (e) {\n      // ignore error\n    }\n    return result;\n  }\n\n  private reset() {\n    this.cached = [];\n    this.initialized = true;\n  }\n\n  private onDisable() {\n    // only write to this.cached if there are active subscriptions\n    // as this.cached can be overridden if onDisable is called multiple times\n    if (this.values.length > 0) {\n      this.cached = this.values;\n    }\n    this.subscriptions.clear();\n    this.topicMap.clear();\n  }\n\n  private async unsubscribeByTopic(topic: string, opts?: RelayerTypes.UnsubscribeOptions) {\n    const ids = this.topicMap.get(topic);\n    await Promise.all(ids.map(async (id) => await this.unsubscribeById(topic, id, opts)));\n  }\n\n  private async unsubscribeById(topic: string, id: string, opts?: RelayerTypes.UnsubscribeOptions) {\n    this.logger.debug(`Unsubscribing Topic`);\n    this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic, id, opts } });\n    try {\n      const relay = getRelayProtocolName(opts);\n      await this.restartToComplete({ topic, id, relay });\n      await this.rpcUnsubscribe(topic, id, relay);\n      const reason = getSdkError(\"USER_DISCONNECTED\", `${this.name}, ${topic}`);\n      await this.onUnsubscribe(topic, id, reason);\n      this.logger.debug(`Successfully Unsubscribed Topic`);\n      this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic, id, opts } });\n    } catch (e) {\n      this.logger.debug(`Failed to Unsubscribe Topic`);\n      this.logger.error(e as any);\n      throw e;\n    }\n  }\n\n  private async rpcSubscribe(\n    topic: string,\n    relay: RelayerTypes.ProtocolOptions,\n    opts?: RelayerTypes.SubscribeOptions,\n  ) {\n    const subId = await this.getSubscriptionId(topic);\n    if (opts?.internal?.skipSubscribe) {\n      return subId;\n    }\n    if (!opts || opts?.transportType === TRANSPORT_TYPES.relay) {\n      await this.restartToComplete({ topic, id: topic, relay });\n    }\n    const api = getRelayProtocolApi(relay.protocol);\n    const request: RequestArguments<RelayJsonRpc.SubscribeParams> = {\n      method: api.subscribe,\n      params: {\n        topic,\n      },\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n    const shouldThrow = opts?.internal?.throwOnFailedPublish;\n    try {\n      // in link mode, allow the app to update its network state (i.e. active airplane mode) with small delay before attempting to subscribe\n      if (opts?.transportType === TRANSPORT_TYPES.link_mode) {\n        setTimeout(() => {\n          if (this.relayer.connected || this.relayer.connecting) {\n            this.relayer.request(request).catch((e) => this.logger.warn(e));\n          }\n        }, toMiliseconds(ONE_SECOND));\n        return subId;\n      }\n      const subscribePromise = new Promise(async (resolve) => {\n        const onSubscribe = (subscription: SubscriberEvents.Created) => {\n          if (subscription.topic === topic) {\n            this.events.removeListener(SUBSCRIBER_EVENTS.created, onSubscribe);\n            resolve(subscription.id);\n          }\n        };\n        this.events.on(SUBSCRIBER_EVENTS.created, onSubscribe);\n        try {\n          const result = await createExpiringPromise(\n            new Promise((resolve, reject) => {\n              this.relayer\n                .request(request)\n                .catch((e) => {\n                  this.logger.warn(e, e?.message);\n                  reject(e);\n                })\n                .then(resolve);\n            }),\n            this.initialSubscribeTimeout,\n            `Subscribing to ${topic} failed, please try again`,\n          );\n          this.events.removeListener(SUBSCRIBER_EVENTS.created, onSubscribe);\n          resolve(result);\n        } catch (err) {}\n      });\n\n      const subscribe = createExpiringPromise(\n        subscribePromise,\n        this.subscribeTimeout,\n        `Subscribing to ${topic} failed, please try again`,\n      );\n\n      const result = await subscribe;\n      if (!result && shouldThrow) {\n        throw new Error(`Subscribing to ${topic} failed, please try again`);\n      }\n      // return null to indicate that the subscription failed\n      return result ? subId : null;\n    } catch (err) {\n      this.logger.debug(`Outgoing Relay Subscribe Payload stalled`);\n      this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);\n      if (shouldThrow) {\n        throw err;\n      }\n    }\n    return null;\n  }\n\n  private async rpcBatchSubscribe(subscriptions: SubscriberTypes.Params[]) {\n    if (!subscriptions.length) return;\n    const relay = subscriptions[0].relay;\n    const api = getRelayProtocolApi(relay!.protocol);\n    const request: RequestArguments<RelayJsonRpc.BatchSubscribeParams> = {\n      method: api.batchSubscribe,\n      params: {\n        topics: subscriptions.map((s) => s.topic),\n      },\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n    try {\n      const subscribe = await createExpiringPromise(\n        new Promise((resolve) => {\n          this.relayer\n            .request(request)\n            .catch((e) => this.logger.warn(e))\n            .then(resolve);\n        }),\n        this.subscribeTimeout,\n        \"rpcBatchSubscribe failed, please try again\",\n      );\n      await subscribe;\n    } catch (err) {\n      this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);\n    }\n  }\n\n  private async rpcBatchFetchMessages(subscriptions: SubscriberTypes.Params[]) {\n    if (!subscriptions.length) return;\n    const relay = subscriptions[0].relay;\n    const api = getRelayProtocolApi(relay!.protocol);\n    const request: RequestArguments<RelayJsonRpc.BatchFetchMessagesParams> = {\n      method: api.batchFetchMessages,\n      params: {\n        topics: subscriptions.map((s) => s.topic),\n      },\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n    let result;\n    try {\n      const fetchMessagesPromise = await createExpiringPromise(\n        new Promise((resolve, reject) => {\n          this.relayer\n            .request(request)\n            .catch((e) => {\n              this.logger.warn(e);\n              reject(e);\n            })\n            .then(resolve);\n        }),\n        this.subscribeTimeout,\n        \"rpcBatchFetchMessages failed, please try again\",\n      );\n      result = (await fetchMessagesPromise) as {\n        messages: RelayerTypes.MessageEvent[];\n      };\n    } catch (err) {\n      this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);\n    }\n    return result;\n  }\n\n  private rpcUnsubscribe(topic: string, id: string, relay: RelayerTypes.ProtocolOptions) {\n    const api = getRelayProtocolApi(relay.protocol);\n    const request: RequestArguments<RelayJsonRpc.UnsubscribeParams> = {\n      method: api.unsubscribe,\n      params: {\n        topic,\n        id,\n      },\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n    return this.relayer.request(request);\n  }\n\n  private onSubscribe(id: string, params: SubscriberTypes.Params) {\n    this.setSubscription(id, { ...params, id });\n    this.pending.delete(params.topic);\n  }\n\n  private onBatchSubscribe(subscriptions: SubscriberTypes.Active[]) {\n    if (!subscriptions.length) return;\n    subscriptions.forEach((subscription) => {\n      this.setSubscription(subscription.id, { ...subscription });\n      this.pending.delete(subscription.topic);\n    });\n  }\n\n  private async onUnsubscribe(topic: string, id: string, reason: ErrorResponse) {\n    this.events.removeAllListeners(id);\n    if (this.hasSubscription(id, topic)) {\n      this.deleteSubscription(id, reason);\n    }\n    await this.relayer.messages.del(topic);\n  }\n\n  private async setRelayerSubscriptions(subscriptions: SubscriberTypes.Active[]) {\n    await this.relayer.core.storage.setItem<SubscriberTypes.Active[]>(\n      this.storageKey,\n      subscriptions,\n    );\n  }\n\n  private async getRelayerSubscriptions() {\n    const subscriptions = await this.relayer.core.storage.getItem<SubscriberTypes.Active[]>(\n      this.storageKey,\n    );\n    return subscriptions;\n  }\n\n  private setSubscription(id: string, subscription: SubscriberTypes.Active) {\n    this.logger.debug(`Setting subscription`);\n    this.logger.trace({ type: \"method\", method: \"setSubscription\", id, subscription });\n    this.addSubscription(id, subscription);\n  }\n\n  private addSubscription(id: string, subscription: SubscriberTypes.Active) {\n    this.subscriptions.set(id, { ...subscription });\n    this.topicMap.set(subscription.topic, id);\n    this.events.emit(SUBSCRIBER_EVENTS.created, subscription);\n  }\n\n  private getSubscription(id: string) {\n    this.logger.debug(`Getting subscription`);\n    this.logger.trace({ type: \"method\", method: \"getSubscription\", id });\n    const subscription = this.subscriptions.get(id);\n    if (!subscription) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${id}`);\n      throw new Error(message);\n    }\n    return subscription;\n  }\n\n  private deleteSubscription(id: string, reason: ErrorResponse) {\n    this.logger.debug(`Deleting subscription`);\n    this.logger.trace({ type: \"method\", method: \"deleteSubscription\", id, reason });\n    const subscription = this.getSubscription(id);\n    this.subscriptions.delete(id);\n    this.topicMap.delete(subscription.topic, id);\n    this.events.emit(SUBSCRIBER_EVENTS.deleted, {\n      ...subscription,\n      reason,\n    } as SubscriberEvents.Deleted);\n  }\n\n  private restart = async () => {\n    await this.restore();\n    await this.onRestart();\n  };\n\n  private async persist() {\n    await this.setRelayerSubscriptions(this.values);\n    this.events.emit(SUBSCRIBER_EVENTS.sync);\n  }\n\n  private async onRestart() {\n    if (this.cached.length) {\n      const subs = [...this.cached];\n      const numOfBatches = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);\n      for (let i = 0; i < numOfBatches; i++) {\n        const batch = subs.splice(0, this.batchSubscribeTopicsLimit);\n        await this.batchSubscribe(batch);\n      }\n    }\n    this.events.emit(SUBSCRIBER_EVENTS.resubscribed);\n  }\n\n  private async restore() {\n    try {\n      const persisted = await this.getRelayerSubscriptions();\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n      if (\n        this.subscriptions.size &&\n        // throw only if the persisted topics differ\n        !persisted.every((s) => s.topic === this.subscriptions.get(s.id)?.topic)\n      ) {\n        const { message } = getInternalError(\"RESTORE_WILL_OVERRIDE\", this.name);\n        this.logger.error(message);\n        this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`);\n        throw new Error(message);\n      }\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored subscriptions for ${this.name}`);\n      this.logger.trace({ type: \"method\", method: \"restore\", subscriptions: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`);\n      this.logger.error(e as any);\n    }\n  }\n\n  private async batchSubscribe(subscriptions: SubscriberTypes.Params[]) {\n    if (!subscriptions.length) return;\n\n    await this.rpcBatchSubscribe(subscriptions);\n    this.onBatchSubscribe(\n      await Promise.all(\n        subscriptions.map(async (s) => {\n          return { ...s, id: await this.getSubscriptionId(s.topic) };\n        }),\n      ),\n    );\n  }\n\n  // @ts-ignore\n  private async batchFetchMessages(subscriptions: SubscriberTypes.Params[]) {\n    if (!subscriptions.length) return;\n    this.logger.trace(`Fetching batch messages for ${subscriptions.length} subscriptions`);\n    const response = await this.rpcBatchFetchMessages(subscriptions);\n    if (response && response.messages) {\n      await sleep(toMiliseconds(ONE_SECOND));\n      await this.relayer.handleBatchMessageEvents(response.messages);\n    }\n  }\n\n  private async onConnect() {\n    await this.restart();\n    this.reset();\n  }\n\n  private onDisconnect() {\n    this.onDisable();\n  }\n\n  private checkPending = async () => {\n    if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) {\n      return;\n    }\n    const pendingSubscriptions: SubscriberTypes.Params[] = [];\n    this.pending.forEach((params) => {\n      pendingSubscriptions.push(params);\n    });\n\n    await this.batchSubscribe(pendingSubscriptions);\n  };\n\n  private registerEventListeners = () => {\n    this.relayer.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, async () => {\n      await this.checkPending();\n    });\n    this.events.on(SUBSCRIBER_EVENTS.created, async (createdEvent: SubscriberEvents.Created) => {\n      const eventName = SUBSCRIBER_EVENTS.created;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: createdEvent });\n      await this.persist();\n    });\n    this.events.on(SUBSCRIBER_EVENTS.deleted, async (deletedEvent: SubscriberEvents.Deleted) => {\n      const eventName = SUBSCRIBER_EVENTS.deleted;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: deletedEvent });\n      await this.persist();\n    });\n  };\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n\n  private async restartToComplete(subscription: SubscriberTypes.Active) {\n    if (!this.relayer.connected && !this.relayer.connecting) {\n      this.cached.push(subscription);\n      await this.relayer.transportOpen();\n    }\n  }\n\n  private async getClientId() {\n    if (!this.clientId) {\n      this.clientId = await this.relayer.core.crypto.getClientId();\n    }\n    return this.clientId;\n  }\n\n  private async getSubscriptionId(topic: string) {\n    return hashMessage(topic + (await this.getClientId()));\n  }\n}\n","import { EventEmitter } from \"events\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport {\n  formatJsonRpcResult,\n  getBigIntRpcId,\n  IJsonRpcProvider,\n  isJsonRpcRequest,\n  isJsonRpcResponse,\n  JsonRpcPayload,\n  JsonRpcRequest,\n  RequestArguments,\n} from \"@walletconnect/jsonrpc-utils\";\nimport WsConnection from \"@walletconnect/jsonrpc-ws-connection\";\nimport { RelayJsonRpc } from \"@walletconnect/relay-api\";\nimport {\n  FIVE_MINUTES,\n  ONE_SECOND,\n  FIVE_SECONDS,\n  THIRTY_SECONDS,\n  toMiliseconds,\n} from \"@walletconnect/time\";\nimport {\n  ICore,\n  IMessageTracker,\n  IPublisher,\n  IRelayer,\n  ISubscriber,\n  RelayerOptions,\n  RelayerTypes,\n  SubscriberTypes,\n} from \"@walletconnect/types\";\nimport {\n  createExpiringPromise,\n  formatRelayRpcUrl,\n  isOnline,\n  subscribeToNetworkChange,\n  getAppId,\n  isAndroid,\n  isIos,\n  getInternalError,\n  isNode,\n  calcExpiry,\n  isAppVisible,\n  createLogger,\n} from \"@walletconnect/utils\";\n\nimport { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\nimport { getLoggerContext, Logger } from \"@walletconnect/logger\";\n\nimport {\n  RELAYER_SDK_VERSION,\n  RELAYER_CONTEXT,\n  RELAYER_DEFAULT_LOGGER,\n  RELAYER_EVENTS,\n  RELAYER_PROVIDER_EVENTS,\n  RELAYER_SUBSCRIBER_SUFFIX,\n  RELAYER_DEFAULT_RELAY_URL,\n  SUBSCRIBER_EVENTS,\n  RELAYER_RECONNECT_TIMEOUT,\n  TRANSPORT_TYPES,\n  MESSAGE_DIRECTION,\n} from \"../constants/index.js\";\nimport { MessageTracker } from \"./messages.js\";\nimport { Publisher } from \"./publisher.js\";\nimport { Subscriber } from \"./subscriber.js\";\n\nexport class Relayer extends IRelayer {\n  public protocol = \"wc\";\n  public version = 2;\n\n  public core: ICore;\n  public logger: Logger;\n  public events = new EventEmitter();\n  public provider: IJsonRpcProvider;\n  public messages: IMessageTracker;\n  public subscriber: ISubscriber;\n  public publisher: IPublisher;\n  public name = RELAYER_CONTEXT;\n  public transportExplicitlyClosed = false;\n\n  private initialized = false;\n  private connectionAttemptInProgress = false;\n\n  private relayUrl: string;\n  private projectId: string | undefined;\n  private packageName: string | undefined;\n  private bundleId: string | undefined;\n  private hasExperiencedNetworkDisruption = false;\n  private pingTimeout: NodeJS.Timeout | undefined;\n  /**\n   * the relay pings the client 30 seconds after the last message was received\n   * meaning if we don't receive a message in 30 seconds, the connection can be considered dead\n   */\n  private heartBeatTimeout = toMiliseconds(THIRTY_SECONDS + FIVE_SECONDS);\n  private reconnectTimeout: NodeJS.Timeout | undefined;\n  private connectPromise: Promise<void> | undefined;\n  private reconnectInProgress = false;\n  private requestsInFlight: string[] = [];\n  private connectTimeout = toMiliseconds(ONE_SECOND * 15);\n  constructor(opts: RelayerOptions) {\n    super(opts);\n    this.core = opts.core;\n    this.logger = createLogger({\n      logger: opts.logger ?? RELAYER_DEFAULT_LOGGER,\n      name: this.name,\n    });\n    this.messages = new MessageTracker(this.logger, opts.core);\n    this.subscriber = new Subscriber(this, this.logger);\n    this.publisher = new Publisher(this, this.logger);\n\n    this.projectId = opts?.projectId;\n    this.relayUrl = opts?.relayUrl || RELAYER_DEFAULT_RELAY_URL;\n\n    if (isAndroid()) {\n      this.packageName = getAppId();\n    } else if (isIos()) {\n      this.bundleId = getAppId();\n    }\n\n    // re-assigned during init()\n    this.provider = {} as IJsonRpcProvider;\n  }\n\n  public async init() {\n    this.logger.trace(`Initialized`);\n    this.registerEventListeners();\n    await Promise.all([this.messages.init(), this.subscriber.init()]);\n    this.initialized = true;\n    // don't block init with transportOpen\n    this.transportOpen().catch((e) => this.logger.warn(e, (e as Error)?.message));\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get connected() {\n    // @ts-expect-error\n    return this.provider?.connection?.socket?.readyState === 1 || false;\n  }\n\n  get connecting() {\n    return (\n      // @ts-expect-error\n      this.provider?.connection?.socket?.readyState === 0 ||\n      this.connectPromise !== undefined ||\n      false\n    );\n  }\n\n  public async publish(topic: string, message: string, opts?: RelayerTypes.PublishOptions) {\n    this.isInitialized();\n    await this.publisher.publish(topic, message, opts);\n    await this.recordMessageEvent(\n      {\n        topic,\n        message,\n        // We don't have `publishedAt` from the relay server on outgoing, so use current time to satisfy type.\n        publishedAt: Date.now(),\n        transportType: TRANSPORT_TYPES.relay,\n      },\n      MESSAGE_DIRECTION.outbound,\n    );\n  }\n\n  public async publishCustom(params: { payload: any; opts?: RelayerTypes.PublishOptions }) {\n    this.isInitialized();\n    await this.publisher.publishCustom(params);\n  }\n\n  public async subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions) {\n    this.isInitialized();\n    if (!opts?.transportType || opts?.transportType === \"relay\") {\n      await this.toEstablishConnection();\n    }\n    // throw unless explicitly set to false\n    const shouldThrowOnFailure =\n      typeof opts?.internal?.throwOnFailedPublish === \"undefined\"\n        ? true\n        : opts?.internal?.throwOnFailedPublish;\n\n    let id = this.subscriber.topicMap.get(topic)?.[0] || \"\";\n    let resolvePromise: () => void;\n    const onSubCreated = (subscription: SubscriberTypes.Active) => {\n      if (subscription.topic === topic) {\n        this.subscriber.off(SUBSCRIBER_EVENTS.created, onSubCreated);\n        resolvePromise();\n      }\n    };\n\n    await Promise.all([\n      new Promise<void>((resolve) => {\n        resolvePromise = resolve;\n        this.subscriber.on(SUBSCRIBER_EVENTS.created, onSubCreated);\n      }),\n      new Promise<void>(async (resolve, reject) => {\n        const result = await this.subscriber\n          .subscribe(topic, {\n            internal: {\n              throwOnFailedPublish: shouldThrowOnFailure,\n            },\n            ...opts,\n          })\n          .catch((error) => {\n            if (shouldThrowOnFailure) {\n              reject(error);\n            }\n          });\n        id = result || id;\n        resolve();\n      }),\n    ]);\n    return id;\n  }\n\n  public request = async (request: RequestArguments<RelayJsonRpc.SubscribeParams>) => {\n    this.logger.debug(`Publishing Request Payload`);\n    const id = request.id || (getBigIntRpcId().toString() as any);\n    await this.toEstablishConnection();\n    try {\n      this.logger.trace(\n        {\n          id,\n          method: request.method,\n          topic: request.params?.topic,\n        },\n        \"relayer.request - publishing...\",\n      );\n      const tag = `${id}:${(request.params as any)?.tag || \"\"}`;\n      this.requestsInFlight.push(tag);\n      const result = await this.provider.request(request);\n      this.requestsInFlight = this.requestsInFlight.filter((i) => i !== tag);\n      return result;\n    } catch (e) {\n      this.logger.debug(`Failed to Publish Request: ${id}`);\n      throw e;\n    }\n  };\n\n  public async unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions) {\n    this.isInitialized();\n    await this.subscriber.unsubscribe(topic, opts);\n  }\n\n  public on(event: string, listener: any) {\n    this.events.on(event, listener);\n  }\n\n  public once(event: string, listener: any) {\n    this.events.once(event, listener);\n  }\n\n  public off(event: string, listener: any) {\n    this.events.off(event, listener);\n  }\n\n  public removeListener(event: string, listener: any) {\n    this.events.removeListener(event, listener);\n  }\n\n  public async transportDisconnect() {\n    if (this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected)) {\n      await createExpiringPromise(this.provider.disconnect(), 2000, \"provider.disconnect()\").catch(\n        () => this.onProviderDisconnect(),\n      );\n    } else {\n      this.onProviderDisconnect();\n    }\n  }\n\n  public async transportClose() {\n    this.transportExplicitlyClosed = true;\n    await this.transportDisconnect();\n  }\n\n  async transportOpen(relayUrl?: string) {\n    if (!this.subscriber.hasAnyTopics) {\n      this.logger.info(\n        \"Starting WS connection skipped because the client has no topics to work with.\",\n      );\n      return;\n    }\n\n    if (this.connectPromise) {\n      this.logger.debug({}, `Waiting for existing connection attempt to resolve...`);\n      await this.connectPromise;\n      this.logger.debug({}, `Existing connection attempt resolved`);\n    } else {\n      this.connectPromise = new Promise(async (resolve, reject) => {\n        await this.connect(relayUrl)\n          .then(resolve)\n          .catch(reject)\n          .finally(() => {\n            this.connectPromise = undefined;\n          });\n      });\n      await this.connectPromise;\n    }\n    if (!this.connected) {\n      throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);\n    }\n  }\n\n  public async restartTransport(relayUrl?: string) {\n    this.logger.debug({}, \"Restarting transport...\");\n    if (this.connectionAttemptInProgress) return;\n    this.relayUrl = relayUrl || this.relayUrl;\n    await this.confirmOnlineStateOrThrow();\n    await this.transportClose();\n    await this.transportOpen();\n  }\n\n  public async confirmOnlineStateOrThrow() {\n    if (await isOnline()) return;\n    throw new Error(\"No internet connection detected. Please restart your network and try again.\");\n  }\n\n  public async handleBatchMessageEvents(messages: RelayerTypes.MessageEvent[]) {\n    if (messages?.length === 0) {\n      this.logger.trace(\"Batch message events is empty. Ignoring...\");\n      return;\n    }\n    const sortedMessages = messages.sort((a, b) => a.publishedAt - b.publishedAt);\n    this.logger.debug(`Batch of ${sortedMessages.length} message events sorted`);\n    for (const message of sortedMessages) {\n      try {\n        await this.onMessageEvent(message);\n      } catch (e) {\n        this.logger.warn(e, \"Error while processing batch message event: \" + (e as Error)?.message);\n      }\n    }\n    this.logger.trace(`Batch of ${sortedMessages.length} message events processed`);\n  }\n\n  public async onLinkMessageEvent(\n    messageEvent: RelayerTypes.MessageEvent,\n    opts: { sessionExists: boolean },\n  ) {\n    const { topic } = messageEvent;\n\n    if (!opts.sessionExists) {\n      const expiry = calcExpiry(FIVE_MINUTES);\n      const pairing = { topic, expiry, relay: { protocol: \"irn\" }, active: false };\n      await this.core.pairing.pairings.set(topic, pairing);\n    }\n\n    this.events.emit(RELAYER_EVENTS.message, messageEvent);\n    await this.recordMessageEvent(messageEvent, MESSAGE_DIRECTION.inbound);\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async connect(relayUrl?: string) {\n    await this.confirmOnlineStateOrThrow();\n    if (relayUrl && relayUrl !== this.relayUrl) {\n      this.relayUrl = relayUrl;\n      await this.transportDisconnect();\n    }\n\n    this.connectionAttemptInProgress = true;\n    this.transportExplicitlyClosed = false;\n    let attempt = 1;\n    while (attempt < 6) {\n      try {\n        if (this.transportExplicitlyClosed) {\n          break;\n        }\n        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${attempt}...`);\n        // Always create new socket instance when trying to connect because if the socket was dropped due to `socket hang up` exception\n        // It wont be able to reconnect\n        await this.createProvider();\n\n        await new Promise<void>(async (resolve, reject) => {\n          const onDisconnect = () => {\n            reject(new Error(`Connection interrupted while trying to connect`));\n          };\n          this.provider.once(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);\n\n          await createExpiringPromise(\n            new Promise((resolve, reject) => {\n              this.provider.connect().then(resolve).catch(reject);\n            }),\n            this.connectTimeout,\n            `Socket stalled when trying to connect to ${this.relayUrl}`,\n          )\n            .catch((e) => {\n              reject(e);\n            })\n            .finally(() => {\n              this.provider.off(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);\n              clearTimeout(this.reconnectTimeout);\n            });\n          await new Promise(async (_resolve, _reject) => {\n            const onDisconnect = () => {\n              reject(new Error(`Connection interrupted while trying to subscribe`));\n            };\n            this.provider.once(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);\n            await this.subscriber\n              .start()\n              .then(_resolve)\n              .catch(_reject)\n              .finally(() => {\n                this.provider.off(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);\n              });\n          });\n          this.hasExperiencedNetworkDisruption = false;\n          resolve();\n        });\n      } catch (e) {\n        await this.subscriber.stop();\n        const error = e as Error;\n        this.logger.warn({}, error.message);\n        this.hasExperiencedNetworkDisruption = true;\n      } finally {\n        this.connectionAttemptInProgress = false;\n      }\n\n      if (this.connected) {\n        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${attempt}`);\n        break;\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, toMiliseconds(attempt * 1)));\n      attempt++;\n    }\n  }\n\n  /*\n   * In Node, we must detect when the connection is stalled and terminate it.\n   * The logic is, if we don't receive ping from the relay within a certain time, we terminate the connection.\n   * The timer is refreshed on every message received from the relay.\n   *\n   * In the browser, ping/pong events are not exposed, so the above behaviour is handled by `subscribeToNetworkChange` and `isOnline` functions.\n   */\n  private startPingTimeout() {\n    if (!isNode()) return;\n    try {\n      //@ts-expect-error - Types are divergent between the node and browser WS API\n      if (this.provider?.connection?.socket) {\n        //@ts-expect-error\n        this.provider?.connection?.socket?.on(\"ping\", () => {\n          this.resetPingTimeout();\n        });\n      }\n      this.resetPingTimeout();\n    } catch (e) {\n      this.logger.warn(e, (e as Error)?.message);\n    }\n  }\n\n  private resetPingTimeout = () => {\n    if (!isNode()) return;\n    clearTimeout(this.pingTimeout);\n    this.pingTimeout = setTimeout(() => {\n      try {\n        this.logger.debug({}, \"pingTimeout: Connection stalled, terminating...\");\n        //@ts-expect-error\n        this.provider?.connection?.socket?.terminate?.();\n      } catch (e) {\n        this.logger.warn(e, (e as Error)?.message);\n      }\n    }, this.heartBeatTimeout);\n  };\n\n  private async createProvider() {\n    if (this.provider.connection) {\n      this.unregisterProviderListeners();\n    }\n    const auth = await this.core.crypto.signJWT(this.relayUrl);\n\n    this.provider = new JsonRpcProvider(\n      new WsConnection(\n        formatRelayRpcUrl({\n          sdkVersion: RELAYER_SDK_VERSION,\n          protocol: this.protocol,\n          version: this.version,\n          relayUrl: this.relayUrl,\n          projectId: this.projectId,\n          auth,\n          useOnCloseEvent: true,\n          bundleId: this.bundleId,\n          packageName: this.packageName,\n        }),\n      ),\n    );\n    this.registerProviderListeners();\n  }\n\n  private async recordMessageEvent(\n    messageEvent: RelayerTypes.MessageEvent,\n    direction?: RelayerTypes.MessageDirection,\n  ) {\n    const { topic, message } = messageEvent;\n    await this.messages.set(topic, message, direction);\n  }\n\n  private async shouldIgnoreMessageEvent(\n    messageEvent: RelayerTypes.MessageEvent,\n  ): Promise<boolean> {\n    const { topic, message } = messageEvent;\n\n    // Ignore if incoming `message` is clearly invalid.\n    if (!message || message.length === 0) {\n      this.logger.warn(`Ignoring invalid/empty message: ${message}`);\n      return true;\n    }\n\n    // Ignore if `topic` is not known to the subscriber.\n    if (!(await this.subscriber.isKnownTopic(topic))) {\n      this.logger.warn(`Ignoring message for unknown topic ${topic}`);\n      return true;\n    }\n\n    // Ignore if `message` is a duplicate.\n    const exists = this.messages.has(topic, message);\n    if (exists) {\n      this.logger.warn(`Ignoring duplicate message: ${message}`);\n    }\n    return exists;\n  }\n\n  private async onProviderPayload(payload: JsonRpcPayload) {\n    this.logger.debug(`Incoming Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"incoming\", payload });\n    if (isJsonRpcRequest(payload)) {\n      if (!payload.method.endsWith(RELAYER_SUBSCRIBER_SUFFIX)) return;\n      const event = (payload as JsonRpcRequest<RelayJsonRpc.SubscriptionParams>).params;\n      const { topic, message, publishedAt, attestation } = event.data;\n      const messageEvent: RelayerTypes.MessageEvent = {\n        topic,\n        message,\n        publishedAt,\n        transportType: TRANSPORT_TYPES.relay,\n        attestation,\n      };\n      this.logger.debug(`Emitting Relayer Payload`);\n      this.logger.trace({ type: \"event\", event: event.id, ...messageEvent });\n      this.events.emit(event.id, messageEvent);\n      await this.acknowledgePayload(payload);\n      await this.onMessageEvent(messageEvent);\n    } else if (isJsonRpcResponse(payload)) {\n      this.events.emit(RELAYER_EVENTS.message_ack, payload);\n    }\n  }\n\n  private async onMessageEvent(messageEvent: RelayerTypes.MessageEvent) {\n    if (await this.shouldIgnoreMessageEvent(messageEvent)) {\n      return;\n    }\n    await this.recordMessageEvent(messageEvent, MESSAGE_DIRECTION.inbound);\n    this.events.emit(RELAYER_EVENTS.message, messageEvent);\n  }\n\n  private async acknowledgePayload(payload: JsonRpcPayload) {\n    const response = formatJsonRpcResult(payload.id, true);\n    await this.provider.connection.send(response);\n  }\n\n  // ---------- Events Handlers ----------------------------------------------- //\n  private onPayloadHandler = (payload: JsonRpcPayload) => {\n    this.onProviderPayload(payload);\n    this.resetPingTimeout();\n  };\n\n  private onConnectHandler = () => {\n    this.logger.warn({}, \"Relayer connected \");\n    this.startPingTimeout();\n    this.events.emit(RELAYER_EVENTS.connect);\n  };\n\n  private onDisconnectHandler = () => {\n    this.logger.warn({}, `Relayer disconnected `);\n    this.requestsInFlight = [];\n    this.onProviderDisconnect();\n  };\n\n  private onProviderErrorHandler = (error: Error) => {\n    this.logger.fatal(`Fatal socket error: ${error.message}`);\n    this.events.emit(RELAYER_EVENTS.error, error);\n    // close the transport when a fatal error is received as there's no way to recover from it\n    // usual cases are missing/invalid projectId, expired jwt token, invalid origin etc\n    this.logger.fatal(\"Fatal socket error received, closing transport\");\n    this.transportClose();\n  };\n\n  private registerProviderListeners = () => {\n    this.provider.on(RELAYER_PROVIDER_EVENTS.payload, this.onPayloadHandler);\n    this.provider.on(RELAYER_PROVIDER_EVENTS.connect, this.onConnectHandler);\n    this.provider.on(RELAYER_PROVIDER_EVENTS.disconnect, this.onDisconnectHandler);\n    this.provider.on(RELAYER_PROVIDER_EVENTS.error, this.onProviderErrorHandler);\n  };\n\n  private unregisterProviderListeners() {\n    this.provider.off(RELAYER_PROVIDER_EVENTS.payload, this.onPayloadHandler);\n    this.provider.off(RELAYER_PROVIDER_EVENTS.connect, this.onConnectHandler);\n    this.provider.off(RELAYER_PROVIDER_EVENTS.disconnect, this.onDisconnectHandler);\n    this.provider.off(RELAYER_PROVIDER_EVENTS.error, this.onProviderErrorHandler);\n    clearTimeout(this.pingTimeout);\n  }\n\n  private async registerEventListeners() {\n    let lastConnectedState = await isOnline();\n    subscribeToNetworkChange(async (connected: boolean) => {\n      // sometimes the network change event is triggered multiple times so avoid reacting to the samFe value\n      if (lastConnectedState === connected) return;\n\n      lastConnectedState = connected;\n      if (!connected) {\n        // when the device network is restarted, the socket might stay in false `connected` state\n        this.hasExperiencedNetworkDisruption = true;\n        await this.transportDisconnect();\n        this.transportExplicitlyClosed = false;\n      } else {\n        await this.transportOpen().catch((error) =>\n          this.logger.error(error, (error as Error)?.message),\n        );\n      }\n    });\n\n    this.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, async () => {\n      if (this.transportExplicitlyClosed) return;\n      if (!this.connected && isAppVisible()) {\n        try {\n          await this.confirmOnlineStateOrThrow();\n          await this.transportOpen();\n        } catch (error) {\n          this.logger.warn(error, (error as Error)?.message);\n        }\n      }\n    });\n  }\n\n  private async onProviderDisconnect() {\n    clearTimeout(this.pingTimeout);\n    this.events.emit(RELAYER_EVENTS.disconnect);\n    this.connectionAttemptInProgress = false;\n    if (this.reconnectInProgress) return;\n\n    this.reconnectInProgress = true;\n    await this.subscriber.stop();\n\n    if (!this.subscriber.hasAnyTopics) return;\n    if (this.transportExplicitlyClosed) return;\n\n    this.reconnectTimeout = setTimeout(async () => {\n      await this.transportOpen().catch((error) =>\n        this.logger.error(error, (error as Error)?.message),\n      );\n      this.reconnectTimeout = undefined;\n      this.reconnectInProgress = false;\n    }, toMiliseconds(RELAYER_RECONNECT_TIMEOUT));\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n\n  private async toEstablishConnection() {\n    await this.confirmOnlineStateOrThrow();\n    if (this.connected) return;\n    if (this.connectPromise) {\n      await this.connectPromise;\n      return;\n    }\n    await this.connect();\n  }\n}\n","function eq(value, other) {\n    return value === other || (Number.isNaN(value) && Number.isNaN(other));\n}\n\nexport { eq };\n","function getSymbols(object) {\n    return Object.getOwnPropertySymbols(object).filter(symbol => Object.prototype.propertyIsEnumerable.call(object, symbol));\n}\n\nexport { getSymbols };\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n} from '@solana/kit';\n\nexport type TransferFee = {\n  /** First epoch where the transfer fee takes effect. */\n  epoch: bigint;\n  /** Maximum fee assessed on transfers, expressed as an amount of tokens. */\n  maximumFee: bigint;\n  /**\n   * Amount of transfer collected as fees, expressed as basis points of the\n   * transfer amount, ie. increments of 0.01%.\n   */\n  transferFeeBasisPoints: number;\n};\n\nexport type TransferFeeArgs = {\n  /** First epoch where the transfer fee takes effect. */\n  epoch: number | bigint;\n  /** Maximum fee assessed on transfers, expressed as an amount of tokens. */\n  maximumFee: number | bigint;\n  /**\n   * Amount of transfer collected as fees, expressed as basis points of the\n   * transfer amount, ie. increments of 0.01%.\n   */\n  transferFeeBasisPoints: number;\n};\n\nexport function getTransferFeeEncoder(): FixedSizeEncoder<TransferFeeArgs> {\n  return getStructEncoder([\n    ['epoch', getU64Encoder()],\n    ['maximumFee', getU64Encoder()],\n    ['transferFeeBasisPoints', getU16Encoder()],\n  ]);\n}\n\nexport function getTransferFeeDecoder(): FixedSizeDecoder<TransferFee> {\n  return getStructDecoder([\n    ['epoch', getU64Decoder()],\n    ['maximumFee', getU64Decoder()],\n    ['transferFeeBasisPoints', getU16Decoder()],\n  ]);\n}\n\nexport function getTransferFeeCodec(): FixedSizeCodec<\n  TransferFeeArgs,\n  TransferFee\n> {\n  return combineCodec(getTransferFeeEncoder(), getTransferFeeDecoder());\n}\n","function getTag(value) {\n    if (value == null) {\n        return value === undefined ? '[object Undefined]' : '[object Null]';\n    }\n    return Object.prototype.toString.call(value);\n}\n\nexport { getTag };\n","const regexpTag = '[object RegExp]';\nconst stringTag = '[object String]';\nconst numberTag = '[object Number]';\nconst booleanTag = '[object Boolean]';\nconst argumentsTag = '[object Arguments]';\nconst symbolTag = '[object Symbol]';\nconst dateTag = '[object Date]';\nconst mapTag = '[object Map]';\nconst setTag = '[object Set]';\nconst arrayTag = '[object Array]';\nconst functionTag = '[object Function]';\nconst arrayBufferTag = '[object ArrayBuffer]';\nconst objectTag = '[object Object]';\nconst errorTag = '[object Error]';\nconst dataViewTag = '[object DataView]';\nconst uint8ArrayTag = '[object Uint8Array]';\nconst uint8ClampedArrayTag = '[object Uint8ClampedArray]';\nconst uint16ArrayTag = '[object Uint16Array]';\nconst uint32ArrayTag = '[object Uint32Array]';\nconst bigUint64ArrayTag = '[object BigUint64Array]';\nconst int8ArrayTag = '[object Int8Array]';\nconst int16ArrayTag = '[object Int16Array]';\nconst int32ArrayTag = '[object Int32Array]';\nconst bigInt64ArrayTag = '[object BigInt64Array]';\nconst float32ArrayTag = '[object Float32Array]';\nconst float64ArrayTag = '[object Float64Array]';\n\nexport { argumentsTag, arrayBufferTag, arrayTag, bigInt64ArrayTag, bigUint64ArrayTag, booleanTag, dataViewTag, dateTag, errorTag, float32ArrayTag, float64ArrayTag, functionTag, int16ArrayTag, int32ArrayTag, int8ArrayTag, mapTag, numberTag, objectTag, regexpTag, setTag, stringTag, symbolTag, uint16ArrayTag, uint32ArrayTag, uint8ArrayTag, uint8ClampedArrayTag };\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getArrayDecoder,\n  getArrayEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getConstantDecoder,\n  getConstantEncoder,\n  getHiddenPrefixDecoder,\n  getHiddenPrefixEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  padLeftEncoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/kit';\nimport {\n  getExtensionDecoder,\n  getExtensionEncoder,\n  type Extension,\n  type ExtensionArgs,\n} from '../types';\n\nexport type Mint = {\n  /**\n   * Optional authority used to mint new tokens. The mint authority may only\n   * be provided during mint creation. If no mint authority is present\n   * then the mint has a fixed supply and no further tokens may be minted.\n   */\n  mintAuthority: Option<Address>;\n  /** Total supply of tokens. */\n  supply: bigint;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** Is `true` if this structure has been initialized. */\n  isInitialized: boolean;\n  /** Optional authority to freeze token accounts. */\n  freezeAuthority: Option<Address>;\n  /** The extensions activated on the mint account. */\n  extensions: Option<Array<Extension>>;\n};\n\nexport type MintArgs = {\n  /**\n   * Optional authority used to mint new tokens. The mint authority may only\n   * be provided during mint creation. If no mint authority is present\n   * then the mint has a fixed supply and no further tokens may be minted.\n   */\n  mintAuthority: OptionOrNullable<Address>;\n  /** Total supply of tokens. */\n  supply: number | bigint;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** Is `true` if this structure has been initialized. */\n  isInitialized: boolean;\n  /** Optional authority to freeze token accounts. */\n  freezeAuthority: OptionOrNullable<Address>;\n  /** The extensions activated on the mint account. */\n  extensions: OptionOrNullable<Array<ExtensionArgs>>;\n};\n\nexport function getMintEncoder(): Encoder<MintArgs> {\n  return getStructEncoder([\n    [\n      'mintAuthority',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['supply', getU64Encoder()],\n    ['decimals', getU8Encoder()],\n    ['isInitialized', getBooleanEncoder()],\n    [\n      'freezeAuthority',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'extensions',\n      getOptionEncoder(\n        getHiddenPrefixEncoder(\n          getArrayEncoder(getExtensionEncoder(), { size: 'remainder' }),\n          [getConstantEncoder(padLeftEncoder(getU8Encoder(), 83).encode(1))]\n        ),\n        { prefix: null }\n      ),\n    ],\n  ]);\n}\n\nexport function getMintDecoder(): Decoder<Mint> {\n  return getStructDecoder([\n    [\n      'mintAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['supply', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n    ['isInitialized', getBooleanDecoder()],\n    [\n      'freezeAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'extensions',\n      getOptionDecoder(\n        getHiddenPrefixDecoder(\n          getArrayDecoder(getExtensionDecoder(), { size: 'remainder' }),\n          [getConstantDecoder(padLeftEncoder(getU8Encoder(), 83).encode(1))]\n        ),\n        { prefix: null }\n      ),\n    ],\n  ]);\n}\n\nexport function getMintCodec(): Codec<MintArgs, Mint> {\n  return combineCodec(getMintEncoder(), getMintDecoder());\n}\n\nexport function decodeMint<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Mint, TAddress>;\nexport function decodeMint<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Mint, TAddress>;\nexport function decodeMint<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Mint, TAddress> | MaybeAccount<Mint, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getMintDecoder()\n  );\n}\n\nexport async function fetchMint<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Mint, TAddress>> {\n  const maybeAccount = await fetchMaybeMint(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeMint<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Mint, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeMint(maybeAccount);\n}\n\nexport async function fetchAllMint(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Mint>[]> {\n  const maybeAccounts = await fetchAllMaybeMint(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeMint(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Mint>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeMint(maybeAccount));\n}\n","function isPlainObject(value) {\n    if (!value || typeof value !== 'object') {\n        return false;\n    }\n    const proto = Object.getPrototypeOf(value);\n    const hasObjectPrototype = proto === null ||\n        proto === Object.prototype ||\n        Object.getPrototypeOf(proto) === null;\n    if (!hasObjectPrototype) {\n        return false;\n    }\n    return Object.prototype.toString.call(value) === '[object Object]';\n}\n\nexport { isPlainObject };\n","import { isPlainObject } from './isPlainObject.mjs';\nimport { getSymbols } from '../compat/_internal/getSymbols.mjs';\nimport { getTag } from '../compat/_internal/getTag.mjs';\nimport { functionTag, regexpTag, symbolTag, dateTag, booleanTag, numberTag, stringTag, objectTag, errorTag, dataViewTag, arrayBufferTag, float64ArrayTag, float32ArrayTag, bigInt64ArrayTag, int32ArrayTag, int16ArrayTag, int8ArrayTag, bigUint64ArrayTag, uint32ArrayTag, uint16ArrayTag, uint8ClampedArrayTag, uint8ArrayTag, arrayTag, setTag, mapTag, argumentsTag } from '../compat/_internal/tags.mjs';\nimport { eq } from '../compat/util/eq.mjs';\n\nfunction isEqualWith(a, b, areValuesEqual) {\n    return isEqualWithImpl(a, b, undefined, undefined, undefined, undefined, areValuesEqual);\n}\nfunction isEqualWithImpl(a, b, property, aParent, bParent, stack, areValuesEqual) {\n    const result = areValuesEqual(a, b, property, aParent, bParent, stack);\n    if (result !== undefined) {\n        return result;\n    }\n    if (typeof a === typeof b) {\n        switch (typeof a) {\n            case 'bigint':\n            case 'string':\n            case 'boolean':\n            case 'symbol':\n            case 'undefined': {\n                return a === b;\n            }\n            case 'number': {\n                return a === b || Object.is(a, b);\n            }\n            case 'function': {\n                return a === b;\n            }\n            case 'object': {\n                return areObjectsEqual(a, b, stack, areValuesEqual);\n            }\n        }\n    }\n    return areObjectsEqual(a, b, stack, areValuesEqual);\n}\nfunction areObjectsEqual(a, b, stack, areValuesEqual) {\n    if (Object.is(a, b)) {\n        return true;\n    }\n    let aTag = getTag(a);\n    let bTag = getTag(b);\n    if (aTag === argumentsTag) {\n        aTag = objectTag;\n    }\n    if (bTag === argumentsTag) {\n        bTag = objectTag;\n    }\n    if (aTag !== bTag) {\n        return false;\n    }\n    switch (aTag) {\n        case stringTag:\n            return a.toString() === b.toString();\n        case numberTag: {\n            const x = a.valueOf();\n            const y = b.valueOf();\n            return eq(x, y);\n        }\n        case booleanTag:\n        case dateTag:\n        case symbolTag:\n            return Object.is(a.valueOf(), b.valueOf());\n        case regexpTag: {\n            return a.source === b.source && a.flags === b.flags;\n        }\n        case functionTag: {\n            return a === b;\n        }\n    }\n    stack = stack ?? new Map();\n    const aStack = stack.get(a);\n    const bStack = stack.get(b);\n    if (aStack != null && bStack != null) {\n        return aStack === b;\n    }\n    stack.set(a, b);\n    stack.set(b, a);\n    try {\n        switch (aTag) {\n            case mapTag: {\n                if (a.size !== b.size) {\n                    return false;\n                }\n                for (const [key, value] of a.entries()) {\n                    if (!b.has(key) || !isEqualWithImpl(value, b.get(key), key, a, b, stack, areValuesEqual)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            case setTag: {\n                if (a.size !== b.size) {\n                    return false;\n                }\n                const aValues = Array.from(a.values());\n                const bValues = Array.from(b.values());\n                for (let i = 0; i < aValues.length; i++) {\n                    const aValue = aValues[i];\n                    const index = bValues.findIndex(bValue => {\n                        return isEqualWithImpl(aValue, bValue, undefined, a, b, stack, areValuesEqual);\n                    });\n                    if (index === -1) {\n                        return false;\n                    }\n                    bValues.splice(index, 1);\n                }\n                return true;\n            }\n            case arrayTag:\n            case uint8ArrayTag:\n            case uint8ClampedArrayTag:\n            case uint16ArrayTag:\n            case uint32ArrayTag:\n            case bigUint64ArrayTag:\n            case int8ArrayTag:\n            case int16ArrayTag:\n            case int32ArrayTag:\n            case bigInt64ArrayTag:\n            case float32ArrayTag:\n            case float64ArrayTag: {\n                if (typeof Buffer !== 'undefined' && Buffer.isBuffer(a) !== Buffer.isBuffer(b)) {\n                    return false;\n                }\n                if (a.length !== b.length) {\n                    return false;\n                }\n                for (let i = 0; i < a.length; i++) {\n                    if (!isEqualWithImpl(a[i], b[i], i, a, b, stack, areValuesEqual)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            case arrayBufferTag: {\n                if (a.byteLength !== b.byteLength) {\n                    return false;\n                }\n                return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack, areValuesEqual);\n            }\n            case dataViewTag: {\n                if (a.byteLength !== b.byteLength || a.byteOffset !== b.byteOffset) {\n                    return false;\n                }\n                return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack, areValuesEqual);\n            }\n            case errorTag: {\n                return a.name === b.name && a.message === b.message;\n            }\n            case objectTag: {\n                const areEqualInstances = areObjectsEqual(a.constructor, b.constructor, stack, areValuesEqual) ||\n                    (isPlainObject(a) && isPlainObject(b));\n                if (!areEqualInstances) {\n                    return false;\n                }\n                const aKeys = [...Object.keys(a), ...getSymbols(a)];\n                const bKeys = [...Object.keys(b), ...getSymbols(b)];\n                if (aKeys.length !== bKeys.length) {\n                    return false;\n                }\n                for (let i = 0; i < aKeys.length; i++) {\n                    const propKey = aKeys[i];\n                    const aProp = a[propKey];\n                    if (!Object.hasOwn(b, propKey)) {\n                        return false;\n                    }\n                    const bProp = b[propKey];\n                    if (!isEqualWithImpl(aProp, bProp, propKey, a, b, stack, areValuesEqual)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            default: {\n                return false;\n            }\n        }\n    }\n    finally {\n        stack.delete(a);\n        stack.delete(b);\n    }\n}\n\nexport { isEqualWith };\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getArrayDecoder,\n  getArrayEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  type Account,\n  type Address,\n  type EncodedAccount,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n} from '@solana/kit';\n\nexport type Multisig = {\n  /** Number of signers required. */\n  m: number;\n  /** Number of valid signers. */\n  n: number;\n  /** Is `true` if this structure has been initialized. */\n  isInitialized: boolean;\n  /** Signer public keys. */\n  signers: Array<Address>;\n};\n\nexport type MultisigArgs = Multisig;\n\nexport function getMultisigEncoder(): FixedSizeEncoder<MultisigArgs> {\n  return getStructEncoder([\n    ['m', getU8Encoder()],\n    ['n', getU8Encoder()],\n    ['isInitialized', getBooleanEncoder()],\n    ['signers', getArrayEncoder(getAddressEncoder(), { size: 11 })],\n  ]);\n}\n\nexport function getMultisigDecoder(): FixedSizeDecoder<Multisig> {\n  return getStructDecoder([\n    ['m', getU8Decoder()],\n    ['n', getU8Decoder()],\n    ['isInitialized', getBooleanDecoder()],\n    ['signers', getArrayDecoder(getAddressDecoder(), { size: 11 })],\n  ]);\n}\n\nexport function getMultisigCodec(): FixedSizeCodec<MultisigArgs, Multisig> {\n  return combineCodec(getMultisigEncoder(), getMultisigDecoder());\n}\n\nexport function decodeMultisig<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Multisig, TAddress>;\nexport function decodeMultisig<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Multisig, TAddress>;\nexport function decodeMultisig<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Multisig, TAddress> | MaybeAccount<Multisig, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getMultisigDecoder()\n  );\n}\n\nexport async function fetchMultisig<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Multisig, TAddress>> {\n  const maybeAccount = await fetchMaybeMultisig(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeMultisig<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Multisig, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeMultisig(maybeAccount);\n}\n\nexport async function fetchAllMultisig(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Multisig>[]> {\n  const maybeAccounts = await fetchAllMaybeMultisig(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeMultisig(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Multisig>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeMultisig(maybeAccount));\n}\n\nexport function getMultisigSize(): number {\n  return 355;\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getArrayDecoder,\n  getArrayEncoder,\n  getConstantDecoder,\n  getConstantEncoder,\n  getHiddenPrefixDecoder,\n  getHiddenPrefixEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Encoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/kit';\nimport {\n  getAccountStateDecoder,\n  getAccountStateEncoder,\n  getExtensionDecoder,\n  getExtensionEncoder,\n  type AccountState,\n  type AccountStateArgs,\n  type Extension,\n  type ExtensionArgs,\n} from '../types';\n\nexport type Token = {\n  /** The mint associated with this account. */\n  mint: Address;\n  /** The owner of this account. */\n  owner: Address;\n  /** The amount of tokens this account holds. */\n  amount: bigint;\n  /**\n   * If `delegate` is `Some` then `delegated_amount` represents\n   * the amount authorized by the delegate.\n   */\n  delegate: Option<Address>;\n  /** The account's state. */\n  state: AccountState;\n  /**\n   * If is_native.is_some, this is a native token, and the value logs the\n   * rent-exempt reserve. An Account is required to be rent-exempt, so\n   * the value is used by the Processor to ensure that wrapped SOL\n   * accounts do not drop below this threshold.\n   */\n  isNative: Option<bigint>;\n  /** The amount delegated. */\n  delegatedAmount: bigint;\n  /** Optional authority to close the account. */\n  closeAuthority: Option<Address>;\n  /** The extensions activated on the token account. */\n  extensions: Option<Array<Extension>>;\n};\n\nexport type TokenArgs = {\n  /** The mint associated with this account. */\n  mint: Address;\n  /** The owner of this account. */\n  owner: Address;\n  /** The amount of tokens this account holds. */\n  amount: number | bigint;\n  /**\n   * If `delegate` is `Some` then `delegated_amount` represents\n   * the amount authorized by the delegate.\n   */\n  delegate: OptionOrNullable<Address>;\n  /** The account's state. */\n  state: AccountStateArgs;\n  /**\n   * If is_native.is_some, this is a native token, and the value logs the\n   * rent-exempt reserve. An Account is required to be rent-exempt, so\n   * the value is used by the Processor to ensure that wrapped SOL\n   * accounts do not drop below this threshold.\n   */\n  isNative: OptionOrNullable<number | bigint>;\n  /** The amount delegated. */\n  delegatedAmount: number | bigint;\n  /** Optional authority to close the account. */\n  closeAuthority: OptionOrNullable<Address>;\n  /** The extensions activated on the token account. */\n  extensions: OptionOrNullable<Array<ExtensionArgs>>;\n};\n\nexport function getTokenEncoder(): Encoder<TokenArgs> {\n  return getStructEncoder([\n    ['mint', getAddressEncoder()],\n    ['owner', getAddressEncoder()],\n    ['amount', getU64Encoder()],\n    [\n      'delegate',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['state', getAccountStateEncoder()],\n    [\n      'isNative',\n      getOptionEncoder(getU64Encoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['delegatedAmount', getU64Encoder()],\n    [\n      'closeAuthority',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'extensions',\n      getOptionEncoder(\n        getHiddenPrefixEncoder(\n          getArrayEncoder(getExtensionEncoder(), { size: 'remainder' }),\n          [getConstantEncoder(getU8Encoder().encode(2))]\n        ),\n        { prefix: null }\n      ),\n    ],\n  ]);\n}\n\nexport function getTokenDecoder(): Decoder<Token> {\n  return getStructDecoder([\n    ['mint', getAddressDecoder()],\n    ['owner', getAddressDecoder()],\n    ['amount', getU64Decoder()],\n    [\n      'delegate',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['state', getAccountStateDecoder()],\n    [\n      'isNative',\n      getOptionDecoder(getU64Decoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['delegatedAmount', getU64Decoder()],\n    [\n      'closeAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'extensions',\n      getOptionDecoder(\n        getHiddenPrefixDecoder(\n          getArrayDecoder(getExtensionDecoder(), { size: 'remainder' }),\n          [getConstantDecoder(getU8Encoder().encode(2))]\n        ),\n        { prefix: null }\n      ),\n    ],\n  ]);\n}\n\nexport function getTokenCodec(): Codec<TokenArgs, Token> {\n  return combineCodec(getTokenEncoder(), getTokenDecoder());\n}\n\nexport function decodeToken<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Token, TAddress>;\nexport function decodeToken<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Token, TAddress>;\nexport function decodeToken<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Token, TAddress> | MaybeAccount<Token, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getTokenDecoder()\n  );\n}\n\nexport async function fetchToken<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Token, TAddress>> {\n  const maybeAccount = await fetchMaybeToken(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeToken<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Token, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeToken(maybeAccount);\n}\n\nexport async function fetchAllToken(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Token>[]> {\n  const maybeAccounts = await fetchAllMaybeToken(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeToken(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Token>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeToken(maybeAccount));\n}\n","/**\n * Internal helpers for blake hash.\n * @module\n */\nimport { rotr } from \"./utils.js\";\n/**\n * Internal blake variable.\n * For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n */\n// prettier-ignore\nexport const BSIGMA = /* @__PURE__ */ Uint8Array.from([\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n    14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n    11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n    7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n    9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n    2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n    12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n    13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n    6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n    10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n    14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n    // Blake1, unused in others\n    11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n    7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n    9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n    2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n]);\n// Mixing function G splitted in two halfs\nexport function G1s(a, b, c, d, x) {\n    a = (a + b + x) | 0;\n    d = rotr(d ^ a, 16);\n    c = (c + d) | 0;\n    b = rotr(b ^ c, 12);\n    return { a, b, c, d };\n}\nexport function G2s(a, b, c, d, x) {\n    a = (a + b + x) | 0;\n    d = rotr(d ^ a, 8);\n    c = (c + d) | 0;\n    b = rotr(b ^ c, 7);\n    return { a, b, c, d };\n}\n//# sourceMappingURL=_blake.js.map","/**\n * blake2b (64-bit) & blake2s (8 to 32-bit) hash functions.\n * b could have been faster, but there is no fast u64 in js, so s is 1.5x faster.\n * @module\n */\nimport { BSIGMA, G1s, G2s } from \"./_blake.js\";\nimport { SHA256_IV } from \"./_md.js\";\nimport * as u64 from \"./_u64.js\";\n// prettier-ignore\nimport { abytes, aexists, anumber, aoutput, clean, createOptHasher, Hash, swap32IfBE, swap8IfBE, toBytes, u32 } from \"./utils.js\";\n// Same as SHA512_IV, but swapped endianness: LE instead of BE. iv[1] is iv[0], etc.\nconst B2B_IV = /* @__PURE__ */ Uint32Array.from([\n    0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,\n    0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19,\n]);\n// Temporary buffer\nconst BBUF = /* @__PURE__ */ new Uint32Array(32);\n// Mixing function G splitted in two halfs\nfunction G1b(a, b, c, d, msg, x) {\n    // NOTE: V is LE here\n    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n    let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n    let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n    let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n    let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n    // v[a] = (v[a] + v[b] + x) | 0;\n    let ll = u64.add3L(Al, Bl, Xl);\n    Ah = u64.add3H(ll, Ah, Bh, Xh);\n    Al = ll | 0;\n    // v[d] = rotr(v[d] ^ v[a], 32)\n    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n    ({ Dh, Dl } = { Dh: u64.rotr32H(Dh, Dl), Dl: u64.rotr32L(Dh, Dl) });\n    // v[c] = (v[c] + v[d]) | 0;\n    ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n    // v[b] = rotr(v[b] ^ v[c], 24)\n    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n    ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 24), Bl: u64.rotrSL(Bh, Bl, 24) });\n    (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n    (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n    (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n    (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\nfunction G2b(a, b, c, d, msg, x) {\n    // NOTE: V is LE here\n    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n    let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n    let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n    let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n    let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n    // v[a] = (v[a] + v[b] + x) | 0;\n    let ll = u64.add3L(Al, Bl, Xl);\n    Ah = u64.add3H(ll, Ah, Bh, Xh);\n    Al = ll | 0;\n    // v[d] = rotr(v[d] ^ v[a], 16)\n    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n    ({ Dh, Dl } = { Dh: u64.rotrSH(Dh, Dl, 16), Dl: u64.rotrSL(Dh, Dl, 16) });\n    // v[c] = (v[c] + v[d]) | 0;\n    ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n    // v[b] = rotr(v[b] ^ v[c], 63)\n    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n    ({ Bh, Bl } = { Bh: u64.rotrBH(Bh, Bl, 63), Bl: u64.rotrBL(Bh, Bl, 63) });\n    (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n    (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n    (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n    (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\nfunction checkBlake2Opts(outputLen, opts = {}, keyLen, saltLen, persLen) {\n    anumber(keyLen);\n    if (outputLen < 0 || outputLen > keyLen)\n        throw new Error('outputLen bigger than keyLen');\n    const { key, salt, personalization } = opts;\n    if (key !== undefined && (key.length < 1 || key.length > keyLen))\n        throw new Error('key length must be undefined or 1..' + keyLen);\n    if (salt !== undefined && salt.length !== saltLen)\n        throw new Error('salt must be undefined or ' + saltLen);\n    if (personalization !== undefined && personalization.length !== persLen)\n        throw new Error('personalization must be undefined or ' + persLen);\n}\n/** Class, from which others are subclassed. */\nexport class BLAKE2 extends Hash {\n    constructor(blockLen, outputLen) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        this.length = 0;\n        this.pos = 0;\n        anumber(blockLen);\n        anumber(outputLen);\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.buffer = new Uint8Array(blockLen);\n        this.buffer32 = u32(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        data = toBytes(data);\n        abytes(data);\n        // Main difference with other hashes: there is flag for last block,\n        // so we cannot process current block before we know that there\n        // is the next one. This significantly complicates logic and reduces ability\n        // to do zero-copy processing\n        const { blockLen, buffer, buffer32 } = this;\n        const len = data.length;\n        const offset = data.byteOffset;\n        const buf = data.buffer;\n        for (let pos = 0; pos < len;) {\n            // If buffer is full and we still have input (don't process last block, same as blake2s)\n            if (this.pos === blockLen) {\n                swap32IfBE(buffer32);\n                this.compress(buffer32, 0, false);\n                swap32IfBE(buffer32);\n                this.pos = 0;\n            }\n            const take = Math.min(blockLen - this.pos, len - pos);\n            const dataOffset = offset + pos;\n            // full block && aligned to 4 bytes && not last in input\n            if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n                const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n                swap32IfBE(data32);\n                for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n                    this.length += blockLen;\n                    this.compress(data32, pos32, false);\n                }\n                swap32IfBE(data32);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            this.length += take;\n            pos += take;\n        }\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        const { pos, buffer32 } = this;\n        this.finished = true;\n        // Padding\n        clean(this.buffer.subarray(pos));\n        swap32IfBE(buffer32);\n        this.compress(buffer32, 0, true);\n        swap32IfBE(buffer32);\n        const out32 = u32(out);\n        this.get().forEach((v, i) => (out32[i] = swap8IfBE(v)));\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        const { buffer, length, finished, destroyed, outputLen, pos } = this;\n        to || (to = new this.constructor({ dkLen: outputLen }));\n        to.set(...this.get());\n        to.buffer.set(buffer);\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        // @ts-ignore\n        to.outputLen = outputLen;\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\nexport class BLAKE2b extends BLAKE2 {\n    constructor(opts = {}) {\n        const olen = opts.dkLen === undefined ? 64 : opts.dkLen;\n        super(128, olen);\n        // Same as SHA-512, but LE\n        this.v0l = B2B_IV[0] | 0;\n        this.v0h = B2B_IV[1] | 0;\n        this.v1l = B2B_IV[2] | 0;\n        this.v1h = B2B_IV[3] | 0;\n        this.v2l = B2B_IV[4] | 0;\n        this.v2h = B2B_IV[5] | 0;\n        this.v3l = B2B_IV[6] | 0;\n        this.v3h = B2B_IV[7] | 0;\n        this.v4l = B2B_IV[8] | 0;\n        this.v4h = B2B_IV[9] | 0;\n        this.v5l = B2B_IV[10] | 0;\n        this.v5h = B2B_IV[11] | 0;\n        this.v6l = B2B_IV[12] | 0;\n        this.v6h = B2B_IV[13] | 0;\n        this.v7l = B2B_IV[14] | 0;\n        this.v7h = B2B_IV[15] | 0;\n        checkBlake2Opts(olen, opts, 64, 16, 16);\n        let { key, personalization, salt } = opts;\n        let keyLength = 0;\n        if (key !== undefined) {\n            key = toBytes(key);\n            keyLength = key.length;\n        }\n        this.v0l ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n        if (salt !== undefined) {\n            salt = toBytes(salt);\n            const slt = u32(salt);\n            this.v4l ^= swap8IfBE(slt[0]);\n            this.v4h ^= swap8IfBE(slt[1]);\n            this.v5l ^= swap8IfBE(slt[2]);\n            this.v5h ^= swap8IfBE(slt[3]);\n        }\n        if (personalization !== undefined) {\n            personalization = toBytes(personalization);\n            const pers = u32(personalization);\n            this.v6l ^= swap8IfBE(pers[0]);\n            this.v6h ^= swap8IfBE(pers[1]);\n            this.v7l ^= swap8IfBE(pers[2]);\n            this.v7h ^= swap8IfBE(pers[3]);\n        }\n        if (key !== undefined) {\n            // Pad to blockLen and update\n            const tmp = new Uint8Array(this.blockLen);\n            tmp.set(key);\n            this.update(tmp);\n        }\n    }\n    // prettier-ignore\n    get() {\n        let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;\n        return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];\n    }\n    // prettier-ignore\n    set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {\n        this.v0l = v0l | 0;\n        this.v0h = v0h | 0;\n        this.v1l = v1l | 0;\n        this.v1h = v1h | 0;\n        this.v2l = v2l | 0;\n        this.v2h = v2h | 0;\n        this.v3l = v3l | 0;\n        this.v3h = v3h | 0;\n        this.v4l = v4l | 0;\n        this.v4h = v4h | 0;\n        this.v5l = v5l | 0;\n        this.v5h = v5h | 0;\n        this.v6l = v6l | 0;\n        this.v6h = v6h | 0;\n        this.v7l = v7l | 0;\n        this.v7h = v7h | 0;\n    }\n    compress(msg, offset, isLast) {\n        this.get().forEach((v, i) => (BBUF[i] = v)); // First half from state.\n        BBUF.set(B2B_IV, 16); // Second half from IV.\n        let { h, l } = u64.fromBig(BigInt(this.length));\n        BBUF[24] = B2B_IV[8] ^ l; // Low word of the offset.\n        BBUF[25] = B2B_IV[9] ^ h; // High word.\n        // Invert all bits for last block\n        if (isLast) {\n            BBUF[28] = ~BBUF[28];\n            BBUF[29] = ~BBUF[29];\n        }\n        let j = 0;\n        const s = BSIGMA;\n        for (let i = 0; i < 12; i++) {\n            G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n            G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n            G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n            G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n            G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n            G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n            G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n            G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n            G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n            G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n            G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n            G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n            G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n            G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n            G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n            G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n        }\n        this.v0l ^= BBUF[0] ^ BBUF[16];\n        this.v0h ^= BBUF[1] ^ BBUF[17];\n        this.v1l ^= BBUF[2] ^ BBUF[18];\n        this.v1h ^= BBUF[3] ^ BBUF[19];\n        this.v2l ^= BBUF[4] ^ BBUF[20];\n        this.v2h ^= BBUF[5] ^ BBUF[21];\n        this.v3l ^= BBUF[6] ^ BBUF[22];\n        this.v3h ^= BBUF[7] ^ BBUF[23];\n        this.v4l ^= BBUF[8] ^ BBUF[24];\n        this.v4h ^= BBUF[9] ^ BBUF[25];\n        this.v5l ^= BBUF[10] ^ BBUF[26];\n        this.v5h ^= BBUF[11] ^ BBUF[27];\n        this.v6l ^= BBUF[12] ^ BBUF[28];\n        this.v6h ^= BBUF[13] ^ BBUF[29];\n        this.v7l ^= BBUF[14] ^ BBUF[30];\n        this.v7h ^= BBUF[15] ^ BBUF[31];\n        clean(BBUF);\n    }\n    destroy() {\n        this.destroyed = true;\n        clean(this.buffer32);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\n/**\n * Blake2b hash function. 64-bit. 1.5x slower than blake2s in JS.\n * @param msg - message that would be hashed\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\n */\nexport const blake2b = /* @__PURE__ */ createOptHasher((opts) => new BLAKE2b(opts));\n// prettier-ignore\nexport function compress(s, offset, msg, rounds, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {\n    let j = 0;\n    for (let i = 0; i < rounds; i++) {\n        ({ a: v0, b: v4, c: v8, d: v12 } = G1s(v0, v4, v8, v12, msg[offset + s[j++]]));\n        ({ a: v0, b: v4, c: v8, d: v12 } = G2s(v0, v4, v8, v12, msg[offset + s[j++]]));\n        ({ a: v1, b: v5, c: v9, d: v13 } = G1s(v1, v5, v9, v13, msg[offset + s[j++]]));\n        ({ a: v1, b: v5, c: v9, d: v13 } = G2s(v1, v5, v9, v13, msg[offset + s[j++]]));\n        ({ a: v2, b: v6, c: v10, d: v14 } = G1s(v2, v6, v10, v14, msg[offset + s[j++]]));\n        ({ a: v2, b: v6, c: v10, d: v14 } = G2s(v2, v6, v10, v14, msg[offset + s[j++]]));\n        ({ a: v3, b: v7, c: v11, d: v15 } = G1s(v3, v7, v11, v15, msg[offset + s[j++]]));\n        ({ a: v3, b: v7, c: v11, d: v15 } = G2s(v3, v7, v11, v15, msg[offset + s[j++]]));\n        ({ a: v0, b: v5, c: v10, d: v15 } = G1s(v0, v5, v10, v15, msg[offset + s[j++]]));\n        ({ a: v0, b: v5, c: v10, d: v15 } = G2s(v0, v5, v10, v15, msg[offset + s[j++]]));\n        ({ a: v1, b: v6, c: v11, d: v12 } = G1s(v1, v6, v11, v12, msg[offset + s[j++]]));\n        ({ a: v1, b: v6, c: v11, d: v12 } = G2s(v1, v6, v11, v12, msg[offset + s[j++]]));\n        ({ a: v2, b: v7, c: v8, d: v13 } = G1s(v2, v7, v8, v13, msg[offset + s[j++]]));\n        ({ a: v2, b: v7, c: v8, d: v13 } = G2s(v2, v7, v8, v13, msg[offset + s[j++]]));\n        ({ a: v3, b: v4, c: v9, d: v14 } = G1s(v3, v4, v9, v14, msg[offset + s[j++]]));\n        ({ a: v3, b: v4, c: v9, d: v14 } = G2s(v3, v4, v9, v14, msg[offset + s[j++]]));\n    }\n    return { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 };\n}\nconst B2S_IV = SHA256_IV;\nexport class BLAKE2s extends BLAKE2 {\n    constructor(opts = {}) {\n        const olen = opts.dkLen === undefined ? 32 : opts.dkLen;\n        super(64, olen);\n        // Internal state, same as SHA-256\n        this.v0 = B2S_IV[0] | 0;\n        this.v1 = B2S_IV[1] | 0;\n        this.v2 = B2S_IV[2] | 0;\n        this.v3 = B2S_IV[3] | 0;\n        this.v4 = B2S_IV[4] | 0;\n        this.v5 = B2S_IV[5] | 0;\n        this.v6 = B2S_IV[6] | 0;\n        this.v7 = B2S_IV[7] | 0;\n        checkBlake2Opts(olen, opts, 32, 8, 8);\n        let { key, personalization, salt } = opts;\n        let keyLength = 0;\n        if (key !== undefined) {\n            key = toBytes(key);\n            keyLength = key.length;\n        }\n        this.v0 ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n        if (salt !== undefined) {\n            salt = toBytes(salt);\n            const slt = u32(salt);\n            this.v4 ^= swap8IfBE(slt[0]);\n            this.v5 ^= swap8IfBE(slt[1]);\n        }\n        if (personalization !== undefined) {\n            personalization = toBytes(personalization);\n            const pers = u32(personalization);\n            this.v6 ^= swap8IfBE(pers[0]);\n            this.v7 ^= swap8IfBE(pers[1]);\n        }\n        if (key !== undefined) {\n            // Pad to blockLen and update\n            abytes(key);\n            const tmp = new Uint8Array(this.blockLen);\n            tmp.set(key);\n            this.update(tmp);\n        }\n    }\n    get() {\n        const { v0, v1, v2, v3, v4, v5, v6, v7 } = this;\n        return [v0, v1, v2, v3, v4, v5, v6, v7];\n    }\n    // prettier-ignore\n    set(v0, v1, v2, v3, v4, v5, v6, v7) {\n        this.v0 = v0 | 0;\n        this.v1 = v1 | 0;\n        this.v2 = v2 | 0;\n        this.v3 = v3 | 0;\n        this.v4 = v4 | 0;\n        this.v5 = v5 | 0;\n        this.v6 = v6 | 0;\n        this.v7 = v7 | 0;\n    }\n    compress(msg, offset, isLast) {\n        const { h, l } = u64.fromBig(BigInt(this.length));\n        // prettier-ignore\n        const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress(BSIGMA, offset, msg, 10, this.v0, this.v1, this.v2, this.v3, this.v4, this.v5, this.v6, this.v7, B2S_IV[0], B2S_IV[1], B2S_IV[2], B2S_IV[3], l ^ B2S_IV[4], h ^ B2S_IV[5], isLast ? ~B2S_IV[6] : B2S_IV[6], B2S_IV[7]);\n        this.v0 ^= v0 ^ v8;\n        this.v1 ^= v1 ^ v9;\n        this.v2 ^= v2 ^ v10;\n        this.v3 ^= v3 ^ v11;\n        this.v4 ^= v4 ^ v12;\n        this.v5 ^= v5 ^ v13;\n        this.v6 ^= v6 ^ v14;\n        this.v7 ^= v7 ^ v15;\n    }\n    destroy() {\n        this.destroyed = true;\n        clean(this.buffer32);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\n/**\n * Blake2s hash function. Focuses on 8-bit to 32-bit platforms. 1.5x faster than blake2b in JS.\n * @param msg - message that would be hashed\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\n */\nexport const blake2s = /* @__PURE__ */ createOptHasher((opts) => new BLAKE2s(opts));\n//# sourceMappingURL=blake2.js.map","import { isEqualWith } from './isEqualWith.mjs';\nimport { noop } from '../function/noop.mjs';\n\nfunction isEqual(a, b) {\n    return isEqualWith(a, b, noop);\n}\n\nexport { isEqual };\n","import { isEqual } from \"es-toolkit/compat\";\nimport { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { ICore, IStore } from \"@walletconnect/types\";\nimport {\n  getInternalError,\n  isProposalStruct,\n  isSessionStruct,\n  isUndefined,\n} from \"@walletconnect/utils\";\nimport { CORE_STORAGE_PREFIX, STORE_STORAGE_VERSION } from \"../constants/index.js\";\n\nexport class Store<Key, Data extends Record<string, any>> extends IStore<Key, Data> {\n  public map = new Map<Key, Data>();\n  public version = STORE_STORAGE_VERSION;\n\n  private cached: Data[] = [];\n  private initialized = false;\n\n  /**\n   * Regenerates the value key to retrieve it from cache\n   */\n  private getKey: ((data: Data) => Key) | undefined;\n\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  // stores recently deleted key to return different rejection message when key is not found\n  private recentlyDeleted: Key[] = [];\n  private recentlyDeletedLimit = 200;\n\n  /**\n   * @param {ICore} core Core\n   * @param {Logger} logger Logger\n   * @param {string} name Store's name\n   * @param {Store<Key, Data>[\"getKey\"]} getKey Regenerates the value key to retrieve it from cache\n   * @param {string} storagePrefix Prefixes value keys\n   */\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public name: string,\n    storagePrefix: string = CORE_STORAGE_PREFIX,\n    getKey: Store<Key, Data>[\"getKey\"] = undefined,\n  ) {\n    super(core, logger, name, storagePrefix);\n    this.logger = generateChildLogger(logger, this.name);\n    this.storagePrefix = storagePrefix;\n    this.getKey = getKey;\n  }\n\n  public init: IStore<Key, Data>[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n\n      await this.restore();\n\n      this.cached.forEach((value) => {\n        if (this.getKey && value !== null && !isUndefined(value)) {\n          this.map.set(this.getKey(value), value);\n        } else if (isProposalStruct(value)) {\n          // TODO(pedro) revert type casting as any\n          this.map.set(value.id as any, value);\n        } else if (isSessionStruct(value)) {\n          // TODO(pedro) revert type casting as any\n          this.map.set(value.topic as any, value);\n        }\n      });\n\n      this.cached = [];\n      this.initialized = true;\n    }\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n\n  get length() {\n    return this.map.size;\n  }\n\n  get keys() {\n    return Array.from(this.map.keys());\n  }\n\n  get values() {\n    return Array.from(this.map.values());\n  }\n\n  public set: IStore<Key, Data>[\"set\"] = async (key, value) => {\n    this.isInitialized();\n    if (this.map.has(key)) {\n      await this.update(key, value);\n    } else {\n      this.logger.debug(`Setting value`);\n      this.logger.trace({ type: \"method\", method: \"set\", key, value });\n      this.map.set(key, value);\n      await this.persist();\n    }\n  };\n\n  public get: IStore<Key, Data>[\"get\"] = (key) => {\n    this.isInitialized();\n    this.logger.debug(`Getting value`);\n    this.logger.trace({ type: \"method\", method: \"get\", key });\n    const value = this.getData(key);\n    return value;\n  };\n\n  public getAll: IStore<Key, Data>[\"getAll\"] = (filter) => {\n    this.isInitialized();\n    if (!filter) return this.values;\n\n    return this.values.filter((value) =>\n      Object.keys(filter).every((key) => isEqual(value[key], filter[key])),\n    );\n  };\n\n  public update: IStore<Key, Data>[\"update\"] = async (key, update) => {\n    this.isInitialized();\n    this.logger.debug(`Updating value`);\n    this.logger.trace({ type: \"method\", method: \"update\", key, update });\n    const value = { ...this.getData(key), ...update };\n    this.map.set(key, value);\n    await this.persist();\n  };\n\n  public delete: IStore<Key, Data>[\"delete\"] = async (key, reason) => {\n    this.isInitialized();\n    if (!this.map.has(key)) return;\n    this.logger.debug(`Deleting value`);\n    this.logger.trace({ type: \"method\", method: \"delete\", key, reason });\n    this.map.delete(key);\n    this.addToRecentlyDeleted(key);\n    await this.persist();\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private addToRecentlyDeleted(key: Key) {\n    this.recentlyDeleted.push(key);\n    // limit the size of the recentlyDeleted array, truncate the 100 oldest entries.\n    if (this.recentlyDeleted.length >= this.recentlyDeletedLimit) {\n      this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);\n    }\n  }\n\n  private async setDataStore(value: Data[]) {\n    await this.core.storage.setItem<Data[]>(this.storageKey, value);\n  }\n\n  private async getDataStore() {\n    const value = await this.core.storage.getItem<Data[]>(this.storageKey);\n    return value;\n  }\n\n  private getData(key: Key) {\n    const value = this.map.get(key);\n    if (!value) {\n      if (this.recentlyDeleted.includes(key)) {\n        const { message } = getInternalError(\n          \"MISSING_OR_INVALID\",\n          `Record was recently deleted - ${this.name}: ${key}`,\n        );\n        this.logger.error(message);\n        throw new Error(message);\n      }\n\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${key}`);\n      this.logger.error(message);\n      throw new Error(message);\n    }\n    return value;\n  }\n\n  private async persist() {\n    await this.setDataStore(this.values);\n  }\n\n  private async restore() {\n    try {\n      const persisted = await this.getDataStore();\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n      if (this.map.size) {\n        const { message } = getInternalError(\"RESTORE_WILL_OVERRIDE\", this.name);\n        this.logger.error(message);\n        throw new Error(message);\n      }\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored value for ${this.name}`);\n      this.logger.trace({ type: \"method\", method: \"restore\", value: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore value for ${this.name}`);\n      this.logger.error(e as any);\n    }\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { generateChildLogger, Logger } from \"@walletconnect/logger\";\nimport { IEchoClient } from \"@walletconnect/types\";\nimport { ECHO_CONTEXT, ECHO_URL } from \"../constants/index.js\";\n\nexport class EchoClient extends IEchoClient {\n  public readonly context = ECHO_CONTEXT;\n  constructor(\n    public projectId: string,\n    public logger: Logger,\n  ) {\n    super(projectId, logger);\n    this.logger = generateChildLogger(logger, this.context);\n  }\n\n  public registerDeviceToken: IEchoClient[\"registerDeviceToken\"] = async (params) => {\n    const { clientId, token, notificationType, enableEncrypted = false } = params;\n\n    const echoUrl = `${ECHO_URL}/${this.projectId}/clients`;\n\n    await fetch(echoUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        client_id: clientId,\n        type: notificationType,\n        token,\n        always_raw: enableEncrypted,\n      }),\n    });\n  };\n}\n","import { generateChildLogger, Logger } from \"@walletconnect/logger\";\nimport { ICore, IEventClient, EventClientTypes } from \"@walletconnect/types\";\nimport { formatUA, isTestRun, uuidv4, getAppMetadata } from \"@walletconnect/utils\";\nimport { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\nimport { fromMiliseconds } from \"@walletconnect/time\";\nimport {\n  CORE_STORAGE_PREFIX,\n  EVENTS_CLIENT_API_URL,\n  EVENTS_STORAGE_CLEANUP_INTERVAL,\n  EVENTS_STORAGE_CONTEXT,\n  EVENTS_STORAGE_VERSION,\n  RELAYER_SDK_VERSION,\n} from \"../constants/index.js\";\n\nexport class EventClient extends IEventClient {\n  public readonly context = EVENTS_STORAGE_CONTEXT;\n  private readonly storagePrefix = CORE_STORAGE_PREFIX;\n  private readonly storageVersion = EVENTS_STORAGE_VERSION;\n  private events = new Map<string, EventClientTypes.Event>();\n  private shouldPersist = false;\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    telemetryEnabled = true,\n  ) {\n    super(core, logger, telemetryEnabled);\n    this.logger = generateChildLogger(logger, this.context);\n    this.telemetryEnabled = telemetryEnabled;\n    if (telemetryEnabled) {\n      this.restore().then(async () => {\n        await this.submit();\n        this.setEventListeners();\n      });\n    } else {\n      // overwrite any persisted events with an empty array\n      this.persist();\n    }\n  }\n\n  get storageKey() {\n    return (\n      this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + \"//\" + this.context\n    );\n  }\n\n  public init: IEventClient[\"init\"] = async () => {\n    if (isTestRun()) return;\n    try {\n      const initEvent = {\n        eventId: uuidv4(),\n        timestamp: Date.now(),\n        domain: this.getAppDomain(),\n        props: {\n          event: \"INIT\",\n          type: \"\",\n          properties: {\n            client_id: await this.core.crypto.getClientId(),\n            user_agent: formatUA(\n              this.core.relayer.protocol,\n              this.core.relayer.version,\n              RELAYER_SDK_VERSION,\n            ),\n          },\n        },\n      };\n      await this.sendEvent([initEvent] as unknown as EventClientTypes.Event[]);\n    } catch (error) {\n      this.logger.warn(error);\n    }\n  };\n\n  public createEvent: IEventClient[\"createEvent\"] = (params) => {\n    const {\n      event = \"ERROR\",\n      type = \"\",\n      properties: { topic, trace },\n    } = params;\n    const eventId = uuidv4();\n    const bundleId = this.core.projectId || \"\";\n    const timestamp = Date.now();\n    const props = {\n      event,\n      type,\n      properties: {\n        topic,\n        trace,\n      },\n    };\n    const eventObj = {\n      eventId,\n      timestamp,\n      props,\n      bundleId,\n      domain: this.getAppDomain(),\n      ...this.setMethods(eventId),\n    };\n    if (this.telemetryEnabled) {\n      this.events.set(eventId, eventObj);\n      this.shouldPersist = true;\n    }\n\n    return eventObj;\n  };\n\n  public getEvent: IEventClient[\"getEvent\"] = (params) => {\n    const { eventId, topic } = params;\n    if (eventId) {\n      return this.events.get(eventId);\n    }\n    const event = Array.from(this.events.values()).find(\n      (event) => event.props.properties.topic === topic,\n    );\n\n    if (!event) return;\n\n    return {\n      ...event,\n      ...this.setMethods(event.eventId),\n    };\n  };\n\n  public deleteEvent: IEventClient[\"deleteEvent\"] = (params) => {\n    const { eventId } = params;\n    this.events.delete(eventId);\n    this.shouldPersist = true;\n  };\n\n  private setEventListeners = () => {\n    this.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, async () => {\n      if (this.shouldPersist) await this.persist();\n      // cleanup events older than EVENTS_STORAGE_CLEANUP_INTERVAL\n      this.events.forEach((event) => {\n        if (\n          fromMiliseconds(Date.now()) - fromMiliseconds(event.timestamp) >\n          EVENTS_STORAGE_CLEANUP_INTERVAL\n        ) {\n          this.events.delete(event.eventId);\n          this.shouldPersist = true;\n        }\n      });\n    });\n  };\n\n  private setMethods = (eventId: string) => {\n    return {\n      addTrace: (trace: string) => this.addTrace(eventId, trace),\n      setError: (errorType: string) => this.setError(eventId, errorType),\n    };\n  };\n\n  private addTrace = (eventId: string, trace: string) => {\n    const event = this.events.get(eventId);\n    if (!event) return;\n    event.props.properties.trace.push(trace);\n    this.events.set(eventId, event);\n    this.shouldPersist = true;\n  };\n\n  private setError = (eventId: string, errorType: string) => {\n    const event = this.events.get(eventId);\n    if (!event) return;\n    event.props.type = errorType;\n    event.timestamp = Date.now();\n    this.events.set(eventId, event);\n    this.shouldPersist = true;\n  };\n\n  private persist = async () => {\n    await this.core.storage.setItem(this.storageKey, Array.from(this.events.values()));\n    this.shouldPersist = false;\n  };\n\n  private restore = async () => {\n    try {\n      const events =\n        (await this.core.storage.getItem<EventClientTypes.Event[]>(this.storageKey)) || [];\n      if (!events.length) return;\n      events.forEach((event) => {\n        this.events.set(event.eventId, {\n          ...event,\n          ...this.setMethods(event.eventId),\n        });\n      });\n    } catch (error) {\n      this.logger.warn(error);\n    }\n  };\n\n  private submit = async () => {\n    if (!this.telemetryEnabled) return;\n\n    if (this.events.size === 0) return;\n\n    const eventsToSend: EventClientTypes.Event[] = [];\n    // exclude events without type as they can be considered `in progress`\n    for (const [_, event] of this.events) {\n      if (event.props.type) {\n        eventsToSend.push(event);\n      }\n    }\n\n    if (eventsToSend.length === 0) return;\n\n    try {\n      const response = await this.sendEvent(eventsToSend);\n      if (response.ok) {\n        for (const event of eventsToSend) {\n          this.events.delete(event.eventId);\n          this.shouldPersist = true;\n        }\n      }\n    } catch (error) {\n      this.logger.warn(error);\n    }\n  };\n\n  private sendEvent = async (events: EventClientTypes.Event[]) => {\n    // if domain isn't available, set `sp` as `desktop` so data would be extracted on api side\n    const platform = this.getAppDomain() ? \"\" : \"&sp=desktop\";\n    const response = await fetch(\n      `${EVENTS_CLIENT_API_URL}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${RELAYER_SDK_VERSION}${platform}`,\n      {\n        method: \"POST\",\n        body: JSON.stringify(events),\n      },\n    );\n    return response;\n  };\n\n  private getAppDomain = () => {\n    return getAppMetadata().url;\n  };\n}\n","import { EventEmitter } from \"events\";\n\nimport { HeartBeat } from \"@walletconnect/heartbeat\";\nimport KeyValueStorage from \"@walletconnect/keyvaluestorage\";\nimport {\n  ChunkLoggerController,\n  generateChildLogger,\n  generatePlatformLogger,\n  getDefaultLoggerOptions,\n  getLoggerContext,\n} from \"@walletconnect/logger\";\nimport { CoreTypes, ICore } from \"@walletconnect/types\";\n\nimport {\n  CORE_CONTEXT,\n  CORE_DEFAULT,\n  CORE_PROTOCOL,\n  CORE_STORAGE_OPTIONS,\n  CORE_VERSION,\n  RELAYER_DEFAULT_RELAY_URL,\n  TRANSPORT_TYPES,\n  WALLETCONNECT_CLIENT_ID,\n  WALLETCONNECT_LINK_MODE_APPS,\n} from \"./constants/index.js\";\nimport {\n  Crypto,\n  EchoClient,\n  EventClient,\n  Expirer,\n  JsonRpcHistory,\n  Pairing,\n  Relayer,\n  Verify,\n} from \"./controllers/index.js\";\n\nexport class Core extends ICore {\n  public readonly protocol = CORE_PROTOCOL;\n  public readonly version = CORE_VERSION;\n\n  public readonly name: ICore[\"name\"] = CORE_CONTEXT;\n  public readonly relayUrl: ICore[\"relayUrl\"];\n  public readonly projectId: ICore[\"projectId\"];\n  public readonly customStoragePrefix: ICore[\"customStoragePrefix\"];\n  public events: ICore[\"events\"] = new EventEmitter();\n  public logger: ICore[\"logger\"];\n  public heartbeat: ICore[\"heartbeat\"];\n  public relayer: ICore[\"relayer\"];\n  public crypto: ICore[\"crypto\"];\n  public storage: ICore[\"storage\"];\n  public history: ICore[\"history\"];\n  public expirer: ICore[\"expirer\"];\n  public pairing: ICore[\"pairing\"];\n  public verify: ICore[\"verify\"];\n  public echoClient: ICore[\"echoClient\"];\n  public linkModeSupportedApps: ICore[\"linkModeSupportedApps\"];\n  public eventClient: ICore[\"eventClient\"];\n\n  private initialized = false;\n  private logChunkController: ChunkLoggerController | null;\n\n  static async init(opts?: CoreTypes.Options) {\n    const core = new Core(opts);\n    await core.initialize();\n    const clientId = await core.crypto.getClientId();\n    await core.storage.setItem(WALLETCONNECT_CLIENT_ID, clientId);\n\n    return core;\n  }\n\n  constructor(opts?: CoreTypes.Options) {\n    super(opts);\n\n    const globalCore = this.getGlobalCore(opts?.customStoragePrefix);\n    if (globalCore) {\n      try {\n        this.customStoragePrefix = globalCore.customStoragePrefix;\n        this.logger = globalCore.logger;\n        this.heartbeat = globalCore.heartbeat;\n        this.crypto = globalCore.crypto;\n        this.history = globalCore.history;\n        this.expirer = globalCore.expirer;\n        this.storage = globalCore.storage;\n        this.relayer = globalCore.relayer;\n        this.pairing = globalCore.pairing;\n        this.verify = globalCore.verify;\n        this.echoClient = globalCore.echoClient;\n        this.linkModeSupportedApps = globalCore.linkModeSupportedApps;\n        this.eventClient = globalCore.eventClient;\n        this.initialized = globalCore.initialized;\n        this.logChunkController = globalCore.logChunkController;\n        return globalCore;\n      } catch (error) {\n        console.warn(\"Failed to copy global core\", error);\n      }\n    }\n\n    this.projectId = opts?.projectId;\n    this.relayUrl = opts?.relayUrl || RELAYER_DEFAULT_RELAY_URL;\n    this.customStoragePrefix = opts?.customStoragePrefix ? `:${opts.customStoragePrefix}` : \"\";\n\n    const loggerOptions = getDefaultLoggerOptions({\n      level: typeof opts?.logger === \"string\" && opts.logger ? opts.logger : CORE_DEFAULT.logger,\n      name: CORE_CONTEXT,\n    });\n\n    const { logger, chunkLoggerController } = generatePlatformLogger({\n      opts: loggerOptions,\n      maxSizeInBytes: opts?.maxLogBlobSizeInBytes,\n      loggerOverride: opts?.logger,\n    });\n\n    this.logChunkController = chunkLoggerController;\n\n    if (this.logChunkController?.downloadLogsBlobInBrowser) {\n      // @ts-ignore\n      window.downloadLogsBlobInBrowser = async () => {\n        // Have to null check twice because there is no guarantee\n        // this.logChunkController.downloadLogsBlobInBrowser is always truthy\n        if (this.logChunkController?.downloadLogsBlobInBrowser) {\n          this.logChunkController?.downloadLogsBlobInBrowser({\n            clientId: await this.crypto.getClientId(),\n          });\n        }\n      };\n    }\n\n    this.logger = generateChildLogger(logger, this.name);\n    this.heartbeat = new HeartBeat();\n    this.crypto = new Crypto(this, this.logger, opts?.keychain);\n    this.history = new JsonRpcHistory(this, this.logger);\n    this.expirer = new Expirer(this, this.logger);\n    this.storage = opts?.storage\n      ? opts.storage\n      : new KeyValueStorage({ ...CORE_STORAGE_OPTIONS, ...opts?.storageOptions });\n    this.relayer = new Relayer({\n      core: this,\n      logger: this.logger,\n      relayUrl: this.relayUrl,\n      projectId: this.projectId,\n    });\n    this.pairing = new Pairing(this, this.logger);\n    this.verify = new Verify(this, this.logger, this.storage);\n    this.echoClient = new EchoClient(this.projectId || \"\", this.logger);\n    this.linkModeSupportedApps = [];\n    this.eventClient = new EventClient(this, this.logger, opts?.telemetryEnabled);\n    this.setGlobalCore(this);\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  // ---------- Public ----------------------------------------------- //\n\n  public async start() {\n    if (this.initialized) return;\n    await this.initialize();\n  }\n\n  public async getLogsBlob() {\n    return this.logChunkController?.logsToBlob({\n      clientId: await this.crypto.getClientId(),\n    });\n  }\n\n  public async addLinkModeSupportedApp(universalLink: string) {\n    if (this.linkModeSupportedApps.includes(universalLink)) return;\n    this.linkModeSupportedApps.push(universalLink);\n    await this.storage.setItem(WALLETCONNECT_LINK_MODE_APPS, this.linkModeSupportedApps);\n  }\n\n  // ---------- Events ----------------------------------------------- //\n\n  public on = (name: any, listener: any) => {\n    return this.events.on(name, listener);\n  };\n\n  public once = (name: any, listener: any) => {\n    return this.events.once(name, listener);\n  };\n\n  public off = (name: any, listener: any) => {\n    return this.events.off(name, listener);\n  };\n\n  public removeListener = (name: any, listener: any) => {\n    return this.events.removeListener(name, listener);\n  };\n\n  // ---------- Link-mode ----------------------------------------------- //\n\n  public dispatchEnvelope = ({\n    topic,\n    message,\n    sessionExists,\n  }: {\n    topic: string;\n    message: string;\n    sessionExists: boolean;\n  }) => {\n    if (!topic || !message) return;\n\n    const payload = {\n      topic,\n      message,\n      publishedAt: Date.now(),\n      transportType: TRANSPORT_TYPES.link_mode,\n    };\n\n    this.relayer.onLinkMessageEvent(payload, { sessionExists });\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    try {\n      await this.crypto.init();\n      await this.history.init();\n      await this.expirer.init();\n      await this.relayer.init();\n      await this.heartbeat.init();\n      await this.pairing.init();\n      this.linkModeSupportedApps = (await this.storage.getItem(WALLETCONNECT_LINK_MODE_APPS)) || [];\n\n      this.initialized = true;\n      this.logger.info(`Core Initialization Success`);\n    } catch (error) {\n      this.logger.warn(error, `Core Initialization Failure at epoch ${Date.now()}`);\n      this.logger.error((error as any).message);\n      throw error;\n    }\n  }\n\n  private getGlobalCore(customStoragePrefix = \"\"): Core | undefined {\n    try {\n      if (this.isGlobalCoreDisabled()) {\n        return undefined;\n      }\n      const globalCorePrefix = `_walletConnectCore_${customStoragePrefix}`;\n\n      const counterKey = `${globalCorePrefix}_count`;\n      globalThis[counterKey] = (globalThis[counterKey] || 0) + 1;\n      if (globalThis[counterKey] > 1) {\n        console.warn(\n          `WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[counterKey]} times.`,\n        );\n      }\n\n      return globalThis[globalCorePrefix];\n    } catch (error) {\n      console.warn(\"Failed to get global WalletConnect core\", error);\n      return undefined;\n    }\n  }\n\n  private setGlobalCore(core: Core) {\n    try {\n      if (this.isGlobalCoreDisabled()) {\n        return;\n      }\n      const customStoragePrefix = core.opts?.customStoragePrefix || \"\";\n      const globalCorePrefix = `_walletConnectCore_${customStoragePrefix}`;\n      globalThis[globalCorePrefix] = core;\n    } catch (error) {\n      console.warn(\"Failed to set global WalletConnect core\", error);\n    }\n  }\n\n  private isGlobalCoreDisabled() {\n    try {\n      return typeof process !== \"undefined\" && process.env.DISABLE_GLOBAL_CORE === \"true\";\n    } catch (error) {\n      return true;\n    }\n  }\n}\n","import { Core as WalletConnectCore } from \"./core.js\";\n\nexport * from \"./constants/index.js\";\nexport * from \"./controllers/index.js\";\n\nexport const Core = WalletConnectCore;\nexport default WalletConnectCore;\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU8Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedCreateAssociatedTokenIdempotentInstruction,\n  type ParsedCreateAssociatedTokenInstruction,\n  type ParsedRecoverNestedAssociatedTokenInstruction,\n} from '../instructions';\n\nexport const ASSOCIATED_TOKEN_PROGRAM_ADDRESS =\n  'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;\n\nexport enum AssociatedTokenInstruction {\n  CreateAssociatedToken,\n  CreateAssociatedTokenIdempotent,\n  RecoverNestedAssociatedToken,\n}\n\nexport function identifyAssociatedTokenInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): AssociatedTokenInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU8Encoder().encode(0), 0)) {\n    return AssociatedTokenInstruction.CreateAssociatedToken;\n  }\n  if (containsBytes(data, getU8Encoder().encode(1), 0)) {\n    return AssociatedTokenInstruction.CreateAssociatedTokenIdempotent;\n  }\n  if (containsBytes(data, getU8Encoder().encode(2), 0)) {\n    return AssociatedTokenInstruction.RecoverNestedAssociatedToken;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a associatedToken instruction.'\n  );\n}\n\nexport type ParsedAssociatedTokenInstruction<\n  TProgram extends string = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',\n> =\n  | ({\n      instructionType: AssociatedTokenInstruction.CreateAssociatedToken;\n    } & ParsedCreateAssociatedTokenInstruction<TProgram>)\n  | ({\n      instructionType: AssociatedTokenInstruction.CreateAssociatedTokenIdempotent;\n    } & ParsedCreateAssociatedTokenIdempotentInstruction<TProgram>)\n  | ({\n      instructionType: AssociatedTokenInstruction.RecoverNestedAssociatedToken;\n    } & ParsedRecoverNestedAssociatedTokenInstruction<TProgram>);\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU8Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedAmountToUiAmountInstruction,\n  type ParsedApplyConfidentialPendingBalanceInstruction,\n  type ParsedApproveCheckedInstruction,\n  type ParsedApproveConfidentialTransferAccountInstruction,\n  type ParsedApproveInstruction,\n  type ParsedBurnCheckedInstruction,\n  type ParsedBurnInstruction,\n  type ParsedCloseAccountInstruction,\n  type ParsedConfidentialDepositInstruction,\n  type ParsedConfidentialTransferInstruction,\n  type ParsedConfidentialTransferWithFeeInstruction,\n  type ParsedConfidentialWithdrawInstruction,\n  type ParsedConfigureConfidentialTransferAccountInstruction,\n  type ParsedCreateNativeMintInstruction,\n  type ParsedDisableConfidentialCreditsInstruction,\n  type ParsedDisableCpiGuardInstruction,\n  type ParsedDisableHarvestToMintInstruction,\n  type ParsedDisableMemoTransfersInstruction,\n  type ParsedDisableNonConfidentialCreditsInstruction,\n  type ParsedEmitTokenMetadataInstruction,\n  type ParsedEmptyConfidentialTransferAccountInstruction,\n  type ParsedEnableConfidentialCreditsInstruction,\n  type ParsedEnableCpiGuardInstruction,\n  type ParsedEnableHarvestToMintInstruction,\n  type ParsedEnableMemoTransfersInstruction,\n  type ParsedEnableNonConfidentialCreditsInstruction,\n  type ParsedFreezeAccountInstruction,\n  type ParsedGetAccountDataSizeInstruction,\n  type ParsedHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction,\n  type ParsedHarvestWithheldTokensToMintInstruction,\n  type ParsedInitializeAccount2Instruction,\n  type ParsedInitializeAccount3Instruction,\n  type ParsedInitializeAccountInstruction,\n  type ParsedInitializeConfidentialTransferFeeInstruction,\n  type ParsedInitializeConfidentialTransferMintInstruction,\n  type ParsedInitializeDefaultAccountStateInstruction,\n  type ParsedInitializeGroupMemberPointerInstruction,\n  type ParsedInitializeGroupPointerInstruction,\n  type ParsedInitializeImmutableOwnerInstruction,\n  type ParsedInitializeInterestBearingMintInstruction,\n  type ParsedInitializeMetadataPointerInstruction,\n  type ParsedInitializeMint2Instruction,\n  type ParsedInitializeMintCloseAuthorityInstruction,\n  type ParsedInitializeMintInstruction,\n  type ParsedInitializeMultisig2Instruction,\n  type ParsedInitializeMultisigInstruction,\n  type ParsedInitializeNonTransferableMintInstruction,\n  type ParsedInitializePausableConfigInstruction,\n  type ParsedInitializePermanentDelegateInstruction,\n  type ParsedInitializeScaledUiAmountMintInstruction,\n  type ParsedInitializeTokenGroupInstruction,\n  type ParsedInitializeTokenGroupMemberInstruction,\n  type ParsedInitializeTokenMetadataInstruction,\n  type ParsedInitializeTransferFeeConfigInstruction,\n  type ParsedInitializeTransferHookInstruction,\n  type ParsedMintToCheckedInstruction,\n  type ParsedMintToInstruction,\n  type ParsedPauseInstruction,\n  type ParsedReallocateInstruction,\n  type ParsedRemoveTokenMetadataKeyInstruction,\n  type ParsedResumeInstruction,\n  type ParsedRevokeInstruction,\n  type ParsedSetAuthorityInstruction,\n  type ParsedSetTransferFeeInstruction,\n  type ParsedSyncNativeInstruction,\n  type ParsedThawAccountInstruction,\n  type ParsedTransferCheckedInstruction,\n  type ParsedTransferCheckedWithFeeInstruction,\n  type ParsedTransferInstruction,\n  type ParsedUiAmountToAmountInstruction,\n  type ParsedUpdateConfidentialTransferMintInstruction,\n  type ParsedUpdateDefaultAccountStateInstruction,\n  type ParsedUpdateGroupMemberPointerInstruction,\n  type ParsedUpdateGroupPointerInstruction,\n  type ParsedUpdateMetadataPointerInstruction,\n  type ParsedUpdateMultiplierScaledUiMintInstruction,\n  type ParsedUpdateRateInterestBearingMintInstruction,\n  type ParsedUpdateTokenGroupMaxSizeInstruction,\n  type ParsedUpdateTokenGroupUpdateAuthorityInstruction,\n  type ParsedUpdateTokenMetadataFieldInstruction,\n  type ParsedUpdateTokenMetadataUpdateAuthorityInstruction,\n  type ParsedUpdateTransferHookInstruction,\n  type ParsedWithdrawExcessLamportsInstruction,\n  type ParsedWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction,\n  type ParsedWithdrawWithheldTokensFromAccountsInstruction,\n  type ParsedWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction,\n  type ParsedWithdrawWithheldTokensFromMintInstruction,\n} from '../instructions';\n\nexport const TOKEN_2022_PROGRAM_ADDRESS =\n  'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n\nexport enum Token2022Account {\n  Mint,\n  Token,\n  Multisig,\n}\n\nexport function identifyToken2022Account(\n  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): Token2022Account {\n  const data = 'data' in account ? account.data : account;\n  if (data.length === 82) {\n    return Token2022Account.Mint;\n  }\n  if (data.length === 165) {\n    return Token2022Account.Token;\n  }\n  if (data.length === 355) {\n    return Token2022Account.Multisig;\n  }\n  throw new Error(\n    'The provided account could not be identified as a token-2022 account.'\n  );\n}\n\nexport enum Token2022Instruction {\n  InitializeMint,\n  InitializeAccount,\n  InitializeMultisig,\n  Transfer,\n  Approve,\n  Revoke,\n  SetAuthority,\n  MintTo,\n  Burn,\n  CloseAccount,\n  FreezeAccount,\n  ThawAccount,\n  TransferChecked,\n  ApproveChecked,\n  MintToChecked,\n  BurnChecked,\n  InitializeAccount2,\n  SyncNative,\n  InitializeAccount3,\n  InitializeMultisig2,\n  InitializeMint2,\n  GetAccountDataSize,\n  InitializeImmutableOwner,\n  AmountToUiAmount,\n  UiAmountToAmount,\n  InitializeMintCloseAuthority,\n  InitializeTransferFeeConfig,\n  TransferCheckedWithFee,\n  WithdrawWithheldTokensFromMint,\n  WithdrawWithheldTokensFromAccounts,\n  HarvestWithheldTokensToMint,\n  SetTransferFee,\n  InitializeConfidentialTransferMint,\n  UpdateConfidentialTransferMint,\n  ConfigureConfidentialTransferAccount,\n  ApproveConfidentialTransferAccount,\n  EmptyConfidentialTransferAccount,\n  ConfidentialDeposit,\n  ConfidentialWithdraw,\n  ConfidentialTransfer,\n  ApplyConfidentialPendingBalance,\n  EnableConfidentialCredits,\n  DisableConfidentialCredits,\n  EnableNonConfidentialCredits,\n  DisableNonConfidentialCredits,\n  ConfidentialTransferWithFee,\n  InitializeDefaultAccountState,\n  UpdateDefaultAccountState,\n  Reallocate,\n  EnableMemoTransfers,\n  DisableMemoTransfers,\n  CreateNativeMint,\n  InitializeNonTransferableMint,\n  InitializeInterestBearingMint,\n  UpdateRateInterestBearingMint,\n  EnableCpiGuard,\n  DisableCpiGuard,\n  InitializePermanentDelegate,\n  InitializeTransferHook,\n  UpdateTransferHook,\n  InitializeConfidentialTransferFee,\n  WithdrawWithheldTokensFromMintForConfidentialTransferFee,\n  WithdrawWithheldTokensFromAccountsForConfidentialTransferFee,\n  HarvestWithheldTokensToMintForConfidentialTransferFee,\n  EnableHarvestToMint,\n  DisableHarvestToMint,\n  WithdrawExcessLamports,\n  InitializeMetadataPointer,\n  UpdateMetadataPointer,\n  InitializeGroupPointer,\n  UpdateGroupPointer,\n  InitializeGroupMemberPointer,\n  UpdateGroupMemberPointer,\n  InitializeScaledUiAmountMint,\n  UpdateMultiplierScaledUiMint,\n  InitializePausableConfig,\n  Pause,\n  Resume,\n  InitializeTokenMetadata,\n  UpdateTokenMetadataField,\n  RemoveTokenMetadataKey,\n  UpdateTokenMetadataUpdateAuthority,\n  EmitTokenMetadata,\n  InitializeTokenGroup,\n  UpdateTokenGroupMaxSize,\n  UpdateTokenGroupUpdateAuthority,\n  InitializeTokenGroupMember,\n}\n\nexport function identifyToken2022Instruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): Token2022Instruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU8Encoder().encode(0), 0)) {\n    return Token2022Instruction.InitializeMint;\n  }\n  if (containsBytes(data, getU8Encoder().encode(1), 0)) {\n    return Token2022Instruction.InitializeAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(2), 0)) {\n    return Token2022Instruction.InitializeMultisig;\n  }\n  if (containsBytes(data, getU8Encoder().encode(3), 0)) {\n    return Token2022Instruction.Transfer;\n  }\n  if (containsBytes(data, getU8Encoder().encode(4), 0)) {\n    return Token2022Instruction.Approve;\n  }\n  if (containsBytes(data, getU8Encoder().encode(5), 0)) {\n    return Token2022Instruction.Revoke;\n  }\n  if (containsBytes(data, getU8Encoder().encode(6), 0)) {\n    return Token2022Instruction.SetAuthority;\n  }\n  if (containsBytes(data, getU8Encoder().encode(7), 0)) {\n    return Token2022Instruction.MintTo;\n  }\n  if (containsBytes(data, getU8Encoder().encode(8), 0)) {\n    return Token2022Instruction.Burn;\n  }\n  if (containsBytes(data, getU8Encoder().encode(9), 0)) {\n    return Token2022Instruction.CloseAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(10), 0)) {\n    return Token2022Instruction.FreezeAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(11), 0)) {\n    return Token2022Instruction.ThawAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(12), 0)) {\n    return Token2022Instruction.TransferChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(13), 0)) {\n    return Token2022Instruction.ApproveChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(14), 0)) {\n    return Token2022Instruction.MintToChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(15), 0)) {\n    return Token2022Instruction.BurnChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(16), 0)) {\n    return Token2022Instruction.InitializeAccount2;\n  }\n  if (containsBytes(data, getU8Encoder().encode(17), 0)) {\n    return Token2022Instruction.SyncNative;\n  }\n  if (containsBytes(data, getU8Encoder().encode(18), 0)) {\n    return Token2022Instruction.InitializeAccount3;\n  }\n  if (containsBytes(data, getU8Encoder().encode(19), 0)) {\n    return Token2022Instruction.InitializeMultisig2;\n  }\n  if (containsBytes(data, getU8Encoder().encode(20), 0)) {\n    return Token2022Instruction.InitializeMint2;\n  }\n  if (containsBytes(data, getU8Encoder().encode(21), 0)) {\n    return Token2022Instruction.GetAccountDataSize;\n  }\n  if (containsBytes(data, getU8Encoder().encode(22), 0)) {\n    return Token2022Instruction.InitializeImmutableOwner;\n  }\n  if (containsBytes(data, getU8Encoder().encode(23), 0)) {\n    return Token2022Instruction.AmountToUiAmount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(24), 0)) {\n    return Token2022Instruction.UiAmountToAmount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(25), 0)) {\n    return Token2022Instruction.InitializeMintCloseAuthority;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeTransferFeeConfig;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.TransferCheckedWithFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(2), 1)\n  ) {\n    return Token2022Instruction.WithdrawWithheldTokensFromMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(3), 1)\n  ) {\n    return Token2022Instruction.WithdrawWithheldTokensFromAccounts;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(4), 1)\n  ) {\n    return Token2022Instruction.HarvestWithheldTokensToMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(5), 1)\n  ) {\n    return Token2022Instruction.SetTransferFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeConfidentialTransferMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateConfidentialTransferMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(2), 1)\n  ) {\n    return Token2022Instruction.ConfigureConfidentialTransferAccount;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(3), 1)\n  ) {\n    return Token2022Instruction.ApproveConfidentialTransferAccount;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(4), 1)\n  ) {\n    return Token2022Instruction.EmptyConfidentialTransferAccount;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(5), 1)\n  ) {\n    return Token2022Instruction.ConfidentialDeposit;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(6), 1)\n  ) {\n    return Token2022Instruction.ConfidentialWithdraw;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(7), 1)\n  ) {\n    return Token2022Instruction.ConfidentialTransfer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(8), 1)\n  ) {\n    return Token2022Instruction.ApplyConfidentialPendingBalance;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(9), 1)\n  ) {\n    return Token2022Instruction.EnableConfidentialCredits;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(10), 1)\n  ) {\n    return Token2022Instruction.DisableConfidentialCredits;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(11), 1)\n  ) {\n    return Token2022Instruction.EnableNonConfidentialCredits;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(12), 1)\n  ) {\n    return Token2022Instruction.DisableNonConfidentialCredits;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(13), 1)\n  ) {\n    return Token2022Instruction.ConfidentialTransferWithFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(28), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeDefaultAccountState;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(28), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateDefaultAccountState;\n  }\n  if (containsBytes(data, getU8Encoder().encode(29), 0)) {\n    return Token2022Instruction.Reallocate;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(30), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.EnableMemoTransfers;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(30), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.DisableMemoTransfers;\n  }\n  if (containsBytes(data, getU8Encoder().encode(31), 0)) {\n    return Token2022Instruction.CreateNativeMint;\n  }\n  if (containsBytes(data, getU8Encoder().encode(32), 0)) {\n    return Token2022Instruction.InitializeNonTransferableMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(33), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeInterestBearingMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(33), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateRateInterestBearingMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(34), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.EnableCpiGuard;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(34), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.DisableCpiGuard;\n  }\n  if (containsBytes(data, getU8Encoder().encode(35), 0)) {\n    return Token2022Instruction.InitializePermanentDelegate;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(36), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeTransferHook;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(36), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateTransferHook;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeConfidentialTransferFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.WithdrawWithheldTokensFromMintForConfidentialTransferFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(2), 1)\n  ) {\n    return Token2022Instruction.WithdrawWithheldTokensFromAccountsForConfidentialTransferFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(3), 1)\n  ) {\n    return Token2022Instruction.HarvestWithheldTokensToMintForConfidentialTransferFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(4), 1)\n  ) {\n    return Token2022Instruction.EnableHarvestToMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(5), 1)\n  ) {\n    return Token2022Instruction.DisableHarvestToMint;\n  }\n  if (containsBytes(data, getU8Encoder().encode(38), 0)) {\n    return Token2022Instruction.WithdrawExcessLamports;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(39), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeMetadataPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(39), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateMetadataPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(40), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeGroupPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(40), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateGroupPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(41), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeGroupMemberPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(41), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateGroupMemberPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(43), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeScaledUiAmountMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(43), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateMultiplierScaledUiMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(44), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializePausableConfig;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(44), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.Pause;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(44), 0) &&\n    containsBytes(data, getU8Encoder().encode(2), 1)\n  ) {\n    return Token2022Instruction.Resume;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([210, 225, 30, 162, 88, 184, 77, 141]),\n      0\n    )\n  ) {\n    return Token2022Instruction.InitializeTokenMetadata;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([221, 233, 49, 45, 181, 202, 220, 200]),\n      0\n    )\n  ) {\n    return Token2022Instruction.UpdateTokenMetadataField;\n  }\n  if (\n    containsBytes(data, new Uint8Array([234, 18, 32, 56, 89, 141, 37, 181]), 0)\n  ) {\n    return Token2022Instruction.RemoveTokenMetadataKey;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([215, 228, 166, 228, 84, 100, 86, 123]),\n      0\n    )\n  ) {\n    return Token2022Instruction.UpdateTokenMetadataUpdateAuthority;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([250, 166, 180, 250, 13, 12, 184, 70]),\n      0\n    )\n  ) {\n    return Token2022Instruction.EmitTokenMetadata;\n  }\n  if (\n    containsBytes(data, new Uint8Array([121, 113, 108, 39, 54, 51, 0, 4]), 0)\n  ) {\n    return Token2022Instruction.InitializeTokenGroup;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([108, 37, 171, 143, 248, 30, 18, 110]),\n      0\n    )\n  ) {\n    return Token2022Instruction.UpdateTokenGroupMaxSize;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([161, 105, 88, 1, 237, 221, 216, 203]),\n      0\n    )\n  ) {\n    return Token2022Instruction.UpdateTokenGroupUpdateAuthority;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([152, 32, 222, 176, 223, 237, 116, 134]),\n      0\n    )\n  ) {\n    return Token2022Instruction.InitializeTokenGroupMember;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a token-2022 instruction.'\n  );\n}\n\nexport type ParsedToken2022Instruction<\n  TProgram extends string = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',\n> =\n  | ({\n      instructionType: Token2022Instruction.InitializeMint;\n    } & ParsedInitializeMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeAccount;\n    } & ParsedInitializeAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeMultisig;\n    } & ParsedInitializeMultisigInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Transfer;\n    } & ParsedTransferInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Approve;\n    } & ParsedApproveInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Revoke;\n    } & ParsedRevokeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.SetAuthority;\n    } & ParsedSetAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.MintTo;\n    } & ParsedMintToInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Burn;\n    } & ParsedBurnInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.CloseAccount;\n    } & ParsedCloseAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.FreezeAccount;\n    } & ParsedFreezeAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ThawAccount;\n    } & ParsedThawAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.TransferChecked;\n    } & ParsedTransferCheckedInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ApproveChecked;\n    } & ParsedApproveCheckedInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.MintToChecked;\n    } & ParsedMintToCheckedInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.BurnChecked;\n    } & ParsedBurnCheckedInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeAccount2;\n    } & ParsedInitializeAccount2Instruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.SyncNative;\n    } & ParsedSyncNativeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeAccount3;\n    } & ParsedInitializeAccount3Instruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeMultisig2;\n    } & ParsedInitializeMultisig2Instruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeMint2;\n    } & ParsedInitializeMint2Instruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.GetAccountDataSize;\n    } & ParsedGetAccountDataSizeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeImmutableOwner;\n    } & ParsedInitializeImmutableOwnerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.AmountToUiAmount;\n    } & ParsedAmountToUiAmountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UiAmountToAmount;\n    } & ParsedUiAmountToAmountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeMintCloseAuthority;\n    } & ParsedInitializeMintCloseAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeTransferFeeConfig;\n    } & ParsedInitializeTransferFeeConfigInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.TransferCheckedWithFee;\n    } & ParsedTransferCheckedWithFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.WithdrawWithheldTokensFromMint;\n    } & ParsedWithdrawWithheldTokensFromMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.WithdrawWithheldTokensFromAccounts;\n    } & ParsedWithdrawWithheldTokensFromAccountsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.HarvestWithheldTokensToMint;\n    } & ParsedHarvestWithheldTokensToMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.SetTransferFee;\n    } & ParsedSetTransferFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeConfidentialTransferMint;\n    } & ParsedInitializeConfidentialTransferMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateConfidentialTransferMint;\n    } & ParsedUpdateConfidentialTransferMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ConfigureConfidentialTransferAccount;\n    } & ParsedConfigureConfidentialTransferAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ApproveConfidentialTransferAccount;\n    } & ParsedApproveConfidentialTransferAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EmptyConfidentialTransferAccount;\n    } & ParsedEmptyConfidentialTransferAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ConfidentialDeposit;\n    } & ParsedConfidentialDepositInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ConfidentialWithdraw;\n    } & ParsedConfidentialWithdrawInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ConfidentialTransfer;\n    } & ParsedConfidentialTransferInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ApplyConfidentialPendingBalance;\n    } & ParsedApplyConfidentialPendingBalanceInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EnableConfidentialCredits;\n    } & ParsedEnableConfidentialCreditsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.DisableConfidentialCredits;\n    } & ParsedDisableConfidentialCreditsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EnableNonConfidentialCredits;\n    } & ParsedEnableNonConfidentialCreditsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.DisableNonConfidentialCredits;\n    } & ParsedDisableNonConfidentialCreditsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ConfidentialTransferWithFee;\n    } & ParsedConfidentialTransferWithFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeDefaultAccountState;\n    } & ParsedInitializeDefaultAccountStateInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateDefaultAccountState;\n    } & ParsedUpdateDefaultAccountStateInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Reallocate;\n    } & ParsedReallocateInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EnableMemoTransfers;\n    } & ParsedEnableMemoTransfersInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.DisableMemoTransfers;\n    } & ParsedDisableMemoTransfersInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.CreateNativeMint;\n    } & ParsedCreateNativeMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeNonTransferableMint;\n    } & ParsedInitializeNonTransferableMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeInterestBearingMint;\n    } & ParsedInitializeInterestBearingMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateRateInterestBearingMint;\n    } & ParsedUpdateRateInterestBearingMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EnableCpiGuard;\n    } & ParsedEnableCpiGuardInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.DisableCpiGuard;\n    } & ParsedDisableCpiGuardInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializePermanentDelegate;\n    } & ParsedInitializePermanentDelegateInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeTransferHook;\n    } & ParsedInitializeTransferHookInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateTransferHook;\n    } & ParsedUpdateTransferHookInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeConfidentialTransferFee;\n    } & ParsedInitializeConfidentialTransferFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.WithdrawWithheldTokensFromMintForConfidentialTransferFee;\n    } & ParsedWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.WithdrawWithheldTokensFromAccountsForConfidentialTransferFee;\n    } & ParsedWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.HarvestWithheldTokensToMintForConfidentialTransferFee;\n    } & ParsedHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EnableHarvestToMint;\n    } & ParsedEnableHarvestToMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.DisableHarvestToMint;\n    } & ParsedDisableHarvestToMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.WithdrawExcessLamports;\n    } & ParsedWithdrawExcessLamportsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeMetadataPointer;\n    } & ParsedInitializeMetadataPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateMetadataPointer;\n    } & ParsedUpdateMetadataPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeGroupPointer;\n    } & ParsedInitializeGroupPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateGroupPointer;\n    } & ParsedUpdateGroupPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeGroupMemberPointer;\n    } & ParsedInitializeGroupMemberPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateGroupMemberPointer;\n    } & ParsedUpdateGroupMemberPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeScaledUiAmountMint;\n    } & ParsedInitializeScaledUiAmountMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateMultiplierScaledUiMint;\n    } & ParsedUpdateMultiplierScaledUiMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializePausableConfig;\n    } & ParsedInitializePausableConfigInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Pause;\n    } & ParsedPauseInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Resume;\n    } & ParsedResumeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeTokenMetadata;\n    } & ParsedInitializeTokenMetadataInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateTokenMetadataField;\n    } & ParsedUpdateTokenMetadataFieldInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.RemoveTokenMetadataKey;\n    } & ParsedRemoveTokenMetadataKeyInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateTokenMetadataUpdateAuthority;\n    } & ParsedUpdateTokenMetadataUpdateAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EmitTokenMetadata;\n    } & ParsedEmitTokenMetadataInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeTokenGroup;\n    } & ParsedInitializeTokenGroupInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateTokenGroupMaxSize;\n    } & ParsedUpdateTokenGroupMaxSizeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateTokenGroupUpdateAuthority;\n    } & ParsedUpdateTokenGroupUpdateAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeTokenGroupMember;\n    } & ParsedInitializeTokenGroupMemberInstruction<TProgram>);\n","import { keccak_256 } from \"@noble/hashes/sha3\";\nimport { Secp256k1, Signature } from \"ox\";\nimport { sha256, sha512_256 } from \"@noble/hashes/sha2\";\nimport bs58 from \"bs58\";\nimport { blake2b } from \"@noble/hashes/blake2\";\nimport { encode as msgpackEncode, decode as msgpackDecode } from \"@msgpack/msgpack\";\nimport { base32 } from \"@scure/base\";\nimport { AuthTypes } from \"@walletconnect/types\";\n\nimport { parseChainId } from \"./caip.js\";\n\nconst DEFAULT_RPC_URL = \"https://rpc.walletconnect.org/v1\";\n\nexport function hashEthereumMessage(message: string) {\n  const prefix = `\\x19Ethereum Signed Message:\\n${message.length}`;\n  const prefixedMessage = new TextEncoder().encode(prefix + message);\n  return \"0x\" + Buffer.from(keccak_256(prefixedMessage)).toString(\"hex\");\n}\n\nexport async function verifySignature(\n  address: string,\n  reconstructedMessage: string,\n  cacaoSignature: AuthTypes.CacaoSignature,\n  chainId: string,\n  projectId: string,\n  baseRpcUrl?: string,\n): Promise<boolean> {\n  // Determine if this signature is from an EOA or a contract.\n  switch (cacaoSignature.t) {\n    case \"eip191\":\n      return await isValidEip191Signature(address, reconstructedMessage, cacaoSignature.s);\n    case \"eip1271\":\n      return await isValidEip1271Signature(\n        address,\n        reconstructedMessage,\n        cacaoSignature.s,\n        chainId,\n        projectId,\n        baseRpcUrl,\n      );\n      break;\n    default:\n      throw new Error(\n        `verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${cacaoSignature.t}`,\n      );\n  }\n}\n\nexport function isValidEip191Signature(\n  address: string,\n  message: string,\n  signature: string,\n): boolean {\n  const parsedSignature = Signature.fromHex(signature as `0x${string}`);\n  const recoveredAddress = Secp256k1.recoverAddress({\n    payload: hashEthereumMessage(message) as `0x${string}`,\n    signature: parsedSignature,\n  });\n  return recoveredAddress.toLowerCase() === address.toLowerCase();\n}\n\nexport async function isValidEip1271Signature(\n  address: string,\n  reconstructedMessage: string,\n  signature: string,\n  chainId: string,\n  projectId: string,\n  baseRpcUrl?: string,\n) {\n  const parsedChain = parseChainId(chainId);\n  if (!parsedChain.namespace || !parsedChain.reference) {\n    throw new Error(\n      `isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${chainId}`,\n    );\n  }\n  try {\n    const eip1271MagicValue = \"0x1626ba7e\";\n    const dynamicTypeOffset = \"0000000000000000000000000000000000000000000000000000000000000040\";\n    const nonPrefixedSignature = signature.substring(2);\n    const dynamicTypeLength = (nonPrefixedSignature.length / 2).toString(16).padStart(64, \"0\");\n    const nonPrefixedHashedMessage = (\n      reconstructedMessage.startsWith(\"0x\")\n        ? reconstructedMessage\n        : hashEthereumMessage(reconstructedMessage)\n    ).substring(2);\n    const data =\n      eip1271MagicValue +\n      nonPrefixedHashedMessage +\n      dynamicTypeOffset +\n      dynamicTypeLength +\n      nonPrefixedSignature;\n    const response = await fetch(\n      `${baseRpcUrl || DEFAULT_RPC_URL}/?chainId=${chainId}&projectId=${projectId}`,\n      {\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        method: \"POST\",\n        body: JSON.stringify({\n          id: generateJsonRpcId(),\n          jsonrpc: \"2.0\",\n          method: \"eth_call\",\n          params: [{ to: address, data }, \"latest\"],\n        }),\n      },\n    );\n    const { result } = await response.json();\n    if (!result) return false;\n\n    // Remove right-padded zeros from result to get only the concrete recovered value.\n    const recoveredValue = result.slice(0, eip1271MagicValue.length);\n    return recoveredValue.toLowerCase() === eip1271MagicValue.toLowerCase();\n  } catch (error: any) {\n    // eslint-disable-next-line no-console\n    console.error(\"isValidEip1271Signature: \", error);\n    return false;\n  }\n}\n\nfunction generateJsonRpcId() {\n  return Date.now() + Math.floor(Math.random() * 1000);\n}\n\nexport function extractSolanaTransactionId(solanaTransaction: string): string {\n  const binary = atob(solanaTransaction);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n\n  // Check signature count (first byte)\n  const signatureCount = bytes[0];\n  if (signatureCount === 0) {\n    throw new Error(\"No signatures found\");\n  }\n\n  // Verify we have enough bytes for all signatures\n  // Each signature is 64 bytes\n  const signatureEndPos = 1 + signatureCount * 64;\n  if (bytes.length < signatureEndPos) {\n    throw new Error(\"Transaction data too short for claimed signature count\");\n  }\n\n  // A transaction must have at least some minimum length\n  if (bytes.length < 100) {\n    throw new Error(\"Transaction too short\");\n  }\n\n  const transactionBuffer = Buffer.from(solanaTransaction, \"base64\");\n\n  const signatureBuffer = transactionBuffer.slice(1, 65);\n\n  return bs58.encode(signatureBuffer);\n}\n\nexport function getSuiDigest(transaction: string) {\n  const txBytes = new Uint8Array(Buffer.from(transaction, \"base64\"));\n\n  const typeTagBytes = Array.from(`TransactionData::`).map((e) => e.charCodeAt(0));\n\n  const dataWithTag = new Uint8Array(typeTagBytes.length + txBytes.length);\n\n  dataWithTag.set(typeTagBytes);\n  dataWithTag.set(txBytes, typeTagBytes.length);\n\n  const hash = blake2b(dataWithTag, { dkLen: 32 });\n\n  return bs58.encode(hash);\n}\n\nexport function getNearTransactionIdFromSignedTransaction(signedTransaction: unknown) {\n  const hash = new Uint8Array(sha256(getNearUint8ArrayFromBytes(signedTransaction)));\n  const hashBase58 = bs58.encode(hash);\n  return hashBase58;\n}\n\nexport function getNearUint8ArrayFromBytes(bytes: unknown) {\n  if (bytes instanceof Uint8Array) {\n    return bytes;\n  } else if (Array.isArray(bytes)) {\n    return new Uint8Array(bytes);\n  } else if (typeof bytes === \"object\" && (bytes as any)?.data) {\n    return new Uint8Array(Object.values((bytes as any).data));\n  } else if (typeof bytes === \"object\" && bytes) {\n    return new Uint8Array(Object.values(bytes));\n  } else {\n    throw new Error(\"getNearUint8ArrayFromBytes: Unexpected result type from bytes array\");\n  }\n}\n\nexport function getAlgorandTransactionId(transaction: string) {\n  const signedTxnBytes = Buffer.from(transaction, \"base64\");\n\n  const decoded = msgpackDecode(signedTxnBytes) as any;\n\n  const unsignedTxn = decoded.txn;\n  if (!unsignedTxn) {\n    throw new Error(\"Invalid signed transaction: missing 'txn' field\");\n  }\n\n  const serializedUnsignedTxn = msgpackEncode(unsignedTxn);\n\n  // Prepend \"TX\" prefix\n  const txPrefix = Buffer.from(\"TX\");\n  const toHash = Buffer.concat([txPrefix, Buffer.from(serializedUnsignedTxn)]);\n\n  const hash = sha512_256(toHash);\n\n  // Encode to base32 and remove padding\n  return base32.encode(hash).replace(/=+$/, \"\");\n}\n\nfunction encodeVarint(value: number | bigint): Buffer {\n  const result: number[] = [];\n  let v = BigInt(value);\n  while (v >= 0x80n) {\n    result.push(Number((v & 0x7fn) | 0x80n));\n    v >>= 7n;\n  }\n  result.push(Number(v));\n  return Buffer.from(result);\n}\n\nexport function getSignDirectHash(payload: {\n  signed: {\n    chainId: string;\n    accountNumber: string;\n    authInfoBytes: string;\n    bodyBytes: string;\n  };\n  signature: {\n    pub_key: {\n      type: string;\n      value: string;\n    };\n    signature: string;\n  };\n}) {\n  const bodyBytes = Buffer.from(payload.signed.bodyBytes, \"base64\");\n  const authInfoBytes = Buffer.from(payload.signed.authInfoBytes, \"base64\");\n  const signature = Buffer.from(payload.signature.signature, \"base64\");\n\n  const chunks: Buffer[] = [];\n\n  chunks.push(Buffer.from([0x0a]));\n  chunks.push(encodeVarint(bodyBytes.length));\n  chunks.push(bodyBytes);\n\n  chunks.push(Buffer.from([0x12]));\n  chunks.push(encodeVarint(authInfoBytes.length));\n  chunks.push(authInfoBytes);\n\n  chunks.push(Buffer.from([0x1a]));\n  chunks.push(encodeVarint(signature.length));\n  chunks.push(signature);\n\n  const txRawBytes = Buffer.concat(chunks);\n  const hashBytes = sha256(txRawBytes);\n\n  return Buffer.from(hashBytes).toString(\"hex\").toUpperCase();\n}\n\nexport function getWalletSendCallsHashes(\n  result: string | { id: string; capabilities: { caip345: { transactionHashes: string[] } } },\n) {\n  const hashes: string[] = [];\n  try {\n    if (typeof result === \"string\") {\n      hashes.push(result);\n      return hashes;\n    }\n\n    if (typeof result !== \"object\") {\n      return hashes;\n    }\n\n    if (result?.id) {\n      hashes.push(result.id);\n    }\n\n    const txHashes = result?.capabilities?.caip345?.transactionHashes;\n\n    if (txHashes) {\n      hashes.push(...txHashes);\n    }\n  } catch (error) {\n    console.warn(\"getWalletSendCallsHashes failed: \", error);\n  }\n\n  return hashes;\n}\n","import { AuthTypes } from \"@walletconnect/types\";\nimport { getCommonValuesInArrays } from \"./misc.js\";\nimport { verifySignature } from \"./signatures.js\";\nconst didPrefix = \"did:pkh:\";\nexport const getDidAddressSegments = (iss: string) => {\n  return iss?.split(\":\");\n};\n\nexport const getDidChainId = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return iss.includes(didPrefix) ? segments[3] : segments[1];\n  }\n  return undefined;\n};\n\nexport const getNamespacedDidChainId = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments[2] + \":\" + segments[3];\n  }\n  return undefined;\n};\n\nexport const getDidAddress = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments.pop();\n  }\n  return undefined;\n};\n\nexport async function validateSignedCacao(params: { cacao: AuthTypes.Cacao; projectId?: string }) {\n  const { cacao, projectId } = params;\n  const { s: signature, p: payload } = cacao;\n  const reconstructed = formatMessage(payload, payload.iss);\n  const walletAddress = getDidAddress(payload.iss) as string;\n  const isValid = await verifySignature(\n    walletAddress,\n    reconstructed,\n    signature,\n    getNamespacedDidChainId(payload.iss) as string,\n    projectId as string,\n  );\n\n  return isValid;\n}\n\nexport const formatMessage = (cacao: AuthTypes.FormatMessageParams, iss: string) => {\n  const header = `${cacao.domain} wants you to sign in with your Ethereum account:`;\n  const walletAddress = getDidAddress(iss);\n\n  if (!cacao.aud && !cacao.uri) {\n    throw new Error(\"Either `aud` or `uri` is required to construct the message\");\n  }\n\n  let statement = cacao.statement || undefined;\n  const uri = `URI: ${cacao.aud || cacao.uri}`;\n  const version = `Version: ${cacao.version}`;\n  const chainId = `Chain ID: ${getDidChainId(iss)}`;\n  const nonce = `Nonce: ${cacao.nonce}`;\n  const issuedAt = `Issued At: ${cacao.iat}`;\n  const expirationTime = cacao.exp ? `Expiration Time: ${cacao.exp}` : undefined;\n  const notBefore = cacao.nbf ? `Not Before: ${cacao.nbf}` : undefined;\n  const requestId = cacao.requestId ? `Request ID: ${cacao.requestId}` : undefined;\n  const resources = cacao.resources\n    ? `Resources:${cacao.resources.map((resource) => `\\n- ${resource}`).join(\"\")}`\n    : undefined;\n  const recap = getRecapFromResources(cacao.resources);\n  if (recap) {\n    const decoded = decodeRecap(recap);\n    statement = formatStatementFromRecap(statement, decoded);\n  }\n\n  const message = [\n    header,\n    walletAddress,\n    ``,\n    statement,\n    ``,\n    uri,\n    version,\n    chainId,\n    nonce,\n    issuedAt,\n    expirationTime,\n    notBefore,\n    requestId,\n    resources,\n  ]\n    .filter((val) => val !== undefined && val !== null) // remove unnecessary empty lines\n    .join(\"\\n\");\n\n  return message;\n};\n\nexport function buildAuthObject(\n  requestPayload: AuthTypes.PayloadParams,\n  signature: AuthTypes.CacaoSignature,\n  iss: string,\n) {\n  if (!iss.includes(\"did:pkh:\")) {\n    iss = `did:pkh:${iss}`;\n  }\n\n  const authObject: AuthTypes.Cacao = {\n    h: {\n      t: \"caip122\",\n    },\n    p: {\n      iss,\n      domain: requestPayload.domain,\n      aud: requestPayload.aud,\n      version: requestPayload.version,\n      nonce: requestPayload.nonce,\n      iat: requestPayload.iat,\n      statement: requestPayload.statement,\n      requestId: requestPayload.requestId,\n      resources: requestPayload.resources,\n      nbf: requestPayload.nbf,\n      exp: requestPayload.exp,\n    },\n    s: signature,\n  };\n  return authObject;\n}\ntype PopulateAuthPayloadParams = {\n  authPayload: AuthTypes.PayloadParams;\n  chains: string[];\n  methods: string[];\n};\nexport function populateAuthPayload(params: PopulateAuthPayloadParams): AuthTypes.PayloadParams {\n  const { authPayload, chains, methods } = params;\n  const statement = authPayload.statement || \"\";\n\n  if (!chains?.length) return authPayload;\n\n  const requested = authPayload.chains;\n  const supported = chains;\n\n  const supportedChains = getCommonValuesInArrays<string>(requested, supported);\n  if (!supportedChains?.length) {\n    throw new Error(\"No supported chains\");\n  }\n\n  const requestedRecaps = getDecodedRecapFromResources(authPayload.resources);\n  if (!requestedRecaps) return authPayload;\n\n  isValidRecap(requestedRecaps);\n  const resource = getRecapResource(requestedRecaps, \"eip155\");\n  let updatedResources = authPayload?.resources || [];\n\n  if (resource?.length) {\n    const actions = getReCapActions(resource);\n    const supportedActions = getCommonValuesInArrays<string>(actions, methods);\n    if (!supportedActions?.length) {\n      throw new Error(\n        `Supported methods don't satisfy the requested: ${JSON.stringify(\n          actions,\n        )}, supported: ${JSON.stringify(methods)}`,\n      );\n    }\n    const formattedActions = assignAbilityToActions(\"request\", supportedActions as string[], {\n      chains: supportedChains,\n    });\n    const updatedRecap = addResourceToRecap(requestedRecaps, \"eip155\", formattedActions);\n    // remove recap from resources as we will add the updated one\n    updatedResources = authPayload?.resources?.slice(0, -1) || [];\n    updatedResources.push(encodeRecap(updatedRecap));\n  }\n\n  return {\n    ...authPayload,\n    statement: buildRecapStatement(statement, getRecapFromResources(updatedResources)),\n    chains: supportedChains,\n    resources: authPayload?.resources || updatedResources.length > 0 ? updatedResources : undefined,\n  };\n}\n\nexport function getDecodedRecapFromResources(resources?: string[]) {\n  const resource = getRecapFromResources(resources);\n  if (!resource) return;\n  if (!isRecap(resource)) return;\n  return decodeRecap(resource);\n}\n\nexport function recapHasResource(recap: any, resource: string) {\n  return recap?.att?.hasOwnProperty(resource);\n}\n\nexport function getRecapResource(recap: any, resource: string): any[] {\n  return recap?.att?.[resource] ? Object.keys(recap?.att?.[resource]) : [];\n}\n\nexport function getRecapAbilitiesFromResource(actions: any[]) {\n  return actions?.map((action) => Object.keys(action)) || [];\n}\n\nexport function getReCapActions(abilities: any[]) {\n  return abilities?.map((ability) => ability.split(\"/\")?.[1]) || [];\n}\n\nexport function base64Encode(input: unknown): string {\n  return Buffer.from(JSON.stringify(input)).toString(\"base64\");\n}\n\nexport function base64Decode(encodedString: string): string {\n  return JSON.parse(Buffer.from(encodedString, \"base64\").toString(\"utf-8\"));\n}\n\nexport function isValidRecap(recap: any) {\n  if (!recap) throw new Error(\"No recap provided, value is undefined\");\n  if (!recap.att) throw new Error(\"No `att` property found\");\n  const resources = Object.keys(recap.att);\n  if (!resources?.length) throw new Error(\"No resources found in `att` property\");\n  resources.forEach((resource) => {\n    const resourceAbilities = recap.att[resource];\n    if (Array.isArray(resourceAbilities))\n      throw new Error(`Resource must be an object: ${resource}`);\n    if (typeof resourceAbilities !== \"object\")\n      throw new Error(`Resource must be an object: ${resource}`);\n    if (!Object.keys(resourceAbilities).length)\n      throw new Error(`Resource object is empty: ${resource}`);\n\n    Object.keys(resourceAbilities).forEach((ability) => {\n      const limits = resourceAbilities[ability];\n      if (!Array.isArray(limits))\n        throw new Error(`Ability limits ${ability} must be an array of objects, found: ${limits}`);\n      if (!limits.length)\n        throw new Error(`Value of ${ability} is empty array, must be an array with objects`);\n      limits.forEach((limit) => {\n        if (typeof limit !== \"object\")\n          throw new Error(\n            `Ability limits (${ability}) must be an array of objects, found: ${limit}`,\n          );\n      });\n    });\n  });\n}\n\nexport function createRecap(resource: string, ability: string, actions: string[], limits = {}) {\n  actions?.sort((a, b) => a.localeCompare(b));\n  return {\n    att: { [resource]: assignAbilityToActions(ability, actions, limits) },\n  };\n}\n\ntype RecapType = {\n  att: {\n    [key: string]: Record<string, unknown>;\n  };\n};\nexport function addResourceToRecap(recap: RecapType, resource: string, actions: unknown[]) {\n  recap.att[resource] = {\n    ...actions,\n  };\n  const keys = Object.keys(recap.att)?.sort((a, b) => a.localeCompare(b));\n  const baseRecap: RecapType = { att: {} };\n  const sorted = keys.reduce((obj, key) => {\n    obj.att[key] = recap.att[key];\n    return obj;\n  }, baseRecap);\n  return sorted;\n}\n\nexport function assignAbilityToActions(ability: string, actions: string[], limits = {}) {\n  // sort resources alphabetically\n  actions = actions?.sort((a, b) => a.localeCompare(b));\n  const abilities = actions.map((action) => {\n    return {\n      [`${ability}/${action}`]: [limits],\n    };\n  });\n  return Object.assign({}, ...abilities);\n}\n\nexport function encodeRecap(recap: any) {\n  isValidRecap(recap);\n  // remove the padding from the base64 string as per recap spec\n  return `urn:recap:${base64Encode(recap).replace(/=/g, \"\")}`;\n}\n\nexport function decodeRecap(recap: any): RecapType {\n  // base64Decode adds padding internally so don't need to add it back if it was removed\n  const decoded = base64Decode(recap.replace(\"urn:recap:\", \"\"));\n  isValidRecap(decoded);\n  return decoded as unknown as RecapType;\n}\n\nexport function createEncodedRecap(resource: string, ability: string, actions: string[]): string {\n  const recap = createRecap(resource, ability, actions);\n  return encodeRecap(recap);\n}\n\nexport function isRecap(resource: string) {\n  return resource && resource.includes(\"urn:recap:\");\n}\n\nexport function mergeEncodedRecaps(recap1: string, recap2: string) {\n  const decoded1 = decodeRecap(recap1);\n  const decoded2 = decodeRecap(recap2);\n  const merged = mergeRecaps(decoded1, decoded2);\n  return encodeRecap(merged);\n}\n\nexport function mergeRecaps(recap1: RecapType, recap2: RecapType) {\n  isValidRecap(recap1);\n  isValidRecap(recap2);\n  const keys = Object.keys(recap1.att)\n    .concat(Object.keys(recap2.att))\n    .sort((a, b) => a.localeCompare(b));\n  const mergedRecap: RecapType = { att: {} };\n  keys.forEach((key) => {\n    const actions = Object.keys(recap1.att?.[key] || {})\n      .concat(Object.keys(recap2.att?.[key] || {}))\n      .sort((a, b) => a.localeCompare(b));\n    actions.forEach((action) => {\n      mergedRecap.att[key] = {\n        ...mergedRecap.att[key],\n        [action]: recap1.att[key]?.[action] || recap2.att[key]?.[action],\n      };\n    });\n  });\n  return mergedRecap;\n}\n\nexport function formatStatementFromRecap(statement = \"\", recap: RecapType) {\n  isValidRecap(recap);\n  const base = \"I further authorize the stated URI to perform the following actions on my behalf: \";\n\n  if (statement.includes(base)) return statement;\n\n  const statementForRecap: string[] = [];\n  let currentCounter = 0;\n  Object.keys(recap.att).forEach((resource) => {\n    const actions = Object.keys(recap.att[resource]).map((ability: any) => {\n      return {\n        ability: ability.split(\"/\")[0],\n        action: ability.split(\"/\")[1],\n      };\n    });\n    //\n    actions.sort((a, b) => a.action.localeCompare(b.action));\n    const uniqueAbilities: Record<string, string[]> = {};\n    actions.forEach((action: any) => {\n      if (!uniqueAbilities[action.ability]) {\n        uniqueAbilities[action.ability] = [];\n      }\n      uniqueAbilities[action.ability].push(action.action);\n    });\n    const abilities = Object.keys(uniqueAbilities).map((ability) => {\n      currentCounter++;\n      return `(${currentCounter}) '${ability}': '${uniqueAbilities[ability].join(\n        \"', '\",\n      )}' for '${resource}'.`;\n    });\n    statementForRecap.push(abilities.join(\", \").replace(\".,\", \".\"));\n  });\n\n  const recapStatemet = statementForRecap.join(\" \");\n  const recapStatement = `${base}${recapStatemet}`;\n  // add a space if there is a statement\n  return `${statement ? statement + \" \" : \"\"}${recapStatement}`;\n}\n\nexport function getMethodsFromRecap(recap: string) {\n  const decoded = decodeRecap(recap);\n  isValidRecap(decoded);\n  // methods are only available for eip155 as per the current implementation\n  const resource = decoded.att?.eip155;\n  if (!resource) return [];\n  return Object.keys(resource).map((ability: any) => ability.split(\"/\")[1]);\n}\n\nexport function getChainsFromRecap(recap: string) {\n  const decoded = decodeRecap(recap);\n  isValidRecap(decoded);\n  const chains: string[] = [];\n\n  Object.values(decoded.att).forEach((resource: any) => {\n    Object.values(resource).forEach((ability: any) => {\n      if (ability?.[0]?.chains) {\n        chains.push(ability[0].chains);\n      }\n    });\n  });\n  return [...new Set(chains.flat())];\n}\n\nexport function buildRecapStatement(statement: string, recap: unknown) {\n  if (!recap) return statement;\n  const decoded = decodeRecap(recap);\n  isValidRecap(decoded);\n  return formatStatementFromRecap(statement, decoded);\n}\n\nexport function getRecapFromResources(resources?: string[]) {\n  if (!resources) return;\n  // per spec, recap is always the last resource\n  const resource = resources?.[resources.length - 1];\n  return isRecap(resource) ? resource : undefined;\n}\n","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is boolean. */\nexport function abool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n/** Asserts something is positive integer. */\nexport function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nexport function abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/**\n * Asserts something is hash\n * TODO: remove\n * @deprecated\n */\nexport function ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// Used in micro\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return BigInt(hex === '' ? '0' : '0x' + hex); // Big Endian\n}\n// Used in ff1\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\n// Used in micro, ff1\nexport function numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n// TODO: remove\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    else if (isBytes(data))\n        data = copyBytes(data);\n    else\n        throw new Error('Uint8Array expected, got ' + typeof data);\n    return data;\n}\n/**\n * Checks if two U8A use same underlying buffer and overlaps.\n * This is invalid and can corrupt data.\n */\nexport function overlapBytes(a, b) {\n    return (a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy\n        a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end\n        b.byteOffset < a.byteOffset + a.byteLength // b starts before a end\n    );\n}\n/**\n * If input and output overlap and input starts before output, we will overwrite end of input before\n * we start processing it, so this is not supported for most ciphers (except chacha/salse, which designed with this)\n */\nexport function complexOverlapBytes(input, output) {\n    // This is very cursed. It works somehow, but I'm completely unsure,\n    // reasoning about overlapping aligned windows is very hard.\n    if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)\n        throw new Error('complex overlap of input and output is not supported');\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexport function checkOpts(defaults, opts) {\n    if (opts == null || typeof opts !== 'object')\n        throw new Error('options must be defined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** Compares 2 uint8array-s in kinda constant time. */\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n// TODO: remove\n/** For runtime check if class implements interface. */\nexport class Hash {\n}\n/**\n * Wraps a cipher: validates args, ensures encrypt() can only be called once.\n * @__NO_SIDE_EFFECTS__\n */\nexport const wrapCipher = (params, constructor) => {\n    function wrappedCipher(key, ...args) {\n        // Validate key\n        abytes(key);\n        // Big-Endian hardware is rare. Just in case someone still decides to run ciphers:\n        if (!isLE)\n            throw new Error('Non little-endian hardware is not yet supported');\n        // Validate nonce if nonceLength is present\n        if (params.nonceLength !== undefined) {\n            const nonce = args[0];\n            if (!nonce)\n                throw new Error('nonce / iv required');\n            if (params.varSizeNonce)\n                abytes(nonce);\n            else\n                abytes(nonce, params.nonceLength);\n        }\n        // Validate AAD if tagLength present\n        const tagl = params.tagLength;\n        if (tagl && args[1] !== undefined) {\n            abytes(args[1]);\n        }\n        const cipher = constructor(key, ...args);\n        const checkOutput = (fnLength, output) => {\n            if (output !== undefined) {\n                if (fnLength !== 2)\n                    throw new Error('cipher output not supported');\n                abytes(output);\n            }\n        };\n        // Create wrapped cipher with validation and single-use encryption\n        let called = false;\n        const wrCipher = {\n            encrypt(data, output) {\n                if (called)\n                    throw new Error('cannot encrypt() twice with same key + nonce');\n                called = true;\n                abytes(data);\n                checkOutput(cipher.encrypt.length, output);\n                return cipher.encrypt(data, output);\n            },\n            decrypt(data, output) {\n                abytes(data);\n                if (tagl && data.length < tagl)\n                    throw new Error('invalid ciphertext length: smaller than tagLength=' + tagl);\n                checkOutput(cipher.decrypt.length, output);\n                return cipher.decrypt(data, output);\n            },\n        };\n        return wrCipher;\n    }\n    Object.assign(wrappedCipher, params);\n    return wrappedCipher;\n};\n/**\n * By default, returns u8a of length.\n * When out is available, it checks it for validity and uses it.\n */\nexport function getOutput(expectedLength, out, onlyAligned = true) {\n    if (out === undefined)\n        return new Uint8Array(expectedLength);\n    if (out.length !== expectedLength)\n        throw new Error('invalid output length, expected ' + expectedLength + ', got: ' + out.length);\n    if (onlyAligned && !isAligned32(out))\n        throw new Error('invalid output, must be aligned');\n    return out;\n}\n/** Polyfill for Safari 14. */\nexport function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\nexport function u64Lengths(dataLength, aadLength, isLE) {\n    abool(isLE);\n    const num = new Uint8Array(16);\n    const view = createView(num);\n    setBigUint64(view, 0, BigInt(aadLength), isLE);\n    setBigUint64(view, 8, BigInt(dataLength), isLE);\n    return num;\n}\n// Is byte array aligned to 4 byte offset (u32)?\nexport function isAligned32(bytes) {\n    return bytes.byteOffset % 4 === 0;\n}\n// copy bytes to new u8a (aligned). Because Buffer.slice is broken.\nexport function copyBytes(bytes) {\n    return Uint8Array.from(bytes);\n}\n//# sourceMappingURL=utils.js.map","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  isProgramError,\n  type Address,\n  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n  type SolanaError,\n} from '@solana/kit';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\n\n/** InvalidOwner: Associated token account owner does not match address derivation */\nexport const ASSOCIATED_TOKEN_ERROR__INVALID_OWNER = 0x0; // 0\n\nexport type AssociatedTokenError = typeof ASSOCIATED_TOKEN_ERROR__INVALID_OWNER;\n\nlet associatedTokenErrorMessages:\n  | Record<AssociatedTokenError, string>\n  | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  associatedTokenErrorMessages = {\n    [ASSOCIATED_TOKEN_ERROR__INVALID_OWNER]: `Associated token account owner does not match address derivation`,\n  };\n}\n\nexport function getAssociatedTokenErrorMessage(\n  code: AssociatedTokenError\n): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (\n      associatedTokenErrorMessages as Record<AssociatedTokenError, string>\n    )[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}\n\nexport function isAssociatedTokenError<\n  TProgramErrorCode extends AssociatedTokenError,\n>(\n  error: unknown,\n  transactionMessage: {\n    instructions: Record<number, { programAddress: Address }>;\n  },\n  code?: TProgramErrorCode\n): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &\n  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return isProgramError<TProgramErrorCode>(\n    error,\n    transactionMessage,\n    ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n    code\n  );\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  isProgramError,\n  type Address,\n  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n  type SolanaError,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\n\n/** NotRentExempt: Lamport balance below rent-exempt threshold */\nexport const TOKEN_2022_ERROR__NOT_RENT_EXEMPT = 0x0; // 0\n/** InsufficientFunds: Insufficient funds */\nexport const TOKEN_2022_ERROR__INSUFFICIENT_FUNDS = 0x1; // 1\n/** InvalidMint: Invalid Mint */\nexport const TOKEN_2022_ERROR__INVALID_MINT = 0x2; // 2\n/** MintMismatch: Account not associated with this Mint */\nexport const TOKEN_2022_ERROR__MINT_MISMATCH = 0x3; // 3\n/** OwnerMismatch: Owner does not match */\nexport const TOKEN_2022_ERROR__OWNER_MISMATCH = 0x4; // 4\n/** FixedSupply: Fixed supply */\nexport const TOKEN_2022_ERROR__FIXED_SUPPLY = 0x5; // 5\n/** AlreadyInUse: Already in use */\nexport const TOKEN_2022_ERROR__ALREADY_IN_USE = 0x6; // 6\n/** InvalidNumberOfProvidedSigners: Invalid number of provided signers */\nexport const TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS = 0x7; // 7\n/** InvalidNumberOfRequiredSigners: Invalid number of required signers */\nexport const TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS = 0x8; // 8\n/** UninitializedState: State is unititialized */\nexport const TOKEN_2022_ERROR__UNINITIALIZED_STATE = 0x9; // 9\n/** NativeNotSupported: Instruction does not support native tokens */\nexport const TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED = 0xa; // 10\n/** NonNativeHasBalance: Non-native account can only be closed if its balance is zero */\nexport const TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE = 0xb; // 11\n/** InvalidInstruction: Invalid instruction */\nexport const TOKEN_2022_ERROR__INVALID_INSTRUCTION = 0xc; // 12\n/** InvalidState: State is invalid for requested operation */\nexport const TOKEN_2022_ERROR__INVALID_STATE = 0xd; // 13\n/** Overflow: Operation overflowed */\nexport const TOKEN_2022_ERROR__OVERFLOW = 0xe; // 14\n/** AuthorityTypeNotSupported: Account does not support specified authority type */\nexport const TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED = 0xf; // 15\n/** MintCannotFreeze: This token mint cannot freeze accounts */\nexport const TOKEN_2022_ERROR__MINT_CANNOT_FREEZE = 0x10; // 16\n/** AccountFrozen: Account is frozen */\nexport const TOKEN_2022_ERROR__ACCOUNT_FROZEN = 0x11; // 17\n/** MintDecimalsMismatch: The provided decimals value different from the Mint decimals */\nexport const TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH = 0x12; // 18\n/** NonNativeNotSupported: Instruction does not support non-native tokens */\nexport const TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED = 0x13; // 19\n\nexport type Token2022Error =\n  | typeof TOKEN_2022_ERROR__ACCOUNT_FROZEN\n  | typeof TOKEN_2022_ERROR__ALREADY_IN_USE\n  | typeof TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED\n  | typeof TOKEN_2022_ERROR__FIXED_SUPPLY\n  | typeof TOKEN_2022_ERROR__INSUFFICIENT_FUNDS\n  | typeof TOKEN_2022_ERROR__INVALID_INSTRUCTION\n  | typeof TOKEN_2022_ERROR__INVALID_MINT\n  | typeof TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS\n  | typeof TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS\n  | typeof TOKEN_2022_ERROR__INVALID_STATE\n  | typeof TOKEN_2022_ERROR__MINT_CANNOT_FREEZE\n  | typeof TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH\n  | typeof TOKEN_2022_ERROR__MINT_MISMATCH\n  | typeof TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED\n  | typeof TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE\n  | typeof TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED\n  | typeof TOKEN_2022_ERROR__NOT_RENT_EXEMPT\n  | typeof TOKEN_2022_ERROR__OVERFLOW\n  | typeof TOKEN_2022_ERROR__OWNER_MISMATCH\n  | typeof TOKEN_2022_ERROR__UNINITIALIZED_STATE;\n\nlet token2022ErrorMessages: Record<Token2022Error, string> | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  token2022ErrorMessages = {\n    [TOKEN_2022_ERROR__ACCOUNT_FROZEN]: `Account is frozen`,\n    [TOKEN_2022_ERROR__ALREADY_IN_USE]: `Already in use`,\n    [TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED]: `Account does not support specified authority type`,\n    [TOKEN_2022_ERROR__FIXED_SUPPLY]: `Fixed supply`,\n    [TOKEN_2022_ERROR__INSUFFICIENT_FUNDS]: `Insufficient funds`,\n    [TOKEN_2022_ERROR__INVALID_INSTRUCTION]: `Invalid instruction`,\n    [TOKEN_2022_ERROR__INVALID_MINT]: `Invalid Mint`,\n    [TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS]: `Invalid number of provided signers`,\n    [TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS]: `Invalid number of required signers`,\n    [TOKEN_2022_ERROR__INVALID_STATE]: `State is invalid for requested operation`,\n    [TOKEN_2022_ERROR__MINT_CANNOT_FREEZE]: `This token mint cannot freeze accounts`,\n    [TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH]: `The provided decimals value different from the Mint decimals`,\n    [TOKEN_2022_ERROR__MINT_MISMATCH]: `Account not associated with this Mint`,\n    [TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED]: `Instruction does not support native tokens`,\n    [TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE]: `Non-native account can only be closed if its balance is zero`,\n    [TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED]: `Instruction does not support non-native tokens`,\n    [TOKEN_2022_ERROR__NOT_RENT_EXEMPT]: `Lamport balance below rent-exempt threshold`,\n    [TOKEN_2022_ERROR__OVERFLOW]: `Operation overflowed`,\n    [TOKEN_2022_ERROR__OWNER_MISMATCH]: `Owner does not match`,\n    [TOKEN_2022_ERROR__UNINITIALIZED_STATE]: `State is unititialized`,\n  };\n}\n\nexport function getToken2022ErrorMessage(code: Token2022Error): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (token2022ErrorMessages as Record<Token2022Error, string>)[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}\n\nexport function isToken2022Error<TProgramErrorCode extends Token2022Error>(\n  error: unknown,\n  transactionMessage: {\n    instructions: Record<number, { programAddress: Address }>;\n  },\n  code?: TProgramErrorCode\n): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &\n  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return isProgramError<TProgramErrorCode>(\n    error,\n    transactionMessage,\n    TOKEN_2022_PROGRAM_ADDRESS,\n    code\n  );\n}\n","/**\n * Basic utils for ARX (add-rotate-xor) salsa and chacha ciphers.\n\nRFC8439 requires multi-step cipher stream, where\nauthKey starts with counter: 0, actual msg with counter: 1.\n\nFor this, we need a way to re-use nonce / counter:\n\n    const counter = new Uint8Array(4);\n    chacha(..., counter, ...); // counter is now 1\n    chacha(..., counter, ...); // counter is now 2\n\nThis is complicated:\n\n- 32-bit counters are enough, no need for 64-bit: max ArrayBuffer size in JS is 4GB\n- Original papers don't allow mutating counters\n- Counter overflow is undefined [^1]\n- Idea A: allow providing (nonce | counter) instead of just nonce, re-use it\n- Caveat: Cannot be re-used through all cases:\n- * chacha has (counter | nonce)\n- * xchacha has (nonce16 | counter | nonce16)\n- Idea B: separate nonce / counter and provide separate API for counter re-use\n- Caveat: there are different counter sizes depending on an algorithm.\n- salsa & chacha also differ in structures of key & sigma:\n  salsa20:      s[0] | k(4) | s[1] | nonce(2) | ctr(2) | s[2] | k(4) | s[3]\n  chacha:       s(4) | k(8) | ctr(1) | nonce(3)\n  chacha20orig: s(4) | k(8) | ctr(2) | nonce(2)\n- Idea C: helper method such as `setSalsaState(key, nonce, sigma, data)`\n- Caveat: we can't re-use counter array\n\nxchacha [^2] uses the subkey and remaining 8 byte nonce with ChaCha20 as normal\n(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).\n\n[^1]: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/\n[^2]: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2\n\n * @module\n */\n// prettier-ignore\nimport { abool, abytes, anumber, checkOpts, clean, copyBytes, u32 } from \"./utils.js\";\n// We can't make top-level var depend on utils.utf8ToBytes\n// because it's not present in all envs. Creating a similar fn here\nconst _utf8ToBytes = (str) => Uint8Array.from(str.split('').map((c) => c.charCodeAt(0)));\nconst sigma16 = _utf8ToBytes('expand 16-byte k');\nconst sigma32 = _utf8ToBytes('expand 32-byte k');\nconst sigma16_32 = u32(sigma16);\nconst sigma32_32 = u32(sigma32);\nexport function rotl(a, b) {\n    return (a << b) | (a >>> (32 - b));\n}\n// Is byte array aligned to 4 byte offset (u32)?\nfunction isAligned32(b) {\n    return b.byteOffset % 4 === 0;\n}\n// Salsa and Chacha block length is always 512-bit\nconst BLOCK_LEN = 64;\nconst BLOCK_LEN32 = 16;\n// new Uint32Array([2**32])   // => Uint32Array(1) [ 0 ]\n// new Uint32Array([2**32-1]) // => Uint32Array(1) [ 4294967295 ]\nconst MAX_COUNTER = 2 ** 32 - 1;\nconst U32_EMPTY = new Uint32Array();\nfunction runCipher(core, sigma, key, nonce, data, output, counter, rounds) {\n    const len = data.length;\n    const block = new Uint8Array(BLOCK_LEN);\n    const b32 = u32(block);\n    // Make sure that buffers aligned to 4 bytes\n    const isAligned = isAligned32(data) && isAligned32(output);\n    const d32 = isAligned ? u32(data) : U32_EMPTY;\n    const o32 = isAligned ? u32(output) : U32_EMPTY;\n    for (let pos = 0; pos < len; counter++) {\n        core(sigma, key, nonce, b32, counter, rounds);\n        if (counter >= MAX_COUNTER)\n            throw new Error('arx: counter overflow');\n        const take = Math.min(BLOCK_LEN, len - pos);\n        // aligned to 4 bytes\n        if (isAligned && take === BLOCK_LEN) {\n            const pos32 = pos / 4;\n            if (pos % 4 !== 0)\n                throw new Error('arx: invalid block position');\n            for (let j = 0, posj; j < BLOCK_LEN32; j++) {\n                posj = pos32 + j;\n                o32[posj] = d32[posj] ^ b32[j];\n            }\n            pos += BLOCK_LEN;\n            continue;\n        }\n        for (let j = 0, posj; j < take; j++) {\n            posj = pos + j;\n            output[posj] = data[posj] ^ block[j];\n        }\n        pos += take;\n    }\n}\n/** Creates ARX-like (ChaCha, Salsa) cipher stream from core function. */\nexport function createCipher(core, opts) {\n    const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);\n    if (typeof core !== 'function')\n        throw new Error('core must be a function');\n    anumber(counterLength);\n    anumber(rounds);\n    abool(counterRight);\n    abool(allowShortKeys);\n    return (key, nonce, data, output, counter = 0) => {\n        abytes(key);\n        abytes(nonce);\n        abytes(data);\n        const len = data.length;\n        if (output === undefined)\n            output = new Uint8Array(len);\n        abytes(output);\n        anumber(counter);\n        if (counter < 0 || counter >= MAX_COUNTER)\n            throw new Error('arx: counter overflow');\n        if (output.length < len)\n            throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);\n        const toClean = [];\n        // Key & sigma\n        // key=16 -> sigma16, k=key|key\n        // key=32 -> sigma32, k=key\n        let l = key.length;\n        let k;\n        let sigma;\n        if (l === 32) {\n            toClean.push((k = copyBytes(key)));\n            sigma = sigma32_32;\n        }\n        else if (l === 16 && allowShortKeys) {\n            k = new Uint8Array(32);\n            k.set(key);\n            k.set(key, 16);\n            sigma = sigma16_32;\n            toClean.push(k);\n        }\n        else {\n            throw new Error(`arx: invalid 32-byte key, got length=${l}`);\n        }\n        // Nonce\n        // salsa20:      8   (8-byte counter)\n        // chacha20orig: 8   (8-byte counter)\n        // chacha20:     12  (4-byte counter)\n        // xsalsa20:     24  (16 -> hsalsa,  8 -> old nonce)\n        // xchacha20:    24  (16 -> hchacha, 8 -> old nonce)\n        // Align nonce to 4 bytes\n        if (!isAligned32(nonce))\n            toClean.push((nonce = copyBytes(nonce)));\n        const k32 = u32(k);\n        // hsalsa & hchacha: handle extended nonce\n        if (extendNonceFn) {\n            if (nonce.length !== 24)\n                throw new Error(`arx: extended nonce must be 24 bytes`);\n            extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);\n            nonce = nonce.subarray(16);\n        }\n        // Handle nonce counter\n        const nonceNcLen = 16 - counterLength;\n        if (nonceNcLen !== nonce.length)\n            throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);\n        // Pad counter when nonce is 64 bit\n        if (nonceNcLen !== 12) {\n            const nc = new Uint8Array(12);\n            nc.set(nonce, counterRight ? 0 : 12 - nonce.length);\n            nonce = nc;\n            toClean.push(nonce);\n        }\n        const n32 = u32(nonce);\n        runCipher(core, sigma, k32, n32, data, output, counter, rounds);\n        clean(...toClean);\n        return output;\n    };\n}\n//# sourceMappingURL=_arx.js.map","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  isProgramDerivedAddress,\n  isTransactionSigner as kitIsTransactionSigner,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type ProgramDerivedAddress,\n  type TransactionSigner,\n  upgradeRoleToSigner,\n} from '@solana/kit';\n\n/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value === null || value === undefined) {\n    throw new Error('Expected a value but received null or undefined.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): Address<T> {\n  if (!value) {\n    throw new Error('Expected a Address.');\n  }\n  if (typeof value === 'object' && 'address' in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0] as Address<T>;\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error('Expected a ProgramDerivedAddress.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error('Expected a TransactionSigner.');\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<\n  T extends string = string,\n  U extends\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null =\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null,\n> = {\n  isWritable: boolean;\n  value: U;\n};\n\n/**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type InstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n * Get account metas and signers from resolved accounts.\n * @internal\n */\nexport function getAccountMetaFactory(\n  programAddress: Address,\n  optionalAccountStrategy: 'omitted' | 'programId'\n) {\n  return (\n    account: ResolvedAccount\n  ): AccountMeta | AccountSignerMeta | undefined => {\n    if (!account.value) {\n      if (optionalAccountStrategy === 'omitted') return;\n      return Object.freeze({\n        address: programAddress,\n        role: AccountRole.READONLY,\n      });\n    }\n\n    const writableRole = account.isWritable\n      ? AccountRole.WRITABLE\n      : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value)\n        ? upgradeRoleToSigner(writableRole)\n        : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),\n    });\n  };\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(\n  value:\n    | Address<TAddress>\n    | ProgramDerivedAddress<TAddress>\n    | TransactionSigner<TAddress>\n): value is TransactionSigner<TAddress> {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'address' in value &&\n    kitIsTransactionSigner(value)\n  );\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR = 23;\n\nexport function getAmountToUiAmountDiscriminatorBytes() {\n  return getU8Encoder().encode(AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR);\n}\n\nexport type AmountToUiAmountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AmountToUiAmountInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to reformat. */\n  amount: bigint;\n};\n\nexport type AmountToUiAmountInstructionDataArgs = {\n  /** The amount of tokens to reformat. */\n  amount: number | bigint;\n};\n\nexport function getAmountToUiAmountInstructionDataEncoder(): FixedSizeEncoder<AmountToUiAmountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getAmountToUiAmountInstructionDataDecoder(): FixedSizeDecoder<AmountToUiAmountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getAmountToUiAmountInstructionDataCodec(): FixedSizeCodec<\n  AmountToUiAmountInstructionDataArgs,\n  AmountToUiAmountInstructionData\n> {\n  return combineCodec(\n    getAmountToUiAmountInstructionDataEncoder(),\n    getAmountToUiAmountInstructionDataDecoder()\n  );\n}\n\nexport type AmountToUiAmountInput<TAccountMint extends string = string> = {\n  /** The mint to calculate for. */\n  mint: Address<TAccountMint>;\n  amount: AmountToUiAmountInstructionDataArgs['amount'];\n};\n\nexport function getAmountToUiAmountInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: AmountToUiAmountInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): AmountToUiAmountInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getAmountToUiAmountInstructionDataEncoder().encode(\n      args as AmountToUiAmountInstructionDataArgs\n    ),\n    programAddress,\n  } as AmountToUiAmountInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedAmountToUiAmountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to calculate for. */\n    mint: TAccountMetas[0];\n  };\n  data: AmountToUiAmountInstructionData;\n};\n\nexport function parseAmountToUiAmountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedAmountToUiAmountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getAmountToUiAmountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR = 27;\n\nexport function getApplyConfidentialPendingBalanceDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR\n  );\n}\n\nexport const APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 8;\n\nexport function getApplyConfidentialPendingBalanceConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ApplyConfidentialPendingBalanceInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApplyConfidentialPendingBalanceInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /**\n   * The expected number of pending balance credits since the last successful\n   * `ApplyPendingBalance` instruction\n   */\n  expectedPendingBalanceCreditCounter: bigint;\n  /**\n   * The new decryptable balance if the pending balance is applied\n   * successfully\n   */\n  newDecryptableAvailableBalance: DecryptableBalance;\n};\n\nexport type ApplyConfidentialPendingBalanceInstructionDataArgs = {\n  /**\n   * The expected number of pending balance credits since the last successful\n   * `ApplyPendingBalance` instruction\n   */\n  expectedPendingBalanceCreditCounter: number | bigint;\n  /**\n   * The new decryptable balance if the pending balance is applied\n   * successfully\n   */\n  newDecryptableAvailableBalance: DecryptableBalanceArgs;\n};\n\nexport function getApplyConfidentialPendingBalanceInstructionDataEncoder(): FixedSizeEncoder<ApplyConfidentialPendingBalanceInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['expectedPendingBalanceCreditCounter', getU64Encoder()],\n      ['newDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getApplyConfidentialPendingBalanceInstructionDataDecoder(): FixedSizeDecoder<ApplyConfidentialPendingBalanceInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['expectedPendingBalanceCreditCounter', getU64Decoder()],\n    ['newDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n  ]);\n}\n\nexport function getApplyConfidentialPendingBalanceInstructionDataCodec(): FixedSizeCodec<\n  ApplyConfidentialPendingBalanceInstructionDataArgs,\n  ApplyConfidentialPendingBalanceInstructionData\n> {\n  return combineCodec(\n    getApplyConfidentialPendingBalanceInstructionDataEncoder(),\n    getApplyConfidentialPendingBalanceInstructionDataDecoder()\n  );\n}\n\nexport type ApplyConfidentialPendingBalanceInput<\n  TAccountToken extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  expectedPendingBalanceCreditCounter: ApplyConfidentialPendingBalanceInstructionDataArgs['expectedPendingBalanceCreditCounter'];\n  newDecryptableAvailableBalance: ApplyConfidentialPendingBalanceInstructionDataArgs['newDecryptableAvailableBalance'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getApplyConfidentialPendingBalanceInstruction<\n  TAccountToken extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ApplyConfidentialPendingBalanceInput<TAccountToken, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): ApplyConfidentialPendingBalanceInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getApplyConfidentialPendingBalanceInstructionDataEncoder().encode(\n      args as ApplyConfidentialPendingBalanceInstructionDataArgs\n    ),\n    programAddress,\n  } as ApplyConfidentialPendingBalanceInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedApplyConfidentialPendingBalanceInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[1];\n  };\n  data: ApplyConfidentialPendingBalanceInstructionData;\n};\n\nexport function parseApplyConfidentialPendingBalanceInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedApplyConfidentialPendingBalanceInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), authority: getNextAccount() },\n    data: getApplyConfidentialPendingBalanceInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * Poly1305 ([PDF](https://cr.yp.to/mac/poly1305-20050329.pdf),\n * [wiki](https://en.wikipedia.org/wiki/Poly1305))\n * is a fast and parallel secret-key message-authentication code suitable for\n * a wide variety of applications. It was standardized in\n * [RFC 8439](https://datatracker.ietf.org/doc/html/rfc8439) and is now used in TLS 1.3.\n *\n * Polynomial MACs are not perfect for every situation:\n * they lack Random Key Robustness: the MAC can be forged, and can't be used in PAKE schemes.\n * See [invisible salamanders attack](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/).\n * To combat invisible salamanders, `hash(key)` can be included in ciphertext,\n * however, this would violate ciphertext indistinguishability:\n * an attacker would know which key was used - so `HKDF(key, i)`\n * could be used instead.\n *\n * Check out [original website](https://cr.yp.to/mac.html).\n * @module\n */\nimport { Hash, abytes, aexists, aoutput, clean, toBytes } from \"./utils.js\";\n// Based on Public Domain poly1305-donna https://github.com/floodyberry/poly1305-donna\nconst u8to16 = (a, i) => (a[i++] & 0xff) | ((a[i++] & 0xff) << 8);\nclass Poly1305 {\n    constructor(key) {\n        this.blockLen = 16;\n        this.outputLen = 16;\n        this.buffer = new Uint8Array(16);\n        this.r = new Uint16Array(10);\n        this.h = new Uint16Array(10);\n        this.pad = new Uint16Array(8);\n        this.pos = 0;\n        this.finished = false;\n        key = toBytes(key);\n        abytes(key, 32);\n        const t0 = u8to16(key, 0);\n        const t1 = u8to16(key, 2);\n        const t2 = u8to16(key, 4);\n        const t3 = u8to16(key, 6);\n        const t4 = u8to16(key, 8);\n        const t5 = u8to16(key, 10);\n        const t6 = u8to16(key, 12);\n        const t7 = u8to16(key, 14);\n        // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47\n        this.r[0] = t0 & 0x1fff;\n        this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;\n        this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;\n        this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;\n        this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;\n        this.r[5] = (t4 >>> 1) & 0x1ffe;\n        this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;\n        this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;\n        this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;\n        this.r[9] = (t7 >>> 5) & 0x007f;\n        for (let i = 0; i < 8; i++)\n            this.pad[i] = u8to16(key, 16 + 2 * i);\n    }\n    process(data, offset, isLast = false) {\n        const hibit = isLast ? 0 : 1 << 11;\n        const { h, r } = this;\n        const r0 = r[0];\n        const r1 = r[1];\n        const r2 = r[2];\n        const r3 = r[3];\n        const r4 = r[4];\n        const r5 = r[5];\n        const r6 = r[6];\n        const r7 = r[7];\n        const r8 = r[8];\n        const r9 = r[9];\n        const t0 = u8to16(data, offset + 0);\n        const t1 = u8to16(data, offset + 2);\n        const t2 = u8to16(data, offset + 4);\n        const t3 = u8to16(data, offset + 6);\n        const t4 = u8to16(data, offset + 8);\n        const t5 = u8to16(data, offset + 10);\n        const t6 = u8to16(data, offset + 12);\n        const t7 = u8to16(data, offset + 14);\n        let h0 = h[0] + (t0 & 0x1fff);\n        let h1 = h[1] + (((t0 >>> 13) | (t1 << 3)) & 0x1fff);\n        let h2 = h[2] + (((t1 >>> 10) | (t2 << 6)) & 0x1fff);\n        let h3 = h[3] + (((t2 >>> 7) | (t3 << 9)) & 0x1fff);\n        let h4 = h[4] + (((t3 >>> 4) | (t4 << 12)) & 0x1fff);\n        let h5 = h[5] + ((t4 >>> 1) & 0x1fff);\n        let h6 = h[6] + (((t4 >>> 14) | (t5 << 2)) & 0x1fff);\n        let h7 = h[7] + (((t5 >>> 11) | (t6 << 5)) & 0x1fff);\n        let h8 = h[8] + (((t6 >>> 8) | (t7 << 8)) & 0x1fff);\n        let h9 = h[9] + ((t7 >>> 5) | hibit);\n        let c = 0;\n        let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);\n        c = d0 >>> 13;\n        d0 &= 0x1fff;\n        d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);\n        c += d0 >>> 13;\n        d0 &= 0x1fff;\n        let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);\n        c = d1 >>> 13;\n        d1 &= 0x1fff;\n        d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);\n        c += d1 >>> 13;\n        d1 &= 0x1fff;\n        let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);\n        c = d2 >>> 13;\n        d2 &= 0x1fff;\n        d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);\n        c += d2 >>> 13;\n        d2 &= 0x1fff;\n        let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);\n        c = d3 >>> 13;\n        d3 &= 0x1fff;\n        d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);\n        c += d3 >>> 13;\n        d3 &= 0x1fff;\n        let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;\n        c = d4 >>> 13;\n        d4 &= 0x1fff;\n        d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);\n        c += d4 >>> 13;\n        d4 &= 0x1fff;\n        let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;\n        c = d5 >>> 13;\n        d5 &= 0x1fff;\n        d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);\n        c += d5 >>> 13;\n        d5 &= 0x1fff;\n        let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;\n        c = d6 >>> 13;\n        d6 &= 0x1fff;\n        d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);\n        c += d6 >>> 13;\n        d6 &= 0x1fff;\n        let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;\n        c = d7 >>> 13;\n        d7 &= 0x1fff;\n        d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);\n        c += d7 >>> 13;\n        d7 &= 0x1fff;\n        let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;\n        c = d8 >>> 13;\n        d8 &= 0x1fff;\n        d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);\n        c += d8 >>> 13;\n        d8 &= 0x1fff;\n        let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;\n        c = d9 >>> 13;\n        d9 &= 0x1fff;\n        d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;\n        c += d9 >>> 13;\n        d9 &= 0x1fff;\n        c = ((c << 2) + c) | 0;\n        c = (c + d0) | 0;\n        d0 = c & 0x1fff;\n        c = c >>> 13;\n        d1 += c;\n        h[0] = d0;\n        h[1] = d1;\n        h[2] = d2;\n        h[3] = d3;\n        h[4] = d4;\n        h[5] = d5;\n        h[6] = d6;\n        h[7] = d7;\n        h[8] = d8;\n        h[9] = d9;\n    }\n    finalize() {\n        const { h, pad } = this;\n        const g = new Uint16Array(10);\n        let c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        for (let i = 2; i < 10; i++) {\n            h[i] += c;\n            c = h[i] >>> 13;\n            h[i] &= 0x1fff;\n        }\n        h[0] += c * 5;\n        c = h[0] >>> 13;\n        h[0] &= 0x1fff;\n        h[1] += c;\n        c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        h[2] += c;\n        g[0] = h[0] + 5;\n        c = g[0] >>> 13;\n        g[0] &= 0x1fff;\n        for (let i = 1; i < 10; i++) {\n            g[i] = h[i] + c;\n            c = g[i] >>> 13;\n            g[i] &= 0x1fff;\n        }\n        g[9] -= 1 << 13;\n        let mask = (c ^ 1) - 1;\n        for (let i = 0; i < 10; i++)\n            g[i] &= mask;\n        mask = ~mask;\n        for (let i = 0; i < 10; i++)\n            h[i] = (h[i] & mask) | g[i];\n        h[0] = (h[0] | (h[1] << 13)) & 0xffff;\n        h[1] = ((h[1] >>> 3) | (h[2] << 10)) & 0xffff;\n        h[2] = ((h[2] >>> 6) | (h[3] << 7)) & 0xffff;\n        h[3] = ((h[3] >>> 9) | (h[4] << 4)) & 0xffff;\n        h[4] = ((h[4] >>> 12) | (h[5] << 1) | (h[6] << 14)) & 0xffff;\n        h[5] = ((h[6] >>> 2) | (h[7] << 11)) & 0xffff;\n        h[6] = ((h[7] >>> 5) | (h[8] << 8)) & 0xffff;\n        h[7] = ((h[8] >>> 8) | (h[9] << 5)) & 0xffff;\n        let f = h[0] + pad[0];\n        h[0] = f & 0xffff;\n        for (let i = 1; i < 8; i++) {\n            f = (((h[i] + pad[i]) | 0) + (f >>> 16)) | 0;\n            h[i] = f & 0xffff;\n        }\n        clean(g);\n    }\n    update(data) {\n        aexists(this);\n        data = toBytes(data);\n        abytes(data);\n        const { buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input\n            if (take === blockLen) {\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(data, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(buffer, 0, false);\n                this.pos = 0;\n            }\n        }\n        return this;\n    }\n    destroy() {\n        clean(this.h, this.r, this.buffer, this.pad);\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        const { buffer, h } = this;\n        let { pos } = this;\n        if (pos) {\n            buffer[pos++] = 1;\n            for (; pos < 16; pos++)\n                buffer[pos] = 0;\n            this.process(buffer, 0, true);\n        }\n        this.finalize();\n        let opos = 0;\n        for (let i = 0; i < 8; i++) {\n            out[opos++] = h[i] >>> 0;\n            out[opos++] = h[i] >>> 8;\n        }\n        return out;\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n}\nexport function wrapConstructorWithKey(hashCons) {\n    const hashC = (msg, key) => hashCons(key).update(toBytes(msg)).digest();\n    const tmp = hashCons(new Uint8Array(32));\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (key) => hashCons(key);\n    return hashC;\n}\n/** Poly1305 MAC from RFC 8439. */\nexport const poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));\n//# sourceMappingURL=_poly1305.js.map","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const APPROVE_DISCRIMINATOR = 4;\n\nexport function getApproveDiscriminatorBytes() {\n  return getU8Encoder().encode(APPROVE_DISCRIMINATOR);\n}\n\nexport type ApproveInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountDelegate extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountDelegate extends string\n        ? ReadonlyAccount<TAccountDelegate>\n        : TAccountDelegate,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApproveInstructionData = {\n  discriminator: number;\n  /** The amount of tokens the delegate is approved for. */\n  amount: bigint;\n};\n\nexport type ApproveInstructionDataArgs = {\n  /** The amount of tokens the delegate is approved for. */\n  amount: number | bigint;\n};\n\nexport function getApproveInstructionDataEncoder(): FixedSizeEncoder<ApproveInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: APPROVE_DISCRIMINATOR })\n  );\n}\n\nexport function getApproveInstructionDataDecoder(): FixedSizeDecoder<ApproveInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getApproveInstructionDataCodec(): FixedSizeCodec<\n  ApproveInstructionDataArgs,\n  ApproveInstructionData\n> {\n  return combineCodec(\n    getApproveInstructionDataEncoder(),\n    getApproveInstructionDataDecoder()\n  );\n}\n\nexport type ApproveInput<\n  TAccountSource extends string = string,\n  TAccountDelegate extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The delegate. */\n  delegate: Address<TAccountDelegate>;\n  /** The source account owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  amount: ApproveInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getApproveInstruction<\n  TAccountSource extends string,\n  TAccountDelegate extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ApproveInput<TAccountSource, TAccountDelegate, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): ApproveInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountDelegate,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    delegate: { value: input.delegate ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.delegate),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getApproveInstructionDataEncoder().encode(\n      args as ApproveInstructionDataArgs\n    ),\n    programAddress,\n  } as ApproveInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountDelegate,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedApproveInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The delegate. */\n    delegate: TAccountMetas[1];\n    /** The source account owner or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: ApproveInstructionData;\n};\n\nexport function parseApproveInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedApproveInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      delegate: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getApproveInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const APPROVE_CHECKED_DISCRIMINATOR = 13;\n\nexport function getApproveCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(APPROVE_CHECKED_DISCRIMINATOR);\n}\n\nexport type ApproveCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountDelegate extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDelegate extends string\n        ? ReadonlyAccount<TAccountDelegate>\n        : TAccountDelegate,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApproveCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of tokens the delegate is approved for. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type ApproveCheckedInstructionDataArgs = {\n  /** The amount of tokens the delegate is approved for. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getApproveCheckedInstructionDataEncoder(): FixedSizeEncoder<ApproveCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: APPROVE_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getApproveCheckedInstructionDataDecoder(): FixedSizeDecoder<ApproveCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getApproveCheckedInstructionDataCodec(): FixedSizeCodec<\n  ApproveCheckedInstructionDataArgs,\n  ApproveCheckedInstructionData\n> {\n  return combineCodec(\n    getApproveCheckedInstructionDataEncoder(),\n    getApproveCheckedInstructionDataDecoder()\n  );\n}\n\nexport type ApproveCheckedInput<\n  TAccountSource extends string = string,\n  TAccountMint extends string = string,\n  TAccountDelegate extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The delegate. */\n  delegate: Address<TAccountDelegate>;\n  /** The source account owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  amount: ApproveCheckedInstructionDataArgs['amount'];\n  decimals: ApproveCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getApproveCheckedInstruction<\n  TAccountSource extends string,\n  TAccountMint extends string,\n  TAccountDelegate extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ApproveCheckedInput<\n    TAccountSource,\n    TAccountMint,\n    TAccountDelegate,\n    TAccountOwner\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ApproveCheckedInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountMint,\n  TAccountDelegate,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    delegate: { value: input.delegate ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.delegate),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getApproveCheckedInstructionDataEncoder().encode(\n      args as ApproveCheckedInstructionDataArgs\n    ),\n    programAddress,\n  } as ApproveCheckedInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountMint,\n    TAccountDelegate,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedApproveCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The delegate. */\n    delegate: TAccountMetas[2];\n    /** The source account owner or its multisignature account. */\n    owner: TAccountMetas[3];\n  };\n  data: ApproveCheckedInstructionData;\n};\n\nexport function parseApproveCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedApproveCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      mint: getNextAccount(),\n      delegate: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getApproveCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR = 27;\n\nexport function getApproveConfidentialTransferAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR\n  );\n}\n\nexport const APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 3;\n\nexport function getApproveConfidentialTransferAccountConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ApproveConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlySignerAccount<TAccountAuthority> &\n            AccountSignerMeta<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApproveConfidentialTransferAccountInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n};\n\nexport type ApproveConfidentialTransferAccountInstructionDataArgs = {};\n\nexport function getApproveConfidentialTransferAccountInstructionDataEncoder(): FixedSizeEncoder<ApproveConfidentialTransferAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getApproveConfidentialTransferAccountInstructionDataDecoder(): FixedSizeDecoder<ApproveConfidentialTransferAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getApproveConfidentialTransferAccountInstructionDataCodec(): FixedSizeCodec<\n  ApproveConfidentialTransferAccountInstructionDataArgs,\n  ApproveConfidentialTransferAccountInstructionData\n> {\n  return combineCodec(\n    getApproveConfidentialTransferAccountInstructionDataEncoder(),\n    getApproveConfidentialTransferAccountInstructionDataDecoder()\n  );\n}\n\nexport type ApproveConfidentialTransferAccountInput<\n  TAccountToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account to approve. */\n  token: Address<TAccountToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /** Confidential transfer mint authority. */\n  authority: TransactionSigner<TAccountAuthority>;\n};\n\nexport function getApproveConfidentialTransferAccountInstruction<\n  TAccountToken extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ApproveConfidentialTransferAccountInput<\n    TAccountToken,\n    TAccountMint,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ApproveConfidentialTransferAccountInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountMint,\n  TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n    ],\n    data: getApproveConfidentialTransferAccountInstructionDataEncoder().encode(\n      {}\n    ),\n    programAddress,\n  } as ApproveConfidentialTransferAccountInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountMint,\n    TAccountAuthority\n  >);\n}\n\nexport type ParsedApproveConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account to approve. */\n    token: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /** Confidential transfer mint authority. */\n    authority: TAccountMetas[2];\n  };\n  data: ApproveConfidentialTransferAccountInstructionData;\n};\n\nexport function parseApproveConfidentialTransferAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedApproveConfidentialTransferAccountInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getApproveConfidentialTransferAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * [ChaCha20](https://cr.yp.to/chacha.html) stream cipher, released\n * in 2008. Developed after Salsa20, ChaCha aims to increase diffusion per round.\n * It was standardized in [RFC 8439](https://datatracker.ietf.org/doc/html/rfc8439) and\n * is now used in TLS 1.3.\n *\n * [XChaCha20](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha)\n * extended-nonce variant is also provided. Similar to XSalsa, it's safe to use with\n * randomly-generated nonces.\n *\n * Check out [PDF](http://cr.yp.to/chacha/chacha-20080128.pdf) and\n * [wiki](https://en.wikipedia.org/wiki/Salsa20).\n * @module\n */\nimport { createCipher, rotl } from \"./_arx.js\";\nimport { poly1305 } from \"./_poly1305.js\";\nimport { clean, equalBytes, getOutput, u64Lengths, wrapCipher, } from \"./utils.js\";\n/**\n * ChaCha core function.\n */\n// prettier-ignore\nfunction chachaCore(s, k, n, out, cnt, rounds = 20) {\n    let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n    y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], // Key      Key     Key     Key\n    y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], // Key      Key     Key     Key\n    y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2]; // Counter  Counter\tNonce   Nonce\n    // Save state to temporary variables\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n    for (let r = 0; r < rounds; r += 2) {\n        x00 = (x00 + x04) | 0;\n        x12 = rotl(x12 ^ x00, 16);\n        x08 = (x08 + x12) | 0;\n        x04 = rotl(x04 ^ x08, 12);\n        x00 = (x00 + x04) | 0;\n        x12 = rotl(x12 ^ x00, 8);\n        x08 = (x08 + x12) | 0;\n        x04 = rotl(x04 ^ x08, 7);\n        x01 = (x01 + x05) | 0;\n        x13 = rotl(x13 ^ x01, 16);\n        x09 = (x09 + x13) | 0;\n        x05 = rotl(x05 ^ x09, 12);\n        x01 = (x01 + x05) | 0;\n        x13 = rotl(x13 ^ x01, 8);\n        x09 = (x09 + x13) | 0;\n        x05 = rotl(x05 ^ x09, 7);\n        x02 = (x02 + x06) | 0;\n        x14 = rotl(x14 ^ x02, 16);\n        x10 = (x10 + x14) | 0;\n        x06 = rotl(x06 ^ x10, 12);\n        x02 = (x02 + x06) | 0;\n        x14 = rotl(x14 ^ x02, 8);\n        x10 = (x10 + x14) | 0;\n        x06 = rotl(x06 ^ x10, 7);\n        x03 = (x03 + x07) | 0;\n        x15 = rotl(x15 ^ x03, 16);\n        x11 = (x11 + x15) | 0;\n        x07 = rotl(x07 ^ x11, 12);\n        x03 = (x03 + x07) | 0;\n        x15 = rotl(x15 ^ x03, 8);\n        x11 = (x11 + x15) | 0;\n        x07 = rotl(x07 ^ x11, 7);\n        x00 = (x00 + x05) | 0;\n        x15 = rotl(x15 ^ x00, 16);\n        x10 = (x10 + x15) | 0;\n        x05 = rotl(x05 ^ x10, 12);\n        x00 = (x00 + x05) | 0;\n        x15 = rotl(x15 ^ x00, 8);\n        x10 = (x10 + x15) | 0;\n        x05 = rotl(x05 ^ x10, 7);\n        x01 = (x01 + x06) | 0;\n        x12 = rotl(x12 ^ x01, 16);\n        x11 = (x11 + x12) | 0;\n        x06 = rotl(x06 ^ x11, 12);\n        x01 = (x01 + x06) | 0;\n        x12 = rotl(x12 ^ x01, 8);\n        x11 = (x11 + x12) | 0;\n        x06 = rotl(x06 ^ x11, 7);\n        x02 = (x02 + x07) | 0;\n        x13 = rotl(x13 ^ x02, 16);\n        x08 = (x08 + x13) | 0;\n        x07 = rotl(x07 ^ x08, 12);\n        x02 = (x02 + x07) | 0;\n        x13 = rotl(x13 ^ x02, 8);\n        x08 = (x08 + x13) | 0;\n        x07 = rotl(x07 ^ x08, 7);\n        x03 = (x03 + x04) | 0;\n        x14 = rotl(x14 ^ x03, 16);\n        x09 = (x09 + x14) | 0;\n        x04 = rotl(x04 ^ x09, 12);\n        x03 = (x03 + x04) | 0;\n        x14 = rotl(x14 ^ x03, 8);\n        x09 = (x09 + x14) | 0;\n        x04 = rotl(x04 ^ x09, 7);\n    }\n    // Write output\n    let oi = 0;\n    out[oi++] = (y00 + x00) | 0;\n    out[oi++] = (y01 + x01) | 0;\n    out[oi++] = (y02 + x02) | 0;\n    out[oi++] = (y03 + x03) | 0;\n    out[oi++] = (y04 + x04) | 0;\n    out[oi++] = (y05 + x05) | 0;\n    out[oi++] = (y06 + x06) | 0;\n    out[oi++] = (y07 + x07) | 0;\n    out[oi++] = (y08 + x08) | 0;\n    out[oi++] = (y09 + x09) | 0;\n    out[oi++] = (y10 + x10) | 0;\n    out[oi++] = (y11 + x11) | 0;\n    out[oi++] = (y12 + x12) | 0;\n    out[oi++] = (y13 + x13) | 0;\n    out[oi++] = (y14 + x14) | 0;\n    out[oi++] = (y15 + x15) | 0;\n}\n/**\n * hchacha helper method, used primarily in xchacha, to hash\n * key and nonce into key' and nonce'.\n * Same as chachaCore, but there doesn't seem to be a way to move the block\n * out without 25% performance hit.\n */\n// prettier-ignore\nexport function hchacha(s, k, i, o32) {\n    let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];\n    for (let r = 0; r < 20; r += 2) {\n        x00 = (x00 + x04) | 0;\n        x12 = rotl(x12 ^ x00, 16);\n        x08 = (x08 + x12) | 0;\n        x04 = rotl(x04 ^ x08, 12);\n        x00 = (x00 + x04) | 0;\n        x12 = rotl(x12 ^ x00, 8);\n        x08 = (x08 + x12) | 0;\n        x04 = rotl(x04 ^ x08, 7);\n        x01 = (x01 + x05) | 0;\n        x13 = rotl(x13 ^ x01, 16);\n        x09 = (x09 + x13) | 0;\n        x05 = rotl(x05 ^ x09, 12);\n        x01 = (x01 + x05) | 0;\n        x13 = rotl(x13 ^ x01, 8);\n        x09 = (x09 + x13) | 0;\n        x05 = rotl(x05 ^ x09, 7);\n        x02 = (x02 + x06) | 0;\n        x14 = rotl(x14 ^ x02, 16);\n        x10 = (x10 + x14) | 0;\n        x06 = rotl(x06 ^ x10, 12);\n        x02 = (x02 + x06) | 0;\n        x14 = rotl(x14 ^ x02, 8);\n        x10 = (x10 + x14) | 0;\n        x06 = rotl(x06 ^ x10, 7);\n        x03 = (x03 + x07) | 0;\n        x15 = rotl(x15 ^ x03, 16);\n        x11 = (x11 + x15) | 0;\n        x07 = rotl(x07 ^ x11, 12);\n        x03 = (x03 + x07) | 0;\n        x15 = rotl(x15 ^ x03, 8);\n        x11 = (x11 + x15) | 0;\n        x07 = rotl(x07 ^ x11, 7);\n        x00 = (x00 + x05) | 0;\n        x15 = rotl(x15 ^ x00, 16);\n        x10 = (x10 + x15) | 0;\n        x05 = rotl(x05 ^ x10, 12);\n        x00 = (x00 + x05) | 0;\n        x15 = rotl(x15 ^ x00, 8);\n        x10 = (x10 + x15) | 0;\n        x05 = rotl(x05 ^ x10, 7);\n        x01 = (x01 + x06) | 0;\n        x12 = rotl(x12 ^ x01, 16);\n        x11 = (x11 + x12) | 0;\n        x06 = rotl(x06 ^ x11, 12);\n        x01 = (x01 + x06) | 0;\n        x12 = rotl(x12 ^ x01, 8);\n        x11 = (x11 + x12) | 0;\n        x06 = rotl(x06 ^ x11, 7);\n        x02 = (x02 + x07) | 0;\n        x13 = rotl(x13 ^ x02, 16);\n        x08 = (x08 + x13) | 0;\n        x07 = rotl(x07 ^ x08, 12);\n        x02 = (x02 + x07) | 0;\n        x13 = rotl(x13 ^ x02, 8);\n        x08 = (x08 + x13) | 0;\n        x07 = rotl(x07 ^ x08, 7);\n        x03 = (x03 + x04) | 0;\n        x14 = rotl(x14 ^ x03, 16);\n        x09 = (x09 + x14) | 0;\n        x04 = rotl(x04 ^ x09, 12);\n        x03 = (x03 + x04) | 0;\n        x14 = rotl(x14 ^ x03, 8);\n        x09 = (x09 + x14) | 0;\n        x04 = rotl(x04 ^ x09, 7);\n    }\n    let oi = 0;\n    o32[oi++] = x00;\n    o32[oi++] = x01;\n    o32[oi++] = x02;\n    o32[oi++] = x03;\n    o32[oi++] = x12;\n    o32[oi++] = x13;\n    o32[oi++] = x14;\n    o32[oi++] = x15;\n}\n/**\n * Original, non-RFC chacha20 from DJB. 8-byte nonce, 8-byte counter.\n */\nexport const chacha20orig = /* @__PURE__ */ createCipher(chachaCore, {\n    counterRight: false,\n    counterLength: 8,\n    allowShortKeys: true,\n});\n/**\n * ChaCha stream cipher. Conforms to RFC 8439 (IETF, TLS). 12-byte nonce, 4-byte counter.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */\nexport const chacha20 = /* @__PURE__ */ createCipher(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    allowShortKeys: false,\n});\n/**\n * XChaCha eXtended-nonce ChaCha. 24-byte nonce.\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n */\nexport const xchacha20 = /* @__PURE__ */ createCipher(chachaCore, {\n    counterRight: false,\n    counterLength: 8,\n    extendNonceFn: hchacha,\n    allowShortKeys: false,\n});\n/**\n * Reduced 8-round chacha, described in original paper.\n */\nexport const chacha8 = /* @__PURE__ */ createCipher(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    rounds: 8,\n});\n/**\n * Reduced 12-round chacha, described in original paper.\n */\nexport const chacha12 = /* @__PURE__ */ createCipher(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    rounds: 12,\n});\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\n// Pad to digest size with zeros\nconst updatePadded = (h, msg) => {\n    h.update(msg);\n    const left = msg.length % 16;\n    if (left)\n        h.update(ZEROS16.subarray(left));\n};\nconst ZEROS32 = /* @__PURE__ */ new Uint8Array(32);\nfunction computeTag(fn, key, nonce, data, AAD) {\n    const authKey = fn(key, nonce, ZEROS32);\n    const h = poly1305.create(authKey);\n    if (AAD)\n        updatePadded(h, AAD);\n    updatePadded(h, data);\n    const num = u64Lengths(data.length, AAD ? AAD.length : 0, true);\n    h.update(num);\n    const res = h.digest();\n    clean(authKey, num);\n    return res;\n}\n/**\n * AEAD algorithm from RFC 8439.\n * Salsa20 and chacha (RFC 8439) use poly1305 differently.\n * We could have composed them similar to:\n * https://github.com/paulmillr/scure-base/blob/b266c73dde977b1dd7ef40ef7a23cc15aab526b3/index.ts#L250\n * But it's hard because of authKey:\n * In salsa20, authKey changes position in salsa stream.\n * In chacha, authKey can't be computed inside computeTag, it modifies the counter.\n */\nexport const _poly1305_aead = (xorStream) => (key, nonce, AAD) => {\n    const tagLength = 16;\n    return {\n        encrypt(plaintext, output) {\n            const plength = plaintext.length;\n            output = getOutput(plength + tagLength, output, false);\n            output.set(plaintext);\n            const oPlain = output.subarray(0, -tagLength);\n            xorStream(key, nonce, oPlain, oPlain, 1);\n            const tag = computeTag(xorStream, key, nonce, oPlain, AAD);\n            output.set(tag, plength); // append tag\n            clean(tag);\n            return output;\n        },\n        decrypt(ciphertext, output) {\n            output = getOutput(ciphertext.length - tagLength, output, false);\n            const data = ciphertext.subarray(0, -tagLength);\n            const passedTag = ciphertext.subarray(-tagLength);\n            const tag = computeTag(xorStream, key, nonce, data, AAD);\n            if (!equalBytes(passedTag, tag))\n                throw new Error('invalid tag');\n            output.set(ciphertext.subarray(0, -tagLength));\n            xorStream(key, nonce, output, output, 1); // start stream with i=1\n            clean(tag);\n            return output;\n        },\n    };\n};\n/**\n * ChaCha20-Poly1305 from RFC 8439.\n *\n * Unsafe to use random nonces under the same key, due to collision chance.\n * Prefer XChaCha instead.\n */\nexport const chacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));\n/**\n * XChaCha20-Poly1305 extended-nonce chacha.\n *\n * Can be safely used with random nonces (CSPRNG).\n * See [IRTF draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha).\n */\nexport const xchacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));\n//# sourceMappingURL=chacha.js.map","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const BURN_DISCRIMINATOR = 8;\n\nexport function getBurnDiscriminatorBytes() {\n  return getU8Encoder().encode(BURN_DISCRIMINATOR);\n}\n\nexport type BurnInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type BurnInstructionData = {\n  /** The amount of tokens to burn. */\n  discriminator: number;\n  amount: bigint;\n};\n\nexport type BurnInstructionDataArgs = { amount: number | bigint };\n\nexport function getBurnInstructionDataEncoder(): FixedSizeEncoder<BurnInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: BURN_DISCRIMINATOR })\n  );\n}\n\nexport function getBurnInstructionDataDecoder(): FixedSizeDecoder<BurnInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getBurnInstructionDataCodec(): FixedSizeCodec<\n  BurnInstructionDataArgs,\n  BurnInstructionData\n> {\n  return combineCodec(\n    getBurnInstructionDataEncoder(),\n    getBurnInstructionDataDecoder()\n  );\n}\n\nexport type BurnInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The account to burn from. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: BurnInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getBurnInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: BurnInput<TAccountAccount, TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): BurnInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getBurnInstructionDataEncoder().encode(\n      args as BurnInstructionDataArgs\n    ),\n    programAddress,\n  } as BurnInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedBurnInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to burn from. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: BurnInstructionData;\n};\n\nexport function parseBurnInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedBurnInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getBurnInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const BURN_CHECKED_DISCRIMINATOR = 15;\n\nexport function getBurnCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(BURN_CHECKED_DISCRIMINATOR);\n}\n\nexport type BurnCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type BurnCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to burn. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type BurnCheckedInstructionDataArgs = {\n  /** The amount of tokens to burn. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getBurnCheckedInstructionDataEncoder(): FixedSizeEncoder<BurnCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: BURN_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getBurnCheckedInstructionDataDecoder(): FixedSizeDecoder<BurnCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getBurnCheckedInstructionDataCodec(): FixedSizeCodec<\n  BurnCheckedInstructionDataArgs,\n  BurnCheckedInstructionData\n> {\n  return combineCodec(\n    getBurnCheckedInstructionDataEncoder(),\n    getBurnCheckedInstructionDataDecoder()\n  );\n}\n\nexport type BurnCheckedInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The account to burn from. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: BurnCheckedInstructionDataArgs['amount'];\n  decimals: BurnCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getBurnCheckedInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: BurnCheckedInput<TAccountAccount, TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): BurnCheckedInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getBurnCheckedInstructionDataEncoder().encode(\n      args as BurnCheckedInstructionDataArgs\n    ),\n    programAddress,\n  } as BurnCheckedInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedBurnCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to burn from. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: BurnCheckedInstructionData;\n};\n\nexport function parseBurnCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedBurnCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getBurnCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash, clean, Hash, toBytes } from \"./utils.js\";\nexport class HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        ahash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        clean(pad);\n    }\n    update(buf) {\n        aexists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        abytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CLOSE_ACCOUNT_DISCRIMINATOR = 9;\n\nexport function getCloseAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(CLOSE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type CloseAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CloseAccountInstructionData = { discriminator: number };\n\nexport type CloseAccountInstructionDataArgs = {};\n\nexport function getCloseAccountInstructionDataEncoder(): FixedSizeEncoder<CloseAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: CLOSE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getCloseAccountInstructionDataDecoder(): FixedSizeDecoder<CloseAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCloseAccountInstructionDataCodec(): FixedSizeCodec<\n  CloseAccountInstructionDataArgs,\n  CloseAccountInstructionData\n> {\n  return combineCodec(\n    getCloseAccountInstructionDataEncoder(),\n    getCloseAccountInstructionDataDecoder()\n  );\n}\n\nexport type CloseAccountInput<\n  TAccountAccount extends string = string,\n  TAccountDestination extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The account to close. */\n  account: Address<TAccountAccount>;\n  /** The destination account. */\n  destination: Address<TAccountDestination>;\n  /** The account's owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getCloseAccountInstruction<\n  TAccountAccount extends string,\n  TAccountDestination extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: CloseAccountInput<TAccountAccount, TAccountDestination, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): CloseAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountDestination,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getCloseAccountInstructionDataEncoder().encode({}),\n    programAddress,\n  } as CloseAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountDestination,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedCloseAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to close. */\n    account: TAccountMetas[0];\n    /** The destination account. */\n    destination: TAccountMetas[1];\n    /** The account's owner or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: CloseAccountInstructionData;\n};\n\nexport function parseCloseAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedCloseAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      destination: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getCloseAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CONFIDENTIAL_DEPOSIT_DISCRIMINATOR = 27;\n\nexport function getConfidentialDepositDiscriminatorBytes() {\n  return getU8Encoder().encode(CONFIDENTIAL_DEPOSIT_DISCRIMINATOR);\n}\n\nexport const CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 5;\n\nexport function getConfidentialDepositConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ConfidentialDepositInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ConfidentialDepositInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /** The amount of tokens to deposit. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type ConfidentialDepositInstructionDataArgs = {\n  /** The amount of tokens to deposit. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getConfidentialDepositInstructionDataEncoder(): FixedSizeEncoder<ConfidentialDepositInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIDENTIAL_DEPOSIT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getConfidentialDepositInstructionDataDecoder(): FixedSizeDecoder<ConfidentialDepositInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getConfidentialDepositInstructionDataCodec(): FixedSizeCodec<\n  ConfidentialDepositInstructionDataArgs,\n  ConfidentialDepositInstructionData\n> {\n  return combineCodec(\n    getConfidentialDepositInstructionDataEncoder(),\n    getConfidentialDepositInstructionDataDecoder()\n  );\n}\n\nexport type ConfidentialDepositInput<\n  TAccountToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: ConfidentialDepositInstructionDataArgs['amount'];\n  decimals: ConfidentialDepositInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getConfidentialDepositInstruction<\n  TAccountToken extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ConfidentialDepositInput<\n    TAccountToken,\n    TAccountMint,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ConfidentialDepositInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getConfidentialDepositInstructionDataEncoder().encode(\n      args as ConfidentialDepositInstructionDataArgs\n    ),\n    programAddress,\n  } as ConfidentialDepositInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedConfidentialDepositInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: ConfidentialDepositInstructionData;\n};\n\nexport function parseConfidentialDepositInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedConfidentialDepositInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getConfidentialDepositInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * HKDF (RFC 5869): extract + expand in one step.\n * See https://soatok.blog/2021/11/17/understanding-hkdf/.\n * @module\n */\nimport { hmac } from \"./hmac.js\";\nimport { ahash, anumber, clean, toBytes } from \"./utils.js\";\n/**\n * HKDF-extract from spec. Less important part. `HKDF-Extract(IKM, salt) -> PRK`\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n */\nexport function extract(hash, ikm, salt) {\n    ahash(hash);\n    // NOTE: some libraries treat zero-length array as 'not provided';\n    // we don't, since we have undefined as 'not provided'\n    // https://github.com/RustCrypto/KDFs/issues/15\n    if (salt === undefined)\n        salt = new Uint8Array(hash.outputLen);\n    return hmac(hash, toBytes(salt), toBytes(ikm));\n}\nconst HKDF_COUNTER = /* @__PURE__ */ Uint8Array.from([0]);\nconst EMPTY_BUFFER = /* @__PURE__ */ Uint8Array.of();\n/**\n * HKDF-expand from the spec. The most important part. `HKDF-Expand(PRK, info, L) -> OKM`\n * @param hash - hash function that would be used (e.g. sha256)\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in bytes\n */\nexport function expand(hash, prk, info, length = 32) {\n    ahash(hash);\n    anumber(length);\n    const olen = hash.outputLen;\n    if (length > 255 * olen)\n        throw new Error('Length should be <= 255*HashLen');\n    const blocks = Math.ceil(length / olen);\n    if (info === undefined)\n        info = EMPTY_BUFFER;\n    // first L(ength) octets of T\n    const okm = new Uint8Array(blocks * olen);\n    // Re-use HMAC instance between blocks\n    const HMAC = hmac.create(hash, prk);\n    const HMACTmp = HMAC._cloneInto();\n    const T = new Uint8Array(HMAC.outputLen);\n    for (let counter = 0; counter < blocks; counter++) {\n        HKDF_COUNTER[0] = counter + 1;\n        // T(0) = empty string (zero length)\n        // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n        HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n            .update(info)\n            .update(HKDF_COUNTER)\n            .digestInto(T);\n        okm.set(T, olen * counter);\n        HMAC._cloneInto(HMACTmp);\n    }\n    HMAC.destroy();\n    HMACTmp.destroy();\n    clean(T, HKDF_COUNTER);\n    return okm.slice(0, length);\n}\n/**\n * HKDF (RFC 5869): derive keys from an initial input.\n * Combines hkdf_extract + hkdf_expand in one step\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in bytes\n * @example\n * import { hkdf } from '@noble/hashes/hkdf';\n * import { sha256 } from '@noble/hashes/sha2';\n * import { randomBytes } from '@noble/hashes/utils';\n * const inputKey = randomBytes(32);\n * const salt = randomBytes(32);\n * const info = 'application-key';\n * const hk1 = hkdf(sha256, inputKey, salt, info, 32);\n */\nexport const hkdf = (hash, ikm, salt, info, length) => expand(hash, extract(hash, ikm, salt), info, length);\n//# sourceMappingURL=hkdf.js.map","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 27;\n\nexport function getConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(CONFIDENTIAL_TRANSFER_DISCRIMINATOR);\n}\n\nexport const CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 7;\n\nexport function getConfidentialTransferConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ConfidentialTransferInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSourceToken extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountDestinationToken extends string | AccountMeta<string> = string,\n  TAccountInstructionsSysvar extends string | AccountMeta<string> = string,\n  TAccountEqualityRecord extends string | AccountMeta<string> = string,\n  TAccountCiphertextValidityRecord extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountRangeRecord extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSourceToken extends string\n        ? WritableAccount<TAccountSourceToken>\n        : TAccountSourceToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestinationToken extends string\n        ? WritableAccount<TAccountDestinationToken>\n        : TAccountDestinationToken,\n      TAccountInstructionsSysvar extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvar>\n        : TAccountInstructionsSysvar,\n      TAccountEqualityRecord extends string\n        ? ReadonlyAccount<TAccountEqualityRecord>\n        : TAccountEqualityRecord,\n      TAccountCiphertextValidityRecord extends string\n        ? ReadonlyAccount<TAccountCiphertextValidityRecord>\n        : TAccountCiphertextValidityRecord,\n      TAccountRangeRecord extends string\n        ? ReadonlyAccount<TAccountRangeRecord>\n        : TAccountRangeRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ConfidentialTransferInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /** The new source decryptable balance if the transfer succeeds. */\n  newSourceDecryptableAvailableBalance: DecryptableBalance;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `Transfer` instruction in the transaction. If the offset is\n   * `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext3HandlesValidity`\n   * instruction to the `Transfer` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  ciphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU128Data`\n   * instruction to the `Transfer` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport type ConfidentialTransferInstructionDataArgs = {\n  /** The new source decryptable balance if the transfer succeeds. */\n  newSourceDecryptableAvailableBalance: DecryptableBalanceArgs;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `Transfer` instruction in the transaction. If the offset is\n   * `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext3HandlesValidity`\n   * instruction to the `Transfer` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  ciphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU128Data`\n   * instruction to the `Transfer` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport function getConfidentialTransferInstructionDataEncoder(): FixedSizeEncoder<ConfidentialTransferInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['newSourceDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n      ['equalityProofInstructionOffset', getI8Encoder()],\n      ['ciphertextValidityProofInstructionOffset', getI8Encoder()],\n      ['rangeProofInstructionOffset', getI8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getConfidentialTransferInstructionDataDecoder(): FixedSizeDecoder<ConfidentialTransferInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['newSourceDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n    ['equalityProofInstructionOffset', getI8Decoder()],\n    ['ciphertextValidityProofInstructionOffset', getI8Decoder()],\n    ['rangeProofInstructionOffset', getI8Decoder()],\n  ]);\n}\n\nexport function getConfidentialTransferInstructionDataCodec(): FixedSizeCodec<\n  ConfidentialTransferInstructionDataArgs,\n  ConfidentialTransferInstructionData\n> {\n  return combineCodec(\n    getConfidentialTransferInstructionDataEncoder(),\n    getConfidentialTransferInstructionDataDecoder()\n  );\n}\n\nexport type ConfidentialTransferInput<\n  TAccountSourceToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountDestinationToken extends string = string,\n  TAccountInstructionsSysvar extends string = string,\n  TAccountEqualityRecord extends string = string,\n  TAccountCiphertextValidityRecord extends string = string,\n  TAccountRangeRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source SPL Token account. */\n  sourceToken: Address<TAccountSourceToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /** The destination SPL Token account. */\n  destinationToken: Address<TAccountDestinationToken>;\n  /**\n   * (Optional) Instructions sysvar if at least one of the\n   * `zk_elgamal_proof` instructions are included in the same\n   * transaction.\n   */\n  instructionsSysvar?: Address<TAccountInstructionsSysvar>;\n  /** (Optional) Equality proof record account or context state account. */\n  equalityRecord?: Address<TAccountEqualityRecord>;\n  /** (Optional) Ciphertext validity proof record account or context state account. */\n  ciphertextValidityRecord?: Address<TAccountCiphertextValidityRecord>;\n  /** (Optional) Range proof record account or context state account. */\n  rangeRecord?: Address<TAccountRangeRecord>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  newSourceDecryptableAvailableBalance: ConfidentialTransferInstructionDataArgs['newSourceDecryptableAvailableBalance'];\n  equalityProofInstructionOffset: ConfidentialTransferInstructionDataArgs['equalityProofInstructionOffset'];\n  ciphertextValidityProofInstructionOffset: ConfidentialTransferInstructionDataArgs['ciphertextValidityProofInstructionOffset'];\n  rangeProofInstructionOffset: ConfidentialTransferInstructionDataArgs['rangeProofInstructionOffset'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getConfidentialTransferInstruction<\n  TAccountSourceToken extends string,\n  TAccountMint extends string,\n  TAccountDestinationToken extends string,\n  TAccountInstructionsSysvar extends string,\n  TAccountEqualityRecord extends string,\n  TAccountCiphertextValidityRecord extends string,\n  TAccountRangeRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ConfidentialTransferInput<\n    TAccountSourceToken,\n    TAccountMint,\n    TAccountDestinationToken,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountCiphertextValidityRecord,\n    TAccountRangeRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ConfidentialTransferInstruction<\n  TProgramAddress,\n  TAccountSourceToken,\n  TAccountMint,\n  TAccountDestinationToken,\n  TAccountInstructionsSysvar,\n  TAccountEqualityRecord,\n  TAccountCiphertextValidityRecord,\n  TAccountRangeRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    sourceToken: { value: input.sourceToken ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destinationToken: {\n      value: input.destinationToken ?? null,\n      isWritable: true,\n    },\n    instructionsSysvar: {\n      value: input.instructionsSysvar ?? null,\n      isWritable: false,\n    },\n    equalityRecord: { value: input.equalityRecord ?? null, isWritable: false },\n    ciphertextValidityRecord: {\n      value: input.ciphertextValidityRecord ?? null,\n      isWritable: false,\n    },\n    rangeRecord: { value: input.rangeRecord ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.sourceToken),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destinationToken),\n      getAccountMeta(accounts.instructionsSysvar),\n      getAccountMeta(accounts.equalityRecord),\n      getAccountMeta(accounts.ciphertextValidityRecord),\n      getAccountMeta(accounts.rangeRecord),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getConfidentialTransferInstructionDataEncoder().encode(\n      args as ConfidentialTransferInstructionDataArgs\n    ),\n    programAddress,\n  } as ConfidentialTransferInstruction<\n    TProgramAddress,\n    TAccountSourceToken,\n    TAccountMint,\n    TAccountDestinationToken,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountCiphertextValidityRecord,\n    TAccountRangeRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedConfidentialTransferInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source SPL Token account. */\n    sourceToken: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /** The destination SPL Token account. */\n    destinationToken: TAccountMetas[2];\n    /**\n     * (Optional) Instructions sysvar if at least one of the\n     * `zk_elgamal_proof` instructions are included in the same\n     * transaction.\n     */\n    instructionsSysvar?: TAccountMetas[3] | undefined;\n    /** (Optional) Equality proof record account or context state account. */\n    equalityRecord?: TAccountMetas[4] | undefined;\n    /** (Optional) Ciphertext validity proof record account or context state account. */\n    ciphertextValidityRecord?: TAccountMetas[5] | undefined;\n    /** (Optional) Range proof record account or context state account. */\n    rangeRecord?: TAccountMetas[6] | undefined;\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[7];\n  };\n  data: ConfidentialTransferInstructionData;\n};\n\nexport function parseConfidentialTransferInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedConfidentialTransferInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 8) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      sourceToken: getNextAccount(),\n      mint: getNextAccount(),\n      destinationToken: getNextAccount(),\n      instructionsSysvar: getNextOptionalAccount(),\n      equalityRecord: getNextOptionalAccount(),\n      ciphertextValidityRecord: getNextOptionalAccount(),\n      rangeRecord: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getConfidentialTransferInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { abytes as abytes_, bytesToHex as bytesToHex_, concatBytes as concatBytes_, hexToBytes as hexToBytes_, isBytes as isBytes_, } from '@noble/hashes/utils.js';\nexport { abytes, anumber, bytesToHex, bytesToUtf8, concatBytes, hexToBytes, isBytes, randomBytes, utf8ToBytes, } from '@noble/hashes/utils.js';\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport function abool(title, value) {\n    if (typeof value !== 'boolean')\n        throw new Error(title + ' boolean expected, got ' + value);\n}\n// tmp name until v2\nexport function _abool2(value, title = '') {\n    if (typeof value !== 'boolean') {\n        const prefix = title && `\"${title}\"`;\n        throw new Error(prefix + 'expected boolean, got type=' + typeof value);\n    }\n    return value;\n}\n// tmp name until v2\n/** Asserts something is Uint8Array. */\nexport function _abytes2(value, length, title = '') {\n    const bytes = isBytes_(value);\n    const len = value?.length;\n    const needsLen = length !== undefined;\n    if (!bytes || (needsLen && len !== length)) {\n        const prefix = title && `\"${title}\" `;\n        const ofLen = needsLen ? ` of length ${length}` : '';\n        const got = bytes ? `length=${len}` : `type=${typeof value}`;\n        throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n    }\n    return value;\n}\n// Used in weierstrass, der\nexport function numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex_(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n    abytes_(bytes);\n    return hexToNumber(bytesToHex_(Uint8Array.from(bytes).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n    return hexToBytes_(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n    return hexToBytes_(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'secret key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes_(hex);\n        }\n        catch (e) {\n            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n        }\n    }\n    else if (isBytes_(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(title + ' must be hex string or Uint8Array');\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,\n * and Buffer#slice creates mutable copy. Never use Buffers!\n */\nexport function copyBytes(bytes) {\n    return Uint8Array.from(bytes);\n}\n/**\n * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols\n * Should be safe to use for things expected to be ASCII.\n * Returns exact same result as utf8ToBytes for ASCII or throws.\n */\nexport function asciiToBytes(ascii) {\n    return Uint8Array.from(ascii, (c, i) => {\n        const charCode = c.charCodeAt(0);\n        if (c.length !== 1 || charCode > 127) {\n            throw new Error(`string contains non-ASCII character \"${ascii[i]}\" with code ${charCode} at position ${i}`);\n        }\n        return charCode;\n    });\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\n// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\n// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nexport function inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n) => (_1n << BigInt(n)) - _1n;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    const u8n = (len) => new Uint8Array(len); // creates Uint8Array\n    const u8of = (byte) => Uint8Array.of(byte); // another shortcut\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0)) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes_(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes_(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nexport function validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error('invalid validator function');\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\nexport function isHash(val) {\n    return typeof val === 'function' && Number.isSafeInteger(val.outputLen);\n}\nexport function _validateObject(object, fields, optFields = {}) {\n    if (!object || typeof object !== 'object')\n        throw new Error('expected valid options object');\n    function checkField(fieldName, expectedType, isOpt) {\n        const val = object[fieldName];\n        if (isOpt && val === undefined)\n            return;\n        const current = typeof val;\n        if (current !== expectedType || val === null)\n            throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n    }\n    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));\n    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));\n}\n/**\n * throws not implemented error\n */\nexport const notImplemented = () => {\n    throw new Error('not implemented');\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR = 27;\n\nexport function getConfidentialTransferWithFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR);\n}\n\nexport const CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 13;\n\nexport function getConfidentialTransferWithFeeConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ConfidentialTransferWithFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSourceToken extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountDestinationToken extends string | AccountMeta<string> = string,\n  TAccountInstructionsSysvar extends string | AccountMeta<string> = string,\n  TAccountEqualityRecord extends string | AccountMeta<string> = string,\n  TAccountTransferAmountCiphertextValidityRecord extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountFeeSigmaRecord extends string | AccountMeta<string> = string,\n  TAccountFeeCiphertextValidityRecord extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountRangeRecord extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSourceToken extends string\n        ? WritableAccount<TAccountSourceToken>\n        : TAccountSourceToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestinationToken extends string\n        ? WritableAccount<TAccountDestinationToken>\n        : TAccountDestinationToken,\n      TAccountInstructionsSysvar extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvar>\n        : TAccountInstructionsSysvar,\n      TAccountEqualityRecord extends string\n        ? ReadonlyAccount<TAccountEqualityRecord>\n        : TAccountEqualityRecord,\n      TAccountTransferAmountCiphertextValidityRecord extends string\n        ? ReadonlyAccount<TAccountTransferAmountCiphertextValidityRecord>\n        : TAccountTransferAmountCiphertextValidityRecord,\n      TAccountFeeSigmaRecord extends string\n        ? ReadonlyAccount<TAccountFeeSigmaRecord>\n        : TAccountFeeSigmaRecord,\n      TAccountFeeCiphertextValidityRecord extends string\n        ? ReadonlyAccount<TAccountFeeCiphertextValidityRecord>\n        : TAccountFeeCiphertextValidityRecord,\n      TAccountRangeRecord extends string\n        ? ReadonlyAccount<TAccountRangeRecord>\n        : TAccountRangeRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ConfidentialTransferWithFeeInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /** The new source decryptable balance if the transfer succeeds. */\n  newSourceDecryptableAvailableBalance: DecryptableBalance;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `TransferWithFee` instruction in the transaction. If the offset\n   * is `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext3HandlesValidity`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  transferAmountCiphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::VerifyPercentageWithFee`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  feeSigmaProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext2HandlesValidity`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  feeCiphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU256Data`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport type ConfidentialTransferWithFeeInstructionDataArgs = {\n  /** The new source decryptable balance if the transfer succeeds. */\n  newSourceDecryptableAvailableBalance: DecryptableBalanceArgs;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `TransferWithFee` instruction in the transaction. If the offset\n   * is `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext3HandlesValidity`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  transferAmountCiphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::VerifyPercentageWithFee`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  feeSigmaProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext2HandlesValidity`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  feeCiphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU256Data`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport function getConfidentialTransferWithFeeInstructionDataEncoder(): FixedSizeEncoder<ConfidentialTransferWithFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['newSourceDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n      ['equalityProofInstructionOffset', getI8Encoder()],\n      [\n        'transferAmountCiphertextValidityProofInstructionOffset',\n        getI8Encoder(),\n      ],\n      ['feeSigmaProofInstructionOffset', getI8Encoder()],\n      ['feeCiphertextValidityProofInstructionOffset', getI8Encoder()],\n      ['rangeProofInstructionOffset', getI8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getConfidentialTransferWithFeeInstructionDataDecoder(): FixedSizeDecoder<ConfidentialTransferWithFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['newSourceDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n    ['equalityProofInstructionOffset', getI8Decoder()],\n    ['transferAmountCiphertextValidityProofInstructionOffset', getI8Decoder()],\n    ['feeSigmaProofInstructionOffset', getI8Decoder()],\n    ['feeCiphertextValidityProofInstructionOffset', getI8Decoder()],\n    ['rangeProofInstructionOffset', getI8Decoder()],\n  ]);\n}\n\nexport function getConfidentialTransferWithFeeInstructionDataCodec(): FixedSizeCodec<\n  ConfidentialTransferWithFeeInstructionDataArgs,\n  ConfidentialTransferWithFeeInstructionData\n> {\n  return combineCodec(\n    getConfidentialTransferWithFeeInstructionDataEncoder(),\n    getConfidentialTransferWithFeeInstructionDataDecoder()\n  );\n}\n\nexport type ConfidentialTransferWithFeeInput<\n  TAccountSourceToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountDestinationToken extends string = string,\n  TAccountInstructionsSysvar extends string = string,\n  TAccountEqualityRecord extends string = string,\n  TAccountTransferAmountCiphertextValidityRecord extends string = string,\n  TAccountFeeSigmaRecord extends string = string,\n  TAccountFeeCiphertextValidityRecord extends string = string,\n  TAccountRangeRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source SPL Token account. */\n  sourceToken: Address<TAccountSourceToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /** The destination SPL Token account. */\n  destinationToken: Address<TAccountDestinationToken>;\n  /**\n   * (Optional) Instructions sysvar if at least one of the\n   * `zk_elgamal_proof` instructions are included in the same\n   * transaction.\n   */\n  instructionsSysvar?: Address<TAccountInstructionsSysvar>;\n  /** (Optional) Equality proof record account or context state account. */\n  equalityRecord?: Address<TAccountEqualityRecord>;\n  /**\n   * (Optional) Transfer amount ciphertext validity proof record\n   * account or context state account.\n   */\n  transferAmountCiphertextValidityRecord?: Address<TAccountTransferAmountCiphertextValidityRecord>;\n  /** (Optional) Fee sigma proof record account or context state account. */\n  feeSigmaRecord?: Address<TAccountFeeSigmaRecord>;\n  /** (Optional) Fee ciphertext validity proof record account or context state account. */\n  feeCiphertextValidityRecord?: Address<TAccountFeeCiphertextValidityRecord>;\n  /** (Optional) Range proof record account or context state account. */\n  rangeRecord?: Address<TAccountRangeRecord>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  newSourceDecryptableAvailableBalance: ConfidentialTransferWithFeeInstructionDataArgs['newSourceDecryptableAvailableBalance'];\n  equalityProofInstructionOffset: ConfidentialTransferWithFeeInstructionDataArgs['equalityProofInstructionOffset'];\n  transferAmountCiphertextValidityProofInstructionOffset: ConfidentialTransferWithFeeInstructionDataArgs['transferAmountCiphertextValidityProofInstructionOffset'];\n  feeSigmaProofInstructionOffset: ConfidentialTransferWithFeeInstructionDataArgs['feeSigmaProofInstructionOffset'];\n  feeCiphertextValidityProofInstructionOffset: ConfidentialTransferWithFeeInstructionDataArgs['feeCiphertextValidityProofInstructionOffset'];\n  rangeProofInstructionOffset: ConfidentialTransferWithFeeInstructionDataArgs['rangeProofInstructionOffset'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getConfidentialTransferWithFeeInstruction<\n  TAccountSourceToken extends string,\n  TAccountMint extends string,\n  TAccountDestinationToken extends string,\n  TAccountInstructionsSysvar extends string,\n  TAccountEqualityRecord extends string,\n  TAccountTransferAmountCiphertextValidityRecord extends string,\n  TAccountFeeSigmaRecord extends string,\n  TAccountFeeCiphertextValidityRecord extends string,\n  TAccountRangeRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ConfidentialTransferWithFeeInput<\n    TAccountSourceToken,\n    TAccountMint,\n    TAccountDestinationToken,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountTransferAmountCiphertextValidityRecord,\n    TAccountFeeSigmaRecord,\n    TAccountFeeCiphertextValidityRecord,\n    TAccountRangeRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ConfidentialTransferWithFeeInstruction<\n  TProgramAddress,\n  TAccountSourceToken,\n  TAccountMint,\n  TAccountDestinationToken,\n  TAccountInstructionsSysvar,\n  TAccountEqualityRecord,\n  TAccountTransferAmountCiphertextValidityRecord,\n  TAccountFeeSigmaRecord,\n  TAccountFeeCiphertextValidityRecord,\n  TAccountRangeRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    sourceToken: { value: input.sourceToken ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destinationToken: {\n      value: input.destinationToken ?? null,\n      isWritable: true,\n    },\n    instructionsSysvar: {\n      value: input.instructionsSysvar ?? null,\n      isWritable: false,\n    },\n    equalityRecord: { value: input.equalityRecord ?? null, isWritable: false },\n    transferAmountCiphertextValidityRecord: {\n      value: input.transferAmountCiphertextValidityRecord ?? null,\n      isWritable: false,\n    },\n    feeSigmaRecord: { value: input.feeSigmaRecord ?? null, isWritable: false },\n    feeCiphertextValidityRecord: {\n      value: input.feeCiphertextValidityRecord ?? null,\n      isWritable: false,\n    },\n    rangeRecord: { value: input.rangeRecord ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.sourceToken),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destinationToken),\n      getAccountMeta(accounts.instructionsSysvar),\n      getAccountMeta(accounts.equalityRecord),\n      getAccountMeta(accounts.transferAmountCiphertextValidityRecord),\n      getAccountMeta(accounts.feeSigmaRecord),\n      getAccountMeta(accounts.feeCiphertextValidityRecord),\n      getAccountMeta(accounts.rangeRecord),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getConfidentialTransferWithFeeInstructionDataEncoder().encode(\n      args as ConfidentialTransferWithFeeInstructionDataArgs\n    ),\n    programAddress,\n  } as ConfidentialTransferWithFeeInstruction<\n    TProgramAddress,\n    TAccountSourceToken,\n    TAccountMint,\n    TAccountDestinationToken,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountTransferAmountCiphertextValidityRecord,\n    TAccountFeeSigmaRecord,\n    TAccountFeeCiphertextValidityRecord,\n    TAccountRangeRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedConfidentialTransferWithFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source SPL Token account. */\n    sourceToken: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /** The destination SPL Token account. */\n    destinationToken: TAccountMetas[2];\n    /**\n     * (Optional) Instructions sysvar if at least one of the\n     * `zk_elgamal_proof` instructions are included in the same\n     * transaction.\n     */\n    instructionsSysvar?: TAccountMetas[3] | undefined;\n    /** (Optional) Equality proof record account or context state account. */\n    equalityRecord?: TAccountMetas[4] | undefined;\n    /**\n     * (Optional) Transfer amount ciphertext validity proof record\n     * account or context state account.\n     */\n    transferAmountCiphertextValidityRecord?: TAccountMetas[5] | undefined;\n    /** (Optional) Fee sigma proof record account or context state account. */\n    feeSigmaRecord?: TAccountMetas[6] | undefined;\n    /** (Optional) Fee ciphertext validity proof record account or context state account. */\n    feeCiphertextValidityRecord?: TAccountMetas[7] | undefined;\n    /** (Optional) Range proof record account or context state account. */\n    rangeRecord?: TAccountMetas[8] | undefined;\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[9];\n  };\n  data: ConfidentialTransferWithFeeInstructionData;\n};\n\nexport function parseConfidentialTransferWithFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedConfidentialTransferWithFeeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 10) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      sourceToken: getNextAccount(),\n      mint: getNextAccount(),\n      destinationToken: getNextAccount(),\n      instructionsSysvar: getNextOptionalAccount(),\n      equalityRecord: getNextOptionalAccount(),\n      transferAmountCiphertextValidityRecord: getNextOptionalAccount(),\n      feeSigmaRecord: getNextOptionalAccount(),\n      feeCiphertextValidityRecord: getNextOptionalAccount(),\n      rangeRecord: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getConfidentialTransferWithFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { _validateObject, anumber, bitMask, bytesToNumberBE, bytesToNumberLE, ensureBytes, numberToBytesBE, numberToBytesLE, } from \"../utils.js\";\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _7n = /* @__PURE__ */ BigInt(7);\n// prettier-ignore\nconst _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nexport function mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction assertIsSquare(Fp, root, n) {\n    if (!Fp.eql(Fp.sqr(root), n))\n        throw new Error('Cannot find square root');\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    assertIsSquare(Fp, root, n);\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    assertIsSquare(Fp, root, n);\n    return root;\n}\n// Based on RFC9380, Kong algorithm\n// prettier-ignore\nfunction sqrt9mod16(P) {\n    const Fp_ = Field(P);\n    const tn = tonelliShanks(P);\n    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    const c2 = tn(Fp_, c1); //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    const c3 = tn(Fp_, Fp_.neg(c1)); //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    const c4 = (P + _7n) / _16n; //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    return (Fp, n) => {\n        let tv1 = Fp.pow(n, c4); //  1. tv1 = x^c4\n        let tv2 = Fp.mul(tv1, c1); //  2. tv2 = c1 * tv1\n        const tv3 = Fp.mul(tv1, c2); //  3. tv3 = c2 * tv1\n        const tv4 = Fp.mul(tv1, c3); //  4. tv4 = c3 * tv1\n        const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x\n        const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x\n        tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x\n        const root = Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2\n        assertIsSquare(Fp, root, n);\n        return root;\n    };\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n    // Initialization (precomputation).\n    // Caching initialization could boost perf by 7%.\n    if (P < _3n)\n        throw new Error('sqrt is not defined for small field');\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while (Q % _2n === _0n) {\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while (FpLegendre(_Fp, Z) === 1) {\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000)\n            throw new Error('Cannot find square root: probably non-prime P');\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1)\n        return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n))\n            return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1)\n            throw new Error('Cannot find square root');\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while (!Fp.eql(t, Fp.ONE)) {\n            if (Fp.is0(t))\n                return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i)  1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while (!Fp.eql(t_tmp, Fp.ONE)) {\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M)\n                    throw new Error('Cannot find square root');\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P  3 (mod 4)\n * 2. P  5 (mod 8)\n * 3. P  9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P) {\n    // P  3 (mod 4) => n = n^((P+1)/4)\n    if (P % _4n === _3n)\n        return sqrt3mod4;\n    // P  5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n)\n        return sqrt5mod8;\n    // P  9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)\n    if (P % _16n === _9n)\n        return sqrt9mod16(P);\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nexport function validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'number',\n        BITS: 'number',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    _validateObject(field, opts);\n    // const max = 16384;\n    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n    return field;\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(Fp, num, power) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return Fp.ONE;\n    if (power === _1n)\n        return num;\n    let p = Fp.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nexport function FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nexport function FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p)  1    if a is a square (mod p), quadratic residue\n * * (a | p)  -1   if a is not a square (mod p), quadratic non residue\n * * (a | p)  0    if a  0 (mod p)\n */\nexport function FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no)\n        throw new Error('invalid Legendre symbol result');\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined)\n        anumber(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, bitLenOrOpts, // TODO: use opts only in v2?\nisLE = false, opts = {}) {\n    if (ORDER <= _0n)\n        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    let _nbitLength = undefined;\n    let _sqrt = undefined;\n    let modFromBytes = false;\n    let allowedLengths = undefined;\n    if (typeof bitLenOrOpts === 'object' && bitLenOrOpts != null) {\n        if (opts.sqrt || isLE)\n            throw new Error('cannot specify opts in two arguments');\n        const _opts = bitLenOrOpts;\n        if (_opts.BITS)\n            _nbitLength = _opts.BITS;\n        if (_opts.sqrt)\n            _sqrt = _opts.sqrt;\n        if (typeof _opts.isLE === 'boolean')\n            isLE = _opts.isLE;\n        if (typeof _opts.modFromBytes === 'boolean')\n            modFromBytes = _opts.modFromBytes;\n        allowedLengths = _opts.allowedLengths;\n    }\n    else {\n        if (typeof bitLenOrOpts === 'number')\n            _nbitLength = bitLenOrOpts;\n        if (opts.sqrt)\n            _sqrt = opts.sqrt;\n    }\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);\n    if (BYTES > 2048)\n        throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: bitMask(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        allowedLengths: allowedLengths,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error('invalid field element: expected bigint, got ' + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        // is valid and invertible\n        isValidNot0: (num) => !f.is0(num) && f.isValid(num),\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: _sqrt ||\n            ((n) => {\n                if (!sqrtP)\n                    sqrtP = FpSqrt(ORDER);\n                return sqrtP(f, n);\n            }),\n        toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n        fromBytes: (bytes, skipValidation = true) => {\n            if (allowedLengths) {\n                if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n                    throw new Error('Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length);\n                }\n                const padded = new Uint8Array(BYTES);\n                // isLE add 0 to right, !isLE to the left.\n                padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n                bytes = padded;\n            }\n            if (bytes.length !== BYTES)\n                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n            let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n            if (modFromBytes)\n                scalar = mod(scalar, ORDER);\n            if (!skipValidation)\n                if (!f.isValid(scalar))\n                    throw new Error('invalid field element: outside of range 0..ORDER');\n            // NOTE: we don't validate scalar here, please use isValid. This done such way because some\n            // protocol may allow non-reduced scalar that reduced later or changed some other way.\n            return scalar;\n        },\n        // TODO: we don't need it here, move out to separate fn\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // We can't move this out because Fp6, Fp12 implement it\n        // and it's unclear what to return in there.\n        cmov: (a, b, c) => (c ? b : a),\n    });\n    return Object.freeze(f);\n}\n// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?\n// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).\n// which mean we cannot force this via opts.\n// Not sure what to do with randomBytes, we can accept it inside opts if wanted.\n// Probably need to export getMinHashLength somewhere?\n// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {\n//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;\n//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?\n//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;\n//   return reduced;\n// },\nexport function FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nexport function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = ensureBytes('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n    const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const CONFIDENTIAL_WITHDRAW_DISCRIMINATOR = 27;\n\nexport function getConfidentialWithdrawDiscriminatorBytes() {\n  return getU8Encoder().encode(CONFIDENTIAL_WITHDRAW_DISCRIMINATOR);\n}\n\nexport const CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 6;\n\nexport function getConfidentialWithdrawConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ConfidentialWithdrawInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountInstructionsSysvar extends string | AccountMeta<string> = string,\n  TAccountEqualityRecord extends string | AccountMeta<string> = string,\n  TAccountRangeRecord extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountInstructionsSysvar extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvar>\n        : TAccountInstructionsSysvar,\n      TAccountEqualityRecord extends string\n        ? ReadonlyAccount<TAccountEqualityRecord>\n        : TAccountEqualityRecord,\n      TAccountRangeRecord extends string\n        ? ReadonlyAccount<TAccountRangeRecord>\n        : TAccountRangeRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ConfidentialWithdrawInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /** The amount of tokens to withdraw. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The new decryptable balance if the withdrawal succeeds. */\n  newDecryptableAvailableBalance: DecryptableBalance;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `Withdraw` instruction in the transaction. If the offset is\n   * `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU64`\n   * instruction to the `Withdraw` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport type ConfidentialWithdrawInstructionDataArgs = {\n  /** The amount of tokens to withdraw. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The new decryptable balance if the withdrawal succeeds. */\n  newDecryptableAvailableBalance: DecryptableBalanceArgs;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `Withdraw` instruction in the transaction. If the offset is\n   * `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU64`\n   * instruction to the `Withdraw` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport function getConfidentialWithdrawInstructionDataEncoder(): FixedSizeEncoder<ConfidentialWithdrawInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n      ['newDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n      ['equalityProofInstructionOffset', getI8Encoder()],\n      ['rangeProofInstructionOffset', getI8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIDENTIAL_WITHDRAW_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getConfidentialWithdrawInstructionDataDecoder(): FixedSizeDecoder<ConfidentialWithdrawInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n    ['newDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n    ['equalityProofInstructionOffset', getI8Decoder()],\n    ['rangeProofInstructionOffset', getI8Decoder()],\n  ]);\n}\n\nexport function getConfidentialWithdrawInstructionDataCodec(): FixedSizeCodec<\n  ConfidentialWithdrawInstructionDataArgs,\n  ConfidentialWithdrawInstructionData\n> {\n  return combineCodec(\n    getConfidentialWithdrawInstructionDataEncoder(),\n    getConfidentialWithdrawInstructionDataDecoder()\n  );\n}\n\nexport type ConfidentialWithdrawInput<\n  TAccountToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountInstructionsSysvar extends string = string,\n  TAccountEqualityRecord extends string = string,\n  TAccountRangeRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /**\n   * Instructions sysvar if at least one of the\n   * `zk_elgamal_proof` instructions are included in the same\n   * transaction.\n   */\n  instructionsSysvar?: Address<TAccountInstructionsSysvar>;\n  /** (Optional) Equality proof record account or context state account. */\n  equalityRecord?: Address<TAccountEqualityRecord>;\n  /** (Optional) Range proof record account or context state account. */\n  rangeRecord?: Address<TAccountRangeRecord>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: ConfidentialWithdrawInstructionDataArgs['amount'];\n  decimals: ConfidentialWithdrawInstructionDataArgs['decimals'];\n  newDecryptableAvailableBalance: ConfidentialWithdrawInstructionDataArgs['newDecryptableAvailableBalance'];\n  equalityProofInstructionOffset: ConfidentialWithdrawInstructionDataArgs['equalityProofInstructionOffset'];\n  rangeProofInstructionOffset: ConfidentialWithdrawInstructionDataArgs['rangeProofInstructionOffset'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getConfidentialWithdrawInstruction<\n  TAccountToken extends string,\n  TAccountMint extends string,\n  TAccountInstructionsSysvar extends string,\n  TAccountEqualityRecord extends string,\n  TAccountRangeRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ConfidentialWithdrawInput<\n    TAccountToken,\n    TAccountMint,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountRangeRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ConfidentialWithdrawInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountMint,\n  TAccountInstructionsSysvar,\n  TAccountEqualityRecord,\n  TAccountRangeRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    instructionsSysvar: {\n      value: input.instructionsSysvar ?? null,\n      isWritable: false,\n    },\n    equalityRecord: { value: input.equalityRecord ?? null, isWritable: false },\n    rangeRecord: { value: input.rangeRecord ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.instructionsSysvar),\n      getAccountMeta(accounts.equalityRecord),\n      getAccountMeta(accounts.rangeRecord),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getConfidentialWithdrawInstructionDataEncoder().encode(\n      args as ConfidentialWithdrawInstructionDataArgs\n    ),\n    programAddress,\n  } as ConfidentialWithdrawInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountMint,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountRangeRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedConfidentialWithdrawInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /**\n     * Instructions sysvar if at least one of the\n     * `zk_elgamal_proof` instructions are included in the same\n     * transaction.\n     */\n    instructionsSysvar?: TAccountMetas[2] | undefined;\n    /** (Optional) Equality proof record account or context state account. */\n    equalityRecord?: TAccountMetas[3] | undefined;\n    /** (Optional) Range proof record account or context state account. */\n    rangeRecord?: TAccountMetas[4] | undefined;\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[5];\n  };\n  data: ConfidentialWithdrawInstructionData;\n};\n\nexport function parseConfidentialWithdrawInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedConfidentialWithdrawInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      mint: getNextAccount(),\n      instructionsSysvar: getNextOptionalAccount(),\n      equalityRecord: getNextOptionalAccount(),\n      rangeRecord: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getConfidentialWithdrawInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR = 27;\n\nexport function getConfigureConfidentialTransferAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR\n  );\n}\n\nexport const CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 2;\n\nexport function getConfigureConfidentialTransferAccountConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ConfigureConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountInstructionsSysvarOrContextState extends\n    | string\n    | AccountMeta<string> = 'Sysvar1nstructions1111111111111111111111111',\n  TAccountRecord extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountInstructionsSysvarOrContextState extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvarOrContextState>\n        : TAccountInstructionsSysvarOrContextState,\n      TAccountRecord extends string\n        ? ReadonlyAccount<TAccountRecord>\n        : TAccountRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ConfigureConfidentialTransferAccountInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /** The decryptable balance (always 0) once the configure account succeeds. */\n  decryptableZeroBalance: DecryptableBalance;\n  /**\n   * The maximum number of despots and transfers that an account can receiver\n   * before the `ApplyPendingBalance` is executed\n   */\n  maximumPendingBalanceCreditCounter: bigint;\n  /**\n   * Relative location of the `ProofInstruction::ZeroCiphertextProof`\n   * instruction to the `ConfigureAccount` instruction in the\n   * transaction. If the offset is `0`, then use a context state account\n   * for the proof.\n   */\n  proofInstructionOffset: number;\n};\n\nexport type ConfigureConfidentialTransferAccountInstructionDataArgs = {\n  /** The decryptable balance (always 0) once the configure account succeeds. */\n  decryptableZeroBalance: DecryptableBalanceArgs;\n  /**\n   * The maximum number of despots and transfers that an account can receiver\n   * before the `ApplyPendingBalance` is executed\n   */\n  maximumPendingBalanceCreditCounter: number | bigint;\n  /**\n   * Relative location of the `ProofInstruction::ZeroCiphertextProof`\n   * instruction to the `ConfigureAccount` instruction in the\n   * transaction. If the offset is `0`, then use a context state account\n   * for the proof.\n   */\n  proofInstructionOffset: number;\n};\n\nexport function getConfigureConfidentialTransferAccountInstructionDataEncoder(): FixedSizeEncoder<ConfigureConfidentialTransferAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['decryptableZeroBalance', getDecryptableBalanceEncoder()],\n      ['maximumPendingBalanceCreditCounter', getU64Encoder()],\n      ['proofInstructionOffset', getI8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getConfigureConfidentialTransferAccountInstructionDataDecoder(): FixedSizeDecoder<ConfigureConfidentialTransferAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['decryptableZeroBalance', getDecryptableBalanceDecoder()],\n    ['maximumPendingBalanceCreditCounter', getU64Decoder()],\n    ['proofInstructionOffset', getI8Decoder()],\n  ]);\n}\n\nexport function getConfigureConfidentialTransferAccountInstructionDataCodec(): FixedSizeCodec<\n  ConfigureConfidentialTransferAccountInstructionDataArgs,\n  ConfigureConfidentialTransferAccountInstructionData\n> {\n  return combineCodec(\n    getConfigureConfidentialTransferAccountInstructionDataEncoder(),\n    getConfigureConfidentialTransferAccountInstructionDataDecoder()\n  );\n}\n\nexport type ConfigureConfidentialTransferAccountInput<\n  TAccountToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountInstructionsSysvarOrContextState extends string = string,\n  TAccountRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /**\n   * Instructions sysvar if `VerifyPubkeyValidity` is included in\n   * the same transaction or context state account if\n   * `VerifyPubkeyValidity` is pre-verified into a context state\n   * account.\n   */\n  instructionsSysvarOrContextState?: Address<TAccountInstructionsSysvarOrContextState>;\n  /** (Optional) Record account if the accompanying proof is to be read from a record account. */\n  record?: Address<TAccountRecord>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  decryptableZeroBalance: ConfigureConfidentialTransferAccountInstructionDataArgs['decryptableZeroBalance'];\n  maximumPendingBalanceCreditCounter: ConfigureConfidentialTransferAccountInstructionDataArgs['maximumPendingBalanceCreditCounter'];\n  proofInstructionOffset: ConfigureConfidentialTransferAccountInstructionDataArgs['proofInstructionOffset'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getConfigureConfidentialTransferAccountInstruction<\n  TAccountToken extends string,\n  TAccountMint extends string,\n  TAccountInstructionsSysvarOrContextState extends string,\n  TAccountRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ConfigureConfidentialTransferAccountInput<\n    TAccountToken,\n    TAccountMint,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ConfigureConfidentialTransferAccountInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountMint,\n  TAccountInstructionsSysvarOrContextState,\n  TAccountRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    instructionsSysvarOrContextState: {\n      value: input.instructionsSysvarOrContextState ?? null,\n      isWritable: false,\n    },\n    record: { value: input.record ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.instructionsSysvarOrContextState.value) {\n    accounts.instructionsSysvarOrContextState.value =\n      'Sysvar1nstructions1111111111111111111111111' as Address<'Sysvar1nstructions1111111111111111111111111'>;\n  }\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.instructionsSysvarOrContextState),\n      getAccountMeta(accounts.record),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getConfigureConfidentialTransferAccountInstructionDataEncoder().encode(\n      args as ConfigureConfidentialTransferAccountInstructionDataArgs\n    ),\n    programAddress,\n  } as ConfigureConfidentialTransferAccountInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountMint,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedConfigureConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /**\n     * Instructions sysvar if `VerifyPubkeyValidity` is included in\n     * the same transaction or context state account if\n     * `VerifyPubkeyValidity` is pre-verified into a context state\n     * account.\n     */\n    instructionsSysvarOrContextState: TAccountMetas[2];\n    /** (Optional) Record account if the accompanying proof is to be read from a record account. */\n    record?: TAccountMetas[3] | undefined;\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[4];\n  };\n  data: ConfigureConfidentialTransferAccountInstructionData;\n};\n\nexport function parseConfigureConfidentialTransferAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedConfigureConfidentialTransferAccountInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      mint: getNextAccount(),\n      instructionsSysvarOrContextState: getNextAccount(),\n      record: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getConfigureConfidentialTransferAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  getAddressEncoder,\n  getProgramDerivedAddress,\n  type Address,\n  type ProgramDerivedAddress,\n} from '@solana/kit';\n\nexport type AssociatedTokenSeeds = {\n  /** The wallet address of the associated token account. */\n  owner: Address;\n  /** The address of the token program to use. */\n  tokenProgram: Address;\n  /** The mint address of the associated token account. */\n  mint: Address;\n};\n\nexport async function findAssociatedTokenPda(\n  seeds: AssociatedTokenSeeds,\n  config: { programAddress?: Address | undefined } = {}\n): Promise<ProgramDerivedAddress> {\n  const {\n    programAddress = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>,\n  } = config;\n  return await getProgramDerivedAddress({\n    programAddress,\n    seeds: [\n      getAddressEncoder().encode(seeds.owner),\n      getAddressEncoder().encode(seeds.tokenProgram),\n      getAddressEncoder().encode(seeds.mint),\n    ],\n  });\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { findAssociatedTokenPda } from '../pdas';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  getAccountMetaFactory,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR = 0;\n\nexport function getCreateAssociatedTokenDiscriminatorBytes() {\n  return getU8Encoder().encode(CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR);\n}\n\nexport type CreateAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountPayer extends string | AccountMeta<string> = string,\n  TAccountAta extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | AccountMeta<string> = '11111111111111111111111111111111',\n  TAccountTokenProgram extends\n    | string\n    | AccountMeta<string> = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            AccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountAta extends string ? WritableAccount<TAccountAta> : TAccountAta,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAssociatedTokenInstructionData = { discriminator: number };\n\nexport type CreateAssociatedTokenInstructionDataArgs = {};\n\nexport function getCreateAssociatedTokenInstructionDataEncoder(): FixedSizeEncoder<CreateAssociatedTokenInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getCreateAssociatedTokenInstructionDataDecoder(): FixedSizeDecoder<CreateAssociatedTokenInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCreateAssociatedTokenInstructionDataCodec(): FixedSizeCodec<\n  CreateAssociatedTokenInstructionDataArgs,\n  CreateAssociatedTokenInstructionData\n> {\n  return combineCodec(\n    getCreateAssociatedTokenInstructionDataEncoder(),\n    getCreateAssociatedTokenInstructionDataDecoder()\n  );\n}\n\nexport type CreateAssociatedTokenAsyncInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata?: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport async function getCreateAssociatedTokenInstructionAsync<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenAsyncInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  CreateAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n  if (!accounts.ata.value) {\n    accounts.ata.value = await findAssociatedTokenPda({\n      owner: expectAddress(accounts.owner.value),\n      tokenProgram: expectAddress(accounts.tokenProgram.value),\n      mint: expectAddress(accounts.mint.value),\n    });\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    data: getCreateAssociatedTokenInstructionDataEncoder().encode({}),\n    programAddress,\n  } as CreateAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >);\n}\n\nexport type CreateAssociatedTokenInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getCreateAssociatedTokenInstruction<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateAssociatedTokenInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountAta,\n  TAccountOwner,\n  TAccountMint,\n  TAccountSystemProgram,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    data: getCreateAssociatedTokenInstructionDataEncoder().encode({}),\n    programAddress,\n  } as CreateAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >);\n}\n\nexport type ParsedCreateAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Funding account (must be a system account). */\n    payer: TAccountMetas[0];\n    /** Associated token account address to be created. */\n    ata: TAccountMetas[1];\n    /** Wallet address for the new associated token account. */\n    owner: TAccountMetas[2];\n    /** The token mint for the new associated token account. */\n    mint: TAccountMetas[3];\n    /** System program. */\n    systemProgram: TAccountMetas[4];\n    /** SPL Token program. */\n    tokenProgram: TAccountMetas[5];\n  };\n  data: CreateAssociatedTokenInstructionData;\n};\n\nexport function parseCreateAssociatedTokenInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedCreateAssociatedTokenInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      ata: getNextAccount(),\n      owner: getNextAccount(),\n      mint: getNextAccount(),\n      systemProgram: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getCreateAssociatedTokenInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { findAssociatedTokenPda } from '../pdas';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  getAccountMetaFactory,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR = 1;\n\nexport function getCreateAssociatedTokenIdempotentDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR\n  );\n}\n\nexport type CreateAssociatedTokenIdempotentInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountPayer extends string | AccountMeta<string> = string,\n  TAccountAta extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | AccountMeta<string> = '11111111111111111111111111111111',\n  TAccountTokenProgram extends\n    | string\n    | AccountMeta<string> = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            AccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountAta extends string ? WritableAccount<TAccountAta> : TAccountAta,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAssociatedTokenIdempotentInstructionData = {\n  discriminator: number;\n};\n\nexport type CreateAssociatedTokenIdempotentInstructionDataArgs = {};\n\nexport function getCreateAssociatedTokenIdempotentInstructionDataEncoder(): FixedSizeEncoder<CreateAssociatedTokenIdempotentInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getCreateAssociatedTokenIdempotentInstructionDataDecoder(): FixedSizeDecoder<CreateAssociatedTokenIdempotentInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCreateAssociatedTokenIdempotentInstructionDataCodec(): FixedSizeCodec<\n  CreateAssociatedTokenIdempotentInstructionDataArgs,\n  CreateAssociatedTokenIdempotentInstructionData\n> {\n  return combineCodec(\n    getCreateAssociatedTokenIdempotentInstructionDataEncoder(),\n    getCreateAssociatedTokenIdempotentInstructionDataDecoder()\n  );\n}\n\nexport type CreateAssociatedTokenIdempotentAsyncInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata?: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport async function getCreateAssociatedTokenIdempotentInstructionAsync<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenIdempotentAsyncInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  CreateAssociatedTokenIdempotentInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n  if (!accounts.ata.value) {\n    accounts.ata.value = await findAssociatedTokenPda({\n      owner: expectAddress(accounts.owner.value),\n      tokenProgram: expectAddress(accounts.tokenProgram.value),\n      mint: expectAddress(accounts.mint.value),\n    });\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    data: getCreateAssociatedTokenIdempotentInstructionDataEncoder().encode({}),\n    programAddress,\n  } as CreateAssociatedTokenIdempotentInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >);\n}\n\nexport type CreateAssociatedTokenIdempotentInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getCreateAssociatedTokenIdempotentInstruction<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenIdempotentInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateAssociatedTokenIdempotentInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountAta,\n  TAccountOwner,\n  TAccountMint,\n  TAccountSystemProgram,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    data: getCreateAssociatedTokenIdempotentInstructionDataEncoder().encode({}),\n    programAddress,\n  } as CreateAssociatedTokenIdempotentInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >);\n}\n\nexport type ParsedCreateAssociatedTokenIdempotentInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Funding account (must be a system account). */\n    payer: TAccountMetas[0];\n    /** Associated token account address to be created. */\n    ata: TAccountMetas[1];\n    /** Wallet address for the new associated token account. */\n    owner: TAccountMetas[2];\n    /** The token mint for the new associated token account. */\n    mint: TAccountMetas[3];\n    /** System program. */\n    systemProgram: TAccountMetas[4];\n    /** SPL Token program. */\n    tokenProgram: TAccountMetas[5];\n  };\n  data: CreateAssociatedTokenIdempotentInstructionData;\n};\n\nexport function parseCreateAssociatedTokenIdempotentInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedCreateAssociatedTokenIdempotentInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      ata: getNextAccount(),\n      owner: getNextAccount(),\n      mint: getNextAccount(),\n      systemProgram: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getCreateAssociatedTokenIdempotentInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { bitLen, bitMask, validateObject } from \"../utils.js\";\nimport { Field, FpInvertBatch, nLength, validateField } from \"./modular.js\";\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nexport function negateCt(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\n/**\n * Takes a bunch of Projective Points but executes only one\n * inversion on all of them. Inversion is very slow operation,\n * so this improves performance massively.\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\n */\nexport function normalizeZ(c, points) {\n    const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));\n    return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = bitMask(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return { windows, windowSize, mask, maxNumber, shiftBy };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    // To disable precomputes:\n    // return 1;\n    return pointWindowSizes.get(P) || 1;\n}\nfunction assert0(n) {\n    if (n !== _0n)\n        throw new Error('invalid wNAF');\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Table generation takes **30MB of ram and 10ms on high-end CPU**,\n * but may take much longer on slow devices. Actual generation will happen on\n * first call of `multiply()`. By default, `BASE` point is precomputed.\n *\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport class wNAF {\n    // Parametrized with a given Point class (not individual point)\n    constructor(Point, bits) {\n        this.BASE = Point.BASE;\n        this.ZERO = Point.ZERO;\n        this.Fn = Point.Fn;\n        this.bits = bits;\n    }\n    // non-const time multiplication ladder\n    _unsafeLadder(elm, n, p = this.ZERO) {\n        let d = elm;\n        while (n > _0n) {\n            if (n & _1n)\n                p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(1) * (Math.ceil( / ) + 1), where:\n     * -  is the window size\n     * -  is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param point Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(point, W) {\n        const { windows, windowSize } = calcWOpts(W, this.bits);\n        const points = [];\n        let p = point;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            // i=1, bc we skip 0\n            for (let i = 1; i < windowSize; i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * More compact implementation:\n     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W, precomputes, n) {\n        // Scalar should be smaller than field order\n        if (!this.Fn.isValid(n))\n            throw new Error('invalid scalar');\n        // Accumulators\n        let p = this.ZERO;\n        let f = this.BASE;\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n        const wo = calcWOpts(W, this.bits);\n        for (let window = 0; window < wo.windows; window++) {\n            // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n            const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // bits are 0: add garbage to fake point\n                // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                f = f.add(negateCt(isNegF, precomputes[offsetF]));\n            }\n            else {\n                // bits are 1: add to result point\n                p = p.add(negateCt(isNeg, precomputes[offset]));\n            }\n        }\n        assert0(n);\n        // Return both real and fake points: JIT won't eliminate f.\n        // At this point there is a way to F be infinity-point even if p is not,\n        // which makes it less const-time: around 1 bigint multiply.\n        return { p, f };\n    }\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */\n    wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {\n        const wo = calcWOpts(W, this.bits);\n        for (let window = 0; window < wo.windows; window++) {\n            if (n === _0n)\n                break; // Early-exit, skip 0 value\n            const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // Window bits are 0: skip processing.\n                // Move to next window.\n                continue;\n            }\n            else {\n                const item = precomputes[offset];\n                acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n            }\n        }\n        assert0(n);\n        return acc;\n    }\n    getPrecomputes(W, point, transform) {\n        // Calculate precomputes on a first run, reuse them after\n        let comp = pointPrecomputes.get(point);\n        if (!comp) {\n            comp = this.precomputeWindow(point, W);\n            if (W !== 1) {\n                // Doing transform outside of if brings 15% perf hit\n                if (typeof transform === 'function')\n                    comp = transform(comp);\n                pointPrecomputes.set(point, comp);\n            }\n        }\n        return comp;\n    }\n    cached(point, scalar, transform) {\n        const W = getW(point);\n        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);\n    }\n    unsafe(point, scalar, transform, prev) {\n        const W = getW(point);\n        if (W === 1)\n            return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster\n        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);\n    }\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    createCache(P, W) {\n        validateW(W, this.bits);\n        pointWindowSizes.set(P, W);\n        pointPrecomputes.delete(P);\n    }\n    hasCache(elm) {\n        return getW(elm) !== 1;\n    }\n}\n/**\n * Endomorphism-specific multiplication for Koblitz curves.\n * Cost: 128 dbl, 0-256 adds.\n */\nexport function mulEndoUnsafe(Point, point, k1, k2) {\n    let acc = point;\n    let p1 = Point.ZERO;\n    let p2 = Point.ZERO;\n    while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n)\n            p1 = p1.add(acc);\n        if (k2 & _1n)\n            p2 = p2.add(acc);\n        acc = acc.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n    }\n    return { p1, p2 };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka secret keys / bigints)\n */\nexport function pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength)\n        throw new Error('arrays of points and scalars must have equal length');\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = bitLen(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12)\n        windowSize = wbits - 3;\n    else if (wbits > 4)\n        windowSize = wbits - 2;\n    else if (wbits > 0)\n        windowSize = 2;\n    const MASK = bitMask(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < slength; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar  256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255  32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16  255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = bitMask(windowSize);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\n// TODO: remove\n/** @deprecated */\nexport function validateBasic(curve) {\n    validateField(curve.Fp);\n    validateObject(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...nLength(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\nfunction createField(order, field, isLE) {\n    if (field) {\n        if (field.ORDER !== order)\n            throw new Error('Field.ORDER must match order: Fp == p, Fn == n');\n        validateField(field);\n        return field;\n    }\n    else {\n        return Field(order, { isLE });\n    }\n}\n/** Validates CURVE opts and creates fields */\nexport function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {\n    if (FpFnLE === undefined)\n        FpFnLE = type === 'edwards';\n    if (!CURVE || typeof CURVE !== 'object')\n        throw new Error(`expected valid ${type} CURVE object`);\n    for (const p of ['p', 'n', 'h']) {\n        const val = CURVE[p];\n        if (!(typeof val === 'bigint' && val > _0n))\n            throw new Error(`CURVE.${p} must be positive bigint`);\n    }\n    const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);\n    const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);\n    const _b = type === 'weierstrass' ? 'b' : 'd';\n    const params = ['Gx', 'Gy', 'a', _b];\n    for (const p of params) {\n        // @ts-ignore\n        if (!Fp.isValid(CURVE[p]))\n            throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n    }\n    CURVE = Object.freeze(Object.assign({}, CURVE));\n    return { CURVE, Fp, Fn };\n}\n//# sourceMappingURL=curve.js.map","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CREATE_NATIVE_MINT_DISCRIMINATOR = 31;\n\nexport function getCreateNativeMintDiscriminatorBytes() {\n  return getU8Encoder().encode(CREATE_NATIVE_MINT_DISCRIMINATOR);\n}\n\nexport type CreateNativeMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountPayer extends string | AccountMeta<string> = string,\n  TAccountNativeMint extends string | AccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | AccountMeta<string> = '11111111111111111111111111111111',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            AccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountNativeMint extends string\n        ? WritableAccount<TAccountNativeMint>\n        : TAccountNativeMint,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateNativeMintInstructionData = { discriminator: number };\n\nexport type CreateNativeMintInstructionDataArgs = {};\n\nexport function getCreateNativeMintInstructionDataEncoder(): FixedSizeEncoder<CreateNativeMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: CREATE_NATIVE_MINT_DISCRIMINATOR })\n  );\n}\n\nexport function getCreateNativeMintInstructionDataDecoder(): FixedSizeDecoder<CreateNativeMintInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCreateNativeMintInstructionDataCodec(): FixedSizeCodec<\n  CreateNativeMintInstructionDataArgs,\n  CreateNativeMintInstructionData\n> {\n  return combineCodec(\n    getCreateNativeMintInstructionDataEncoder(),\n    getCreateNativeMintInstructionDataDecoder()\n  );\n}\n\nexport type CreateNativeMintInput<\n  TAccountPayer extends string = string,\n  TAccountNativeMint extends string = string,\n  TAccountSystemProgram extends string = string,\n> = {\n  /** Funding account (must be a system account) */\n  payer: TransactionSigner<TAccountPayer>;\n  /** The native mint address */\n  nativeMint: Address<TAccountNativeMint>;\n  /** System program for mint account funding */\n  systemProgram?: Address<TAccountSystemProgram>;\n};\n\nexport function getCreateNativeMintInstruction<\n  TAccountPayer extends string,\n  TAccountNativeMint extends string,\n  TAccountSystemProgram extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: CreateNativeMintInput<\n    TAccountPayer,\n    TAccountNativeMint,\n    TAccountSystemProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateNativeMintInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountNativeMint,\n  TAccountSystemProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    nativeMint: { value: input.nativeMint ?? null, isWritable: true },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.nativeMint),\n      getAccountMeta(accounts.systemProgram),\n    ],\n    data: getCreateNativeMintInstructionDataEncoder().encode({}),\n    programAddress,\n  } as CreateNativeMintInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountNativeMint,\n    TAccountSystemProgram\n  >);\n}\n\nexport type ParsedCreateNativeMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Funding account (must be a system account) */\n    payer: TAccountMetas[0];\n    /** The native mint address */\n    nativeMint: TAccountMetas[1];\n    /** System program for mint account funding */\n    systemProgram: TAccountMetas[2];\n  };\n  data: CreateNativeMintInstructionData;\n};\n\nexport function parseCreateNativeMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedCreateNativeMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      nativeMint: getNextAccount(),\n      systemProgram: getNextAccount(),\n    },\n    data: getCreateNativeMintInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;\n\nexport function getDisableConfidentialCreditsDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR);\n}\n\nexport const DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 10;\n\nexport function getDisableConfidentialCreditsConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type DisableConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DisableConfidentialCreditsInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n};\n\nexport type DisableConfidentialCreditsInstructionDataArgs = {};\n\nexport function getDisableConfidentialCreditsInstructionDataEncoder(): FixedSizeEncoder<DisableConfidentialCreditsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDisableConfidentialCreditsInstructionDataDecoder(): FixedSizeDecoder<DisableConfidentialCreditsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getDisableConfidentialCreditsInstructionDataCodec(): FixedSizeCodec<\n  DisableConfidentialCreditsInstructionDataArgs,\n  DisableConfidentialCreditsInstructionData\n> {\n  return combineCodec(\n    getDisableConfidentialCreditsInstructionDataEncoder(),\n    getDisableConfidentialCreditsInstructionDataDecoder()\n  );\n}\n\nexport type DisableConfidentialCreditsInput<\n  TAccountToken extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getDisableConfidentialCreditsInstruction<\n  TAccountToken extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: DisableConfidentialCreditsInput<TAccountToken, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): DisableConfidentialCreditsInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getDisableConfidentialCreditsInstructionDataEncoder().encode({}),\n    programAddress,\n  } as DisableConfidentialCreditsInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedDisableConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[1];\n  };\n  data: DisableConfidentialCreditsInstructionData;\n};\n\nexport function parseDisableConfidentialCreditsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedDisableConfidentialCreditsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), authority: getNextAccount() },\n    data: getDisableConfidentialCreditsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DISABLE_CPI_GUARD_DISCRIMINATOR = 34;\n\nexport function getDisableCpiGuardDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_CPI_GUARD_DISCRIMINATOR);\n}\n\nexport const DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR = 1;\n\nexport function getDisableCpiGuardCpiGuardDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR);\n}\n\nexport type DisableCpiGuardInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DisableCpiGuardInstructionData = {\n  discriminator: number;\n  cpiGuardDiscriminator: number;\n};\n\nexport type DisableCpiGuardInstructionDataArgs = {};\n\nexport function getDisableCpiGuardInstructionDataEncoder(): FixedSizeEncoder<DisableCpiGuardInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['cpiGuardDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_CPI_GUARD_DISCRIMINATOR,\n      cpiGuardDiscriminator: DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDisableCpiGuardInstructionDataDecoder(): FixedSizeDecoder<DisableCpiGuardInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['cpiGuardDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getDisableCpiGuardInstructionDataCodec(): FixedSizeCodec<\n  DisableCpiGuardInstructionDataArgs,\n  DisableCpiGuardInstructionData\n> {\n  return combineCodec(\n    getDisableCpiGuardInstructionDataEncoder(),\n    getDisableCpiGuardInstructionDataDecoder()\n  );\n}\n\nexport type DisableCpiGuardInput<\n  TAccountToken extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The token account to update. */\n  token: Address<TAccountToken>;\n  /** The account's owner/delegate or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getDisableCpiGuardInstruction<\n  TAccountToken extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: DisableCpiGuardInput<TAccountToken, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): DisableCpiGuardInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getDisableCpiGuardInstructionDataEncoder().encode({}),\n    programAddress,\n  } as DisableCpiGuardInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedDisableCpiGuardInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token account to update. */\n    token: TAccountMetas[0];\n    /** The account's owner/delegate or its multisignature account. */\n    owner: TAccountMetas[1];\n  };\n  data: DisableCpiGuardInstructionData;\n};\n\nexport function parseDisableCpiGuardInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedDisableCpiGuardInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), owner: getNextAccount() },\n    data: getDisableCpiGuardInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DISABLE_HARVEST_TO_MINT_DISCRIMINATOR = 37;\n\nexport function getDisableHarvestToMintDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_HARVEST_TO_MINT_DISCRIMINATOR);\n}\n\nexport const DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 5;\n\nexport function getDisableHarvestToMintConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type DisableHarvestToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DisableHarvestToMintInstructionData = {\n  discriminator: number;\n  confidentialTransferFeeDiscriminator: number;\n};\n\nexport type DisableHarvestToMintInstructionDataArgs = {};\n\nexport function getDisableHarvestToMintInstructionDataEncoder(): FixedSizeEncoder<DisableHarvestToMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_HARVEST_TO_MINT_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDisableHarvestToMintInstructionDataDecoder(): FixedSizeDecoder<DisableHarvestToMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getDisableHarvestToMintInstructionDataCodec(): FixedSizeCodec<\n  DisableHarvestToMintInstructionDataArgs,\n  DisableHarvestToMintInstructionData\n> {\n  return combineCodec(\n    getDisableHarvestToMintInstructionDataEncoder(),\n    getDisableHarvestToMintInstructionDataDecoder()\n  );\n}\n\nexport type DisableHarvestToMintInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The confidential transfer fee authority */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getDisableHarvestToMintInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: DisableHarvestToMintInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): DisableHarvestToMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getDisableHarvestToMintInstructionDataEncoder().encode({}),\n    programAddress,\n  } as DisableHarvestToMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedDisableHarvestToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. */\n    mint: TAccountMetas[0];\n    /** The confidential transfer fee authority */\n    authority: TAccountMetas[1];\n  };\n  data: DisableHarvestToMintInstructionData;\n};\n\nexport function parseDisableHarvestToMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedDisableHarvestToMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), authority: getNextAccount() },\n    data: getDisableHarvestToMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DISABLE_MEMO_TRANSFERS_DISCRIMINATOR = 30;\n\nexport function getDisableMemoTransfersDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_MEMO_TRANSFERS_DISCRIMINATOR);\n}\n\nexport const DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR = 1;\n\nexport function getDisableMemoTransfersMemoTransfersDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR\n  );\n}\n\nexport type DisableMemoTransfersInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DisableMemoTransfersInstructionData = {\n  discriminator: number;\n  memoTransfersDiscriminator: number;\n};\n\nexport type DisableMemoTransfersInstructionDataArgs = {};\n\nexport function getDisableMemoTransfersInstructionDataEncoder(): FixedSizeEncoder<DisableMemoTransfersInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['memoTransfersDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_MEMO_TRANSFERS_DISCRIMINATOR,\n      memoTransfersDiscriminator:\n        DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDisableMemoTransfersInstructionDataDecoder(): FixedSizeDecoder<DisableMemoTransfersInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['memoTransfersDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getDisableMemoTransfersInstructionDataCodec(): FixedSizeCodec<\n  DisableMemoTransfersInstructionDataArgs,\n  DisableMemoTransfersInstructionData\n> {\n  return combineCodec(\n    getDisableMemoTransfersInstructionDataEncoder(),\n    getDisableMemoTransfersInstructionDataDecoder()\n  );\n}\n\nexport type DisableMemoTransfersInput<\n  TAccountToken extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The token account to update. */\n  token: Address<TAccountToken>;\n  /** The account's owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getDisableMemoTransfersInstruction<\n  TAccountToken extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: DisableMemoTransfersInput<TAccountToken, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): DisableMemoTransfersInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getDisableMemoTransfersInstructionDataEncoder().encode({}),\n    programAddress,\n  } as DisableMemoTransfersInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedDisableMemoTransfersInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token account to update. */\n    token: TAccountMetas[0];\n    /** The account's owner or its multisignature account. */\n    owner: TAccountMetas[1];\n  };\n  data: DisableMemoTransfersInstructionData;\n};\n\nexport function parseDisableMemoTransfersInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedDisableMemoTransfersInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), owner: getNextAccount() },\n    data: getDisableMemoTransfersInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * Twisted Edwards curve. The formula is: ax + y = 1 + dxy.\n * For design rationale of types / exports, see weierstrass module documentation.\n * Untwisted Edwards curves exist, but they aren't used in real-world protocols.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { _validateObject, _abool2 as abool, _abytes2 as abytes, aInRange, bytesToHex, bytesToNumberLE, concatBytes, copyBytes, ensureBytes, isBytes, memoized, notImplemented, randomBytes as randomBytesWeb, } from \"../utils.js\";\nimport { _createCurveFields, normalizeZ, pippenger, wNAF, } from \"./curve.js\";\nimport { Field } from \"./modular.js\";\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\nfunction isEdValidXY(Fp, CURVE, x, y) {\n    const x2 = Fp.sqr(x);\n    const y2 = Fp.sqr(y);\n    const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n    const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n    return Fp.eql(left, right);\n}\nexport function edwards(params, extraOpts = {}) {\n    const validated = _createCurveFields('edwards', params, extraOpts, extraOpts.FpFnLE);\n    const { Fp, Fn } = validated;\n    let CURVE = validated.CURVE;\n    const { h: cofactor } = CURVE;\n    _validateObject(extraOpts, {}, { uvRatio: 'function' });\n    // Important:\n    // There are some places where Fp.BYTES is used instead of nByteLength.\n    // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n    // TODO: test and find curves which behave otherwise.\n    const MASK = _2n << (BigInt(Fn.BYTES * 8) - _1n);\n    const modP = (n) => Fp.create(n); // Function overrides\n    // sqrt(u/v)\n    const uvRatio = extraOpts.uvRatio ||\n        ((u, v) => {\n            try {\n                return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };\n            }\n            catch (e) {\n                return { isValid: false, value: _0n };\n            }\n        });\n    // Validate whether the passed curve params are valid.\n    // equation ax + y = 1 + dxy should work for generator point.\n    if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))\n        throw new Error('bad curve params: generator point');\n    /**\n     * Asserts coordinate is valid: 0 <= n < MASK.\n     * Coordinates >= Fp.ORDER are allowed for zip215.\n     */\n    function acoord(title, n, banZero = false) {\n        const min = banZero ? _1n : _0n;\n        aInRange('coordinate ' + title, n, min, MASK);\n        return n;\n    }\n    function aextpoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ExtendedPoint expected');\n    }\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    const toAffineMemo = memoized((p, iz) => {\n        const { X, Y, Z } = p;\n        const is0 = p.is0();\n        if (iz == null)\n            iz = is0 ? _8n : Fp.inv(Z); // 8 was chosen arbitrarily\n        const x = modP(X * iz);\n        const y = modP(Y * iz);\n        const zz = Fp.mul(Z, iz);\n        if (is0)\n            return { x: _0n, y: _1n };\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return { x, y };\n    });\n    const assertValidMemo = memoized((p) => {\n        const { a, d } = CURVE;\n        if (p.is0())\n            throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n        // Equation in affine coordinates: ax + y = 1 + dxy\n        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX + Y)Z = Z + dXY\n        const { X, Y, Z, T } = p;\n        const X2 = modP(X * X); // X\n        const Y2 = modP(Y * Y); // Y\n        const Z2 = modP(Z * Z); // Z\n        const Z4 = modP(Z2 * Z2); // Z\n        const aX2 = modP(X2 * a); // aX\n        const left = modP(Z2 * modP(aX2 + Y2)); // (aX + Y)Z\n        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z + dXY\n        if (left !== right)\n            throw new Error('bad point: equation left != right (1)');\n        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n        const XY = modP(X * Y);\n        const ZT = modP(Z * T);\n        if (XY !== ZT)\n            throw new Error('bad point: equation left != right (2)');\n        return true;\n    });\n    // Extended Point works in extended coordinates: (X, Y, Z, T)  (x=X/Z, y=Y/Z, T=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        constructor(X, Y, Z, T) {\n            this.X = acoord('x', X);\n            this.Y = acoord('y', Y);\n            this.Z = acoord('z', Z, true);\n            this.T = acoord('t', T);\n            Object.freeze(this);\n        }\n        static CURVE() {\n            return CURVE;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point)\n                throw new Error('extended point not allowed');\n            const { x, y } = p || {};\n            acoord('x', x);\n            acoord('y', y);\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        // Uses algo from RFC8032 5.1.3.\n        static fromBytes(bytes, zip215 = false) {\n            const len = Fp.BYTES;\n            const { a, d } = CURVE;\n            bytes = copyBytes(abytes(bytes, len, 'point'));\n            abool(zip215, 'zip215');\n            const normed = copyBytes(bytes); // copy again, we'll manipulate it\n            const lastByte = bytes[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = bytesToNumberLE(normed);\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // RFC8032 prohibits >= p, but ZIP215 doesn't\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            const max = zip215 ? MASK : Fp.ORDER;\n            aInRange('point.y', y, _0n, max);\n            // Ed25519: x = (y-1)/(dy+1) mod p. Ed448: x = (y-1)/(dy-1) mod p. Generic case:\n            // ax+y=1+dxy => y-1=dxy-ax => y-1=x(dy-a) => x=(y-1)/(dy-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y - 1\n            const v = modP(d * y2 - a); // v = d y + 1.\n            let { isValid, value: x } = uvRatio(u, v); // (u/v)\n            if (!isValid)\n                throw new Error('bad point: invalid y coordinate');\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd)\n                // if x=0 and x_0 = 1, fail\n                throw new Error('bad point: x=0 and x_0=1');\n            if (isLastByteOdd !== isXOdd)\n                x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({ x, y });\n        }\n        static fromHex(bytes, zip215 = false) {\n            return Point.fromBytes(ensureBytes('point', bytes), zip215);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        precompute(windowSize = 8, isLazy = true) {\n            wnaf.createCache(this, windowSize);\n            if (!isLazy)\n                this.multiply(_2n); // random number\n            return this;\n        }\n        // Useful in fromAffine() - not for fromBytes(), which always created valid points.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        // Compare one point to another.\n        equals(other) {\n            aextpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            aextpoint(other);\n            const { a, d } = CURVE;\n            const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;\n            const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            // 1 <= scalar < L\n            if (!Fn.isValidNot0(scalar))\n                throw new Error('invalid scalar: expected 1 <= sc < curve.n');\n            const { p, f } = wnaf.cached(this, scalar, (p) => normalizeZ(Point, p));\n            return normalizeZ(Point, [p, f])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n        multiplyUnsafe(scalar, acc = Point.ZERO) {\n            // 0 <= scalar < L\n            if (!Fn.isValid(scalar))\n                throw new Error('invalid scalar: expected 0 <= sc < curve.n');\n            if (scalar === _0n)\n                return Point.ZERO;\n            if (this.is0() || scalar === _1n)\n                return this;\n            return wnaf.unsafe(this, scalar, (p) => normalizeZ(Point, p), acc);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafe(this, CURVE.n).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(invertedZ) {\n            return toAffineMemo(this, invertedZ);\n        }\n        clearCofactor() {\n            if (cofactor === _1n)\n                return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        toBytes() {\n            const { x, y } = this.toAffine();\n            // Fp.toBytes() allows non-canonical encoding of y (>= p).\n            const bytes = Fp.toBytes(y);\n            // Each y has 2 valid points: (x, y), (x,-y).\n            // When compressing, it's enough to store y and use the last byte to encode sign of x\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0;\n            return bytes;\n        }\n        toHex() {\n            return bytesToHex(this.toBytes());\n        }\n        toString() {\n            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n        }\n        // TODO: remove\n        get ex() {\n            return this.X;\n        }\n        get ey() {\n            return this.Y;\n        }\n        get ez() {\n            return this.Z;\n        }\n        get et() {\n            return this.T;\n        }\n        static normalizeZ(points) {\n            return normalizeZ(Point, points);\n        }\n        static msm(points, scalars) {\n            return pippenger(Point, Fn, points, scalars);\n        }\n        _setWindowSize(windowSize) {\n            this.precompute(windowSize);\n        }\n        toRawBytes() {\n            return this.toBytes();\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    // zero / infinity / identity point\n    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    // math field\n    Point.Fp = Fp;\n    // scalar field\n    Point.Fn = Fn;\n    const wnaf = new wNAF(Point, Fn.BITS);\n    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    return Point;\n}\n/**\n * Base class for prime-order points like Ristretto255 and Decaf448.\n * These points eliminate cofactor issues by representing equivalence classes\n * of Edwards curve points.\n */\nexport class PrimeEdwardsPoint {\n    constructor(ep) {\n        this.ep = ep;\n    }\n    // Static methods that must be implemented by subclasses\n    static fromBytes(_bytes) {\n        notImplemented();\n    }\n    static fromHex(_hex) {\n        notImplemented();\n    }\n    get x() {\n        return this.toAffine().x;\n    }\n    get y() {\n        return this.toAffine().y;\n    }\n    // Common implementations\n    clearCofactor() {\n        // no-op for prime-order groups\n        return this;\n    }\n    assertValidity() {\n        this.ep.assertValidity();\n    }\n    toAffine(invertedZ) {\n        return this.ep.toAffine(invertedZ);\n    }\n    toHex() {\n        return bytesToHex(this.toBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    isTorsionFree() {\n        return true;\n    }\n    isSmallOrder() {\n        return false;\n    }\n    add(other) {\n        this.assertSame(other);\n        return this.init(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        this.assertSame(other);\n        return this.init(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return this.init(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return this.init(this.ep.multiplyUnsafe(scalar));\n    }\n    double() {\n        return this.init(this.ep.double());\n    }\n    negate() {\n        return this.init(this.ep.negate());\n    }\n    precompute(windowSize, isLazy) {\n        return this.init(this.ep.precompute(windowSize, isLazy));\n    }\n    /** @deprecated use `toBytes` */\n    toRawBytes() {\n        return this.toBytes();\n    }\n}\n/**\n * Initializes EdDSA signatures over given Edwards curve.\n */\nexport function eddsa(Point, cHash, eddsaOpts = {}) {\n    if (typeof cHash !== 'function')\n        throw new Error('\"hash\" function param is required');\n    _validateObject(eddsaOpts, {}, {\n        adjustScalarBytes: 'function',\n        randomBytes: 'function',\n        domain: 'function',\n        prehash: 'function',\n        mapToCurve: 'function',\n    });\n    const { prehash } = eddsaOpts;\n    const { BASE, Fp, Fn } = Point;\n    const randomBytes = eddsaOpts.randomBytes || randomBytesWeb;\n    const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);\n    const domain = eddsaOpts.domain ||\n        ((data, ctx, phflag) => {\n            abool(phflag, 'phflag');\n            if (ctx.length || phflag)\n                throw new Error('Contexts/pre-hash are not supported');\n            return data;\n        }); // NOOP\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        return Fn.create(bytesToNumberLE(hash)); // Not Fn.fromBytes: it has length limit\n    }\n    // Get the hashed private scalar per RFC8032 5.1.5\n    function getPrivateScalar(key) {\n        const len = lengths.secretKey;\n        key = ensureBytes('private key', key, len);\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        return { head, prefix, scalar };\n    }\n    /** Convenience method that creates public key from scalar. RFC8032 5.1.5 */\n    function getExtendedPublicKey(secretKey) {\n        const { head, prefix, scalar } = getPrivateScalar(secretKey);\n        const point = BASE.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toBytes();\n        return { head, prefix, scalar, point, pointBytes };\n    }\n    /** Calculates EdDSA pub key. RFC8032 5.1.5. */\n    function getPublicKey(secretKey) {\n        return getExtendedPublicKey(secretKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {\n        const msg = concatBytes(...msgs);\n        return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n    }\n    /** Signs message with privateKey. RFC8032 5.1.6 */\n    function sign(msg, secretKey, options = {}) {\n        msg = ensureBytes('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = BASE.multiply(r).toBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = Fn.create(r + k * scalar); // S = (r + k * s) mod L\n        if (!Fn.isValid(s))\n            throw new Error('sign failed: invalid s'); // 0 <= s < L\n        const rs = concatBytes(R, Fn.toBytes(s));\n        return abytes(rs, lengths.signature, 'result');\n    }\n    // verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\n    const verifyOpts = { zip215: true };\n    /**\n     * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n     * An extended group equation is checked.\n     */\n    function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = lengths.signature;\n        sig = ensureBytes('signature', sig, len);\n        msg = ensureBytes('message', msg);\n        publicKey = ensureBytes('publicKey', publicKey, lengths.publicKey);\n        if (zip215 !== undefined)\n            abool(zip215, 'zip215');\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph, etc\n        const mid = len / 2;\n        const r = sig.subarray(0, mid);\n        const s = bytesToNumberLE(sig.subarray(mid, len));\n        let A, R, SB;\n        try {\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            A = Point.fromBytes(publicKey, zip215);\n            R = Point.fromBytes(r, zip215);\n            SB = BASE.multiplyUnsafe(s); // 0 <= s < l is done inside\n        }\n        catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder())\n            return false; // zip215 allows public keys of small order\n        const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // Extended group equation\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().is0();\n    }\n    const _size = Fp.BYTES; // 32 for ed25519, 57 for ed448\n    const lengths = {\n        secretKey: _size,\n        publicKey: _size,\n        signature: 2 * _size,\n        seed: _size,\n    };\n    function randomSecretKey(seed = randomBytes(lengths.seed)) {\n        return abytes(seed, lengths.seed, 'seed');\n    }\n    function keygen(seed) {\n        const secretKey = utils.randomSecretKey(seed);\n        return { secretKey, publicKey: getPublicKey(secretKey) };\n    }\n    function isValidSecretKey(key) {\n        return isBytes(key) && key.length === Fn.BYTES;\n    }\n    function isValidPublicKey(key, zip215) {\n        try {\n            return !!Point.fromBytes(key, zip215);\n        }\n        catch (error) {\n            return false;\n        }\n    }\n    const utils = {\n        getExtendedPublicKey,\n        randomSecretKey,\n        isValidSecretKey,\n        isValidPublicKey,\n        /**\n         * Converts ed public key to x public key. Uses formula:\n         * - ed25519:\n         *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n         *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n         * - ed448:\n         *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`\n         *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`\n         */\n        toMontgomery(publicKey) {\n            const { y } = Point.fromBytes(publicKey);\n            const size = lengths.publicKey;\n            const is25519 = size === 32;\n            if (!is25519 && size !== 57)\n                throw new Error('only defined for 25519 and 448');\n            const u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);\n            return Fp.toBytes(u);\n        },\n        toMontgomerySecret(secretKey) {\n            const size = lengths.secretKey;\n            abytes(secretKey, size);\n            const hashed = cHash(secretKey.subarray(0, size));\n            return adjustScalarBytes(hashed).subarray(0, size);\n        },\n        /** @deprecated */\n        randomPrivateKey: randomSecretKey,\n        /** @deprecated */\n        precompute(windowSize = 8, point = Point.BASE) {\n            return point.precompute(windowSize, false);\n        },\n    };\n    return Object.freeze({\n        keygen,\n        getPublicKey,\n        sign,\n        verify,\n        utils,\n        Point,\n        lengths,\n    });\n}\nfunction _eddsa_legacy_opts_to_new(c) {\n    const CURVE = {\n        a: c.a,\n        d: c.d,\n        p: c.Fp.ORDER,\n        n: c.n,\n        h: c.h,\n        Gx: c.Gx,\n        Gy: c.Gy,\n    };\n    const Fp = c.Fp;\n    const Fn = Field(CURVE.n, c.nBitLength, true);\n    const curveOpts = { Fp, Fn, uvRatio: c.uvRatio };\n    const eddsaOpts = {\n        randomBytes: c.randomBytes,\n        adjustScalarBytes: c.adjustScalarBytes,\n        domain: c.domain,\n        prehash: c.prehash,\n        mapToCurve: c.mapToCurve,\n    };\n    return { CURVE, curveOpts, hash: c.hash, eddsaOpts };\n}\nfunction _eddsa_new_output_to_legacy(c, eddsa) {\n    const Point = eddsa.Point;\n    const legacy = Object.assign({}, eddsa, {\n        ExtendedPoint: Point,\n        CURVE: c,\n        nBitLength: Point.Fn.BITS,\n        nByteLength: Point.Fn.BYTES,\n    });\n    return legacy;\n}\n// TODO: remove. Use eddsa\nexport function twistedEdwards(c) {\n    const { CURVE, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new(c);\n    const Point = edwards(CURVE, curveOpts);\n    const EDDSA = eddsa(Point, hash, eddsaOpts);\n    return _eddsa_new_output_to_legacy(c, EDDSA);\n}\n//# sourceMappingURL=edwards.js.map","/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { _validateObject, abytes, aInRange, bytesToNumberLE, ensureBytes, numberToBytesLE, randomBytes, } from \"../utils.js\";\nimport { mod } from \"./modular.js\";\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nfunction validateOpts(curve) {\n    _validateObject(curve, {\n        adjustScalarBytes: 'function',\n        powPminus2: 'function',\n    });\n    return Object.freeze({ ...curve });\n}\nexport function montgomery(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;\n    const is25519 = type === 'x25519';\n    if (!is25519 && type !== 'x448')\n        throw new Error('invalid type');\n    const randomBytes_ = rand || randomBytes;\n    const montgomeryBits = is25519 ? 255 : 448;\n    const fieldLen = is25519 ? 32 : 56;\n    const Gu = is25519 ? BigInt(9) : BigInt(5);\n    // RFC 7748 #5:\n    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and\n    // (156326 - 2) / 4 = 39081 for curve448/X448\n    // const a = is25519 ? 156326n : 486662n;\n    const a24 = is25519 ? BigInt(121665) : BigInt(39081);\n    // RFC: x25519 \"the resulting integer is of the form 2^254 plus\n    // eight times a value between 0 and 2^251 - 1 (inclusive)\"\n    // x448: \"2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)\"\n    const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);\n    const maxAdded = is25519\n        ? BigInt(8) * _2n ** BigInt(251) - _1n\n        : BigInt(4) * _2n ** BigInt(445) - _1n;\n    const maxScalar = minScalar + maxAdded + _1n; // (inclusive)\n    const modP = (n) => mod(n, P);\n    const GuBytes = encodeU(Gu);\n    function encodeU(u) {\n        return numberToBytesLE(modP(u), fieldLen);\n    }\n    function decodeU(u) {\n        const _u = ensureBytes('u coordinate', u, fieldLen);\n        // RFC: When receiving such an array, implementations of X25519\n        // (but not X448) MUST mask the most significant bit in the final byte.\n        if (is25519)\n            _u[31] &= 127; // 0b0111_1111\n        // RFC: Implementations MUST accept non-canonical values and process them as\n        // if they had been reduced modulo the field prime.  The non-canonical\n        // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224\n        // - 1 through 2^448 - 1 for X448.\n        return modP(bytesToNumberLE(_u));\n    }\n    function decodeScalar(scalar) {\n        return bytesToNumberLE(adjustScalarBytes(ensureBytes('scalar', scalar, fieldLen)));\n    }\n    function scalarMult(scalar, u) {\n        const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));\n        // Some public keys are useless, of low-order. Curve author doesn't think\n        // it needs to be validated, but we do it nonetheless.\n        // https://cr.yp.to/ecdh.html#validate\n        if (pu === _0n)\n            throw new Error('invalid private or public key received');\n        return encodeU(pu);\n    }\n    // Computes public key from private. By doing scalar multiplication of base point.\n    function scalarMultBase(scalar) {\n        return scalarMult(scalar, GuBytes);\n    }\n    // cswap from RFC7748 \"example code\"\n    function cswap(swap, x_2, x_3) {\n        // dummy = mask(swap) AND (x_2 XOR x_3)\n        // Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n        // and x_3, computed, e.g., as mask(swap) = 0 - swap.\n        const dummy = modP(swap * (x_2 - x_3));\n        x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy\n        x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy\n        return { x_2, x_3 };\n    }\n    /**\n     * Montgomery x-only multiplication ladder.\n     * @param pointU u coordinate (x) on Montgomery Curve 25519\n     * @param scalar by which the point would be multiplied\n     * @returns new Point on Montgomery curve\n     */\n    function montgomeryLadder(u, scalar) {\n        aInRange('u', u, _0n, P);\n        aInRange('scalar', scalar, minScalar, maxScalar);\n        const k = scalar;\n        const x_1 = u;\n        let x_2 = _1n;\n        let z_2 = _0n;\n        let x_3 = u;\n        let z_3 = _1n;\n        let swap = _0n;\n        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n            const k_t = (k >> t) & _1n;\n            swap ^= k_t;\n            ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n            ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n            swap = k_t;\n            const A = x_2 + z_2;\n            const AA = modP(A * A);\n            const B = x_2 - z_2;\n            const BB = modP(B * B);\n            const E = AA - BB;\n            const C = x_3 + z_3;\n            const D = x_3 - z_3;\n            const DA = modP(D * A);\n            const CB = modP(C * B);\n            const dacb = DA + CB;\n            const da_cb = DA - CB;\n            x_3 = modP(dacb * dacb);\n            z_3 = modP(x_1 * modP(da_cb * da_cb));\n            x_2 = modP(AA * BB);\n            z_2 = modP(E * (AA + modP(a24 * E)));\n        }\n        ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n        const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent\n        return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))\n    }\n    const lengths = {\n        secretKey: fieldLen,\n        publicKey: fieldLen,\n        seed: fieldLen,\n    };\n    const randomSecretKey = (seed = randomBytes_(fieldLen)) => {\n        abytes(seed, lengths.seed);\n        return seed;\n    };\n    function keygen(seed) {\n        const secretKey = randomSecretKey(seed);\n        return { secretKey, publicKey: scalarMultBase(secretKey) };\n    }\n    const utils = {\n        randomSecretKey,\n        randomPrivateKey: randomSecretKey,\n    };\n    return {\n        keygen,\n        getSharedSecret: (secretKey, publicKey) => scalarMult(secretKey, publicKey),\n        getPublicKey: (secretKey) => scalarMultBase(secretKey),\n        scalarMult,\n        scalarMultBase,\n        utils,\n        GuBytes: GuBytes.slice(),\n        lengths,\n    };\n}\n//# sourceMappingURL=montgomery.js.map","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;\n\nexport function getDisableNonConfidentialCreditsDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR);\n}\n\nexport const DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 12;\n\nexport function getDisableNonConfidentialCreditsConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type DisableNonConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DisableNonConfidentialCreditsInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n};\n\nexport type DisableNonConfidentialCreditsInstructionDataArgs = {};\n\nexport function getDisableNonConfidentialCreditsInstructionDataEncoder(): FixedSizeEncoder<DisableNonConfidentialCreditsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDisableNonConfidentialCreditsInstructionDataDecoder(): FixedSizeDecoder<DisableNonConfidentialCreditsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getDisableNonConfidentialCreditsInstructionDataCodec(): FixedSizeCodec<\n  DisableNonConfidentialCreditsInstructionDataArgs,\n  DisableNonConfidentialCreditsInstructionData\n> {\n  return combineCodec(\n    getDisableNonConfidentialCreditsInstructionDataEncoder(),\n    getDisableNonConfidentialCreditsInstructionDataDecoder()\n  );\n}\n\nexport type DisableNonConfidentialCreditsInput<\n  TAccountToken extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getDisableNonConfidentialCreditsInstruction<\n  TAccountToken extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: DisableNonConfidentialCreditsInput<TAccountToken, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): DisableNonConfidentialCreditsInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getDisableNonConfidentialCreditsInstructionDataEncoder().encode({}),\n    programAddress,\n  } as DisableNonConfidentialCreditsInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedDisableNonConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[1];\n  };\n  data: DisableNonConfidentialCreditsInstructionData;\n};\n\nexport function parseDisableNonConfidentialCreditsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedDisableNonConfidentialCreditsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), authority: getNextAccount() },\n    data: getDisableNonConfidentialCreditsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  none,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const EMIT_TOKEN_METADATA_DISCRIMINATOR = new Uint8Array([\n  250, 166, 180, 250, 13, 12, 184, 70,\n]);\n\nexport function getEmitTokenMetadataDiscriminatorBytes() {\n  return getBytesEncoder().encode(EMIT_TOKEN_METADATA_DISCRIMINATOR);\n}\n\nexport type EmitTokenMetadataInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMetadata extends string\n        ? ReadonlyAccount<TAccountMetadata>\n        : TAccountMetadata,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EmitTokenMetadataInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** Start of range of data to emit */\n  start: Option<bigint>;\n  /** End of range of data to emit */\n  end: Option<bigint>;\n};\n\nexport type EmitTokenMetadataInstructionDataArgs = {\n  /** Start of range of data to emit */\n  start?: OptionOrNullable<number | bigint>;\n  /** End of range of data to emit */\n  end?: OptionOrNullable<number | bigint>;\n};\n\nexport function getEmitTokenMetadataInstructionDataEncoder(): Encoder<EmitTokenMetadataInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      ['start', getOptionEncoder(getU64Encoder())],\n      ['end', getOptionEncoder(getU64Encoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: EMIT_TOKEN_METADATA_DISCRIMINATOR,\n      start: value.start ?? none(),\n      end: value.end ?? none(),\n    })\n  );\n}\n\nexport function getEmitTokenMetadataInstructionDataDecoder(): Decoder<EmitTokenMetadataInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    ['start', getOptionDecoder(getU64Decoder())],\n    ['end', getOptionDecoder(getU64Decoder())],\n  ]);\n}\n\nexport function getEmitTokenMetadataInstructionDataCodec(): Codec<\n  EmitTokenMetadataInstructionDataArgs,\n  EmitTokenMetadataInstructionData\n> {\n  return combineCodec(\n    getEmitTokenMetadataInstructionDataEncoder(),\n    getEmitTokenMetadataInstructionDataDecoder()\n  );\n}\n\nexport type EmitTokenMetadataInput<TAccountMetadata extends string = string> = {\n  metadata: Address<TAccountMetadata>;\n  start?: EmitTokenMetadataInstructionDataArgs['start'];\n  end?: EmitTokenMetadataInstructionDataArgs['end'];\n};\n\nexport function getEmitTokenMetadataInstruction<\n  TAccountMetadata extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EmitTokenMetadataInput<TAccountMetadata>,\n  config?: { programAddress?: TProgramAddress }\n): EmitTokenMetadataInstruction<TProgramAddress, TAccountMetadata> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.metadata)],\n    data: getEmitTokenMetadataInstructionDataEncoder().encode(\n      args as EmitTokenMetadataInstructionDataArgs\n    ),\n    programAddress,\n  } as EmitTokenMetadataInstruction<TProgramAddress, TAccountMetadata>);\n}\n\nexport type ParsedEmitTokenMetadataInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    metadata: TAccountMetas[0];\n  };\n  data: EmitTokenMetadataInstructionData;\n};\n\nexport function parseEmitTokenMetadataInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedEmitTokenMetadataInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { metadata: getNextAccount() },\n    data: getEmitTokenMetadataInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha2.js';\nimport { abytes, concatBytes, utf8ToBytes } from '@noble/hashes/utils.js';\nimport { pippenger } from \"./abstract/curve.js\";\nimport { PrimeEdwardsPoint, twistedEdwards, } from \"./abstract/edwards.js\";\nimport { _DST_scalar, createHasher, expand_message_xmd, } from \"./abstract/hash-to-curve.js\";\nimport { Field, FpInvertBatch, FpSqrtEven, isNegativeLE, mod, pow2, } from \"./abstract/modular.js\";\nimport { montgomery } from \"./abstract/montgomery.js\";\nimport { bytesToNumberLE, ensureBytes, equalBytes } from \"./utils.js\";\n// prettier-ignore\nconst _0n = /* @__PURE__ */ BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\n// P = 2n**255n-19n\nconst ed25519_CURVE_p = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed');\n// N = 2n**252n + 27742317777372353535851937790883648493n\n// a = Fp.create(BigInt(-1))\n// d = -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))\nconst ed25519_CURVE = /* @__PURE__ */ (() => ({\n    p: ed25519_CURVE_p,\n    n: BigInt('0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed'),\n    h: _8n,\n    a: BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec'),\n    d: BigInt('0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3'),\n    Gx: BigInt('0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a'),\n    Gy: BigInt('0x6666666666666666666666666666666666666666666666666666666666666658'),\n}))();\nfunction ed25519_pow_2_252_3(x) {\n    // prettier-ignore\n    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n    const P = ed25519_CURVE_p;\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P; // x^3, 11\n    const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n    const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n    const b10 = (pow2(b5, _5n, P) * b5) % P;\n    const b20 = (pow2(b10, _10n, P) * b10) % P;\n    const b40 = (pow2(b20, _20n, P) * b20) % P;\n    const b80 = (pow2(b40, _40n, P) * b40) % P;\n    const b160 = (pow2(b80, _80n, P) * b80) % P;\n    const b240 = (pow2(b160, _80n, P) * b80) % P;\n    const b250 = (pow2(b240, _10n, P) * b10) % P;\n    const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n    // ^ To pow to (p+3)/8, multiply it by x.\n    return { pow_p_5_8, b2 };\n}\nfunction adjustScalarBytes(bytes) {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 127; // 0b0111_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n}\n// (-1) aka (a) aka 2^((p-1)/4)\n// Fp.sqrt(Fp.neg(1))\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\n// sqrt(u/v)\nfunction uvRatio(u, v) {\n    const P = ed25519_CURVE_p;\n    const v3 = mod(v * v * v, P); // v\n    const v7 = mod(v3 * v3 * v, P); // v\n    // (p+3)/8 and (p-5)/8\n    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow, P); // (uv)(uv)^(p-5)/8\n    const vx2 = mod(v * x * x, P); // vx\n    const root1 = x; // First root candidate\n    const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n    const useRoot2 = vx2 === mod(-u, P); // If vx = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx = -u(-1)\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2; // We return root2 anyway, for const-time\n    if (isNegativeLE(x, P))\n        x = mod(-x, P);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\nconst Fp = /* @__PURE__ */ (() => Field(ed25519_CURVE.p, { isLE: true }))();\nconst Fn = /* @__PURE__ */ (() => Field(ed25519_CURVE.n, { isLE: true }))();\nconst ed25519Defaults = /* @__PURE__ */ (() => ({\n    ...ed25519_CURVE,\n    Fp,\n    hash: sha512,\n    adjustScalarBytes,\n    // dom2\n    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n    // Constant-time, u/v\n    uvRatio,\n}))();\n/**\n * ed25519 curve with EdDSA signatures.\n * @example\n * import { ed25519 } from '@noble/curves/ed25519';\n * const { secretKey, publicKey } = ed25519.keygen();\n * const msg = new TextEncoder().encode('hello');\n * const sig = ed25519.sign(msg, priv);\n * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215\n * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5\n */\nexport const ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();\nfunction ed25519_domain(data, ctx, phflag) {\n    if (ctx.length > 255)\n        throw new Error('Context is too big');\n    return concatBytes(utf8ToBytes('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);\n}\n/** Context of ed25519. Uses context for domain separation. */\nexport const ed25519ctx = /* @__PURE__ */ (() => twistedEdwards({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n}))();\n/** Prehashed version of ed25519. Accepts already-hashed messages in sign() and verify(). */\nexport const ed25519ph = /* @__PURE__ */ (() => twistedEdwards(Object.assign({}, ed25519Defaults, {\n    domain: ed25519_domain,\n    prehash: sha512,\n})))();\n/**\n * ECDH using curve25519 aka x25519.\n * @example\n * import { x25519 } from '@noble/curves/ed25519';\n * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';\n * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';\n * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases\n * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);\n * x25519.getPublicKey(x25519.utils.randomSecretKey());\n */\nexport const x25519 = /* @__PURE__ */ (() => {\n    const P = Fp.ORDER;\n    return montgomery({\n        P,\n        type: 'x25519',\n        powPminus2: (x) => {\n            // x^(p-2) aka x^(2^255-21)\n            const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n            return mod(pow2(pow_p_5_8, _3n, P) * b2, P);\n        },\n        adjustScalarBytes,\n    });\n})();\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = /* @__PURE__ */ (() => (ed25519_CURVE_p + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u) {\n    const ELL2_C4 = (ed25519_CURVE_p - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n    const ELL2_J = BigInt(486662);\n    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u) {\n    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n    // map_to_curve_elligator2_curve25519(u)\n    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n    const [xd_inv, yd_inv] = FpInvertBatch(Fp, [xd, yd], true); // batch division\n    return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) }; //  13. return (xn, xd, yn, yd)\n}\n/** Hashing to ed25519 points / field. RFC 9380 methods. */\nexport const ed25519_hasher = /* @__PURE__ */ (() => createHasher(ed25519.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {\n    DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n    encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n    p: ed25519_CURVE_p,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha512,\n}))();\n// (-1) aka (a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// (ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\n// 1 / (a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\n// 1-d\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\n// (d-1)\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\n// Calculates 1/(number)\nconst invertSqrt = (number) => uvRatio(_1n, number);\nconst MAX_255B = /* @__PURE__ */ BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nconst bytes255ToNumberLE = (bytes) => ed25519.Point.Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n/**\n * Computes Elligator map for Ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n * the [website](https://ristretto.group/formulas/elligator.html).\n */\nfunction calcElligatorRistrettoMap(r0) {\n    const { d } = ed25519_CURVE;\n    const P = ed25519_CURVE_p;\n    const mod = (n) => Fp.create(n);\n    const r = mod(SQRT_M1 * r0 * r0); // 1\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n    let c = BigInt(-1); // 3\n    const D = mod((c - d * r) * mod(r + d)); // 4\n    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n    let s_ = mod(s * r0); // 6\n    if (!isNegativeLE(s_, P))\n        s_ = mod(-s_);\n    if (!Ns_D_is_sq)\n        s = s_; // 7\n    if (!Ns_D_is_sq)\n        c = r; // 8\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n    const s2 = s * s;\n    const W0 = mod((s + s) * D); // 10\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n    const W2 = mod(_1n - s2); // 12\n    const W3 = mod(_1n + s2); // 13\n    return new ed25519.Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\nfunction ristretto255_map(bytes) {\n    abytes(bytes, 64);\n    const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));\n    const R1 = calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));\n    const R2 = calcElligatorRistrettoMap(r2);\n    return new _RistrettoPoint(R1.add(R2));\n}\n/**\n * Wrapper over Edwards Point for ristretto255.\n *\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */\nclass _RistrettoPoint extends PrimeEdwardsPoint {\n    constructor(ep) {\n        super(ep);\n    }\n    static fromAffine(ap) {\n        return new _RistrettoPoint(ed25519.Point.fromAffine(ap));\n    }\n    assertSame(other) {\n        if (!(other instanceof _RistrettoPoint))\n            throw new Error('RistrettoPoint expected');\n    }\n    init(ep) {\n        return new _RistrettoPoint(ep);\n    }\n    /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */\n    static hashToCurve(hex) {\n        return ristretto255_map(ensureBytes('ristrettoHash', hex, 64));\n    }\n    static fromBytes(bytes) {\n        abytes(bytes, 32);\n        const { a, d } = ed25519_CURVE;\n        const P = ed25519_CURVE_p;\n        const mod = (n) => Fp.create(n);\n        const s = bytes255ToNumberLE(bytes);\n        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n        // 3. Check that s is non-negative, or else abort\n        if (!equalBytes(Fp.toBytes(s), bytes) || isNegativeLE(s, P))\n            throw new Error('invalid ristretto255 encoding 1');\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2); // 4 (a is -1)\n        const u2 = mod(_1n - a * s2); // 5\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2); // 6\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n        const Dx = mod(I * u2); // 8\n        const Dy = mod(I * Dx * v); // 9\n        let x = mod((s + s) * Dx); // 10\n        if (isNegativeLE(x, P))\n            x = mod(-x); // 10\n        const y = mod(u1 * Dy); // 11\n        const t = mod(x * y); // 12\n        if (!isValid || isNegativeLE(t, P) || y === _0n)\n            throw new Error('invalid ristretto255 encoding 2');\n        return new _RistrettoPoint(new ed25519.Point(x, y, _1n, t));\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */\n    static fromHex(hex) {\n        return _RistrettoPoint.fromBytes(ensureBytes('ristrettoHex', hex, 32));\n    }\n    static msm(points, scalars) {\n        return pippenger(_RistrettoPoint, ed25519.Point.Fn, points, scalars);\n    }\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).\n     */\n    toBytes() {\n        let { X, Y, Z, T } = this.ep;\n        const P = ed25519_CURVE_p;\n        const mod = (n) => Fp.create(n);\n        const u1 = mod(mod(Z + Y) * mod(Z - Y)); // 1\n        const u2 = mod(X * Y); // 2\n        // Square root always exists\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n        const D1 = mod(invsqrt * u1); // 4\n        const D2 = mod(invsqrt * u2); // 5\n        const zInv = mod(D1 * D2 * T); // 6\n        let D; // 7\n        if (isNegativeLE(T * zInv, P)) {\n            let _x = mod(Y * SQRT_M1);\n            let _y = mod(X * SQRT_M1);\n            X = _x;\n            Y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2; // 8\n        }\n        if (isNegativeLE(X * zInv, P))\n            Y = mod(-Y); // 9\n        let s = mod((Z - Y) * D); // 10 (check footer's note, no sqrt(-a))\n        if (isNegativeLE(s, P))\n            s = mod(-s);\n        return Fp.toBytes(s); // 11\n    }\n    /**\n     * Compares two Ristretto points.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).\n     */\n    equals(other) {\n        this.assertSame(other);\n        const { X: X1, Y: Y1 } = this.ep;\n        const { X: X2, Y: Y2 } = other.ep;\n        const mod = (n) => Fp.create(n);\n        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n        const one = mod(X1 * Y2) === mod(Y1 * X2);\n        const two = mod(Y1 * Y2) === mod(X1 * X2);\n        return one || two;\n    }\n    is0() {\n        return this.equals(_RistrettoPoint.ZERO);\n    }\n}\n// Do NOT change syntax: the following gymnastics is done,\n// because typescript strips comments, which makes bundlers disable tree-shaking.\n// prettier-ignore\n_RistrettoPoint.BASE = \n/* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.BASE))();\n// prettier-ignore\n_RistrettoPoint.ZERO = \n/* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.ZERO))();\n// prettier-ignore\n_RistrettoPoint.Fp = \n/* @__PURE__ */ (() => Fp)();\n// prettier-ignore\n_RistrettoPoint.Fn = \n/* @__PURE__ */ (() => Fn)();\nexport const ristretto255 = { Point: _RistrettoPoint };\n/** Hashing to ristretto255 points / field. RFC 9380 methods. */\nexport const ristretto255_hasher = {\n    hashToCurve(msg, options) {\n        const DST = options?.DST || 'ristretto255_XMD:SHA-512_R255MAP_RO_';\n        const xmd = expand_message_xmd(msg, DST, 64, sha512);\n        return ristretto255_map(xmd);\n    },\n    hashToScalar(msg, options = { DST: _DST_scalar }) {\n        const xmd = expand_message_xmd(msg, options.DST, 64, sha512);\n        return Fn.create(bytesToNumberLE(xmd));\n    },\n};\n// export const ristretto255_oprf: OPRF = createORPF({\n//   name: 'ristretto255-SHA512',\n//   Point: RistrettoPoint,\n//   hash: sha512,\n//   hashToGroup: ristretto255_hasher.hashToCurve,\n//   hashToScalar: ristretto255_hasher.hashToScalar,\n// });\n/**\n * Weird / bogus points, useful for debugging.\n * All 8 ed25519 points of 8-torsion subgroup can be generated from the point\n * T = `26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05`.\n * T = { O, T, 2T, 3T, 4T, 5T, 6T, 7T }\n */\nexport const ED25519_TORSION_SUBGROUP = [\n    '0100000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n    '0000000000000000000000000000000000000000000000000000000000000080',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n    'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n    '0000000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\n/** @deprecated use `ed25519.utils.toMontgomery` */\nexport function edwardsToMontgomeryPub(edwardsPub) {\n    return ed25519.utils.toMontgomery(ensureBytes('pub', edwardsPub));\n}\n/** @deprecated use `ed25519.utils.toMontgomery` */\nexport const edwardsToMontgomery = edwardsToMontgomeryPub;\n/** @deprecated use `ed25519.utils.toMontgomerySecret` */\nexport function edwardsToMontgomeryPriv(edwardsPriv) {\n    return ed25519.utils.toMontgomerySecret(ensureBytes('pub', edwardsPriv));\n}\n/** @deprecated use `ristretto255.Point` */\nexport const RistrettoPoint = _RistrettoPoint;\n/** @deprecated use `import { ed25519_hasher } from '@noble/curves/ed25519.js';` */\nexport const hashToCurve = /* @__PURE__ */ (() => ed25519_hasher.hashToCurve)();\n/** @deprecated use `import { ed25519_hasher } from '@noble/curves/ed25519.js';` */\nexport const encodeToCurve = /* @__PURE__ */ (() => ed25519_hasher.encodeToCurve)();\n/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */\nexport const hashToRistretto255 = /* @__PURE__ */ (() => ristretto255_hasher.hashToCurve)();\n/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */\nexport const hash_to_ristretto255 = /* @__PURE__ */ (() => ristretto255_hasher.hashToCurve)();\n//# sourceMappingURL=ed25519.js.map","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR = 27;\n\nexport function getEmptyConfidentialTransferAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR\n  );\n}\n\nexport const EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 4;\n\nexport function getEmptyConfidentialTransferAccountConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type EmptyConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountInstructionsSysvarOrContextState extends\n    | string\n    | AccountMeta<string> = 'Sysvar1nstructions1111111111111111111111111',\n  TAccountRecord extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountInstructionsSysvarOrContextState extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvarOrContextState>\n        : TAccountInstructionsSysvarOrContextState,\n      TAccountRecord extends string\n        ? ReadonlyAccount<TAccountRecord>\n        : TAccountRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EmptyConfidentialTransferAccountInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /**\n   * Relative location of the `ProofInstruction::VerifyCloseAccount`\n   * instruction to the `EmptyAccount` instruction in the transaction. If\n   * the offset is `0`, then use a context state account for the proof.\n   */\n  proofInstructionOffset: number;\n};\n\nexport type EmptyConfidentialTransferAccountInstructionDataArgs = {\n  /**\n   * Relative location of the `ProofInstruction::VerifyCloseAccount`\n   * instruction to the `EmptyAccount` instruction in the transaction. If\n   * the offset is `0`, then use a context state account for the proof.\n   */\n  proofInstructionOffset: number;\n};\n\nexport function getEmptyConfidentialTransferAccountInstructionDataEncoder(): FixedSizeEncoder<EmptyConfidentialTransferAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['proofInstructionOffset', getI8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEmptyConfidentialTransferAccountInstructionDataDecoder(): FixedSizeDecoder<EmptyConfidentialTransferAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['proofInstructionOffset', getI8Decoder()],\n  ]);\n}\n\nexport function getEmptyConfidentialTransferAccountInstructionDataCodec(): FixedSizeCodec<\n  EmptyConfidentialTransferAccountInstructionDataArgs,\n  EmptyConfidentialTransferAccountInstructionData\n> {\n  return combineCodec(\n    getEmptyConfidentialTransferAccountInstructionDataEncoder(),\n    getEmptyConfidentialTransferAccountInstructionDataDecoder()\n  );\n}\n\nexport type EmptyConfidentialTransferAccountInput<\n  TAccountToken extends string = string,\n  TAccountInstructionsSysvarOrContextState extends string = string,\n  TAccountRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /**\n   * Instructions sysvar if `VerifyZeroCiphertext` is included in\n   * the same transaction or context state account if\n   * `VerifyZeroCiphertext` is pre-verified into a context state\n   * account.\n   */\n  instructionsSysvarOrContextState?: Address<TAccountInstructionsSysvarOrContextState>;\n  /** (Optional) Record account if the accompanying proof is to be read from a record account. */\n  record?: Address<TAccountRecord>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  proofInstructionOffset: EmptyConfidentialTransferAccountInstructionDataArgs['proofInstructionOffset'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEmptyConfidentialTransferAccountInstruction<\n  TAccountToken extends string,\n  TAccountInstructionsSysvarOrContextState extends string,\n  TAccountRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EmptyConfidentialTransferAccountInput<\n    TAccountToken,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): EmptyConfidentialTransferAccountInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountInstructionsSysvarOrContextState,\n  TAccountRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    instructionsSysvarOrContextState: {\n      value: input.instructionsSysvarOrContextState ?? null,\n      isWritable: false,\n    },\n    record: { value: input.record ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.instructionsSysvarOrContextState.value) {\n    accounts.instructionsSysvarOrContextState.value =\n      'Sysvar1nstructions1111111111111111111111111' as Address<'Sysvar1nstructions1111111111111111111111111'>;\n  }\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.instructionsSysvarOrContextState),\n      getAccountMeta(accounts.record),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getEmptyConfidentialTransferAccountInstructionDataEncoder().encode(\n      args as EmptyConfidentialTransferAccountInstructionDataArgs\n    ),\n    programAddress,\n  } as EmptyConfidentialTransferAccountInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedEmptyConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /**\n     * Instructions sysvar if `VerifyZeroCiphertext` is included in\n     * the same transaction or context state account if\n     * `VerifyZeroCiphertext` is pre-verified into a context state\n     * account.\n     */\n    instructionsSysvarOrContextState: TAccountMetas[1];\n    /** (Optional) Record account if the accompanying proof is to be read from a record account. */\n    record?: TAccountMetas[2] | undefined;\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[3];\n  };\n  data: EmptyConfidentialTransferAccountInstructionData;\n};\n\nexport function parseEmptyConfidentialTransferAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedEmptyConfidentialTransferAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      instructionsSysvarOrContextState: getNextAccount(),\n      record: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getEmptyConfidentialTransferAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * Short Weierstrass curve methods. The formula is: y = x + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac as nobleHmac } from '@noble/hashes/hmac.js';\nimport { ahash } from '@noble/hashes/utils';\nimport { _validateObject, _abool2 as abool, _abytes2 as abytes, aInRange, bitLen, bitMask, bytesToHex, bytesToNumberBE, concatBytes, createHmacDrbg, ensureBytes, hexToBytes, inRange, isBytes, memoized, numberToHexUnpadded, randomBytes as randomBytesWeb, } from \"../utils.js\";\nimport { _createCurveFields, mulEndoUnsafe, negateCt, normalizeZ, pippenger, wNAF, } from \"./curve.js\";\nimport { Field, FpInvertBatch, getMinHashLength, mapHashToField, nLength, validateField, } from \"./modular.js\";\n// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)\nconst divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n) / den;\n/**\n * Splits scalar for GLV endomorphism.\n */\nexport function _splitEndoScalar(k, basis, n) {\n    // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`\n    // Since part can be negative, we need to do this on point.\n    // TODO: verifyScalar function which consumes lambda\n    const [[a1, b1], [a2, b2]] = basis;\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    // |k1|/|k2| is < sqrt(N), but can be negative.\n    // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.\n    let k1 = k - c1 * a1 - c2 * a2;\n    let k2 = -c1 * b1 - c2 * b2;\n    const k1neg = k1 < _0n;\n    const k2neg = k2 < _0n;\n    if (k1neg)\n        k1 = -k1;\n    if (k2neg)\n        k2 = -k2;\n    // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.\n    // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.\n    const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n; // Half bits of N\n    if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {\n        throw new Error('splitScalar (endomorphism): failed, k=' + k);\n    }\n    return { k1neg, k1, k2neg, k2 };\n}\nfunction validateSigFormat(format) {\n    if (!['compact', 'recovered', 'der'].includes(format))\n        throw new Error('Signature format must be \"compact\", \"recovered\", or \"der\"');\n    return format;\n}\nfunction validateSigOpts(opts, def) {\n    const optsn = {};\n    for (let optName of Object.keys(def)) {\n        // @ts-ignore\n        optsn[optName] = opts[optName] === undefined ? def[optName] : opts[optName];\n    }\n    abool(optsn.lowS, 'lowS');\n    abool(optsn.prehash, 'prehash');\n    if (optsn.format !== undefined)\n        validateSigFormat(optsn.format);\n    return optsn;\n}\nexport class DERErr extends Error {\n    constructor(m = '') {\n        super(m);\n    }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexport const DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data) => {\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length & 1)\n                throw new E('tlv.encode: unpadded data');\n            const dataLen = data.length / 2;\n            const len = numberToHexUnpadded(dataLen);\n            if ((len.length / 2) & 128)\n                throw new E('tlv.encode: long form length too big');\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? numberToHexUnpadded((len.length / 2) | 128) : '';\n            const t = numberToHexUnpadded(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode(tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length < 2 || data[pos++] !== tag)\n                throw new E('tlv.decode: wrong tlv');\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong)\n                length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen)\n                    throw new E('tlv.decode(long): indefinite length not supported');\n                if (lenLen > 4)\n                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen)\n                    throw new E('tlv.decode: length bytes not complete');\n                if (lengthBytes[0] === 0)\n                    throw new E('tlv.decode(long): zero leftmost byte');\n                for (const b of lengthBytes)\n                    length = (length << 8) | b;\n                pos += lenLen;\n                if (length < 128)\n                    throw new E('tlv.decode(long): not minimal encoding');\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length)\n                throw new E('tlv.decode: wrong value length');\n            return { v, l: data.subarray(pos + length) };\n        },\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode(num) {\n            const { Err: E } = DER;\n            if (num < _0n)\n                throw new E('integer: negative integers are not allowed');\n            let hex = numberToHexUnpadded(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 0b1000)\n                hex = '00' + hex;\n            if (hex.length & 1)\n                throw new E('unexpected DER parsing assertion: unpadded hex');\n            return hex;\n        },\n        decode(data) {\n            const { Err: E } = DER;\n            if (data[0] & 128)\n                throw new E('invalid signature integer: negative');\n            if (data[0] === 0x00 && !(data[1] & 128))\n                throw new E('invalid signature integer: unnecessary leading zero');\n            return bytesToNumberBE(data);\n        },\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = ensureBytes('signature', hex);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        return { r: int.decode(rBytes), s: int.decode(sBytes) };\n    },\n    hexFromSig(sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nexport function _normFnElement(Fn, key) {\n    const { BYTES: expected } = Fn;\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else {\n        let bytes = ensureBytes('private key', key);\n        try {\n            num = Fn.fromBytes(bytes);\n        }\n        catch (error) {\n            throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);\n        }\n    }\n    if (!Fn.isValidNot0(num))\n        throw new Error('invalid private key: out of range [1..N-1]');\n    return num;\n}\n/**\n * Creates weierstrass Point constructor, based on specified curve options.\n *\n * @example\n```js\nconst opts = {\n  p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),\n  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n  h: BigInt(1),\n  a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),\n  b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),\n  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n};\nconst p256_Point = weierstrass(opts);\n```\n */\nexport function weierstrassN(params, extraOpts = {}) {\n    const validated = _createCurveFields('weierstrass', params, extraOpts);\n    const { Fp, Fn } = validated;\n    let CURVE = validated.CURVE;\n    const { h: cofactor, n: CURVE_ORDER } = CURVE;\n    _validateObject(extraOpts, {}, {\n        allowInfinityPoint: 'boolean',\n        clearCofactor: 'function',\n        isTorsionFree: 'function',\n        fromBytes: 'function',\n        toBytes: 'function',\n        endo: 'object',\n        wrapPrivateKey: 'boolean',\n    });\n    const { endo } = extraOpts;\n    if (endo) {\n        // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });\n        if (!Fp.is0(CURVE.a) || typeof endo.beta !== 'bigint' || !Array.isArray(endo.basises)) {\n            throw new Error('invalid endo: expected \"beta\": bigint and \"basises\": array');\n        }\n    }\n    const lengths = getWLengths(Fp, Fn);\n    function assertCompressionIsSupported() {\n        if (!Fp.isOdd)\n            throw new Error('compression is not supported: Field does not have .isOdd()');\n    }\n    // Implements IEEE P1363 point encoding\n    function pointToBytes(_c, point, isCompressed) {\n        const { x, y } = point.toAffine();\n        const bx = Fp.toBytes(x);\n        abool(isCompressed, 'isCompressed');\n        if (isCompressed) {\n            assertCompressionIsSupported();\n            const hasEvenY = !Fp.isOdd(y);\n            return concatBytes(pprefix(hasEvenY), bx);\n        }\n        else {\n            return concatBytes(Uint8Array.of(0x04), bx, Fp.toBytes(y));\n        }\n    }\n    function pointFromBytes(bytes) {\n        abytes(bytes, undefined, 'Point');\n        const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths; // e.g. for 32-byte: 33, 65\n        const length = bytes.length;\n        const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // No actual validation is done here: use .assertValidity()\n        if (length === comp && (head === 0x02 || head === 0x03)) {\n            const x = Fp.fromBytes(tail);\n            if (!Fp.isValid(x))\n                throw new Error('bad point: is not on curve, wrong x');\n            const y2 = weierstrassEquation(x); // y = x + ax + b\n            let y;\n            try {\n                y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n            }\n            catch (sqrtError) {\n                const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                throw new Error('bad point: is not on curve, sqrt error' + err);\n            }\n            assertCompressionIsSupported();\n            const isYOdd = Fp.isOdd(y); // (y & _1n) === _1n;\n            const isHeadOdd = (head & 1) === 1; // ECDSA-specific\n            if (isHeadOdd !== isYOdd)\n                y = Fp.neg(y);\n            return { x, y };\n        }\n        else if (length === uncomp && head === 0x04) {\n            // TODO: more checks\n            const L = Fp.BYTES;\n            const x = Fp.fromBytes(tail.subarray(0, L));\n            const y = Fp.fromBytes(tail.subarray(L, L * 2));\n            if (!isValidXY(x, y))\n                throw new Error('bad point: is not on curve');\n            return { x, y };\n        }\n        else {\n            throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);\n        }\n    }\n    const encodePoint = extraOpts.toBytes || pointToBytes;\n    const decodePoint = extraOpts.fromBytes || pointFromBytes;\n    function weierstrassEquation(x) {\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b); // x + a * x + b\n    }\n    // TODO: move top-level\n    /** Checks whether equation holds for given x, y: y == x + ax + b */\n    function isValidXY(x, y) {\n        const left = Fp.sqr(y); // y\n        const right = weierstrassEquation(x); // x + ax + b\n        return Fp.eql(left, right);\n    }\n    // Validate whether the passed curve params are valid.\n    // Test 1: equation y = x + ax + b should work for generator point.\n    if (!isValidXY(CURVE.Gx, CURVE.Gy))\n        throw new Error('bad curve params: generator point');\n    // Test 2: discriminant  part should be non-zero: 4a + 27b != 0.\n    // Guarantees curve is genus-1, smooth (non-singular).\n    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n    if (Fp.is0(Fp.add(_4a3, _27b2)))\n        throw new Error('bad curve params: a or b');\n    /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */\n    function acoord(title, n, banZero = false) {\n        if (!Fp.isValid(n) || (banZero && Fp.is0(n)))\n            throw new Error(`bad point coordinate ${title}`);\n        return n;\n    }\n    function aprjpoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    function splitEndoScalarN(k) {\n        if (!endo || !endo.basises)\n            throw new Error('no endo');\n        return _splitEndoScalar(k, endo.basises, Fn.ORDER);\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (X, Y, Z)  (x=X/Z, y=Y/Z)\n    const toAffineMemo = memoized((p, iz) => {\n        const { X, Y, Z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(Z, Fp.ONE))\n            return { x: X, y: Y };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null)\n            iz = is0 ? Fp.ONE : Fp.inv(Z);\n        const x = Fp.mul(X, iz);\n        const y = Fp.mul(Y, iz);\n        const zz = Fp.mul(Z, iz);\n        if (is0)\n            return { x: Fp.ZERO, y: Fp.ZERO };\n        if (!Fp.eql(zz, Fp.ONE))\n            throw new Error('invZ was invalid');\n        return { x, y };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = memoized((p) => {\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))\n                return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        if (!Fp.isValid(x) || !Fp.isValid(y))\n            throw new Error('bad point: x or y not field elements');\n        if (!isValidXY(x, y))\n            throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree())\n            throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {\n        k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);\n        k1p = negateCt(k1neg, k1p);\n        k2p = negateCt(k2neg, k2p);\n        return k1p.add(k2p);\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z)  (x=X/Z, y=Y/Z).\n     * Default Point works in 2d / affine coordinates: (x, y).\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n        constructor(X, Y, Z) {\n            this.X = acoord('x', X);\n            this.Y = acoord('y', Y, true);\n            this.Z = acoord('z', Z);\n            Object.freeze(this);\n        }\n        static CURVE() {\n            return CURVE;\n        }\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)\n            if (Fp.is0(x) && Fp.is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        static fromBytes(bytes) {\n            const P = Point.fromAffine(decodePoint(abytes(bytes, undefined, 'point')));\n            P.assertValidity();\n            return P;\n        }\n        static fromHex(hex) {\n            return Point.fromBytes(ensureBytes('pointHex', hex));\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         *\n         * @param windowSize\n         * @param isLazy true will defer table computation until the first multiplication\n         * @returns\n         */\n        precompute(windowSize = 8, isLazy = true) {\n            wnaf.createCache(this, windowSize);\n            if (!isLazy)\n                this.multiply(_3n); // random number\n            return this;\n        }\n        // TODO: return `this`\n        /** A point on curve is valid if it conforms to equation. */\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (!Fp.isOdd)\n                throw new Error(\"Field doesn't support isOdd\");\n            return !Fp.isOdd(y);\n        }\n        /** Compare one point to another. */\n        equals(other) {\n            aprjpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */\n        negate() {\n            return new Point(this.X, Fp.neg(this.Y), this.Z);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            aprjpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            const { endo } = extraOpts;\n            if (!Fn.isValidNot0(scalar))\n                throw new Error('invalid scalar: out of range'); // 0 is invalid\n            let point, fake; // Fake point is used to const-time mult\n            const mul = (n) => wnaf.cached(this, n, (p) => normalizeZ(Point, p));\n            /** See docs for {@link EndomorphismOpts} */\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);\n                const { p: k1p, f: k1f } = mul(k1);\n                const { p: k2p, f: k2f } = mul(k2);\n                fake = k1f.add(k2f);\n                point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);\n            }\n            else {\n                const { p, f } = mul(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return normalizeZ(Point, [point, fake])[0];\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed secret key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(sc) {\n            const { endo } = extraOpts;\n            const p = this;\n            if (!Fn.isValid(sc))\n                throw new Error('invalid scalar: out of range'); // 0 is valid\n            if (sc === _0n || p.is0())\n                return Point.ZERO;\n            if (sc === _1n)\n                return p; // fast-path\n            if (wnaf.hasCache(this))\n                return this.multiply(sc);\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);\n                const { p1, p2 } = mulEndoUnsafe(Point, p, k1, k2); // 30% faster vs wnaf.unsafe\n                return finishEndo(endo.beta, p1, p2, k1neg, k2neg);\n            }\n            else {\n                return wnaf.unsafe(p, sc);\n            }\n        }\n        multiplyAndAddUnsafe(Q, a, b) {\n            const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));\n            return sum.is0() ? undefined : sum;\n        }\n        /**\n         * Converts Projective point to affine (x, y) coordinates.\n         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n         */\n        toAffine(invertedZ) {\n            return toAffineMemo(this, invertedZ);\n        }\n        /**\n         * Checks whether Point is free of torsion elements (is in prime subgroup).\n         * Always torsion-free for cofactor=1 curves.\n         */\n        isTorsionFree() {\n            const { isTorsionFree } = extraOpts;\n            if (cofactor === _1n)\n                return true;\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            return wnaf.unsafe(this, CURVE_ORDER).is0();\n        }\n        clearCofactor() {\n            const { clearCofactor } = extraOpts;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(cofactor);\n        }\n        isSmallOrder() {\n            // can we use this.clearCofactor()?\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        toBytes(isCompressed = true) {\n            abool(isCompressed, 'isCompressed');\n            this.assertValidity();\n            return encodePoint(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return bytesToHex(this.toBytes(isCompressed));\n        }\n        toString() {\n            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n        }\n        // TODO: remove\n        get px() {\n            return this.X;\n        }\n        get py() {\n            return this.X;\n        }\n        get pz() {\n            return this.Z;\n        }\n        toRawBytes(isCompressed = true) {\n            return this.toBytes(isCompressed);\n        }\n        _setWindowSize(windowSize) {\n            this.precompute(windowSize);\n        }\n        static normalizeZ(points) {\n            return normalizeZ(Point, points);\n        }\n        static msm(points, scalars) {\n            return pippenger(Point, Fn, points, scalars);\n        }\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(_normFnElement(Fn, privateKey));\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    // math field\n    Point.Fp = Fp;\n    // scalar field\n    Point.Fn = Fn;\n    const bits = Fn.BITS;\n    const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);\n    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    return Point;\n}\n// Points start with byte 0x02 when y is even; otherwise 0x03\nfunction pprefix(hasEvenY) {\n    return Uint8Array.of(hasEvenY ? 0x02 : 0x03);\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU(Fp, opts) {\n    validateField(Fp);\n    const { A, B, Z } = opts;\n    if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, Z);\n    if (!Fp.isOdd)\n        throw new Error('Field does not have .isOdd()');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        const tv4_inv = FpInvertBatch(Fp, [tv4], true)[0];\n        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\nfunction getWLengths(Fp, Fn) {\n    return {\n        secretKey: Fn.BYTES,\n        publicKey: 1 + Fp.BYTES,\n        publicKeyUncompressed: 1 + 2 * Fp.BYTES,\n        publicKeyHasPrefix: true,\n        signature: 2 * Fn.BYTES,\n    };\n}\n/**\n * Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.\n * This helper ensures no signature functionality is present. Less code, smaller bundle size.\n */\nexport function ecdh(Point, ecdhOpts = {}) {\n    const { Fn } = Point;\n    const randomBytes_ = ecdhOpts.randomBytes || randomBytesWeb;\n    const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: getMinHashLength(Fn.ORDER) });\n    function isValidSecretKey(secretKey) {\n        try {\n            return !!_normFnElement(Fn, secretKey);\n        }\n        catch (error) {\n            return false;\n        }\n    }\n    function isValidPublicKey(publicKey, isCompressed) {\n        const { publicKey: comp, publicKeyUncompressed } = lengths;\n        try {\n            const l = publicKey.length;\n            if (isCompressed === true && l !== comp)\n                return false;\n            if (isCompressed === false && l !== publicKeyUncompressed)\n                return false;\n            return !!Point.fromBytes(publicKey);\n        }\n        catch (error) {\n            return false;\n        }\n    }\n    /**\n     * Produces cryptographically secure secret key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */\n    function randomSecretKey(seed = randomBytes_(lengths.seed)) {\n        return mapHashToField(abytes(seed, lengths.seed, 'seed'), Fn.ORDER);\n    }\n    /**\n     * Computes public key for a secret key. Checks for validity of the secret key.\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(secretKey, isCompressed = true) {\n        return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);\n    }\n    function keygen(seed) {\n        const secretKey = randomSecretKey(seed);\n        return { secretKey, publicKey: getPublicKey(secretKey) };\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        if (typeof item === 'bigint')\n            return false;\n        if (item instanceof Point)\n            return true;\n        const { secretKey, publicKey, publicKeyUncompressed } = lengths;\n        if (Fn.allowedLengths || secretKey === publicKey)\n            return undefined;\n        const l = ensureBytes('key', item).length;\n        return l === publicKey || l === publicKeyUncompressed;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from secret key A and public key B.\n     * Checks: 1) secret key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {\n        if (isProbPub(secretKeyA) === true)\n            throw new Error('first arg must be private key');\n        if (isProbPub(publicKeyB) === false)\n            throw new Error('second arg must be public key');\n        const s = _normFnElement(Fn, secretKeyA);\n        const b = Point.fromHex(publicKeyB); // checks for being on-curve\n        return b.multiply(s).toBytes(isCompressed);\n    }\n    const utils = {\n        isValidSecretKey,\n        isValidPublicKey,\n        randomSecretKey,\n        // TODO: remove\n        isValidPrivateKey: isValidSecretKey,\n        randomPrivateKey: randomSecretKey,\n        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),\n        precompute(windowSize = 8, point = Point.BASE) {\n            return point.precompute(windowSize, false);\n        },\n    };\n    return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });\n}\n/**\n * Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.\n * We need `hash` for 2 features:\n * 1. Message prehash-ing. NOT used if `sign` / `verify` are called with `prehash: false`\n * 2. k generation in `sign`, using HMAC-drbg(hash)\n *\n * ECDSAOpts are only rarely needed.\n *\n * @example\n * ```js\n * const p256_Point = weierstrass(...);\n * const p256_sha256 = ecdsa(p256_Point, sha256);\n * const p256_sha224 = ecdsa(p256_Point, sha224);\n * const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });\n * ```\n */\nexport function ecdsa(Point, hash, ecdsaOpts = {}) {\n    ahash(hash);\n    _validateObject(ecdsaOpts, {}, {\n        hmac: 'function',\n        lowS: 'boolean',\n        randomBytes: 'function',\n        bits2int: 'function',\n        bits2int_modN: 'function',\n    });\n    const randomBytes = ecdsaOpts.randomBytes || randomBytesWeb;\n    const hmac = ecdsaOpts.hmac ||\n        ((key, ...msgs) => nobleHmac(hash, key, concatBytes(...msgs)));\n    const { Fp, Fn } = Point;\n    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;\n    const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);\n    const defaultSigOpts = {\n        prehash: false,\n        lowS: typeof ecdsaOpts.lowS === 'boolean' ? ecdsaOpts.lowS : false,\n        format: undefined, //'compact' as ECDSASigFormat,\n        extraEntropy: false,\n    };\n    const defaultSigOpts_format = 'compact';\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function validateRS(title, num) {\n        if (!Fn.isValidNot0(num))\n            throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);\n        return num;\n    }\n    function validateSigLength(bytes, format) {\n        validateSigFormat(format);\n        const size = lengths.signature;\n        const sizer = format === 'compact' ? size : format === 'recovered' ? size + 1 : undefined;\n        return abytes(bytes, sizer, `${format} signature`);\n    }\n    /**\n     * ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = validateRS('r', r); // r in [1..N-1];\n            this.s = validateRS('s', s); // s in [1..N-1];\n            if (recovery != null)\n                this.recovery = recovery;\n            Object.freeze(this);\n        }\n        static fromBytes(bytes, format = defaultSigOpts_format) {\n            validateSigLength(bytes, format);\n            let recid;\n            if (format === 'der') {\n                const { r, s } = DER.toSig(abytes(bytes));\n                return new Signature(r, s);\n            }\n            if (format === 'recovered') {\n                recid = bytes[0];\n                format = 'compact';\n                bytes = bytes.subarray(1);\n            }\n            const L = Fn.BYTES;\n            const r = bytes.subarray(0, L);\n            const s = bytes.subarray(L, L * 2);\n            return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);\n        }\n        static fromHex(hex, format) {\n            return this.fromBytes(hexToBytes(hex), format);\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(messageHash) {\n            const FIELD_ORDER = Fp.ORDER;\n            const { r, s, recovery: rec } = this;\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            // ECDSA recovery is hard for cofactor > 1 curves.\n            // In sign, `r = q.x mod n`, and here we recover q.x from r.\n            // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.\n            // However, for cofactor>1, r+n may not get q.x:\n            // r+n*i would need to be done instead where i is unknown.\n            // To easily get i, we either need to:\n            // a. increase amount of valid recid values (4, 5...); OR\n            // b. prohibit non-prime-order signatures (recid > 1).\n            const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;\n            if (hasCofactor && rec > 1)\n                throw new Error('recovery id is ambiguous for h>1 curve');\n            const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;\n            if (!Fp.isValid(radj))\n                throw new Error('recovery id 2 or 3 invalid');\n            const x = Fp.toBytes(radj);\n            const R = Point.fromBytes(concatBytes(pprefix((rec & 1) === 0), x));\n            const ir = Fn.inv(radj); // r^-1\n            const h = bits2int_modN(ensureBytes('msgHash', messageHash)); // Truncate hash\n            const u1 = Fn.create(-h * ir); // -hr^-1\n            const u2 = Fn.create(s * ir); // sr^-1\n            // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.\n            const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));\n            if (Q.is0())\n                throw new Error('point at infinify');\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        toBytes(format = defaultSigOpts_format) {\n            validateSigFormat(format);\n            if (format === 'der')\n                return hexToBytes(DER.hexFromSig(this));\n            const r = Fn.toBytes(this.r);\n            const s = Fn.toBytes(this.s);\n            if (format === 'recovered') {\n                if (this.recovery == null)\n                    throw new Error('recovery bit must be present');\n                return concatBytes(Uint8Array.of(this.recovery), r, s);\n            }\n            return concatBytes(r, s);\n        }\n        toHex(format) {\n            return bytesToHex(this.toBytes(format));\n        }\n        // TODO: remove\n        assertValidity() { }\n        static fromCompact(hex) {\n            return Signature.fromBytes(ensureBytes('sig', hex), 'compact');\n        }\n        static fromDER(hex) {\n            return Signature.fromBytes(ensureBytes('sig', hex), 'der');\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;\n        }\n        toDERRawBytes() {\n            return this.toBytes('der');\n        }\n        toDERHex() {\n            return bytesToHex(this.toBytes('der'));\n        }\n        toCompactRawBytes() {\n            return this.toBytes('compact');\n        }\n        toCompactHex() {\n            return bytesToHex(this.toBytes('compact'));\n        }\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = ecdsaOpts.bits2int ||\n        function bits2int_def(bytes) {\n            // Our custom check \"just in case\", for protection against DoS\n            if (bytes.length > 8192)\n                throw new Error('input is too large');\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = ecdsaOpts.bits2int_modN ||\n        function bits2int_modN_def(bytes) {\n            return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // Pads output with zero as per spec\n    const ORDER_MASK = bitMask(fnBits);\n    /** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */\n    function int2octets(num) {\n        // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`\n        aInRange('num < 2^' + fnBits, num, _0n, ORDER_MASK);\n        return Fn.toBytes(num);\n    }\n    function validateMsgAndHash(message, prehash) {\n        abytes(message, undefined, 'message');\n        return prehash ? abytes(hash(message), undefined, 'prehashed message') : message;\n    }\n    /**\n     * Steps A, D of RFC6979 3.2.\n     * Creates RFC6979 seed; converts msg/privKey to numbers.\n     * Used only in sign, not in verify.\n     *\n     * Warning: we cannot assume here that message has same amount of bytes as curve order,\n     * this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.\n     */\n    function prepSig(message, privateKey, opts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);\n        message = validateMsgAndHash(message, prehash); // RFC6979 3.2 A: h1 = H(m)\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(message);\n        const d = _normFnElement(Fn, privateKey); // validate secret key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (extraEntropy != null && extraEntropy !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            // gen random bytes OR pass as-is\n            const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;\n            seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n        }\n        const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        // To transform k => Signature:\n        // q = kG\n        // r = q.x mod n\n        // s = k^-1(m + rd) mod n\n        // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n        // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n        // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            // Important: all mod() calls here must be done over N\n            const k = bits2int(kBytes); // mod n, not mod p\n            if (!Fn.isValidNot0(k))\n                return; // Valid scalars (including k) must be in 1..N-1\n            const ik = Fn.inv(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = kG\n            const r = Fn.create(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = Fn.neg(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    /**\n     * Signs message hash with a secret key.\n     *\n     * ```\n     * sign(m, d) where\n     *   k = rfc6979_hmac_drbg(m, d)\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr) / k mod n\n     * ```\n     */\n    function sign(message, secretKey, opts = {}) {\n        message = ensureBytes('message', message);\n        const { seed, k2sig } = prepSig(message, secretKey, opts); // Steps A, D of RFC6979 3.2.\n        const drbg = createHmacDrbg(hash.outputLen, Fn.BYTES, hmac);\n        const sig = drbg(seed, k2sig); // Steps B, C, D, E, F, G\n        return sig;\n    }\n    function tryParsingSig(sg) {\n        // Try to deduce format\n        let sig = undefined;\n        const isHex = typeof sg === 'string' || isBytes(sg);\n        const isObj = !isHex &&\n            sg !== null &&\n            typeof sg === 'object' &&\n            typeof sg.r === 'bigint' &&\n            typeof sg.s === 'bigint';\n        if (!isHex && !isObj)\n            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n        if (isObj) {\n            sig = new Signature(sg.r, sg.s);\n        }\n        else if (isHex) {\n            try {\n                sig = Signature.fromBytes(ensureBytes('sig', sg), 'der');\n            }\n            catch (derError) {\n                if (!(derError instanceof DER.Err))\n                    throw derError;\n            }\n            if (!sig) {\n                try {\n                    sig = Signature.fromBytes(ensureBytes('sig', sg), 'compact');\n                }\n                catch (error) {\n                    return false;\n                }\n            }\n        }\n        if (!sig)\n            return false;\n        return sig;\n    }\n    /**\n     * Verifies a signature against message and public key.\n     * Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.\n     * Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   u1 = hs^-1 mod n\n     *   u2 = rs^-1 mod n\n     *   R = u1G + u2P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, message, publicKey, opts = {}) {\n        const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);\n        publicKey = ensureBytes('publicKey', publicKey);\n        message = validateMsgAndHash(ensureBytes('message', message), prehash);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const sig = format === undefined\n            ? tryParsingSig(signature)\n            : Signature.fromBytes(ensureBytes('sig', signature), format);\n        if (sig === false)\n            return false;\n        try {\n            const P = Point.fromBytes(publicKey);\n            if (lowS && sig.hasHighS())\n                return false;\n            const { r, s } = sig;\n            const h = bits2int_modN(message); // mod n, not mod p\n            const is = Fn.inv(s); // s^-1 mod n\n            const u1 = Fn.create(h * is); // u1 = hs^-1 mod n\n            const u2 = Fn.create(r * is); // u2 = rs^-1 mod n\n            const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2)); // u1G + u2P\n            if (R.is0())\n                return false;\n            const v = Fn.create(R.x); // v = r.x mod n\n            return v === r;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    function recoverPublicKey(signature, message, opts = {}) {\n        const { prehash } = validateSigOpts(opts, defaultSigOpts);\n        message = validateMsgAndHash(message, prehash);\n        return Signature.fromBytes(signature, 'recovered').recoverPublicKey(message).toBytes();\n    }\n    return Object.freeze({\n        keygen,\n        getPublicKey,\n        getSharedSecret,\n        utils,\n        lengths,\n        Point,\n        sign,\n        verify,\n        recoverPublicKey,\n        Signature,\n        hash,\n    });\n}\n/** @deprecated use `weierstrass` in newer releases */\nexport function weierstrassPoints(c) {\n    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n    const Point = weierstrassN(CURVE, curveOpts);\n    return _weierstrass_new_output_to_legacy(c, Point);\n}\nfunction _weierstrass_legacy_opts_to_new(c) {\n    const CURVE = {\n        a: c.a,\n        b: c.b,\n        p: c.Fp.ORDER,\n        n: c.n,\n        h: c.h,\n        Gx: c.Gx,\n        Gy: c.Gy,\n    };\n    const Fp = c.Fp;\n    let allowedLengths = c.allowedPrivateKeyLengths\n        ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2))))\n        : undefined;\n    const Fn = Field(CURVE.n, {\n        BITS: c.nBitLength,\n        allowedLengths: allowedLengths,\n        modFromBytes: c.wrapPrivateKey,\n    });\n    const curveOpts = {\n        Fp,\n        Fn,\n        allowInfinityPoint: c.allowInfinityPoint,\n        endo: c.endo,\n        isTorsionFree: c.isTorsionFree,\n        clearCofactor: c.clearCofactor,\n        fromBytes: c.fromBytes,\n        toBytes: c.toBytes,\n    };\n    return { CURVE, curveOpts };\n}\nfunction _ecdsa_legacy_opts_to_new(c) {\n    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n    const ecdsaOpts = {\n        hmac: c.hmac,\n        randomBytes: c.randomBytes,\n        lowS: c.lowS,\n        bits2int: c.bits2int,\n        bits2int_modN: c.bits2int_modN,\n    };\n    return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };\n}\nexport function _legacyHelperEquat(Fp, a, b) {\n    /**\n     * y = x + ax + b: Short weierstrass curve formula. Takes x, returns y.\n     * @returns y\n     */\n    function weierstrassEquation(x) {\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x + a * x + b\n    }\n    return weierstrassEquation;\n}\nfunction _weierstrass_new_output_to_legacy(c, Point) {\n    const { Fp, Fn } = Point;\n    function isWithinCurveOrder(num) {\n        return inRange(num, _1n, Fn.ORDER);\n    }\n    const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);\n    return Object.assign({}, {\n        CURVE: c,\n        Point: Point,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),\n        weierstrassEquation,\n        isWithinCurveOrder,\n    });\n}\nfunction _ecdsa_new_output_to_legacy(c, _ecdsa) {\n    const Point = _ecdsa.Point;\n    return Object.assign({}, _ecdsa, {\n        ProjectivePoint: Point,\n        CURVE: Object.assign({}, c, nLength(Point.Fn.ORDER, Point.Fn.BITS)),\n    });\n}\n// _ecdsa_legacy\nexport function weierstrass(c) {\n    const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);\n    const Point = weierstrassN(CURVE, curveOpts);\n    const signs = ecdsa(Point, hash, ecdsaOpts);\n    return _ecdsa_new_output_to_legacy(c, signs);\n}\n//# sourceMappingURL=weierstrass.js.map","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;\n\nexport function getEnableConfidentialCreditsDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR);\n}\n\nexport const ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 9;\n\nexport function getEnableConfidentialCreditsConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type EnableConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EnableConfidentialCreditsInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n};\n\nexport type EnableConfidentialCreditsInstructionDataArgs = {};\n\nexport function getEnableConfidentialCreditsInstructionDataEncoder(): FixedSizeEncoder<EnableConfidentialCreditsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEnableConfidentialCreditsInstructionDataDecoder(): FixedSizeDecoder<EnableConfidentialCreditsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getEnableConfidentialCreditsInstructionDataCodec(): FixedSizeCodec<\n  EnableConfidentialCreditsInstructionDataArgs,\n  EnableConfidentialCreditsInstructionData\n> {\n  return combineCodec(\n    getEnableConfidentialCreditsInstructionDataEncoder(),\n    getEnableConfidentialCreditsInstructionDataDecoder()\n  );\n}\n\nexport type EnableConfidentialCreditsInput<\n  TAccountToken extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEnableConfidentialCreditsInstruction<\n  TAccountToken extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EnableConfidentialCreditsInput<TAccountToken, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): EnableConfidentialCreditsInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getEnableConfidentialCreditsInstructionDataEncoder().encode({}),\n    programAddress,\n  } as EnableConfidentialCreditsInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedEnableConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[1];\n  };\n  data: EnableConfidentialCreditsInstructionData;\n};\n\nexport function parseEnableConfidentialCreditsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedEnableConfidentialCreditsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), authority: getNextAccount() },\n    data: getEnableConfidentialCreditsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ENABLE_CPI_GUARD_DISCRIMINATOR = 34;\n\nexport function getEnableCpiGuardDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_CPI_GUARD_DISCRIMINATOR);\n}\n\nexport const ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR = 0;\n\nexport function getEnableCpiGuardCpiGuardDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR);\n}\n\nexport type EnableCpiGuardInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EnableCpiGuardInstructionData = {\n  discriminator: number;\n  cpiGuardDiscriminator: number;\n};\n\nexport type EnableCpiGuardInstructionDataArgs = {};\n\nexport function getEnableCpiGuardInstructionDataEncoder(): FixedSizeEncoder<EnableCpiGuardInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['cpiGuardDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_CPI_GUARD_DISCRIMINATOR,\n      cpiGuardDiscriminator: ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEnableCpiGuardInstructionDataDecoder(): FixedSizeDecoder<EnableCpiGuardInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['cpiGuardDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getEnableCpiGuardInstructionDataCodec(): FixedSizeCodec<\n  EnableCpiGuardInstructionDataArgs,\n  EnableCpiGuardInstructionData\n> {\n  return combineCodec(\n    getEnableCpiGuardInstructionDataEncoder(),\n    getEnableCpiGuardInstructionDataDecoder()\n  );\n}\n\nexport type EnableCpiGuardInput<\n  TAccountToken extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The token account to update. */\n  token: Address<TAccountToken>;\n  /** The account's owner/delegate or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEnableCpiGuardInstruction<\n  TAccountToken extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EnableCpiGuardInput<TAccountToken, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): EnableCpiGuardInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getEnableCpiGuardInstructionDataEncoder().encode({}),\n    programAddress,\n  } as EnableCpiGuardInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedEnableCpiGuardInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token account to update. */\n    token: TAccountMetas[0];\n    /** The account's owner/delegate or its multisignature account. */\n    owner: TAccountMetas[1];\n  };\n  data: EnableCpiGuardInstructionData;\n};\n\nexport function parseEnableCpiGuardInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedEnableCpiGuardInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), owner: getNextAccount() },\n    data: getEnableCpiGuardInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ENABLE_HARVEST_TO_MINT_DISCRIMINATOR = 37;\n\nexport function getEnableHarvestToMintDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_HARVEST_TO_MINT_DISCRIMINATOR);\n}\n\nexport const ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 4;\n\nexport function getEnableHarvestToMintConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type EnableHarvestToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EnableHarvestToMintInstructionData = {\n  discriminator: number;\n  confidentialTransferFeeDiscriminator: number;\n};\n\nexport type EnableHarvestToMintInstructionDataArgs = {};\n\nexport function getEnableHarvestToMintInstructionDataEncoder(): FixedSizeEncoder<EnableHarvestToMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_HARVEST_TO_MINT_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEnableHarvestToMintInstructionDataDecoder(): FixedSizeDecoder<EnableHarvestToMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getEnableHarvestToMintInstructionDataCodec(): FixedSizeCodec<\n  EnableHarvestToMintInstructionDataArgs,\n  EnableHarvestToMintInstructionData\n> {\n  return combineCodec(\n    getEnableHarvestToMintInstructionDataEncoder(),\n    getEnableHarvestToMintInstructionDataDecoder()\n  );\n}\n\nexport type EnableHarvestToMintInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The confidential transfer fee authority */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEnableHarvestToMintInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EnableHarvestToMintInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): EnableHarvestToMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getEnableHarvestToMintInstructionDataEncoder().encode({}),\n    programAddress,\n  } as EnableHarvestToMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedEnableHarvestToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. */\n    mint: TAccountMetas[0];\n    /** The confidential transfer fee authority */\n    authority: TAccountMetas[1];\n  };\n  data: EnableHarvestToMintInstructionData;\n};\n\nexport function parseEnableHarvestToMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedEnableHarvestToMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), authority: getNextAccount() },\n    data: getEnableHarvestToMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ENABLE_MEMO_TRANSFERS_DISCRIMINATOR = 30;\n\nexport function getEnableMemoTransfersDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_MEMO_TRANSFERS_DISCRIMINATOR);\n}\n\nexport const ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR = 0;\n\nexport function getEnableMemoTransfersMemoTransfersDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR\n  );\n}\n\nexport type EnableMemoTransfersInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EnableMemoTransfersInstructionData = {\n  discriminator: number;\n  memoTransfersDiscriminator: number;\n};\n\nexport type EnableMemoTransfersInstructionDataArgs = {};\n\nexport function getEnableMemoTransfersInstructionDataEncoder(): FixedSizeEncoder<EnableMemoTransfersInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['memoTransfersDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_MEMO_TRANSFERS_DISCRIMINATOR,\n      memoTransfersDiscriminator:\n        ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEnableMemoTransfersInstructionDataDecoder(): FixedSizeDecoder<EnableMemoTransfersInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['memoTransfersDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getEnableMemoTransfersInstructionDataCodec(): FixedSizeCodec<\n  EnableMemoTransfersInstructionDataArgs,\n  EnableMemoTransfersInstructionData\n> {\n  return combineCodec(\n    getEnableMemoTransfersInstructionDataEncoder(),\n    getEnableMemoTransfersInstructionDataDecoder()\n  );\n}\n\nexport type EnableMemoTransfersInput<\n  TAccountToken extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The token account to update. */\n  token: Address<TAccountToken>;\n  /** The account's owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEnableMemoTransfersInstruction<\n  TAccountToken extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EnableMemoTransfersInput<TAccountToken, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): EnableMemoTransfersInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getEnableMemoTransfersInstructionDataEncoder().encode({}),\n    programAddress,\n  } as EnableMemoTransfersInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedEnableMemoTransfersInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token account to update. */\n    token: TAccountMetas[0];\n    /** The account's owner or its multisignature account. */\n    owner: TAccountMetas[1];\n  };\n  data: EnableMemoTransfersInstructionData;\n};\n\nexport function parseEnableMemoTransfersInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedEnableMemoTransfersInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), owner: getNextAccount() },\n    data: getEnableMemoTransfersInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;\n\nexport function getEnableNonConfidentialCreditsDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR);\n}\n\nexport const ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 11;\n\nexport function getEnableNonConfidentialCreditsConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type EnableNonConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EnableNonConfidentialCreditsInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n};\n\nexport type EnableNonConfidentialCreditsInstructionDataArgs = {};\n\nexport function getEnableNonConfidentialCreditsInstructionDataEncoder(): FixedSizeEncoder<EnableNonConfidentialCreditsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEnableNonConfidentialCreditsInstructionDataDecoder(): FixedSizeDecoder<EnableNonConfidentialCreditsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getEnableNonConfidentialCreditsInstructionDataCodec(): FixedSizeCodec<\n  EnableNonConfidentialCreditsInstructionDataArgs,\n  EnableNonConfidentialCreditsInstructionData\n> {\n  return combineCodec(\n    getEnableNonConfidentialCreditsInstructionDataEncoder(),\n    getEnableNonConfidentialCreditsInstructionDataDecoder()\n  );\n}\n\nexport type EnableNonConfidentialCreditsInput<\n  TAccountToken extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEnableNonConfidentialCreditsInstruction<\n  TAccountToken extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EnableNonConfidentialCreditsInput<TAccountToken, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): EnableNonConfidentialCreditsInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getEnableNonConfidentialCreditsInstructionDataEncoder().encode({}),\n    programAddress,\n  } as EnableNonConfidentialCreditsInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedEnableNonConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[1];\n  };\n  data: EnableNonConfidentialCreditsInstructionData;\n};\n\nexport function parseEnableNonConfidentialCreditsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedEnableNonConfidentialCreditsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), authority: getNextAccount() },\n    data: getEnableNonConfidentialCreditsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const FREEZE_ACCOUNT_DISCRIMINATOR = 10;\n\nexport function getFreezeAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(FREEZE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type FreezeAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type FreezeAccountInstructionData = { discriminator: number };\n\nexport type FreezeAccountInstructionDataArgs = {};\n\nexport function getFreezeAccountInstructionDataEncoder(): FixedSizeEncoder<FreezeAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: FREEZE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getFreezeAccountInstructionDataDecoder(): FixedSizeDecoder<FreezeAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getFreezeAccountInstructionDataCodec(): FixedSizeCodec<\n  FreezeAccountInstructionDataArgs,\n  FreezeAccountInstructionData\n> {\n  return combineCodec(\n    getFreezeAccountInstructionDataEncoder(),\n    getFreezeAccountInstructionDataDecoder()\n  );\n}\n\nexport type FreezeAccountInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The account to freeze. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The mint freeze authority or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getFreezeAccountInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: FreezeAccountInput<TAccountAccount, TAccountMint, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): FreezeAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getFreezeAccountInstructionDataEncoder().encode({}),\n    programAddress,\n  } as FreezeAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedFreezeAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to freeze. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The mint freeze authority or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: FreezeAccountInstructionData;\n};\n\nexport function parseFreezeAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedFreezeAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getFreezeAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR = 21;\n\nexport function getGetAccountDataSizeDiscriminatorBytes() {\n  return getU8Encoder().encode(GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR);\n}\n\nexport type GetAccountDataSizeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type GetAccountDataSizeInstructionData = { discriminator: number };\n\nexport type GetAccountDataSizeInstructionDataArgs = {};\n\nexport function getGetAccountDataSizeInstructionDataEncoder(): FixedSizeEncoder<GetAccountDataSizeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getGetAccountDataSizeInstructionDataDecoder(): FixedSizeDecoder<GetAccountDataSizeInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getGetAccountDataSizeInstructionDataCodec(): FixedSizeCodec<\n  GetAccountDataSizeInstructionDataArgs,\n  GetAccountDataSizeInstructionData\n> {\n  return combineCodec(\n    getGetAccountDataSizeInstructionDataEncoder(),\n    getGetAccountDataSizeInstructionDataDecoder()\n  );\n}\n\nexport type GetAccountDataSizeInput<TAccountMint extends string = string> = {\n  /** The mint to calculate for. */\n  mint: Address<TAccountMint>;\n};\n\nexport function getGetAccountDataSizeInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: GetAccountDataSizeInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): GetAccountDataSizeInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getGetAccountDataSizeInstructionDataEncoder().encode({}),\n    programAddress,\n  } as GetAccountDataSizeInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedGetAccountDataSizeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to calculate for. */\n    mint: TAccountMetas[0];\n  };\n  data: GetAccountDataSizeInstructionData;\n};\n\nexport function parseGetAccountDataSizeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedGetAccountDataSizeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getGetAccountDataSizeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR = 26;\n\nexport function getHarvestWithheldTokensToMintDiscriminatorBytes() {\n  return getU8Encoder().encode(HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR);\n}\n\nexport const HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR = 4;\n\nexport function getHarvestWithheldTokensToMintTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type HarvestWithheldTokensToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type HarvestWithheldTokensToMintInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n};\n\nexport type HarvestWithheldTokensToMintInstructionDataArgs = {};\n\nexport function getHarvestWithheldTokensToMintInstructionDataEncoder(): FixedSizeEncoder<HarvestWithheldTokensToMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR,\n      transferFeeDiscriminator:\n        HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getHarvestWithheldTokensToMintInstructionDataDecoder(): FixedSizeDecoder<HarvestWithheldTokensToMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getHarvestWithheldTokensToMintInstructionDataCodec(): FixedSizeCodec<\n  HarvestWithheldTokensToMintInstructionDataArgs,\n  HarvestWithheldTokensToMintInstructionData\n> {\n  return combineCodec(\n    getHarvestWithheldTokensToMintInstructionDataEncoder(),\n    getHarvestWithheldTokensToMintInstructionDataDecoder()\n  );\n}\n\nexport type HarvestWithheldTokensToMintInput<\n  TAccountMint extends string = string,\n> = {\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  sources: Array<Address>;\n};\n\nexport function getHarvestWithheldTokensToMintInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: HarvestWithheldTokensToMintInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): HarvestWithheldTokensToMintInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = args.sources.map((address) => ({\n    address,\n    role: AccountRole.WRITABLE,\n  }));\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint), ...remainingAccounts],\n    data: getHarvestWithheldTokensToMintInstructionDataEncoder().encode({}),\n    programAddress,\n  } as HarvestWithheldTokensToMintInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedHarvestWithheldTokensToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. */\n    mint: TAccountMetas[0];\n  };\n  data: HarvestWithheldTokensToMintInstructionData;\n};\n\nexport function parseHarvestWithheldTokensToMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedHarvestWithheldTokensToMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getHarvestWithheldTokensToMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport const HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 3;\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type HarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionData =\n  { discriminator: number; confidentialTransferFeeDiscriminator: number };\n\nexport type HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataArgs =\n  {};\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder(): FixedSizeEncoder<HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator:\n        HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder(): FixedSizeDecoder<HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataCodec(): FixedSizeCodec<\n  HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataArgs,\n  HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionData\n> {\n  return combineCodec(\n    getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder(),\n    getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder()\n  );\n}\n\nexport type HarvestWithheldTokensToMintForConfidentialTransferFeeInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  sources?: Array<Address>;\n};\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: HarvestWithheldTokensToMintForConfidentialTransferFeeInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): HarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TProgramAddress,\n  TAccountMint\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.sources ?? []).map(\n    (address) => ({ address, role: AccountRole.WRITABLE })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint), ...remainingAccounts],\n    data: getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder().encode(\n      {}\n    ),\n    programAddress,\n  } as HarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n    TProgramAddress,\n    TAccountMint\n  >);\n}\n\nexport type ParsedHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n  };\n  data: HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionData;\n};\n\nexport function parseHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ACCOUNT_DISCRIMINATOR = 1;\n\nexport function getInitializeAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type InitializeAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAccountInstructionData = { discriminator: number };\n\nexport type InitializeAccountInstructionDataArgs = {};\n\nexport function getInitializeAccountInstructionDataEncoder(): FixedSizeEncoder<InitializeAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeAccountInstructionDataDecoder(): FixedSizeDecoder<InitializeAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getInitializeAccountInstructionDataCodec(): FixedSizeCodec<\n  InitializeAccountInstructionDataArgs,\n  InitializeAccountInstructionData\n> {\n  return combineCodec(\n    getInitializeAccountInstructionDataEncoder(),\n    getInitializeAccountInstructionDataDecoder()\n  );\n}\n\nexport type InitializeAccountInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountOwner extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n  /** The mint this account will be associated with. */\n  mint: Address<TAccountMint>;\n  /** The new account's owner/multisignature. */\n  owner: Address<TAccountOwner>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n};\n\nexport function getInitializeAccountInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountOwner extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeAccountInput<\n    TAccountAccount,\n    TAccountMint,\n    TAccountOwner,\n    TAccountRent\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  TAccountOwner,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.rent),\n    ],\n    data: getInitializeAccountInstructionDataEncoder().encode({}),\n    programAddress,\n  } as InitializeAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    TAccountOwner,\n    TAccountRent\n  >);\n}\n\nexport type ParsedInitializeAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n    /** The mint this account will be associated with. */\n    mint: TAccountMetas[1];\n    /** The new account's owner/multisignature. */\n    owner: TAccountMetas[2];\n    /** Rent sysvar. */\n    rent: TAccountMetas[3];\n  };\n  data: InitializeAccountInstructionData;\n};\n\nexport function parseInitializeAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ACCOUNT2_DISCRIMINATOR = 16;\n\nexport function getInitializeAccount2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT2_DISCRIMINATOR);\n}\n\nexport type InitializeAccount2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAccount2InstructionData = {\n  discriminator: number;\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport type InitializeAccount2InstructionDataArgs = {\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport function getInitializeAccount2InstructionDataEncoder(): FixedSizeEncoder<InitializeAccount2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['owner', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT2_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeAccount2InstructionDataDecoder(): FixedSizeDecoder<InitializeAccount2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['owner', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializeAccount2InstructionDataCodec(): FixedSizeCodec<\n  InitializeAccount2InstructionDataArgs,\n  InitializeAccount2InstructionData\n> {\n  return combineCodec(\n    getInitializeAccount2InstructionDataEncoder(),\n    getInitializeAccount2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeAccount2Input<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n  /** The mint this account will be associated with. */\n  mint: Address<TAccountMint>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n  owner: InitializeAccount2InstructionDataArgs['owner'];\n};\n\nexport function getInitializeAccount2Instruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeAccount2Input<TAccountAccount, TAccountMint, TAccountRent>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAccount2Instruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.rent),\n    ],\n    data: getInitializeAccount2InstructionDataEncoder().encode(\n      args as InitializeAccount2InstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeAccount2Instruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    TAccountRent\n  >);\n}\n\nexport type ParsedInitializeAccount2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n    /** The mint this account will be associated with. */\n    mint: TAccountMetas[1];\n    /** Rent sysvar. */\n    rent: TAccountMetas[2];\n  };\n  data: InitializeAccount2InstructionData;\n};\n\nexport function parseInitializeAccount2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeAccount2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeAccount2InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ACCOUNT3_DISCRIMINATOR = 18;\n\nexport function getInitializeAccount3DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT3_DISCRIMINATOR);\n}\n\nexport type InitializeAccount3Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAccount3InstructionData = {\n  discriminator: number;\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport type InitializeAccount3InstructionDataArgs = {\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport function getInitializeAccount3InstructionDataEncoder(): FixedSizeEncoder<InitializeAccount3InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['owner', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT3_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeAccount3InstructionDataDecoder(): FixedSizeDecoder<InitializeAccount3InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['owner', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializeAccount3InstructionDataCodec(): FixedSizeCodec<\n  InitializeAccount3InstructionDataArgs,\n  InitializeAccount3InstructionData\n> {\n  return combineCodec(\n    getInitializeAccount3InstructionDataEncoder(),\n    getInitializeAccount3InstructionDataDecoder()\n  );\n}\n\nexport type InitializeAccount3Input<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n  /** The mint this account will be associated with. */\n  mint: Address<TAccountMint>;\n  owner: InitializeAccount3InstructionDataArgs['owner'];\n};\n\nexport function getInitializeAccount3Instruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeAccount3Input<TAccountAccount, TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAccount3Instruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.account), getAccountMeta(accounts.mint)],\n    data: getInitializeAccount3InstructionDataEncoder().encode(\n      args as InitializeAccount3InstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeAccount3Instruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint\n  >);\n}\n\nexport type ParsedInitializeAccount3Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n    /** The mint this account will be associated with. */\n    mint: TAccountMetas[1];\n  };\n  data: InitializeAccount3InstructionData;\n};\n\nexport function parseInitializeAccount3Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeAccount3Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { account: getNextAccount(), mint: getNextAccount() },\n    data: getInitializeAccount3InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;\n\nexport function getInitializeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport const INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 0;\n\nexport function getInitializeConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type InitializeConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeConfidentialTransferFeeInstructionData = {\n  discriminator: number;\n  confidentialTransferFeeDiscriminator: number;\n  /** Optional authority to set the withdraw withheld authority ElGamal key */\n  authority: Option<Address>;\n  /** Withheld fees from accounts must be encrypted with this ElGamal key */\n  withdrawWithheldAuthorityElGamalPubkey: Option<Address>;\n};\n\nexport type InitializeConfidentialTransferFeeInstructionDataArgs = {\n  /** Optional authority to set the withdraw withheld authority ElGamal key */\n  authority: OptionOrNullable<Address>;\n  /** Withheld fees from accounts must be encrypted with this ElGamal key */\n  withdrawWithheldAuthorityElGamalPubkey: OptionOrNullable<Address>;\n};\n\nexport function getInitializeConfidentialTransferFeeInstructionDataEncoder(): FixedSizeEncoder<InitializeConfidentialTransferFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      [\n        'withdrawWithheldAuthorityElGamalPubkey',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeConfidentialTransferFeeInstructionDataDecoder(): FixedSizeDecoder<InitializeConfidentialTransferFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'withdrawWithheldAuthorityElGamalPubkey',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeConfidentialTransferFeeInstructionDataCodec(): FixedSizeCodec<\n  InitializeConfidentialTransferFeeInstructionDataArgs,\n  InitializeConfidentialTransferFeeInstructionData\n> {\n  return combineCodec(\n    getInitializeConfidentialTransferFeeInstructionDataEncoder(),\n    getInitializeConfidentialTransferFeeInstructionDataDecoder()\n  );\n}\n\nexport type InitializeConfidentialTransferFeeInput<\n  TAccountMint extends string = string,\n> = {\n  /** The SPL Token mint. */\n  mint: Address<TAccountMint>;\n  authority: InitializeConfidentialTransferFeeInstructionDataArgs['authority'];\n  withdrawWithheldAuthorityElGamalPubkey: InitializeConfidentialTransferFeeInstructionDataArgs['withdrawWithheldAuthorityElGamalPubkey'];\n};\n\nexport function getInitializeConfidentialTransferFeeInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeConfidentialTransferFeeInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeConfidentialTransferFeeInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeConfidentialTransferFeeInstructionDataEncoder().encode(\n      args as InitializeConfidentialTransferFeeInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeConfidentialTransferFeeInstruction<\n    TProgramAddress,\n    TAccountMint\n  >);\n}\n\nexport type ParsedInitializeConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token mint. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeConfidentialTransferFeeInstructionData;\n};\n\nexport function parseInitializeConfidentialTransferFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeConfidentialTransferFeeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeConfidentialTransferFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR = 27;\n\nexport function getInitializeConfidentialTransferMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR\n  );\n}\n\nexport const INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 0;\n\nexport function getInitializeConfidentialTransferMintConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type InitializeConfidentialTransferMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeConfidentialTransferMintInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /**\n   * Authority to modify the `ConfidentialTransferMint` configuration and to\n   * approve new accounts.\n   */\n  authority: Option<Address>;\n  /**\n   * Determines if newly configured accounts must be approved by the\n   * `authority` before they may be used by the user.\n   */\n  autoApproveNewAccounts: boolean;\n  /** New authority to decode any transfer amount in a confidential transfer. */\n  auditorElgamalPubkey: Option<Address>;\n};\n\nexport type InitializeConfidentialTransferMintInstructionDataArgs = {\n  /**\n   * Authority to modify the `ConfidentialTransferMint` configuration and to\n   * approve new accounts.\n   */\n  authority: OptionOrNullable<Address>;\n  /**\n   * Determines if newly configured accounts must be approved by the\n   * `authority` before they may be used by the user.\n   */\n  autoApproveNewAccounts: boolean;\n  /** New authority to decode any transfer amount in a confidential transfer. */\n  auditorElgamalPubkey: OptionOrNullable<Address>;\n};\n\nexport function getInitializeConfidentialTransferMintInstructionDataEncoder(): FixedSizeEncoder<InitializeConfidentialTransferMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      ['autoApproveNewAccounts', getBooleanEncoder()],\n      [\n        'auditorElgamalPubkey',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeConfidentialTransferMintInstructionDataDecoder(): FixedSizeDecoder<InitializeConfidentialTransferMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['autoApproveNewAccounts', getBooleanDecoder()],\n    [\n      'auditorElgamalPubkey',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeConfidentialTransferMintInstructionDataCodec(): FixedSizeCodec<\n  InitializeConfidentialTransferMintInstructionDataArgs,\n  InitializeConfidentialTransferMintInstructionData\n> {\n  return combineCodec(\n    getInitializeConfidentialTransferMintInstructionDataEncoder(),\n    getInitializeConfidentialTransferMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeConfidentialTransferMintInput<\n  TAccountMint extends string = string,\n> = {\n  /** The SPL Token mint. */\n  mint: Address<TAccountMint>;\n  authority: InitializeConfidentialTransferMintInstructionDataArgs['authority'];\n  autoApproveNewAccounts: InitializeConfidentialTransferMintInstructionDataArgs['autoApproveNewAccounts'];\n  auditorElgamalPubkey: InitializeConfidentialTransferMintInstructionDataArgs['auditorElgamalPubkey'];\n};\n\nexport function getInitializeConfidentialTransferMintInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeConfidentialTransferMintInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeConfidentialTransferMintInstruction<\n  TProgramAddress,\n  TAccountMint\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeConfidentialTransferMintInstructionDataEncoder().encode(\n      args as InitializeConfidentialTransferMintInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeConfidentialTransferMintInstruction<\n    TProgramAddress,\n    TAccountMint\n  >);\n}\n\nexport type ParsedInitializeConfidentialTransferMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token mint. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeConfidentialTransferMintInstructionData;\n};\n\nexport function parseInitializeConfidentialTransferMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeConfidentialTransferMintInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeConfidentialTransferMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getAccountStateDecoder,\n  getAccountStateEncoder,\n  type AccountState,\n  type AccountStateArgs,\n} from '../types';\n\nexport const INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 28;\n\nexport function getInitializeDefaultAccountStateDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 0;\n\nexport function getInitializeDefaultAccountStateDefaultAccountStateDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR\n  );\n}\n\nexport type InitializeDefaultAccountStateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeDefaultAccountStateInstructionData = {\n  discriminator: number;\n  defaultAccountStateDiscriminator: number;\n  /** The state each new token account should start with. */\n  state: AccountState;\n};\n\nexport type InitializeDefaultAccountStateInstructionDataArgs = {\n  /** The state each new token account should start with. */\n  state: AccountStateArgs;\n};\n\nexport function getInitializeDefaultAccountStateInstructionDataEncoder(): FixedSizeEncoder<InitializeDefaultAccountStateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['defaultAccountStateDiscriminator', getU8Encoder()],\n      ['state', getAccountStateEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR,\n      defaultAccountStateDiscriminator:\n        INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeDefaultAccountStateInstructionDataDecoder(): FixedSizeDecoder<InitializeDefaultAccountStateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['defaultAccountStateDiscriminator', getU8Decoder()],\n    ['state', getAccountStateDecoder()],\n  ]);\n}\n\nexport function getInitializeDefaultAccountStateInstructionDataCodec(): FixedSizeCodec<\n  InitializeDefaultAccountStateInstructionDataArgs,\n  InitializeDefaultAccountStateInstructionData\n> {\n  return combineCodec(\n    getInitializeDefaultAccountStateInstructionDataEncoder(),\n    getInitializeDefaultAccountStateInstructionDataDecoder()\n  );\n}\n\nexport type InitializeDefaultAccountStateInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  state: InitializeDefaultAccountStateInstructionDataArgs['state'];\n};\n\nexport function getInitializeDefaultAccountStateInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeDefaultAccountStateInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeDefaultAccountStateInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeDefaultAccountStateInstructionDataEncoder().encode(\n      args as InitializeDefaultAccountStateInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeDefaultAccountStateInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeDefaultAccountStateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeDefaultAccountStateInstructionData;\n};\n\nexport function parseInitializeDefaultAccountStateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeDefaultAccountStateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeDefaultAccountStateInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR = 41;\n\nexport function getInitializeGroupMemberPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR = 0;\n\nexport function getInitializeGroupMemberPointerGroupMemberPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type InitializeGroupMemberPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeGroupMemberPointerInstructionData = {\n  discriminator: number;\n  groupMemberPointerDiscriminator: number;\n  /** The public key for the account that can update the group member address. */\n  authority: Option<Address>;\n  /** The account address that holds the member. */\n  memberAddress: Option<Address>;\n};\n\nexport type InitializeGroupMemberPointerInstructionDataArgs = {\n  /** The public key for the account that can update the group member address. */\n  authority: OptionOrNullable<Address>;\n  /** The account address that holds the member. */\n  memberAddress: OptionOrNullable<Address>;\n};\n\nexport function getInitializeGroupMemberPointerInstructionDataEncoder(): FixedSizeEncoder<InitializeGroupMemberPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['groupMemberPointerDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      [\n        'memberAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR,\n      groupMemberPointerDiscriminator:\n        INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeGroupMemberPointerInstructionDataDecoder(): FixedSizeDecoder<InitializeGroupMemberPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['groupMemberPointerDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'memberAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeGroupMemberPointerInstructionDataCodec(): FixedSizeCodec<\n  InitializeGroupMemberPointerInstructionDataArgs,\n  InitializeGroupMemberPointerInstructionData\n> {\n  return combineCodec(\n    getInitializeGroupMemberPointerInstructionDataEncoder(),\n    getInitializeGroupMemberPointerInstructionDataDecoder()\n  );\n}\n\nexport type InitializeGroupMemberPointerInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  authority: InitializeGroupMemberPointerInstructionDataArgs['authority'];\n  memberAddress: InitializeGroupMemberPointerInstructionDataArgs['memberAddress'];\n};\n\nexport function getInitializeGroupMemberPointerInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeGroupMemberPointerInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeGroupMemberPointerInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeGroupMemberPointerInstructionDataEncoder().encode(\n      args as InitializeGroupMemberPointerInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeGroupMemberPointerInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeGroupMemberPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeGroupMemberPointerInstructionData;\n};\n\nexport function parseInitializeGroupMemberPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeGroupMemberPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeGroupMemberPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { weierstrass } from \"./abstract/weierstrass.js\";\n/** connects noble-curves to noble-hashes */\nexport function getHash(hash) {\n    return { hash };\n}\n/** @deprecated use new `weierstrass()` and `ecdsa()` methods */\nexport function createCurve(curveDef, defHash) {\n    const create = (hash) => weierstrass({ ...curveDef, hash: hash });\n    return { ...create(defHash), create };\n}\n//# sourceMappingURL=_shortw_utils.js.map","/**\n * Internal module for NIST P256, P384, P521 curves.\n * Do not use for now.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256, sha384, sha512 } from '@noble/hashes/sha2.js';\nimport { createCurve } from \"./_shortw_utils.js\";\nimport { createHasher } from \"./abstract/hash-to-curve.js\";\nimport { Field } from \"./abstract/modular.js\";\nimport { mapToCurveSimpleSWU, } from \"./abstract/weierstrass.js\";\n// p = 2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n - 1n\n// a = Fp256.create(BigInt('-3'));\nconst p256_CURVE = {\n    p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),\n    n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n    h: BigInt(1),\n    a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),\n    b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),\n    Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n    Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n};\n// p = 2n**384n - 2n**128n - 2n**96n + 2n**32n - 1n\nconst p384_CURVE = {\n    p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff'),\n    n: BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973'),\n    h: BigInt(1),\n    a: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc'),\n    b: BigInt('0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef'),\n    Gx: BigInt('0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7'),\n    Gy: BigInt('0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f'),\n};\n// p = 2n**521n - 1n\nconst p521_CURVE = {\n    p: BigInt('0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'),\n    n: BigInt('0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409'),\n    h: BigInt(1),\n    a: BigInt('0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc'),\n    b: BigInt('0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00'),\n    Gx: BigInt('0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66'),\n    Gy: BigInt('0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650'),\n};\nconst Fp256 = Field(p256_CURVE.p);\nconst Fp384 = Field(p384_CURVE.p);\nconst Fp521 = Field(p521_CURVE.p);\nfunction createSWU(Point, opts) {\n    const map = mapToCurveSimpleSWU(Point.Fp, opts);\n    return (scalars) => map(scalars[0]);\n}\n/** NIST P256 (aka secp256r1, prime256v1) curve, ECDSA and ECDH methods. */\nexport const p256 = createCurve({ ...p256_CURVE, Fp: Fp256, lowS: false }, sha256);\n/** Hashing / encoding to p256 points / field. RFC 9380 methods. */\nexport const p256_hasher = /* @__PURE__ */ (() => {\n    return createHasher(p256.Point, createSWU(p256.Point, {\n        A: p256_CURVE.a,\n        B: p256_CURVE.b,\n        Z: p256.Point.Fp.create(BigInt('-10')),\n    }), {\n        DST: 'P256_XMD:SHA-256_SSWU_RO_',\n        encodeDST: 'P256_XMD:SHA-256_SSWU_NU_',\n        p: p256_CURVE.p,\n        m: 1,\n        k: 128,\n        expand: 'xmd',\n        hash: sha256,\n    });\n})();\n// export const p256_oprf: OPRF = createORPF({\n//   name: 'P256-SHA256',\n//   Point: p256.Point,\n//   hash: sha256,\n//   hashToGroup: p256_hasher.hashToCurve,\n//   hashToScalar: p256_hasher.hashToScalar,\n// });\n/** NIST P384 (aka secp384r1) curve, ECDSA and ECDH methods. */\nexport const p384 = createCurve({ ...p384_CURVE, Fp: Fp384, lowS: false }, sha384);\n/** Hashing / encoding to p384 points / field. RFC 9380 methods. */\nexport const p384_hasher = /* @__PURE__ */ (() => {\n    return createHasher(p384.Point, createSWU(p384.Point, {\n        A: p384_CURVE.a,\n        B: p384_CURVE.b,\n        Z: p384.Point.Fp.create(BigInt('-12')),\n    }), {\n        DST: 'P384_XMD:SHA-384_SSWU_RO_',\n        encodeDST: 'P384_XMD:SHA-384_SSWU_NU_',\n        p: p384_CURVE.p,\n        m: 1,\n        k: 192,\n        expand: 'xmd',\n        hash: sha384,\n    });\n})();\n// export const p384_oprf: OPRF = createORPF({\n//   name: 'P384-SHA384',\n//   Point: p384.Point,\n//   hash: sha384,\n//   hashToGroup: p384_hasher.hashToCurve,\n//   hashToScalar: p384_hasher.hashToScalar,\n// });\n// const Fn521 = Field(p521_CURVE.n, { allowedScalarLengths: [65, 66] });\n/** NIST P521 (aka secp521r1) curve, ECDSA and ECDH methods. */\nexport const p521 = createCurve({ ...p521_CURVE, Fp: Fp521, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, sha512);\n/** @deprecated use `p256` for consistency with `p256_hasher` */\nexport const secp256r1 = p256;\n/** @deprecated use `p384` for consistency with `p384_hasher` */\nexport const secp384r1 = p384;\n/** @deprecated use `p521` for consistency with `p521_hasher` */\nexport const secp521r1 = p521;\n/** Hashing / encoding to p521 points / field. RFC 9380 methods. */\nexport const p521_hasher = /* @__PURE__ */ (() => {\n    return createHasher(p521.Point, createSWU(p521.Point, {\n        A: p521_CURVE.a,\n        B: p521_CURVE.b,\n        Z: p521.Point.Fp.create(BigInt('-4')),\n    }), {\n        DST: 'P521_XMD:SHA-512_SSWU_RO_',\n        encodeDST: 'P521_XMD:SHA-512_SSWU_NU_',\n        p: p521_CURVE.p,\n        m: 1,\n        k: 256,\n        expand: 'xmd',\n        hash: sha512,\n    });\n})();\n// export const p521_oprf: OPRF = createORPF({\n//   name: 'P521-SHA512',\n//   Point: p521.Point,\n//   hash: sha512,\n//   hashToGroup: p521_hasher.hashToCurve,\n//   hashToScalar: p521_hasher.hashToScalar, // produces L=98 just like in RFC\n// });\n//# sourceMappingURL=nist.js.map","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_GROUP_POINTER_DISCRIMINATOR = 40;\n\nexport function getInitializeGroupPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_GROUP_POINTER_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR = 0;\n\nexport function getInitializeGroupPointerGroupPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type InitializeGroupPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeGroupPointerInstructionData = {\n  discriminator: number;\n  groupPointerDiscriminator: number;\n  /** The public key for the account that can update the group address. */\n  authority: Option<Address>;\n  /** The account address that holds the group. */\n  groupAddress: Option<Address>;\n};\n\nexport type InitializeGroupPointerInstructionDataArgs = {\n  /** The public key for the account that can update the group address. */\n  authority: OptionOrNullable<Address>;\n  /** The account address that holds the group. */\n  groupAddress: OptionOrNullable<Address>;\n};\n\nexport function getInitializeGroupPointerInstructionDataEncoder(): FixedSizeEncoder<InitializeGroupPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['groupPointerDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      [\n        'groupAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_GROUP_POINTER_DISCRIMINATOR,\n      groupPointerDiscriminator:\n        INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeGroupPointerInstructionDataDecoder(): FixedSizeDecoder<InitializeGroupPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['groupPointerDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'groupAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeGroupPointerInstructionDataCodec(): FixedSizeCodec<\n  InitializeGroupPointerInstructionDataArgs,\n  InitializeGroupPointerInstructionData\n> {\n  return combineCodec(\n    getInitializeGroupPointerInstructionDataEncoder(),\n    getInitializeGroupPointerInstructionDataDecoder()\n  );\n}\n\nexport type InitializeGroupPointerInput<TAccountMint extends string = string> =\n  {\n    /** The mint to initialize. */\n    mint: Address<TAccountMint>;\n    authority: InitializeGroupPointerInstructionDataArgs['authority'];\n    groupAddress: InitializeGroupPointerInstructionDataArgs['groupAddress'];\n  };\n\nexport function getInitializeGroupPointerInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeGroupPointerInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeGroupPointerInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeGroupPointerInstructionDataEncoder().encode(\n      args as InitializeGroupPointerInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeGroupPointerInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeGroupPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeGroupPointerInstructionData;\n};\n\nexport function parseInitializeGroupPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeGroupPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeGroupPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * NIST secp256r1 aka p256.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {} from \"./abstract/hash-to-curve.js\";\nimport { p256_hasher, p256 as p256n } from \"./nist.js\";\n/** @deprecated use `import { p256 } from '@noble/curves/nist.js';` */\nexport const p256 = p256n;\n/** @deprecated use `import { p256 } from '@noble/curves/nist.js';` */\nexport const secp256r1 = p256n;\n/** @deprecated use `import { p256_hasher } from '@noble/curves/nist.js';` */\nexport const hashToCurve = /* @__PURE__ */ (() => p256_hasher.hashToCurve)();\n/** @deprecated use `import { p256_hasher } from '@noble/curves/nist.js';` */\nexport const encodeToCurve = /* @__PURE__ */ (() => p256_hasher.encodeToCurve)();\n//# sourceMappingURL=p256.js.map","import { chacha20poly1305 } from \"@noble/ciphers/chacha\";\nimport { hkdf } from \"@noble/hashes/hkdf\";\nimport { randomBytes } from \"@noble/hashes/utils\";\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport { x25519 } from \"@noble/curves/ed25519\";\nimport { p256 } from \"@noble/curves/p256\";\nimport { CryptoTypes } from \"@walletconnect/types\";\nimport { decodeJWT } from \"@walletconnect/relay-auth\";\nimport { concat, fromString, toString } from \"uint8arrays\";\n\nexport const BASE10 = \"base10\";\nexport const BASE16 = \"base16\";\nexport const BASE64 = \"base64pad\";\nexport const BASE64URL = \"base64url\";\nexport const UTF8 = \"utf8\";\n\nexport const TYPE_0 = 0;\nexport const TYPE_1 = 1;\nexport const TYPE_2 = 2;\n\nexport type P256KeyDataType = {\n  crv: \"P-256\" | string;\n  ext: true | boolean;\n  key_ops: [\"verify\"] | string[];\n  kty: string;\n  x: string;\n  y: string;\n};\n\nconst ZERO_INDEX = 0;\nconst TYPE_LENGTH = 1;\nconst IV_LENGTH = 12;\nconst KEY_LENGTH = 32;\n\nexport function generateKeyPair(): CryptoTypes.KeyPair {\n  const privateKey = x25519.utils.randomPrivateKey();\n  const publicKey = x25519.getPublicKey(privateKey);\n  return {\n    privateKey: toString(privateKey, BASE16),\n    publicKey: toString(publicKey, BASE16),\n  };\n}\n\nexport function generateRandomBytes32(): string {\n  const random = randomBytes(KEY_LENGTH);\n  return toString(random, BASE16);\n}\n\nexport function deriveSymKey(privateKeyA: string, publicKeyB: string): string {\n  const sharedKey = x25519.getSharedSecret(\n    fromString(privateKeyA, BASE16),\n    fromString(publicKeyB, BASE16),\n  );\n  const symKey = hkdf(sha256, sharedKey, undefined, undefined, KEY_LENGTH);\n  return toString(symKey, BASE16);\n}\n\nexport function hashKey(key: string): string {\n  const result = sha256(fromString(key, BASE16));\n  return toString(result, BASE16);\n}\n\nexport function hashMessage(message: string): string {\n  const result = sha256(fromString(message, UTF8));\n  return toString(result, BASE16);\n}\n\nexport function encodeTypeByte(type: number): Uint8Array {\n  return fromString(`${type}`, BASE10);\n}\n\nexport function decodeTypeByte(byte: Uint8Array): number {\n  return Number(toString(byte, BASE10));\n}\n\nfunction toBase64URL(base64: string): string {\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\n\nfunction fromBase64URL(base64url: string): string {\n  const base64 = base64url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const padding = (4 - (base64.length % 4)) % 4;\n  return base64 + \"=\".repeat(padding);\n}\n\nexport function encrypt(params: CryptoTypes.EncryptParams): string {\n  const type = encodeTypeByte(typeof params.type !== \"undefined\" ? params.type : TYPE_0);\n  if (decodeTypeByte(type) === TYPE_1 && typeof params.senderPublicKey === \"undefined\") {\n    throw new Error(\"Missing sender public key for type 1 envelope\");\n  }\n  const senderPublicKey =\n    typeof params.senderPublicKey !== \"undefined\"\n      ? fromString(params.senderPublicKey, BASE16)\n      : undefined;\n\n  const iv =\n    typeof params.iv !== \"undefined\" ? fromString(params.iv, BASE16) : randomBytes(IV_LENGTH);\n  const key = fromString(params.symKey, BASE16);\n  const box = chacha20poly1305(key, iv);\n  const sealed = box.encrypt(fromString(params.message, UTF8));\n  const result = serialize({ type, sealed, iv, senderPublicKey });\n  return params.encoding === BASE64URL ? toBase64URL(result) : result;\n}\n\nexport function decrypt(params: CryptoTypes.DecryptParams): string {\n  const key = fromString(params.symKey, BASE16);\n  const { sealed, iv } = deserialize({ encoded: params.encoded, encoding: params.encoding });\n  const box = chacha20poly1305(key, iv);\n  const message = box.decrypt(sealed);\n  if (message === null) throw new Error(\"Failed to decrypt\");\n  return toString(message, UTF8);\n}\n\nexport function encodeTypeTwoEnvelope(\n  message: string,\n  encoding?: CryptoTypes.EncodingType,\n): string {\n  const type = encodeTypeByte(TYPE_2);\n  // iv is not used in type 2 envelopes\n  const iv = randomBytes(IV_LENGTH);\n  const sealed = fromString(message, UTF8);\n  const result = serialize({ type, sealed, iv });\n  return encoding === BASE64URL ? toBase64URL(result) : result;\n}\n\nexport function decodeTypeTwoEnvelope(\n  encoded: string,\n  encoding?: CryptoTypes.EncodingType,\n): string {\n  const { sealed } = deserialize({ encoded, encoding });\n  return toString(sealed, UTF8);\n}\n\nexport function serialize(params: CryptoTypes.EncodingParams): string {\n  if (decodeTypeByte(params.type) === TYPE_2) {\n    return toString(concat([params.type, params.sealed]), BASE64);\n  }\n  if (decodeTypeByte(params.type) === TYPE_1) {\n    if (typeof params.senderPublicKey === \"undefined\") {\n      throw new Error(\"Missing sender public key for type 1 envelope\");\n    }\n    return toString(\n      concat([params.type, params.senderPublicKey, params.iv, params.sealed]),\n      BASE64,\n    );\n  }\n  // default to type 0 envelope\n  return toString(concat([params.type, params.iv, params.sealed]), BASE64);\n}\n\nexport function deserialize(params: CryptoTypes.DecodingParams): CryptoTypes.EncodingParams {\n  const encoding = params.encoding || BASE64;\n  const normalizedEncoded = encoding === BASE64URL ? fromBase64URL(params.encoded) : params.encoded;\n  const bytes = fromString(normalizedEncoded, BASE64);\n  const type = bytes.slice(ZERO_INDEX, TYPE_LENGTH);\n  const slice1 = TYPE_LENGTH;\n  if (decodeTypeByte(type) === TYPE_1) {\n    const slice2 = slice1 + KEY_LENGTH;\n    const slice3 = slice2 + IV_LENGTH;\n    const senderPublicKey = bytes.slice(slice1, slice2);\n    const iv = bytes.slice(slice2, slice3);\n    const sealed = bytes.slice(slice3);\n    return { type, sealed, iv, senderPublicKey };\n  }\n  if (decodeTypeByte(type) === TYPE_2) {\n    const sealed = bytes.slice(slice1);\n    // iv is not used in type 2 envelopes\n    const iv = randomBytes(IV_LENGTH);\n    return { type, sealed, iv };\n  }\n  // default to type 0 envelope\n  const slice2 = slice1 + IV_LENGTH;\n  const iv = bytes.slice(slice1, slice2);\n  const sealed = bytes.slice(slice2);\n  return { type, sealed, iv };\n}\n\nexport function validateDecoding(\n  encoded: string,\n  opts?: CryptoTypes.DecodeOptions,\n): CryptoTypes.EncodingValidation {\n  const deserialized = deserialize({ encoded, encoding: opts?.encoding });\n  return validateEncoding({\n    type: decodeTypeByte(deserialized.type),\n    senderPublicKey:\n      typeof deserialized.senderPublicKey !== \"undefined\"\n        ? toString(deserialized.senderPublicKey, BASE16)\n        : undefined,\n    receiverPublicKey: opts?.receiverPublicKey,\n  });\n}\n\nexport function validateEncoding(opts?: CryptoTypes.EncodeOptions): CryptoTypes.EncodingValidation {\n  const type = opts?.type || TYPE_0;\n  if (type === TYPE_1) {\n    if (typeof opts?.senderPublicKey === \"undefined\") {\n      throw new Error(\"missing sender public key\");\n    }\n    if (typeof opts?.receiverPublicKey === \"undefined\") {\n      throw new Error(\"missing receiver public key\");\n    }\n  }\n  return {\n    type,\n    senderPublicKey: opts?.senderPublicKey,\n    receiverPublicKey: opts?.receiverPublicKey,\n  };\n}\n\nexport function isTypeOneEnvelope(\n  result: CryptoTypes.EncodingValidation,\n): result is CryptoTypes.TypeOneParams {\n  return (\n    result.type === TYPE_1 &&\n    typeof result.senderPublicKey === \"string\" &&\n    typeof result.receiverPublicKey === \"string\"\n  );\n}\n\nexport function isTypeTwoEnvelope(\n  result: CryptoTypes.EncodingValidation,\n): result is CryptoTypes.TypeOneParams {\n  return result.type === TYPE_2;\n}\n\nexport function getCryptoKeyFromKeyData(keyData: P256KeyDataType): Uint8Array {\n  const xBuffer = Buffer.from(keyData.x, \"base64\");\n  const yBuffer = Buffer.from(keyData.y, \"base64\");\n\n  // Concatenate x and y coordinates with 0x04 prefix (uncompressed point format)\n  return concat([new Uint8Array([0x04]), xBuffer, yBuffer]);\n}\n\nexport function verifyP256Jwt<T>(token: string, keyData: P256KeyDataType) {\n  const [headerBase64Url, payloadBase64Url, signatureBase64Url] = token.split(\".\");\n\n  // Decode the signature\n  const signatureBuffer = Buffer.from(fromBase64URL(signatureBase64Url), \"base64\");\n\n  // Check if signature length is correct (64 bytes for P-256)\n  if (signatureBuffer.length !== 64) {\n    throw new Error(\"Invalid signature length\");\n  }\n\n  // Extract r and s from the signature\n  const r = signatureBuffer.slice(0, 32);\n  const s = signatureBuffer.slice(32, 64);\n\n  // Create the signing input\n  const signingInput = `${headerBase64Url}.${payloadBase64Url}`;\n\n  // Hash the signing input\n  const messageHash = sha256(signingInput);\n\n  // Get the public key in uncompressed point format\n  const publicKey = getCryptoKeyFromKeyData(keyData);\n\n  // Verify the signature using noble/curves p256\n  const isValid = p256.verify(\n    concat([r, s]), // signature bytes\n    messageHash, // message hash\n    publicKey, // public key in uncompressed format\n  );\n\n  if (!isValid) {\n    throw new Error(\"Invalid signature\");\n  }\n\n  const data = decodeJWT(token) as unknown as { payload: T };\n  return data.payload;\n}\n","import { EngineTypes, RelayerTypes } from \"@walletconnect/types\";\nimport { fromBase64 } from \"./misc.js\";\n\n// -- uri -------------------------------------------------- //\n\nexport function parseRelayParams(params: any, delimiter = \"-\"): RelayerTypes.ProtocolOptions {\n  const relay: any = {};\n  const prefix = \"relay\" + delimiter;\n  Object.keys(params).forEach((key) => {\n    if (key.startsWith(prefix)) {\n      const name = key.replace(prefix, \"\");\n      const value = params[key];\n      relay[name] = value;\n    }\n  });\n  return relay;\n}\n\nexport function parseUri(str: string): EngineTypes.UriParameters {\n  if (!str.includes(\"wc:\")) {\n    const parsed = fromBase64(str);\n    if (parsed?.includes(\"wc:\")) {\n      str = parsed;\n    }\n  }\n\n  // remove android schema prefix\n  str = str.includes(\"wc://\") ? str.replace(\"wc://\", \"\") : str;\n  // remove ios schema prefix\n  str = str.includes(\"wc:\") ? str.replace(\"wc:\", \"\") : str;\n  const pathStart: number = str.indexOf(\":\");\n  const pathEnd: number | undefined = str.indexOf(\"?\") !== -1 ? str.indexOf(\"?\") : undefined;\n  const protocol: string = str.substring(0, pathStart);\n  const path: string = str.substring(pathStart + 1, pathEnd);\n  const requiredValues = path.split(\"@\");\n  const queryString: string = typeof pathEnd !== \"undefined\" ? str.substring(pathEnd) : \"\";\n  const urlSearchParams = new URLSearchParams(queryString);\n  const queryParams = Object.fromEntries(urlSearchParams.entries());\n  const methods =\n    typeof queryParams.methods === \"string\" ? queryParams.methods.split(\",\") : undefined;\n  const result = {\n    protocol,\n    topic: parseTopic(requiredValues[0]),\n    version: parseInt(requiredValues[1], 10),\n    symKey: queryParams.symKey as string,\n    relay: parseRelayParams(queryParams),\n    methods,\n    expiryTimestamp: queryParams.expiryTimestamp\n      ? parseInt(queryParams.expiryTimestamp as string, 10)\n      : undefined,\n  };\n  return result;\n}\n\nexport function parseTopic(topic: string): string {\n  return topic.startsWith(\"//\") ? topic.substring(2) : topic;\n}\n\nexport function formatRelayParams(relay: RelayerTypes.ProtocolOptions, delimiter = \"-\") {\n  const prefix = \"relay\";\n  const params: any = {};\n  Object.keys(relay).forEach((key) => {\n    const typedKey = key as keyof typeof relay;\n    const k = prefix + delimiter + typedKey;\n    if (relay[typedKey]) {\n      params[k] = relay[typedKey];\n    }\n  });\n  return params;\n}\n\nexport function formatUri(params: EngineTypes.UriParameters): string {\n  const urlSearchParams = new URLSearchParams();\n\n  // Combine all params into a single object first\n  const allParams = {\n    ...formatRelayParams(params.relay),\n    symKey: params.symKey,\n    ...(params.expiryTimestamp && { expiryTimestamp: params.expiryTimestamp.toString() }),\n    ...(params.methods && { methods: params.methods.join(\",\") }),\n  };\n\n  // Sort and append all at once\n  Object.entries(allParams)\n    .sort(([a], [b]) => a.localeCompare(b))\n    .forEach(([key, value]) => {\n      if (value !== undefined) {\n        urlSearchParams.append(key, String(value));\n      }\n    });\n\n  return `${params.protocol}:${params.topic}@${params.version}?${urlSearchParams}`;\n}\n\nexport function getLinkModeURL(\n  universalLink: string,\n  topic: string,\n  encodedEnvelope: string,\n): string {\n  return `${universalLink}?wc_ev=${encodedEnvelope}&topic=${topic}`;\n}\n","import { ProposalTypes, SessionTypes } from \"@walletconnect/types\";\nimport { mergeArrays } from \"./misc.js\";\nimport { isConformingNamespaces, isValidNamespaces, isValidObject } from \"./validators.js\";\n\nexport function getAccountsChains(accounts: SessionTypes.Namespace[\"accounts\"]) {\n  const chains: string[] = [];\n  accounts.forEach((account) => {\n    const [chain, chainId] = account.split(\":\");\n    chains.push(`${chain}:${chainId}`);\n  });\n\n  return chains;\n}\n\nexport function getNamespacesChains(namespaces: SessionTypes.Namespaces) {\n  const chains: string[] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    chains.push(...getAccountsChains(namespace.accounts));\n  });\n\n  return chains;\n}\n\nexport function getNamespacesMethodsForChainId(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n) {\n  const methods: SessionTypes.Namespace[\"methods\"] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    const chains = getAccountsChains(namespace.accounts);\n    if (chains.includes(chainId)) methods.push(...namespace.methods);\n  });\n\n  return methods;\n}\n\nexport function getNamespacesEventsForChainId(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n) {\n  const events: SessionTypes.Namespace[\"events\"] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    const chains = getAccountsChains(namespace.accounts);\n    if (chains.includes(chainId)) events.push(...namespace.events);\n  });\n\n  return events;\n}\n\nexport function getRequiredNamespacesFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  caller: string,\n): ProposalTypes.RequiredNamespaces {\n  const validNamespacesError = isValidNamespaces(namespaces, caller);\n  if (validNamespacesError) throw new Error(validNamespacesError.message);\n\n  const required: ProposalTypes.RequiredNamespaces = {};\n  for (const [namespace, values] of Object.entries(namespaces)) {\n    required[namespace] = {\n      methods: values.methods,\n      events: values.events,\n      chains: values.accounts.map((account) => `${account.split(\":\")[0]}:${account.split(\":\")[1]}`),\n    };\n  }\n  return required;\n}\n\nexport type BuildApprovedNamespacesParams = {\n  proposal: ProposalTypes.Struct;\n  supportedNamespaces: Record<\n    string,\n    { chains: string[]; methods: string[]; events: string[]; accounts: string[] }\n  >;\n};\n\n/**\n * util designed for Wallets that builds namespaces structure by provided supported chains, methods, events & accounts.\n * It takes required & optional namespaces provided in the session proposal\n * along with the supported chains/methods/events/accounts by the wallet and returns a structured namespaces object\n * @param {BuildApprovedNamespacesParams} params\n * @returns {SessionTypes.Namespaces}\n */\nexport function buildApprovedNamespaces(\n  params: BuildApprovedNamespacesParams,\n): SessionTypes.Namespaces {\n  const {\n    proposal: { requiredNamespaces, optionalNamespaces = {} },\n    supportedNamespaces,\n  } = params;\n  const normalizedRequired = normalizeNamespaces(requiredNamespaces);\n  const normalizedOptional = normalizeNamespaces(optionalNamespaces);\n\n  // build approved namespaces\n  const namespaces: SessionTypes.Namespaces = {};\n  Object.keys(supportedNamespaces).forEach((namespace) => {\n    const supportedChains = supportedNamespaces[namespace].chains;\n    const supportedMethods = supportedNamespaces[namespace].methods;\n    const supportedEvents = supportedNamespaces[namespace].events;\n    const supportedAccounts = supportedNamespaces[namespace].accounts;\n\n    supportedChains.forEach((chain) => {\n      if (!supportedAccounts.some((account) => account.includes(chain))) {\n        throw new Error(`No accounts provided for chain ${chain} in namespace ${namespace}`);\n      }\n    });\n\n    namespaces[namespace] = {\n      chains: supportedChains,\n      methods: supportedMethods,\n      events: supportedEvents,\n      accounts: supportedAccounts,\n    };\n  });\n\n  // verify all required namespaces are supported\n  const err = isConformingNamespaces(requiredNamespaces, namespaces, \"approve()\");\n  if (err) throw new Error(err.message);\n\n  const approvedNamespaces: SessionTypes.Namespaces = {};\n\n  // if both required & optional namespaces are empty, return all supported namespaces by the wallet\n  if (!Object.keys(requiredNamespaces).length && !Object.keys(optionalNamespaces).length)\n    return namespaces;\n\n  // assign accounts for the required namespaces\n  Object.keys(normalizedRequired).forEach((requiredNamespace) => {\n    const chains = supportedNamespaces[requiredNamespace].chains.filter((chain) =>\n      normalizedRequired[requiredNamespace]?.chains?.includes(chain),\n    );\n    const methods = supportedNamespaces[requiredNamespace].methods.filter((method) =>\n      normalizedRequired[requiredNamespace]?.methods?.includes(method),\n    );\n    const events = supportedNamespaces[requiredNamespace].events.filter((event) =>\n      normalizedRequired[requiredNamespace]?.events?.includes(event),\n    );\n\n    const accounts = chains\n      .map((chain: string) =>\n        supportedNamespaces[requiredNamespace].accounts.filter((account: string) =>\n          account.includes(`${chain}:`),\n        ),\n      )\n      .flat();\n\n    approvedNamespaces[requiredNamespace] = {\n      chains,\n      methods,\n      events,\n      accounts,\n    };\n  });\n\n  // add optional namespaces\n  Object.keys(normalizedOptional).forEach((optionalNamespace) => {\n    if (!supportedNamespaces[optionalNamespace]) return;\n\n    const chainsToAdd = normalizedOptional[optionalNamespace]?.chains?.filter((chain) =>\n      supportedNamespaces[optionalNamespace].chains.includes(chain),\n    );\n    const methodsToAdd = supportedNamespaces[optionalNamespace].methods.filter((method) =>\n      normalizedOptional[optionalNamespace]?.methods?.includes(method),\n    );\n    const eventsToAdd = supportedNamespaces[optionalNamespace].events.filter((event) =>\n      normalizedOptional[optionalNamespace]?.events?.includes(event),\n    );\n\n    const accountsToAdd = chainsToAdd\n      ?.map((chain: string) =>\n        supportedNamespaces[optionalNamespace].accounts.filter((account: string) =>\n          account.includes(`${chain}:`),\n        ),\n      )\n      .flat();\n\n    approvedNamespaces[optionalNamespace] = {\n      chains: mergeArrays(approvedNamespaces[optionalNamespace]?.chains, chainsToAdd),\n      methods: mergeArrays(approvedNamespaces[optionalNamespace]?.methods, methodsToAdd),\n      events: mergeArrays(approvedNamespaces[optionalNamespace]?.events, eventsToAdd),\n      accounts: mergeArrays(approvedNamespaces[optionalNamespace]?.accounts, accountsToAdd),\n    };\n  });\n\n  // remove namespaces with no chains or accounts\n  for (const [namespace, values] of Object.entries(approvedNamespaces)) {\n    if (values.accounts.length === 0 || values?.chains?.length === 0) {\n      delete approvedNamespaces[namespace];\n    }\n  }\n\n  return approvedNamespaces;\n}\n\nexport function isCaipNamespace(namespace: string): boolean {\n  return namespace.includes(\":\");\n}\n\nexport function parseNamespaceKey(namespace: string) {\n  return isCaipNamespace(namespace) ? namespace.split(\":\")[0] : namespace;\n}\n\n/**\n * Converts\n * ```\n * {\n *  \"eip155:1\": {...},\n *  \"eip155:2\": {...},\n * }\n * ```\n * into\n * ```\n * {\n *  \"eip155\": {\n *      chains: [\"eip155:1\", \"eip155:2\"],\n *      ...\n *    }\n * }\n *```\n */\nexport function normalizeNamespaces(\n  namespaces: ProposalTypes.RequiredNamespaces,\n): ProposalTypes.RequiredNamespaces {\n  const normalizedNamespaces = {} as ProposalTypes.RequiredNamespaces;\n  if (!isValidObject(namespaces)) return normalizedNamespaces;\n  for (const [key, values] of Object.entries(namespaces)) {\n    const chains = isCaipNamespace(key) ? [key] : values.chains;\n    const methods = values.methods || [];\n    const events = values.events || [];\n    const normalizedKey = parseNamespaceKey(key);\n    normalizedNamespaces[normalizedKey] = {\n      ...normalizedNamespaces[normalizedKey],\n      chains: mergeArrays(chains, normalizedNamespaces[normalizedKey]?.chains),\n      methods: mergeArrays(methods, normalizedNamespaces[normalizedKey]?.methods),\n      events: mergeArrays(events, normalizedNamespaces[normalizedKey]?.events),\n    };\n  }\n  return normalizedNamespaces;\n}\n\nexport function getNamespacesFromAccounts(accounts: string[]) {\n  const namespaces: SessionTypes.Namespaces = {};\n  accounts?.forEach((account) => {\n    const [namespace, chainId] = account.split(\":\");\n    if (!namespaces[namespace]) {\n      namespaces[namespace] = {\n        accounts: [],\n        chains: [],\n        events: [],\n        methods: [],\n      };\n    }\n    namespaces[namespace].accounts.push(account);\n    namespaces[namespace].chains?.push(`${namespace}:${chainId}`);\n  });\n\n  return namespaces;\n}\n\nexport function buildNamespacesFromAuth(methods: string[], accounts: string[]) {\n  accounts = accounts.map((account) => account.replace(\"did:pkh:\", \"\"));\n\n  const namespaces = getNamespacesFromAccounts(accounts);\n\n  for (const [_, values] of Object.entries(namespaces) as [string, SessionTypes.Namespace][]) {\n    if (!values.methods) {\n      values.methods = methods;\n    } else {\n      values.methods = mergeArrays(values.methods, methods);\n    }\n    values.events = [\"chainChanged\", \"accountsChanged\"];\n  }\n  return namespaces;\n}\n\nexport function mergeRequiredAndOptionalNamespaces(\n  requiredNamespaces: ProposalTypes.RequiredNamespaces,\n  optionalNamespaces: ProposalTypes.OptionalNamespaces,\n) {\n  const normalizedRequired = normalizeNamespaces(requiredNamespaces);\n  const normalizedOptional = normalizeNamespaces(optionalNamespaces);\n\n  const mergedNamespaces: ProposalTypes.OptionalNamespaces = {};\n\n  const combinedNamespaces = Object.keys(normalizedRequired).concat(\n    Object.keys(normalizedOptional),\n  );\n\n  for (const namespace of combinedNamespaces) {\n    mergedNamespaces[namespace] = {\n      chains: mergeArrays(\n        normalizedRequired[namespace]?.chains,\n        normalizedOptional[namespace]?.chains,\n      ),\n      methods: mergeArrays(\n        normalizedRequired[namespace]?.methods,\n        normalizedOptional[namespace]?.methods,\n      ),\n      events: mergeArrays(\n        normalizedRequired[namespace]?.events,\n        normalizedOptional[namespace]?.events,\n      ),\n    };\n  }\n\n  return mergedNamespaces;\n}\n","/**\n * Types\n */\nexport type SdkErrorKey = keyof typeof SDK_ERRORS;\nexport type InternalErrorKey = keyof typeof INTERNAL_ERRORS;\n\n/**\n * Constants\n */\nexport const SDK_ERRORS = {\n  /* ----- INVALID (1xxx) ----- */\n  INVALID_METHOD: {\n    message: \"Invalid method.\",\n    code: 1001,\n  },\n  INVALID_EVENT: {\n    message: \"Invalid event.\",\n    code: 1002,\n  },\n  INVALID_UPDATE_REQUEST: {\n    message: \"Invalid update request.\",\n    code: 1003,\n  },\n  INVALID_EXTEND_REQUEST: {\n    message: \"Invalid extend request.\",\n    code: 1004,\n  },\n  INVALID_SESSION_SETTLE_REQUEST: {\n    message: \"Invalid session settle request.\",\n    code: 1005,\n  },\n  /* ----- UNAUTHORIZED (3xxx) ----- */\n  UNAUTHORIZED_METHOD: {\n    message: \"Unauthorized method.\",\n    code: 3001,\n  },\n  UNAUTHORIZED_EVENT: {\n    message: \"Unauthorized event.\",\n    code: 3002,\n  },\n  UNAUTHORIZED_UPDATE_REQUEST: {\n    message: \"Unauthorized update request.\",\n    code: 3003,\n  },\n  UNAUTHORIZED_EXTEND_REQUEST: {\n    message: \"Unauthorized extend request.\",\n    code: 3004,\n  },\n  /* ----- REJECTED (5xxx) ----- */\n  USER_REJECTED: {\n    message: \"User rejected.\",\n    code: 5000,\n  },\n  USER_REJECTED_CHAINS: {\n    message: \"User rejected chains.\",\n    code: 5001,\n  },\n  USER_REJECTED_METHODS: {\n    message: \"User rejected methods.\",\n    code: 5002,\n  },\n  USER_REJECTED_EVENTS: {\n    message: \"User rejected events.\",\n    code: 5003,\n  },\n  UNSUPPORTED_CHAINS: {\n    message: \"Unsupported chains.\",\n    code: 5100,\n  },\n  UNSUPPORTED_METHODS: {\n    message: \"Unsupported methods.\",\n    code: 5101,\n  },\n  UNSUPPORTED_EVENTS: {\n    message: \"Unsupported events.\",\n    code: 5102,\n  },\n  UNSUPPORTED_ACCOUNTS: {\n    message: \"Unsupported accounts.\",\n    code: 5103,\n  },\n  UNSUPPORTED_NAMESPACE_KEY: {\n    message: \"Unsupported namespace key.\",\n    code: 5104,\n  },\n  /* ----- REASON (6xxx) ----- */\n  USER_DISCONNECTED: {\n    message: \"User disconnected.\",\n    code: 6000,\n  },\n  /* ----- FAILURE (7xxx) ----- */\n  SESSION_SETTLEMENT_FAILED: {\n    message: \"Session settlement failed.\",\n    code: 7000,\n  },\n  /* ----- PAIRING (10xxx) ----- */\n  WC_METHOD_UNSUPPORTED: {\n    message: \"Unsupported wc_ method.\",\n    code: 10001,\n  },\n};\n\nexport const INTERNAL_ERRORS = {\n  NOT_INITIALIZED: {\n    message: \"Not initialized.\",\n    code: 1,\n  },\n  NO_MATCHING_KEY: {\n    message: \"No matching key.\",\n    code: 2,\n  },\n  RESTORE_WILL_OVERRIDE: {\n    message: \"Restore will override.\",\n    code: 3,\n  },\n  RESUBSCRIBED: {\n    message: \"Resubscribed.\",\n    code: 4,\n  },\n  MISSING_OR_INVALID: {\n    message: \"Missing or invalid.\",\n    code: 5,\n  },\n  EXPIRED: {\n    message: \"Expired.\",\n    code: 6,\n  },\n  UNKNOWN_TYPE: {\n    message: \"Unknown type.\",\n    code: 7,\n  },\n  MISMATCHED_TOPIC: {\n    message: \"Mismatched topic.\",\n    code: 8,\n  },\n  NON_CONFORMING_NAMESPACES: {\n    message: \"Non conforming namespaces.\",\n    code: 9,\n  },\n};\n\n/**\n * Utilities\n */\nexport function getInternalError(key: InternalErrorKey, context?: string | number) {\n  const { message, code } = INTERNAL_ERRORS[key];\n  return {\n    message: context ? `${message} ${context}` : message,\n    code,\n  };\n}\n\nexport function getSdkError(key: SdkErrorKey, context?: string | number) {\n  const { message, code } = SDK_ERRORS[key];\n  return {\n    message: context ? `${message} ${context}` : message,\n    code,\n  };\n}\n","import { SessionTypes, ProposalTypes, RelayerTypes, EngineTypes } from \"@walletconnect/types\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport {\n  getNamespacesChains,\n  getNamespacesMethodsForChainId,\n  getNamespacesEventsForChainId,\n  getAccountsChains,\n} from \"./namespaces.js\";\nimport { getSdkError, getInternalError } from \"./errors.js\";\nimport { fromBase64, hasOverlap } from \"./misc.js\";\nimport { getChainsFromNamespace } from \"./caip.js\";\n\nexport type ErrorObject = { message: string; code: number } | null;\n\n// -- types validation ----------------------------------------------------- //\n\nexport function isValidArray(arr: any, itemCondition?: (item: any) => boolean) {\n  if (Array.isArray(arr)) {\n    if (typeof itemCondition !== \"undefined\" && arr.length) {\n      return arr.every(itemCondition);\n    } else {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function isValidObject(obj: any) {\n  return Object.getPrototypeOf(obj) === Object.prototype && Object.keys(obj).length;\n}\n\nexport function isUndefined(input: any): input is undefined {\n  return typeof input === \"undefined\";\n}\n\nexport function isValidString(input: any, optional: boolean): input is string {\n  if (optional && isUndefined(input)) return true;\n\n  return typeof input === \"string\" && Boolean(input.trim().length);\n}\n\nexport function isValidNumber(input: any, optional: boolean) {\n  if (optional && isUndefined(input)) return true;\n\n  return typeof input === \"number\" && !isNaN(input);\n}\n\n// -- protocol validation -------------------------------------------------- //\n\nexport function isSessionCompatible(session: SessionTypes.Struct, params: EngineTypes.FindParams) {\n  const { requiredNamespaces } = params;\n  const sessionKeys = Object.keys(session.namespaces);\n  const paramsKeys = Object.keys(requiredNamespaces);\n  let compatible = true;\n\n  if (!hasOverlap(paramsKeys, sessionKeys)) return false;\n\n  sessionKeys.forEach((key) => {\n    const { accounts, methods, events } = session.namespaces[key];\n    const chains = getAccountsChains(accounts);\n    const requiredNamespace = requiredNamespaces[key];\n    if (\n      !hasOverlap(getChainsFromNamespace(key, requiredNamespace), chains) ||\n      !hasOverlap(requiredNamespace.methods, methods) ||\n      !hasOverlap(requiredNamespace.events, events)\n    ) {\n      compatible = false;\n    }\n  });\n\n  return compatible;\n}\n\nexport function isValidChainId(value: any) {\n  if (isValidString(value, false) && value.includes(\":\")) {\n    const split = value.split(\":\");\n    return split.length === 2;\n  }\n  return false;\n}\n\nexport function isValidAccountId(value: any) {\n  if (isValidString(value, false) && value.includes(\":\")) {\n    const split = value.split(\":\");\n    if (split.length === 3) {\n      const chainId = split[0] + \":\" + split[1];\n      return !!split[2] && isValidChainId(chainId);\n    }\n  }\n  return false;\n}\n\nexport function isValidUrl(value: any) {\n  function validateUrl(blob: string) {\n    try {\n      const url = new URL(blob);\n      return typeof url !== \"undefined\";\n    } catch (e) {\n      return false;\n    }\n  }\n  try {\n    if (isValidString(value, false)) {\n      const isValid = validateUrl(value);\n      if (isValid) return true;\n\n      const decoded = fromBase64(value);\n      return validateUrl(decoded);\n    }\n  } catch (e) {}\n  return false;\n}\n\nexport function isProposalStruct(input: any): input is ProposalTypes.Struct {\n  return input?.proposer?.publicKey;\n}\n\nexport function isSessionStruct(input: any): input is SessionTypes.Struct {\n  return input?.topic;\n}\n\nexport function isValidController(input: any, method: string) {\n  let error: ErrorObject = null;\n  if (!isValidString(input?.publicKey, false)) {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method} controller public key should be a string`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceMethodsOrEvents(input: any): input is string {\n  let valid = true;\n  if (isValidArray(input)) {\n    if (input.length) {\n      valid = input.every((item: any) => isValidString(item, false));\n    }\n  } else {\n    valid = false;\n  }\n\n  return valid;\n}\n\nexport function isValidChains(key: string, chains: any, context: string) {\n  let error: ErrorObject = null;\n\n  if (isValidArray(chains) && chains.length) {\n    chains.forEach((chain: any) => {\n      if (error) return;\n      if (!isValidChainId(chain)) {\n        error = getSdkError(\n          \"UNSUPPORTED_CHAINS\",\n          `${context}, chain ${chain} should be a string and conform to \"namespace:chainId\" format`,\n        );\n      }\n    });\n  } else if (!isValidChainId(key)) {\n    error = getSdkError(\n      \"UNSUPPORTED_CHAINS\",\n      `${context}, chains must be defined as \"namespace:chainId\" e.g. \"eip155:1\": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: [\"eip155:1\", \"eip155:5\"] }`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceChains(namespaces: any, method: string, type: string) {\n  let error: ErrorObject = null;\n  Object.entries(namespaces).forEach(([key, namespace]: [string, any]) => {\n    if (error) return;\n    const validChainsError = isValidChains(\n      key,\n      getChainsFromNamespace(key, namespace),\n      `${method} ${type}`,\n    );\n    if (validChainsError) {\n      error = validChainsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidAccounts(accounts: any, context: string) {\n  let error: ErrorObject = null;\n  if (isValidArray(accounts)) {\n    accounts.forEach((account: any) => {\n      if (error) return;\n      if (!isValidAccountId(account)) {\n        error = getSdkError(\n          \"UNSUPPORTED_ACCOUNTS\",\n          `${context}, account ${account} should be a string and conform to \"namespace:chainId:address\" format`,\n        );\n      }\n    });\n  } else {\n    error = getSdkError(\n      \"UNSUPPORTED_ACCOUNTS\",\n      `${context}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceAccounts(input: any, method: string) {\n  let error: ErrorObject = null;\n  Object.values(input).forEach((namespace: any) => {\n    if (error) return;\n    const validAccountsError = isValidAccounts(namespace?.accounts, `${method} namespace`);\n    if (validAccountsError) {\n      error = validAccountsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidActions(namespace: any, context: string) {\n  let error: ErrorObject = null;\n  if (!isValidNamespaceMethodsOrEvents(namespace?.methods)) {\n    error = getSdkError(\n      \"UNSUPPORTED_METHODS\",\n      `${context}, methods should be an array of strings or empty array for no methods`,\n    );\n  } else if (!isValidNamespaceMethodsOrEvents(namespace?.events)) {\n    error = getSdkError(\n      \"UNSUPPORTED_EVENTS\",\n      `${context}, events should be an array of strings or empty array for no events`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceActions(input: any, method: string) {\n  let error: ErrorObject = null;\n  Object.values(input).forEach((namespace: any) => {\n    if (error) return;\n    const validActionsError = isValidActions(namespace, `${method}, namespace`);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidRequiredNamespaces(input: any, method: string, type: string) {\n  let error: ErrorObject = null;\n  if (input && isValidObject(input)) {\n    const validActionsError = isValidNamespaceActions(input, method);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n    const validChainsError = isValidNamespaceChains(input, method, type);\n    if (validChainsError) {\n      error = validChainsError;\n    }\n  } else {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method}, ${type} should be an object with data`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaces(input: any, method: string) {\n  let error: ErrorObject = null;\n  if (input && isValidObject(input)) {\n    const validActionsError = isValidNamespaceActions(input, method);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n    const validAccountsError = isValidNamespaceAccounts(input, method);\n    if (validAccountsError) {\n      error = validAccountsError;\n    }\n  } else {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method}, namespaces should be an object with data`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidRelay(input: any): input is RelayerTypes.ProtocolOptions {\n  return isValidString(input.protocol, true);\n}\n\nexport function isValidRelays(\n  input: any,\n  optional: boolean,\n): input is RelayerTypes.ProtocolOptions[] {\n  let valid = false;\n\n  if (optional && !input) valid = true;\n  else if (input && isValidArray(input) && input.length) {\n    input.forEach((relay: RelayerTypes.ProtocolOptions) => {\n      valid = isValidRelay(relay);\n    });\n  }\n\n  return valid;\n}\n\nexport function isValidId(input: any) {\n  return typeof input === \"number\";\n}\n\nexport function isValidParams(input: any) {\n  // eslint-disable-next-line valid-typeof\n  return typeof input !== \"undefined\" && typeof input !== null;\n}\n\nexport function isValidErrorReason(input: any): input is ErrorResponse {\n  if (!input) return false;\n  if (typeof input !== \"object\") return false;\n  if (!input.code || !isValidNumber(input.code, false)) return false;\n  if (!input.message || !isValidString(input.message, false)) return false;\n\n  return true;\n}\n\nexport function isValidRequest(request: any) {\n  if (isUndefined(request)) return false;\n  if (!isValidString(request.method, false)) return false;\n  return true;\n}\n\nexport function isValidResponse(response: any) {\n  if (isUndefined(response)) return false;\n  if (isUndefined(response.result) && isUndefined(response.error)) return false;\n  if (!isValidNumber(response.id, false)) return false;\n  if (!isValidString(response.jsonrpc, false)) return false;\n  return true;\n}\n\nexport function isValidEvent(event: any) {\n  if (isUndefined(event)) return false;\n  if (!isValidString(event.name, false)) return false;\n  return true;\n}\n\nexport function isValidNamespacesChainId(namespaces: SessionTypes.Namespaces, chainId: string) {\n  if (!isValidChainId(chainId)) return false;\n  const chains = getNamespacesChains(namespaces);\n  if (!chains.includes(chainId)) return false;\n\n  return true;\n}\n\nexport function isValidNamespacesRequest(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n  method: string,\n) {\n  if (!isValidString(method, false)) return false;\n  const methods = getNamespacesMethodsForChainId(namespaces, chainId);\n  return methods.includes(method);\n}\n\nexport function isValidNamespacesEvent(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n  eventName: string,\n) {\n  if (!isValidString(eventName, false)) return false;\n  const events = getNamespacesEventsForChainId(namespaces, chainId);\n  return events.includes(eventName);\n}\n\nexport function isConformingNamespaces(\n  requiredNamespaces: ProposalTypes.RequiredNamespaces,\n  namespaces: SessionTypes.Namespaces,\n  context: string,\n) {\n  let error: ErrorObject = null;\n\n  const parsedRequired = parseNamespaces(requiredNamespaces);\n  const parsedApproved = parseApprovedNamespaces(namespaces);\n  const requiredChains = Object.keys(parsedRequired);\n  const approvedChains = Object.keys(parsedApproved);\n\n  const uniqueRequired = filterDuplicateNamespaces(Object.keys(requiredNamespaces));\n  const uniqueApproved = filterDuplicateNamespaces(Object.keys(namespaces));\n  const missingRequiredNamespaces = uniqueRequired.filter(\n    (namespace) => !uniqueApproved.includes(namespace),\n  );\n\n  if (missingRequiredNamespaces.length) {\n    error = getInternalError(\n      \"NON_CONFORMING_NAMESPACES\",\n      `${context} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${missingRequiredNamespaces.toString()}\n      Received: ${Object.keys(namespaces).toString()}`,\n    );\n  }\n\n  if (!hasOverlap(requiredChains, approvedChains)) {\n    error = getInternalError(\n      \"NON_CONFORMING_NAMESPACES\",\n      `${context} namespaces chains don't satisfy required namespaces.\n      Required: ${requiredChains.toString()}\n      Approved: ${approvedChains.toString()}`,\n    );\n  }\n\n  // validate inline defined chains with approved accounts\n  Object.keys(namespaces).forEach((chain) => {\n    if (!chain.includes(\":\")) return;\n    if (error) return;\n    const chains = getAccountsChains(namespaces[chain].accounts);\n    if (!chains.includes(chain)) {\n      error = getInternalError(\n        \"NON_CONFORMING_NAMESPACES\",\n        `${context} namespaces accounts don't satisfy namespace accounts for ${chain}\n        Required: ${chain}\n        Approved: ${chains.toString()}`,\n      );\n    }\n  });\n\n  requiredChains.forEach((chain) => {\n    if (error) return;\n\n    if (!hasOverlap(parsedRequired[chain].methods, parsedApproved[chain].methods)) {\n      error = getInternalError(\n        \"NON_CONFORMING_NAMESPACES\",\n        `${context} namespaces methods don't satisfy namespace methods for ${chain}`,\n      );\n    } else if (!hasOverlap(parsedRequired[chain].events, parsedApproved[chain].events)) {\n      error = getInternalError(\n        \"NON_CONFORMING_NAMESPACES\",\n        `${context} namespaces events don't satisfy namespace events for ${chain}`,\n      );\n    }\n  });\n\n  return error;\n}\n\nfunction parseNamespaces(namespaces: ProposalTypes.RequiredNamespaces) {\n  const parsed: ProposalTypes.RequiredNamespaces = {};\n  Object.keys(namespaces).forEach((key) => {\n    // e.g. `eip155:1`\n    const isInlineChainDefinition = key.includes(\":\");\n\n    if (isInlineChainDefinition) {\n      parsed[key] = namespaces[key];\n    } else {\n      namespaces[key].chains?.forEach((chain) => {\n        parsed[chain] = {\n          methods: namespaces[key].methods,\n          events: namespaces[key].events,\n        };\n      });\n    }\n  });\n  return parsed;\n}\n\nfunction filterDuplicateNamespaces(namespaces: string[]) {\n  return [\n    ...new Set(\n      namespaces.map((namespace) =>\n        namespace.includes(\":\") ? namespace.split(\":\")[0] : namespace,\n      ),\n    ),\n  ];\n}\n\nfunction parseApprovedNamespaces(namespaces: SessionTypes.Namespaces) {\n  const parsed: SessionTypes.Namespaces = {};\n  Object.keys(namespaces).forEach((key) => {\n    const isInlineChainDefinition = key.includes(\":\");\n    if (isInlineChainDefinition) {\n      parsed[key] = namespaces[key];\n    } else {\n      const chains = getAccountsChains(namespaces[key].accounts);\n      chains?.forEach((chain) => {\n        parsed[chain] = {\n          accounts: namespaces[key].accounts.filter((account: string) =>\n            account.includes(`${chain}:`),\n          ),\n          methods: namespaces[key].methods,\n          events: namespaces[key].events,\n        };\n      });\n    }\n  });\n  return parsed;\n}\n\nexport function isValidRequestExpiry(expiry: number, boundaries: { min: number; max: number }) {\n  return isValidNumber(expiry, false) && expiry <= boundaries.max && expiry >= boundaries.min;\n}\n","import { getDocument } from \"@walletconnect/window-getters\";\nimport { getEnvironment, ENV_MAP, isBrowser, isReactNative } from \"./misc.js\";\n\nexport function isOnline(): Promise<boolean> {\n  const env = getEnvironment();\n  return new Promise((resolve) => {\n    switch (env) {\n      case ENV_MAP.browser:\n        resolve(getBrowserOnlineStatus());\n        break;\n      case ENV_MAP.reactNative:\n        resolve(getReactNativeOnlineStatus());\n        break;\n      case ENV_MAP.node:\n        resolve(getNodeOnlineStatus());\n        break;\n      default:\n        resolve(true);\n    }\n  });\n}\n\nexport function getBrowserOnlineStatus() {\n  return isBrowser() && navigator?.onLine;\n}\n\nexport async function getReactNativeOnlineStatus(): Promise<boolean> {\n  // global.NetInfo is set in react-native-compat\n  if (isReactNative() && typeof global !== \"undefined\" && (global as any)?.NetInfo) {\n    const state = await (global as any)?.NetInfo.fetch();\n    return state?.isConnected;\n  }\n  // fallback to true if global.NetInfo is undefined, meaning an older version of react-native-compat is used\n  return true;\n}\n\nexport function getNodeOnlineStatus() {\n  /**\n   * TODO: need to implement\n   */\n  return true;\n}\n\nexport function subscribeToNetworkChange(callbackHandler: (connected: boolean) => void) {\n  const env = getEnvironment();\n  switch (env) {\n    case ENV_MAP.browser:\n      subscribeToBrowserNetworkChange(callbackHandler);\n      break;\n    case ENV_MAP.reactNative:\n      subscribeToReactNativeNetworkChange(callbackHandler);\n      break;\n    case ENV_MAP.node:\n      // wip: need to implement\n      break;\n    default:\n      break;\n  }\n}\n\nexport function subscribeToBrowserNetworkChange(callbackHandler: (connected: boolean) => void) {\n  if (!isReactNative() && isBrowser()) {\n    window.addEventListener(\"online\", () => callbackHandler(true));\n    window.addEventListener(\"offline\", () => callbackHandler(false));\n  }\n}\n\n// global.NetInfo is set in react-native-compat\nexport function subscribeToReactNativeNetworkChange(callbackHandler: (connected: boolean) => void) {\n  if (isReactNative() && typeof global !== \"undefined\" && (global as any)?.NetInfo) {\n    (global as any)?.NetInfo.addEventListener((state: any) => callbackHandler(state?.isConnected));\n  }\n}\n\nexport function isAppVisible(): boolean {\n  if (isBrowser() && getDocument()) {\n    return getDocument()?.visibilityState === \"visible\";\n  }\n  // TODO: implement reliable visibility check for react-native\n  // node.js does not have a visibilityState\n  return true;\n}\n","const memoryStore: Record<string, any> = {};\n\nexport abstract class MemoryStore {\n  static get<T = unknown>(key: string) {\n    return memoryStore[key] as T | undefined;\n  }\n\n  static set(key: string, value: unknown) {\n    memoryStore[key] = value;\n  }\n\n  static delete(key: string) {\n    delete memoryStore[key];\n  }\n}\n","import { generatePlatformLogger, Logger } from \"@walletconnect/logger\";\n\nexport function createLogger({ logger, name }: { logger: Logger | string; name: string }) {\n  const loggerInstance =\n    typeof logger === \"string\"\n      ? generatePlatformLogger({\n          opts: {\n            level: logger,\n            name,\n          },\n        }).logger\n      : logger;\n  loggerInstance.level = typeof logger === \"string\" ? logger : logger.level;\n  return loggerInstance as Logger;\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR = 22;\n\nexport function getInitializeImmutableOwnerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR);\n}\n\nexport type InitializeImmutableOwnerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeImmutableOwnerInstructionData = { discriminator: number };\n\nexport type InitializeImmutableOwnerInstructionDataArgs = {};\n\nexport function getInitializeImmutableOwnerInstructionDataEncoder(): FixedSizeEncoder<InitializeImmutableOwnerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeImmutableOwnerInstructionDataDecoder(): FixedSizeDecoder<InitializeImmutableOwnerInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getInitializeImmutableOwnerInstructionDataCodec(): FixedSizeCodec<\n  InitializeImmutableOwnerInstructionDataArgs,\n  InitializeImmutableOwnerInstructionData\n> {\n  return combineCodec(\n    getInitializeImmutableOwnerInstructionDataEncoder(),\n    getInitializeImmutableOwnerInstructionDataDecoder()\n  );\n}\n\nexport type InitializeImmutableOwnerInput<\n  TAccountAccount extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n};\n\nexport function getInitializeImmutableOwnerInstruction<\n  TAccountAccount extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeImmutableOwnerInput<TAccountAccount>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeImmutableOwnerInstruction<TProgramAddress, TAccountAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.account)],\n    data: getInitializeImmutableOwnerInstructionDataEncoder().encode({}),\n    programAddress,\n  } as InitializeImmutableOwnerInstruction<TProgramAddress, TAccountAccount>);\n}\n\nexport type ParsedInitializeImmutableOwnerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n  };\n  data: InitializeImmutableOwnerInstructionData;\n};\n\nexport function parseInitializeImmutableOwnerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeImmutableOwnerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { account: getNextAccount() },\n    data: getInitializeImmutableOwnerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getI16Decoder,\n  getI16Encoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR = 33;\n\nexport function getInitializeInterestBearingMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR = 0;\n\nexport function getInitializeInterestBearingMintInterestBearingMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR\n  );\n}\n\nexport type InitializeInterestBearingMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeInterestBearingMintInstructionData = {\n  discriminator: number;\n  interestBearingMintDiscriminator: number;\n  /** The public key for the account that can update the rate */\n  rateAuthority: Option<Address>;\n  /** The initial interest rate */\n  rate: number;\n};\n\nexport type InitializeInterestBearingMintInstructionDataArgs = {\n  /** The public key for the account that can update the rate */\n  rateAuthority: OptionOrNullable<Address>;\n  /** The initial interest rate */\n  rate: number;\n};\n\nexport function getInitializeInterestBearingMintInstructionDataEncoder(): FixedSizeEncoder<InitializeInterestBearingMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['interestBearingMintDiscriminator', getU8Encoder()],\n      [\n        'rateAuthority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      ['rate', getI16Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR,\n      interestBearingMintDiscriminator:\n        INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeInterestBearingMintInstructionDataDecoder(): FixedSizeDecoder<InitializeInterestBearingMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['interestBearingMintDiscriminator', getU8Decoder()],\n    [\n      'rateAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['rate', getI16Decoder()],\n  ]);\n}\n\nexport function getInitializeInterestBearingMintInstructionDataCodec(): FixedSizeCodec<\n  InitializeInterestBearingMintInstructionDataArgs,\n  InitializeInterestBearingMintInstructionData\n> {\n  return combineCodec(\n    getInitializeInterestBearingMintInstructionDataEncoder(),\n    getInitializeInterestBearingMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeInterestBearingMintInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  rateAuthority: InitializeInterestBearingMintInstructionDataArgs['rateAuthority'];\n  rate: InitializeInterestBearingMintInstructionDataArgs['rate'];\n};\n\nexport function getInitializeInterestBearingMintInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeInterestBearingMintInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeInterestBearingMintInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeInterestBearingMintInstructionDataEncoder().encode(\n      args as InitializeInterestBearingMintInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeInterestBearingMintInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeInterestBearingMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeInterestBearingMintInstructionData;\n};\n\nexport function parseInitializeInterestBearingMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeInterestBearingMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeInterestBearingMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_METADATA_POINTER_DISCRIMINATOR = 39;\n\nexport function getInitializeMetadataPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_METADATA_POINTER_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR = 0;\n\nexport function getInitializeMetadataPointerMetadataPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type InitializeMetadataPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMetadataPointerInstructionData = {\n  discriminator: number;\n  metadataPointerDiscriminator: number;\n  /** The public key for the account that can update the metadata address. */\n  authority: Option<Address>;\n  /** The account address that holds the metadata. */\n  metadataAddress: Option<Address>;\n};\n\nexport type InitializeMetadataPointerInstructionDataArgs = {\n  /** The public key for the account that can update the metadata address. */\n  authority: OptionOrNullable<Address>;\n  /** The account address that holds the metadata. */\n  metadataAddress: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMetadataPointerInstructionDataEncoder(): FixedSizeEncoder<InitializeMetadataPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['metadataPointerDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      [\n        'metadataAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_METADATA_POINTER_DISCRIMINATOR,\n      metadataPointerDiscriminator:\n        INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeMetadataPointerInstructionDataDecoder(): FixedSizeDecoder<InitializeMetadataPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['metadataPointerDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'metadataAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeMetadataPointerInstructionDataCodec(): FixedSizeCodec<\n  InitializeMetadataPointerInstructionDataArgs,\n  InitializeMetadataPointerInstructionData\n> {\n  return combineCodec(\n    getInitializeMetadataPointerInstructionDataEncoder(),\n    getInitializeMetadataPointerInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMetadataPointerInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  authority: InitializeMetadataPointerInstructionDataArgs['authority'];\n  metadataAddress: InitializeMetadataPointerInstructionDataArgs['metadataAddress'];\n};\n\nexport function getInitializeMetadataPointerInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMetadataPointerInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMetadataPointerInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeMetadataPointerInstructionDataEncoder().encode(\n      args as InitializeMetadataPointerInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeMetadataPointerInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeMetadataPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeMetadataPointerInstructionData;\n};\n\nexport function parseInitializeMetadataPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeMetadataPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeMetadataPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  none,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MINT_DISCRIMINATOR = 0;\n\nexport function getInitializeMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MINT_DISCRIMINATOR);\n}\n\nexport type InitializeMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMintInstructionData = {\n  discriminator: number;\n  /** Number of decimals in token account amounts. */\n  decimals: number;\n  /** Minting authority. */\n  mintAuthority: Address;\n  /** Optional authority that can freeze token accounts. */\n  freezeAuthority: Option<Address>;\n};\n\nexport type InitializeMintInstructionDataArgs = {\n  /** Number of decimals in token account amounts. */\n  decimals: number;\n  /** Minting authority. */\n  mintAuthority: Address;\n  /** Optional authority that can freeze token accounts. */\n  freezeAuthority?: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMintInstructionDataEncoder(): Encoder<InitializeMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['decimals', getU8Encoder()],\n      ['mintAuthority', getAddressEncoder()],\n      ['freezeAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_MINT_DISCRIMINATOR,\n      freezeAuthority: value.freezeAuthority ?? none(),\n    })\n  );\n}\n\nexport function getInitializeMintInstructionDataDecoder(): Decoder<InitializeMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['decimals', getU8Decoder()],\n    ['mintAuthority', getAddressDecoder()],\n    ['freezeAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getInitializeMintInstructionDataCodec(): Codec<\n  InitializeMintInstructionDataArgs,\n  InitializeMintInstructionData\n> {\n  return combineCodec(\n    getInitializeMintInstructionDataEncoder(),\n    getInitializeMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMintInput<\n  TAccountMint extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** Token mint account. */\n  mint: Address<TAccountMint>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n  decimals: InitializeMintInstructionDataArgs['decimals'];\n  mintAuthority: InitializeMintInstructionDataArgs['mintAuthority'];\n  freezeAuthority?: InitializeMintInstructionDataArgs['freezeAuthority'];\n};\n\nexport function getInitializeMintInstruction<\n  TAccountMint extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMintInput<TAccountMint, TAccountRent>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMintInstruction<TProgramAddress, TAccountMint, TAccountRent> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint), getAccountMeta(accounts.rent)],\n    data: getInitializeMintInstructionDataEncoder().encode(\n      args as InitializeMintInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeMintInstruction<TProgramAddress, TAccountMint, TAccountRent>);\n}\n\nexport type ParsedInitializeMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Token mint account. */\n    mint: TAccountMetas[0];\n    /** Rent sysvar. */\n    rent: TAccountMetas[1];\n  };\n  data: InitializeMintInstructionData;\n};\n\nexport function parseInitializeMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), rent: getNextAccount() },\n    data: getInitializeMintInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  none,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MINT2_DISCRIMINATOR = 20;\n\nexport function getInitializeMint2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MINT2_DISCRIMINATOR);\n}\n\nexport type InitializeMint2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMint2InstructionData = {\n  discriminator: number;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The authority/multisignature to mint tokens. */\n  mintAuthority: Address;\n  /** The optional freeze authority/multisignature of the mint. */\n  freezeAuthority: Option<Address>;\n};\n\nexport type InitializeMint2InstructionDataArgs = {\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The authority/multisignature to mint tokens. */\n  mintAuthority: Address;\n  /** The optional freeze authority/multisignature of the mint. */\n  freezeAuthority?: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMint2InstructionDataEncoder(): Encoder<InitializeMint2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['decimals', getU8Encoder()],\n      ['mintAuthority', getAddressEncoder()],\n      ['freezeAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_MINT2_DISCRIMINATOR,\n      freezeAuthority: value.freezeAuthority ?? none(),\n    })\n  );\n}\n\nexport function getInitializeMint2InstructionDataDecoder(): Decoder<InitializeMint2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['decimals', getU8Decoder()],\n    ['mintAuthority', getAddressDecoder()],\n    ['freezeAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getInitializeMint2InstructionDataCodec(): Codec<\n  InitializeMint2InstructionDataArgs,\n  InitializeMint2InstructionData\n> {\n  return combineCodec(\n    getInitializeMint2InstructionDataEncoder(),\n    getInitializeMint2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeMint2Input<TAccountMint extends string = string> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  decimals: InitializeMint2InstructionDataArgs['decimals'];\n  mintAuthority: InitializeMint2InstructionDataArgs['mintAuthority'];\n  freezeAuthority?: InitializeMint2InstructionDataArgs['freezeAuthority'];\n};\n\nexport function getInitializeMint2Instruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMint2Input<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMint2Instruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeMint2InstructionDataEncoder().encode(\n      args as InitializeMint2InstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeMint2Instruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeMint2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeMint2InstructionData;\n};\n\nexport function parseInitializeMint2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeMint2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeMint2InstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR = 25;\n\nexport function getInitializeMintCloseAuthorityDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR);\n}\n\nexport type InitializeMintCloseAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMintCloseAuthorityInstructionData = {\n  discriminator: number;\n  /** Authority that must sign the `CloseAccount` instruction on a mint. */\n  closeAuthority: Option<Address>;\n};\n\nexport type InitializeMintCloseAuthorityInstructionDataArgs = {\n  /** Authority that must sign the `CloseAccount` instruction on a mint. */\n  closeAuthority: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMintCloseAuthorityInstructionDataEncoder(): Encoder<InitializeMintCloseAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['closeAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeMintCloseAuthorityInstructionDataDecoder(): Decoder<InitializeMintCloseAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['closeAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getInitializeMintCloseAuthorityInstructionDataCodec(): Codec<\n  InitializeMintCloseAuthorityInstructionDataArgs,\n  InitializeMintCloseAuthorityInstructionData\n> {\n  return combineCodec(\n    getInitializeMintCloseAuthorityInstructionDataEncoder(),\n    getInitializeMintCloseAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMintCloseAuthorityInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  closeAuthority: InitializeMintCloseAuthorityInstructionDataArgs['closeAuthority'];\n};\n\nexport function getInitializeMintCloseAuthorityInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMintCloseAuthorityInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMintCloseAuthorityInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeMintCloseAuthorityInstructionDataEncoder().encode(\n      args as InitializeMintCloseAuthorityInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeMintCloseAuthorityInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeMintCloseAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeMintCloseAuthorityInstructionData;\n};\n\nexport function parseInitializeMintCloseAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeMintCloseAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeMintCloseAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MULTISIG_DISCRIMINATOR = 2;\n\nexport function getInitializeMultisigDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MULTISIG_DISCRIMINATOR);\n}\n\nexport type InitializeMultisigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMultisig extends string | AccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMultisig extends string\n        ? WritableAccount<TAccountMultisig>\n        : TAccountMultisig,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMultisigInstructionData = {\n  discriminator: number;\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport type InitializeMultisigInstructionDataArgs = {\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport function getInitializeMultisigInstructionDataEncoder(): FixedSizeEncoder<InitializeMultisigInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['m', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_MULTISIG_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeMultisigInstructionDataDecoder(): FixedSizeDecoder<InitializeMultisigInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['m', getU8Decoder()],\n  ]);\n}\n\nexport function getInitializeMultisigInstructionDataCodec(): FixedSizeCodec<\n  InitializeMultisigInstructionDataArgs,\n  InitializeMultisigInstructionData\n> {\n  return combineCodec(\n    getInitializeMultisigInstructionDataEncoder(),\n    getInitializeMultisigInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMultisigInput<\n  TAccountMultisig extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** The multisignature account to initialize. */\n  multisig: Address<TAccountMultisig>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n  m: InitializeMultisigInstructionDataArgs['m'];\n  signers: Array<Address>;\n};\n\nexport function getInitializeMultisigInstruction<\n  TAccountMultisig extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMultisigInput<TAccountMultisig, TAccountRent>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMultisigInstruction<\n  TProgramAddress,\n  TAccountMultisig,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    multisig: { value: input.multisig ?? null, isWritable: true },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = args.signers.map((address) => ({\n    address,\n    role: AccountRole.READONLY,\n  }));\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.multisig),\n      getAccountMeta(accounts.rent),\n      ...remainingAccounts,\n    ],\n    data: getInitializeMultisigInstructionDataEncoder().encode(\n      args as InitializeMultisigInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeMultisigInstruction<\n    TProgramAddress,\n    TAccountMultisig,\n    TAccountRent\n  >);\n}\n\nexport type ParsedInitializeMultisigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The multisignature account to initialize. */\n    multisig: TAccountMetas[0];\n    /** Rent sysvar. */\n    rent: TAccountMetas[1];\n  };\n  data: InitializeMultisigInstructionData;\n};\n\nexport function parseInitializeMultisigInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeMultisigInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { multisig: getNextAccount(), rent: getNextAccount() },\n    data: getInitializeMultisigInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MULTISIG2_DISCRIMINATOR = 19;\n\nexport function getInitializeMultisig2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MULTISIG2_DISCRIMINATOR);\n}\n\nexport type InitializeMultisig2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMultisig extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMultisig extends string\n        ? WritableAccount<TAccountMultisig>\n        : TAccountMultisig,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMultisig2InstructionData = {\n  discriminator: number;\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport type InitializeMultisig2InstructionDataArgs = {\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport function getInitializeMultisig2InstructionDataEncoder(): FixedSizeEncoder<InitializeMultisig2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['m', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_MULTISIG2_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeMultisig2InstructionDataDecoder(): FixedSizeDecoder<InitializeMultisig2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['m', getU8Decoder()],\n  ]);\n}\n\nexport function getInitializeMultisig2InstructionDataCodec(): FixedSizeCodec<\n  InitializeMultisig2InstructionDataArgs,\n  InitializeMultisig2InstructionData\n> {\n  return combineCodec(\n    getInitializeMultisig2InstructionDataEncoder(),\n    getInitializeMultisig2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeMultisig2Input<TAccountMultisig extends string = string> =\n  {\n    /** The multisignature account to initialize. */\n    multisig: Address<TAccountMultisig>;\n    m: InitializeMultisig2InstructionDataArgs['m'];\n    signers: Array<Address>;\n  };\n\nexport function getInitializeMultisig2Instruction<\n  TAccountMultisig extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMultisig2Input<TAccountMultisig>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMultisig2Instruction<TProgramAddress, TAccountMultisig> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    multisig: { value: input.multisig ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = args.signers.map((address) => ({\n    address,\n    role: AccountRole.READONLY,\n  }));\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.multisig), ...remainingAccounts],\n    data: getInitializeMultisig2InstructionDataEncoder().encode(\n      args as InitializeMultisig2InstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeMultisig2Instruction<TProgramAddress, TAccountMultisig>);\n}\n\nexport type ParsedInitializeMultisig2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The multisignature account to initialize. */\n    multisig: TAccountMetas[0];\n  };\n  data: InitializeMultisig2InstructionData;\n};\n\nexport function parseInitializeMultisig2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeMultisig2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { multisig: getNextAccount() },\n    data: getInitializeMultisig2InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR = 32;\n\nexport function getInitializeNonTransferableMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR);\n}\n\nexport type InitializeNonTransferableMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeNonTransferableMintInstructionData = {\n  discriminator: number;\n};\n\nexport type InitializeNonTransferableMintInstructionDataArgs = {};\n\nexport function getInitializeNonTransferableMintInstructionDataEncoder(): FixedSizeEncoder<InitializeNonTransferableMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeNonTransferableMintInstructionDataDecoder(): FixedSizeDecoder<InitializeNonTransferableMintInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getInitializeNonTransferableMintInstructionDataCodec(): FixedSizeCodec<\n  InitializeNonTransferableMintInstructionDataArgs,\n  InitializeNonTransferableMintInstructionData\n> {\n  return combineCodec(\n    getInitializeNonTransferableMintInstructionDataEncoder(),\n    getInitializeNonTransferableMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeNonTransferableMintInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint account to initialize. */\n  mint: Address<TAccountMint>;\n};\n\nexport function getInitializeNonTransferableMintInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeNonTransferableMintInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeNonTransferableMintInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeNonTransferableMintInstructionDataEncoder().encode({}),\n    programAddress,\n  } as InitializeNonTransferableMintInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeNonTransferableMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint account to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeNonTransferableMintInstructionData;\n};\n\nexport function parseInitializeNonTransferableMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeNonTransferableMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeNonTransferableMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_PAUSABLE_CONFIG_DISCRIMINATOR = 44;\n\nexport function getInitializePausableConfigDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_PAUSABLE_CONFIG_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_PAUSABLE_CONFIG_PAUSABLE_DISCRIMINATOR = 0;\n\nexport function getInitializePausableConfigPausableDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_PAUSABLE_CONFIG_PAUSABLE_DISCRIMINATOR\n  );\n}\n\nexport type InitializePausableConfigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializePausableConfigInstructionData = {\n  discriminator: number;\n  pausableDiscriminator: number;\n  /** The authority that can pause and resume the mint. */\n  authority: Option<Address>;\n};\n\nexport type InitializePausableConfigInstructionDataArgs = {\n  /** The authority that can pause and resume the mint. */\n  authority: OptionOrNullable<Address>;\n};\n\nexport function getInitializePausableConfigInstructionDataEncoder(): FixedSizeEncoder<InitializePausableConfigInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['pausableDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_PAUSABLE_CONFIG_DISCRIMINATOR,\n      pausableDiscriminator: INITIALIZE_PAUSABLE_CONFIG_PAUSABLE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializePausableConfigInstructionDataDecoder(): FixedSizeDecoder<InitializePausableConfigInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['pausableDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializePausableConfigInstructionDataCodec(): FixedSizeCodec<\n  InitializePausableConfigInstructionDataArgs,\n  InitializePausableConfigInstructionData\n> {\n  return combineCodec(\n    getInitializePausableConfigInstructionDataEncoder(),\n    getInitializePausableConfigInstructionDataDecoder()\n  );\n}\n\nexport type InitializePausableConfigInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  authority: InitializePausableConfigInstructionDataArgs['authority'];\n};\n\nexport function getInitializePausableConfigInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializePausableConfigInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializePausableConfigInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializePausableConfigInstructionDataEncoder().encode(\n      args as InitializePausableConfigInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializePausableConfigInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializePausableConfigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializePausableConfigInstructionData;\n};\n\nexport function parseInitializePausableConfigInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializePausableConfigInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializePausableConfigInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR = 35;\n\nexport function getInitializePermanentDelegateDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR);\n}\n\nexport type InitializePermanentDelegateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializePermanentDelegateInstructionData = {\n  discriminator: number;\n  /** Authority that may sign for `Transfer`s and `Burn`s on any account */\n  delegate: Address;\n};\n\nexport type InitializePermanentDelegateInstructionDataArgs = {\n  /** Authority that may sign for `Transfer`s and `Burn`s on any account */\n  delegate: Address;\n};\n\nexport function getInitializePermanentDelegateInstructionDataEncoder(): FixedSizeEncoder<InitializePermanentDelegateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['delegate', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializePermanentDelegateInstructionDataDecoder(): FixedSizeDecoder<InitializePermanentDelegateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['delegate', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializePermanentDelegateInstructionDataCodec(): FixedSizeCodec<\n  InitializePermanentDelegateInstructionDataArgs,\n  InitializePermanentDelegateInstructionData\n> {\n  return combineCodec(\n    getInitializePermanentDelegateInstructionDataEncoder(),\n    getInitializePermanentDelegateInstructionDataDecoder()\n  );\n}\n\nexport type InitializePermanentDelegateInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  delegate: InitializePermanentDelegateInstructionDataArgs['delegate'];\n};\n\nexport function getInitializePermanentDelegateInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializePermanentDelegateInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializePermanentDelegateInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializePermanentDelegateInstructionDataEncoder().encode(\n      args as InitializePermanentDelegateInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializePermanentDelegateInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializePermanentDelegateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializePermanentDelegateInstructionData;\n};\n\nexport function parseInitializePermanentDelegateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializePermanentDelegateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializePermanentDelegateInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getF64Decoder,\n  getF64Encoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR = 43;\n\nexport function getInitializeScaledUiAmountMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_SCALED_UI_AMOUNT_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR = 0;\n\nexport function getInitializeScaledUiAmountMintScaledUiAmountMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_SCALED_UI_AMOUNT_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR\n  );\n}\n\nexport type InitializeScaledUiAmountMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeScaledUiAmountMintInstructionData = {\n  discriminator: number;\n  scaledUiAmountMintDiscriminator: number;\n  /** The authority that can update the multiplier */\n  authority: Option<Address>;\n  /** The initial multiplier for the scaled UI extension */\n  multiplier: number;\n};\n\nexport type InitializeScaledUiAmountMintInstructionDataArgs = {\n  /** The authority that can update the multiplier */\n  authority: OptionOrNullable<Address>;\n  /** The initial multiplier for the scaled UI extension */\n  multiplier: number;\n};\n\nexport function getInitializeScaledUiAmountMintInstructionDataEncoder(): FixedSizeEncoder<InitializeScaledUiAmountMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['scaledUiAmountMintDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      ['multiplier', getF64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR,\n      scaledUiAmountMintDiscriminator:\n        INITIALIZE_SCALED_UI_AMOUNT_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeScaledUiAmountMintInstructionDataDecoder(): FixedSizeDecoder<InitializeScaledUiAmountMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['scaledUiAmountMintDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['multiplier', getF64Decoder()],\n  ]);\n}\n\nexport function getInitializeScaledUiAmountMintInstructionDataCodec(): FixedSizeCodec<\n  InitializeScaledUiAmountMintInstructionDataArgs,\n  InitializeScaledUiAmountMintInstructionData\n> {\n  return combineCodec(\n    getInitializeScaledUiAmountMintInstructionDataEncoder(),\n    getInitializeScaledUiAmountMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeScaledUiAmountMintInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  authority: InitializeScaledUiAmountMintInstructionDataArgs['authority'];\n  multiplier: InitializeScaledUiAmountMintInstructionDataArgs['multiplier'];\n};\n\nexport function getInitializeScaledUiAmountMintInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeScaledUiAmountMintInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeScaledUiAmountMintInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeScaledUiAmountMintInstructionDataEncoder().encode(\n      args as InitializeScaledUiAmountMintInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeScaledUiAmountMintInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeScaledUiAmountMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeScaledUiAmountMintInstructionData;\n};\n\nexport function parseInitializeScaledUiAmountMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeScaledUiAmountMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeScaledUiAmountMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TOKEN_GROUP_DISCRIMINATOR = new Uint8Array([\n  121, 113, 108, 39, 54, 51, 0, 4,\n]);\n\nexport function getInitializeTokenGroupDiscriminatorBytes() {\n  return getBytesEncoder().encode(INITIALIZE_TOKEN_GROUP_DISCRIMINATOR);\n}\n\nexport type InitializeTokenGroupInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountGroup extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountMintAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountGroup extends string\n        ? WritableAccount<TAccountGroup>\n        : TAccountGroup,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountMintAuthority extends string\n        ? ReadonlySignerAccount<TAccountMintAuthority> &\n            AccountSignerMeta<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTokenGroupInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** Update authority for the group */\n  updateAuthority: Option<Address>;\n  /** The maximum number of group members */\n  maxSize: bigint;\n};\n\nexport type InitializeTokenGroupInstructionDataArgs = {\n  /** Update authority for the group */\n  updateAuthority: OptionOrNullable<Address>;\n  /** The maximum number of group members */\n  maxSize: number | bigint;\n};\n\nexport function getInitializeTokenGroupInstructionDataEncoder(): Encoder<InitializeTokenGroupInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      [\n        'updateAuthority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      ['maxSize', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TOKEN_GROUP_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTokenGroupInstructionDataDecoder(): Decoder<InitializeTokenGroupInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    [\n      'updateAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['maxSize', getU64Decoder()],\n  ]);\n}\n\nexport function getInitializeTokenGroupInstructionDataCodec(): Codec<\n  InitializeTokenGroupInstructionDataArgs,\n  InitializeTokenGroupInstructionData\n> {\n  return combineCodec(\n    getInitializeTokenGroupInstructionDataEncoder(),\n    getInitializeTokenGroupInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTokenGroupInput<\n  TAccountGroup extends string = string,\n  TAccountMint extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  group: Address<TAccountGroup>;\n  mint: Address<TAccountMint>;\n  mintAuthority: TransactionSigner<TAccountMintAuthority>;\n  updateAuthority: InitializeTokenGroupInstructionDataArgs['updateAuthority'];\n  maxSize: InitializeTokenGroupInstructionDataArgs['maxSize'];\n};\n\nexport function getInitializeTokenGroupInstruction<\n  TAccountGroup extends string,\n  TAccountMint extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeTokenGroupInput<\n    TAccountGroup,\n    TAccountMint,\n    TAccountMintAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTokenGroupInstruction<\n  TProgramAddress,\n  TAccountGroup,\n  TAccountMint,\n  TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    group: { value: input.group ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.group),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.mintAuthority),\n    ],\n    data: getInitializeTokenGroupInstructionDataEncoder().encode(\n      args as InitializeTokenGroupInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeTokenGroupInstruction<\n    TProgramAddress,\n    TAccountGroup,\n    TAccountMint,\n    TAccountMintAuthority\n  >);\n}\n\nexport type ParsedInitializeTokenGroupInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    group: TAccountMetas[0];\n    mint: TAccountMetas[1];\n    mintAuthority: TAccountMetas[2];\n  };\n  data: InitializeTokenGroupInstructionData;\n};\n\nexport function parseInitializeTokenGroupInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeTokenGroupInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      group: getNextAccount(),\n      mint: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getInitializeTokenGroupInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR = new Uint8Array([\n  152, 32, 222, 176, 223, 237, 116, 134,\n]);\n\nexport function getInitializeTokenGroupMemberDiscriminatorBytes() {\n  return getBytesEncoder().encode(INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR);\n}\n\nexport type InitializeTokenGroupMemberInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMember extends string | AccountMeta<string> = string,\n  TAccountMemberMint extends string | AccountMeta<string> = string,\n  TAccountMemberMintAuthority extends string | AccountMeta<string> = string,\n  TAccountGroup extends string | AccountMeta<string> = string,\n  TAccountGroupUpdateAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMember extends string\n        ? WritableAccount<TAccountMember>\n        : TAccountMember,\n      TAccountMemberMint extends string\n        ? ReadonlyAccount<TAccountMemberMint>\n        : TAccountMemberMint,\n      TAccountMemberMintAuthority extends string\n        ? ReadonlySignerAccount<TAccountMemberMintAuthority> &\n            AccountSignerMeta<TAccountMemberMintAuthority>\n        : TAccountMemberMintAuthority,\n      TAccountGroup extends string\n        ? WritableAccount<TAccountGroup>\n        : TAccountGroup,\n      TAccountGroupUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountGroupUpdateAuthority> &\n            AccountSignerMeta<TAccountGroupUpdateAuthority>\n        : TAccountGroupUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTokenGroupMemberInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type InitializeTokenGroupMemberInstructionDataArgs = {};\n\nexport function getInitializeTokenGroupMemberInstructionDataEncoder(): Encoder<InitializeTokenGroupMemberInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getBytesEncoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTokenGroupMemberInstructionDataDecoder(): Decoder<InitializeTokenGroupMemberInstructionData> {\n  return getStructDecoder([['discriminator', getBytesDecoder()]]);\n}\n\nexport function getInitializeTokenGroupMemberInstructionDataCodec(): Codec<\n  InitializeTokenGroupMemberInstructionDataArgs,\n  InitializeTokenGroupMemberInstructionData\n> {\n  return combineCodec(\n    getInitializeTokenGroupMemberInstructionDataEncoder(),\n    getInitializeTokenGroupMemberInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTokenGroupMemberInput<\n  TAccountMember extends string = string,\n  TAccountMemberMint extends string = string,\n  TAccountMemberMintAuthority extends string = string,\n  TAccountGroup extends string = string,\n  TAccountGroupUpdateAuthority extends string = string,\n> = {\n  member: Address<TAccountMember>;\n  memberMint: Address<TAccountMemberMint>;\n  memberMintAuthority: TransactionSigner<TAccountMemberMintAuthority>;\n  group: Address<TAccountGroup>;\n  groupUpdateAuthority: TransactionSigner<TAccountGroupUpdateAuthority>;\n};\n\nexport function getInitializeTokenGroupMemberInstruction<\n  TAccountMember extends string,\n  TAccountMemberMint extends string,\n  TAccountMemberMintAuthority extends string,\n  TAccountGroup extends string,\n  TAccountGroupUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeTokenGroupMemberInput<\n    TAccountMember,\n    TAccountMemberMint,\n    TAccountMemberMintAuthority,\n    TAccountGroup,\n    TAccountGroupUpdateAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTokenGroupMemberInstruction<\n  TProgramAddress,\n  TAccountMember,\n  TAccountMemberMint,\n  TAccountMemberMintAuthority,\n  TAccountGroup,\n  TAccountGroupUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    member: { value: input.member ?? null, isWritable: true },\n    memberMint: { value: input.memberMint ?? null, isWritable: false },\n    memberMintAuthority: {\n      value: input.memberMintAuthority ?? null,\n      isWritable: false,\n    },\n    group: { value: input.group ?? null, isWritable: true },\n    groupUpdateAuthority: {\n      value: input.groupUpdateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.member),\n      getAccountMeta(accounts.memberMint),\n      getAccountMeta(accounts.memberMintAuthority),\n      getAccountMeta(accounts.group),\n      getAccountMeta(accounts.groupUpdateAuthority),\n    ],\n    data: getInitializeTokenGroupMemberInstructionDataEncoder().encode({}),\n    programAddress,\n  } as InitializeTokenGroupMemberInstruction<\n    TProgramAddress,\n    TAccountMember,\n    TAccountMemberMint,\n    TAccountMemberMintAuthority,\n    TAccountGroup,\n    TAccountGroupUpdateAuthority\n  >);\n}\n\nexport type ParsedInitializeTokenGroupMemberInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    member: TAccountMetas[0];\n    memberMint: TAccountMetas[1];\n    memberMintAuthority: TAccountMetas[2];\n    group: TAccountMetas[3];\n    groupUpdateAuthority: TAccountMetas[4];\n  };\n  data: InitializeTokenGroupMemberInstructionData;\n};\n\nexport function parseInitializeTokenGroupMemberInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeTokenGroupMemberInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      member: getNextAccount(),\n      memberMint: getNextAccount(),\n      memberMintAuthority: getNextAccount(),\n      group: getNextAccount(),\n      groupUpdateAuthority: getNextAccount(),\n    },\n    data: getInitializeTokenGroupMemberInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TOKEN_METADATA_DISCRIMINATOR = new Uint8Array([\n  210, 225, 30, 162, 88, 184, 77, 141,\n]);\n\nexport function getInitializeTokenMetadataDiscriminatorBytes() {\n  return getBytesEncoder().encode(INITIALIZE_TOKEN_METADATA_DISCRIMINATOR);\n}\n\nexport type InitializeTokenMetadataInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | AccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountMintAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMetadata extends string\n        ? WritableAccount<TAccountMetadata>\n        : TAccountMetadata,\n      TAccountUpdateAuthority extends string\n        ? ReadonlyAccount<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountMintAuthority extends string\n        ? ReadonlySignerAccount<TAccountMintAuthority> &\n            AccountSignerMeta<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTokenMetadataInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** Longer name of the token. */\n  name: string;\n  /** Shortened symbol of the token. */\n  symbol: string;\n  /** URI pointing to more metadata (image, video, etc.). */\n  uri: string;\n};\n\nexport type InitializeTokenMetadataInstructionDataArgs = {\n  /** Longer name of the token. */\n  name: string;\n  /** Shortened symbol of the token. */\n  symbol: string;\n  /** URI pointing to more metadata (image, video, etc.). */\n  uri: string;\n};\n\nexport function getInitializeTokenMetadataInstructionDataEncoder(): Encoder<InitializeTokenMetadataInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n      ['symbol', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n      ['uri', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TOKEN_METADATA_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTokenMetadataInstructionDataDecoder(): Decoder<InitializeTokenMetadataInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['symbol', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['uri', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n  ]);\n}\n\nexport function getInitializeTokenMetadataInstructionDataCodec(): Codec<\n  InitializeTokenMetadataInstructionDataArgs,\n  InitializeTokenMetadataInstructionData\n> {\n  return combineCodec(\n    getInitializeTokenMetadataInstructionDataEncoder(),\n    getInitializeTokenMetadataInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTokenMetadataInput<\n  TAccountMetadata extends string = string,\n  TAccountUpdateAuthority extends string = string,\n  TAccountMint extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  metadata: Address<TAccountMetadata>;\n  updateAuthority: Address<TAccountUpdateAuthority>;\n  mint: Address<TAccountMint>;\n  mintAuthority: TransactionSigner<TAccountMintAuthority>;\n  name: InitializeTokenMetadataInstructionDataArgs['name'];\n  symbol: InitializeTokenMetadataInstructionDataArgs['symbol'];\n  uri: InitializeTokenMetadataInstructionDataArgs['uri'];\n};\n\nexport function getInitializeTokenMetadataInstruction<\n  TAccountMetadata extends string,\n  TAccountUpdateAuthority extends string,\n  TAccountMint extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeTokenMetadataInput<\n    TAccountMetadata,\n    TAccountUpdateAuthority,\n    TAccountMint,\n    TAccountMintAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTokenMetadataInstruction<\n  TProgramAddress,\n  TAccountMetadata,\n  TAccountUpdateAuthority,\n  TAccountMint,\n  TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n    mint: { value: input.mint ?? null, isWritable: false },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.updateAuthority),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.mintAuthority),\n    ],\n    data: getInitializeTokenMetadataInstructionDataEncoder().encode(\n      args as InitializeTokenMetadataInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeTokenMetadataInstruction<\n    TProgramAddress,\n    TAccountMetadata,\n    TAccountUpdateAuthority,\n    TAccountMint,\n    TAccountMintAuthority\n  >);\n}\n\nexport type ParsedInitializeTokenMetadataInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    metadata: TAccountMetas[0];\n    updateAuthority: TAccountMetas[1];\n    mint: TAccountMetas[2];\n    mintAuthority: TAccountMetas[3];\n  };\n  data: InitializeTokenMetadataInstructionData;\n};\n\nexport function parseInitializeTokenMetadataInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeTokenMetadataInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      metadata: getNextAccount(),\n      updateAuthority: getNextAccount(),\n      mint: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getInitializeTokenMetadataInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR = 26;\n\nexport function getInitializeTransferFeeConfigDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR = 0;\n\nexport function getInitializeTransferFeeConfigTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type InitializeTransferFeeConfigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTransferFeeConfigInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n  /** Pubkey that may update the fees. */\n  transferFeeConfigAuthority: Option<Address>;\n  /** Withdraw instructions must be signed by this key. */\n  withdrawWithheldAuthority: Option<Address>;\n  /** Amount of transfer collected as fees, expressed as basis points of the transfer amount. */\n  transferFeeBasisPoints: number;\n  /** Maximum fee assessed on transfers. */\n  maximumFee: bigint;\n};\n\nexport type InitializeTransferFeeConfigInstructionDataArgs = {\n  /** Pubkey that may update the fees. */\n  transferFeeConfigAuthority: OptionOrNullable<Address>;\n  /** Withdraw instructions must be signed by this key. */\n  withdrawWithheldAuthority: OptionOrNullable<Address>;\n  /** Amount of transfer collected as fees, expressed as basis points of the transfer amount. */\n  transferFeeBasisPoints: number;\n  /** Maximum fee assessed on transfers. */\n  maximumFee: number | bigint;\n};\n\nexport function getInitializeTransferFeeConfigInstructionDataEncoder(): Encoder<InitializeTransferFeeConfigInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n      ['transferFeeConfigAuthority', getOptionEncoder(getAddressEncoder())],\n      ['withdrawWithheldAuthority', getOptionEncoder(getAddressEncoder())],\n      ['transferFeeBasisPoints', getU16Encoder()],\n      ['maximumFee', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR,\n      transferFeeDiscriminator:\n        INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTransferFeeConfigInstructionDataDecoder(): Decoder<InitializeTransferFeeConfigInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n    ['transferFeeConfigAuthority', getOptionDecoder(getAddressDecoder())],\n    ['withdrawWithheldAuthority', getOptionDecoder(getAddressDecoder())],\n    ['transferFeeBasisPoints', getU16Decoder()],\n    ['maximumFee', getU64Decoder()],\n  ]);\n}\n\nexport function getInitializeTransferFeeConfigInstructionDataCodec(): Codec<\n  InitializeTransferFeeConfigInstructionDataArgs,\n  InitializeTransferFeeConfigInstructionData\n> {\n  return combineCodec(\n    getInitializeTransferFeeConfigInstructionDataEncoder(),\n    getInitializeTransferFeeConfigInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTransferFeeConfigInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  transferFeeConfigAuthority: InitializeTransferFeeConfigInstructionDataArgs['transferFeeConfigAuthority'];\n  withdrawWithheldAuthority: InitializeTransferFeeConfigInstructionDataArgs['withdrawWithheldAuthority'];\n  transferFeeBasisPoints: InitializeTransferFeeConfigInstructionDataArgs['transferFeeBasisPoints'];\n  maximumFee: InitializeTransferFeeConfigInstructionDataArgs['maximumFee'];\n};\n\nexport function getInitializeTransferFeeConfigInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeTransferFeeConfigInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTransferFeeConfigInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeTransferFeeConfigInstructionDataEncoder().encode(\n      args as InitializeTransferFeeConfigInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeTransferFeeConfigInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeTransferFeeConfigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeTransferFeeConfigInstructionData;\n};\n\nexport function parseInitializeTransferFeeConfigInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeTransferFeeConfigInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeTransferFeeConfigInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR = 36;\n\nexport function getInitializeTransferHookDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR = 0;\n\nexport function getInitializeTransferHookTransferHookDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR\n  );\n}\n\nexport type InitializeTransferHookInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTransferHookInstructionData = {\n  discriminator: number;\n  transferHookDiscriminator: number;\n  /** The public key for the account that can update the program id */\n  authority: Option<Address>;\n  /** The program id that performs logic during transfers */\n  programId: Option<Address>;\n};\n\nexport type InitializeTransferHookInstructionDataArgs = {\n  /** The public key for the account that can update the program id */\n  authority: OptionOrNullable<Address>;\n  /** The program id that performs logic during transfers */\n  programId: OptionOrNullable<Address>;\n};\n\nexport function getInitializeTransferHookInstructionDataEncoder(): FixedSizeEncoder<InitializeTransferHookInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferHookDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      [\n        'programId',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR,\n      transferHookDiscriminator:\n        INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTransferHookInstructionDataDecoder(): FixedSizeDecoder<InitializeTransferHookInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferHookDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'programId',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeTransferHookInstructionDataCodec(): FixedSizeCodec<\n  InitializeTransferHookInstructionDataArgs,\n  InitializeTransferHookInstructionData\n> {\n  return combineCodec(\n    getInitializeTransferHookInstructionDataEncoder(),\n    getInitializeTransferHookInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTransferHookInput<TAccountMint extends string = string> =\n  {\n    /** The mint to initialize. */\n    mint: Address<TAccountMint>;\n    authority: InitializeTransferHookInstructionDataArgs['authority'];\n    programId: InitializeTransferHookInstructionDataArgs['programId'];\n  };\n\nexport function getInitializeTransferHookInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeTransferHookInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTransferHookInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeTransferHookInstructionDataEncoder().encode(\n      args as InitializeTransferHookInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeTransferHookInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeTransferHookInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeTransferHookInstructionData;\n};\n\nexport function parseInitializeTransferHookInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeTransferHookInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeTransferHookInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const MINT_TO_DISCRIMINATOR = 7;\n\nexport function getMintToDiscriminatorBytes() {\n  return getU8Encoder().encode(MINT_TO_DISCRIMINATOR);\n}\n\nexport type MintToInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountMintAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMintAuthority extends string\n        ? ReadonlyAccount<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type MintToInstructionData = {\n  discriminator: number;\n  /** The amount of new tokens to mint. */\n  amount: bigint;\n};\n\nexport type MintToInstructionDataArgs = {\n  /** The amount of new tokens to mint. */\n  amount: number | bigint;\n};\n\nexport function getMintToInstructionDataEncoder(): FixedSizeEncoder<MintToInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: MINT_TO_DISCRIMINATOR })\n  );\n}\n\nexport function getMintToInstructionDataDecoder(): FixedSizeDecoder<MintToInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getMintToInstructionDataCodec(): FixedSizeCodec<\n  MintToInstructionDataArgs,\n  MintToInstructionData\n> {\n  return combineCodec(\n    getMintToInstructionDataEncoder(),\n    getMintToInstructionDataDecoder()\n  );\n}\n\nexport type MintToInput<\n  TAccountMint extends string = string,\n  TAccountToken extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  /** The mint account. */\n  mint: Address<TAccountMint>;\n  /** The account to mint tokens to. */\n  token: Address<TAccountToken>;\n  /** The mint's minting authority or its multisignature account. */\n  mintAuthority:\n    | Address<TAccountMintAuthority>\n    | TransactionSigner<TAccountMintAuthority>;\n  amount: MintToInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getMintToInstruction<\n  TAccountMint extends string,\n  TAccountToken extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: MintToInput<TAccountMint, TAccountToken, TAccountMintAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): MintToInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountToken,\n  (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n    ? ReadonlySignerAccount<TAccountMintAuthority> &\n        AccountSignerMeta<TAccountMintAuthority>\n    : TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    token: { value: input.token ?? null, isWritable: true },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mintAuthority),\n      ...remainingAccounts,\n    ],\n    data: getMintToInstructionDataEncoder().encode(\n      args as MintToInstructionDataArgs\n    ),\n    programAddress,\n  } as MintToInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountToken,\n    (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n      ? ReadonlySignerAccount<TAccountMintAuthority> &\n          AccountSignerMeta<TAccountMintAuthority>\n      : TAccountMintAuthority\n  >);\n}\n\nexport type ParsedMintToInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint account. */\n    mint: TAccountMetas[0];\n    /** The account to mint tokens to. */\n    token: TAccountMetas[1];\n    /** The mint's minting authority or its multisignature account. */\n    mintAuthority: TAccountMetas[2];\n  };\n  data: MintToInstructionData;\n};\n\nexport function parseMintToInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedMintToInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      token: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getMintToInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const MINT_TO_CHECKED_DISCRIMINATOR = 14;\n\nexport function getMintToCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(MINT_TO_CHECKED_DISCRIMINATOR);\n}\n\nexport type MintToCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountMintAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMintAuthority extends string\n        ? ReadonlyAccount<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type MintToCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of new tokens to mint. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type MintToCheckedInstructionDataArgs = {\n  /** The amount of new tokens to mint. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getMintToCheckedInstructionDataEncoder(): FixedSizeEncoder<MintToCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: MINT_TO_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getMintToCheckedInstructionDataDecoder(): FixedSizeDecoder<MintToCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getMintToCheckedInstructionDataCodec(): FixedSizeCodec<\n  MintToCheckedInstructionDataArgs,\n  MintToCheckedInstructionData\n> {\n  return combineCodec(\n    getMintToCheckedInstructionDataEncoder(),\n    getMintToCheckedInstructionDataDecoder()\n  );\n}\n\nexport type MintToCheckedInput<\n  TAccountMint extends string = string,\n  TAccountToken extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The account to mint tokens to. */\n  token: Address<TAccountToken>;\n  /** The mint's minting authority or its multisignature account. */\n  mintAuthority:\n    | Address<TAccountMintAuthority>\n    | TransactionSigner<TAccountMintAuthority>;\n  amount: MintToCheckedInstructionDataArgs['amount'];\n  decimals: MintToCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getMintToCheckedInstruction<\n  TAccountMint extends string,\n  TAccountToken extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: MintToCheckedInput<TAccountMint, TAccountToken, TAccountMintAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): MintToCheckedInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountToken,\n  (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n    ? ReadonlySignerAccount<TAccountMintAuthority> &\n        AccountSignerMeta<TAccountMintAuthority>\n    : TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    token: { value: input.token ?? null, isWritable: true },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mintAuthority),\n      ...remainingAccounts,\n    ],\n    data: getMintToCheckedInstructionDataEncoder().encode(\n      args as MintToCheckedInstructionDataArgs\n    ),\n    programAddress,\n  } as MintToCheckedInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountToken,\n    (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n      ? ReadonlySignerAccount<TAccountMintAuthority> &\n          AccountSignerMeta<TAccountMintAuthority>\n      : TAccountMintAuthority\n  >);\n}\n\nexport type ParsedMintToCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The account to mint tokens to. */\n    token: TAccountMetas[1];\n    /** The mint's minting authority or its multisignature account. */\n    mintAuthority: TAccountMetas[2];\n  };\n  data: MintToCheckedInstructionData;\n};\n\nexport function parseMintToCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedMintToCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      token: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getMintToCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const PAUSE_DISCRIMINATOR = 44;\n\nexport function getPauseDiscriminatorBytes() {\n  return getU8Encoder().encode(PAUSE_DISCRIMINATOR);\n}\n\nexport const PAUSE_PAUSABLE_DISCRIMINATOR = 1;\n\nexport function getPausePausableDiscriminatorBytes() {\n  return getU8Encoder().encode(PAUSE_PAUSABLE_DISCRIMINATOR);\n}\n\nexport type PauseInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type PauseInstructionData = {\n  discriminator: number;\n  pausableDiscriminator: number;\n};\n\nexport type PauseInstructionDataArgs = {};\n\nexport function getPauseInstructionDataEncoder(): FixedSizeEncoder<PauseInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['pausableDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: PAUSE_DISCRIMINATOR,\n      pausableDiscriminator: PAUSE_PAUSABLE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getPauseInstructionDataDecoder(): FixedSizeDecoder<PauseInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['pausableDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getPauseInstructionDataCodec(): FixedSizeCodec<\n  PauseInstructionDataArgs,\n  PauseInstructionData\n> {\n  return combineCodec(\n    getPauseInstructionDataEncoder(),\n    getPauseInstructionDataDecoder()\n  );\n}\n\nexport type PauseInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The pausable authority that can pause the mint. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n};\n\nexport function getPauseInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: PauseInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): PauseInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n    ],\n    data: getPauseInstructionDataEncoder().encode({}),\n    programAddress,\n  } as PauseInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedPauseInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The pausable authority that can pause the mint. */\n    authority: TAccountMetas[1];\n  };\n  data: PauseInstructionData;\n};\n\nexport function parsePauseInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedPauseInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), authority: getNextAccount() },\n    data: getPauseInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getArrayDecoder,\n  getArrayEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getExtensionTypeDecoder,\n  getExtensionTypeEncoder,\n  type ExtensionType,\n  type ExtensionTypeArgs,\n} from '../types';\n\nexport const REALLOCATE_DISCRIMINATOR = 29;\n\nexport function getReallocateDiscriminatorBytes() {\n  return getU8Encoder().encode(REALLOCATE_DISCRIMINATOR);\n}\n\nexport type ReallocateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountPayer extends string | AccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | AccountMeta<string> = '11111111111111111111111111111111',\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            AccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ReallocateInstructionData = {\n  discriminator: number;\n  /** New extension types to include in the reallocated account. */\n  newExtensionTypes: Array<ExtensionType>;\n};\n\nexport type ReallocateInstructionDataArgs = {\n  /** New extension types to include in the reallocated account. */\n  newExtensionTypes: Array<ExtensionTypeArgs>;\n};\n\nexport function getReallocateInstructionDataEncoder(): Encoder<ReallocateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      [\n        'newExtensionTypes',\n        getArrayEncoder(getExtensionTypeEncoder(), { size: 'remainder' }),\n      ],\n    ]),\n    (value) => ({ ...value, discriminator: REALLOCATE_DISCRIMINATOR })\n  );\n}\n\nexport function getReallocateInstructionDataDecoder(): Decoder<ReallocateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    [\n      'newExtensionTypes',\n      getArrayDecoder(getExtensionTypeDecoder(), { size: 'remainder' }),\n    ],\n  ]);\n}\n\nexport function getReallocateInstructionDataCodec(): Codec<\n  ReallocateInstructionDataArgs,\n  ReallocateInstructionData\n> {\n  return combineCodec(\n    getReallocateInstructionDataEncoder(),\n    getReallocateInstructionDataDecoder()\n  );\n}\n\nexport type ReallocateInput<\n  TAccountToken extends string = string,\n  TAccountPayer extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The token account to reallocate. */\n  token: Address<TAccountToken>;\n  /** The payer account to fund reallocation. */\n  payer: TransactionSigner<TAccountPayer>;\n  /** System program for reallocation funding. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** The account's owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  newExtensionTypes: ReallocateInstructionDataArgs['newExtensionTypes'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getReallocateInstruction<\n  TAccountToken extends string,\n  TAccountPayer extends string,\n  TAccountSystemProgram extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ReallocateInput<\n    TAccountToken,\n    TAccountPayer,\n    TAccountSystemProgram,\n    TAccountOwner\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ReallocateInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountPayer,\n  TAccountSystemProgram,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    payer: { value: input.payer ?? null, isWritable: true },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getReallocateInstructionDataEncoder().encode(\n      args as ReallocateInstructionDataArgs\n    ),\n    programAddress,\n  } as ReallocateInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountPayer,\n    TAccountSystemProgram,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedReallocateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token account to reallocate. */\n    token: TAccountMetas[0];\n    /** The payer account to fund reallocation. */\n    payer: TAccountMetas[1];\n    /** System program for reallocation funding. */\n    systemProgram: TAccountMetas[2];\n    /** The account's owner or its multisignature account. */\n    owner: TAccountMetas[3];\n  };\n  data: ReallocateInstructionData;\n};\n\nexport function parseReallocateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedReallocateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      payer: getNextAccount(),\n      systemProgram: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getReallocateInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { findAssociatedTokenPda } from '../pdas';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  getAccountMetaFactory,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR = 2;\n\nexport function getRecoverNestedAssociatedTokenDiscriminatorBytes() {\n  return getU8Encoder().encode(RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR);\n}\n\nexport type RecoverNestedAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountNestedAssociatedAccountAddress extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountNestedTokenMintAddress extends string | AccountMeta<string> = string,\n  TAccountDestinationAssociatedAccountAddress extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountOwnerAssociatedAccountAddress extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountOwnerTokenMintAddress extends string | AccountMeta<string> = string,\n  TAccountWalletAddress extends string | AccountMeta<string> = string,\n  TAccountTokenProgram extends\n    | string\n    | AccountMeta<string> = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountNestedAssociatedAccountAddress extends string\n        ? WritableAccount<TAccountNestedAssociatedAccountAddress>\n        : TAccountNestedAssociatedAccountAddress,\n      TAccountNestedTokenMintAddress extends string\n        ? ReadonlyAccount<TAccountNestedTokenMintAddress>\n        : TAccountNestedTokenMintAddress,\n      TAccountDestinationAssociatedAccountAddress extends string\n        ? WritableAccount<TAccountDestinationAssociatedAccountAddress>\n        : TAccountDestinationAssociatedAccountAddress,\n      TAccountOwnerAssociatedAccountAddress extends string\n        ? ReadonlyAccount<TAccountOwnerAssociatedAccountAddress>\n        : TAccountOwnerAssociatedAccountAddress,\n      TAccountOwnerTokenMintAddress extends string\n        ? ReadonlyAccount<TAccountOwnerTokenMintAddress>\n        : TAccountOwnerTokenMintAddress,\n      TAccountWalletAddress extends string\n        ? WritableSignerAccount<TAccountWalletAddress> &\n            AccountSignerMeta<TAccountWalletAddress>\n        : TAccountWalletAddress,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type RecoverNestedAssociatedTokenInstructionData = {\n  discriminator: number;\n};\n\nexport type RecoverNestedAssociatedTokenInstructionDataArgs = {};\n\nexport function getRecoverNestedAssociatedTokenInstructionDataEncoder(): FixedSizeEncoder<RecoverNestedAssociatedTokenInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getRecoverNestedAssociatedTokenInstructionDataDecoder(): FixedSizeDecoder<RecoverNestedAssociatedTokenInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getRecoverNestedAssociatedTokenInstructionDataCodec(): FixedSizeCodec<\n  RecoverNestedAssociatedTokenInstructionDataArgs,\n  RecoverNestedAssociatedTokenInstructionData\n> {\n  return combineCodec(\n    getRecoverNestedAssociatedTokenInstructionDataEncoder(),\n    getRecoverNestedAssociatedTokenInstructionDataDecoder()\n  );\n}\n\nexport type RecoverNestedAssociatedTokenAsyncInput<\n  TAccountNestedAssociatedAccountAddress extends string = string,\n  TAccountNestedTokenMintAddress extends string = string,\n  TAccountDestinationAssociatedAccountAddress extends string = string,\n  TAccountOwnerAssociatedAccountAddress extends string = string,\n  TAccountOwnerTokenMintAddress extends string = string,\n  TAccountWalletAddress extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Nested associated token account, must be owned by `ownerAssociatedAccountAddress`. */\n  nestedAssociatedAccountAddress?: Address<TAccountNestedAssociatedAccountAddress>;\n  /** Token mint for the nested associated token account. */\n  nestedTokenMintAddress: Address<TAccountNestedTokenMintAddress>;\n  /** Wallet's associated token account. */\n  destinationAssociatedAccountAddress?: Address<TAccountDestinationAssociatedAccountAddress>;\n  /** Owner associated token account address, must be owned by `walletAddress`. */\n  ownerAssociatedAccountAddress?: Address<TAccountOwnerAssociatedAccountAddress>;\n  /** Token mint for the owner associated token account. */\n  ownerTokenMintAddress: Address<TAccountOwnerTokenMintAddress>;\n  /** Wallet address for the owner associated token account. */\n  walletAddress: TransactionSigner<TAccountWalletAddress>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport async function getRecoverNestedAssociatedTokenInstructionAsync<\n  TAccountNestedAssociatedAccountAddress extends string,\n  TAccountNestedTokenMintAddress extends string,\n  TAccountDestinationAssociatedAccountAddress extends string,\n  TAccountOwnerAssociatedAccountAddress extends string,\n  TAccountOwnerTokenMintAddress extends string,\n  TAccountWalletAddress extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: RecoverNestedAssociatedTokenAsyncInput<\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  RecoverNestedAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nestedAssociatedAccountAddress: {\n      value: input.nestedAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    nestedTokenMintAddress: {\n      value: input.nestedTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    destinationAssociatedAccountAddress: {\n      value: input.destinationAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    ownerAssociatedAccountAddress: {\n      value: input.ownerAssociatedAccountAddress ?? null,\n      isWritable: false,\n    },\n    ownerTokenMintAddress: {\n      value: input.ownerTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    walletAddress: { value: input.walletAddress ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n  if (!accounts.ownerAssociatedAccountAddress.value) {\n    accounts.ownerAssociatedAccountAddress.value = await findAssociatedTokenPda(\n      {\n        owner: expectAddress(accounts.walletAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.ownerTokenMintAddress.value),\n      }\n    );\n  }\n  if (!accounts.nestedAssociatedAccountAddress.value) {\n    accounts.nestedAssociatedAccountAddress.value =\n      await findAssociatedTokenPda({\n        owner: expectAddress(accounts.ownerAssociatedAccountAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.nestedTokenMintAddress.value),\n      });\n  }\n  if (!accounts.destinationAssociatedAccountAddress.value) {\n    accounts.destinationAssociatedAccountAddress.value =\n      await findAssociatedTokenPda({\n        owner: expectAddress(accounts.walletAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.nestedTokenMintAddress.value),\n      });\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.nestedAssociatedAccountAddress),\n      getAccountMeta(accounts.nestedTokenMintAddress),\n      getAccountMeta(accounts.destinationAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerTokenMintAddress),\n      getAccountMeta(accounts.walletAddress),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    data: getRecoverNestedAssociatedTokenInstructionDataEncoder().encode({}),\n    programAddress,\n  } as RecoverNestedAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >);\n}\n\nexport type RecoverNestedAssociatedTokenInput<\n  TAccountNestedAssociatedAccountAddress extends string = string,\n  TAccountNestedTokenMintAddress extends string = string,\n  TAccountDestinationAssociatedAccountAddress extends string = string,\n  TAccountOwnerAssociatedAccountAddress extends string = string,\n  TAccountOwnerTokenMintAddress extends string = string,\n  TAccountWalletAddress extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Nested associated token account, must be owned by `ownerAssociatedAccountAddress`. */\n  nestedAssociatedAccountAddress: Address<TAccountNestedAssociatedAccountAddress>;\n  /** Token mint for the nested associated token account. */\n  nestedTokenMintAddress: Address<TAccountNestedTokenMintAddress>;\n  /** Wallet's associated token account. */\n  destinationAssociatedAccountAddress: Address<TAccountDestinationAssociatedAccountAddress>;\n  /** Owner associated token account address, must be owned by `walletAddress`. */\n  ownerAssociatedAccountAddress: Address<TAccountOwnerAssociatedAccountAddress>;\n  /** Token mint for the owner associated token account. */\n  ownerTokenMintAddress: Address<TAccountOwnerTokenMintAddress>;\n  /** Wallet address for the owner associated token account. */\n  walletAddress: TransactionSigner<TAccountWalletAddress>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getRecoverNestedAssociatedTokenInstruction<\n  TAccountNestedAssociatedAccountAddress extends string,\n  TAccountNestedTokenMintAddress extends string,\n  TAccountDestinationAssociatedAccountAddress extends string,\n  TAccountOwnerAssociatedAccountAddress extends string,\n  TAccountOwnerTokenMintAddress extends string,\n  TAccountWalletAddress extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: RecoverNestedAssociatedTokenInput<\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): RecoverNestedAssociatedTokenInstruction<\n  TProgramAddress,\n  TAccountNestedAssociatedAccountAddress,\n  TAccountNestedTokenMintAddress,\n  TAccountDestinationAssociatedAccountAddress,\n  TAccountOwnerAssociatedAccountAddress,\n  TAccountOwnerTokenMintAddress,\n  TAccountWalletAddress,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nestedAssociatedAccountAddress: {\n      value: input.nestedAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    nestedTokenMintAddress: {\n      value: input.nestedTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    destinationAssociatedAccountAddress: {\n      value: input.destinationAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    ownerAssociatedAccountAddress: {\n      value: input.ownerAssociatedAccountAddress ?? null,\n      isWritable: false,\n    },\n    ownerTokenMintAddress: {\n      value: input.ownerTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    walletAddress: { value: input.walletAddress ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.nestedAssociatedAccountAddress),\n      getAccountMeta(accounts.nestedTokenMintAddress),\n      getAccountMeta(accounts.destinationAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerTokenMintAddress),\n      getAccountMeta(accounts.walletAddress),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    data: getRecoverNestedAssociatedTokenInstructionDataEncoder().encode({}),\n    programAddress,\n  } as RecoverNestedAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >);\n}\n\nexport type ParsedRecoverNestedAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Nested associated token account, must be owned by `ownerAssociatedAccountAddress`. */\n    nestedAssociatedAccountAddress: TAccountMetas[0];\n    /** Token mint for the nested associated token account. */\n    nestedTokenMintAddress: TAccountMetas[1];\n    /** Wallet's associated token account. */\n    destinationAssociatedAccountAddress: TAccountMetas[2];\n    /** Owner associated token account address, must be owned by `walletAddress`. */\n    ownerAssociatedAccountAddress: TAccountMetas[3];\n    /** Token mint for the owner associated token account. */\n    ownerTokenMintAddress: TAccountMetas[4];\n    /** Wallet address for the owner associated token account. */\n    walletAddress: TAccountMetas[5];\n    /** SPL Token program. */\n    tokenProgram: TAccountMetas[6];\n  };\n  data: RecoverNestedAssociatedTokenInstructionData;\n};\n\nexport function parseRecoverNestedAssociatedTokenInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedRecoverNestedAssociatedTokenInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 7) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nestedAssociatedAccountAddress: getNextAccount(),\n      nestedTokenMintAddress: getNextAccount(),\n      destinationAssociatedAccountAddress: getNextAccount(),\n      ownerAssociatedAccountAddress: getNextAccount(),\n      ownerTokenMintAddress: getNextAccount(),\n      walletAddress: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getRecoverNestedAssociatedTokenInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR = new Uint8Array([\n  234, 18, 32, 56, 89, 141, 37, 181,\n]);\n\nexport function getRemoveTokenMetadataKeyDiscriminatorBytes() {\n  return getBytesEncoder().encode(REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR);\n}\n\nexport type RemoveTokenMetadataKeyInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | AccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMetadata extends string\n        ? WritableAccount<TAccountMetadata>\n        : TAccountMetadata,\n      TAccountUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountUpdateAuthority> &\n            AccountSignerMeta<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type RemoveTokenMetadataKeyInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /**\n   * If the idempotent flag is set to true, then the instruction will not\n   * error if the key does not exist\n   */\n  idempotent: boolean;\n  /** Key to remove in the additional metadata portion. */\n  key: string;\n};\n\nexport type RemoveTokenMetadataKeyInstructionDataArgs = {\n  /**\n   * If the idempotent flag is set to true, then the instruction will not\n   * error if the key does not exist\n   */\n  idempotent?: boolean;\n  /** Key to remove in the additional metadata portion. */\n  key: string;\n};\n\nexport function getRemoveTokenMetadataKeyInstructionDataEncoder(): Encoder<RemoveTokenMetadataKeyInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      ['idempotent', getBooleanEncoder()],\n      ['key', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR,\n      idempotent: value.idempotent ?? false,\n    })\n  );\n}\n\nexport function getRemoveTokenMetadataKeyInstructionDataDecoder(): Decoder<RemoveTokenMetadataKeyInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    ['idempotent', getBooleanDecoder()],\n    ['key', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n  ]);\n}\n\nexport function getRemoveTokenMetadataKeyInstructionDataCodec(): Codec<\n  RemoveTokenMetadataKeyInstructionDataArgs,\n  RemoveTokenMetadataKeyInstructionData\n> {\n  return combineCodec(\n    getRemoveTokenMetadataKeyInstructionDataEncoder(),\n    getRemoveTokenMetadataKeyInstructionDataDecoder()\n  );\n}\n\nexport type RemoveTokenMetadataKeyInput<\n  TAccountMetadata extends string = string,\n  TAccountUpdateAuthority extends string = string,\n> = {\n  metadata: Address<TAccountMetadata>;\n  updateAuthority: TransactionSigner<TAccountUpdateAuthority>;\n  idempotent?: RemoveTokenMetadataKeyInstructionDataArgs['idempotent'];\n  key: RemoveTokenMetadataKeyInstructionDataArgs['key'];\n};\n\nexport function getRemoveTokenMetadataKeyInstruction<\n  TAccountMetadata extends string,\n  TAccountUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: RemoveTokenMetadataKeyInput<TAccountMetadata, TAccountUpdateAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): RemoveTokenMetadataKeyInstruction<\n  TProgramAddress,\n  TAccountMetadata,\n  TAccountUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.updateAuthority),\n    ],\n    data: getRemoveTokenMetadataKeyInstructionDataEncoder().encode(\n      args as RemoveTokenMetadataKeyInstructionDataArgs\n    ),\n    programAddress,\n  } as RemoveTokenMetadataKeyInstruction<\n    TProgramAddress,\n    TAccountMetadata,\n    TAccountUpdateAuthority\n  >);\n}\n\nexport type ParsedRemoveTokenMetadataKeyInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    metadata: TAccountMetas[0];\n    updateAuthority: TAccountMetas[1];\n  };\n  data: RemoveTokenMetadataKeyInstructionData;\n};\n\nexport function parseRemoveTokenMetadataKeyInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedRemoveTokenMetadataKeyInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { metadata: getNextAccount(), updateAuthority: getNextAccount() },\n    data: getRemoveTokenMetadataKeyInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const RESUME_DISCRIMINATOR = 44;\n\nexport function getResumeDiscriminatorBytes() {\n  return getU8Encoder().encode(RESUME_DISCRIMINATOR);\n}\n\nexport const RESUME_PAUSABLE_DISCRIMINATOR = 2;\n\nexport function getResumePausableDiscriminatorBytes() {\n  return getU8Encoder().encode(RESUME_PAUSABLE_DISCRIMINATOR);\n}\n\nexport type ResumeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ResumeInstructionData = {\n  discriminator: number;\n  pausableDiscriminator: number;\n};\n\nexport type ResumeInstructionDataArgs = {};\n\nexport function getResumeInstructionDataEncoder(): FixedSizeEncoder<ResumeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['pausableDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: RESUME_DISCRIMINATOR,\n      pausableDiscriminator: RESUME_PAUSABLE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getResumeInstructionDataDecoder(): FixedSizeDecoder<ResumeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['pausableDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getResumeInstructionDataCodec(): FixedSizeCodec<\n  ResumeInstructionDataArgs,\n  ResumeInstructionData\n> {\n  return combineCodec(\n    getResumeInstructionDataEncoder(),\n    getResumeInstructionDataDecoder()\n  );\n}\n\nexport type ResumeInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The pausable authority that can resume the mint. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n};\n\nexport function getResumeInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ResumeInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): ResumeInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n    ],\n    data: getResumeInstructionDataEncoder().encode({}),\n    programAddress,\n  } as ResumeInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedResumeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The pausable authority that can resume the mint. */\n    authority: TAccountMetas[1];\n  };\n  data: ResumeInstructionData;\n};\n\nexport function parseResumeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedResumeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), authority: getNextAccount() },\n    data: getResumeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const REVOKE_DISCRIMINATOR = 5;\n\nexport function getRevokeDiscriminatorBytes() {\n  return getU8Encoder().encode(REVOKE_DISCRIMINATOR);\n}\n\nexport type RevokeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type RevokeInstructionData = { discriminator: number };\n\nexport type RevokeInstructionDataArgs = {};\n\nexport function getRevokeInstructionDataEncoder(): FixedSizeEncoder<RevokeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: REVOKE_DISCRIMINATOR })\n  );\n}\n\nexport function getRevokeInstructionDataDecoder(): FixedSizeDecoder<RevokeInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getRevokeInstructionDataCodec(): FixedSizeCodec<\n  RevokeInstructionDataArgs,\n  RevokeInstructionData\n> {\n  return combineCodec(\n    getRevokeInstructionDataEncoder(),\n    getRevokeInstructionDataDecoder()\n  );\n}\n\nexport type RevokeInput<\n  TAccountSource extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The source account owner or its multisignature. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getRevokeInstruction<\n  TAccountSource extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: RevokeInput<TAccountSource, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): RevokeInstruction<\n  TProgramAddress,\n  TAccountSource,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getRevokeInstructionDataEncoder().encode({}),\n    programAddress,\n  } as RevokeInstruction<\n    TProgramAddress,\n    TAccountSource,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedRevokeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The source account owner or its multisignature. */\n    owner: TAccountMetas[1];\n  };\n  data: RevokeInstructionData;\n};\n\nexport function parseRevokeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedRevokeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { source: getNextAccount(), owner: getNextAccount() },\n    data: getRevokeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getAuthorityTypeDecoder,\n  getAuthorityTypeEncoder,\n  type AuthorityType,\n  type AuthorityTypeArgs,\n} from '../types';\n\nexport const SET_AUTHORITY_DISCRIMINATOR = 6;\n\nexport function getSetAuthorityDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_AUTHORITY_DISCRIMINATOR);\n}\n\nexport type SetAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountOwned extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountOwned extends string\n        ? WritableAccount<TAccountOwned>\n        : TAccountOwned,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetAuthorityInstructionData = {\n  discriminator: number;\n  /** The type of authority to update. */\n  authorityType: AuthorityType;\n  /** The new authority */\n  newAuthority: Option<Address>;\n};\n\nexport type SetAuthorityInstructionDataArgs = {\n  /** The type of authority to update. */\n  authorityType: AuthorityTypeArgs;\n  /** The new authority */\n  newAuthority: OptionOrNullable<Address>;\n};\n\nexport function getSetAuthorityInstructionDataEncoder(): Encoder<SetAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['authorityType', getAuthorityTypeEncoder()],\n      ['newAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({ ...value, discriminator: SET_AUTHORITY_DISCRIMINATOR })\n  );\n}\n\nexport function getSetAuthorityInstructionDataDecoder(): Decoder<SetAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['authorityType', getAuthorityTypeDecoder()],\n    ['newAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getSetAuthorityInstructionDataCodec(): Codec<\n  SetAuthorityInstructionDataArgs,\n  SetAuthorityInstructionData\n> {\n  return combineCodec(\n    getSetAuthorityInstructionDataEncoder(),\n    getSetAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type SetAuthorityInput<\n  TAccountOwned extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The mint or account to change the authority of. */\n  owned: Address<TAccountOwned>;\n  /** The current authority or the multisignature account of the mint or account to update. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  authorityType: SetAuthorityInstructionDataArgs['authorityType'];\n  newAuthority: SetAuthorityInstructionDataArgs['newAuthority'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getSetAuthorityInstruction<\n  TAccountOwned extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: SetAuthorityInput<TAccountOwned, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): SetAuthorityInstruction<\n  TProgramAddress,\n  TAccountOwned,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    owned: { value: input.owned ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.owned),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getSetAuthorityInstructionDataEncoder().encode(\n      args as SetAuthorityInstructionDataArgs\n    ),\n    programAddress,\n  } as SetAuthorityInstruction<\n    TProgramAddress,\n    TAccountOwned,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedSetAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint or account to change the authority of. */\n    owned: TAccountMetas[0];\n    /** The current authority or the multisignature account of the mint or account to update. */\n    owner: TAccountMetas[1];\n  };\n  data: SetAuthorityInstructionData;\n};\n\nexport function parseSetAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedSetAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { owned: getNextAccount(), owner: getNextAccount() },\n    data: getSetAuthorityInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_TRANSFER_FEE_DISCRIMINATOR = 26;\n\nexport function getSetTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_TRANSFER_FEE_DISCRIMINATOR);\n}\n\nexport const SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR = 5;\n\nexport function getSetTransferFeeTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR);\n}\n\nexport type SetTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountTransferFeeConfigAuthority extends\n    | string\n    | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountTransferFeeConfigAuthority extends string\n        ? ReadonlyAccount<TAccountTransferFeeConfigAuthority>\n        : TAccountTransferFeeConfigAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetTransferFeeInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n  /** Amount of transfer collected as fees, expressed as basis points of the transfer amount. */\n  transferFeeBasisPoints: number;\n  /** Maximum fee assessed on transfers. */\n  maximumFee: bigint;\n};\n\nexport type SetTransferFeeInstructionDataArgs = {\n  /** Amount of transfer collected as fees, expressed as basis points of the transfer amount. */\n  transferFeeBasisPoints: number;\n  /** Maximum fee assessed on transfers. */\n  maximumFee: number | bigint;\n};\n\nexport function getSetTransferFeeInstructionDataEncoder(): FixedSizeEncoder<SetTransferFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n      ['transferFeeBasisPoints', getU16Encoder()],\n      ['maximumFee', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_TRANSFER_FEE_DISCRIMINATOR,\n      transferFeeDiscriminator: SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetTransferFeeInstructionDataDecoder(): FixedSizeDecoder<SetTransferFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n    ['transferFeeBasisPoints', getU16Decoder()],\n    ['maximumFee', getU64Decoder()],\n  ]);\n}\n\nexport function getSetTransferFeeInstructionDataCodec(): FixedSizeCodec<\n  SetTransferFeeInstructionDataArgs,\n  SetTransferFeeInstructionData\n> {\n  return combineCodec(\n    getSetTransferFeeInstructionDataEncoder(),\n    getSetTransferFeeInstructionDataDecoder()\n  );\n}\n\nexport type SetTransferFeeInput<\n  TAccountMint extends string = string,\n  TAccountTransferFeeConfigAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The mint's fee account owner or its multisignature account. */\n  transferFeeConfigAuthority:\n    | Address<TAccountTransferFeeConfigAuthority>\n    | TransactionSigner<TAccountTransferFeeConfigAuthority>;\n  transferFeeBasisPoints: SetTransferFeeInstructionDataArgs['transferFeeBasisPoints'];\n  maximumFee: SetTransferFeeInstructionDataArgs['maximumFee'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getSetTransferFeeInstruction<\n  TAccountMint extends string,\n  TAccountTransferFeeConfigAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: SetTransferFeeInput<TAccountMint, TAccountTransferFeeConfigAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): SetTransferFeeInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['transferFeeConfigAuthority'] extends TransactionSigner<TAccountTransferFeeConfigAuthority>\n    ? ReadonlySignerAccount<TAccountTransferFeeConfigAuthority> &\n        AccountSignerMeta<TAccountTransferFeeConfigAuthority>\n    : TAccountTransferFeeConfigAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    transferFeeConfigAuthority: {\n      value: input.transferFeeConfigAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.transferFeeConfigAuthority),\n      ...remainingAccounts,\n    ],\n    data: getSetTransferFeeInstructionDataEncoder().encode(\n      args as SetTransferFeeInstructionDataArgs\n    ),\n    programAddress,\n  } as SetTransferFeeInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['transferFeeConfigAuthority'] extends TransactionSigner<TAccountTransferFeeConfigAuthority>\n      ? ReadonlySignerAccount<TAccountTransferFeeConfigAuthority> &\n          AccountSignerMeta<TAccountTransferFeeConfigAuthority>\n      : TAccountTransferFeeConfigAuthority\n  >);\n}\n\nexport type ParsedSetTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The mint's fee account owner or its multisignature account. */\n    transferFeeConfigAuthority: TAccountMetas[1];\n  };\n  data: SetTransferFeeInstructionData;\n};\n\nexport function parseSetTransferFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedSetTransferFeeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      transferFeeConfigAuthority: getNextAccount(),\n    },\n    data: getSetTransferFeeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SYNC_NATIVE_DISCRIMINATOR = 17;\n\nexport function getSyncNativeDiscriminatorBytes() {\n  return getU8Encoder().encode(SYNC_NATIVE_DISCRIMINATOR);\n}\n\nexport type SyncNativeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SyncNativeInstructionData = { discriminator: number };\n\nexport type SyncNativeInstructionDataArgs = {};\n\nexport function getSyncNativeInstructionDataEncoder(): FixedSizeEncoder<SyncNativeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: SYNC_NATIVE_DISCRIMINATOR })\n  );\n}\n\nexport function getSyncNativeInstructionDataDecoder(): FixedSizeDecoder<SyncNativeInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getSyncNativeInstructionDataCodec(): FixedSizeCodec<\n  SyncNativeInstructionDataArgs,\n  SyncNativeInstructionData\n> {\n  return combineCodec(\n    getSyncNativeInstructionDataEncoder(),\n    getSyncNativeInstructionDataDecoder()\n  );\n}\n\nexport type SyncNativeInput<TAccountAccount extends string = string> = {\n  /** The native token account to sync with its underlying lamports. */\n  account: Address<TAccountAccount>;\n};\n\nexport function getSyncNativeInstruction<\n  TAccountAccount extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: SyncNativeInput<TAccountAccount>,\n  config?: { programAddress?: TProgramAddress }\n): SyncNativeInstruction<TProgramAddress, TAccountAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.account)],\n    data: getSyncNativeInstructionDataEncoder().encode({}),\n    programAddress,\n  } as SyncNativeInstruction<TProgramAddress, TAccountAccount>);\n}\n\nexport type ParsedSyncNativeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The native token account to sync with its underlying lamports. */\n    account: TAccountMetas[0];\n  };\n  data: SyncNativeInstructionData;\n};\n\nexport function parseSyncNativeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedSyncNativeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { account: getNextAccount() },\n    data: getSyncNativeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const THAW_ACCOUNT_DISCRIMINATOR = 11;\n\nexport function getThawAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(THAW_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type ThawAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ThawAccountInstructionData = { discriminator: number };\n\nexport type ThawAccountInstructionDataArgs = {};\n\nexport function getThawAccountInstructionDataEncoder(): FixedSizeEncoder<ThawAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: THAW_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getThawAccountInstructionDataDecoder(): FixedSizeDecoder<ThawAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getThawAccountInstructionDataCodec(): FixedSizeCodec<\n  ThawAccountInstructionDataArgs,\n  ThawAccountInstructionData\n> {\n  return combineCodec(\n    getThawAccountInstructionDataEncoder(),\n    getThawAccountInstructionDataDecoder()\n  );\n}\n\nexport type ThawAccountInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The account to thaw. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The mint freeze authority or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getThawAccountInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ThawAccountInput<TAccountAccount, TAccountMint, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): ThawAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getThawAccountInstructionDataEncoder().encode({}),\n    programAddress,\n  } as ThawAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedThawAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to thaw. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The mint freeze authority or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: ThawAccountInstructionData;\n};\n\nexport function parseThawAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedThawAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getThawAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_DISCRIMINATOR = 3;\n\nexport function getTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(TRANSFER_DISCRIMINATOR);\n}\n\nexport type TransferInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to transfer. */\n  amount: bigint;\n};\n\nexport type TransferInstructionDataArgs = {\n  /** The amount of tokens to transfer. */\n  amount: number | bigint;\n};\n\nexport function getTransferInstructionDataEncoder(): FixedSizeEncoder<TransferInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: TRANSFER_DISCRIMINATOR })\n  );\n}\n\nexport function getTransferInstructionDataDecoder(): FixedSizeDecoder<TransferInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getTransferInstructionDataCodec(): FixedSizeCodec<\n  TransferInstructionDataArgs,\n  TransferInstructionData\n> {\n  return combineCodec(\n    getTransferInstructionDataEncoder(),\n    getTransferInstructionDataDecoder()\n  );\n}\n\nexport type TransferInput<\n  TAccountSource extends string = string,\n  TAccountDestination extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The destination account. */\n  destination: Address<TAccountDestination>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: TransferInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getTransferInstruction<\n  TAccountSource extends string,\n  TAccountDestination extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: TransferInput<TAccountSource, TAccountDestination, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): TransferInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountDestination,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getTransferInstructionDataEncoder().encode(\n      args as TransferInstructionDataArgs\n    ),\n    programAddress,\n  } as TransferInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountDestination,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedTransferInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The destination account. */\n    destination: TAccountMetas[1];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: TransferInstructionData;\n};\n\nexport function parseTransferInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedTransferInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      destination: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getTransferInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_CHECKED_DISCRIMINATOR = 12;\n\nexport function getTransferCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(TRANSFER_CHECKED_DISCRIMINATOR);\n}\n\nexport type TransferCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to transfer. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type TransferCheckedInstructionDataArgs = {\n  /** The amount of tokens to transfer. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getTransferCheckedInstructionDataEncoder(): FixedSizeEncoder<TransferCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: TRANSFER_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getTransferCheckedInstructionDataDecoder(): FixedSizeDecoder<TransferCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getTransferCheckedInstructionDataCodec(): FixedSizeCodec<\n  TransferCheckedInstructionDataArgs,\n  TransferCheckedInstructionData\n> {\n  return combineCodec(\n    getTransferCheckedInstructionDataEncoder(),\n    getTransferCheckedInstructionDataDecoder()\n  );\n}\n\nexport type TransferCheckedInput<\n  TAccountSource extends string = string,\n  TAccountMint extends string = string,\n  TAccountDestination extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The destination account. */\n  destination: Address<TAccountDestination>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: TransferCheckedInstructionDataArgs['amount'];\n  decimals: TransferCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getTransferCheckedInstruction<\n  TAccountSource extends string,\n  TAccountMint extends string,\n  TAccountDestination extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: TransferCheckedInput<\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): TransferCheckedInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountMint,\n  TAccountDestination,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getTransferCheckedInstructionDataEncoder().encode(\n      args as TransferCheckedInstructionDataArgs\n    ),\n    programAddress,\n  } as TransferCheckedInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedTransferCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The destination account. */\n    destination: TAccountMetas[2];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[3];\n  };\n  data: TransferCheckedInstructionData;\n};\n\nexport function parseTransferCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedTransferCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getTransferCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR = 26;\n\nexport function getTransferCheckedWithFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR);\n}\n\nexport const TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR = 1;\n\nexport function getTransferCheckedWithFeeTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type TransferCheckedWithFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferCheckedWithFeeInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n  /** The amount of tokens to transfer. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /**\n   * Expected fee assessed on this transfer, calculated off-chain based\n   * on the transfer_fee_basis_points and maximum_fee of the mint. May\n   * be 0 for a mint without a configured transfer fee.\n   */\n  fee: bigint;\n};\n\nexport type TransferCheckedWithFeeInstructionDataArgs = {\n  /** The amount of tokens to transfer. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /**\n   * Expected fee assessed on this transfer, calculated off-chain based\n   * on the transfer_fee_basis_points and maximum_fee of the mint. May\n   * be 0 for a mint without a configured transfer fee.\n   */\n  fee: number | bigint;\n};\n\nexport function getTransferCheckedWithFeeInstructionDataEncoder(): FixedSizeEncoder<TransferCheckedWithFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n      ['fee', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR,\n      transferFeeDiscriminator:\n        TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getTransferCheckedWithFeeInstructionDataDecoder(): FixedSizeDecoder<TransferCheckedWithFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n    ['fee', getU64Decoder()],\n  ]);\n}\n\nexport function getTransferCheckedWithFeeInstructionDataCodec(): FixedSizeCodec<\n  TransferCheckedWithFeeInstructionDataArgs,\n  TransferCheckedWithFeeInstructionData\n> {\n  return combineCodec(\n    getTransferCheckedWithFeeInstructionDataEncoder(),\n    getTransferCheckedWithFeeInstructionDataDecoder()\n  );\n}\n\nexport type TransferCheckedWithFeeInput<\n  TAccountSource extends string = string,\n  TAccountMint extends string = string,\n  TAccountDestination extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source account. May include the `TransferFeeAmount` extension. */\n  source: Address<TAccountSource>;\n  /** The token mint. May include the `TransferFeeConfig` extension. */\n  mint: Address<TAccountMint>;\n  /** The destination account. May include the `TransferFeeAmount` extension. */\n  destination: Address<TAccountDestination>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: TransferCheckedWithFeeInstructionDataArgs['amount'];\n  decimals: TransferCheckedWithFeeInstructionDataArgs['decimals'];\n  fee: TransferCheckedWithFeeInstructionDataArgs['fee'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getTransferCheckedWithFeeInstruction<\n  TAccountSource extends string,\n  TAccountMint extends string,\n  TAccountDestination extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: TransferCheckedWithFeeInput<\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): TransferCheckedWithFeeInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountMint,\n  TAccountDestination,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getTransferCheckedWithFeeInstructionDataEncoder().encode(\n      args as TransferCheckedWithFeeInstructionDataArgs\n    ),\n    programAddress,\n  } as TransferCheckedWithFeeInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedTransferCheckedWithFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. May include the `TransferFeeAmount` extension. */\n    source: TAccountMetas[0];\n    /** The token mint. May include the `TransferFeeConfig` extension. */\n    mint: TAccountMetas[1];\n    /** The destination account. May include the `TransferFeeAmount` extension. */\n    destination: TAccountMetas[2];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[3];\n  };\n  data: TransferCheckedWithFeeInstructionData;\n};\n\nexport function parseTransferCheckedWithFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedTransferCheckedWithFeeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getTransferCheckedWithFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR = 24;\n\nexport function getUiAmountToAmountDiscriminatorBytes() {\n  return getU8Encoder().encode(UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR);\n}\n\nexport type UiAmountToAmountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UiAmountToAmountInstructionData = {\n  discriminator: number;\n  /** The ui_amount of tokens to reformat. */\n  uiAmount: string;\n};\n\nexport type UiAmountToAmountInstructionDataArgs = {\n  /** The ui_amount of tokens to reformat. */\n  uiAmount: string;\n};\n\nexport function getUiAmountToAmountInstructionDataEncoder(): Encoder<UiAmountToAmountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['uiAmount', getUtf8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getUiAmountToAmountInstructionDataDecoder(): Decoder<UiAmountToAmountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['uiAmount', getUtf8Decoder()],\n  ]);\n}\n\nexport function getUiAmountToAmountInstructionDataCodec(): Codec<\n  UiAmountToAmountInstructionDataArgs,\n  UiAmountToAmountInstructionData\n> {\n  return combineCodec(\n    getUiAmountToAmountInstructionDataEncoder(),\n    getUiAmountToAmountInstructionDataDecoder()\n  );\n}\n\nexport type UiAmountToAmountInput<TAccountMint extends string = string> = {\n  /** The mint to calculate for. */\n  mint: Address<TAccountMint>;\n  uiAmount: UiAmountToAmountInstructionDataArgs['uiAmount'];\n};\n\nexport function getUiAmountToAmountInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UiAmountToAmountInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): UiAmountToAmountInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getUiAmountToAmountInstructionDataEncoder().encode(\n      args as UiAmountToAmountInstructionDataArgs\n    ),\n    programAddress,\n  } as UiAmountToAmountInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedUiAmountToAmountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to calculate for. */\n    mint: TAccountMetas[0];\n  };\n  data: UiAmountToAmountInstructionData;\n};\n\nexport function parseUiAmountToAmountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUiAmountToAmountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getUiAmountToAmountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR = 27;\n\nexport function getUpdateConfidentialTransferMintDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR);\n}\n\nexport const UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 1;\n\nexport function getUpdateConfidentialTransferMintConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type UpdateConfidentialTransferMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlySignerAccount<TAccountAuthority> &\n            AccountSignerMeta<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateConfidentialTransferMintInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /**\n   * Determines if newly configured accounts must be approved by the\n   * `authority` before they may be used by the user.\n   */\n  autoApproveNewAccounts: boolean;\n  /** New authority to decode any transfer amount in a confidential transfer. */\n  auditorElgamalPubkey: Option<Address>;\n};\n\nexport type UpdateConfidentialTransferMintInstructionDataArgs = {\n  /**\n   * Determines if newly configured accounts must be approved by the\n   * `authority` before they may be used by the user.\n   */\n  autoApproveNewAccounts: boolean;\n  /** New authority to decode any transfer amount in a confidential transfer. */\n  auditorElgamalPubkey: OptionOrNullable<Address>;\n};\n\nexport function getUpdateConfidentialTransferMintInstructionDataEncoder(): FixedSizeEncoder<UpdateConfidentialTransferMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['autoApproveNewAccounts', getBooleanEncoder()],\n      [\n        'auditorElgamalPubkey',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateConfidentialTransferMintInstructionDataDecoder(): FixedSizeDecoder<UpdateConfidentialTransferMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['autoApproveNewAccounts', getBooleanDecoder()],\n    [\n      'auditorElgamalPubkey',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateConfidentialTransferMintInstructionDataCodec(): FixedSizeCodec<\n  UpdateConfidentialTransferMintInstructionDataArgs,\n  UpdateConfidentialTransferMintInstructionData\n> {\n  return combineCodec(\n    getUpdateConfidentialTransferMintInstructionDataEncoder(),\n    getUpdateConfidentialTransferMintInstructionDataDecoder()\n  );\n}\n\nexport type UpdateConfidentialTransferMintInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /** Confidential transfer mint authority. */\n  authority: TransactionSigner<TAccountAuthority>;\n  autoApproveNewAccounts: UpdateConfidentialTransferMintInstructionDataArgs['autoApproveNewAccounts'];\n  auditorElgamalPubkey: UpdateConfidentialTransferMintInstructionDataArgs['auditorElgamalPubkey'];\n};\n\nexport function getUpdateConfidentialTransferMintInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateConfidentialTransferMintInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateConfidentialTransferMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n    ],\n    data: getUpdateConfidentialTransferMintInstructionDataEncoder().encode(\n      args as UpdateConfidentialTransferMintInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateConfidentialTransferMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountAuthority\n  >);\n}\n\nexport type ParsedUpdateConfidentialTransferMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token mint. */\n    mint: TAccountMetas[0];\n    /** Confidential transfer mint authority. */\n    authority: TAccountMetas[1];\n  };\n  data: UpdateConfidentialTransferMintInstructionData;\n};\n\nexport function parseUpdateConfidentialTransferMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateConfidentialTransferMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), authority: getNextAccount() },\n    data: getUpdateConfidentialTransferMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getAccountStateDecoder,\n  getAccountStateEncoder,\n  type AccountState,\n  type AccountStateArgs,\n} from '../types';\n\nexport const UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 28;\n\nexport function getUpdateDefaultAccountStateDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR);\n}\n\nexport const UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 1;\n\nexport function getUpdateDefaultAccountStateDefaultAccountStateDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR\n  );\n}\n\nexport type UpdateDefaultAccountStateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountFreezeAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountFreezeAuthority extends string\n        ? ReadonlyAccount<TAccountFreezeAuthority>\n        : TAccountFreezeAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateDefaultAccountStateInstructionData = {\n  discriminator: number;\n  defaultAccountStateDiscriminator: number;\n  /** The state each new token account should start with. */\n  state: AccountState;\n};\n\nexport type UpdateDefaultAccountStateInstructionDataArgs = {\n  /** The state each new token account should start with. */\n  state: AccountStateArgs;\n};\n\nexport function getUpdateDefaultAccountStateInstructionDataEncoder(): FixedSizeEncoder<UpdateDefaultAccountStateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['defaultAccountStateDiscriminator', getU8Encoder()],\n      ['state', getAccountStateEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR,\n      defaultAccountStateDiscriminator:\n        UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateDefaultAccountStateInstructionDataDecoder(): FixedSizeDecoder<UpdateDefaultAccountStateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['defaultAccountStateDiscriminator', getU8Decoder()],\n    ['state', getAccountStateDecoder()],\n  ]);\n}\n\nexport function getUpdateDefaultAccountStateInstructionDataCodec(): FixedSizeCodec<\n  UpdateDefaultAccountStateInstructionDataArgs,\n  UpdateDefaultAccountStateInstructionData\n> {\n  return combineCodec(\n    getUpdateDefaultAccountStateInstructionDataEncoder(),\n    getUpdateDefaultAccountStateInstructionDataDecoder()\n  );\n}\n\nexport type UpdateDefaultAccountStateInput<\n  TAccountMint extends string = string,\n  TAccountFreezeAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The mint freeze authority or its multisignature account. */\n  freezeAuthority:\n    | Address<TAccountFreezeAuthority>\n    | TransactionSigner<TAccountFreezeAuthority>;\n  state: UpdateDefaultAccountStateInstructionDataArgs['state'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateDefaultAccountStateInstruction<\n  TAccountMint extends string,\n  TAccountFreezeAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateDefaultAccountStateInput<TAccountMint, TAccountFreezeAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateDefaultAccountStateInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['freezeAuthority'] extends TransactionSigner<TAccountFreezeAuthority>\n    ? ReadonlySignerAccount<TAccountFreezeAuthority> &\n        AccountSignerMeta<TAccountFreezeAuthority>\n    : TAccountFreezeAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    freezeAuthority: {\n      value: input.freezeAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.freezeAuthority),\n      ...remainingAccounts,\n    ],\n    data: getUpdateDefaultAccountStateInstructionDataEncoder().encode(\n      args as UpdateDefaultAccountStateInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateDefaultAccountStateInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['freezeAuthority'] extends TransactionSigner<TAccountFreezeAuthority>\n      ? ReadonlySignerAccount<TAccountFreezeAuthority> &\n          AccountSignerMeta<TAccountFreezeAuthority>\n      : TAccountFreezeAuthority\n  >);\n}\n\nexport type ParsedUpdateDefaultAccountStateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The mint freeze authority or its multisignature account. */\n    freezeAuthority: TAccountMetas[1];\n  };\n  data: UpdateDefaultAccountStateInstructionData;\n};\n\nexport function parseUpdateDefaultAccountStateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateDefaultAccountStateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), freezeAuthority: getNextAccount() },\n    data: getUpdateDefaultAccountStateInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR = 41;\n\nexport function getUpdateGroupMemberPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR);\n}\n\nexport const UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR = 1;\n\nexport function getUpdateGroupMemberPointerGroupMemberPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type UpdateGroupMemberPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountGroupMemberPointerAuthority extends\n    | string\n    | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountGroupMemberPointerAuthority extends string\n        ? ReadonlyAccount<TAccountGroupMemberPointerAuthority>\n        : TAccountGroupMemberPointerAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateGroupMemberPointerInstructionData = {\n  discriminator: number;\n  groupMemberPointerDiscriminator: number;\n  /** The new account address that holds the member. */\n  memberAddress: Option<Address>;\n};\n\nexport type UpdateGroupMemberPointerInstructionDataArgs = {\n  /** The new account address that holds the member. */\n  memberAddress: OptionOrNullable<Address>;\n};\n\nexport function getUpdateGroupMemberPointerInstructionDataEncoder(): FixedSizeEncoder<UpdateGroupMemberPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['groupMemberPointerDiscriminator', getU8Encoder()],\n      [\n        'memberAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR,\n      groupMemberPointerDiscriminator:\n        UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateGroupMemberPointerInstructionDataDecoder(): FixedSizeDecoder<UpdateGroupMemberPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['groupMemberPointerDiscriminator', getU8Decoder()],\n    [\n      'memberAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateGroupMemberPointerInstructionDataCodec(): FixedSizeCodec<\n  UpdateGroupMemberPointerInstructionDataArgs,\n  UpdateGroupMemberPointerInstructionData\n> {\n  return combineCodec(\n    getUpdateGroupMemberPointerInstructionDataEncoder(),\n    getUpdateGroupMemberPointerInstructionDataDecoder()\n  );\n}\n\nexport type UpdateGroupMemberPointerInput<\n  TAccountMint extends string = string,\n  TAccountGroupMemberPointerAuthority extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  /** The group member pointer authority or its multisignature account. */\n  groupMemberPointerAuthority:\n    | Address<TAccountGroupMemberPointerAuthority>\n    | TransactionSigner<TAccountGroupMemberPointerAuthority>;\n  memberAddress: UpdateGroupMemberPointerInstructionDataArgs['memberAddress'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateGroupMemberPointerInstruction<\n  TAccountMint extends string,\n  TAccountGroupMemberPointerAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateGroupMemberPointerInput<\n    TAccountMint,\n    TAccountGroupMemberPointerAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateGroupMemberPointerInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['groupMemberPointerAuthority'] extends TransactionSigner<TAccountGroupMemberPointerAuthority>\n    ? ReadonlySignerAccount<TAccountGroupMemberPointerAuthority> &\n        AccountSignerMeta<TAccountGroupMemberPointerAuthority>\n    : TAccountGroupMemberPointerAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    groupMemberPointerAuthority: {\n      value: input.groupMemberPointerAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.groupMemberPointerAuthority),\n      ...remainingAccounts,\n    ],\n    data: getUpdateGroupMemberPointerInstructionDataEncoder().encode(\n      args as UpdateGroupMemberPointerInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateGroupMemberPointerInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['groupMemberPointerAuthority'] extends TransactionSigner<TAccountGroupMemberPointerAuthority>\n      ? ReadonlySignerAccount<TAccountGroupMemberPointerAuthority> &\n          AccountSignerMeta<TAccountGroupMemberPointerAuthority>\n      : TAccountGroupMemberPointerAuthority\n  >);\n}\n\nexport type ParsedUpdateGroupMemberPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n    /** The group member pointer authority or its multisignature account. */\n    groupMemberPointerAuthority: TAccountMetas[1];\n  };\n  data: UpdateGroupMemberPointerInstructionData;\n};\n\nexport function parseUpdateGroupMemberPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateGroupMemberPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      groupMemberPointerAuthority: getNextAccount(),\n    },\n    data: getUpdateGroupMemberPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_GROUP_POINTER_DISCRIMINATOR = 40;\n\nexport function getUpdateGroupPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_GROUP_POINTER_DISCRIMINATOR);\n}\n\nexport const UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR = 1;\n\nexport function getUpdateGroupPointerGroupPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type UpdateGroupPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountGroupPointerAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountGroupPointerAuthority extends string\n        ? ReadonlyAccount<TAccountGroupPointerAuthority>\n        : TAccountGroupPointerAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateGroupPointerInstructionData = {\n  discriminator: number;\n  groupPointerDiscriminator: number;\n  /** The new account address that holds the group configurations. */\n  groupAddress: Option<Address>;\n};\n\nexport type UpdateGroupPointerInstructionDataArgs = {\n  /** The new account address that holds the group configurations. */\n  groupAddress: OptionOrNullable<Address>;\n};\n\nexport function getUpdateGroupPointerInstructionDataEncoder(): FixedSizeEncoder<UpdateGroupPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['groupPointerDiscriminator', getU8Encoder()],\n      [\n        'groupAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_GROUP_POINTER_DISCRIMINATOR,\n      groupPointerDiscriminator:\n        UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateGroupPointerInstructionDataDecoder(): FixedSizeDecoder<UpdateGroupPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['groupPointerDiscriminator', getU8Decoder()],\n    [\n      'groupAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateGroupPointerInstructionDataCodec(): FixedSizeCodec<\n  UpdateGroupPointerInstructionDataArgs,\n  UpdateGroupPointerInstructionData\n> {\n  return combineCodec(\n    getUpdateGroupPointerInstructionDataEncoder(),\n    getUpdateGroupPointerInstructionDataDecoder()\n  );\n}\n\nexport type UpdateGroupPointerInput<\n  TAccountMint extends string = string,\n  TAccountGroupPointerAuthority extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  /** The group pointer authority or its multisignature account. */\n  groupPointerAuthority:\n    | Address<TAccountGroupPointerAuthority>\n    | TransactionSigner<TAccountGroupPointerAuthority>;\n  groupAddress: UpdateGroupPointerInstructionDataArgs['groupAddress'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateGroupPointerInstruction<\n  TAccountMint extends string,\n  TAccountGroupPointerAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateGroupPointerInput<TAccountMint, TAccountGroupPointerAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateGroupPointerInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['groupPointerAuthority'] extends TransactionSigner<TAccountGroupPointerAuthority>\n    ? ReadonlySignerAccount<TAccountGroupPointerAuthority> &\n        AccountSignerMeta<TAccountGroupPointerAuthority>\n    : TAccountGroupPointerAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    groupPointerAuthority: {\n      value: input.groupPointerAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.groupPointerAuthority),\n      ...remainingAccounts,\n    ],\n    data: getUpdateGroupPointerInstructionDataEncoder().encode(\n      args as UpdateGroupPointerInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateGroupPointerInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['groupPointerAuthority'] extends TransactionSigner<TAccountGroupPointerAuthority>\n      ? ReadonlySignerAccount<TAccountGroupPointerAuthority> &\n          AccountSignerMeta<TAccountGroupPointerAuthority>\n      : TAccountGroupPointerAuthority\n  >);\n}\n\nexport type ParsedUpdateGroupPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n    /** The group pointer authority or its multisignature account. */\n    groupPointerAuthority: TAccountMetas[1];\n  };\n  data: UpdateGroupPointerInstructionData;\n};\n\nexport function parseUpdateGroupPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateGroupPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      groupPointerAuthority: getNextAccount(),\n    },\n    data: getUpdateGroupPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_METADATA_POINTER_DISCRIMINATOR = 39;\n\nexport function getUpdateMetadataPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_METADATA_POINTER_DISCRIMINATOR);\n}\n\nexport const UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR = 1;\n\nexport function getUpdateMetadataPointerMetadataPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type UpdateMetadataPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountMetadataPointerAuthority extends\n    | string\n    | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountMetadataPointerAuthority extends string\n        ? ReadonlyAccount<TAccountMetadataPointerAuthority>\n        : TAccountMetadataPointerAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateMetadataPointerInstructionData = {\n  discriminator: number;\n  metadataPointerDiscriminator: number;\n  /** The new account address that holds the metadata. */\n  metadataAddress: Option<Address>;\n};\n\nexport type UpdateMetadataPointerInstructionDataArgs = {\n  /** The new account address that holds the metadata. */\n  metadataAddress: OptionOrNullable<Address>;\n};\n\nexport function getUpdateMetadataPointerInstructionDataEncoder(): FixedSizeEncoder<UpdateMetadataPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['metadataPointerDiscriminator', getU8Encoder()],\n      [\n        'metadataAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_METADATA_POINTER_DISCRIMINATOR,\n      metadataPointerDiscriminator:\n        UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateMetadataPointerInstructionDataDecoder(): FixedSizeDecoder<UpdateMetadataPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['metadataPointerDiscriminator', getU8Decoder()],\n    [\n      'metadataAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateMetadataPointerInstructionDataCodec(): FixedSizeCodec<\n  UpdateMetadataPointerInstructionDataArgs,\n  UpdateMetadataPointerInstructionData\n> {\n  return combineCodec(\n    getUpdateMetadataPointerInstructionDataEncoder(),\n    getUpdateMetadataPointerInstructionDataDecoder()\n  );\n}\n\nexport type UpdateMetadataPointerInput<\n  TAccountMint extends string = string,\n  TAccountMetadataPointerAuthority extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  /** The metadata pointer authority or its multisignature account. */\n  metadataPointerAuthority:\n    | Address<TAccountMetadataPointerAuthority>\n    | TransactionSigner<TAccountMetadataPointerAuthority>;\n  metadataAddress: UpdateMetadataPointerInstructionDataArgs['metadataAddress'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateMetadataPointerInstruction<\n  TAccountMint extends string,\n  TAccountMetadataPointerAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateMetadataPointerInput<\n    TAccountMint,\n    TAccountMetadataPointerAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateMetadataPointerInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['metadataPointerAuthority'] extends TransactionSigner<TAccountMetadataPointerAuthority>\n    ? ReadonlySignerAccount<TAccountMetadataPointerAuthority> &\n        AccountSignerMeta<TAccountMetadataPointerAuthority>\n    : TAccountMetadataPointerAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    metadataPointerAuthority: {\n      value: input.metadataPointerAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.metadataPointerAuthority),\n      ...remainingAccounts,\n    ],\n    data: getUpdateMetadataPointerInstructionDataEncoder().encode(\n      args as UpdateMetadataPointerInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateMetadataPointerInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['metadataPointerAuthority'] extends TransactionSigner<TAccountMetadataPointerAuthority>\n      ? ReadonlySignerAccount<TAccountMetadataPointerAuthority> &\n          AccountSignerMeta<TAccountMetadataPointerAuthority>\n      : TAccountMetadataPointerAuthority\n  >);\n}\n\nexport type ParsedUpdateMetadataPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n    /** The metadata pointer authority or its multisignature account. */\n    metadataPointerAuthority: TAccountMetas[1];\n  };\n  data: UpdateMetadataPointerInstructionData;\n};\n\nexport function parseUpdateMetadataPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateMetadataPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      metadataPointerAuthority: getNextAccount(),\n    },\n    data: getUpdateMetadataPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getF64Decoder,\n  getF64Encoder,\n  getI64Decoder,\n  getI64Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_MULTIPLIER_SCALED_UI_MINT_DISCRIMINATOR = 43;\n\nexport function getUpdateMultiplierScaledUiMintDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_MULTIPLIER_SCALED_UI_MINT_DISCRIMINATOR);\n}\n\nexport const UPDATE_MULTIPLIER_SCALED_UI_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR = 1;\n\nexport function getUpdateMultiplierScaledUiMintScaledUiAmountMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_MULTIPLIER_SCALED_UI_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR\n  );\n}\n\nexport type UpdateMultiplierScaledUiMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? WritableAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateMultiplierScaledUiMintInstructionData = {\n  discriminator: number;\n  scaledUiAmountMintDiscriminator: number;\n  /** The new multiplier for the scaled UI extension */\n  multiplier: number;\n  /** The timestamp at which the new multiplier will take effect */\n  effectiveTimestamp: bigint;\n};\n\nexport type UpdateMultiplierScaledUiMintInstructionDataArgs = {\n  /** The new multiplier for the scaled UI extension */\n  multiplier: number;\n  /** The timestamp at which the new multiplier will take effect */\n  effectiveTimestamp: number | bigint;\n};\n\nexport function getUpdateMultiplierScaledUiMintInstructionDataEncoder(): FixedSizeEncoder<UpdateMultiplierScaledUiMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['scaledUiAmountMintDiscriminator', getU8Encoder()],\n      ['multiplier', getF64Encoder()],\n      ['effectiveTimestamp', getI64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_MULTIPLIER_SCALED_UI_MINT_DISCRIMINATOR,\n      scaledUiAmountMintDiscriminator:\n        UPDATE_MULTIPLIER_SCALED_UI_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateMultiplierScaledUiMintInstructionDataDecoder(): FixedSizeDecoder<UpdateMultiplierScaledUiMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['scaledUiAmountMintDiscriminator', getU8Decoder()],\n    ['multiplier', getF64Decoder()],\n    ['effectiveTimestamp', getI64Decoder()],\n  ]);\n}\n\nexport function getUpdateMultiplierScaledUiMintInstructionDataCodec(): FixedSizeCodec<\n  UpdateMultiplierScaledUiMintInstructionDataArgs,\n  UpdateMultiplierScaledUiMintInstructionData\n> {\n  return combineCodec(\n    getUpdateMultiplierScaledUiMintInstructionDataEncoder(),\n    getUpdateMultiplierScaledUiMintInstructionDataDecoder()\n  );\n}\n\nexport type UpdateMultiplierScaledUiMintInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The multiplier authority. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiplier: UpdateMultiplierScaledUiMintInstructionDataArgs['multiplier'];\n  effectiveTimestamp: UpdateMultiplierScaledUiMintInstructionDataArgs['effectiveTimestamp'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateMultiplierScaledUiMintInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateMultiplierScaledUiMintInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateMultiplierScaledUiMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? WritableSignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getUpdateMultiplierScaledUiMintInstructionDataEncoder().encode(\n      args as UpdateMultiplierScaledUiMintInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateMultiplierScaledUiMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? WritableSignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedUpdateMultiplierScaledUiMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The multiplier authority. */\n    authority: TAccountMetas[1];\n  };\n  data: UpdateMultiplierScaledUiMintInstructionData;\n};\n\nexport function parseUpdateMultiplierScaledUiMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateMultiplierScaledUiMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), authority: getNextAccount() },\n    data: getUpdateMultiplierScaledUiMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI16Decoder,\n  getI16Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR = 33;\n\nexport function getUpdateRateInterestBearingMintDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR);\n}\n\nexport const UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR = 1;\n\nexport function getUpdateRateInterestBearingMintInterestBearingMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR\n  );\n}\n\nexport type UpdateRateInterestBearingMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountRateAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountRateAuthority extends string\n        ? WritableAccount<TAccountRateAuthority>\n        : TAccountRateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateRateInterestBearingMintInstructionData = {\n  discriminator: number;\n  interestBearingMintDiscriminator: number;\n  /** The interest rate to update. */\n  rate: number;\n};\n\nexport type UpdateRateInterestBearingMintInstructionDataArgs = {\n  /** The interest rate to update. */\n  rate: number;\n};\n\nexport function getUpdateRateInterestBearingMintInstructionDataEncoder(): FixedSizeEncoder<UpdateRateInterestBearingMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['interestBearingMintDiscriminator', getU8Encoder()],\n      ['rate', getI16Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR,\n      interestBearingMintDiscriminator:\n        UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateRateInterestBearingMintInstructionDataDecoder(): FixedSizeDecoder<UpdateRateInterestBearingMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['interestBearingMintDiscriminator', getU8Decoder()],\n    ['rate', getI16Decoder()],\n  ]);\n}\n\nexport function getUpdateRateInterestBearingMintInstructionDataCodec(): FixedSizeCodec<\n  UpdateRateInterestBearingMintInstructionDataArgs,\n  UpdateRateInterestBearingMintInstructionData\n> {\n  return combineCodec(\n    getUpdateRateInterestBearingMintInstructionDataEncoder(),\n    getUpdateRateInterestBearingMintInstructionDataDecoder()\n  );\n}\n\nexport type UpdateRateInterestBearingMintInput<\n  TAccountMint extends string = string,\n  TAccountRateAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The mint rate authority. */\n  rateAuthority:\n    | Address<TAccountRateAuthority>\n    | TransactionSigner<TAccountRateAuthority>;\n  rate: UpdateRateInterestBearingMintInstructionDataArgs['rate'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateRateInterestBearingMintInstruction<\n  TAccountMint extends string,\n  TAccountRateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateRateInterestBearingMintInput<\n    TAccountMint,\n    TAccountRateAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateRateInterestBearingMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['rateAuthority'] extends TransactionSigner<TAccountRateAuthority>\n    ? WritableSignerAccount<TAccountRateAuthority> &\n        AccountSignerMeta<TAccountRateAuthority>\n    : TAccountRateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    rateAuthority: { value: input.rateAuthority ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.rateAuthority),\n      ...remainingAccounts,\n    ],\n    data: getUpdateRateInterestBearingMintInstructionDataEncoder().encode(\n      args as UpdateRateInterestBearingMintInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateRateInterestBearingMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['rateAuthority'] extends TransactionSigner<TAccountRateAuthority>\n      ? WritableSignerAccount<TAccountRateAuthority> &\n          AccountSignerMeta<TAccountRateAuthority>\n      : TAccountRateAuthority\n  >);\n}\n\nexport type ParsedUpdateRateInterestBearingMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The mint rate authority. */\n    rateAuthority: TAccountMetas[1];\n  };\n  data: UpdateRateInterestBearingMintInstructionData;\n};\n\nexport function parseUpdateRateInterestBearingMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateRateInterestBearingMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), rateAuthority: getNextAccount() },\n    data: getUpdateRateInterestBearingMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR = new Uint8Array([\n  108, 37, 171, 143, 248, 30, 18, 110,\n]);\n\nexport function getUpdateTokenGroupMaxSizeDiscriminatorBytes() {\n  return getBytesEncoder().encode(UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR);\n}\n\nexport type UpdateTokenGroupMaxSizeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountGroup extends string | AccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountGroup extends string\n        ? WritableAccount<TAccountGroup>\n        : TAccountGroup,\n      TAccountUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountUpdateAuthority> &\n            AccountSignerMeta<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateTokenGroupMaxSizeInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** New max size for the group */\n  maxSize: bigint;\n};\n\nexport type UpdateTokenGroupMaxSizeInstructionDataArgs = {\n  /** New max size for the group */\n  maxSize: number | bigint;\n};\n\nexport function getUpdateTokenGroupMaxSizeInstructionDataEncoder(): Encoder<UpdateTokenGroupMaxSizeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      ['maxSize', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateTokenGroupMaxSizeInstructionDataDecoder(): Decoder<UpdateTokenGroupMaxSizeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    ['maxSize', getU64Decoder()],\n  ]);\n}\n\nexport function getUpdateTokenGroupMaxSizeInstructionDataCodec(): Codec<\n  UpdateTokenGroupMaxSizeInstructionDataArgs,\n  UpdateTokenGroupMaxSizeInstructionData\n> {\n  return combineCodec(\n    getUpdateTokenGroupMaxSizeInstructionDataEncoder(),\n    getUpdateTokenGroupMaxSizeInstructionDataDecoder()\n  );\n}\n\nexport type UpdateTokenGroupMaxSizeInput<\n  TAccountGroup extends string = string,\n  TAccountUpdateAuthority extends string = string,\n> = {\n  group: Address<TAccountGroup>;\n  updateAuthority: TransactionSigner<TAccountUpdateAuthority>;\n  maxSize: UpdateTokenGroupMaxSizeInstructionDataArgs['maxSize'];\n};\n\nexport function getUpdateTokenGroupMaxSizeInstruction<\n  TAccountGroup extends string,\n  TAccountUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateTokenGroupMaxSizeInput<TAccountGroup, TAccountUpdateAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateTokenGroupMaxSizeInstruction<\n  TProgramAddress,\n  TAccountGroup,\n  TAccountUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    group: { value: input.group ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.group),\n      getAccountMeta(accounts.updateAuthority),\n    ],\n    data: getUpdateTokenGroupMaxSizeInstructionDataEncoder().encode(\n      args as UpdateTokenGroupMaxSizeInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateTokenGroupMaxSizeInstruction<\n    TProgramAddress,\n    TAccountGroup,\n    TAccountUpdateAuthority\n  >);\n}\n\nexport type ParsedUpdateTokenGroupMaxSizeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    group: TAccountMetas[0];\n    updateAuthority: TAccountMetas[1];\n  };\n  data: UpdateTokenGroupMaxSizeInstructionData;\n};\n\nexport function parseUpdateTokenGroupMaxSizeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateTokenGroupMaxSizeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { group: getNextAccount(), updateAuthority: getNextAccount() },\n    data: getUpdateTokenGroupMaxSizeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR = new Uint8Array(\n  [161, 105, 88, 1, 237, 221, 216, 203]\n);\n\nexport function getUpdateTokenGroupUpdateAuthorityDiscriminatorBytes() {\n  return getBytesEncoder().encode(\n    UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR\n  );\n}\n\nexport type UpdateTokenGroupUpdateAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountGroup extends string | AccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountGroup extends string\n        ? WritableAccount<TAccountGroup>\n        : TAccountGroup,\n      TAccountUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountUpdateAuthority> &\n            AccountSignerMeta<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateTokenGroupUpdateAuthorityInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** New authority for the group, or unset if `None` */\n  newUpdateAuthority: Option<Address>;\n};\n\nexport type UpdateTokenGroupUpdateAuthorityInstructionDataArgs = {\n  /** New authority for the group, or unset if `None` */\n  newUpdateAuthority: OptionOrNullable<Address>;\n};\n\nexport function getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder(): Encoder<UpdateTokenGroupUpdateAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      [\n        'newUpdateAuthority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder(): Decoder<UpdateTokenGroupUpdateAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    [\n      'newUpdateAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateTokenGroupUpdateAuthorityInstructionDataCodec(): Codec<\n  UpdateTokenGroupUpdateAuthorityInstructionDataArgs,\n  UpdateTokenGroupUpdateAuthorityInstructionData\n> {\n  return combineCodec(\n    getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder(),\n    getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type UpdateTokenGroupUpdateAuthorityInput<\n  TAccountGroup extends string = string,\n  TAccountUpdateAuthority extends string = string,\n> = {\n  group: Address<TAccountGroup>;\n  /** Current update authority */\n  updateAuthority: TransactionSigner<TAccountUpdateAuthority>;\n  newUpdateAuthority: UpdateTokenGroupUpdateAuthorityInstructionDataArgs['newUpdateAuthority'];\n};\n\nexport function getUpdateTokenGroupUpdateAuthorityInstruction<\n  TAccountGroup extends string,\n  TAccountUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateTokenGroupUpdateAuthorityInput<\n    TAccountGroup,\n    TAccountUpdateAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateTokenGroupUpdateAuthorityInstruction<\n  TProgramAddress,\n  TAccountGroup,\n  TAccountUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    group: { value: input.group ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.group),\n      getAccountMeta(accounts.updateAuthority),\n    ],\n    data: getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder().encode(\n      args as UpdateTokenGroupUpdateAuthorityInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateTokenGroupUpdateAuthorityInstruction<\n    TProgramAddress,\n    TAccountGroup,\n    TAccountUpdateAuthority\n  >);\n}\n\nexport type ParsedUpdateTokenGroupUpdateAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    group: TAccountMetas[0];\n    /** Current update authority */\n    updateAuthority: TAccountMetas[1];\n  };\n  data: UpdateTokenGroupUpdateAuthorityInstructionData;\n};\n\nexport function parseUpdateTokenGroupUpdateAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateTokenGroupUpdateAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { group: getNextAccount(), updateAuthority: getNextAccount() },\n    data: getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getTokenMetadataFieldDecoder,\n  getTokenMetadataFieldEncoder,\n  type TokenMetadataField,\n  type TokenMetadataFieldArgs,\n} from '../types';\n\nexport const UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR = new Uint8Array([\n  221, 233, 49, 45, 181, 202, 220, 200,\n]);\n\nexport function getUpdateTokenMetadataFieldDiscriminatorBytes() {\n  return getBytesEncoder().encode(UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR);\n}\n\nexport type UpdateTokenMetadataFieldInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | AccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMetadata extends string\n        ? WritableAccount<TAccountMetadata>\n        : TAccountMetadata,\n      TAccountUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountUpdateAuthority> &\n            AccountSignerMeta<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateTokenMetadataFieldInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** Field to update in the metadata. */\n  field: TokenMetadataField;\n  /** Value to write for the field. */\n  value: string;\n};\n\nexport type UpdateTokenMetadataFieldInstructionDataArgs = {\n  /** Field to update in the metadata. */\n  field: TokenMetadataFieldArgs;\n  /** Value to write for the field. */\n  value: string;\n};\n\nexport function getUpdateTokenMetadataFieldInstructionDataEncoder(): Encoder<UpdateTokenMetadataFieldInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      ['field', getTokenMetadataFieldEncoder()],\n      ['value', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateTokenMetadataFieldInstructionDataDecoder(): Decoder<UpdateTokenMetadataFieldInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    ['field', getTokenMetadataFieldDecoder()],\n    ['value', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n  ]);\n}\n\nexport function getUpdateTokenMetadataFieldInstructionDataCodec(): Codec<\n  UpdateTokenMetadataFieldInstructionDataArgs,\n  UpdateTokenMetadataFieldInstructionData\n> {\n  return combineCodec(\n    getUpdateTokenMetadataFieldInstructionDataEncoder(),\n    getUpdateTokenMetadataFieldInstructionDataDecoder()\n  );\n}\n\nexport type UpdateTokenMetadataFieldInput<\n  TAccountMetadata extends string = string,\n  TAccountUpdateAuthority extends string = string,\n> = {\n  metadata: Address<TAccountMetadata>;\n  updateAuthority: TransactionSigner<TAccountUpdateAuthority>;\n  field: UpdateTokenMetadataFieldInstructionDataArgs['field'];\n  value: UpdateTokenMetadataFieldInstructionDataArgs['value'];\n};\n\nexport function getUpdateTokenMetadataFieldInstruction<\n  TAccountMetadata extends string,\n  TAccountUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateTokenMetadataFieldInput<\n    TAccountMetadata,\n    TAccountUpdateAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateTokenMetadataFieldInstruction<\n  TProgramAddress,\n  TAccountMetadata,\n  TAccountUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.updateAuthority),\n    ],\n    data: getUpdateTokenMetadataFieldInstructionDataEncoder().encode(\n      args as UpdateTokenMetadataFieldInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateTokenMetadataFieldInstruction<\n    TProgramAddress,\n    TAccountMetadata,\n    TAccountUpdateAuthority\n  >);\n}\n\nexport type ParsedUpdateTokenMetadataFieldInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    metadata: TAccountMetas[0];\n    updateAuthority: TAccountMetas[1];\n  };\n  data: UpdateTokenMetadataFieldInstructionData;\n};\n\nexport function parseUpdateTokenMetadataFieldInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateTokenMetadataFieldInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { metadata: getNextAccount(), updateAuthority: getNextAccount() },\n    data: getUpdateTokenMetadataFieldInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR =\n  new Uint8Array([215, 228, 166, 228, 84, 100, 86, 123]);\n\nexport function getUpdateTokenMetadataUpdateAuthorityDiscriminatorBytes() {\n  return getBytesEncoder().encode(\n    UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR\n  );\n}\n\nexport type UpdateTokenMetadataUpdateAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | AccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMetadata extends string\n        ? WritableAccount<TAccountMetadata>\n        : TAccountMetadata,\n      TAccountUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountUpdateAuthority> &\n            AccountSignerMeta<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateTokenMetadataUpdateAuthorityInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** New authority for the token metadata, or unset if `None` */\n  newUpdateAuthority: Option<Address>;\n};\n\nexport type UpdateTokenMetadataUpdateAuthorityInstructionDataArgs = {\n  /** New authority for the token metadata, or unset if `None` */\n  newUpdateAuthority: OptionOrNullable<Address>;\n};\n\nexport function getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder(): Encoder<UpdateTokenMetadataUpdateAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      [\n        'newUpdateAuthority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder(): Decoder<UpdateTokenMetadataUpdateAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    [\n      'newUpdateAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateTokenMetadataUpdateAuthorityInstructionDataCodec(): Codec<\n  UpdateTokenMetadataUpdateAuthorityInstructionDataArgs,\n  UpdateTokenMetadataUpdateAuthorityInstructionData\n> {\n  return combineCodec(\n    getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder(),\n    getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type UpdateTokenMetadataUpdateAuthorityInput<\n  TAccountMetadata extends string = string,\n  TAccountUpdateAuthority extends string = string,\n> = {\n  metadata: Address<TAccountMetadata>;\n  updateAuthority: TransactionSigner<TAccountUpdateAuthority>;\n  newUpdateAuthority: UpdateTokenMetadataUpdateAuthorityInstructionDataArgs['newUpdateAuthority'];\n};\n\nexport function getUpdateTokenMetadataUpdateAuthorityInstruction<\n  TAccountMetadata extends string,\n  TAccountUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateTokenMetadataUpdateAuthorityInput<\n    TAccountMetadata,\n    TAccountUpdateAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateTokenMetadataUpdateAuthorityInstruction<\n  TProgramAddress,\n  TAccountMetadata,\n  TAccountUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.updateAuthority),\n    ],\n    data: getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder().encode(\n      args as UpdateTokenMetadataUpdateAuthorityInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateTokenMetadataUpdateAuthorityInstruction<\n    TProgramAddress,\n    TAccountMetadata,\n    TAccountUpdateAuthority\n  >);\n}\n\nexport type ParsedUpdateTokenMetadataUpdateAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    metadata: TAccountMetas[0];\n    updateAuthority: TAccountMetas[1];\n  };\n  data: UpdateTokenMetadataUpdateAuthorityInstructionData;\n};\n\nexport function parseUpdateTokenMetadataUpdateAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateTokenMetadataUpdateAuthorityInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { metadata: getNextAccount(), updateAuthority: getNextAccount() },\n    data: getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_TRANSFER_HOOK_DISCRIMINATOR = 36;\n\nexport function getUpdateTransferHookDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_TRANSFER_HOOK_DISCRIMINATOR);\n}\n\nexport const UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR = 1;\n\nexport function getUpdateTransferHookTransferHookDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR\n  );\n}\n\nexport type UpdateTransferHookInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateTransferHookInstructionData = {\n  discriminator: number;\n  transferHookDiscriminator: number;\n  /** The program id that performs logic during transfers */\n  programId: Option<Address>;\n};\n\nexport type UpdateTransferHookInstructionDataArgs = {\n  /** The program id that performs logic during transfers */\n  programId: OptionOrNullable<Address>;\n};\n\nexport function getUpdateTransferHookInstructionDataEncoder(): FixedSizeEncoder<UpdateTransferHookInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferHookDiscriminator', getU8Encoder()],\n      [\n        'programId',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TRANSFER_HOOK_DISCRIMINATOR,\n      transferHookDiscriminator:\n        UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateTransferHookInstructionDataDecoder(): FixedSizeDecoder<UpdateTransferHookInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferHookDiscriminator', getU8Decoder()],\n    [\n      'programId',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateTransferHookInstructionDataCodec(): FixedSizeCodec<\n  UpdateTransferHookInstructionDataArgs,\n  UpdateTransferHookInstructionData\n> {\n  return combineCodec(\n    getUpdateTransferHookInstructionDataEncoder(),\n    getUpdateTransferHookInstructionDataDecoder()\n  );\n}\n\nexport type UpdateTransferHookInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The transfer hook authority. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  programId: UpdateTransferHookInstructionDataArgs['programId'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateTransferHookInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateTransferHookInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateTransferHookInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getUpdateTransferHookInstructionDataEncoder().encode(\n      args as UpdateTransferHookInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateTransferHookInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedUpdateTransferHookInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The transfer hook authority. */\n    authority: TAccountMetas[1];\n  };\n  data: UpdateTransferHookInstructionData;\n};\n\nexport function parseUpdateTransferHookInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateTransferHookInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), authority: getNextAccount() },\n    data: getUpdateTransferHookInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR = 38;\n\nexport function getWithdrawExcessLamportsDiscriminatorBytes() {\n  return getU8Encoder().encode(WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR);\n}\n\nexport type WithdrawExcessLamportsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSourceAccount extends string | AccountMeta<string> = string,\n  TAccountDestinationAccount extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSourceAccount extends string\n        ? WritableAccount<TAccountSourceAccount>\n        : TAccountSourceAccount,\n      TAccountDestinationAccount extends string\n        ? WritableAccount<TAccountDestinationAccount>\n        : TAccountDestinationAccount,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawExcessLamportsInstructionData = { discriminator: number };\n\nexport type WithdrawExcessLamportsInstructionDataArgs = {};\n\nexport function getWithdrawExcessLamportsInstructionDataEncoder(): FixedSizeEncoder<WithdrawExcessLamportsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawExcessLamportsInstructionDataDecoder(): FixedSizeDecoder<WithdrawExcessLamportsInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getWithdrawExcessLamportsInstructionDataCodec(): FixedSizeCodec<\n  WithdrawExcessLamportsInstructionDataArgs,\n  WithdrawExcessLamportsInstructionData\n> {\n  return combineCodec(\n    getWithdrawExcessLamportsInstructionDataEncoder(),\n    getWithdrawExcessLamportsInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawExcessLamportsInput<\n  TAccountSourceAccount extends string = string,\n  TAccountDestinationAccount extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** Account holding excess lamports. */\n  sourceAccount: Address<TAccountSourceAccount>;\n  /** Destination account for withdrawn lamports. */\n  destinationAccount: Address<TAccountDestinationAccount>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getWithdrawExcessLamportsInstruction<\n  TAccountSourceAccount extends string,\n  TAccountDestinationAccount extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: WithdrawExcessLamportsInput<\n    TAccountSourceAccount,\n    TAccountDestinationAccount,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawExcessLamportsInstruction<\n  TProgramAddress,\n  TAccountSourceAccount,\n  TAccountDestinationAccount,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    sourceAccount: { value: input.sourceAccount ?? null, isWritable: true },\n    destinationAccount: {\n      value: input.destinationAccount ?? null,\n      isWritable: true,\n    },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.sourceAccount),\n      getAccountMeta(accounts.destinationAccount),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getWithdrawExcessLamportsInstructionDataEncoder().encode({}),\n    programAddress,\n  } as WithdrawExcessLamportsInstruction<\n    TProgramAddress,\n    TAccountSourceAccount,\n    TAccountDestinationAccount,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedWithdrawExcessLamportsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Account holding excess lamports. */\n    sourceAccount: TAccountMetas[0];\n    /** Destination account for withdrawn lamports. */\n    destinationAccount: TAccountMetas[1];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: WithdrawExcessLamportsInstructionData;\n};\n\nexport function parseWithdrawExcessLamportsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedWithdrawExcessLamportsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      sourceAccount: getNextAccount(),\n      destinationAccount: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getWithdrawExcessLamportsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR = 26;\n\nexport function getWithdrawWithheldTokensFromAccountsDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR\n  );\n}\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR = 3;\n\nexport function getWithdrawWithheldTokensFromAccountsTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type WithdrawWithheldTokensFromAccountsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountFeeReceiver extends string | AccountMeta<string> = string,\n  TAccountWithdrawWithheldAuthority extends\n    | string\n    | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountFeeReceiver extends string\n        ? WritableAccount<TAccountFeeReceiver>\n        : TAccountFeeReceiver,\n      TAccountWithdrawWithheldAuthority extends string\n        ? ReadonlyAccount<TAccountWithdrawWithheldAuthority>\n        : TAccountWithdrawWithheldAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawWithheldTokensFromAccountsInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n  /** Number of token accounts harvested. */\n  numTokenAccounts: number;\n};\n\nexport type WithdrawWithheldTokensFromAccountsInstructionDataArgs = {\n  /** Number of token accounts harvested. */\n  numTokenAccounts: number;\n};\n\nexport function getWithdrawWithheldTokensFromAccountsInstructionDataEncoder(): FixedSizeEncoder<WithdrawWithheldTokensFromAccountsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n      ['numTokenAccounts', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR,\n      transferFeeDiscriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawWithheldTokensFromAccountsInstructionDataDecoder(): FixedSizeDecoder<WithdrawWithheldTokensFromAccountsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n    ['numTokenAccounts', getU8Decoder()],\n  ]);\n}\n\nexport function getWithdrawWithheldTokensFromAccountsInstructionDataCodec(): FixedSizeCodec<\n  WithdrawWithheldTokensFromAccountsInstructionDataArgs,\n  WithdrawWithheldTokensFromAccountsInstructionData\n> {\n  return combineCodec(\n    getWithdrawWithheldTokensFromAccountsInstructionDataEncoder(),\n    getWithdrawWithheldTokensFromAccountsInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawWithheldTokensFromAccountsInput<\n  TAccountMint extends string = string,\n  TAccountFeeReceiver extends string = string,\n  TAccountWithdrawWithheldAuthority extends string = string,\n> = {\n  /** The token mint. Must include the `TransferFeeConfig` extension. */\n  mint: Address<TAccountMint>;\n  /**\n   * The fee receiver account. Must include the `TransferFeeAmount`\n   * extension associated with the provided mint.\n   */\n  feeReceiver: Address<TAccountFeeReceiver>;\n  /** The mint's `withdraw_withheld_authority` or its multisignature account. */\n  withdrawWithheldAuthority:\n    | Address<TAccountWithdrawWithheldAuthority>\n    | TransactionSigner<TAccountWithdrawWithheldAuthority>;\n  numTokenAccounts: WithdrawWithheldTokensFromAccountsInstructionDataArgs['numTokenAccounts'];\n  multiSigners?: Array<TransactionSigner>;\n  sources: Array<Address>;\n};\n\nexport function getWithdrawWithheldTokensFromAccountsInstruction<\n  TAccountMint extends string,\n  TAccountFeeReceiver extends string,\n  TAccountWithdrawWithheldAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: WithdrawWithheldTokensFromAccountsInput<\n    TAccountMint,\n    TAccountFeeReceiver,\n    TAccountWithdrawWithheldAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawWithheldTokensFromAccountsInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountFeeReceiver,\n  (typeof input)['withdrawWithheldAuthority'] extends TransactionSigner<TAccountWithdrawWithheldAuthority>\n    ? ReadonlySignerAccount<TAccountWithdrawWithheldAuthority> &\n        AccountSignerMeta<TAccountWithdrawWithheldAuthority>\n    : TAccountWithdrawWithheldAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n    feeReceiver: { value: input.feeReceiver ?? null, isWritable: true },\n    withdrawWithheldAuthority: {\n      value: input.withdrawWithheldAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = [\n    ...(args.multiSigners ?? []).map((signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })),\n    ...args.sources.map((address) => ({ address, role: AccountRole.WRITABLE })),\n  ];\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.feeReceiver),\n      getAccountMeta(accounts.withdrawWithheldAuthority),\n      ...remainingAccounts,\n    ],\n    data: getWithdrawWithheldTokensFromAccountsInstructionDataEncoder().encode(\n      args as WithdrawWithheldTokensFromAccountsInstructionDataArgs\n    ),\n    programAddress,\n  } as WithdrawWithheldTokensFromAccountsInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountFeeReceiver,\n    (typeof input)['withdrawWithheldAuthority'] extends TransactionSigner<TAccountWithdrawWithheldAuthority>\n      ? ReadonlySignerAccount<TAccountWithdrawWithheldAuthority> &\n          AccountSignerMeta<TAccountWithdrawWithheldAuthority>\n      : TAccountWithdrawWithheldAuthority\n  >);\n}\n\nexport type ParsedWithdrawWithheldTokensFromAccountsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. Must include the `TransferFeeConfig` extension. */\n    mint: TAccountMetas[0];\n    /**\n     * The fee receiver account. Must include the `TransferFeeAmount`\n     * extension associated with the provided mint.\n     */\n    feeReceiver: TAccountMetas[1];\n    /** The mint's `withdraw_withheld_authority` or its multisignature account. */\n    withdrawWithheldAuthority: TAccountMetas[2];\n  };\n  data: WithdrawWithheldTokensFromAccountsInstructionData;\n};\n\nexport function parseWithdrawWithheldTokensFromAccountsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedWithdrawWithheldTokensFromAccountsInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      feeReceiver: getNextAccount(),\n      withdrawWithheldAuthority: getNextAccount(),\n    },\n    data: getWithdrawWithheldTokensFromAccountsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 2;\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TAccountInstructionsSysvarOrContextState extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountRecord extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountInstructionsSysvarOrContextState extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvarOrContextState>\n        : TAccountInstructionsSysvarOrContextState,\n      TAccountRecord extends string\n        ? ReadonlyAccount<TAccountRecord>\n        : TAccountRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionData =\n  {\n    discriminator: number;\n    confidentialTransferFeeDiscriminator: number;\n    /** Number of token accounts harvested */\n    numTokenAccounts: number;\n    /** Proof instruction offset */\n    proofInstructionOffset: number;\n    /** The new decryptable balance in the destination token account */\n    newDecryptableAvailableBalance: DecryptableBalance;\n  };\n\nexport type WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs =\n  {\n    /** Number of token accounts harvested */\n    numTokenAccounts: number;\n    /** Proof instruction offset */\n    proofInstructionOffset: number;\n    /** The new decryptable balance in the destination token account */\n    newDecryptableAvailableBalance: DecryptableBalanceArgs;\n  };\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder(): FixedSizeEncoder<WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n      ['numTokenAccounts', getU8Encoder()],\n      ['proofInstructionOffset', getI8Encoder()],\n      ['newDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder(): FixedSizeDecoder<WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n    ['numTokenAccounts', getU8Decoder()],\n    ['proofInstructionOffset', getI8Decoder()],\n    ['newDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n  ]);\n}\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataCodec(): FixedSizeCodec<\n  WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs,\n  WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionData\n> {\n  return combineCodec(\n    getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder(),\n    getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInput<\n  TAccountMint extends string = string,\n  TAccountDestination extends string = string,\n  TAccountInstructionsSysvarOrContextState extends string = string,\n  TAccountRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The fee receiver account. */\n  destination: Address<TAccountDestination>;\n  /** Instructions sysvar or context state account */\n  instructionsSysvarOrContextState: Address<TAccountInstructionsSysvarOrContextState>;\n  /** Optional record account */\n  record?: Address<TAccountRecord>;\n  /** The mint's withdraw_withheld_authority */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  numTokenAccounts: WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs['numTokenAccounts'];\n  proofInstructionOffset: WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs['proofInstructionOffset'];\n  newDecryptableAvailableBalance: WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs['newDecryptableAvailableBalance'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TAccountMint extends string,\n  TAccountDestination extends string,\n  TAccountInstructionsSysvarOrContextState extends string,\n  TAccountRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInput<\n    TAccountMint,\n    TAccountDestination,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountDestination,\n  TAccountInstructionsSysvarOrContextState,\n  TAccountRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n    instructionsSysvarOrContextState: {\n      value: input.instructionsSysvarOrContextState ?? null,\n      isWritable: false,\n    },\n    record: { value: input.record ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.instructionsSysvarOrContextState),\n      getAccountMeta(accounts.record),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder().encode(\n      args as WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs\n    ),\n    programAddress,\n  } as WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountDestination,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. */\n    mint: TAccountMetas[0];\n    /** The fee receiver account. */\n    destination: TAccountMetas[1];\n    /** Instructions sysvar or context state account */\n    instructionsSysvarOrContextState: TAccountMetas[2];\n    /** Optional record account */\n    record?: TAccountMetas[3] | undefined;\n    /** The mint's withdraw_withheld_authority */\n    authority: TAccountMetas[4];\n  };\n  data: WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionData;\n};\n\nexport function parseWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      instructionsSysvarOrContextState: getNextAccount(),\n      record: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR = 26;\n\nexport function getWithdrawWithheldTokensFromMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR\n  );\n}\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR = 2;\n\nexport function getWithdrawWithheldTokensFromMintTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type WithdrawWithheldTokensFromMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountFeeReceiver extends string | AccountMeta<string> = string,\n  TAccountWithdrawWithheldAuthority extends\n    | string\n    | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountFeeReceiver extends string\n        ? WritableAccount<TAccountFeeReceiver>\n        : TAccountFeeReceiver,\n      TAccountWithdrawWithheldAuthority extends string\n        ? ReadonlyAccount<TAccountWithdrawWithheldAuthority>\n        : TAccountWithdrawWithheldAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawWithheldTokensFromMintInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n};\n\nexport type WithdrawWithheldTokensFromMintInstructionDataArgs = {};\n\nexport function getWithdrawWithheldTokensFromMintInstructionDataEncoder(): FixedSizeEncoder<WithdrawWithheldTokensFromMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR,\n      transferFeeDiscriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawWithheldTokensFromMintInstructionDataDecoder(): FixedSizeDecoder<WithdrawWithheldTokensFromMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getWithdrawWithheldTokensFromMintInstructionDataCodec(): FixedSizeCodec<\n  WithdrawWithheldTokensFromMintInstructionDataArgs,\n  WithdrawWithheldTokensFromMintInstructionData\n> {\n  return combineCodec(\n    getWithdrawWithheldTokensFromMintInstructionDataEncoder(),\n    getWithdrawWithheldTokensFromMintInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawWithheldTokensFromMintInput<\n  TAccountMint extends string = string,\n  TAccountFeeReceiver extends string = string,\n  TAccountWithdrawWithheldAuthority extends string = string,\n> = {\n  /** The token mint. Must include the `TransferFeeConfig` extension. */\n  mint: Address<TAccountMint>;\n  /**\n   * The fee receiver account. Must include the `TransferFeeAmount`\n   * extension associated with the provided mint.\n   */\n  feeReceiver: Address<TAccountFeeReceiver>;\n  /** The mint's `withdraw_withheld_authority` or its multisignature account. */\n  withdrawWithheldAuthority:\n    | Address<TAccountWithdrawWithheldAuthority>\n    | TransactionSigner<TAccountWithdrawWithheldAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getWithdrawWithheldTokensFromMintInstruction<\n  TAccountMint extends string,\n  TAccountFeeReceiver extends string,\n  TAccountWithdrawWithheldAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: WithdrawWithheldTokensFromMintInput<\n    TAccountMint,\n    TAccountFeeReceiver,\n    TAccountWithdrawWithheldAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawWithheldTokensFromMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountFeeReceiver,\n  (typeof input)['withdrawWithheldAuthority'] extends TransactionSigner<TAccountWithdrawWithheldAuthority>\n    ? ReadonlySignerAccount<TAccountWithdrawWithheldAuthority> &\n        AccountSignerMeta<TAccountWithdrawWithheldAuthority>\n    : TAccountWithdrawWithheldAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    feeReceiver: { value: input.feeReceiver ?? null, isWritable: true },\n    withdrawWithheldAuthority: {\n      value: input.withdrawWithheldAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.feeReceiver),\n      getAccountMeta(accounts.withdrawWithheldAuthority),\n      ...remainingAccounts,\n    ],\n    data: getWithdrawWithheldTokensFromMintInstructionDataEncoder().encode({}),\n    programAddress,\n  } as WithdrawWithheldTokensFromMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountFeeReceiver,\n    (typeof input)['withdrawWithheldAuthority'] extends TransactionSigner<TAccountWithdrawWithheldAuthority>\n      ? ReadonlySignerAccount<TAccountWithdrawWithheldAuthority> &\n          AccountSignerMeta<TAccountWithdrawWithheldAuthority>\n      : TAccountWithdrawWithheldAuthority\n  >);\n}\n\nexport type ParsedWithdrawWithheldTokensFromMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. Must include the `TransferFeeConfig` extension. */\n    mint: TAccountMetas[0];\n    /**\n     * The fee receiver account. Must include the `TransferFeeAmount`\n     * extension associated with the provided mint.\n     */\n    feeReceiver: TAccountMetas[1];\n    /** The mint's `withdraw_withheld_authority` or its multisignature account. */\n    withdrawWithheldAuthority: TAccountMetas[2];\n  };\n  data: WithdrawWithheldTokensFromMintInstructionData;\n};\n\nexport function parseWithdrawWithheldTokensFromMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedWithdrawWithheldTokensFromMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      feeReceiver: getNextAccount(),\n      withdrawWithheldAuthority: getNextAccount(),\n    },\n    data: getWithdrawWithheldTokensFromMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 1;\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TAccountInstructionsSysvarOrContextState extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountRecord extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountInstructionsSysvarOrContextState extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvarOrContextState>\n        : TAccountInstructionsSysvarOrContextState,\n      TAccountRecord extends string\n        ? ReadonlyAccount<TAccountRecord>\n        : TAccountRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionData =\n  {\n    discriminator: number;\n    confidentialTransferFeeDiscriminator: number;\n    /** Proof instruction offset */\n    proofInstructionOffset: number;\n    /** The new decryptable balance in the destination token account */\n    newDecryptableAvailableBalance: DecryptableBalance;\n  };\n\nexport type WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs =\n  {\n    /** Proof instruction offset */\n    proofInstructionOffset: number;\n    /** The new decryptable balance in the destination token account */\n    newDecryptableAvailableBalance: DecryptableBalanceArgs;\n  };\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder(): FixedSizeEncoder<WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n      ['proofInstructionOffset', getI8Encoder()],\n      ['newDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder(): FixedSizeDecoder<WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n    ['proofInstructionOffset', getI8Decoder()],\n    ['newDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n  ]);\n}\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataCodec(): FixedSizeCodec<\n  WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs,\n  WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionData\n> {\n  return combineCodec(\n    getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder(),\n    getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawWithheldTokensFromMintForConfidentialTransferFeeInput<\n  TAccountMint extends string = string,\n  TAccountDestination extends string = string,\n  TAccountInstructionsSysvarOrContextState extends string = string,\n  TAccountRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The fee receiver account. */\n  destination: Address<TAccountDestination>;\n  /** Instructions sysvar or context state account */\n  instructionsSysvarOrContextState: Address<TAccountInstructionsSysvarOrContextState>;\n  /** Optional record account if proof is read from record */\n  record?: Address<TAccountRecord>;\n  /** The mint's withdraw_withheld_authority */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  proofInstructionOffset: WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs['proofInstructionOffset'];\n  newDecryptableAvailableBalance: WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs['newDecryptableAvailableBalance'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TAccountMint extends string,\n  TAccountDestination extends string,\n  TAccountInstructionsSysvarOrContextState extends string,\n  TAccountRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: WithdrawWithheldTokensFromMintForConfidentialTransferFeeInput<\n    TAccountMint,\n    TAccountDestination,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountDestination,\n  TAccountInstructionsSysvarOrContextState,\n  TAccountRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n    instructionsSysvarOrContextState: {\n      value: input.instructionsSysvarOrContextState ?? null,\n      isWritable: false,\n    },\n    record: { value: input.record ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.instructionsSysvarOrContextState),\n      getAccountMeta(accounts.record),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder().encode(\n      args as WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs\n    ),\n    programAddress,\n  } as WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountDestination,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. */\n    mint: TAccountMetas[0];\n    /** The fee receiver account. */\n    destination: TAccountMetas[1];\n    /** Instructions sysvar or context state account */\n    instructionsSysvarOrContextState: TAccountMetas[2];\n    /** Optional record account if proof is read from record */\n    record?: TAccountMetas[3] | undefined;\n    /** The mint's withdraw_withheld_authority */\n    authority: TAccountMetas[4];\n  };\n  data: WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionData;\n};\n\nexport function parseWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      instructionsSysvarOrContextState: getNextAccount(),\n      record: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","import {\n  type GetAccountInfoApi,\n  type Rpc,\n  Address,\n  UnixTimestamp,\n  unwrapOption,\n} from '@solana/kit';\nimport { fetchSysvarClock } from '@solana/sysvars';\nimport { fetchMint } from './generated';\n\n// Constants\nconst ONE_IN_BASIS_POINTS = 10000;\nconst SECONDS_PER_YEAR = 60 * 60 * 24 * 365.24;\n\n/**\n * Calculates the exponent for the interest rate formula.\n * @param t1 - The start time in seconds.\n * @param t2 - The end time in seconds.\n * @param r  - The interest rate in basis points.\n *\n * @returns The calculated exponent.\n */\nfunction calculateExponentForTimesAndRate(t1: number, t2: number, r: number) {\n  const timespan = t2 - t1;\n  if (timespan < 0) {\n    throw new Error('Invalid timespan: end time before start time');\n  }\n\n  const numerator = r * timespan;\n  const exponent = numerator / (SECONDS_PER_YEAR * ONE_IN_BASIS_POINTS);\n  return Math.exp(exponent);\n}\n\n/**\n * Calculates the total scale factor for an interest bearing token by combining two exponential functions:\n * One for the period between initialization and last update using the pre-update average rate,\n * and another for the period between last update and current time using the current rate.\n *\n * @param currentTimestamp         Current timestamp in seconds\n * @param lastUpdateTimestamp      Last time the interest rate was updated in seconds\n * @param initializationTimestamp  Time the interest bearing extension was initialized in seconds\n * @param preUpdateAverageRate     Interest rate in basis points before last update\n * @param currentRate              Current interest rate in basis points\n *\n * @returns The total scale factor as a product of the two exponential functions\n */\nfunction calculateTotalScale({\n  currentTimestamp,\n  lastUpdateTimestamp,\n  initializationTimestamp,\n  preUpdateAverageRate,\n  currentRate,\n}: {\n  currentTimestamp: number;\n  lastUpdateTimestamp: number;\n  initializationTimestamp: number;\n  preUpdateAverageRate: number;\n  currentRate: number;\n}): number {\n  // Calculate pre-update exponent\n  const preUpdateExp = calculateExponentForTimesAndRate(\n    initializationTimestamp,\n    lastUpdateTimestamp,\n    preUpdateAverageRate\n  );\n\n  // Calculate post-update exponent\n  const postUpdateExp = calculateExponentForTimesAndRate(\n    lastUpdateTimestamp,\n    currentTimestamp,\n    currentRate\n  );\n\n  return preUpdateExp * postUpdateExp;\n}\n\n/**\n * Calculates the decimal factor for a given number of decimals\n * @param decimals - Number of decimals\n * @returns The decimal factor (e.g., 100 for 2 decimals)\n */\nfunction getDecimalFactor(decimals: number): number {\n  return Math.pow(10, decimals);\n}\n\n/**\n * Retrieves the current timestamp from the Solana clock sysvar.\n * @param rpc - The Solana rpc object.\n * @returns A promise that resolves to the current timestamp in seconds.\n * @throws An error if the sysvar clock cannot be fetched or parsed.\n */\nasync function getSysvarClockTimestamp(\n  rpc: Rpc<GetAccountInfoApi>\n): Promise<UnixTimestamp> {\n  const info = await fetchSysvarClock(rpc);\n  if (!info) {\n    throw new Error('Failed to fetch sysvar clock');\n  }\n  return info.unixTimestamp;\n}\n\n// ========== INTEREST BEARING MINT FUNCTIONS ==========\n\n/**\n * Convert amount to UiAmount for a mint with interest bearing extension without simulating a transaction\n * This implements the same logic as the CPI instruction available in /token/program-2022/src/extension/interest_bearing_mint/mod.rs\n * In general to calculate compounding interest over a period of time, the formula is:\n * A = P * e^(r * t) where\n * A = final amount after interest\n * P = principal amount (initial investment)\n * r = annual interest rate (as a decimal, e.g., 5% = 0.05)\n * t = time in years\n * e = mathematical constant (~2.718)\n *\n * In this case, we are calculating the total scale factor for the interest bearing extension which is the product of two exponential functions:\n * totalScale = e^(r1 * t1) * e^(r2 * t2)\n * where r1 and r2 are the interest rates before and after the last update, and t1 and t2 are the times in years between\n * the initialization timestamp and the last update timestamp, and between the last update timestamp and the current timestamp.\n *\n * @param amount                   Amount of tokens to be converted\n * @param decimals                 Number of decimals of the mint\n * @param currentTimestamp         Current timestamp in seconds\n * @param lastUpdateTimestamp      Last time the interest rate was updated in seconds\n * @param initializationTimestamp  Time the interest bearing extension was initialized in seconds\n * @param preUpdateAverageRate     Interest rate in basis points (1 basis point = 0.01%) before last update\n * @param currentRate              Current interest rate in basis points\n *\n * @return Amount scaled by accrued interest as a string with appropriate decimal places\n */\nexport function amountToUiAmountForInterestBearingMintWithoutSimulation(\n  amount: bigint,\n  decimals: number,\n  currentTimestamp: number,\n  lastUpdateTimestamp: number,\n  initializationTimestamp: number,\n  preUpdateAverageRate: number,\n  currentRate: number\n): string {\n  const totalScale = calculateTotalScale({\n    currentTimestamp,\n    lastUpdateTimestamp,\n    initializationTimestamp,\n    preUpdateAverageRate,\n    currentRate,\n  });\n\n  // Scale the amount by the total interest factor\n  const scaledAmount = Number(amount) * totalScale;\n  const decimalFactor = getDecimalFactor(decimals);\n\n  return (Math.trunc(scaledAmount) / decimalFactor).toString();\n}\n\n/**\n * Convert an amount with interest back to the original amount without interest\n * This implements the same logic as the CPI instruction available in /token/program-2022/src/extension/interest_bearing_mint/mod.rs\n *\n * @param uiAmount                  UI Amount (principal plus continuously compounding interest) to be converted back to original principal\n * @param decimals                  Number of decimals for the mint\n * @param currentTimestamp          Current timestamp in seconds\n * @param lastUpdateTimestamp       Last time the interest rate was updated in seconds\n * @param initializationTimestamp   Time the interest bearing extension was initialized in seconds\n * @param preUpdateAverageRate      Interest rate in basis points (hundredths of a percent) before the last update\n * @param currentRate              Current interest rate in basis points\n *\n * In general to calculate the principal from the UI amount, the formula is:\n * P = A / (e^(r * t)) where\n * P = principal\n * A = UI amount\n * r = annual interest rate (as a decimal, e.g., 5% = 0.05)\n * t = time in years\n *\n * In this case, we are calculating the principal by dividing the UI amount by the total scale factor which is the product of two exponential functions:\n * totalScale = e^(r1 * t1) * e^(r2 * t2)\n * where r1 is the pre-update average rate, r2 is the current rate, t1 is the time in years between the initialization timestamp and the last update timestamp,\n * and t2 is the time in years between the last update timestamp and the current timestamp.\n * then to calculate the principal, we divide the UI amount by the total scale factor:\n * P = A / totalScale\n *\n * @return Original amount (principal) without interest\n */\nexport function uiAmountToAmountForInterestBearingMintWithoutSimulation(\n  uiAmount: string,\n  decimals: number,\n  currentTimestamp: number,\n  lastUpdateTimestamp: number,\n  initializationTimestamp: number,\n  preUpdateAverageRate: number,\n  currentRate: number\n): bigint {\n  const uiAmountNumber = parseFloat(uiAmount);\n  const decimalsFactor = getDecimalFactor(decimals);\n  const uiAmountScaled = uiAmountNumber * decimalsFactor;\n\n  const totalScale = calculateTotalScale({\n    currentTimestamp,\n    lastUpdateTimestamp,\n    initializationTimestamp,\n    preUpdateAverageRate,\n    currentRate,\n  });\n\n  // Calculate original principal by dividing the UI amount by the total scale\n  const originalPrincipal = uiAmountScaled / totalScale;\n  return BigInt(Math.trunc(originalPrincipal));\n}\n\n// ========== SCALED UI AMOUNT MINT FUNCTIONS ==========\n\n/**\n * Convert amount to UiAmount for a mint with scaled UI amount extension\n * @param amount     Amount of tokens to be converted\n * @param decimals   Number of decimals of the mint\n * @param multiplier Multiplier to scale the amount\n * @return Scaled UI amount as a string\n */\nexport function amountToUiAmountForScaledUiAmountMintWithoutSimulation(\n  amount: bigint,\n  decimals: number,\n  multiplier: number\n): string {\n  const scaledAmount = Number(amount) * multiplier;\n  const decimalFactor = getDecimalFactor(decimals);\n  return (Math.trunc(scaledAmount) / decimalFactor).toString();\n}\n\n/**\n * Convert a UI amount back to the raw amount for a mint with a scaled UI amount extension\n * @param uiAmount       UI Amount to be converted back to raw amount\n * @param decimals       Number of decimals for the mint\n * @param multiplier     Multiplier for the scaled UI amount\n *\n * @return Raw amount\n */\nexport function uiAmountToAmountForScaledUiAmountMintWithoutSimulation(\n  uiAmount: string,\n  decimals: number,\n  multiplier: number\n): bigint {\n  const uiAmountNumber = parseFloat(uiAmount);\n  const decimalsFactor = getDecimalFactor(decimals);\n  const uiAmountScaled = uiAmountNumber * decimalsFactor;\n  const rawAmount = uiAmountScaled / multiplier;\n  return BigInt(Math.trunc(rawAmount));\n}\n\n// ========== MAIN ENTRY POINT FUNCTIONS ==========\n\n/**\n * Convert amount to UiAmount for a mint without simulating a transaction\n * This implements the same logic as `process_amount_to_ui_amount` in\n * solana-labs/solana-program-library/token/program-2022/src/processor.rs\n * and `process_amount_to_ui_amount` in solana-labs/solana-program-library/token/program/src/processor.rs\n *\n * @param rpc     Rpc to use\n * @param mint    Mint to use for calculations\n * @param amount  Amount of tokens to be converted to Ui Amount\n *\n * @return Ui Amount generated\n */\nexport async function amountToUiAmountForMintWithoutSimulation(\n  rpc: Rpc<GetAccountInfoApi>,\n  mint: Address,\n  amount: bigint\n): Promise<string> {\n  const accountInfo = await fetchMint(rpc, mint);\n  const extensions = unwrapOption(accountInfo.data.extensions);\n\n  // Check for interest bearing mint extension\n  const interestBearingMintConfigState = extensions?.find(\n    (ext) => ext.__kind === 'InterestBearingConfig'\n  );\n\n  // Check for scaled UI amount extension\n  const scaledUiAmountConfig = extensions?.find(\n    (ext) => ext.__kind === 'ScaledUiAmountConfig'\n  );\n\n  // If no special extension, do standard conversion\n  if (!interestBearingMintConfigState && !scaledUiAmountConfig) {\n    const amountNumber = Number(amount);\n    const decimalsFactor = getDecimalFactor(accountInfo.data.decimals);\n    return (amountNumber / decimalsFactor).toString();\n  }\n\n  // Get timestamp if needed for special mint types\n  const timestamp = await getSysvarClockTimestamp(rpc);\n\n  // Handle interest bearing mint\n  if (interestBearingMintConfigState) {\n    return amountToUiAmountForInterestBearingMintWithoutSimulation(\n      amount,\n      accountInfo.data.decimals,\n      Number(timestamp),\n      Number(interestBearingMintConfigState.lastUpdateTimestamp),\n      Number(interestBearingMintConfigState.initializationTimestamp),\n      interestBearingMintConfigState.preUpdateAverageRate,\n      interestBearingMintConfigState.currentRate\n    );\n  }\n\n  // At this point, we know it must be a scaled UI amount mint\n  if (scaledUiAmountConfig) {\n    let multiplier = scaledUiAmountConfig.multiplier;\n    // Use new multiplier if it's effective\n    if (timestamp >= scaledUiAmountConfig.newMultiplierEffectiveTimestamp) {\n      multiplier = scaledUiAmountConfig.newMultiplier;\n    }\n    return amountToUiAmountForScaledUiAmountMintWithoutSimulation(\n      amount,\n      accountInfo.data.decimals,\n      multiplier\n    );\n  }\n\n  // This should never happen due to the conditions above\n  throw new Error('Unknown mint extension type');\n}\n\n/**\n * Convert a UI amount back to the raw amount\n *\n * @param rpc      Rpc to use\n * @param mint     Mint to use for calculations\n * @param uiAmount UI Amount to be converted back to raw amount\n *\n * @return Raw amount\n */\nexport async function uiAmountToAmountForMintWithoutSimulation(\n  rpc: Rpc<GetAccountInfoApi>,\n  mint: Address,\n  uiAmount: string\n): Promise<bigint> {\n  const accountInfo = await fetchMint(rpc, mint);\n  const extensions = unwrapOption(accountInfo.data.extensions);\n\n  // Check for interest bearing mint extension\n  const interestBearingMintConfigState = extensions?.find(\n    (ext) => ext.__kind === 'InterestBearingConfig'\n  );\n\n  // Check for scaled UI amount extension\n  const scaledUiAmountConfig = extensions?.find(\n    (ext) => ext.__kind === 'ScaledUiAmountConfig'\n  );\n\n  // If no special extension, do standard conversion\n  if (!interestBearingMintConfigState && !scaledUiAmountConfig) {\n    const uiAmountScaled =\n      parseFloat(uiAmount) * getDecimalFactor(accountInfo.data.decimals);\n    return BigInt(Math.trunc(uiAmountScaled));\n  }\n\n  // Get timestamp if needed for special mint types\n  const timestamp = await getSysvarClockTimestamp(rpc);\n\n  // Handle interest bearing mint\n  if (interestBearingMintConfigState) {\n    return uiAmountToAmountForInterestBearingMintWithoutSimulation(\n      uiAmount,\n      accountInfo.data.decimals,\n      Number(timestamp),\n      Number(interestBearingMintConfigState.lastUpdateTimestamp),\n      Number(interestBearingMintConfigState.initializationTimestamp),\n      interestBearingMintConfigState.preUpdateAverageRate,\n      interestBearingMintConfigState.currentRate\n    );\n  }\n\n  // At this point, we know it must be a scaled UI amount mint\n  if (scaledUiAmountConfig) {\n    let multiplier = scaledUiAmountConfig.multiplier;\n    // Use new multiplier if it's effective\n    if (timestamp >= scaledUiAmountConfig.newMultiplierEffectiveTimestamp) {\n      multiplier = scaledUiAmountConfig.newMultiplier;\n    }\n    return uiAmountToAmountForScaledUiAmountMintWithoutSimulation(\n      uiAmount,\n      accountInfo.data.decimals,\n      multiplier\n    );\n  }\n\n  // This should never happen due to the conditions above\n  throw new Error('Unknown mint extension type');\n}\n","import {\n  Address,\n  Instruction,\n  isNone,\n  isOption,\n  TransactionSigner,\n  wrapNullable,\n} from '@solana/kit';\nimport {\n  ExtensionArgs,\n  getDisableMemoTransfersInstruction,\n  getEnableMemoTransfersInstruction,\n  getEnableCpiGuardInstruction,\n  getDisableCpiGuardInstruction,\n  getInitializeConfidentialTransferMintInstruction,\n  getInitializeDefaultAccountStateInstruction,\n  getInitializeGroupMemberPointerInstruction,\n  getInitializeGroupPointerInstruction,\n  getInitializeInterestBearingMintInstruction,\n  getInitializeMetadataPointerInstruction,\n  getInitializeMintCloseAuthorityInstruction,\n  getInitializeTokenGroupInstruction,\n  getInitializeTokenMetadataInstruction,\n  getInitializeTransferFeeConfigInstruction,\n  getInitializeNonTransferableMintInstruction,\n  getInitializeTransferHookInstruction,\n  getInitializePermanentDelegateInstruction,\n  getInitializeScaledUiAmountMintInstruction,\n  getInitializeConfidentialTransferFeeInstruction,\n  getInitializePausableConfigInstruction,\n} from './generated';\n\n/**\n * Given a mint address and a list of mint extensions, returns a list of\n * instructions that MUST be run _before_ the `initializeMint` instruction\n * to properly initialize the given extensions on the mint account.\n */\nexport function getPreInitializeInstructionsForMintExtensions(\n  mint: Address,\n  extensions: ExtensionArgs[]\n): Instruction[] {\n  return extensions.flatMap((extension) => {\n    switch (extension.__kind) {\n      case 'ConfidentialTransferMint':\n        return [\n          getInitializeConfidentialTransferMintInstruction({\n            mint,\n            ...extension,\n          }),\n        ];\n      case 'DefaultAccountState':\n        return [\n          getInitializeDefaultAccountStateInstruction({\n            mint,\n            state: extension.state,\n          }),\n        ];\n      case 'TransferFeeConfig':\n        return [\n          getInitializeTransferFeeConfigInstruction({\n            mint,\n            transferFeeConfigAuthority: extension.transferFeeConfigAuthority,\n            withdrawWithheldAuthority: extension.withdrawWithheldAuthority,\n            transferFeeBasisPoints:\n              extension.newerTransferFee.transferFeeBasisPoints,\n            maximumFee: extension.newerTransferFee.maximumFee,\n          }),\n        ];\n      case 'MetadataPointer':\n        return [\n          getInitializeMetadataPointerInstruction({\n            mint,\n            authority: extension.authority,\n            metadataAddress: extension.metadataAddress,\n          }),\n        ];\n      case 'InterestBearingConfig':\n        return [\n          getInitializeInterestBearingMintInstruction({\n            mint,\n            rateAuthority: extension.rateAuthority,\n            rate: extension.currentRate,\n          }),\n        ];\n      case 'ScaledUiAmountConfig':\n        return [\n          getInitializeScaledUiAmountMintInstruction({\n            mint,\n            authority: extension.authority,\n            multiplier: extension.multiplier,\n          }),\n        ];\n      case 'PausableConfig':\n        return [\n          getInitializePausableConfigInstruction({\n            mint,\n            authority: extension.authority,\n          }),\n        ];\n      case 'GroupPointer':\n        return [\n          getInitializeGroupPointerInstruction({\n            mint,\n            authority: extension.authority,\n            groupAddress: extension.groupAddress,\n          }),\n        ];\n      case 'GroupMemberPointer':\n        return [\n          getInitializeGroupMemberPointerInstruction({\n            mint,\n            authority: extension.authority,\n            memberAddress: extension.memberAddress,\n          }),\n        ];\n      case 'NonTransferable':\n        return getInitializeNonTransferableMintInstruction({ mint });\n      case 'TransferHook':\n        return [\n          getInitializeTransferHookInstruction({\n            mint,\n            authority: extension.authority,\n            programId: extension.programId,\n          }),\n        ];\n      case 'PermanentDelegate':\n        return getInitializePermanentDelegateInstruction({\n          mint,\n          delegate: extension.delegate,\n        });\n      case 'ConfidentialTransferFee':\n        return [\n          getInitializeConfidentialTransferFeeInstruction({\n            mint,\n            authority: extension.authority,\n            withdrawWithheldAuthorityElGamalPubkey: extension.elgamalPubkey,\n          }),\n        ];\n      case 'MintCloseAuthority':\n        return getInitializeMintCloseAuthorityInstruction({\n          closeAuthority: extension.closeAuthority,\n          mint,\n        });\n      default:\n        return [];\n    }\n  });\n}\n\n/**\n * Given a mint address and a list of mint extensions, returns a list of\n * instructions that MUST be run _after_ the `initializeMint` instruction\n * to properly initialize the given extensions on the mint account.\n */\nexport function getPostInitializeInstructionsForMintExtensions(\n  mint: Address,\n  authority: TransactionSigner,\n  extensions: ExtensionArgs[]\n): Instruction[] {\n  return extensions.flatMap((extension): Instruction[] => {\n    switch (extension.__kind) {\n      case 'TokenMetadata':\n        // eslint-disable-next-line no-case-declarations\n        const tokenMetadataUpdateAuthority = isOption(extension.updateAuthority)\n          ? extension.updateAuthority\n          : wrapNullable(extension.updateAuthority);\n        if (isNone(tokenMetadataUpdateAuthority)) {\n          return [];\n        }\n        return [\n          getInitializeTokenMetadataInstruction({\n            metadata: mint,\n            updateAuthority: tokenMetadataUpdateAuthority.value,\n            mint,\n            mintAuthority: authority,\n            name: extension.name,\n            symbol: extension.symbol,\n            uri: extension.uri,\n          }),\n        ];\n      case 'TokenGroup':\n        return [\n          getInitializeTokenGroupInstruction({\n            group: mint,\n            updateAuthority: isOption(extension.updateAuthority)\n              ? extension.updateAuthority\n              : wrapNullable(extension.updateAuthority),\n            mint,\n            mintAuthority: authority,\n            maxSize: extension.maxSize,\n          }),\n        ];\n      default:\n        return [];\n    }\n  });\n}\n\n/**\n * Given a token address, its owner and a list of token extensions, returns a list\n * of instructions that MUST be run _after_ the `initializeAccount` instruction\n * to properly initialize the given extensions on the token account.\n */\nexport function getPostInitializeInstructionsForTokenExtensions(\n  token: Address,\n  owner: TransactionSigner | Address,\n  extensions: ExtensionArgs[],\n  multiSigners?: TransactionSigner[]\n): Instruction[] {\n  return extensions.flatMap((extension) => {\n    switch (extension.__kind) {\n      case 'MemoTransfer':\n        return [\n          extension.requireIncomingTransferMemos\n            ? getEnableMemoTransfersInstruction({ owner, token, multiSigners })\n            : getDisableMemoTransfersInstruction({\n                owner,\n                token,\n                multiSigners,\n              }),\n        ];\n      case 'CpiGuard':\n        return [\n          extension.lockCpi\n            ? getEnableCpiGuardInstruction({ owner, token, multiSigners })\n            : getDisableCpiGuardInstruction({\n                owner,\n                token,\n                multiSigners,\n              }),\n        ];\n      default:\n        return [];\n    }\n  });\n}\n","import {\n  getArrayEncoder,\n  getConstantEncoder,\n  getHiddenPrefixEncoder,\n  getU8Encoder,\n} from '@solana/kit';\nimport { ExtensionArgs, getExtensionEncoder } from './generated';\n\nconst TOKEN_BASE_SIZE = 165;\n\nexport function getTokenSize(extensions?: ExtensionArgs[]): number {\n  if (extensions == null) return TOKEN_BASE_SIZE;\n  const tvlEncoder = getHiddenPrefixEncoder(\n    getArrayEncoder(getExtensionEncoder(), { size: 'remainder' }),\n    [getConstantEncoder(getU8Encoder().encode(2))]\n  );\n  return TOKEN_BASE_SIZE + tvlEncoder.encode(extensions).length;\n}\n","import {\n  getArrayEncoder,\n  getConstantEncoder,\n  getHiddenPrefixEncoder,\n  getU8Encoder,\n  padLeftEncoder,\n} from '@solana/kit';\nimport { ExtensionArgs, getExtensionEncoder } from './generated';\n\nconst MINT_BASE_SIZE = 82;\n\nexport function getMintSize(extensions?: ExtensionArgs[]): number {\n  if (extensions == null) return MINT_BASE_SIZE;\n  const tvlEncoder = getHiddenPrefixEncoder(\n    getArrayEncoder(getExtensionEncoder(), { size: 'remainder' }),\n    [getConstantEncoder(padLeftEncoder(getU8Encoder(), 83).encode(1))]\n  );\n  return MINT_BASE_SIZE + tvlEncoder.encode(extensions).length;\n}\n"],"names":["AccountState","node","value","BaseChunkLogger","level","MAX_LOG_SIZE_IN_BYTES","MAX_LOG_SIZE_IN_BYTES_DEFAULT","__publicField","levels","LinkedList","chunk","safeJsonStringify","extraMetadata","logArray","s","IEngine","client","ENGINE_CONTEXT","EventEmmiter","ENGINE_QUEUE_STATES","LimitedSet","ONE_SECOND","ENGINE_RPC_OPTS","toMiliseconds","params","connectParams","__spreadProps","__spreadValues","mergeRequiredAndOptionalNamespaces","pairingTopic","requiredNamespaces","optionalNamespaces","sessionProperties","scopedProperties","relays","topic","uri","active","pairing","error","newTopic","newUri","message","getInternalError","publicKey","expiry","FIVE_MINUTES","expiryTimestamp","calcExpiry","proposal","RELAYER_DEFAULT_PROTOCOL","payloadId","sessionConnectTarget","engineEvent","reject","resolve","approval","createDelayedPromise","PROPOSAL_EXPIRY_MESSAGE","proposalExpireHandler","id","session","_a","_b","_c","configEvent","EVENT_CLIENT_SESSION_TRACES","EVENT_CLIENT_SESSION_ERRORS","relayProtocol","namespaces","sessionConfig","proposer","event","selfPublicKey","peerPublicKey","sessionTopic","sessionSettle","SESSION_EXPIRY","transportType","TRANSPORT_TYPES","getSdkError","reason","acknowledged","clientRpcId","relayRpcId","getBigIntRpcId","oldNamespaces","e","chainId","request","done","result","protocolMethod","appLink","protocolRequestParams","wcDeepLink","getDeepLink","WALLETCONNECT_DEEPLINK_CHOICE","handleDeeplinkRedirect","response","isJsonRpcResult","isJsonRpcError","isSessionCompatible","walletUniversalLink","isLinkMode","chains","statement","domain","nonce","type","exp","nbf","methods","resources","connectionUri","responseTopic","hashKey","AUTH_PUBLIC_KEY_NAME","namespace","parseChainId","recap","createEncodedRecap","getRecapFromResources","mergeEncodedRecaps","authRequestExpiry","authenticateId","sessionConnectEventTarget","authenticateEventTarget","onSessionConnect","onAuthenticate","payload","cacaos","responder","approvedMethods","approvedAccounts","cacao","validateSignedCacao","approvedChains","getNamespacedDidChainId","parsedAddress","getDidAddress","methodsfromRecap","getMethodsFromRecap","chainsFromRecap","getChainsFromRecap","chain","buildNamespacesFromAuth","linkModeURL","formatJsonRpcRequest","TYPE_2","BASE64URL","getLinkModeURL","sessionAuthenticateResponseParams","auths","EVENT_CLIENT_AUTHENTICATE_TRACES","EVENT_CLIENT_AUTHENTICATE_ERRORS","pendingRequest","receiverPublicKey","senderPublicKey","encodeOpts","TYPE_1","invalidErr","iss","formatMessage","duplicates","p","expirerHasDeleted","emitEvent","self","r","verifyContext","args","method","throwOnFailedPublish","tvf","publishOpts","encoding","BASE64","attestation","METHODS_TO_VERIFY","decryptedId","hashMessage","opts","redirectURL","proposeSessionPayload","proposeSessionMessage","attestationId","pairingProposalResponse","sessionSettleRequest","pairingPayload","formatJsonRpcResult","pairingResponseMessage","sessionSettlePayload","sessionSettlementRequestMessage","record","rpcOpts","formatJsonRpcError","sessionTopics","proposalIds","toCleanup","isExpired","encryptedId","reqMethod","resMethod","requestMethod","expectedMethods","EVENT_CLIENT_PAIRING_ERRORS","EVENT_CLIENT_PAIRING_TRACES","err","subscriptionId","target","relay","controller","pendingSession","memoryKey","lastSessionUpdateId","MemoryStore","lastId","currentId","_topic","RELAYER_EVENTS","requester","authPayload","pendingRequests","isValidParams","isUndefined","isValidRelays","isValidObject","warning","requestedNamespaces","ns","validRequiredNamespacesError","isValidRequiredNamespaces","validNamespacesError","isValidNamespaces","conformingNamespacesError","isConformingNamespaces","isValidString","approvedNamespaces","isValidErrorReason","isValidRelay","validControllerError","isValidController","isValidNamespacesChainId","isValidRequest","isValidNamespacesRequest","isValidRequestExpiry","SESSION_REQUEST_EXPIRY_BOUNDARIES","isValidResponse","isValidEvent","isValidNamespacesEvent","hash","metadata","context","VERIFY_SERVER","applink","properties","property","index","i","numItemsToDelete","k","deletedRecord","peerMetadata","_d","_e","_f","_g","_h","_i","url","getSearchParamFromURL","sessionExists","isTestRun","isReactNative","linking","initialUrl","txHashes","data","hexPart","methodConfig","TVF_METHODS","getSuiDigest","getNearTransactionIdFromSignedTransaction","tx","buildSignedExtrinsicHash","isValidArray","getAlgorandTransactionId","getSignDirectHash","getWalletSendCallsHashes","hashes","extractSolanaTransactionId","topics","pendingMessages","messages","isJsonRpcRequest","isJsonRpcResponse","EXPIRER_EVENTS","parseExpirerTarget","PAIRING_EVENTS","isValidId","REQUEST_CONTEXT","val","core","logger","THIRTY_DAYS","FIVE_SECONDS","AUTH_STORAGE_PREFIX","AuthorityType","getEnumEncoder","SignClient","ISignClient","SIGN_CLIENT_PROTOCOL","SIGN_CLIENT_VERSION","SIGN_CLIENT_DEFAULT","EventEmitter","name","listener","populateAppMetadata","createLogger","Core","Session","Proposal","PendingRequest","Engine","AuthStore","getLoggerContext","getU32Encoder","getU64Encoder","getU8Decoder","combineCodec","getU64Decoder","getBlockhashEncoder","getDefaultLamportsEncoder","getDefaultLamportsDecoder","getStructEncoder","getStructDecoder","getU8Encoder","decodeAccount","transformEncoder","getBlockhashDecoder","transformChannelOutboundMessages","getU32Decoder","SolanaError","toBytes","pipe","decode","previousUnits","_1n","_7n","getArrayDecoder","estimateComputeUnitLimit","assertAccountExists","u32","S","l","O","j","d","x","rpc","projectId","RPC_URL","accounts","address","matchedNamespaceKeys","key","accountsForNamespace","_","required","optional","merge","normalizedNamespaces","values","isCaipNamespace","events","rpcMap","normalizedKey","parseNamespaceKey","mergeArrays","caip10Account","parsedNamespaces","str","parsed","globals","EIP155_PREFIX","CAPABILITIES_KEYS","hexToDecimal","hex","decimalToHex","decimal","getCapabilitiesFromObject","object","item","acc","parseCapabilityValue","isValidJSONObject","chainIds","globalCapabilities","chainSpecific","addressSpecific","g","storage","kvStorage","I","UniversalProvider","LOGGER","CONTEXT","provider","callback","approved","populateNamespacesChains","mergeRequiredOptionalNamespaces","rpcUrl","inactivePairings","RELAY_URL","sessions","providersToCreate","setGlobal","getAccountsFromSession","getChainsFromApprovedSession","mergedNamespaces","combinedNamespace","Eip155Provider","GenericProvider","parseCaip10Account","requestChainId","payloadChainId","chainIdToProcess","convertChainIdToNumber","_session","PROVIDER_EVENTS","GENERIC_SUBPROVIDER_NAME","defaultNamespace","defaultChain","currentCaipChainId","previousCaipChainId","internal","newChainIdAccounts","account","namespaceKey","STORAGE","keys","appendTransactionMessageInstruction","previousMicroLamports","from","encode","ExtensionType","clean","u64.split","getU16Encoder","getEnumDecoder","getU16Decoder","getDiscriminatedUnionEncoder","getUnitEncoder","getUtf8Encoder","getDiscriminatedUnionDecoder","getUnitDecoder","getUtf8Decoder","y","h","R","IMessageTracker","MESSAGES_CONTEXT","MESSAGES_STORAGE_VERSION","CORE_STORAGE_PREFIX","messagesWithoutClientAck","direction","MESSAGE_DIRECTION","generateChildLogger","mapToObj","objToMap","IPublisher","relayer","PUBLISHER_CONTEXT","ONE_MINUTE","ttl","PUBLISHER_DEFAULT_TTL","prompt","tag","api","getRelayProtocolApi","getRelayProtocolName","failedPublishMessage","publishPromise","onPublish","initialPublish","createExpiringPromise","publishMethod","attempt","HEARTBEAT_EVENTS","ISubscriber","SubscriberTopicMap","SUBSCRIBER_CONTEXT","SUBSCRIBER_STORAGE_VERSION","pendingSubscriptions","SUBSCRIBER_EVENTS","createdEvent","eventName","deletedEvent","ids","subId","shouldThrow","subscribePromise","onSubscribe","subscription","subscriptions","subs","numOfBatches","batch","persisted","sleep","m","IRelayer","RELAYER_CONTEXT","THIRTY_SECONDS","isNode","RELAYER_PROVIDER_EVENTS","RELAYER_DEFAULT_LOGGER","MessageTracker","Subscriber","Publisher","RELAYER_DEFAULT_RELAY_URL","isAndroid","getAppId","isIos","shouldThrowOnFailure","resolvePromise","onSubCreated","relayUrl","isOnline","sortedMessages","a","b","messageEvent","onDisconnect","_resolve","_reject","auth","JsonRpcProvider","WsConnection","formatRelayRpcUrl","RELAYER_SDK_VERSION","exists","RELAYER_SUBSCRIBER_SUFFIX","publishedAt","lastConnectedState","subscribeToNetworkChange","connected","isAppVisible","RELAYER_RECONNECT_TIMEOUT","u64.rotrSH","u64.rotrSL","u64.shrSL","getOptionEncoder","getBooleanEncoder","u64.rotrBH","getAddressEncoder","u64.add5H","u64.add","getOptionDecoder","u64.add3L","u64.add3H","getBooleanDecoder","getArrayEncoder","getAddressDecoder","sha256","assertAccountsExist","fetchEncodedAccounts","getHiddenPrefixEncoder","getConstantEncoder","u64.rotr32H","u64.rotr32L","getHiddenPrefixDecoder","getConstantDecoder","IEchoClient","ECHO_CONTEXT","clientId","token","notificationType","enableEncrypted","echoUrl","ECHO_URL","ICore","CORE_PROTOCOL","CORE_VERSION","CORE_CONTEXT","globalCore","loggerOptions","getDefaultLoggerOptions","CORE_DEFAULT","chunkLoggerController","generatePlatformLogger","HeartBeat","Crypto","JsonRpcHistory","Expirer","KeyValueStorage","CORE_STORAGE_OPTIONS","Relayer","Pairing","Verify","EchoClient","EventClient","WALLETCONNECT_CLIENT_ID","universalLink","WALLETCONNECT_LINK_MODE_APPS","customStoragePrefix","globalCorePrefix","counterKey","fetchEncodedAccount","WalletConnectCore","AssociatedTokenInstruction","Token2022Account","Token2022Instruction","containsBytes","prefix","didPrefix","segments","signature","reconstructed","walletAddress","verifySignature","header","version","issuedAt","expirationTime","notBefore","requestId","resource","requestPayload","requested","supportedChains","getCommonValuesInArrays","requestedRecaps","updatedResources","actions","supportedActions","formattedActions","updatedRecap","action","abilities","ability","input","encodedString","resourceAbilities","limits","limit","baseRecap","obj","decoded","recap1","recap2","decoded1","decoded2","merged","mergedRecap","base","statementForRecap","currentCounter","uniqueAbilities","recapStatemet","recapStatement","isAligned32","isProgramError","kitIsTransactionSigner","AccountRole","aexists","isBytes_","abytes_","_0n","getI8Encoder","getI8Decoder","_4n","_2n","_5n","getBytesEncoder","getBytesDecoder","abytes","abool","randomBytesWeb","randomBytes","hmac","nobleHmac","isBytes","p256n","ZERO_INDEX","TYPE_LENGTH","IV_LENGTH","KEY_LENGTH","privateKey","x25519","toString","random","privateKeyA","publicKeyB","sharedKey","fromString","symKey","hkdf","byte","toBase64URL","base64","fromBase64URL","base64url","padding","iv","sealed","chacha20poly1305","encoded","concat","normalizedEncoded","bytes","slice1","slice2","slice3","deserialized","keyData","xBuffer","yBuffer","headerBase64Url","payloadBase64Url","signatureBase64Url","signatureBuffer","signingInput","messageHash","p256","decodeJWT","delimiter","fromBase64","pathStart","pathEnd","protocol","requiredValues","queryString","urlSearchParams","queryParams","typedKey","allParams","encodedEnvelope","caller","supportedNamespaces","normalizedRequired","normalizedOptional","supportedMethods","supportedEvents","supportedAccounts","requiredNamespace","optionalNamespace","chainsToAdd","methodsToAdd","eventsToAdd","accountsToAdd","combinedNamespaces","code","itemCondition","arr","sessionKeys","paramsKeys","compatible","hasOverlap","getAccountsChains","getChainsFromNamespace","split","validateUrl","blob","valid","validChainsError","validAccountsError","validActionsError","getNamespacesChains","getNamespacesMethodsForChainId","getNamespacesEventsForChainId","parsedRequired","parseNamespaces","parsedApproved","parseApprovedNamespaces","requiredChains","uniqueRequired","filterDuplicateNamespaces","uniqueApproved","missingRequiredNamespaces","boundaries","env","getEnvironment","ENV_MAP","isBrowser","state","callbackHandler","getDocument","memoryStore","loggerInstance","getI16Encoder","getI16Decoder","none","getF64Encoder","getF64Decoder","addEncoderSizePrefix","addDecoderSizePrefix","extension","padLeftEncoder"],"mappings":"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NnnBqS,CuNmnBrS,CvNnnBuS,KuNmnBjSC,EAAiB,cvNnnBqS,CAAC,IuNonBvTC,AvNpnB2T,CuNonB3TA,CvNpnB6T,AuNonB7TA,CAAU,KAAK,evNpnBmU,IuNonB/ShC,AvNpnBmT,CuNonBnTA,CAAAA,CAAQ,CvNpnBgT,GuNonB3S,CAAA,OvNpnBsT,CuNonBtT,CAAUA,CvNpnB+S,CuNonBvS,AvNpnBwS,EAAE,IAAI,EAAE,KuNonBnS,CAAA,CACrF,GAAIgC,CACF,CAAA,EvNtnBoY,GAAG,EuNsnBvY,KvNtnB8Y,CuNsnBxY,CvNtnB0Y,GAAG,CuNsnBxY,AvNtnByY,IAAI,OuNsnBjY,CAAA,CACrB,IvNvnBma,GAAG,EAAE,EuNunBxaV,CAAAA,CAAAA,CACA,KvNxnBkb,GAAG,CAAC,EuNwnBtbC,AvNxnBwb,CuNynBxb,CAAA,EvNznB4b,EAAE,CuNynB9b,AvNznB+b,CuNynB/bjD,EACA,KvN1nBuc,CuN0nB/byD,AvN1nBgc,CAAC,AuN0nBjcA,CAAAA,CACR,AvN3nB2c,OuN2nBnc,AvN3nB0c,CuN4nBhd,EvN5nBkd,KuN4nBld,AvN5nBud,CuN4nB9clE,CAAAC,AvN5nBgd,CuN4nBhdA,CAAAA,CAAA,GACJ8D,CADI,AvN5nBud,CuN4nBvd,CAAA,AvN5nByd,CuN8nBhe,AvN9nBie,CAAC,EAAE,EAAE,GAAG,EAAE,GAAG,CAAC,EuN8nB9dzC,GvN9nBme,EAAE,KuN8nB1dH,CAAAA,CAAM,AvN9nB2d,CuN+nB/f,AvN/nBggB,CuNgoBhgB,AvNhoBigB,CuNgoBjgB,AvNhoBkgB,CuNgoBlgB,CvNhoBogB,EAAE,IuNgoBtgB,CAAA2C,CACF,AvNjoB8gB,CuNioB9gB,AvNjoB+gB,CuNkoB/gB,AvNloBghB,CAAC,CAAC,CAAC,EAAE,EuNkoBrhB3C,CACA,CAAA,AvNnoByhB,EAAE,EAAE,KAAK,CAAC,UuNmoBniB,CAAsB,GACtB,EvNpoBmjB,CAAC,GAAG,CuNooBvjBgD,CAAAA,CACF,CAAC,CAAE,CAAA,CvNroB6jB,IuNqoB7jB,CAAOtD,CAAUe,CvNroBmjB,CuNqoBnjBA,CAAAA,CAAOf,CAAK,CAAC,CAAA,AvNroB4iB,CuNuoB7kB,AvNvoB8kB,EAAE,EuNuoB3kB,CAAA,EvNvoBglB,CAAC,CAAC,CAAC,CuNuoBnlB,CAAO,AvNvoB8kB,CAAC,CAAC,GAAG,EuNuoB5kB,EvNvoBglB,CAAC,CuNuoB5kB,CAAA,CvNvoB+kB,CAAC,KAAK,OAAO,MAAM,CAAC,CuNuoBnmB,CAAwB,AvNvoB6kB,CuNwoB3nB,IvNxoBgoB,CuNwoBhoB,AvNxoBioB,CuNwoBjoBJ,AvNxoBkoB,CAAC,CuNyoBnoB,CvNzoBqoB,CAAC,CAAC,EAAE,EuNyoBzoBsD,AvNzoB2oB,CuNyoB3oBA,CAAAA,AvNzoB6oB,CuN0oB7oB,KvN1oBmpB,CAAC,EuN0oBppBD,AvN1oBspB,CuN2oBtpB,CAAA,EAAA,AvN3oB0pB,CuN2oBtpBL,CvN3oBwpB,AuN4oB9pB,CAAC,CAAA,CACc,EvN7oBmpB,IuN6oB7oBO,CAAAA,EvN7oBopB,CuNipB3qB,CvNjpB6qB,GAAG,EuNipB1qBI,CAAAA,CAAyE,AvNjpBqmB,CuNkpBlrB,AvNlpBmrB,GAAG,CAAC,GuNkpB9qBpE,CAAAA,AvNlpBkrB,CuNkpBlrBA,CAAAC,AvNlpBorB,EuNkpBprB,EACJ8D,CAAAA,CAAAA,CAAAA,AvNnpB+rB,CuNkpB3rB,CAEP,CvNppBqsB,MAAE,AAAI,CAAC,GAAS,EAAE,EuNopBvtB,CAAiBzC,KvNppB8sB,CAAC,IAAI,CuNopBxsBH,CvNppB0sB,AuNopBpsB,CACpC,GACA,AvNtpB4uB,CAAC,GAAG,GuNspBhvB2C,CAAAA,CACF,AvNvpBuvB,EuNypBvvB,EvNzpB2vB,EAAE,EAAE,CuNypBxvB,MAAM,AvNzpByvB,CAAC,GAAG,GuNypBrvB,AvNzpBwvB,CuNypBxvB,EvNzpB2vB,CuNypB3vB,CAAI,AvNzpByvB,CuN0pBhxB,GvN1pBoxB,CuN0pBhxB,GvN1pBoxB,IuN0pBpxB,CAAc,AvN1pB2wB,EAAE,IuN0pBtwBjC,CAAAA,CvN1pB4wB,CuN0pBhwB,AvN1pBiwB,CuN2pBpyB,CvN3pBs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A0G3Bb,E1G2Be,AAAC,EDsD3B,AgCxMwC,GAAA,G2EuHnB,CAAE,CAAA,GAAA,CAAK3S,CAAcoQ,EAAAA,K1G4BnC,CwD7TO,CrL+LP,AsL7J2D,CG7BlD,AH6BkD,OzD2R9C,CAAC,C0G5BqBA,CAAkBpQ,A1G4BrC,AAAC,C0G5B6C,CAAC,A9C5RtC,C8C6RhD,CACF,A9C9RoD,C5DwTL,A0GxB/C4S,CAAAA,A1GwBiD,CAAC,CAAG,EAAE,AAAC,K0GxBxDA,A1GwB6D,C0GxBnD,A1GwBoD,CAAC,AAChD,CADiD,O0GxB5C,IAAK,CAAA,A1GgClB,EAAA,CAAA,G0GhCwB,CAC/BA,CAAAA,SAAAA,CAAU,QAAU,CAAA,A1GiCH,CAAC,ChFtGqB,AgFsGpB,A4DzTI,ChComBH,AG9bE,A/BmJF,A4DzTI,C8CwRJ,AxQvCD,A8JwEE,AhFtGoB,A4InNhB,A5D0TnB,C0GlCmB,C1GkCnB,EAAQ,G0GlCiB,A1GkCjB,C0GjCdA,A1GiCc,C0GjCdA,C1GiCsB,CAAC,GAAG,I0GjC1BA,CAAU,I1GiCyB,GACrB,EAAE,AyDtQsB,AOxFlB,GAAA,CAAA,EhE8VK,EAAA,GAAA,C0GlCQ,A1GkCD,C0GlCC,A1GkCA,AhFpGY,CgFoGV,CAAC,AzFCJ,EmMnCC,CAAK,A1GkCE,CAAC,CAAC,AAC5C,CAAC,AgBhCA,ahBkCwB,CAAI,C4B0SD,AnGxad,AtDD6B,CuO0FgB,CAAA,CAEzDD,A1GgC6D,E0GhC3C,E1GoCL,EAAE,A3GtEe,AqItFN,ArIsFM,GqNkCH3S,A1GoCR,C0GpCQA,A1GoCR,C0GpCQA,EAAc,A1GqCnC,C0GpCJ,A1GmCsB,A0B3Jb,C1B4JG,C/B9FC,AvF0EI,CgOhBb,A1GoC4B,C0GpC3B,A1GoC4B,GAAG,C0GpC/B,CAAK,OAAS,A1FI8B,A8CtThB,C4CkTd,C9E8UM,EAA4B,I8E7UrD,MAAMqP,A1GyCK,C0GzCLA,C1GyCK,A0GzCMwD,E1GyCN,CAAA,EAAA,EAAA,EAAA,MAAA,MAAA,C0GzC6B7S,CAAAA,CAAAA,CAAW,IAAK,CAAA,OAAO,EAC/D,GAAIqP,CAAAA,CAAAA,EAAA,IAAAA,C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R6S,C1GuEC,A0GvEDA,I1GuEK,C3G1DG,C2G0DG,EAAG,CAAC,AiFrZM,C5L2VH,A2G0DD,EAAG,CiFrZO,A/OiVyC,EwQHpEA,A1GuEuB,CAAC,A0GvER,CrNaW,A2G0DF,IAG7B,GAAA,YACS,C0G3EmCvZ,A1G2ElC,C0G3EkCA,ArNiB/B,CqNjB+BA,EAAgC,CAC9E,G1G0EoB,C0G1EpB,CAAK,C1G0EkB,CAAC,CAAC,A3G1DE,AnDXJ,YwQLHE,CAAAC,CAAAA,CAAAA,CAAA,EAAKH,CAAAA,CAAAA,A1G6Eb,C0G7EaA,CAAL,CAAa,K1G6ErB,G0G7EqB,A1G6ErB,C0G7E+B,A1G6EnB,C0G7EwB,A1G6EvB,CqF9aO,AqBiWgB,CnHqGd,AmHrGc,ArNoBnB,CqNpBoB,ArNoBnB,EqNnBhC,CAAC,EACH,CAEQ,U1GkF2B,C0GlFf8F,A1GkFe,C0GlFfA,CAAAA,CAA8B,CAChD,OAAO,C1GoFH,C4BwSqC,CAAA,C8E5XlC,CAAK,C1GoFE,CAAA,AAAE,CAAC,CuF1V4B,AFvFS,CrFibnC,AAAG,EAAE,EAAE,CAAC,CACxB,AqFlb6D,CqB6VvCA,A1GqFrB,C0GrFqBA,CAAS,CAAK,EAAA,ArB7V+B,EAAE,EqB6VjC,CAAK,E1GsFzB,AqFnb0D,CrFmbzD,AqFnb0D,CrFmb1D,AqFnb2D,ErFmbvD,CAAC,AiF1ZM,EjF0ZJ,CAAG,CAAC,AAAF,CAAG,C0GtFyB0T,O1GsFjB,CAAC,CAAK,CAAC,CAAC,CAAC,C3G7DD,A2G6DE,CAAC,CAAC,GAAG,CAAC,E3G7DA,A2G6DM,G0GtFmB,CACnF,CAEQ,K1GmFkE,CAAC,AACzE,CAD0E,C3G7DD,M2GoElE,C0G1FD,EAAwB,CAC9B,I1GyFe,CAAQ,C0GzFvB,A1GyFuB,C0GzFhB,A1G0FL,IAAA,C0G1FU,C1G0FV,EAAA,C0G1Fe,CAAA,Q1G0Ff,CAAA,EAAA,C0G1F2B,CAAE,CAAA,A1G0FoB,ClCsBK,AmHjbE,AWoRA,Mc6C3B,CAAS1T,CAAsB,EAAA,A1G0FC,C0G3fnE,CzBgG2E,CjF2ZL,CiF3ZO,AjF2ZN,CAAC,A0G3fxExD,ArBwE8E,CqBxE9EA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AA,AwQoI8B,EAAA,CACvC,GxQrI2B,CAAG,CAAC,A0NnPI,C1NmPJ,CwQqIxB,CxQrIiC,EAAA,EAAU,CwQqIrC,CxQrIwC,CAAC,GwQqIpC,QxQpIA,CAAA,CAAA,CwQoIYA,CxQpIZ,AwQoIYA,CAAS,CAAE,CAAA,cxQvIkC,CAMrE,AwQiImC,ExQjInC,AwQkIR,CAEA,ExQpIQ,CAAA,GwQoIM,UxQnIM,IwQmIS,AxQnIL,CwC2EJ,AmM/YA,A7E8YF,A9J1EO,AwQmII,CxQnIJ,AwQoIvB,ExQpI6B,EAAA,EAAA,IAAA,EAA2B,EAAA,IwQoIxD6T,CAAAA,CxQpIkE,AwQoIlEA,CnMtDmC,AsKjZN,AnM+YF,AgOyD3B,ExQnIF,E0NjPI,K1NiPG,G8JoLc,EAAO,EAAE,AAAE,EAAQ,C0GjDtCC,CAAAA,CAAAA,CACA,A1GgDoC,GAAS,CAAC,CAAC,I0GhD/CC,CAAW,CAAA,CAAA,CACb,CAAkC,CAAA,CAChC,C1GmDE,E0GnDE,A1GmDG,C0GnDF,IAAK,CAAA,O1GmDH,CAAA,E0GnDG,CAAY,C1GmDf,CAAoB,K0GjD3B,KAAM,CAAC/T,CAAAA,CAAW9B,CAAO,CAAA,CAAI,I1GsD3B,C0GtDgC,AnBlS1B,ANvEC,CAAA,IjF+Za,CzBHkC,AyBGjC,CAAC,M0GtDwB2V,CAAAA,CAAkB,CAE7D3V,CAAAA,A1GuDG,C0GvDHA,GAEL,A1GsDQ,GAAE,C0GtDL,A1GsDK,CAAA,A0GtDL,C1GsDW,E4BkSsC,EAAA,CAAA,Q5BlSzB,EAAE,I0GtD1B,CAAqB8B,C1GuDjB,C0GvD4B9B,AzBzWrB,CyByW4B,CAAA,CAEvC6V,CAMH,A1G+CY,CAAA,C0G/CZ,GzBjXwB,CyBiXxB,CAAK,AzBjXqB,AAAC,CjFgaL,C3GlEO,CyE8FT,AkC5BI,G0G/CZ,CAAA,C1G+CkB,CAAC,CAAC,C0G/CpB,A1G+CqB,AACjC,C0GhDiB,M1GgDX,MAAU,ClC4BK,E4I5EY7V,CAAO,CAAA,CACxC,IAAK,CAAA,gCAAA,A1GsDK,C0GtD4B,AjLjFzB,CiLkFX,I1GsDI,CAAE,GAAA,C0GtDN,A1GsDY,C0GtDZ8B,A1GsDc,C0GrDd,CAAA,C1GqDkB,CAAE,CAAE,GAAI,CuG/hBlC,AHyE0C,CAAA,CAAA,IpGsdG,CACjC,CAAE,G0GtDN,A1GsDU,C0GtDV6T,A1GsDY,C0GrDZ,A1GqDc,C0GrDd,C1GqDgB,C4BkSS,A5BlSP,CAAE,CAAE,EAAE,CAAE,CAAE,CAAE,CAAG,EAC7B,EAAE,AAAG,CiFhaK,AjF+ZwB,CiF/ZvB,AjF+ZwB,AAC5B,AAAC,C4BiSa,A6Ej0BjC,CAAA/B,C7Ei0BwD,A8EvVhD,AD1eRA,CC0eQgC,A1GsDgB,C0GrDlB,AzB3WuB,AwBhI7B,A7Ek0BiC,C8EvV1B,A9EuV0B,C8EjW3B,EAAA,A1G+DwB,CAAC,CyGhiB/B,CAAA,AzGgiBiC,AAAE,C0G/D7B,CAAK,A1G+D0B,CAAC,AAAE,EAAE,AAAC,GAAG,CAAC,C4BkSd,C5BlSgB,AyGhiBjD,AzGgiBmD,CyGhiBnD,A7Ek0BwD,E8EjWjC9T,CAAS,A1GgEpB,C0GhEoB,CAAE,A1GgEpB,AAAG,CiFhaE,CAAC,AjFgaD,AAAC,GAAG,CAAA,EAAI,GAAG,CAAC,EAAI,C0GhEe9B,CAAAA,A1GgEb,C0GhEoB,A1GgEjB,C0GnDpC,CAAA,A1GmDuC,GAAG,CAAC,E0GnDrC,A1GmDyC,EAAE,CAAC,E0GnDvC,M1GoDF,C0GpDU,CAAA,C1GoDJ,CiFhaO,AjFiatB,CAAC,S0GrDkB,CAAc,IAAK,CAAA,K1G2DzB,CiFjaO,CAAA,GyBsW4B,CAClD,AzBvWsB,CAAA,CyBuWtB,CAKQ,AzB5Wc,CAAA,EjFiaW,CzBaE,EyBbC,CAAC,IAAI,CAAC,EAAE,EAAG,IAAA,CAAA,EAAA,U0GrDN,CACvC,G1G4DQ,CAAA,CAAG,CAAE,CAAC,CAAA,C0G5Dd,A1G4Dc,C0G5Dd8B,CACA,A1G4DQ,C0G5DR,C1G4DQ,EAAQ,EiFlaQ,CAAA,CAAA,EjFkaD,GAAG,CAAC,CAAC,AAClB,C2Glf0B,A1BgFnB,A0B/Eb,C3GifQ,CAAE,C0G7Dd,A1G6DgB,CAAE,A0G7DlB6T,CACA,AzBtWyB,CyBsWzB,A1G4DoB,CiFlaO,CAAA,CjFkaD,EAAE,CAAA,CAAI,CAAA,CAAK,EiFlaQ,EjFkaJ,CAAC,AACxC,CiFna+C,CAAC,AjFmahD,EAAA,C0G7DF,CAAAC,CACF,CAAA,A1G4DoB,C0G5DuB,A1G4DvB,C0GrjBtB,C1GqjB6B,EAAE,C0GrjB/BtX,CAAAC,CAAAA,CAAAA,A1GqjBoC,C0G3DhC,A1G2DkC,EAAE,C0G3DhC,CACF,A1G0DwC,G0G1DpCqX,C1G0DwC,A0G1DhBD,C1G0DiB,AiFjarC,CjFiasC,C0G1DlBA,A1G2DnB,C0G3DmBA,CAC1B,A1G0DO,GAAM,CAAA,EAAA,C0GvDf,EFxeS,ExG+hBgB,AAChB,E0GxDHxE,A1GwDM,C0GxDK5S,CAAAA,A1GsD+C,AiFha5C,CyB0WHA,A1GwDF,C0GxDEA,A1GwDD,C0GxDCA,CAAAD,A1GwDC,AAAE,CADc,AvEvIjB,AwJ1RU,CuB/Hc,AEyexB,A1GwDK,A4BgSpB,C5BhSqB,CAAC,CiFlaO,AjFmatB,C0GzDa,CAAA,A1GyDV,CiFnasB,AACf,CAAC,CjFkaL,CAAA,EiFnawB,AjFmanB,C0GzDE,E1G0DlB,C0G1Da,C1G0Db,EAAQ,CiFpamC,AyB0W9BA,AzBxWE,AuB9HO,CEseTA,CFteS,CvB4HwB,AjFoalC,CiFpamC,CjFoanC,C0G1DCA,CAAAA,CAAAA,A1GsFjB,C0GtFiBA,CAAc,O1G2D1B,EiFlaQ,AjFkaN,AAAC,C0G3DkCwD,AzBvW3B,CyBuW2BA,CAAAA,A1G2D/B,C0G3D+BA,A1G2D/B,EAAA,C0G3DM,E1G4DjB,EADqB,AAChB,EAAE,AwGhiBM,GxGgiBF,CAAC,C4BgSJ,C8E5VSvD,A1G4DH,AAAE,CADc,A0G3DwB,C1G4DpC,A0G5DoC,C1G6DtD,CiFlaO,CAAA,EjFkaC,G0G7D8C,A1G6D3C,C0G5DX,A1G4DY,EAAE,AAAE,C0G5DZ,CAAC4S,CAAU,CAAA,G1G6DP,E4BgSU,AqDlsBJ,CjFkaH,C0G5DX,A1G4DY,C8FvfM,A9FufL,CAAE,C4BgSG,CqDlsBG,AjFkaJ,CAAC,AiFlaI,CAAC,AyBsWjB2E,A1G4Da,CACd,A0G7DCA,CAAqB3E,CACxB,A1G4DI,C0G5DJ,E1G4DQ,CAAC,EAAI,C0G5Db,C1G4De,A0G5DP4E,C1G4DQ,AACnB,A0G7DuBA,C1G4DH,AiFjab,CjFkaF,A0G7DkBA,CAAAA,C1G6DlB,A0G7D0B,G1G6D1B,CAAA,EAAA,E0G7DmC,CAAA,CAAA,C1G8DnC,C0G9DsCJ,CAAkB,A1G8DtD,AAAC,C0G9DwD,CAAA,C1G8DrD,A0G9DqD,C1G8DrD,A0G9DsD,CAC9D,C1G6Da,A0G7Db,E1G4D4B,C0G5D5B,A1G8DH,C2GlfqD,ADob9CV,C1G8DF,EAAA,C8FzfqC,E9FyfrC,CAAA,EAAA,OACG,E0G/DiB,C1G+DjB,A0G/DiB,C1G+DjB,A0G9DR,E1G8DgB,CiFlaO,AyBoWnB,CCjbsB,ApIwgBJ,AyBzBJ,A0G9Db3I,C1G8Dc,EACd,EAAG,GAAA,CAAI,EAAI,C0G/DXA,CAAawJ,CAAkB,CAAA,C1GgE/B,A0GhEkC,E1GgEhC,GAAI,CAAC,C0G/DZ,C1G+DgB,CvExIG,AwJ1RI,EyBmWvB,CAAK,C1G+DgB,KACV,C0GhEC,A1GgED,EAAI,C4BgSG,A4Eh0BW,CEgeZ,A1G+Dc,C0G/Dd,E1GiEZ,E3G5DM,A4LtWE,AjFkaN,GAAI,CAAC,EAAI,CiFlaO,CAAC,AjFkaN,ClCmCG,AkCnCF,IACX,A0GlES,CAAmBA,CAAkB,C1GkE9C,CAAA,A0GjEV,CAAS/Y,C1GiEQ,GACf,EAAK,A0GlEEA,CAAAA,CAAO,A1GkEN,C0GjER,E1GiEW,CAAA,C0GjEX,C1GiEgB,A0GjEX,E1GiEa,CAAC,AACnB,CADoB,AwG/hBb,CxGgiBF,C0GlEO,C1GkEJ,A3G7DmB,A2G6DpB,A0GlEK,G1GkEJ,CAAI,A0GlEA,CAAKA,C1GkEH,AAAE,A0GlEQ,CAAA,C1GkEN,CAAC,AACnB,CADoB,CAAC,AACrB,EAAA,GAAA,CAAY,EAAI,EADe,AACb,CAAC,CAAC,A3G5DI,C2G6DnB,EAAG,GAAA,CAAA,EAAQ,EAAE,CAAC,CAAC,CACf,AwGjiB6B,CAAC,CnNoeV,A2G6DpB,GAAA,CAAO,EAAE,GACd,EAAA,EAAQ,GAAA,A0GtEgE,C1GsE5D,C0GrEd,C1GqEkB,A0GpEpB,CAEQ,S1GmEO,CAAA,EAAK,KACX,EAAG,C0GpEiB+E,CAAAA,C1GoEd,A0GpEcA,C1GoEb,A0GpEgC9B,CAAuB,C1GoEvD,A0GpEuD,CACrE,E1GoEE,C0GpEE,C1GoEG,A0GpEF,E1GoEE,G0GpEG,A1GoEG,CAAC,EAAA,KACP,EAAG,A0GrEY,CAAA,E1GqEZ,CAAA,EAAA,E0GnEV,K1GoEU,C0GpEJgW,CAAAA,C1GoEI,A0GpEW,C1GoEP,EAAA,C0GpEY,CAAA,G1GqEnB,CiFlaK,CAAA,GjFkaC,CAAC,C0GrEY,C1GqER,A0GrEmBlU,CnIuGd,AmIvGuB,CAAIA,CAAAA,A1GuEzC,C0GvEyCA,C1GqE3B,A0GrEuC,CAAGA,C1GuEpD,CtHoEO,AgO3I6CA,ChO2I7C,AgO3IsD,CAAI9B,ChO2I1D,AgO3I0DA,EAAAA,A1GsE5E,C0GtEmF,C1GsE9E,AAD0B,A0GnE3ByV,CnIqGgC,AmIrGhCA,C1GoEI,AzBiC6B,AmIrGjCA,CnIqGiC,AmIrGjCA,CAAmB,C1GoEZ,A0GnEX,C1GmEY,EAAE,AAAE,GAElB,A0GrEE,C1GqED,A0GrES,EAAC,CACT,E9EiW4B,A5BvRd,CAAA,C4BuR0C,E5BtR9C,C0G3ED,CAAA,GACT,C1G2EM,CAAE,GAAI,ClCuCG,A4IlHP,C1G2EQ,A0G3ER,EACR,C1G0EoB,A0G1EpB,C1G0EsB,ClCuCG,AkCvCD,GAAA,CAAM,CAAE,CAAG,IAAI,A0G1EvC,C1G0EwC,AAClC,A0G3EQzV,C1G2ER,A0G1ER,CAAA,CAEK,C1GwES,CAAA,CAAI,E0GxER,C1GwEY,CAAE,CAAE,GAAA,CAAM,CAAE,CAAG,C0GxEhBgW,CAAAA,A1GyEnB,C0GzE+B,C1GyE/B,A0GvES,CAAA,C1GuET,G0GvES,C1GuEO,A0GvEF,C1GuEI,CvExID,AqC+KI,AmH1cI,CjFmaL,AlCuCE,EAAA,IkCvCQ,CAAE,A0GvEPA,CzB5Vc,AyB4VdA,CAAY,A5I8GD,AmH1cI,AjFmaN,AAAG,CiFnaO,CAAC,AjFmaN,AAAC,E0GtExC,E1GsEwC,CAClC,CAAC,AADuC,A0GtEzC,C1GuEK,A0GvEL,CzB7ViD,CAAC,AjFoavC,CiFpawC,AjFoaxC,CACV,AiFramD,CjFoa1C,CACJ,EAAE,AAAC,E0GxET,C1GwEY,A0GxEDA,C1GwEE,A0GxEU,CAAA,C1GwEJ,A0GxEM,C1GwEL,CAAE,CAFqC,AAEzC,EAAO,CiFlavB,AjFkawB,CAAC,C8FveM,AbqE/B,EjFmaK,E0GzEiChW,C1GyEjC,A0GzEiCA,CAAAA,A1GyE7B,C0GzE6BA,A9EwW3C,AnGvaa,AwJ3RQ,CAAC,AjFmaN,AAAE,A0G3EpB,E1G2EsB,CAAC,CAAC,A0G3EnB,C1G2EoB,AAChB,A0G5EJ,E1G4EM,AAAC,EiFnaM,CjFmaH,CAAA,C8FxesB,C9FwejB,CADc,CACZ,A0G5EjB,C1G4EkB,AACvB,A0G7EgBgW,C1G4EQ,A0G5EI,CAAA,A1G6EnB,C0G7EuBP,CjL5DP,AuEyIb,C0GzEhB,CAEQ,C1GuEW,CAAA,EAAK,EAAE,AvExIF,CuEwIG,CAAC,CACf,A0GxEO,E1GwEP,A0GxEO,CAClB,E1GuEiB,CAAC,E0GvEb,A1GuEiB,UACL,CAAA,EAAK,EiFnaQ,AjFmaN,A0GxEH,C1GwEI,CAAC,A0GxEL,CACrB,A1GuE2B,EACjB,E0GxEL,C1GwEQ,A0GxER,C1GwEQ,AiFpa0B,EjFoarB,AiFpauB,CjFmaL,E0GvE/B,CAAO,C1GyEL,CiFrawC,CjFqarC,CiFrauC,AyB4VhC,CAAA,C1GyEP,CAAI,EAAA,IiFra4C,CyB4VzC,A1G0EV,CiFtaqD,AyB4VhC,C1G0ErB,A0G1EuB,EzB5ViC,CjFsalD,CAAC,CiFnaO,CAH8C,AAG7C,AjFmaN,AAAE,CiFtakD,A1GudjD,AmI3HoB,CAAA,IAAA,CAAK,G1G2E/B,CAAA,EAAA,C0G3EuC,CAAC,EACvD,CAEA,I1GyEa,EAAG,A0GzEF,G1GyEE,CAAI,EAAI,C0GzEA,E1GwGpB,A0GxGoB,CACtB,C1GwE2B,G0GxEtB,CAAA,G1GyEE,EAAG,C6GrmBO,E7GqmBJ,CAAA,C0GzER,CAAa,A1GyEL,K0GxEb,A1GyEO,C0GzEP,CAAA,A1GyES,AAAC,E4B+RN,C5B/RS,C0GzEb,A1GyEc,C0GzET,C1GyEW,AAAE,GAChB,EAAE,AAAG,EAAE,GAAI,CAAC,EAAA,GACZ,C0G3EwB,CAAA,A1G2EnB,EAAE,AAAC,G0G3EgB,A1G2EhB,C0G3EgB,A1G2EZ,C0G1Ed,C1G0EkB,G0G1Eb,CAAA,C1G2EE,EAAG,GAAG,CAAC,EAAI,CtHyEI,EsHxEpB,CtH0EK,CsH3EgB,AACnB,AAAG,EAAE,AAAC,C0G5EL,AhOsJU,CgOtJU,ChOsJV,CsH1ED,EAAE,AiFnaO,CyBwVvB,AzBxVuB,CyBwVvB,CAAA,E1G4EO,CiFnaO,CjFmaJ,E0G5EJ,C1G4EI,CAAI,E0G5EH,A1G4EK,AAAE,C0G5EP,C1G4ES,GACb,EAAE,AAAC,GAAG,CAAC,EAAE,AAAE,EAAE,C0G7ET,A1G6EU,C0G7EM,A1G6EL,CtH0EG,EsHzEf,CtH0EG,CAAC,CsH1ED,CAAA,EAAA,G0G9E0B,CACvC,C1G8EO,A0G9EP,E1G8EU,CvExIG,AwJ3RI,EjFmaJ,CAAA,A0G9EP,E1G8EY,CiFnaO,CyBqVd,C1G+ET,A0G/ES,E1G8EY,AAChB,C8GtnBc,C9GsnBX,GAAA,CAAA,EAAA,K0G/EC,A1GgFJ,C0GhFoB,C1GgFjB,GAAA,CAAA,EAAQ,KACX,ClC6CG,CAAA,GkC7CG,CAAC,EAAI,A0GjF6B,C5I8H1B,AgIxfE,AY0XwB,CAC/C,K1GiFU,C0GjFJ,E1GiFI,CAAA,C0GjFC,C1GiFO,A0GjFP,C5I8HU,EkC5CnB,EAAE,AAAG,EAAE,GAAI,CAAC,EAAI,E0GlFP,CAAgB,E1GkFJ,AAChB,EAAG,C8GtnBc,EAAA,CAAA,EAAA,G9GunBtB,EAAE,AAAG,EAAE,AAAC,E0GpFoC,AIliB5B,CJkiB4B,AIliB5B,CJoiBlB,AIpiBkB,E9GsnBD,CvExID,CiLsDX,A1GkFc,C0GlFd,E1GmFE,EzB8DM,AyB9DJ,AAAC,G0GnFL,A1GmFQ,C0GnFE,A1GmFF,EAAA,K0GlFb,A1GmFO,EAAE,AAAC,E0GnFL,CAAA,A1GmFQ,CAAA,EAAK,KACX,EAAA,GAAM,CAAC,EAAE,AAAE,EAAE,GAAG,AAChB,C0GrFF,CAAuB,A9EmXK,A5B9RxB,A+GznBM,A/GynBL,C0GrFoB,E1GqFjB,CAAC,CAAC,CAAE,EADgB,AACd,CAAC,CAAC,C+GznBO,A/G0nBrB,C+G3nBoC,C/G2nBlC,AAAC,E0GtFoB,CAAgB,A1GsFpC,C0GtFyC,A1GsFzC,C0GtFyC,CAAC,A1GsFlC,C0GrFlB,AjLnDiB,CiLmDjB,A1GqFoB,CAClB,AADmB,CAAC,CACf,C+GznBO,C/GynBJ,AAAD,C+GznBQ,ALmiBX,E1GsFO,CAAC,C0GtFH,CAAA,A1GsFK,KACT,EAAE,GAAA,CAAK,EAAE,C0GvFL,GACb,CAEA,E1GqFY,C+GznBO,E/GynBJ,CAAC,A0GrFF,E1GqFM,KAAK,AAChB,A0GtFK,CKniBE,ALmiBMnE,C1GsFX,AAAC,C0GtFuBxF,CZ7WD,AY6WgB,CKpiBd,A/G0nBrB,A0GtFmC,C1GsFlC,A0GtoBlB,E1GsoBsB,EADe,A0GroBrCxN,A1GsoBwB,CAClB,A0GvoBNA,CAijBI,C1GsFI,A+GznBM,A/GynBH,C+GznBO,C/GynBL,AAAC,C+GznBO,CAAC,C/GynBL,A0GtFP3B,C1GsFQ,A0GtFRA,CKniBe,ALmiBfA,CAAAA,A1GsFY,C0GtFJ2B,EAAA,E1GuFP,C+GznBO,AnFw5BV,C5B/RK,AAAC,A+GznBK,ALkiBI,CAAA,CMhjBM,CAAA,ChHuoBX,EAAI,CvExID,AsLjfQ,CLkiBN,C1GwFjB,CgHvoBO,ChHuoBF,A0GxFO,CKjiBA,C/GynBL,A+GznBM,ELiiBDA,C1GwFD,A0GxFCA,C1GwFA,EAAE,E0GxFFA,C1G0FL,A0G1FKA,CAAAA,AjL9CN,CiL8CMA,CAAc,CjL9CpB,EuEwIW,EAAI,A0G1Fc,CZrWP,C9F+bL,C0G1FY,C1GyF9B,AACoB,C0G1FU,C1GyF9B,A0GxFP,G1GwFa,CAAC,EAAI,A0GxFZ,G1G0FN,C+GznBY,A/GynBX,AAED,A0G5FW,C1GwFY,AtH8FpB,AgOtLQ,EZvWmB,IYuWnB,CAAO,ChOsLf,CsH1FkB,C+G1nBF,C/G2nBjB,A0G7FqB,CAAA,ChOuLjB,KsH1FG,CtH0FG,AgOvLW,CAAQ,E1G6FlB,CAAA,GAAI,CAAC,A0G7FqB,CAAA,CAAA,AjL5CrB,A/CmOI,EgOvLoB2X,I1G6FZ,EAAE,C0G7FiB,A1G6FhB,CAAC,A0G7Fe,CAAA,EAAI3E,CAAG,CAAA,EAAG3U,CAAK,CAAA,CAAA,CAAImP,CAAI,EAC1E,CAEA,E1G8Fe,CAAC,G0G9FF,G1G8FQ,CAAC,EAAA,IAAA,E0G9FT,A1GiGJ,C0GjGiBwF,CAAa,CAAA,CArjB1C,C1GspBY,CAAc,CAAA,C0GtpB1BhT,A1GupBM,C0GvpBNA,CAsjBI,K1GiGS,C0GjGH3B,A5IqJM,C4IrJE2B,A1GiGA,C0GjGAA,AMziBc,CNyiBdA,AMziBe,CNyiBfA,CAAAA,CAAA,IAAK,CAAA,A1GiGK,CAAC,IAAI,CAAE,C0GjGZ,A1GiGa,CAAE,E0GjGpB,A1GiG0B,I0GjG1BA,CAAAA,KAAAA,A1GiGoC,C0GjGpCA,A1GiGqC,CAAC,A0GjGtCA,CAAAA,CAAc,QAAS,EACrC,CAAA,E1GwGe,C+G7nBK,A/G6nBK,CAAA,CACvB,C+G7nBO,CLohBF,C1GyGC,C+G7nBO,ILohBF,C1GyGH,C+G7nBO,A/G6nBH,CAAA,C0GzGD,CAAK,A1GyGC,CAAC,CvE5ID,AuE4IG,CAAG,G0GzGA,CAAA,C1G0Gd,C+G7nBO,ELmhBO,A9EqYH,C8ErYQ,AKnhBT,K/G6nBA,E0G1GiB,A1G0Gb,C0G1Ga,E1G0GR,CAAC,I0G1GO,CAAQ,CAAG2X,EAAAA,A1G2GrC,EAAM,IAAI,C0G3GkC,CAAI3E,CAAAA,EAAAA,CAAG,CAAG3U,C1G4GrD,C0G5GqDA,CAAK,AZ9UnD,AiBnMC,C/G6nBL,C0G5GyD,CAC3E,CAEA,I1GyGkB,E0GzGJ,Q1G0GD,GAAG,I0G1GF,A1G0GE,C0G1Gc2U,CAAa,CAAA,CA1jB7C,A1GoqBkB,GAAA,C0GpqBlBhT,CA2jBI,CAAA,I1GyGuC,E0GzGjC3B,CAAQ2B,CAAAA,A1GyG6B,C0GzG7BA,A1GyG8B,C0GzG9BA,CAAAA,CAAA,IAAK,A1G4GJ,C0G5GI,C9EwYf,CnGvaY,CuE2IG,A4B4Rf,I8ExYe,GAAL,K9EwYV,C5B5R+B,IAAI,CAAC,C0G5G1BA,A1G4G0B,C0G5GZ,CAAA,KAAA,A1G6GjB,EAAA,C0G7G0B,EACrC,CAAA,MAAM,IAAK,CAAA,C1G4GqB,CAAC,I0G5GtB,A1G4G0B,C0G5GnB,A1G4GqB,EAAE,AAAE,E0G5GpB,A1G4G0B,C0G5G1B,OAAA,CAAQ,C1G4G4B,CAAC,CAAC,GAIvD,C+G7nBK,GL6gB+B,CAAA,CAAA,C1GgHlC,C0GhHqC2X,A1GgHhC,CiH5qBC,GjH4qBC,CAAE,E0GhHmC,CAAA,CAAA,EAAI3E,CAAG,A1GgHxC,C0GhHwC,A1GgHnC,E0GhHsC3U,CAAK,CAAE,A1GgH3C,C0GhH2C,A1GgHzC,CAAE,C0G/GhC,A1G+GmC,C0G5GnC,C1G4GwC,EAAD,G0G5GzB,M1G4GqC,CAAC,EAAE,CkH3qB1C,AlH2qB2C,CAAC,CkH3qB5C,ER+jBmB,A1G8G3B,E0G9G2B,A1G8G3B,C0G9qBN,CKkDa,EAAA,CLlDb2B,CAikBI,CAAA,CK/gBS,EL+gBL,CACF,GAAA,A1G8GO,C0G9GP,CAAIA,A1G8GQ,C0G9GR,AK/gBe,CL+gBf,C1G8GW,AlC0DI,CkC1DA,E0G9Gf,A1G8GoB,C0G9Gf,G1G+GH,EAAE,AAAG,I0G/GP,C1G+GY,E+G5nBG,CL6gBfA,A1G+Ge,C0G/GfA,AK7gBe,CAAA,E/G4nBU,CAAC,C0G/G1BA,CAAAA,A1G+G2B,C0G/G3BA,A1G+G4B,C0G/G5BA,A1G+G6B,AvE3IV,AyLhiBQ,CR4jBd,AQ5jBe,MAAM,AlH4qBtB,C0GhHS,AQ5jBc,CR4jBd,AQ5jBe,AlH4qBxB,CkH5qByB,ClH4qBzB,CkH5qB2B,CAAC,ClH4qB5B,C0GhHS,AQ5jBqB,AlH4qBhB,CkH5qBiB,CR4jBb,A1GgHH,C0G/G7B,CAAA,A1GgHA,CAAC,CkH7qBiD,AlH6qB9C,EAAA,G0G9GN,G1G8GM,G0G9GA4X,CAAAA,CAAO,E1G+GJ,CkH1qBO,CH+CG,AnFw5BE,C5B5RnB,C0GhHiB,C1GgHf,EAAA,C0GhHe,CAAK,MAAO,CAAA,IAAA,CAAK,A1GkHzB,EAAM,CAAH,A+G1nBD,AAAI,C/G0nBI,G0GlHuB,CAAA,E1GkHjB,EAAA,EACvB,C0GnHwC,E1GmHxC,CAAA,A0GlHJ,E1GkHI,E0GlHO5E,A1GkHU,M0GlHVA,A1GkHU,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E,IAAI,AACrF,CADsF,AACrF,AAGD,eAAa,KwIt/BjB,CAAA,CAAA,CAAA,AxIu/Ba,CwHx0BO,EAAE,AAAE,C/LynBT,C+LznBS,CgB/KxB,CxIu/B4B,AwIv/B5B,CxIu/B6B,CwHx0BO,OxHw0BC,CwHx0BO,CxHw0BL,CACnC,CAAC,GwIx/BL,AhBgLY,CAAC,AgBhLb,EhBgLe,EgBhLfE,GAAA,CAAA,MxI0/Ba,AwI1/Bb,CAAA,ExI0/BiB,CwHx0BO,CAAC,IkBhLlB,I1Iw/BoB,CAAA,IAAA,EAIvB,MwI9/BJ,CAAA,IAAAC,GAAA,CAAA,IxI8/BI,EwI9/BJ,CAAA,KxI+/Ba,CwHz0BO,ExHy0BG,CwHz0BA,CAAC,CAAC,CxHy0BG,CAAC,A4I//B7B,CAAA,AnN+yBoB,CuEgNG,EvEhNQ,CmN/yB/B,CAAA,EJAA,CAAA,GxI+/ByC,CwI//BzCvM,CxI+/B2C,CAAC,CAAC,AwI//B7C,CAAA,MAAA,CAAA,GIAA,CAAA,IAAA,CAAA,AJAA,CIAA,AJAA,IxImgCa,E4IngCb,CAAA,A5I2TS,GAwsBkB,IAAI,AwIngC/B,CAAAwM,AxImgCgC,C4IngChC,A5ImgCiC,C4IngCjC,C5ImgCmC,AwIngCnC,CxImgCoC,AwIngCpC,CxImgCqC,CAxsB5B,EAwsB+B,AAxsBJ,CAA3B,A9JrEoB,CsNnPW,AtNmPV,AsStP9B,CtSsP+B,A8JqEQ,AwI3TvC,CxImgCsD,CAxsBb,GAwsBiB,A4IngC1D,C5ImgC2D,A4IngC3D,C5ImgC4D,A4IngC5D,CAAA,C5ImgC8D,AwIngC9D,CxImgCqD,AAAU,AwIngC/D,CxImgCgE,CAAC,E4IngCjE,CAAA,S5IwjCqB,A4IxjCrB,COMwB,AnJkjCmB,A4IxjC3C,COMyB,A3BoOA,AAAG,CAAF,GxH+0BF,AwIzjCxB,CWO6B,AXP7B,CWO8B,GXP9B5D,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CIAA,AJAA,CIAA,EJAA,CAAA,AWO8B,CPP9B+G,GAAA,AJAA,CIAA,AJAA,CIAA,AJAA3V,AWO8B,CPP9B,AOO8B,CPP9B,CAAA,AJAA,CIAA,AJAA,CIAA,AJAA,CAAA,CAAA,CIAA,AJAA,CAAA,AIAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,AJAA,AxI0jCwB,C4I1jCxB,AJAA,CIAA,AJAA,AxI0jC6B,C4I1jC7B,AJAA,CAAA,CxI0jC6B,GAAA,CAAA,EAEzB,E4I5jCJ,CAAA,CAAA,A5I4jCU,C4I5jCV,AJAA,CIAA,A5I4jCgB,AwI5jChB,AxI2jCgB,CwI3jChB,ChB+OsB,AgB/OtB,CxI2jC4B,AwI3jC5B,IWWoC,CAAC,AnJgjCJ,CAAE,EmJhjCM,AXXzC,CIAA,AOW0C,AnJijC1B,AwI5jChB,CAAA,AxI2jCuC,A4I3jCvC,C5I2jCwC,AwI3jCxC,AIAA,C5I2jCyC,AwI3jCzC,AIAA,CAAA,COW+C,CnJijCrB,AmJjjCsB,CnJijCrB,AACjB,CwI7jCV,AhBiPe,CgBjPf,AhBiPe,CgBjPf,CWWqD,AXXrD,AhBiPe,CgBjPf,AIAA,CJAA,AIAA,CJAA,AIAA,CJAA,AIAA,CJAA,AxI6jCwB,A4I7jCxB,CpBiP6B,AgBjP7B,AxI6jCyB,CwI7jCzB,C/M02BuB,AuEoNH,AwI9jCpB,CAAA8L,AhBiPgC4M,A4B3OP,CpJwjCC,A4I9jC1B,CQM2B,ApJwjCA,AAAJ,A4I9jCvB,CAAA,A5I8jC4B,AwI9jC5B,AhBiPuC,CxH60BV,AwI9jC7B,AhBiPwC,AoBjPxC,CJAA,AIAA,CpBiP0C,AgBjP1C,AIAA,CJAA,AIAA,CJAA,AWWsE,APXtE,COWuE,A3BsO1B,AoBjP7C,CpBiP8C,AoBjP9C,CJAA,AIAA,CpBiPgD,A4B3OP,AZNzC,AIAA,CAAApG,CpBiPkD,A4B3OP,EZN3C,AIAA,CpBiPqD,AoBjPrD,CpBiPsD,AoBjPtD,CAAA,CpBiPwD,AoBjPxD,AJAA,CIAA,A5I8jC8C,AwI9jC9C,EhBiP2D,CoBjP3D,CAAA,AJAA,ChBiP8D,AgBjP9D,ChBiP+D,EAAE,AoBjPjE,AJAA,CAAA,CAAA,ChBiPoE,CgBjPpE,AIAA,CAAA,AJAA,CAAAtM,AhBiPuE,AxH+0B7B,CwH/0B8B,CAAC,CoBjPzE,AJAA,CIAA,A5IgkC0D,AwIhkC1D,AhBiP2E,GoBjP3E,CAAA,AJAA,CAAA,AIAA,CJAA,CxIgkCqD,AAAY,AwIhkCjE,AIAA,CJAA,AIAA,C5IgkCmE,AAGtD,AwInkCb,AIAA,C5IgkCoE,A4IhkCpE,CQYqB,A5B4OA,AgBxPrB4I,AIAA,C5ImkCgB,AoJvjCM,CpJujCD,CwH30BGgK,AgBxPxB,CIAA,ApBwPiC,AgBxPjC,CAAA,AhBwPkC,AxH20BF,A4InkChC,CJAA,AIAA,CJAA,AIAA,C5ImkCmC,A4InkCnC,AJAA,CxI+jCI,A4I/jCJ,AJAA,AhBwP8C,CgBxP9C,CxI+jCI,A4I/jCJjD,AJAA,CAAA,CxImkCwC,AwInkCxC,AxI+jCgC,CwI/jChC,AxI+jCiC,A4I/jCjC,CpBwPoD,AxHu0BlB,A4I/jClC,CpBwPqD,AxHu0BlB,A4I/jCnC,CpBwPsD,AgBxPtDpD,AIAA,CAAA,C5I4lCQ,AoJrlCkC,ARP1C,CJAA,AIAA,C5I4lCQ,AoJrlCoC,AZP5C,AIAA,CAAA,CAAA,A5I6lCU,C4I7lCV,AnN04BoB,CmN14BpB,AJAA,GIAA,CAAA,AJAA,CIAA,AQOqD,AZPrD,CxI6lCkB,CoJtlCqC,CpJwjCH,AvErLrB,CmN14B/B,AJAAA,GAAA,CIAA,AJAA,CIAA,AJAA,CAAA,CAAAC,AYOgE,C3Nm4BjC,CuEoNA,AoJvlCmC,ARPlE,CAAA,AJAA,CIAA,AJAA,CIAA,CAAA,ApBkR2B,CoBlR3B,ApBkR4B,AxH80BlB,C4IhmCV,ApBkR6B,AgBlR7B,CAAA,AIAA,ApBkR8B,A0BtG1B,A1BwGc,A4B5OG,CZxCrB,CAAA,AYO2E,A3No4BnD,CuEqNT,AwH90BkB,AgBlRjC,AYwCqB,CRxCrB,AQO6E,AZP7E,CIAA,CJAA5D,AIAA,AQwCqB,CRxCrB,A5IgmCyB,C4IhmCzB,CpBoRiC,AgBpRjC,AIAA,CJAA,AhBoRkC,CoBpRlC+G,AJAA,AhBoRmC,AxH40BN,CwIhmC7B,AxIgmC+B,CwIhmC/B,CAAA,AIAA,ApBqRkB,A0BxGC,CV7KnB,AIAA,CJAA,AIAA,CJAA,AIAA,AQyCqB,CpJujCgB,AoJzlCsD,AZP3F,AIAA,A5IgmCyC,CoJzlCmD,AZP5F,AIAA,AQyCuB,A5B4OI,C4B9QkE,AZP7F,AIAA,AQyCwB,A5B4OI,CoBrR5B,AQyCyB,A5B4OI,CoBrR7B,ApBqR8B,CoBrR9B,A5IgmC8C,C4IhmC9C,A5IgmC+C,C4IhmC/C,ApBqRiC,CAAC,CgBrRlC,AhBqRmC,CgBrRnC,CAAA,CAAA,CAAA,CIAA,AJAA,CIAA,AJAA,CAAA,AIAA,CJAA,AIAA,CJAA,GAAA,AIAAvV,CJAA,CAAA,CAAA,AIAA,CJAAkS,AIAA,C5IgmCmE,A4IhmCnE,CAAA,A5IgmCoE,CwIhmCpE,AxIgmCqE,A4IhmCrE,CJAA,AIAA,CJAA,AIAA,CJAA,AIAA,CJAA,CAAA,CIAAqD,G5ImmCkC,AwInmClC7P,AIAA,CAAA,CAAA,CJAA,AIAA,CJAA,CxIomCmC,AwIpmCnC,CxIomCoC,AwIpmCpC,CUsL4C,AVtL5C,AxIomCoB,CwIpmCpB,AxImmC0C,AwH10Bf,CxH20BD,AwIpmC1B,AhByR4B,CAAK,AgBzRjC,AIAA,CAAA,ApByRkC,CAAC,CgBzRnC8I,AIAA,E5IomCgC,CwIpmChC,AxIomCuC,CwIpmCvC,CUsL4C,AVtL5C,CAAA,EIAA,CAAA,CAAA,CAAA,C5IqmCa,CwIrmCb,AIAA,CAAA,AJAA,AxIqmCa,CADsC,A4IpmCnD,CJAA,AxIqmCyB,A4IrmCzB,CAAA,CpB0RiC,AoB1RjC,C5IqmC4B,AkJ96BM,A1BmGA,AxH20BF,A4IniCnB,CMqHqB,A1BmGC,GxHy0BmC,CwInmCtE,CxIqmCsC,AwIrmCtC,AIkEa,C5ImiC0B,AwIrmCvC,CAAA,ExIqmCgD,AwIrmChD,CAAA,CxIqmC4C,AwIrmC5C,CIkEa,A5ImiCgC,AAAM,AAE3C,AwIvmCR,CxIqmC8C,AAAM,AwIrmCpD,CxIqmC+C,AoJrjCnC,A5B4OA,AxH40BR,AwIxmCJ,ChB4Ra,AAAc,AgBlRpB,ChBkRqB,AAAG,CAAhB,CAAe,CxH40BrB,AwH50BsB,EgBlRlB,AIwDgBgH,Q5IsiCN,A4ItiCe,CAiCpC,C5IqgCqB,GAJmE,MAK5E,CAAiB,A4ItgCjB3U,CnNmzBF,A2Nr2BQ,ARkDNA,C5IugCR,AoJzjCe,ARkDPA,CpB2LD,A/LynBN,A+M74B6BwR,AIyFA,CpB0LT,AoB7R3B,CpB6R4B,C0BlGN,EN3LtBhZ,CAoGI,A5IsgCS,C4ItgCT,C5IsgCc,EAAS,CwH50BA,AAAO,CAAN,AAAO,AoB1L/B,CpB0LgC,AoB1L1BwH,CAAI,CJ1FsC,AxIgmCpB,AAGxB,A4IzgCM,CJ5EZ,AxIklC+B,A4IviC/B/K,C5IuiCgC,AAGb,CAHc,CAAC,A4IviClC,CAAA,AMiIoB,C1B6FK,A0B7FL,GNjIpB,CAAO,EJ1CEyS,CAAAA,CAAAA,CACAD,CACP,CAAA,CACA,CxIqlCkB,CoJxjCG,AAAC,ARUN,CQVM,ARUN,C5IijChB,CwIxlCMC,CAAAA,CIuCU,AJvCVA,CAAQD,AIuCE,CJvCE,AIwCpBxS,CJ3CS,CAAA,CI2CT,CAAA,EJ3CS,CAAA,CI2CT,CAAO,C5IsiC4D,GwIjlC1D,CAAAyS,CACA,CAAA,AxIwlCe,EkJp6BJ,AlJo6BgB,C4I9iCnB,CJ1CR,AxIwlC8B,A4I5iCvCzS,CJ5CS,AI4CTA,A5I4iCuC,C4I5iCvCA,C5I4iCuC,EwIxlC9B,AI4CTA,CAAA,AJ5CSwS,AxI0lCA,CwIzmCTxS,CAAAA,CxIymCyB,C4I9iClB,C5I8iCuB,A4I9iCvB,AJ3DPA,CAAA,AxIymC4B,CAC5B,CAAC,AAuDD,CkJx9B2C,A1BqHhC,CgB9TJ,CAAA,AI2DA,AQTD,CRSC,A5IsmCD,C4IrmCNA,AWnDS,CAAG,AHmGF,AGnGA,EXmDV,AWnDY,CXmDZ,IAAA,AJ5DO,CI4DA,AJ5DW,AxIiqC6B,CuJxpCP,EAAE,CfTpB,AeSoB,GfH1CA,CIuDAA,AJvDAA,CAAAA,AIuDAA,CAAAA,EJvDAA,CAAA,AIuDAA,CAAA,A5IomC8D,CAAK,CAAE,CwI3pC9D,AxI2pC+D,CwI3pC/D,AIuDA,CAAA,A5IqmCyB,CAAE,AuJxpCR,EAAG,CAAC,AHmGA,CpJqjCQ,CAAE,AoJrjCR,A3Nq2BJ,A8Nx8BI,CDyGpB,ACzGsB,CvJwpCY,A4IrmCvC,CUsD6B,ACzGA,AAAI,AXmDxB,EWnD0B,CvJwpCQ,CuJxpCN,AvJwpCQ,A4IrmChCoT,CWnD0B,EAAE,EAAE,EvJwpCS,AuJxpCP,CAAA,CAAA,CvJwpCc,CAAE,CAAC,A4IrmCjDA,AJvDb,CIuDaA,AJvDc,CIwDlCpT,GAAA,AJxDsC,CIwDtC,C5I2nCA,CwInrCsC,CAAA,AxImrCjC,CwIlrCLA,AIuDA,CAAO,C5I2nCF,CwIlrCL,AxIkrCU,CwIlrCV,AxIkrCW,IwIlrCX,CAAO,EIwDPA,CAAAA,CAAAA,GJxDcwc,AIwDdxc,CAAA,C5I0nCW,CAAA,E4I1nCJ,CAAA,A5IosCA,UwI3vCPA,AIuDO,CJvDPA,AIuDO,CACPA,AJxDAA,GIwDA,AJxDAA,CIwDA,AJxDA,IIwDA,AJxDO,CIwDA,AJxDA,CxI8hCP,QwI9hCO,CxI8hCE,AAAa,AwI9hCLyc,CWnBS,CP4E1Bzc,AO5E0B,CP4E1BA,CAAAA,AO5E0B,CAAA,CnJijCoC,C4Ir+B9DA,CAAA,IAAO,CpBwJ2D,AoBxJ3D,E5Is+BE,EAAK,CwH70BE,A0BnHZ,ACjHY,EnJijCF,IwI7hCdA,AIuDO,CJvDPA,AIuDO,CJvDPA,AIwDAA,GAAA,AJxDAA,CAAA,AIwDA,C5Iq+B6B,CAAC,EwI7hCtB,AIwDR,CJxDQ,AxI6hCkC,A4Ir+BnC,IO5EkC,EP4E3B2f,AO5E6B,CnJijCH,A4Ir+B1BA,C5Iq+B2B,EAAW,CAAC,EwI7hC7C,AxI8hCR,CwI9hCsB,AxI8hCrB,IwI7hCD3f,GAAA,CAAA,AIuDc2f,C5Iq+BmD,A4Ir+BnDA,C5Iq+BoD,A4Ip+BlE3f,C5Io+BmE,CwI5hCnE,CAAQ,AIwDR,CAAA,G5ImgCA,C4IngCA,CAAO,O5ImgCP,CAAA,CAA4C,AwI3jCpB0c,CAAAA,AxI2jCgC,CwH50BjB,AAAM,AxH40Ba,CwH50BX,CAAY,AAAlB,CAAQ,AAAU,CAAA,AAAhB,CAAQ,EAAE,EAAE,CxH60BzB,CwH70B2B,CxH40Ba,CwH50BX,CxH60BrD,AAA4B,E4IpgCC,A5IogC7B,C4IpgC6B,CJxDXA,AIwDW,CJxDXA,AIwDW,A5IogCD,CwIjjClC1c,AI6CmC,CAEnCA,EJ/CA,CAAA,AI+CA,CAAA,A5IkgC0C,AAAI,CoJvjCzB,CAAC,CZMtB,CAAO,AI+CP,CAAQ,C5IkgC4C,CoJvjCzB,CAAC,CAAC,CZMU,CAAA,OI+CjB,CAAA,CJ/C6B,AI+C7B,CAAA,AJ9CpB,CI8CoB,CMqEsB,ANpE5CA,CJ/CM,CAAC,AUmHqC,CNpE5C,CAAA,EJ/CY,CAAA,CI+CZ,CAAQ,SJ/CI,CAAa,AxIijCI,CwIhjCzB,EhBqO8B,EgBrO9B,AxIgjCE,CwIhjCG,AYPE,CpJujCK,CwH30BL,CAAC,CAAsB,EgBrOlB,CAAA,CxIgjCD,EAA2B,AAAI,EwIhjC9B,CAAM,AI8CgB,CAAA,CAAA,CAAA,A5IkgCc,C4IlgCd,CAEtCA,GAAA,CAAA,IJhDmC,AIgDnC,CJ/CI,AI+CI,CJ/CJ,GAAI,CACF,KI+CNA,CJ/CY+R,AI+CZ/R,CJ/CuB,AI+CvBA,CJ/CuB,EI+CvBA,CAAA,GJ/C6B,CI+CrB,CAAA,EJ/C0B,CAAA,OxI+iChB,C4IhgCV,CAAA,CACRA,GAAA,CAAA,A5I+/ByB,CAAC,GACf,AwIhjCuB,AIgDlC,CAAQ,EQvD4B,A5B6OpB,AgBrON,CxI8iCuB,AoJtjCI,A5B6OpB,CxHy0BiB,AoJtjCI,CpJsjCH,AvEhNlB,EuEiNE,CAAC,CwH10BG,AgBrON+R,ChBqOO,AxH00BmB,AwI/iC1BA,ChBqOQ,CgBrOK,CIgD9B/R,C5I+/BsD,A4I//BtDA,CAAAA,G5I+/BmD,A4I//BnDA,CnN8yB+B,AuEiNqB,A4I//BpD,C5I+/BqD,GwI9iC7C,AI+CA,C5I+/BwD,A4I//BxD,C5I+/ByD,CwI9iCzD,IAAA,AxI8iCkC,CwI9iC7B,ExI6iCkD,C4I9/BvD,A5IsmCR,C4ItmCQ,CACRA,C5I8/B6E,CAAC,CwI9iCtD+R,AIgDxB,A5I8/B+E,C4I9/B/E,AJhDwBA,CAAAA,CAAAA,CAElB,AxImpCG,AAAK,CAAY,A4IrmC1B,C5IqmC0B,A4IrmClB,C5IqmCkB,CAAoB,EwInpClC4K,AxImpCyC,CwInpCzCA,AxImpCuD,CwInpC5B,CxIopCrC,GAAM,CAAA,CwIppCqC,IAAK,AxIopC1C,CwIppC0C,AxIopC1C,CAAA,MAAA,CAAa,CAAE,CwJlrCM,CAAA,KZ4Ea,CAAA,CAAA,C5IqiCzB,A4IriCyB,CAAA,A5IqiCzB,CAAc,A4IpiC/B3c,C5IoiCkD,CAAE,C4IpiCpD,C5IoiC2D,A4IpiC3D,C5IoiC2D,CAAH,CvEpNvB,CmNh1BjC,CAAQ,IJ/C0C,EACxC,CAAA,MImDVA,CJnDiB2c,AImDjB3c,CJnD8C,AImD9CA,EJnD8C,CImD9CA,CAAA,IAAQ,CAAA,E5IgiCwB,CAAC,CwInlCa,GACtC,AxIklC6B,CAAC,AAAC,CAAC,EAAE,AAAG,AwIllChC,CxIklC+B,AAAE,AwIllCjC,IxIklCqC,E4IhiC1C,C5IgiC+C,A4IhiC5BgB,C5IgiC2B,CAAC,IAAA,AACzC,MAAA,C4IjiC2B4e,CAAAA,GJlD5B,CAA2BjD,GAElC,IAAK,CAAA,EIgD8BiD,CAAiBjN,GJhD/C,CAAO,KAAM,CAAA,CAAA,CIgD8C,CAAA,CAAA,CACtE3S,GAAA,CAAA,IAAA,CAAQ,C5IiiCA,CwH7yBK,KxH6yBH,CoJzjCK,A5B4QC,CAAA,SoBnPhBA,CAAAA,CAAAA,C5IgiCgB,AwIllCQ,ChBqSM,CgBrS+B,AIkD7DA,A5IgiC6B,CwH7yBN,AoBnPvB,AQzBuB,ApJyjCS,CwH7yBR,CAAC,A6BvRsC,ArJqkCzD,CwH9yBoB,A4B5QA,A5B6Qf,AgBtSuD,CIkD1D,AJlD0D,CIkD1D,ASpCuD,ADWnC,ApJyjCS,CoJzjCR,A5B4QA,AxH6yBS,CwH7yBR,CxH8yBtB,AwInlC8D,ChBsSzD,AxH6yBD,AwInlC4D,CAAA,AY0B1D,ApJyjCF,CwInlC4D,CAClE,KAAK,CxIklCC,CAAS,CAAE,C4IjiCf,AQxBoB,C5B4QC,A4B5QA,ARwBrB,CQxBsB,A5B4QA,AoBnP9BA,AJlDkB,ChBqSa,AgBrSb,EIkDlB,CAAA,EJlDkB,CAAM,CIkDxB,AJlD0B,CxIklCS,A4IhiC3B,C5IgiC6B,CAAG,CAAE,AwIllChB,CxIklCmB,AwIllCb,IxIklCiB,CAAC,CAAC,EwIllCT,CAAA,GxImlCtB,CwH5yBT,C4B5QC,CpJwjCe,AwInlCe,AhBuS7B,CxH4yBW,AAAG,AwInlCuB,CIkDpB,CAAA,CAAA,CAAA,CAAA,CAC9BA,GAAA,AJnD6D,CImD7D,AJnD6D,IImD7D,AJnD6D,CImDrD,AJnD2D,KAAK,GxIqlCnD,CAHgE,AwHzyB3D,CAAC,C4B3QnB,EZ9ByE,CAAA,CxIslClE,CoJvjCJ,A5B4QA,C4B5QC,ApJujCa,CwItlC6D,AImDjD,ApBwPxB,A4B5QA,CZ/B0E,AImDlD,CQpBtB,ApJujCU,CoJvjCT,AZ9BZ,AImDJA,ApBuPgB,CgB1SH,AImDbA,A5IkiCsB,AoJvjCL,CRqBjBA,AQrBkB,GRqBlBA,CAAA,CJnDa,CAAA,CAAG,CACV,AIkDE,CAAA,GJlDF,CAAK,IxIolC+C,EAAK,CwIplC7C,CxIolC4C,CAAS,CAAC,CAAC,AAKvE,CwIzlCsB,AIkDhB,CJlDgB,AIkDCgB,A5IkiC6C,CwIplC9C,CxIilCwE,AAQxF,EoJxjCM,EpJwjCgB,CoJxjCK,EpJyjC3B,EAAI,EAAuB,A4IxiCIF,AQhBrB,CRgBqBA,E5IyiC/B,EAAW,CoJxjCJ,ApJwjCK,CqJzjClB,C5Ns2BY,AuEmNiB,CAAC,CAAC,C4IziCMA,A5IyiCvB,AAAmB,C4IziCiB,AnNs1BxB,CuEkNoB,AACF,C4IziCQ,CAAA,CAAA,A5IyiCD,C4Ip7BrDd,A5Io7BsD,AAEpD,CwI7lCsB,AxI2lC2B,CAAC,C4Ip7BpD,AJvKyD,AxI6lC5C,C4It7Bb,A5Io7B6C,GwI3lCiB,CAAA,AIuK9D,CAAO,A5Is7BD,GwI7lC4D,AxI6lCzD,AAAI,CAAA,AwI7lCuD,CAAA,CAAA,CAC9D,CxI4lCO,C4It7BI,CAAA,A5Is7BmB,CwI5lCzB,AxI4lC0B,AAEjC,CwI9lCO,GxI8lCD,C4Ix7BckF,A5Iw7Bb,C4Ix7ByE,CJtKzE,AxI8lCW,AoJxjCH,CRgIiE,AJtKlE,CIjDpB,E5I+oCgB,CoJ1jCuC,CRrFvD3B,AQqFwD,ApJ0jCzB,CwI9lCL,AIjD1BA,A5I+oCmB,CwI9lCe,AIjDlCC,A5I+oC+B,C4Iv7B3B,CJtKE,AIsKF,ASjIkB,A5Nq2BF,AuEmN0B,CoJ1jCe,AZnCrD,AxIwlCoF,EoJrjC7B,CAAC,ARmI5D,CQnI6D,ARmIxD,A5Iu7B0C,CAAC,CAAC,AAAE,CoJ1jCa,AZnC5D,AxI6lC8C,CoJ1jCe,AZlC7D,AxI6lCF,CADoD,C4Iv7B1C,A5Iu7B2C,AAC5C,CoJ3jCyD,ARmIxD,A5Iu7B4C,CwI5lC/C,AYkC4D,CZlC5D,CYkC8D,ApJ2jCxD,CAAC,C4Ix7BJ,CAAM,AQnIwD,CpJ2jC9C,CvEpNkC,A2Nv2Bc,CAAC,EAAE,CAAC,CZlCvE,CYkCyE,AZlC3D,CACrB,CawC0C,CbxC1C,CACF,CYgCuF,AZ/BzF,CAqBAxD,CYU2F,AZV3FA,CAAAA,AxIqkC8C,CAAC,CAAC,CAC9C,AwItkCFA,AxIqkCiD,CwIrkCjD,AxIqkCkD,AAC/C,AAyBD,CA1BiD,GwIrkC5C,CAAA,AhB0RU,CxHq0Bf,E4Il9B8C,CAAA,AQnIyD,CRoIvG,AJ9IK,AYUmG,CZVrE,CxIokC2D,AoJ1jCY,ApJ6jC7F,I4Iz7BPqD,CAAAA,AJ9IoCzB,CI8I/BsD,AJ9I+BtD,AxIukCd,C4Iz7BT,AJ9I8BO,CI8I9B,AJ9IuCya,CAAAA,CAAAA,AI8IvC,C5Iy7BK,C4Iz7BE9X,A5Iy7BD,CAFgD,AwIrkCD,CxIukCpC,AwItkCpC,CxIskCqC,CAAC,CAAC,CwItkClC,CAAA,KxIykCI,AAAM,CAAA,C4I57B0B,EAAA,CAAE,GJ7ItC,CxI2kCH,CwI1kCF,CAAA,EYkBY,ApJwjCJ,A4I97B4C,C5I87B3C,CAAG,A4I97BwC,CACpD,C5I67BqB,AAL0C,AwIrkCzDsK,CYkBsB,AZlBftE,CAAAA,CxI2kCX,E4I97BI,AQ3HmB,A3Ns2BnB,CuEkNc,AoJxjCa,ApJwjCN,AvElNrB,C2Nt2B4B,ApJwjCN,AACrB,CADsB,C4I77BvB,A5I67BwB,AACJ,C4I97Bf,CQ3H2B,CpJyjCR,AoJxjCZ,AADqB,CAAC,AZlB3BA,CYkB4B,AZlBhB3I,CAAO,CAAA,CAChC,EYkByB,ApJyjCvB,CADoC,AoJzjCS,CCW7B,ADTG,AZnBjB4P,CYmBkB,AAF2B,AZjBlC,CxI2kCP,AoJ1jC0C,AZjBnC,CYiBoC,CAE1B,EZnBV,CAAK,AxI2kCP,AAAK,EAzSJ,C4ItpBmB,AQxHX,CpJujCL,C4I/7BgB,A5Ig8BzB,C4I/7BR,C5I+7BQ,CwI5kCqB,CI6IzB,A5I+7Bc,AwI5kCW,CI8I3B,EQzHyB,AZrBE,CxI4kCP,AwI5kCWnQ,CI8I1B,A5I87BgB,AwI5kCe,CI8I/B,AQzHuB,AZrBQ,CAItC,CxIukCmC,CoJvjCO,CZnBtC,AhBiS8C,CAAC,CoBpJ5C,C5I87BwB,A4I97BjB,C5I87BkB,CAAC,CAAC,CwI3kCvBmQ,AhBiS8C,AxH0yBtB,C4I77B/B,CAAA,CACE,AJ/IkB,ChBiSqC,CoBlJvD1O,CAAAA,AQ3HyC,CR2HzCA,AQ3H0C,CR4H1C,A5I27BqC,EAH0C,AAGxC,CAAC,AACtC,CADuC,AACtC,CoJxjC6C,ApJwjC1C,CwI3kCV0O,AI+IY7M,ApBiJyD,CoBjJzDA,A5I47BG,C4I57BHA,ApBiJ2D,CoBjJnD,ApBiJoD,AgBhSxE6M,AYmBwD,ApJwjCzC,CwI3kCfA,AxI2kCkB,CwI3kCP,AYoBc,A3Nq2BR,AuEkNE,CAHuE,AAGtE,AACpB,CAFsD,AwI1kC1C,A/M03BX,C+M13BW,CAEV,AI8IE,A5I47BA,C4I57BA,A5I47BC,GAAK,CoJvjCK,AAAE,CR2Hb,CJ9IKA,AI8IL,A5I47BS,AAAE,CwI1kCNA,AI8IExO,CJ9IO6L,AI8IPlK,CJ9IW,AI8IXA,CJ9IW,AI8IXA,AQ1HG,CR0HK,ASvGD,CbvCU,CxIykCS,AACf,CqJxiCN,GrJ4iCV,CAAC,CAAG,C4Ih8BC,C5Ig8BI,EAAK,C4Ih8BT3B,AJ7IX,CxI6kCyB,A4Ih8BdA,A5Im7BH,CAakB,CAAG,EAAI,CAAC,A4Ih8BvBA,A5Im7BE,AoJxjCI,CpJqkCkB,A4Ih8BxBA,A5Im7BG,AwIhkCP6L,CAAAA,AxI6kC6B,AAbrB,A4In7BJ7L,CJxIb,AIwIaA,A5Ig8B0B,CAAC,A4Ih8BX,E5Ii8BvB,AwI5kCNwO,CxI4kCO,AwI5kCPA,ChBoRkC,AgBpRzB3C,CI4IL,AJ5IS,CI4IT,A5Ig8BQ,AwI5kCC,CI6IT,AQvHe,AZtBFjN,CACjB,CAAA,AxI2kCe,AoJtjCS,EAAD,EZrBvB,CAAK,EhBmRyC,AxHyzB5C,CwHzzB6C,GxHyzB7C,EAAe,AAAiB,CwI5kCpB,AhBmRuC,AxHyzBlB,CuJxpCc,AvJwpCb,CAAlB,AuJxpCgC,CvJspCgB,AwI1kChDP,AxI4kCC,CwHzzBsC,AxHyzBrC,AwI5kCFA,CAAAA,AxI4kCG,CvEhND,A+M53BKmQ,CAAQ,CAAA,CAE7B6K,AxI0kCsB,CwHzzBqC,AgBjR7CC,AxI0kCS,CAAC,AAAW,CwHzzB0B,AxHyzBpC,CwHzzBqC,AgBjRhDA,AxI0kCY,CwHzzBqC,A+B/VvB,AvJwpCb,CuJxpCc,AvJwpCb,CAAC,C4I/7B/B,A5I+7B2C,C4I/7B3C,A5I+7B4C,C4I97B5C,A5I87B6C,CAAC,CAAC,CAAG,G4I97B5CW,A5I87B+C,C4I97B/CA,A5I87BgD,AACtD,C4I/7BY,A5I87B2C,C4I97BxCna,A5I+7BH,CuJxpCO,AvJupCqC,AAC3C,C4I/7BEA,AJ5ICwZ,CI4IC,AJ5IiB,CI4IZrZ,CAAAA,EAAAA,CAAAA,CAAAA,CJ5IqB,AI4IrBA,CJ5IqB,AI4IrB0B,CJ3ItB,AI2I8B,A5IssBzB,AA0P6B,C4Ih8BJ,AWxNW,AvJwpCN,CAAC,CuJxpCO,CvJwpCL,CAA1B,AAA2B,CuJxpCpB,Af6EbyX,Ae7EwC,Cf6Eb,AI2IH,AWxNiB,CAA1B,Af6EY,CxIi1BnB,AuJ95BmC,CXwN3B,AWxNC,AAA2B,CAA1B,CvJk6B1B,AwIr1BmC,CAAK,AxIo1BtB,AAsO6E,C4I/6BvEnZ,CAAAA,A5Ii8BD,CAAC,AuJxpCQ,CvJwpCP,CuJxpCS,AvJwpCR,AA5Pb,CA4Pc,C4Ij8BHA,AWvNY,CvJ45BR,A4IrsBJA,AWvNa,CXuNbA,CAAAA,AWvNe,CXuNS,AWvNR,AvJi6BN,EuJj6BQ,AvJi6BH,C4I1sBgB,AWvNZ,AvJqpCqD,AApPxD,CAAC,CAAC,AuJj6BG,CXuNU,AX5NP,AsBKF,AvJi6BH,CAAC,AiIt6BI,CsBKA,AXuNS,CACvD,AWxN+C,CXwN/C,A5IysB2B,C4IzsB3B,A5IysB4B,AuJj6BqB,AvJypCnC,CuJzpCoC,AvJi6BrB,AAwPd,CAxPe,AwIr1BiC,CxIq1BhC,AwIr1BgC,AxI6kC9C,C4Ij8BjB,AQpH0B,AGnGA,CXuNrB,CJ5I0D,CAAI5B,CAAK,CxI+kCnD,AwI/kCmD,CxI+kClD,AuJxpCM,CAAA,AfyEiD,ExI+kC9C,AwI/kC+C,CAC9E,KAAK,AxImmCyB,E4Ix9BR,AY1Nc,AAAM,CZ0NpB,AY1Ne,CxJkrCW,CArBgB,CuJxpCf,AvJqpCiB,CA2BpE,A4I39BwB,AWrN4B,AvJ6qCb,AwJlrCI,CZ0Nd4b,AY1Ne,AxJkrCU,C4Ix9BtB,A5Iw9BuB,CAAC,A4Ix9BxB,CAC9B,A5Iu9BuD,EAvBT,AAyB1C,AACC,I4I19BCpY,CAAAA,CAAS,I5NgCL,CwN5KoB,AxI8kCqD,AhFl6BzE,CwN5KoB,AI4IT,A5NkCzB,CyI/JwC,AzI+JxB,CAAA,CACkD,AwN/KhC,CAAIxD,AI4Ib,CAAK,AJ5IeT,CAAAA,CAAAA,CAAAC,GAAA,CAAA,CI4IN,CAAA,AJ5IM,CxImmC2C,AwIlmC/Eub,CADoC,CAAA,CAAA,CAEvC,CAACvN,CI0IgC,AJ1I5B,CI0IoClK,CAAO,AJ1IxC/C,CI0IwC,AJzIlD,CI0IA,AJ1IA,CAAC,ExN8K8B,AwN7KjC,C7MyOgC,AiItRI,A4E+CpC,C5E/CoC,EgFsL7B,AhFtL6B,IgFsL7B,AJvID,CIuIC,ChFtL6B,A5I0NoB,IwN3KlD,ExN2KkD,EwN3KlD,CAAK,MIuIJ,CAAmB,EJtInBiN,CAAAA,CIsIwB,AJrIjC,CIqIiC,AJnIjCpP,CAAAA,CAAAA,GAAAA,CAAA,IAAO,CAAA,KAAA,AImI0B,CJnIK4B,AImIY,CJnIF,EAAA,CAC9C,EIkIwDgO,CAAAA,CAAAA,CJlInD,CIkIyDA,CAAM4N,GAAAA,CAAG,CAC9DpY,CAAAA,CACT,CAASJ,E5NmCoC,CAAC,AwNvK3B,CxNuK2B,CwNvK3B,CACnB,AImISA,CAAAA,CAAG,CACV,CJpIE+M,AxNsK0C,CwNtK1CA,CAAW,GIoIb,CJpIkB,AxNsK0B,CwNtK1B,EIoIlB,CAAK,KJpIa,CIoIN,AJpIe,CIoIf,EJpImBnQ,CAAAA,CAAK,CIoIxB,CJnId,AImIoB,CAA8ByB,MJnI9C,OAAO0O,CAAa,EAAA,WAAA,AImI0B1O,EAAAA,CAAE,AJlIlD0O,CIkIoD,AJlIzC,CAAA,AIkIyC,CAAA,CJhI/CA,AIiIC/M,CJjID+M,AIkIP,CJlIOA,AImIT,CJlIA,AIuVA/R,CAAAA,CAAAA,CJrVAA,EIqVAA,CJrVA,AIqVA,CJrVA,GIqVQ,A5NrL0C,CwNhKlD,AIqVQ,CJrVD,eAAmD6R,CAAAA,CAAAA,AIqVlD,CAAmB,CJrV0C,CACnE,EIoV+B,CAC1BgO,CJrVL,CAAK,IIqVO,EAAA,GACZ,IJtVmB,EAAA,CACnB,KIqVa,CJrVP9N,AIqVO,CJrV8B,CAAA,EAC3C,AIoVa,CAAK,AJpVlB,IAAA,MAAWnQ,CAASiQ,AIoVS,C5NjLvB,A4NiLuB,C5NjLvB,A4NkLN,EJrVoBA,CAAAA,CAAQ,AIqVvB,CJpVH,AIoVG,K5NjLE,CwNnKC8K,EAA2B,GIoV9B,CJpVmC,AIoVrB,CJpVqB,SIoVV,CAAA,I5N9KY,A4N8KN,CArcxC,E5NiR6D,EAMf,A4NvR9CpZ,CAAAC,CAAAA,CAAAA,C5NuRwD,A4NvRxDC,CJiH4C,AIjH5CwM,CJiHqE,AIjHrEA,CAAAA,CAscM,CJrVmErO,CAAAA,CAAK,AIqVpE,CJrVyE,AIsV3E,C5NxLqF,CwN9JV,EAC7EmQ,AIqVO,CAAA,AJrVPA,CAAAA,CAASnQ,CAAK,CxN8JyE,AwN9JrE,CAAA,CIqVX,CAAO,IJrVI,AxNqKwD,CwNrKjD,AIqVL,CAAA,EAAI,CAAA,C5N7Kd,CwNxKsB+a,CAAAA,CAAwB,EAC1D,CACA,OAAO5K,CACT,GAEA/R,GAAA,CAAA,ExNmKsB,EwNnKtB,CAAO,KAA8B,CAAA,CAAC4B,CAAOO,CAAAA,CAAAA,GAAY,CACvD,IAAA,CAAK,GI+UsE,CAEvE8N,CAAAA,CAAAA,C5N9KwB,A4N8KxBA,ChFrY6B,AgFqY7BA,CAAAxM,CAAAD,CAAAA,CAAAA,CAAAA,CAAAA,CJhVJ,AxNoKY,A4N4KRD,CJhVJ,AIgVI,CAAA,IAAA,CJhVEwO,AIgVG,CJhVQ,CAAA,IAAA,CAAK,CIgVlB,EJhVsBnQ,CIgVtB,AJhVsBA,CAAK,CACzBwN,CAAAA,CAAAA,AI+UF,CJ/UStE,AI+UT,E5N5MuD,C8CoFpB,E8KwHnC,CAAA,CAAAvH,CAAe,CAAA,GJ/UMpB,CAAO,CAAA,CAChC,II8UmB,GJ9UZ,AI8UH,IAAAqB,CAAAA,E5N3KwB,AwNnKduO,ClE5GmB,AkE4GV3C,ClE5GW,AkE4GXA,CAAI,AI8UvB5L,CJ9U6B,AI8U7BA,CAAAA,CJ9U6B,AI8U7BA,C5NvKuB,A4NuKI,ChF5XP,A3FgOD,AxCpCR,KmI5LS,AgF4XpB,GAAA,CJ7UN,GI6UM,AJ3UNxD,CI2UM,EJ3UN,CAAA,EI2UM,CAAA,CJ3UN,AI2UMyD,CAAmC,AJ3UlC,CI2UkC,IJ3UJ,CAAA,II2UI,EJ3UG7B,CAAOO,AI2U7C,CJ3U6CA,CAAAA,EI2U7C8N,CJ3UyD,CI2UzDA,AJ1UJ,AxNqKM,C4NqKFA,CAAA,A5NrKE,EAAA,AwNrKN,CAAK,CI0UDxM,CAAAA,CAAAA,EACF,A5NrKK,C4NqKIuB,C5NrKE,GAAU,E4NqKZA,CAAAA,CAAG,CJ1Ud,AI2UI,A5NpKI,CwNvKR,CxNuKQ,E4NoKJ,CAAK,EJ3UH+M,CAAW,CAAA,CxNuKF,C4NoKC,A5I9DE,C4I8DF,CJ3UC,CAAK,CxNuKF,C4G+YV,AgH3OM,CAAK/M,CAAIA,CAAAA,CAAAA,EAAA,G5NnKd,C4NmKcA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAa,EJ3US,CAAA,GAAA,CI2UF,AJ3UMpD,CAAK,CAAA,AI4UtD,CJ3UF,AI4UA,CAAA,CAAG,CJ5UC,GI4UI,CAAA,E5NjKV,CAAC,AwN3KYmQ,AjOmRZ,AqKtWK,C4DmFOA,A5E1CToD,ArF8QA,AvDzDF,EwN3KwB,IxN4KT,CAAA,EAAA,G4NgKS,CJ3UtB,AI4UJ,CJ5UI,CI4UJ,CAAA,CAAA,CAiGAnV,GJ1aE,AI0aF,CAAA,E5N/P2B,E4N+P3B,CJ1aQoP,AI0aA,C5NhQN,AwN1KMA,CAAOtE,CxN0Kb,GAEO,CAAC,CAD4B,AAC3B,EAAM,EAAA,CwN5KU3I,CAAAA,CAAO,CxN4KjB,CwN1Kf,CIwa0BwF,C5N9PX,A4N8PWA,CAAAA,E5NhQA,A4NgQ4B,CACtD,CJzaOoK,CAAAA,CAAS3C,CIyahB,AJzaoB,CIyaf,AJzae,CAChB,MAAO,CAAA,GxIujCqC,CwIvjCrC,AxIujCsC,CAAC,AwIvjClC2C,CAAQ,CAAA,CAAE,CxIujC4B,CAAC,A4I/oBhCpK,C5NhQoD,A4NgQ7C,CAAA,CAC9B,IJzaqC,AIyahC,CJxaH,AIwaG,CJxaH,AxIsjC8D,CAAE,AADxD,CACyD,CoJvjCnD,ApJujCoD,CwItjClE,CAAK,CxIqjCQ,CAAC,EwJlrCM,CJ4HC,C3Nq2BP,A+Nj+BQ,GxJmrCuD,CAAE,A4I9oB5E,C5I8oB6E,CAAC,C4I7oBrF,CAAA,CYriBwE,AZqiBxE,CAEA3H,A5I2oByF,CAAC,AwJlrChB,CxJkrCiB,AAC7E,C4I5oBd,CAAA,A5I4oBoB,EACpB,CAAC,CwIxjCiC,AI2alC,CnN2bqB,AuEiNI,A4I5oBjB,AJ3a0B,CxIujCR,CAAC,AwJnrCyD,CxJmrCxD,CwJnrC0D,ExJusCtF,AwI3kCkC,CYCE,AZDK4B,CYCJ,AZDS,CAAA,CAE1C,EYDqC,EI7HuD,AhB8HvF,CxIykCA,AACP,AwI1kCO,CxI0kCP,CAAA,C4IjqByB,A5IkqBb,C4IlqBa,A5ImqBzB,CoJ3jCqC,ApJ2jCvB,CACd,CoJ9kCiD,CAAC,AR0anB,AQxZkB,ApJ4jC1C,CoJ9kC4C,AAkBV,ApJ4jCpB,A4InqBrB,CQzZ0C,AAlBU,EAAE,CpJsjCH,A4I3oBnD,CAAK,C5I2rBD,CoJtmCsD,ApJsmC9B,CAAC,AADzB,AvEzNE,EuEqMN,AwJvqCU,CZigBE,C5IsqBF,A4ItqBE,G5IsqBU,AAoBY,AwIpmC3B,CI0aK,AnN8cO,A+Mx3Ba,CI0af,AQ3amD,AAoBxC,ApJ6jCrB,CoJjlC8D,AAoBxC,CRuZX,AQ3aoD,CR2ajD,AQ3akD,AZCnCA,CAAOmQ,CYD8B,AZC9BA,CAAQ,CxIglCpB,AAoBY,AwIlmC3C,CxI8kCiC,AAoBW,AwIlmC5C,EYH8E,EAAE,EZG1E,CxI8kCkC,CAAC,AACjB,CADkB,AwJxrCb,ChB0GlB,CgB1GoB,AhB0GpB,EgB1GsB,EAAE,GJuG2D,AIvGxD,AhB0G3B,CYHoF,ApJklC5D,CoJllC6D,AIvGxD,AxJyrCH,CwJzrCK,AhB2G5C,CAAA,CgB3G8C,AhB2G9C,CIua6C,AJra7C/R,CIqa6C,CAC3C,EJtaF,CxI4kCgD,CAAC,A4ItqB1C,CAAA,A5IsqB2C,CACxC,AwI7kCH,CxI6kCO,AwI7kCP,CgB5GS,AJ4HG,IZhBZ,CAA8B,GYgBlB,CpJ6jCI,EwI7kCqB4B,CAAAA,CIsarC,CJta+C,CIuapD,AJtaA,CIsaA,C5IsqBuB,CoJ7jCK,AAAC,CI5HI,AJ4HJ,AZf7B,CxI4kCkC,AwI5kC7B,AIsaL,CAAK,C5I0qBL,CwJ1rCK,CAAC,CAAC,AxJyrCP,CwJ1rCK,CZihBO,AYjhBN,CAAC,AxJ0rCY,A4IzqBP,GYjhBF,AxJ2rCN,CwJ3rCO,AZihBC,CAAKyL,AYhhBP,AhB0GS,CgB1GR,ChB0GQ,CACnB,KAAK,CxI+kCW,CwJ1rCK,AJ4HA,CAAA,GRoZW,CAAA,CJralB,CxI+kCc,AAAI,AwI/kClB,CgB1GC,CJ4HK,CI5HH,AAAI,ExJyrCgB,A4I1qBE,C5I0qBD,AwI/kCxB,CIsahB,AJtauBzL,CIsavB,AJta4B,CAAA,AIsa5B,CAEA5B,AJvaE,GIuaF,CAAA,AJvaO,CAAA,GIuaP,CAAQ,oBJvaD,CIuauB,AJvaE,CIuaF,IAAM,CAClC,AJxaqC4B,CAAAA,CAAK,EIwa1C,AJvaA,CIuaK,C5IuqBU,IAAX,AwI9kCE,CIuaM,CAAA,C5IuqB2B,CwI9kCjC,CxI8kCkB,AwI9kCb,AcwBI,CV+YH,A5IuqBF,C4IvqBO,EAAC,CAAG,E5IuqB2B,AwI9kC7B,GACrB,AxI6kC8B,CwIrsC5B,CAAA,CAAA,AxIqsC+D,GAA7B,CwIrsClC,CAAK,AxIqsC+D,GAAhB,EAAgB,CwIrsCtDkb,CAAAA,ExIqsC4C,EAClD,AAAI,CwJzrCG,AAAI,CJ4HH,AI5HA,CAAK,CJ4HC,CpJ6jCL,CAAA,E4IxqB6B,CAAA,CAC9C,IAAK,CAAA,AJ/hBSA,CAAoBrK,EAAQ,IAAK,CAAA,IAAI,CACnD,CAAA,EI8hBK,CAAmB,CJ9hBxB,CI8hByB,AJ9hBpB,CI+hBL,GJ/hBYD,CI+hBP,AJ/hBOA,AxIssCZ,C4IvqBK,CJ9hBP,CAyBA,CxI4qCQ,EAAA,AAAsB,CwI5qC1B,GY+GkC,CAAC,EpJ6jChB,CAAe,CAAb,CwI5qCH,AxI4qCd,AoJ7jCoC,CZ9G1C,IIogBK,EY5hBM,CZ6hBb,AJrgBSuB,CIqgBT,C5IsqB0C,A4ItqB1C,CAEA/T,EY/hBa,CZ+hBb,CAAA,AQzZmD,CpJ8jC3C,CoJ9jC6C,ApJ6jCJ,AwJxrCpC,CxJwrCqC,AwJxrCrC,CZohBb,AYphBa,CxJwrCuC,A4IpqB5C,C5IoqB6C,CAAC,AwJxrCzC,CxJ2rCR,CoJhkCuD,AZ9GlC,CAAA,CY8GoC,ApJikC5C,CwJ3rCH,AJ0HgD,CIzHrC,ChBWA,AY8GuC,CZ9GlC,AY8GmC,EAAE,IZ9G/B,AxI+qCjC,CoJjkCqE,AZ7GzE,CAEA,CY2G2E,GZ3GvE,CgB3BS,CZ+hBqBgC,CAAAA,C5IyqBvB,A4IzqBuBA,AYlhBR,EZkhByB,CACjD,IYhiBW,AZgiBX,AQ1ZuF,CR0ZlF,AQ1ZmF,AZ3GzE,CACf,CY0G0F,AIvHpE,IZihBV,CAAA,CJpgBL,IIogBK,AJpgBA,AxI6qCV,CwI7qCU,AIogBM,AYjhBT,AJ4HA,CRqZgCA,CnNgdlC,I+Nh/BI,A/Ng/BJ,EuEyNK,CAAC,CwJ1rCO,CxJ2rCF,AAAhB,CwJ3rCoB,ChBaV,CAAgB,EcuHb,EdvHkB,CAAA,EIogBQA,EAAAA,CAAAA,CAAM,CJpgBd,CAAU,CgB5BhC,AxJ0sCF,EAAG,CwI9qCoC,AxI8qCnC,C4I1qByC,AJpgBN,CIogBM,CAAE,CACxD,CAAA,AJrgBgD,AxI+qC3C,CwI/qCgD,ExI+qCvC,C4I1qBd,A5I0qBe,C4I1qBV,AnNidW,CuE0Nd,AwJ3rCuB,CAAM,AJ6HtB,CI7HkB,AACb,CJ2HU,ApJ8jCJ,AwJzrCL,CADc,AJ4HJ,CRoZb,AY/gBK,CZ+gBL,A5I2qBJ,AAAI,CwJ1rCO,AAAI,EAAF,AAAI,CZ+gBb,CAAKqL,AY/gBU,AxJ0rCV,CAAC,CwJ1rCW,CAAC,CAAC,AhBU4C,IAAO,CAAA,IAAA,CAAK,AIqgBvD,CAAA,GJpgBlC,CAEA,CIkgBkC,CAAOrL,CAAK,CAAA,AJlgB1C,CIqgBF,IAAK,CAAA,MAAA,CAAO,KAAM,CAAA,OJrgBhB,EAA6B,CAC/B,OACE,KAAK,WxI2qCqF,CAAC,CwI1qC3F,AxI0qC4F,AAI9F,CwI9qCE,AgBbG,EAAE,EhBaL,CAAK,CgBZI,IxJ2rCE,E4I7qBqD,AJjgBhE,AxI8qCkB,C4I5qBpB,AJlgBE,AYgHkB,CRkZpB,AnNmdQ,A2Nr2BQ,ApJ8jCC,CoJ9jCA,CpJ8jCO,CwI9qCtB,CgBnCS,AhBmCJ,AxI8qC2B,A4I5qBlC,CAAK,AnNmdqB,CuEyNU,AAAC,CAAC,CwJjtC3B,AhBmCC,AxI8qC4B,CwI9qC5B,CcuH8B,AtJujCA,AAAC,CAAV,CAAW,CAAC,GAChC,CAAC,AwJ1rCMwgB,EZ6gBA,CY7gBO,AxJ6rCnB,CwJ7rCoB,AxJ6rCnB,AyJnvCQ,AzJovCP,AAAW,C4IhrBvB,AY3gBoB,AACG,CZ4gBvBxiB,AatkBqB,AACG,CbqkBxBA,AY7gBsBqiB,ACxDG,ADyDW,CZ4gBpCriB,AY5gBqC,CAAV,ACzDA,ADyDW,CAAV,AxJ0rCV,C4I9qBlBA,AJrgBc,A/My9BI,A+Nh+BW,C/Ni+BP,A+Mz9BlB,AIogBJ,AY5gByC,CCzDV,AzJmvCC,CwJ1rCA,ACzDA,ADyDW,EhBSvC,AImgBI,CJngBJ,AImgBI,E5I8qB0B,CwJ1rCW,AACtB,ChBQnB,CAAK,AgBRmB,CxJyrCU,CwJzrCX,AxJyrCwB,CwJzrCvB,CAAa,ChBSrC,CgBTuC,CAAC,CAAC,CxJyrCa,CwJttC7C,AxJstC8C,EAAE,CAAC,AACxD,CADyD,AACxD,AAAC,CwJzrCS,EAAE,AACF,EAAE,CFoIoC,AtJojCxC,E4I/qBP,AYzgBe,AFoIgC,AtJojC9B,C4I/qBW,A5I+qBV,A0JxvC5B0Y,AFgEkC,AxJyrCxB,CwIhrCR,AgBV2B,AACM,ChByFjC,AgB1F4B,AAAQ,CAAP,AAAQ,AxJ0rC7B,C4IhrBkC,AY1gBJ,AxJ0rCzB,C4I/qBX,A5I+qBY,CwJ1rCkB,C/Nm+Bd,A+Nn+BuB,ChB0F3B,CIibP,AY3gBoC,CZ2gBpC,AY3gBqC,CAAC,OZ2gBtC,A5I+qB2B,C4I/qBlB,EAAGoH,A5I+qBkB,AAAC,C4I/qBnBA,E5I+qBmB,EwIhmCxB,AxIgmC8B,CwIhmCX/N,CAAqD,CAAA,CACpF,ExI+lCgD,EAExC,AAAC,EwIjmCH,CxIimCW,AAAW,GwIjmCtB,AgBtFiC,ChBsF5B,CxIimCsB,G4IjrBhB+N,CAAwB,AJhbzB,ExIimCiB,CAAA,EAAA,EwIjmCT,AxIimC4B,A4IjrBF,CJhb1B,AIgb0B,IAAA,CAAK,EJhb/B,CACtB,ExIgmC6D,CwJ1tCpD,AxJ0tCqD,CwIhmCzD,CAAA,AxIgmC2D,CAAC,CAAC,AAElE,CwJxrCgD,AxJwrC/C,CwJxrCgD,AxJwrC7C,CwJxrC8C,CxJwrCzC,E4InrB4D,AnN8d/D,CmN9d+D,A5ImrB5D,CwIlmCJ,AIgbP,CJ/aE/C,ExIimCiB,C4IlrBd,A5IkrBe,C4IlrBf,C5ImrBL,CvEtNqB,A+Nj+BQ,AxJurC5B,AAAC,CwJvrC4B,ChBqFnBhL,CAAAA,CAAQ,CACnB,CI8aK,A5IkrBwB,AACpB,C4InrBK,AJ7ahB,AgBvFsC,AxJsrCN,CwI7lChC,AxI6lCiC,AwJprClB,AxJqrCG,C4InrBC+N,A5ImrBA,C4InrBAA,AYpgBsB,CFgJrB,AEhJsB,GhByF5B,CgBzFgC,CxJwrCnC,CsJniCU,AtJoiCnB,CwJzrC+C,AxJyrC9C,CwJzrC+C,ExJ0rC5C,CAAC,CwJrrCK,EAL4C,AxJ2rClD,CvEnND,E+Nx+BsD,AxJ2rC7C,EAAK,EAAD,C4IvrBCA,CYpgB8C,AZogBtB,CYpgBuB,AF0J9C,GtJiiCO,G4IvrByB,A5IsrBvC,C4ItrBuC,IAAA,CAAK,CJ3a3C,AxIimCM,CwIhmClB/N,AxIimCoC,CwIhmCrB,AxIimCX,AsJ7hCe,CEvJK,AhBmFT,CACf,CgBnFW,CAAA,EAAA,EhBmFL,AxIgmCuB,IwIhmCvB,AxIgmCuB,CwIhmClB,AIwa4D,A5IwrBrC,C4IxrBqC,CACvE,A5IurBkC,EwIhmClB,CAAA,CIyaX,CAAA,A5IwrBC,CAAA,EAAA,CAAG,CwIjmCO,CAAQ,CxIimCb,C4IxrBN,A5IwrBO,C4IxrBE,AY1fG,AxJkrCH,CAAG,C4IxrBA+N,AY1fG,CZ0fHA,A5IyrBX,CsJ3hCY,AtJ2hCX,CwIjmCL,AxIimCQ,EwJlrCQ,CF4JE,Cd3Eb,AgBjFW,ChBiFX,AxIkmCD,EAAE,AAtZD,GAsZI,AAAK,CAAC,CADiB,AArZpB,AAsZI,EAtZJ,AAsZM,CACd,EAAK,CsJxhCkC,AE1J7B,CAAC,AxJkrCD,CAAC,AsJthCZ,CV2VYA,A5I0rBU,AACZ,AAAK,C4I3rBqB,AU5VV,EtJwhCzB,EADmB,AACd,CvEjNH,CuEiNQ,CAAC,CAAG,AwJlrCA,ChB8Eb,A/Mk5BmB,A+Nh+BL,ChB+EnB/C,AIuamD,CAAA,A5I6rB/C,EADmB,AACf,E4I7rB2C,AnN4e7C,AuEiNQ,C4I7rB0C,EJva/ChL,AgB9EU,ChB8EVA,AxIomCS,CwIpmCD,AxIomCE,CwInmCrB,A/Mk5BkB,EuE+M0B,AwIhmC9C,CAEA,Ac2EoB,Md3EN,ExI+lCgC,G4I5rBiC,CAAA,CAC7E,G5I4rByC,C4I5rBpC,A5I4rBoC,C4I5rBpC,C5I4rBwC,EAJ4C,AAI1C,AAAE,CsJjhCnB,CtJihCqB,CAAC,CAAE,C4I5rBjD,AJpa6E,CAClF,AImac,EAAG+N,CAAAA,G5I4rB6C,AwI/lCxD/N,CAAW,CAAA,AxI+lC+C,CAAC,CAAC,IwI/lC3C,ExIgmCnB,CAAC,CwIhmCuB,AxIgmCtB,CwIhmCsB,CxIimClB,AACH,CwJlrCQ,CxJirCA,CwIjmCa,AxIimCZ,CwIjmCiB,AgBhFf,AxJirCJ,AAAG,CAAA,C4I9rBA+N,CAAwB,A5I6rB1B,CADqE,CAGvE,CwJnrCK,ChBiFuB,CAAA,AImaO,A5IusBhD,C4IvsBgD,GmB7iBrC,CnB6iBqC,CAAK,CJnaZ,CACvC,KAAK,GxIymCU,KAAK,EwIxmCtB,CAAA,CACA,EuB7ImC,CnB6iBwC,A5IwsB3E,E4IvsBF,CAzeE,CJwEO,AIxEP,CAAA,GEpGa,C9IoxCJ,A4IhrCT,A5Io6BA,C4Ip6BK,CJwES/N,CAAa,EAAA,AIxEfhH,CAAAA,CAAAA,CAAK,IACjB,CAAA,GJuE2B,CIvE3B,AJuEyCiS,CIvEpC,A5Im6Ba,CAAmB,G+I59BkC,E/I69BjE,A4Ip6BQxJ,CJuEoCzB,AxI61B3C,A4Ip6BOyB,AnNktBL,AsN3wB8D,CPgIrBzB,AhBkBpC,CgBlB4C,EAAI,KxI81BnC,AwI71B7B,CAAA,CAEA,CI1EgByB,CAAa,C5Iu6BzB,A4It6BA,C5Is6BC,AAAC,CwH10BK,CgBnBG,ExI21ByB,C4Ip6BnC,A5Io6BoC,CAE3B,AAF4B,A4Ip6BrC,CAAQjQ,CpB4FO,AxH00BC,A4It6BRwH,C5Is6BS,A4It6BTA,ApB4FQ,C/LynBF,A+LznBQ,AoB5FdA,CAAK,ApB4FK,AxH00BJ,CwH10BK,KxH40BnB,A4Ix6BQ,C5Iw6BP,AACH,E4Iz6BU,IAAA,CAAAxH,EAAewc,SJyEb,EAEZ,CACA,IxI81BwB,CwH10BK,CgBpBvBhO,AhBoBwB,AxHg1B9B,CwIp2BiB,ASnLc,CTmLd,ASnLe,AzBuMA,EoB/F9B,ApB+FgC,CoB/FhC,GJ2EqB,CI3ErB,CAAM,GJ2EoB,CI3Ef,CAAA,EJ2EoB,AxIo2Bf,CwIp2Be,COnHnC,AHyCE,CAAC,A5I86BgC,AANa,C4Ix6B7C,ApBmG6B,CuB5IhC,AH0CE,A5I86BE,AADiC,AwH30BJ,CyBtMtB,ET6KwB,CxIq2BzB,A4I96BH,AKrG0B,AzBuMI,AgBzBM,CIzEpC,AKrG2B,CzBuMK,AxH40BpB,GAAiB,C+Iv9BS,AE3DhB,AzBsMc,CgBxBvC,AxIo2BsC,AiJlhCZ,CjJkhCa,AwIp2BvC,AhBwByC,CxH40BD,A4I96BrC,ApBkGuC,CxH40BD,A4I96B3B,ApBkG6B,EgBxB3C,CAAK,AhBwByCkQ,CoBlG5BjC,G5I+6BX,C+Ix9BS,A/Iu9Be,CwH50ByB,CAAC,IAAI,CuB3IpB,CvB2IsB,CuB3IC,CAAA,AHyC9CA,CvP+Z0C,AuP/Z3B,CpBkGkC,AnO6TL,C4LtWnB,CuCyC0B,AvCzCzB,CuCyC0B,AnO6TD,AuP/Z/B,CpBkGiC,AnO6TL,A4LtWhB,A5LsWwB,AuP/ZpC,C3DyDiB,C5LuW3D,A4LvWwD,CuCyCsBkC,CvCzChB,CuDkB5D,CAAA,AnPqVF,AuPha0C,CJ4ExC,AvDnB+D,A2DzDfnX,CpBkGqC,AnO8TvF,A4LvWkE,A2DzDX,CpBkGiC,AvCzCrB,A2DzDZ,CvPgavD,GmO9T4F,AoBlGjC,CJ4ElD,AI3EP,CpBiG4F,AoBjG5F,CvP+ZF,CACM,EAAW,AuPhaf,ApBiGgG,CoBjG3F,CJ2ESgH,AhBsBoF,CAAC,AnO+ThE,CmO/TiE,CgBtBzE,AhBsB0E,GnOgUxF,GuPjaK,AvPiaY,CuPjaZ,CvPga2B,CAAC,AAGhD,CAHiD,CmPrVNiL,AI3EnBiD,CvPmaxB,AmPxV2CjD,EnPwV3C,IAAA,EAAA,AmPxV2CA,CI3ER,AJ2EiBjL,CI3EjB,AJ2EyB,CAAA,AnPwV5B,CmPxVgC,CnPwV1B,CuPnaH,AvPmaA,CuPnaM,C9CrBH,C0CiGtC,AnPuV0C,CACxC,AmPxVF,CAEA,AI9E8C,CAAA,IvPoatC,CmPtVM,CI9EsC,CAClD,CAAA,EvPmagB,EmPtVJ,AxIkZI,AwGhiBa,AoCiE7B,CAAK,CJ6EiB,CACtB,MAAM,CnPqVwB,AuPnab,C9CrBiB,A8CqBjB,CvPmasB,CmPrVjC,CAAK,CI9EUmO,CvPmae,QuPnaL,CAAA,IAAA,CAAM,EJ8EP,CAAA,CI9EY,CAAA,EJ8EZ,CAAK,EnPqVgC,CAAG,AuPnatB,CAEhD,CAAA,CvPiayE,CAAC,CmPrV/B,AnPqVgC,CmPrVhC,AI5E3C,CJ6EA,AI7EK,KvPkaP,CmPrVQ,CnPqVR,EuPlamBnV,CJ6EX,AnPqVR,AuPlamBA,CJ6EN,AI7EMA,EAAA,AvPkanB,GAA0D,CuPlavCA,CAAAA,CvPoaM,C2G4DH,C3G5DgB,EuPpanBA,CAAAA,CvPoa0B,AuPpa1BA,CAAAA,CAAM,CvPoauB,CAAC,MAC1C,CuPpaL,CvPoaK,AuPpaL,GvPoa4B,CuPpa5B,CvPoaqC,AuPpahC,GvPoa4C,CmPxVH,CnPwVX,CAA8B,EAAS,AmPxVvB,AI5EnCA,CJ4EmC,AI5EnCA,CAAAA,CAAAA,C5I06BP,C4I16BO,AvPoawD,C2GsgB/D,CiF52BsD,C5LsWmB,A4LtWlB,CAAC,A5LsWkB,AuPpanEA,CvPoagD,AAAoB,AuPpapEA,KAAAA,CAAAA,C5I06ByB,A4I16BzBA,C5I06B0B,A4I16B1BA,CAAM,E5I06B6B,EAAM,CAAT,AAAU,CAC1D,AAD2D,AwI91BgB,CxI81BnB,AAAI,AAC3D,C4I36BiCoV,AJ6EpC,CAEQ,CStLE,AzBuMA,CoBhG0BA,EKvGvB,OjJ4hCA,CiJnhCK,AzBuMA,CgB1BM,AhB0BI,CxH40BD,AwH50BP,CAAY,AxH40BH,AiJnhCR,AT6KG,ChB0BU,AAAZ,AgBzBpB,CxIq2BmC,CwH50BD,AAAM,AAAlB,CyBvMmB,AjJmhCA,AwIr2BrC,CAAC,AhByBqC,AAAI,AAAtB,AxH40BQ,AwH50BI,AyBvMM,CjJmhCrB,CAAmB,AwH50BI,AAAI,AAAtB,AAAY,CxH40BO,CwH50BK,CgBzBxC,ChByB0C,CxH60BlD,A4It7BgCA,CpByGoB,AoBvGlDC,C5Io7BI,CwH70BgD,CyBtMxC,CzBsM0C,EAAE,EAAE,AgBzBvC,CAAA,AI9ET,CJ+EZ,AhBwB8D,CoBvGlD,CpBuGoD,AoBtGhE,EpBsGkE,CxH60B9C,AwIr2Bd,ChBwB8D,AxH60B/C,AwIr2Bb,AI9EH,CAAA,CpBsGiE,EAAE,GAAG,AgBxBnEje,CAAAA,CAAQ,CxIq2Be,AwIr2BXC,CxIq2BY,AwH70B+C,AgBxB3DA,CS9KmB,AjJmhCN,AwH70B+C,AoBtG3E,CKhGmC,ALgGrBie,C5Io7BJ,OAAO,A4Ip7BM,CpBwGC,AxH40BN,CAAC,A4Ip7BI,C5Io7BH,AwH50BM,AoBvGtBC,C5Io7BF,AADmB,CAAC,CwIt2BPle,CAAiB,CI7EtB,A5IqqCrB,CAAC,C4IrqCoB,GnNguBsB,AmN/tBrC,IKjG6C,ALiGxC,CKjGyC,ALiGzC,OJ4EmD,CI5EnD,CAAWie,EJ4E6C,CAAA,IAAI,CACjE,AI7EyB,CJ6EzB,CI7EyB,CAAA,CAI3B,GJyEQ,CIzEH,CAAA,EJyEO,GxIq2B6D,EwIr2B7D,CIzEP,AJyEale,CAAO,AIzET,CJ0EhB,CACF,CACF,AI3EE,CAEA,MAAa,IAAO,EAAA,CAClB,IAAK,CAAA,MAAA,CAAO,A1N1GqE,K0N0G/D,CAAA,aAAa,CAC/B,CAAA,IAAA,CAAK,sBA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AK,CpJDsB,AoJCtB,CpJAD,CAAA,EAAA,IvB0Ff,AuB1F2B,EoJAX,CAAW,ApJAM,C0BzF+C,E1ByF5C,CAAC,AvB0FrC,CiDnLoF,EAAA,C0HyFhD,CAAA,CpJAU,CAAA,CoJAV,CAAI7B,ApJAY,CoJAP,ApJAQ,CoJAR,ApJAS,CAAE,CAAC,CAAC,AoJA/C,CpJAgD,CACxD,CAAC,CoJDO6B,CAAAA,KAAAA,CAAAA,CAAAA,A3K0FX,C2K1FWA,CAAsC,CAAM,ApJMP,CoJNO,ApJMN,GoJNM,CpJMC,CoJND,CpJMG,AoJLpD+c,CACJ,CAAA,MAAMC,CAAgBvB,CAAAA,CAAAA,C3KwFxB,C2KxFiE,CACzDA,CAAAA,CAAa,KpJID,AoJJWtd,GAAAA,CAAAA,C3KuF/B,E2KtFM,IAAK,CAAA,EpJIQ,AvBkFnB,GuBlFmB,GAAA,CAAU,CoJJlB,CAAW,ApJGqB,AACV,E7DYM,CiNhBb6c,CAAAA,GpJKf,YQgrCP,CwJprCE,CZDoBA,CAAkB,EYClC,CAAC,GxJqrCX,CAAa,A4ItrCwCgC,C5IurCrD,ARnrC+D,AoJJVA,C5I2rCpD,A4I3rCgE,CAC3DD,C5I6rCN,A4I7rCMA,CAAAA,E5I4rCN,A4I1rCE,EAAA,CAAA,A5I0rCY,CwJ3rCR,AZGJ,AYHe,CxJ2rCD,AvE1NN,CuE0NO,AACb,CAAC,CwJ5rCK,CxJ4rCF,AAAD,AwJ5rCI,EZGH,K5IyrCO,C4IzrCP,A5IyrCQ,EAAK,CAAC,CAAC,CwJ3rCG,CAAC,AxJ2rCA,CAAC,A4IzrCpB,CYFuB,AZEf,C5IyrCc,AwJ3rCE,AxJ2rCD,E4IzrCX,CAAA,CAChB,G5IwrCkC,CAAC,A4IxrC/B,E5IwrCoC,CAAC,CAAC,EAAI,CAAC,A4IxrC3C,CAAexd,C5IwrC8B,AAAC,A4IxrCnB,EAAA,CAC7Bwd,CAAiBxd,CAAAA,CAAAA,C5IurCsC,A4ItrCvD,C5IsrCwD,EAAK,C4ItrCxD,A5IsrCyD,C4ItrCzD,A5IsrCuD,AAAG,CAAA,EgK/rCrE,IhKgsCQ,AAAI,CwJ3rCK,CAAH,CZIH,CAAW,EYJL,AZIQyb,CAAAA,iBAAAA,CAAkB,OAASgC,CAAAA,CAAY,EAC5D,CAAC,CACD,CAAA,I5IsrCJ,A4ItrCQ,IYLF,AxJ2rCA,EAAY,AAtFd,C4IhmCkB,CAAA,MAAOzd,CAASD,A5IgmCxB,AACd,CAAA,A4IjmCsCA,CAAAA,AYlFtB,AxJorChB,CAAI,E4IlmC6C,A5IqmCjD,C4IxlCMM,AY/Fc,CZ+FdA,CAZe,CYnFmB,AxJurClC,CAAC,CAAG,EAAE,AAAC,C4IpmCc,I5IomCT,A4IpmCS,CAAK,A5IomCb,AACf,CAAC,CAAG,GAAG,AACX,IAAK,C4IrmCI,CAAA,E5IqmCA,CAAC,CAAG,CAAC,CAAG,G4IrmCR,A5IqmCa,C4IrmCHzB,A5IqmCI,C4IrmCGR,AYhFA,AxJqrCA,C4IrmCAA,GAAAA,CAAA,A5IqmCQ,C4IpmCxB,E5IomC2B,AAAE,CAAC,EAAI,AwJrrCA,CAAC,ExJqrCI,A4IpmCvC,CAAU,CACR,C5ImmC0C,GACtD,IAAM,EAAK,CAAC,AwJprCE,CxJurCR,AAHO,CAAC,CgKhsCJ,AhKmsCW,IAAQ,EAAK,A4IvmCtB,A5IumCmB,C4IvmCGmf,CACxB,CAAA,A5IsmC2B,AAAG,C4ItmC9B,CACGxV,CACJ,A5IomCkC,AACrC,C4IrmCG,A5IomCmC,C4IpmCnC,A5IomCoC,AAC1B,C4IpmCV,C5IomCyB,CwJprCV,ExJqrClB,AAD+B,C4IpmCrB/I,A5IomCsB,CAC9B,AAAG,A4IrmCKA,CAAAA,A5IqmCJ,CAAC,CAAG,A4IrmCU,CACZue,C5IomCE,A4IpmCFA,C5IomCK,CAAC,AAAG,A4InmCXxd,CYjFW,AZiFJf,C5IomCb,A4IpmCaA,CAAK,C5IomCb,CAAA,A4IlmCH,CAAC,C5IkmCQ,A4IjmCIqB,E5IimCJ,A4IjmCIA,C5IimCD,A4IjmCCA,CACfL,AoBzFmB,AhKyrCJ,AAAG,C4IhmCV,A5I+lCqB,EACR,AACrB,C4IhmCF,A5I+lCwB,C4I/lCvB,A5IgmCM,C4I/lCT,A5I8lC2B,C4I9lC1B,A5I+lCqB,C4I/lCrB,AYrFa,CZsFPK,AYtFQ,CZuFjB,A5I+lCM,C4IrkCN,C5IqkCW,CAFkB,CAEf,EwJtrCoB,A/Nm+BxB,CmNl3BG,AYjHsB,AxJsrClB,CAAA,CATwD,CASpD,AwJtrCiB,EAAE,CxJurClC,CwJ9rC0E,CxJ6rCtD,AACpB,AwJvrCqC,CAPuC,AASrD,CxJqrCf,AwJrrCgB,CACb,AZ8GJ,CnNk3BW,A+N1+B6D,A/N2+B3E,AmNn3BezB,CAAemJ,A5IskCvB,C4ItkCuBA,A5IskCvB,C4ItkCuBA,C5IskCvB,AwJ9rCwE,AZwHT,CAC9E,A5IqkCoB,EAAE,E4IrkCtB,A5IqkCsB,C4IrkCjB,A5IqkCuB,CADW,AACV,AAAG,CwJ9rC+D,EAAE,CxJ+rC/F,CwJprCG,CxJorCS,CADwB,AACvB,CAAI,CAAA,CAN+D,E4IhkC/D,EAAA,CACnB,K5IskCU,C4ItkCJ,AY9GS,AxJ8qCmE,CAO9E,AwJrrCY,AxJorCJ,CAAC,CAAC,AACJ,C4IvkCJ,A5IukCC,CAAK,A4IvkCD,A5IukCE,EANqE,CAMlE,CAAC,CAAC,CAAE,EAH6C,CAI7D,C4IxkCkB,C5IukCG,AwJnrCf,AxJorCA,A4IxkCY,C5IwkCf,AwJprCI,AxJkrCiB,CvEjNpB,A+Nj+BQ,AxJorCJ,AAAC,GAAA,CvEpNc,AuEoNV,GAAG,AACpB,CADqB,CAAC,A4IxkCA,A5IykChB,CADiB,A4IxkCWnJ,A5IykC/B,C4IzkCsCmJ,A5IykChC,CwJprCG,AZ2G6BA,CAAI,C5IykCjC,AAF6B,CAE5B,A4IxkCf,CAEO,C5IskCa,CAAC,A4ItkCX9G,C5IskCY,A4ItkCZA,C5IukCR,A4IvkCQA,A5IskCa,C4ItkCEqP,A5IskCD,C4ItkCgB,AnNm3BnB,CmNn3BmB,C5IukCtC,A4ItkCA,E5IskCU,CAF8B,CAE3B,A4ItkCR,CAAA,CY9GY,CxJorCD,CAAC,CAAC,CAAE,CwJprCG,AZ8GlB,CAAO,C5IukCZ,AADuB,C4ItkCRrP,C5IukCT,A4IvkCSA,C5IskCW,AACvB,A4IvkCYA,A5IqkC0B,CAEhC,A4IvkCaqP,CAAQ,CY7Gf,CxJorCH,A4ItkCd,C5IskCe,A4IpkCR,E5IokCa,E4IpkCb,A5IokCe,CwJprCK,AxJorCJ,AACrB,A4IrkCUrP,C5IokCY,A4IpkCGqP,C5IokCF,A4IpkCEA,A5IqkCnB,CAAH,A4IrkCsBA,C5IqkChB,A4IrkC+B,CYhHV,AZiH9B,E5IokCY,CAAC,C4IpkCb,A5IkkC6C,AwJnrCX,CAAC,AxJqrCjB,A4IpkCb,EYhHmB,A/Ni+BR,C+Nj+BS,AxJorCJ,AACrB,EAAM,CADkB,AACrB,A4IrkCS,C5IqkCN,A4IrkCM,G5ImkC6B,AAE7B,CAAC,A4IrkCD,CoBtHT,ApBsHcrP,CnNi3BU,AuEoNT,C4IrkCMqP,CAAQ,C5IskChC,CADsB,AgK3rCnB,ApBuHL,C5IqkCQ,A4InkCD,C5ImkCF,AwJprCM,CxJorCA,C4InkCJ,CAAIrP,C5ImkCG,AgK3rCd,ApBwH0BqP,C5ImkCZ,A4InkCYA,CAAAA,C5ImkCN,A4InkCqB,CYjHlB,AxJorCF,AAF0B,A4IhkC7C,CYlHsB,AxJorCF,CAAC,CAAC,CvEnNH,AmN/2BnB,CAAK,G5ImkCK,CwJprCK,AxJkrC0B,AwJnrCX,CxJqrCjB,AwJrrCkB,CZkHnB,CAAA,AoBxHd,ChK2rCe,CAAI,C4InkCL,C5ImkCK,A4InkCDrP,CAAOqP,CAAAA,C5IokCvB,A4IpkC+B,E5IokCzB,A4InkCR,C5IkkC8B,AACzB,A4IjkCE,C5IikCG,AAAC,GAAG,CAAC,CwJprCK,CxJsqCT,GAcS,AAClB,EADoB,CAAC,CwJprCK,AxJorCJ,AAClB,A4IlkCgBrP,C5IikCG,A4IjkCHA,CAAAA,AYnHQ,AxJqrCxB,CwJrrCyB,AZmHMqP,C5IkkCrB,A4IlkCoC,CYnHnB,AZmHmB,CAClD,C5IikCiB,AAfM,CAa2B,AAEhC,CwJprCK,C/Ni+BP,AmN92BX,A5IikCkB,AwJprCC,CAAC,AZmHpB,A5IikCgB,CAAK,AAAD,GAAI,CAAC,CAC9B,A4IlkCK,AnN82BsB,AuEmNI,CAAC,A4IjkCpB,C5IkkCN,CAAH,AAFuC,CAEjC,EwJprCM,CxJorCH,AgK1rCd,ChK0rCe,EAAK,CwJprCG,CAAC,AxJorCF,CAAC,AACrB,CADsB,CAAC,AACjB,A4InkCqBrP,CYlHD,AxJqrCvB,A4InkCwBA,CYlHA,AACnB,AxJorCC,A4InkCkBA,CYjHlB,AAAK,AZiHoBqP,CYjHnB,AZiH2B,C5ImkC9B,CAAC,A4IlkCf,CAEA,C5I8jCwD,AAEpC,CwJprCK,CAAC,CAAC,AxJqrCzB,AADqB,CAAC,CAAC,AACjB,AvEpNa,A+Nj+BQ,AZoHhB,C5IgkCa,AACrB,CAAK,AAAC,IAAI,CAAC,CAF8B,CAEzB,CgK1rCrB,ChK0rC0B,CAAF,EACtB,CAD4B,CAAC,AwJnrCvB,AxJorCA,CADwB,AAC3B,CAAM,AAAD,AADuB,C4IjkCE,EAAA,A5I+iCiD,CAmBrE,A4IjkCT,C5IikCU,AAFgC,EAEhC,C4IjkCL,C5IikCK,A4IjkCL,G5ImkCT,IAF+B,AAE1B,C4InkCI,CAAS,E5ImkCT,CAAC,CAAG,CvEnNL,CuEmNS,CAAC,CAAG,CwJprCK,CZiHO,AYjHN,CxJorCH,AwJprCI,AxJorCF,CAAC,C4InkCM,C5ImkCJ,AvEnNJ,CuEmNM,AAHiC,CAGhC,AAC9B,C4IpkC+B,CYhHvB,AZgH4B,E5IokChC,EAAA,EAAU,EgK5rClB,GhK6rCU,CADa,CAH2C,AwJjrCpC,CAAC,CAAC,AxJqrCd,EAAM,GAAG,GAAG,CACtB,EwJprCQ,AxJorCD,CgK7rCf,ARSiB,CxJorCC,GAAG,A4ItkCsD,C5IskCrD,CAFsB,A4IpkC+B,C5IskChD,GAAG,AACpB,A4IvkCiE,C5IskC5C,A4ItkCiD,C5IskChD,AACjB,CADkB,CACf,EgK3rClB,AvOw+BkB,CuEiNiC,AAE9B,CAAC,CgK1rCtB,CpBoHI,A5IskCwB,C4ItkCxB,CAAA,A5IskCsB,AAAK,GAAG,EAC9B,CADiC,A4ItkC3B0K,CY7GE,AxJorCF,CwJprCO,AAAJ,AxJorCN,CAAK,AvEnNF,AuEmNG,GAAG,CAAC,CAFuC,CAElC,AgK1rCtB,ChK0rCoB,EAAK,AACrB,CADsB,CAAC,AwJnrCf,AxJorCF,CADkB,AACrB,CAAK,AvEnNF,AuEmNG,GAAA,CAAI,C4IxkCe,C5IwkCV,A4IxkCU,C5IskC4B,AvEjNvC,AuEmND,CwJprCU,EZ4GE,C5IykCrB,A4IzkC0B,C5IwkCT,CACd,GAAG,CAAC,EwJprCQ,AxJorCH,A4IzkCuB,CY3GnB,AxJorCN,A4IzkCyB,E5IykCpB,CAAC,CACjB,AADkB,AAFyB,CAExB,CAChB,CwJprCO,CADkB,CAAC,CxJqrCtB,A4I1kC6B,C5I0kC7B,AwJrrCwB,CZ2GmB,C5I0kCrC,A4I1kCqC,E5I0kChC,C4I1kCgC,CAAM,A5IwkCb,AAEvB,CwJtrC8B,AxJsrC7B,AAC3B,CAD4B,CwJtrC8B,AxJsrC7B,AACvB,CAAH,CgK3rCP,AhK2rCY,AAAC,CwJprCO,GxJorCH,CAAC,EwJprCQ,A/Ni+BR,AuEmNM,CwJprCG,AxJkrC2B,CwJprCO,AxJsrChC,CwJtrCiC,AxJsrCnC,CACzB,AvEpN2B,AuEmNE,CAC5B,AACD,AAF8B,CwJnrCxB,AQPR,AhK0rCiC,CwJnrCxB,AACD,AxJkrC0B,CwJlrCzB,GZuGgF,A5I6kChF,C4I7kCgF,CAAE,KACrF,CAAA,C5I4kCc,EAAM,C4I5kCd,CYxGgB,AxJorCJ,CwJprCK,A/Ni+BR,AuEgN8C,EAGpC,A4I5kCd,CAAA,A5I4kCgB,CAAG,CAAE,AACtC,CADoC,AACnC,CAAC,AACF,EwJrrCM,CxJqrCN,CwJrrCQ,CAAC,AxJqrCF,GgK7rCP,EhK6rCY,CwJprCG,AxJorCA,CwJprCG,CAAC,CxJorCD,EAAK,A4I9kCN,EACb,CAAA,A5I6kCsB,AAAE,CAAC,A4I3kCzB,I5I6kCI,A4I7kCC,CAAA,C5I6kCI,CAAC,EAAE,KAAM,CAAG,EAAA,CAAG,CAAC,AAAG,GACxB,CwJprCK,CxJorCH,AAAG,CADwB,AwJnrCtB,AZsGN,CYtGO,AxJorCD,AAAC,E4I5kChB,CAEA,C5I0kCoB,CAAC,EAAE,AAAC,E4I1kCX,C5I0kCc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CACnB,CAAC,EAAA,G4I3kCF,EAAiB,A5I4kC1B,C4I3kCF,G5I2kCE,C4I3kCF,CAAK,A5I2kCH,EAAa,EAFmC,CAEnC,CAAA,GACP,CADe,AwJnrCR,CAAC,A/Ni+BR,AuEmNG,CAAA,CAAM,EAJiE,CAI9D,CAAC,CwJprCO,AxJorCN,CAAE,AwJprCK,CxJorCJ,CAAC,CAAC,CAAC,CgK3rC9B,AhK4rCU,CAF8B,A4I3kCL,CAAA,A5I6kCtB,AAAD,C4I7kCuB,CAAA,CACjC,AoBjHF,AhK6rCa,CAAI,EAAK,CAAF,EAAK,AACrB,A4I7kCI,C5I4kCkB,CAAC,CAAC,CACpB,A4I7kCA,C5I2kCuC,A4I3kClC,C5I6kCH,AAAG,EAAA,GAAM,CgK1rCnB,AhK0rCmB,EAAM,EAAE,CACvB,CwJprCc,CxJmrCY,AACxB,AAAG,EAAE,AAAC,EwJprCe,CAAA,AxJkrCsB,A4I5kChB,CYtGN,EZuG3B,A5I6kCoB,CwJprCc,AZyGlC,E5I4kCI,AADmB,CAAC,CAAC,CAAC,CAChB,A4I5kCJ,EYxGY,AxJorCN,AAFmC,EAE7B,CwJprCO,ExJorCJ,CAAC,EAAE,AAAE,EAAE,CAAC,AACnB,A4I7kCU0C,CAAAA,A5I4kCU,CgK3rC9B,AhK2rC+B,AACf,A4I7kCIA,CYvGG,AZuGgB,CYvGf,AxJorCN,AAAC,A4I5kCjB,C5I0kC2C,EAEvB,A4I5kChB,C5I4kCiB,A4I5kChB,E5I4kCkB,AAAC,E4I5kCnB,C5I4kCsB,A4I5kCjB,C5I4kCkB,EAAE,CAAC,AAAE,CAAC,EAC1B,AAFuC,CACV,AwJnrCtB,CAD6B,AxJqrChC,C4I7kCS,C5I6kCT,AAAM,A4I7kCG,G5I6kCA,CAAC,EAAK,CAAF,AAAG,CAAC,CAAC,AAC5B,CAD6B,CACrB,CgK5rCZ,ApB8GuB,C5I8kCX,A4I9kCyB,CACjC,G5I6kCe,CAAC,A4I7kChB,CAAK,C5I6kCa,AAAE,CgK3rCxB,ChK2rC0B,AAAE,G4I7kCZ,C5I6kCgB,A4I7kChB,C5I6kCiB,CAAC,CAAC,C4I7kCnB,C5I2kCyD,AACnB,A4I3kChD,C5I6kCO,IgK1rCb,IhK0rCsB,CwJprCO,CAAC,CAAC,CxJorCL,MACxB,CAAC,CADqC,AACpC,AAIJ,EwJxrCU,CAAC,CAIL,GxJorCC,GAiB0B,EAAE,AAAE,EAAA,CAAM,CAAC,CAAC,AAC7C,GAAA,CAAK,EAAE,AAAC,KAAK,CAAA,MAAQ,AAAI,IAvBsD,EAuBtD,IgKhsCzB,OAfA,MpB4GI,CAAA,CACA,MACF,CAiBA,GAfI,G5IkmCN,C4IlmCM,CAAK,K5IkmCJ,QAED,C4InmCF,C5ImmCE,C4InmCF,C5ImmCE,EAAe,C4InmCjB,C5ImmCsB,A4InmCjB,C5ImmCe,CAAO,CAAF,CAAO,CAAF,AAAG,CAAA,A4InmCrB,CAAA,C5IomCd,EAAM,CAAH,CwJ1rCK,AxJ0rCC,A4IpmCK,CYtFL,AZsFW,E5IomCX,A4IpmCY,CAAG,A5IomCX,GACb,CADiB,CACX,CAAH,CAAK,AwJ1rCI,AxJ0rCH,GAAG,CAAA,EAAM,EAAK,CAAC,CAAF,AAAG,AwJ1rCC,CxJ2rC1B,AAD0B,CAAC,CADM,AAE3B,CAAH,CwJ1rCS,AxJ0rCJ,AAAC,EwJ1rCMzL,CxJ0rCH,CAAC,GACb,EAAM,CADa,AAChB,CAAM,AwJ3rCa,AACd,CADe,AACT,ExJ0rCF,CAAA,EAFmC,AAE7B,EvEzNF,CuE0NhB,AwJ3rCuB,AxJ0rCF,EACf,CAAH,AADqB,CwJzrChB,AxJ0rCC,CwJ3rCmB,CAAC,CAAC,AxJ2rClB,CAAC,EAAK,EvE1NW,AuE0NT,AAAC,C4IxmC0D,CAAA,C5IwmCvD,A4IvmCtB,CYnF2B,AxJ0rCJ,CACzB,AwJ3rC8B,AxJ0rCJ,CAAC,CACrB,AvE1NkB,CuE0NrB,AwJ3rC8B,CAAC,AAC1B,AZkFA,A5IwmCC,CwJ3rC0B,CAAC,CxJ2rCxB,AwJ3rCyB,CxJyrCS,AwJzrCR,AxJ2rCzB,A4IxmCL,CAAK,C5IwmCK,EAAK,CAAC,CwJ1rCK,A/Ni+BR,AuEyNI,AAAH,CwJ1rCQ,AxJ0rCJ,AAC1B,CAD2B,CACrB,CAAH,AwJ3rC8B,CAAC,AxJ2rCzB,CwJ3rC0B,CAAC,AxJyrCW,CwJzrCV,AQNvC,CRMwC,AxJ2rCzB,A4IxmCX,C5IwmCY,A4IxmCZ,E5IwmCiB,AgKnsCrB,ChKmsCsB,CAAA,A4IxmClB,CAAK,C5IwmCkB,CwJ1rCK,ExJ0rCF,CAAC,CwJ1rCK,AZkFpB,C5IumCiC,AgK/rCjD,ARMqC,AZkFrB,CYlFsB,AxJ0rCJ,AAAG,CAAC,AAAH,AwJ1rCI,CAAC,CxJ0rCC,C4IxmCzB,CAAM,C5IwmCsB,C4IxmCrB,A5IwmCsB,C4IxmCnB,C5IwmCwB,CAAF,CAAI,AAAC,IAAI,CAAC,CAAC,AgK/rC3D,ChK+rC4D,AAC1D,CAD2D,CACrD,CgK/rCR,ChK+rCU,AwJ1rCI,GxJ0rCA,CAAC,EAAK,EAAK,CAAC,CAAC,AwJ1rCI,AxJ0rCP,CwJ1rCQ,AxJ0rCJ,CAAC,EwJ1rCM,CAAC,AxJ2rCzB,CwJ3rC0B,CAAC,CAAC,AxJ2rCzB,CwJ3rC0B,AxJ2rCzB,K4I1mCiD,A5I2mCxD,CADa,AvExNZ,AmNl5BuD,C5I2mCtD,E4IzmCN,C5IymCU,CAAC,E4IzmCN,AnN+4BmB,AuEwNqB,C4IvmCxC,A5IsmCwF,EAIzF,CADa,CACX,AAAC,GAAG,CAAA,AwJ3rCgB,ExJ2rCV,CwJ1rCK,CxJ0rCD,CAAE,CwJ1rCEA,AxJ0rCJ,AAAG,A4I1mClB,AoBvFT,ChKisC4B,A4I1mCF,C5I0mCG,CwJ3rCU,C/Nk+BR,CmNj5BD,AYjFW,AxJ4rC9B,CwJ1rCK,ExJ0rCF,CAAC,CwJ1rCK,CxJ0rCA,C4I3mCU,CAAQ,C5I4mCpC,AADqB,CAAC,AwJ1rCE,CAAC,AxJ0rCF,AACjB,CAAH,AADqB,CwJzrChB,AxJ0rCA,AwJ1rCI,CZ8E+BjS,CAAAA,CAASD,A5I4mCxC,CAAC,A4I5mCkD,A5I0mChB,CwJ1rCG,CAAC,AxJ4rCjC,C4I5mC6C,CAC3D,C5I4mCJ,AADqB,CAAC,CAChB,AADiB,CACpB,AADqB,CwJ1rCK,AxJ2rCrB,AwJ1rCI,AAAJ,CZ8EE,AY/EoB,EAClB,CxJ0rCC,CwJ3rCqB,AZ+ExB,CY/EyB,AZ+EpB,A5I4mCG,CwJ3rCkB,CxJyrCU,AgK/rChD,ARMuC,CAAC,AxJ2rCjB,CwJ3rCkB,AxJ2rCjB,CAChB,AADiB,CAAC,CACf,A4I7mCc2d,AY9EM,CZ8ENA,AY9EO,CZ8EC,C5I6mCtB,A4I5mCF,C5I4mCM,A4I5mCN,CY/E2B,CxJ2rChB,AwJ3rCiB,CAAC,CAAC,AZ+E9B,A5I0mCuC,AAEvB,CAAC,A4I5mCZ1d,AY/E0B,CZ+EnB,AY/EoB,AxJ2rCd,AwJ1rCI,CxJ0rCH,AwJ1rCI,AZ8EX,A5I6mCnB,C4I5mCO,A5I2mCoB,CACrB,CAAH,CwJ3rC+B,AACtB,AxJ0rCJ,AAAC,CwJ3rC0B,CZ+EtBD,AoBtFf,AROsC,CAAC,AZ+ExBA,A5I4mCJ,CwJ3rC6B,AZ+EnB,A5I4mCN,CwJ3rC0B,AZgFhC,CAAA,A5IymCuC,AAE5B,GAAG,AACrB,CADsB,AwJzrCjB,AxJ0rCJ,CADsB,AACtB,CADuB,C4I3mCjB,AY/EsB,AxJ2rCtB,CwJ3rCuB,AZ+Ef,CoBtFjB,ChKksCY,CAFqC,AAEpC,CwJ3rCuB,AZ+Eb,CY/Ec,AZgF3B,A5I2mCM,CwJ3rCsB,AxJ2rCtB,CwJ3rCuB,CAAC,AxJ4rCtC,CwJ5rCuC,AZgF1B,CAAA,AoBtFf,ChKksCQ,CwJ1rCK,QAAA,CAAA,CxJ0rCM,E4I5mCJ,CAAiB,CY9EL,GxJ0rCH,C4I3mChB,AY/EqB,AxJ0rCH,CAAG,C4I3mCrB,C5I2mC8B,AADQ,A4I1mCrC,CnNk5BmB,CmNj5BxB,A5I0mCwC,C4I1mCvC,CAAA,CACD,A5IymC2C,AAC7C,CAD8C,AAC7C,CADmC,AAAW,AAC3C,CAD4C,CAC1C,AAAC,E4I1mCC,C5I0mCE,CAAC,CvEzNH,CmNj5BA,AnNi5BA,CmNj5BK,GoBtFf,AhKgsCsB,GACb,EgKhsCT,ChKgsCY,CAAC,CAAC,CwJ1rCK,AxJ0rCH,E4IzmCV,C5I0mCJ,A4I1mCI,CAAA,A5I0mCH,C4I1mCI,A5I0mCJ,EAAA,CADqB,C4IzmCZ,CAAA,C5I0mCC,CAAC,CAAC,CAAE,EwJ3rCmB,AxJ2rCd,CwJ3rCe,EZiFzB,A5I2mCV,C4I1mCE,A5I0mCD,CwJ5rCsC,AxJ4rCnC,CwJ5rCoC,CxJ4rCjC,AADoB,AACrB,CADsB,CAAC,C4IzmCrB,A5IymCsB,CADW,AAE9B,CAH8C,AAG7C,CAJqF,AAIpF,C4I1mCD,AYlFoC,AxJ4rCnC,CwJ5rCoC,CQNnD,ARMoD,AxJ4rCrC,CgKjsCf,EpBuFoB,A5I2mClB,C4I3mCkB,AY/Eb,CZ+Ea,E5I2mCZ,EAAK,CADqB,CACrB,KAAS,CAAC,KAAO,EAAE,AAAC,CvEzNJ,GuOx+B7B,ChKisCuC,C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UACZ,EACA,MAAS,CACP,YAAa,6CACb,SAAU,UACZ,EACA,MAAS,CACP,YAAa,6CACb,SAAU,UACZ,EACA,KAAQ,CACN,YAAa,6CACb,SAAU,cACZ,EAEA,IAAO,CACL,YAAa,+CACb,SAAU,MACZ,EAEA,IAAO,CACL,YAAa,+CACb,SAAU,MACZ,EACA,KAAQ,CACN,YAAa,6CACb,SAAU,MACZ,EACA,KAAQ,CACN,YAAa,6CACb,SAAU,MACZ,EACA,IAAO,CACL,YAAa,6CACb,SAAU,UACZ,EACA,MAAS,CACP,YAAa,6CACb,SAAU,MACZ,EACA,KAAQ,CACN,YAAa,6CACb,SAAU,MACZ,EACA,KAAQ,CACN,YAAa,6CACb,SAAU,cACZ,EACA,MAAS,CACP,YAAa,6CACb,SAAU,cACZ,EACA,KAAQ,CACN,YAAa,6CACb,SAAU,cACZ,EACA,MAAS,CACP,YAAa,6CACb,SAAU,yBACZ,EACA,WAAa,CACX,YAAa,6CACb,SAAU,6BACZ,CACF,EkG/EI,GAAU,CACZ,CACE,WAAW,EACX,OAAQ,CACN,CACE,QAAS,GACT,aAAc,UACd,KAAM,QACN,KAAM,SACR,EACA,CACE,SAAS,EACT,aAAc,UACd,KAAM,UACN,KAAM,SACR,EACA,CACE,QAAS,GACT,aAAc,UACd,KAAM,QACN,KAAM,SACR,EACD,CACD,KAAM,WACN,KAAM,OACR,EACA,CACE,WAAW,EACX,OAAQ,CACN,CACE,QAAS,GACT,aAAc,UACd,KAAM,aACN,KAAM,SACR,EACA,CACE,SAAS,EACT,aAAc,UACd,KAAM,QACN,KAAM,SACR,EACD,CACD,KAAM,wBACN,KAAM,OACR,EACA,CACE,WAAW,EACX,OAAQ,CACN,CACE,SAAS,EACT,aAAc,UACd,KAAM,aACN,KAAM,SACR,EACA,CACE,SAAS,EACT,aAAc,UACd,KAAM,QACN,KAAM,SACR,EACD,CACD,KAAM,oBACN,KAAM,OACR,EACA,CACE,WAAW,EACX,OAAQ,CACN,CACE,SAAS,EACT,aAAc,UACd,KAAM,WACN,KAAM,SACR,EACD,CACD,KAAM,cACN,KAAM,OACR,EACA,CACE,WAAW,EACX,OAAQ,CACN,CACE,SAAS,EACT,aAAc,UACd,KAAM,iBACN,KAAM,SACR,EACD,CACD,KAAM,qBACN,KAAM,OACR,EACA,CACE,WAAW,EACX,OAAQ,CACN,CACE,SAAS,EACT,aAAc,UACd,KAAM,SACN,KAAM,SACR,EACA,CACE,SAAS,EACT,aAAc,UACd,KAAM,SACN,KAAM,SACR,EACD,CACD,KAAM,OACN,KAAM,OACR,EACA,CACE,WAAW,EACX,OAAQ,CACN,CACE,SAAS,EACT,aAAc,UACd,KAAM,kBACN,KAAM,SACR,EACD,CACD,KAAM,sBACN,KAAM,OACR,EACA,CACE,WAAW,EACX,OAAQ,CACN,CACE,SAAS,EACT,aAAc,UACd,KAAM,SACN,KAAM,SACR,EACA,CAAE,SAAS,EAAM,aAAc,UAAW,KAAM,KAAM,KAAM,SAAU,EACtE,CACE,SAAS,EACT,aAAc,UACd,KAAM,SACN,KAAM,SACR,EACD,CACD,KAAM,OACN,KAAM,OACR,EACA,CACE,WAAW,EACX,OAAQ,CACN,CACE,SAAS,EACT,aAAc,UACd,KAAM,SACN,KAAM,SACR,EACA,CACE,SAAS,EACT,aAAc,UACd,KAAM,sBACN,KAAM,SACR,EACD,CACD,KAAM,mBACN,KAAM,OACR,EACA,CACE,WAAW,EACX,OAAQ,CACN,CACE,SAAS,EACT,aAAc,UACd,KAAM,YACN,KAAM,SACR,EACD,CACD,KAAM,gBACN,KAAM,OACR,EACA,CACE,UAAW,GACX,OAAQ,CACN,CACE,SAAS,EACT,aAAc,UACd,KAAM,gBACN,KAAM,SACR,EACA,CACE,SAAS,EACT,aAAc,UACd,KAAM,WACN,KAAM,SACR,EACD,CACD,KAAM,uBACN,KAAM,OACR,EACA,CAAE,WAAW,EAAO,OAAQ,EAAE,CAAE,KAAM,QAAS,KAAM,OAAQ,EAC7D,CACE,WAAW,EACX,OAAQ,CACN,CACE,QAAS,GACT,aAAc,UACd,KAAM,aACN,KAAM,SACR,EACD,CACD,KAAM,gBACN,KAAM,OACR,EACA,CACE,WAAW,EACX,OAAQ,CACN,CACE,SAAS,EACT,aAAc,UACd,KA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BI,8B5GoBnC,CqFtDe,AakBF,alGqC/B,SAAA,EAAA,EAAA,cAAgC,CAAA,4BAGtB,EAAK,C+FyBe,CAAA,OAAA,gB/FxBf,MAAM,IAAI,CAAC,CAAA,EXSiB,GAAA,UAAA,EWTN,EAAK,cAAA,aAI1C,WAAW,CAAA,aAED,EAAA,WAAA,CAAiB,CsDMa,EAAA,CAAA,AtDNR,CVgFS,CgE1EK,AmD/EE,CnD+ED,AmD/EE,AzGyEd,AACpC,CsDKgD,AtDNR,CAAF,GyGzEsB,AzG0EvD,CAAC,EyG1EyD,CAAC,CzG0EtD,CAAA,CAAA,EAAC,CyG1EwD,EAAA,UAAA,AzG0E9C,EAAC,GAAG,CAAC,CAAC,CAC5B,yBAKD,gBAAA,MAAA,IAA2B,CAAA,CAAA,EAAC,GAAA,UAAA,AAAU,EAAC,EAAK,EAAD,aAAgB,CAAC,CAAC,kiBzCvHpC,kCAAA,gBAAA,KAAA,EAAA,WAAA,svB1CJkD,CACvF,yCAA2C,iCAUiB,E6BhBA,AxBkCA,AuB5BE,iH5BaU,EAAA,CAAoB,CAC5F,C0DtBO,K1DsBC,I2DdmE,CAAC,CJE3E,AIF4E,MCAyC,KFR3D,CHU9C,AGVkD,CHUjD,AGViD,EAAA,gB1DsBlB,CAAE,C0DtBmC,A1DuBnF,C0DvBuF,A1DuBvF,C0DvBuF,EAAA,cGAvE3W,ACAAA,KJA0F,CIA1FA,AJER,AGFQA,CHER,CAAA,CGFwB,ACAA,AJExB,CGKJ,ACAA,WACLC,ADAAA,CAAAA,ACAAA,CAAAA,ADAAA,CCCAC,ADAAA,IAAgCC,AHPvB,AIOuBA,CJPD,CACjC,IAAA,CAAM,mBACN,CAAA,EIME,ADAA,CAAA,ACAA,CATFC,ADAAA,EHGA,CAAQ,CIHR,ADAA,ICAQ,ADAA,CCAA,ADAA,CHIR,CAAA,IIJQ,ADAA,CAAA,ACAA,CACRA,ADAAA,IHGA,AGHA,ACAA,CJGY,CACZ,CAAA,CIJQ,ADAA,AHIR,CGJQ,ACAA,OAAA,ADAA,AHIR,CIJQ,ADAA,AHIE,CGHVA,ACAAA,IDAA,ACAA,IDAQ,ACAA,CDAA,ACAA,YDAA,ACAA,CDAA,ACAA,CAERA,ADAAA,G7D8B2E,C8D9B3E,ADAA,C7D8B2E,CAAa,C0D5B1F,A1D6BM,C6D/BI,ACAA,AJEV,A1D6BQ,C0D3BK,AIJH,ADAA,G7D+BE,CAAE,c0D3B0E,CAAA,CACtF,GILQ,ADAA,CCAA,ADAA,CCMN,ADAA,KCAK,ADAA,KCAQH,ADAAA,CAAAA,ACAAA,AJDG,CGCHA,ACAAA,AJDG,EGCH,ACAA,KAAAA,ADAAA,A7DyBqC,C8DzB5B,ADAA,A7DyB8B,C8DzB9B,ADAA,A7D0BrB,CAAA,M8D1BqB,ADAA,CACtB,ACAA,CJFgB,CAClB,GICO,ADAA,UCAaI,ADAAA,CHDJ,AICIA,ADAAA,CHDJ,KGCIA,ACAAA,CAAO,ADAA,OAAO,ACAA,GJDlB,CAChB,AGAuC,ACAA,CAAA,ADAA,KCAK,ADAA,ECE1C,ADAA,ICAK,ADAA,CAAA,ACAA,CJFS,CAAA,gBAAA,CAChB,EGCO,ACAA,CDAwBH,ACAAA,IAC7B,ADAA,IAAK,ACAA,CDAA,ACAA,AJFO,CAAA,GIEP,ADAA,CCAO,ADAA,ICAII,ADAAA,CCAW,ADAA,CCAA,ADAA,IAAA,AHFf,AIEe,CJD7B,AICkC,ADAA,cHDlB,CAAA,MGCuC,ACAA,EACvD,ADAA,CCEO,ADAA,OHJS,CAChB,SGGwBC,ACAAA,CAAYN,ADAAA,CCAAA,ADAAA,CCAAA,ADAAA,CAAe,ACAA,CDC7CA,AHJU,AIIVA,CJJU,AIIAI,ADAAA,GCAAA,ADAAA,MCAAA,ADAAA,CCAO,ADAA,MHJP,CAChB,AIG8B,ADAA,KCE1B,ADAA,CCAA,ADAA,OCAA,ADAA,CAAQ,ACAA,CJLK,CAAA,IGKCE,ACAAA,CDAK,ACAA,CDAA,ACAA,CACVN,ADAAA,IAAUI,ACAAA,MDAO,AHNb,AIMa,CJL9B,AIK8B,ADAA,MCAA,ADAA,CCAO,ADAA,KCEjC,ADAA,OCAQ,ADAA,CAAA,ACAA,AJPU,CAAA,GIOV,ADAA,CAAKE,ACAAA,CAAK,ADAA,CCCTN,ADAAA,CAAAA,ACAAA,CDAAA,ACAAA,GDAUI,ACAAA,OAAO,ADAA,IHRR,CACtB,CIOqC,ADAA,CAAA,ACAA,KDAA,ACAA,CAEjC,ADAA,KHTW,CAAA,EISH,ADAA,KCAME,ADAAA,CCAAA,ADAAA,CCAK,ADAA,ECCVN,ADAAA,CAAUI,ACAAA,GAAAA,ADAAA,AHVR,CACf,KISuBA,ADAAA,CCAO,ADAA,OCAO,ADAA,EHTpB,CAAA,EIWb,ADAA,CAAA,ACAA,OAAA,ADAA,CCAQ,ADAA,KAAME,ACAAA,CAAAA,AJXD,AGWCA,CCAK,AJVvB,AGUuB,CAGnB,ACAA,CAAA,ADAA,OCAA,ADAA,CCAQ,ADAA,IAAIA,ACAAA,CAAK,ADAA,ECErB,ADAA,CAEO,ACAA,EJjBe,CAAA,Q2E4BiB,CxEXnBA,ACAAA,CAAAA,ADAAA,CCAAA,ADAAA,CCAY,ADAA,CAC9B,ACAA,IDAK,ACAA,CAAA,ADAA,ICAA,AJlBe,AGkBf,CHjBP,AIiBY,ADAA,OCCRC,ADAAA,eHlBoB,CAAA,CIkBF,ADAA,CCAA,ADAA,CCChB,ADAA,UCAW,ADAA,ICAI,ADAA,ICAA,ADAA,GHnBG,AGmBI,ACAA,CJlB5B,UIkBwC,ADAA,ECAA,ADAA,CAClC,ACAA,EJnBW,CAAA,CImBND,ADAAA,CCCP,ADAA,CCAC,ADAA,CCCH,ADAA,CCGA,ADAA,CCAA,ADAA,MCAMN,ADAAA,EAAQ,ACAA,GJvBlB,CAEa,CAAA,EIqBYM,ADAAA,CCAAA,ADAAA,ECAU,ADAA,SCAW,ADAA,IAAK,ACAA,CDAA,ACAA,KAAA,ADAA,CCAMA,ADAAA,CCAK,ADAA,CAAE,ACAA,AJrBnD,CIqBmD,AJrBrB,AGqBqB,CHpB9D,IGoB8D,ACAA,CAAQA,ADAAA,ECAM,ADAA,CHpB5E,CAAU,GIqBJN,ADAAA,CCAAA,ADAAA,CCAAA,ADAAA,ECAS,ADAA,GHpBjB,CAAA,CGoBsB,AHlBT,AIkBS,UAChB,ADAA,ECAA,ADAA,IAAA,ACAA,CAAK,ADAA,YHnBkC,CAAA,IImBjBM,ADAAA,CAAON,ACAAA,CAAAA,ADAAA,CCAK,ADAA,ECEtC,ADAA,CCEO,ADAA,OCAA,ADAA,ECAU,ADAA,CCCf,ADAA,OCAO,ADAA,ICAA,ADAA,CAAK,ACAA,IACd,ADAA,CCEO,ADAA,OjCfL,CAAA,CkCeK,ADAA,AjCfL,EkCeiB,ADAA,CACjB,ACAA,IAAK,ADAA,CCAA,ADAA,ICAA,ADAA,CCAO,ADAA,GjChBZ,CACe,AkCeCK,ADAAA,CyCrDT,ADN4D,AzE6CnE,AkCc2B,ADAA,CCAA,ADAA,EyCpD3B,EzCoD2B,ACAA,CAAK,ADAA,OjCdrB,CAAA,UAAA,CACF,CAAA,CkCa4C,ADAA,EACvD,ACAA,CDEO,ACAA,WlChBI,CACK,CkCeK,ADAA,AjCfL,CkCgBd,ADAA,OCAO,ADAA,MCAM,ADAA,AjChBC,CACD,CAAA,EkCeK,ADAA,CCAA,ADAA,EjCfL,CAAA,CAAA,AkCeK,ADAA,CCAK,ADAA,AjCbrB,IkCayB,ADAA,CAC7B,ACAA,CDEO,ACAA,WAAWG,ADAAA,CAAuC,ACAA,CAAA,ADAA,CACvD,ACAA,MDAMC,ACAAA,CAAW,ADAA,CAAA,ACAA,IDAA,ACAA,CDAK,ACAA,aDCtB,ACAA,CDAA,ACAA,ODAAA,ACAAA,EAAS,ADAA,ICAKF,ADAAA,CCAAA,ADAAA,iBCAAA,ADAAA,CAAkB,ACAA,CDAE,ACAA,aDAAC,ACAAA,CAAAA,ADAAA,CAAc,ACAA,CAAC,ADAA,CCAC,ADAA,CCAA,ADAA,CACrC,ACAA,AlCXD,GAAA,CiCWK,ACAA,IDAKC,ACAAA,CDAAA,ACAAA,CAAAA,ADAAA,CCAU,ADAA,CAAE,ACAA,IDAM,ACAA,CDAA,ACAA,kBAAmB,ADAA,CAAC,ACAA,CDE9D,ACAA,CDCF,ACAA,6WyCdI,CAAA,CAAA,YAAA,CAAA,WAEA,CAAA,CAAA,eAAA,CACc,eACd,CAAA,MACA,CAAI,CACL,CAAG,uQAckE,CtDkBE,CsDlBA,GRVD,4KQzCzD,qBACR,2RAQA,+XclBG,mrCIET,QAAA,oGAMS,mhBQ+BS,CAAC,GACjB,yV5HnB8D,iR6DVA,KAAK,gHzDiBjE,kK4CfJ,CAAA,kWsCrBY,qXA+BQ,iiBAoDA,oEAMR,iCAIN,aAAA,4DAMK,iDAMR,mEAOiB,uCAIhB,6CAGE,KAAM,oDAKA,+EAIA,CyF5CS,AZCA,A5EwGH,AehBD,AwB5BE,2BxCbjB,KAAA,wCAGkB,C6E3CS,CqC3DsD,ApD4LvD,qB9DpFhB,WAET,6CAKD,OAAA,mGASU,6DAOR,sEAEQ,kBACA,CTiBiB,SSd3B,KAAM,yDAKF,KAAM,wFAUN,KAAA,WACA,C8CuCM,AgB2DC,IAAA,iB9D/FL,wMAeI,yBACN,KAAM,WAET,qCAEQ,CtDFH,AkByDI,AuKnPI,CAAA,iBnI6LG,eACX,CiGrCK,uJjGqDL,ClB6HO,AmHjJW,ajGqBF,2CAIhB,CACE,aAAc,uBAEd,KAAM,C6IrPa,AtEoXF,wBvE5HH,mCAIjB,6DAEK,CpCsDK,IsCsCa,8DFtFxB,KAAA,YAGJ,KAAA,kCAEA,gBAAiB,eACX,iCAKU,eAEM,mCAER,CtDoBK,UsDlBb,CACE,aAAA,4BAEA,CmI5La,IAAA,WnI8Lf,CACE,GmJpNQ,APXA,U5I+NR,8BAEA,EwC8Cc,C4G5TC,AlJoXV,CFtGD,CAAE,ClBmIS,AsKjZI,QpJiRnB,aAAA,qDAKc,QACd,KAAA,sBAGH,8EAGD,KAAA,iBAGE,iCACG,EAAA,CACT,gBAAiB,eACX,YAER,EmI5LI,gGnIuME,CtD8BK,AoC2GA,UkBzIO,CACV,CwJzRW,AxJ0RT,CmGuaY,AqDjsBF,CAAC,WxJ0RG,mDACd,KAAA,oCAIA,CtD6B8B,AgNxRrB,Y1J2PK,CmGwaa,uEnGtarB,ClB0IS,CAAC,CuDHC,AuHxbI,M5JmTxB,ClByIK,A0KlaI,axJ0RI,iEAIjB,0CAKD,OAAQ,eAEU,CTmCK,AiK5TI,A5L0VR,yCoC5Df,CpCiEK,EnDPE,AmDOA,UAAA,kFoC3DF,CwJzRK,CxJ2RV,aAAA,UACA,KAAM,8CAIO,C4JjTK,EhMqXF,AsCkEA,qBFnItB,SAEI,cACgB,CwJzRS,CIxBC,AJwBA,CAAC,AIxBA,GJwBG,CAAC,ExJyRN,EwJzRU,EAAE,CAAC,CxJ0R9B,CpCoEK,C4L9V4B,C5L8V1B,A4L9V2B,CAAC,CAAC,CAAC,GAAG,CAAC,AxJ2R/C,CvFkFO,AmDdF,G4L/V8C,CxJ2R7C,CwJ3R+C,A/O6WxC,C+O7WyC,CAAC,SxJ8RvD,E4JjTU,W5JiTI,eACR,CqCqJO,erCpJb,C4JjTS,EnPqYA,CuFpFL,CAAA,WAEN,cACgB,EEyIE,qBFvIhB,KAAM,EmGwaN,SnGtaF,CwJzRO,AxJ0RL,GoK1XQ,E3P+cF,AmPvYI,Q5JkTV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","ignoreList":[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594]}
# Prompt 7: Add Real-Time Data Fetching and Hooks

## Goal
Create React hooks for fetching and managing on-chain data with proper caching, polling, and error handling.

## Hooks to Create

### 1. `useIntent` - Fetch single intent with live updates

```typescript
// frontend/app/hooks/useIntent.ts
export function useIntent(intentId: number, options?: {
  refetchInterval?: number;
  enabled?: boolean;
}) {
  // Returns:
  // - intent: IntentRecord | null
  // - isLoading: boolean
  // - error: Error | null
  // - refetch: () => void

  // Features:
  // - Auto-refetch every 10s for active intents
  // - No polling for terminal states (filled/cancelled/expired)
  // - Parse full IntentRecord with fills, auction, etc.
}
```

### 2. `useUserIntents` - Fetch all user intents

```typescript
// frontend/app/hooks/useUserIntents.ts
export function useUserIntents(userAddress: string, options?: {
  status?: IntentStatus[];
  limit?: number;
  offset?: number;
}) {
  // Returns:
  // - intents: IntentRecord[]
  // - total: number
  // - isLoading: boolean
  // - refetch: () => void

  // Features:
  // - Pagination support
  // - Filter by status
  // - Sort by creation date (newest first)
}
```

### 3. `useDutchAuctionPrice` - Live Dutch auction price

```typescript
// frontend/app/hooks/useDutchAuctionPrice.ts
export function useDutchAuctionPrice(intentId: number, options?: {
  startPrice: bigint;
  endPrice: bigint;
  startTime: number;
  endTime: number;
}) {
  // Returns:
  // - currentPrice: bigint
  // - pricePercent: number (0-100, how far through decay)
  // - timeRemaining: number (seconds)
  // - isEnded: boolean

  // Features:
  // - Client-side price calculation (no RPC calls)
  // - Updates every second
  // - Uses contract's same linear decay formula
}
```

### 4. `useAuction` - Auction state management

```typescript
// frontend/app/hooks/useAuction.ts
export function useAuction(intentId: number) {
  // Returns:
  // - auction: AuctionState
  // - bids: Bid[]
  // - winner: { hasWinner: boolean; address: string }
  // - timeRemaining: number
  // - currentPrice: bigint | null (for Dutch)
  // - refetch: () => void

  // Features:
  // - Polls during active auction phases
  // - Stops polling when completed/failed
}
```

### 5. `useScheduledIntent` - TWAP/DCA specific data

```typescript
// frontend/app/hooks/useScheduledIntent.ts
export function useScheduledIntent(intentId: number) {
  // Returns:
  // - chunksExecuted: number
  // - totalChunks: number
  // - nextExecution: Date
  // - timeUntilNext: number (seconds)
  // - isReady: boolean (can execute now)
  // - averagePrice: bigint
  // - fills: Fill[]

  // Features:
  // - Countdown to next execution
  // - Calculate average execution price from fills
}
```

### 6. `useProtocolStats` - Global protocol statistics

```typescript
// frontend/app/hooks/useProtocolStats.ts
export function useProtocolStats() {
  // Returns:
  // - totalIntents: number
  // - totalSolvers: number
  // - feeBps: number
  // - totalCollected: bigint
  // - escrowAddress: string

  // Features:
  // - Cache for 60 seconds
  // - Used in footer/dashboard
}
```

### 7. `useSolverInfo` - Solver details and stats

```typescript
// frontend/app/hooks/useSolverInfo.ts
export function useSolverInfo(solverAddress: string) {
  // Returns:
  // - isRegistered: boolean
  // - isActive: boolean
  // - stake: bigint
  // - reputation: number
  // - successfulFills: number
  // - failedFills: number
  // - totalVolume: bigint
  // - lastActive: Date
}
```

## Data Fetching Utilities

### 1. Create `frontend/app/lib/velox/queries.ts`

```typescript
// Batch fetch multiple intents
export async function fetchIntents(
  client: Aptos,
  registryAddr: string,
  intentIds: number[]
): Promise<IntentRecord[]>

// Fetch intents by user with pagination
export async function fetchUserIntents(
  client: Aptos,
  registryAddr: string,
  userAddress: string,
  offset: number,
  limit: number
): Promise<{ intents: IntentRecord[]; total: number }>

// Fetch active intents (for solvers)
export async function fetchActiveIntents(
  client: Aptos,
  registryAddr: string,
  limit: number
): Promise<IntentRecord[]>
```

### 2. Create query key factory

```typescript
// frontend/app/lib/velox/queryKeys.ts
export const veloxKeys = {
  all: ['velox'] as const,
  intents: () => [...veloxKeys.all, 'intents'] as const,
  intent: (id: number) => [...veloxKeys.intents(), id] as const,
  userIntents: (user: string) => [...veloxKeys.intents(), 'user', user] as const,
  auction: (id: number) => [...veloxKeys.all, 'auction', id] as const,
  stats: () => [...veloxKeys.all, 'stats'] as const,
  solver: (addr: string) => [...veloxKeys.all, 'solver', addr] as const,
};
```

## Context Provider Updates

### Update VeloxContext

```typescript
// Add to context:
interface VeloxContextValue {
  registryAddr: string;
  feeConfigAddr: string;
  escrowAddr: string | null;

  // Cached data
  feeBps: number;
  totalIntents: number;

  // Actions
  refetchStats: () => void;
}
```

## Verification
- [ ] useIntent hook with proper polling
- [ ] useDutchAuctionPrice with client-side calculation
- [ ] useScheduledIntent with countdown
- [ ] Batch fetching utilities created
- [ ] Query key factory for cache management
- [ ] Context updated with shared state
- [ ] Proper error boundaries for failed queries
